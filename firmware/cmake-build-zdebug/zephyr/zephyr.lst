
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:

void i2c_dump_msgs(const char *name, const struct i2c_msg *msgs,
		   uint8_t num_msgs, uint16_t addr)
{
	LOG_DBG("I2C msg: %s, addr=%x", name, addr);
	for (unsigned int i = 0; i < num_msgs; i++) {
   0:	80 69 00 20 f9 8b 01 00 43 c8 02 00 b1 8b 01 00     .i. ....C.......
					    gpio_pin_t pin,
					    gpio_flags_t flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	__unused const struct gpio_driver_config *const cfg =
  10:	b1 8b 01 00 b1 8b 01 00 b1 8b 01 00 00 00 00 00     ................
	...

	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
		 "Output needs to be enabled for 'Open Drain', 'Open Source' "
		 "mode to be supported");

	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
  2c:	a5 84 01 00 b1 8b 01 00 00 00 00 00 11 84 01 00     ................
			(flags & GPIO_LINE_OPEN_DRAIN) == 0);

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
  3c:	b1 8b 01 00                                         ....

00000040 <_irq_vector_table>:
		 || (flags & GPIO_OUTPUT) != 0,
		 "Output needs to be enabled to be initialized low or high");

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
  40:	51 86 01 00 71 04 03 00 51 86 01 00 51 86 01 00     Q...q...Q...Q...
		 != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
		 "Output cannot be initialized low and high");

	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
  50:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
	}

	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
  60:	39 04 03 00 51 86 01 00 51 86 01 00 57 04 03 00     9...Q...Q...W...
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
  70:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	return api->pin_configure(port, pin, flags);
  80:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
	__ASSERT((flags & GPIO_INT_MASK) == 0,
  90:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
  a0:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
  b0:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
  c0:	51 86 01 00 51 86 01 00 51 86 01 00 51 86 01 00     Q...Q...Q...Q...
  d0:	51 86 01 00 51 86 01 00 51 86 01 00                 Q...Q...Q...

Disassembly of section text:

000000e0 <__aeabi_drsub>:
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
      e0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
      e4:	e002      	b.n	ec <__adddf3>
      e6:	bf00      	nop

000000e8 <__aeabi_dsub>:
      e8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000000ec <__adddf3>:
      ec:	b530      	push	{r4, r5, lr}
      ee:	ea4f 0441 	mov.w	r4, r1, lsl #1
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
      f2:	ea4f 0543 	mov.w	r5, r3, lsl #1
      f6:	ea94 0f05 	teq	r4, r5
      fa:	bf08      	it	eq
      fc:	ea90 0f02 	teqeq	r0, r2
     100:	bf1f      	itttt	ne
     102:	ea54 0c00 	orrsne.w	ip, r4, r0
     106:	ea55 0c02 	orrsne.w	ip, r5, r2
     10a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
     10e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     112:	f000 80e2 	beq.w	2da <CONFIG_BT_DEVICE_APPEARANCE+0xda>
     116:	ea4f 5454 	mov.w	r4, r4, lsr #21
     11a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
     11e:	bfb8      	it	lt
     120:	426d      	neglt	r5, r5
     122:	dd0c      	ble.n	13e <CONFIG_KOBJECT_TEXT_AREA+0x3e>
     124:	442c      	add	r4, r5
     126:	ea80 0202 	eor.w	r2, r0, r2
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
     12a:	ea81 0303 	eor.w	r3, r1, r3
     12e:	ea82 0000 	eor.w	r0, r2, r0
     132:	ea83 0101 	eor.w	r1, r3, r1
     136:	ea80 0202 	eor.w	r2, r0, r2
     13a:	ea81 0303 	eor.w	r3, r1, r3
     13e:	2d36      	cmp	r5, #54	; 0x36
     140:	bf88      	it	hi
     142:	bd30      	pophi	{r4, r5, pc}
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     144:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     148:	ea4f 3101 	mov.w	r1, r1, lsl #12
     14c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
     150:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
     154:	d002      	beq.n	15c <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x12>
     156:	4240      	negs	r0, r0
     158:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     15c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
     160:	ea4f 3303 	mov.w	r3, r3, lsl #12
     164:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
     168:	d002      	beq.n	170 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x3>
     16a:	4252      	negs	r2, r2
     16c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     170:	ea94 0f05 	teq	r4, r5
     174:	f000 80a7 	beq.w	2c6 <CONFIG_BT_DEVICE_APPEARANCE+0xc6>
     178:	f1a4 0401 	sub.w	r4, r4, #1
     17c:	f1d5 0e20 	rsbs	lr, r5, #32
     180:	db0d      	blt.n	19e <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x31>
     182:	fa02 fc0e 	lsl.w	ip, r2, lr
     186:	fa22 f205 	lsr.w	r2, r2, r5
     18a:	1880      	adds	r0, r0, r2
     18c:	f141 0100 	adc.w	r1, r1, #0
     190:	fa03 f20e 	lsl.w	r2, r3, lr
     194:	1880      	adds	r0, r0, r2
     196:	fa43 f305 	asr.w	r3, r3, r5
     19a:	4159      	adcs	r1, r3
     19c:	e00e      	b.n	1bc <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x4f>
     19e:	f1a5 0520 	sub.w	r5, r5, #32
     1a2:	f10e 0e20 	add.w	lr, lr, #32
     1a6:	2a01      	cmp	r2, #1
     1a8:	fa03 fc0e 	lsl.w	ip, r3, lr
     1ac:	bf28      	it	cs
     1ae:	f04c 0c02 	orrcs.w	ip, ip, #2
     1b2:	fa43 f305 	asr.w	r3, r3, r5
     1b6:	18c0      	adds	r0, r0, r3
     1b8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
     1bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     1c0:	d507      	bpl.n	1d2 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x65>
     1c2:	f04f 0e00 	mov.w	lr, #0
     1c6:	f1dc 0c00 	rsbs	ip, ip, #0
     1ca:	eb7e 0000 	sbcs.w	r0, lr, r0
     1ce:	eb6e 0101 	sbc.w	r1, lr, r1
     1d2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
     1d6:	d31b      	bcc.n	210 <CONFIG_BT_DEVICE_APPEARANCE+0x10>
     1d8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
     1dc:	d30c      	bcc.n	1f8 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x8b>
     1de:	0849      	lsrs	r1, r1, #1
     1e0:	ea5f 0030 	movs.w	r0, r0, rrx
     1e4:	ea4f 0c3c 	mov.w	ip, ip, rrx
     1e8:	f104 0401 	add.w	r4, r4, #1
     1ec:	ea4f 5244 	mov.w	r2, r4, lsl #21
     1f0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
     1f4:	f080 809a 	bcs.w	32c <CONFIG_BT_DEVICE_APPEARANCE+0x12c>
     1f8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     1fc:	bf08      	it	eq
     1fe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     202:	f150 0000 	adcs.w	r0, r0, #0
     206:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     20a:	ea41 0105 	orr.w	r1, r1, r5
     20e:	bd30      	pop	{r4, r5, pc}
     210:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
     214:	4140      	adcs	r0, r0
     216:	eb41 0101 	adc.w	r1, r1, r1
     21a:	3c01      	subs	r4, #1
     21c:	bf28      	it	cs
     21e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
     222:	d2e9      	bcs.n	1f8 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x8b>
     224:	f091 0f00 	teq	r1, #0
     228:	bf04      	itt	eq
     22a:	4601      	moveq	r1, r0
     22c:	2000      	moveq	r0, #0
     22e:	fab1 f381 	clz	r3, r1
     232:	bf08      	it	eq
     234:	3320      	addeq	r3, #32
     236:	f1a3 030b 	sub.w	r3, r3, #11
     23a:	f1b3 0220 	subs.w	r2, r3, #32
     23e:	da0c      	bge.n	25a <CONFIG_BT_DEVICE_APPEARANCE+0x5a>
     240:	320c      	adds	r2, #12
     242:	dd08      	ble.n	256 <CONFIG_BT_DEVICE_APPEARANCE+0x56>
     244:	f102 0c14 	add.w	ip, r2, #20
     248:	f1c2 020c 	rsb	r2, r2, #12
     24c:	fa01 f00c 	lsl.w	r0, r1, ip
     250:	fa21 f102 	lsr.w	r1, r1, r2
     254:	e00c      	b.n	270 <CONFIG_BT_DEVICE_APPEARANCE+0x70>
     256:	f102 0214 	add.w	r2, r2, #20
     25a:	bfd8      	it	le
     25c:	f1c2 0c20 	rsble	ip, r2, #32
     260:	fa01 f102 	lsl.w	r1, r1, r2
     264:	fa20 fc0c 	lsr.w	ip, r0, ip
     268:	bfdc      	itt	le
     26a:	ea41 010c 	orrle.w	r1, r1, ip
     26e:	4090      	lslle	r0, r2
     270:	1ae4      	subs	r4, r4, r3
     272:	bfa2      	ittt	ge
     274:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
     278:	4329      	orrge	r1, r5
     27a:	bd30      	popge	{r4, r5, pc}
     27c:	ea6f 0404 	mvn.w	r4, r4
     280:	3c1f      	subs	r4, #31
     282:	da1c      	bge.n	2be <CONFIG_BT_DEVICE_APPEARANCE+0xbe>
     284:	340c      	adds	r4, #12
     286:	dc0e      	bgt.n	2a6 <CONFIG_BT_DEVICE_APPEARANCE+0xa6>
     288:	f104 0414 	add.w	r4, r4, #20
     28c:	f1c4 0220 	rsb	r2, r4, #32
     290:	fa20 f004 	lsr.w	r0, r0, r4
     294:	fa01 f302 	lsl.w	r3, r1, r2
     298:	ea40 0003 	orr.w	r0, r0, r3
     29c:	fa21 f304 	lsr.w	r3, r1, r4
     2a0:	ea45 0103 	orr.w	r1, r5, r3
     2a4:	bd30      	pop	{r4, r5, pc}
     2a6:	f1c4 040c 	rsb	r4, r4, #12
     2aa:	f1c4 0220 	rsb	r2, r4, #32
     2ae:	fa20 f002 	lsr.w	r0, r0, r2
     2b2:	fa01 f304 	lsl.w	r3, r1, r4
     2b6:	ea40 0003 	orr.w	r0, r0, r3
     2ba:	4629      	mov	r1, r5
     2bc:	bd30      	pop	{r4, r5, pc}
     2be:	fa21 f004 	lsr.w	r0, r1, r4
     2c2:	4629      	mov	r1, r5
     2c4:	bd30      	pop	{r4, r5, pc}
     2c6:	f094 0f00 	teq	r4, #0
     2ca:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
     2ce:	bf06      	itte	eq
     2d0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
     2d4:	3401      	addeq	r4, #1
     2d6:	3d01      	subne	r5, #1
     2d8:	e74e      	b.n	178 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0xb>
     2da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     2de:	bf18      	it	ne
     2e0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     2e4:	d029      	beq.n	33a <CONFIG_BT_DEVICE_APPEARANCE+0x13a>
     2e6:	ea94 0f05 	teq	r4, r5
     2ea:	bf08      	it	eq
     2ec:	ea90 0f02 	teqeq	r0, r2
     2f0:	d005      	beq.n	2fe <CONFIG_BT_DEVICE_APPEARANCE+0xfe>
     2f2:	ea54 0c00 	orrs.w	ip, r4, r0
     2f6:	bf04      	itt	eq
     2f8:	4619      	moveq	r1, r3
     2fa:	4610      	moveq	r0, r2
     2fc:	bd30      	pop	{r4, r5, pc}
     2fe:	ea91 0f03 	teq	r1, r3
     302:	bf1e      	ittt	ne
     304:	2100      	movne	r1, #0
     306:	2000      	movne	r0, #0
     308:	bd30      	popne	{r4, r5, pc}
     30a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
     30e:	d105      	bne.n	31c <CONFIG_BT_DEVICE_APPEARANCE+0x11c>
     310:	0040      	lsls	r0, r0, #1
     312:	4149      	adcs	r1, r1
     314:	bf28      	it	cs
     316:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
     31a:	bd30      	pop	{r4, r5, pc}
     31c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
     320:	bf3c      	itt	cc
     322:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
     326:	bd30      	popcc	{r4, r5, pc}
     328:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     32c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
     330:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     334:	f04f 0000 	mov.w	r0, #0
     338:	bd30      	pop	{r4, r5, pc}
     33a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     33e:	bf1a      	itte	ne
     340:	4619      	movne	r1, r3
     342:	4610      	movne	r0, r2
     344:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
     348:	bf1c      	itt	ne
     34a:	460b      	movne	r3, r1
     34c:	4602      	movne	r2, r0
     34e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     352:	bf06      	itte	eq
     354:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
     358:	ea91 0f03 	teqeq	r1, r3
     35c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
     360:	bd30      	pop	{r4, r5, pc}
     362:	bf00      	nop

00000364 <__aeabi_ui2d>:
     364:	f090 0f00 	teq	r0, #0
     368:	bf04      	itt	eq
     36a:	2100      	moveq	r1, #0
     36c:	4770      	bxeq	lr
     36e:	b530      	push	{r4, r5, lr}
     370:	f44f 6480 	mov.w	r4, #1024	; 0x400
     374:	f104 0432 	add.w	r4, r4, #50	; 0x32
     378:	f04f 0500 	mov.w	r5, #0
     37c:	f04f 0100 	mov.w	r1, #0
     380:	e750      	b.n	224 <CONFIG_BT_DEVICE_APPEARANCE+0x24>
     382:	bf00      	nop

00000384 <__aeabi_i2d>:
     384:	f090 0f00 	teq	r0, #0
     388:	bf04      	itt	eq
     38a:	2100      	moveq	r1, #0
     38c:	4770      	bxeq	lr
     38e:	b530      	push	{r4, r5, lr}
     390:	f44f 6480 	mov.w	r4, #1024	; 0x400
     394:	f104 0432 	add.w	r4, r4, #50	; 0x32
     398:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
     39c:	bf48      	it	mi
     39e:	4240      	negmi	r0, r0
     3a0:	f04f 0100 	mov.w	r1, #0
     3a4:	e73e      	b.n	224 <CONFIG_BT_DEVICE_APPEARANCE+0x24>
     3a6:	bf00      	nop

000003a8 <__aeabi_f2d>:
     3a8:	0042      	lsls	r2, r0, #1
     3aa:	ea4f 01e2 	mov.w	r1, r2, asr #3
     3ae:	ea4f 0131 	mov.w	r1, r1, rrx
     3b2:	ea4f 7002 	mov.w	r0, r2, lsl #28
     3b6:	bf1f      	itttt	ne
     3b8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
     3bc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     3c0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
     3c4:	4770      	bxne	lr
     3c6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
     3ca:	bf08      	it	eq
     3cc:	4770      	bxeq	lr
     3ce:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
     3d2:	bf04      	itt	eq
     3d4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
     3d8:	4770      	bxeq	lr
     3da:	b530      	push	{r4, r5, lr}
     3dc:	f44f 7460 	mov.w	r4, #896	; 0x380
     3e0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     3e4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     3e8:	e71c      	b.n	224 <CONFIG_BT_DEVICE_APPEARANCE+0x24>
     3ea:	bf00      	nop

000003ec <__aeabi_ul2d>:
     3ec:	ea50 0201 	orrs.w	r2, r0, r1
     3f0:	bf08      	it	eq
     3f2:	4770      	bxeq	lr
     3f4:	b530      	push	{r4, r5, lr}
     3f6:	f04f 0500 	mov.w	r5, #0
     3fa:	e00a      	b.n	412 <CONFIG_BT_CTLR_SDC_RX_STACK_SIZE+0x12>

000003fc <__aeabi_l2d>:
     3fc:	ea50 0201 	orrs.w	r2, r0, r1
     400:	bf08      	it	eq
     402:	4770      	bxeq	lr
     404:	b530      	push	{r4, r5, lr}
     406:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
     40a:	d502      	bpl.n	412 <CONFIG_BT_CTLR_SDC_RX_STACK_SIZE+0x12>
     40c:	4240      	negs	r0, r0
     40e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     412:	f44f 6480 	mov.w	r4, #1024	; 0x400
     416:	f104 0432 	add.w	r4, r4, #50	; 0x32
     41a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
     41e:	f43f aed8 	beq.w	1d2 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x65>
     422:	f04f 0203 	mov.w	r2, #3
     426:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     42a:	bf18      	it	ne
     42c:	3203      	addne	r2, #3
     42e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     432:	bf18      	it	ne
     434:	3203      	addne	r2, #3
     436:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
     43a:	f1c2 0320 	rsb	r3, r2, #32
     43e:	fa00 fc03 	lsl.w	ip, r0, r3
     442:	fa20 f002 	lsr.w	r0, r0, r2
     446:	fa01 fe03 	lsl.w	lr, r1, r3
     44a:	ea40 000e 	orr.w	r0, r0, lr
     44e:	fa21 f102 	lsr.w	r1, r1, r2
     452:	4414      	add	r4, r2
     454:	e6bd      	b.n	1d2 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x65>
     456:	bf00      	nop

00000458 <__aeabi_dmul>:
     458:	b570      	push	{r4, r5, r6, lr}
     45a:	f04f 0cff 	mov.w	ip, #255	; 0xff
     45e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     462:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     466:	bf1d      	ittte	ne
     468:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     46c:	ea94 0f0c 	teqne	r4, ip
     470:	ea95 0f0c 	teqne	r5, ip
     474:	f000 f8de 	bleq	634 <CONFIG_BT_HCI_TX_STACK_SIZE+0x34>
     478:	442c      	add	r4, r5
     47a:	ea81 0603 	eor.w	r6, r1, r3
     47e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
     482:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
     486:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
     48a:	bf18      	it	ne
     48c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
     490:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     494:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
     498:	d038      	beq.n	50c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x24>
     49a:	fba0 ce02 	umull	ip, lr, r0, r2
     49e:	f04f 0500 	mov.w	r5, #0
     4a2:	fbe1 e502 	umlal	lr, r5, r1, r2
     4a6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
     4aa:	fbe0 e503 	umlal	lr, r5, r0, r3
     4ae:	f04f 0600 	mov.w	r6, #0
     4b2:	fbe1 5603 	umlal	r5, r6, r1, r3
     4b6:	f09c 0f00 	teq	ip, #0
     4ba:	bf18      	it	ne
     4bc:	f04e 0e01 	orrne.w	lr, lr, #1
     4c0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
     4c4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
     4c8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
     4cc:	d204      	bcs.n	4d8 <__aeabi_dmul+0x80>
     4ce:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
     4d2:	416d      	adcs	r5, r5
     4d4:	eb46 0606 	adc.w	r6, r6, r6
     4d8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
     4dc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
     4e0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
     4e4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
     4e8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
     4ec:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     4f0:	bf88      	it	hi
     4f2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     4f6:	d81e      	bhi.n	536 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x22>
     4f8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
     4fc:	bf08      	it	eq
     4fe:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
     502:	f150 0000 	adcs.w	r0, r0, #0
     506:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     50a:	bd70      	pop	{r4, r5, r6, pc}
     50c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
     510:	ea46 0101 	orr.w	r1, r6, r1
     514:	ea40 0002 	orr.w	r0, r0, r2
     518:	ea81 0103 	eor.w	r1, r1, r3
     51c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
     520:	bfc2      	ittt	gt
     522:	ebd4 050c 	rsbsgt	r5, r4, ip
     526:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     52a:	bd70      	popgt	{r4, r5, r6, pc}
     52c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     530:	f04f 0e00 	mov.w	lr, #0
     534:	3c01      	subs	r4, #1
     536:	f300 80ab 	bgt.w	690 <CONFIG_BT_HCI_TX_STACK_SIZE+0x90>
     53a:	f114 0f36 	cmn.w	r4, #54	; 0x36
     53e:	bfde      	ittt	le
     540:	2000      	movle	r0, #0
     542:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
     546:	bd70      	pople	{r4, r5, r6, pc}
     548:	f1c4 0400 	rsb	r4, r4, #0
     54c:	3c20      	subs	r4, #32
     54e:	da35      	bge.n	5bc <CONFIG_BT_LONG_WQ_STACK_SIZE+0xa8>
     550:	340c      	adds	r4, #12
     552:	dc1b      	bgt.n	58c <CONFIG_BT_LONG_WQ_STACK_SIZE+0x78>
     554:	f104 0414 	add.w	r4, r4, #20
     558:	f1c4 0520 	rsb	r5, r4, #32
     55c:	fa00 f305 	lsl.w	r3, r0, r5
     560:	fa20 f004 	lsr.w	r0, r0, r4
     564:	fa01 f205 	lsl.w	r2, r1, r5
     568:	ea40 0002 	orr.w	r0, r0, r2
     56c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
     570:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     574:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     578:	fa21 f604 	lsr.w	r6, r1, r4
     57c:	eb42 0106 	adc.w	r1, r2, r6
     580:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     584:	bf08      	it	eq
     586:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     58a:	bd70      	pop	{r4, r5, r6, pc}
     58c:	f1c4 040c 	rsb	r4, r4, #12
     590:	f1c4 0520 	rsb	r5, r4, #32
     594:	fa00 f304 	lsl.w	r3, r0, r4
     598:	fa20 f005 	lsr.w	r0, r0, r5
     59c:	fa01 f204 	lsl.w	r2, r1, r4
     5a0:	ea40 0002 	orr.w	r0, r0, r2
     5a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     5a8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     5ac:	f141 0100 	adc.w	r1, r1, #0
     5b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     5b4:	bf08      	it	eq
     5b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     5ba:	bd70      	pop	{r4, r5, r6, pc}
     5bc:	f1c4 0520 	rsb	r5, r4, #32
     5c0:	fa00 f205 	lsl.w	r2, r0, r5
     5c4:	ea4e 0e02 	orr.w	lr, lr, r2
     5c8:	fa20 f304 	lsr.w	r3, r0, r4
     5cc:	fa01 f205 	lsl.w	r2, r1, r5
     5d0:	ea43 0302 	orr.w	r3, r3, r2
     5d4:	fa21 f004 	lsr.w	r0, r1, r4
     5d8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     5dc:	fa21 f204 	lsr.w	r2, r1, r4
     5e0:	ea20 0002 	bic.w	r0, r0, r2
     5e4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
     5e8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     5ec:	bf08      	it	eq
     5ee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     5f2:	bd70      	pop	{r4, r5, r6, pc}
     5f4:	f094 0f00 	teq	r4, #0
     5f8:	d10f      	bne.n	61a <CONFIG_BT_HCI_TX_STACK_SIZE+0x1a>
     5fa:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
     5fe:	0040      	lsls	r0, r0, #1
     600:	eb41 0101 	adc.w	r1, r1, r1
     604:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     608:	bf08      	it	eq
     60a:	3c01      	subeq	r4, #1
     60c:	d0f7      	beq.n	5fe <CONFIG_BT_COMPANY_ID+0xd>
     60e:	ea41 0106 	orr.w	r1, r1, r6
     612:	f095 0f00 	teq	r5, #0
     616:	bf18      	it	ne
     618:	4770      	bxne	lr
     61a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
     61e:	0052      	lsls	r2, r2, #1
     620:	eb43 0303 	adc.w	r3, r3, r3
     624:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
     628:	bf08      	it	eq
     62a:	3d01      	subeq	r5, #1
     62c:	d0f7      	beq.n	61e <CONFIG_BT_HCI_TX_STACK_SIZE+0x1e>
     62e:	ea43 0306 	orr.w	r3, r3, r6
     632:	4770      	bx	lr
     634:	ea94 0f0c 	teq	r4, ip
     638:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
     63c:	bf18      	it	ne
     63e:	ea95 0f0c 	teqne	r5, ip
     642:	d00c      	beq.n	65e <CONFIG_BT_HCI_TX_STACK_SIZE+0x5e>
     644:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     648:	bf18      	it	ne
     64a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     64e:	d1d1      	bne.n	5f4 <CONFIG_BT_COMPANY_ID+0x3>
     650:	ea81 0103 	eor.w	r1, r1, r3
     654:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     658:	f04f 0000 	mov.w	r0, #0
     65c:	bd70      	pop	{r4, r5, r6, pc}
     65e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     662:	bf06      	itte	eq
     664:	4610      	moveq	r0, r2
     666:	4619      	moveq	r1, r3
     668:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     66c:	d019      	beq.n	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     66e:	ea94 0f0c 	teq	r4, ip
     672:	d102      	bne.n	67a <CONFIG_BT_HCI_TX_STACK_SIZE+0x7a>
     674:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
     678:	d113      	bne.n	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     67a:	ea95 0f0c 	teq	r5, ip
     67e:	d105      	bne.n	68c <CONFIG_BT_HCI_TX_STACK_SIZE+0x8c>
     680:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
     684:	bf1c      	itt	ne
     686:	4610      	movne	r0, r2
     688:	4619      	movne	r1, r3
     68a:	d10a      	bne.n	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     68c:	ea81 0103 	eor.w	r1, r1, r3
     690:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
     694:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
     698:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     69c:	f04f 0000 	mov.w	r0, #0
     6a0:	bd70      	pop	{r4, r5, r6, pc}
     6a2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
     6a6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
     6aa:	bd70      	pop	{r4, r5, r6, pc}

000006ac <__aeabi_ddiv>:
     6ac:	b570      	push	{r4, r5, r6, lr}
     6ae:	f04f 0cff 	mov.w	ip, #255	; 0xff
     6b2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     6b6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     6ba:	bf1d      	ittte	ne
     6bc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     6c0:	ea94 0f0c 	teqne	r4, ip
     6c4:	ea95 0f0c 	teqne	r5, ip
     6c8:	f000 f8a7 	bleq	81a <CONFIG_ISR_STACK_SIZE+0x1a>
     6cc:	eba4 0405 	sub.w	r4, r4, r5
     6d0:	ea81 0e03 	eor.w	lr, r1, r3
     6d4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
     6d8:	ea4f 3101 	mov.w	r1, r1, lsl #12
     6dc:	f000 8088 	beq.w	7f0 <__aeabi_ddiv+0x144>
     6e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
     6e4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
     6e8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
     6ec:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
     6f0:	ea4f 2202 	mov.w	r2, r2, lsl #8
     6f4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
     6f8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
     6fc:	ea4f 2600 	mov.w	r6, r0, lsl #8
     700:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
     704:	429d      	cmp	r5, r3
     706:	bf08      	it	eq
     708:	4296      	cmpeq	r6, r2
     70a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
     70e:	f504 7440 	add.w	r4, r4, #768	; 0x300
     712:	d202      	bcs.n	71a <__aeabi_ddiv+0x6e>
     714:	085b      	lsrs	r3, r3, #1
     716:	ea4f 0232 	mov.w	r2, r2, rrx
     71a:	1ab6      	subs	r6, r6, r2
     71c:	eb65 0503 	sbc.w	r5, r5, r3
     720:	085b      	lsrs	r3, r3, #1
     722:	ea4f 0232 	mov.w	r2, r2, rrx
     726:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     72a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
     72e:	ebb6 0e02 	subs.w	lr, r6, r2
     732:	eb75 0e03 	sbcs.w	lr, r5, r3
     736:	bf22      	ittt	cs
     738:	1ab6      	subcs	r6, r6, r2
     73a:	4675      	movcs	r5, lr
     73c:	ea40 000c 	orrcs.w	r0, r0, ip
     740:	085b      	lsrs	r3, r3, #1
     742:	ea4f 0232 	mov.w	r2, r2, rrx
     746:	ebb6 0e02 	subs.w	lr, r6, r2
     74a:	eb75 0e03 	sbcs.w	lr, r5, r3
     74e:	bf22      	ittt	cs
     750:	1ab6      	subcs	r6, r6, r2
     752:	4675      	movcs	r5, lr
     754:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
     758:	085b      	lsrs	r3, r3, #1
     75a:	ea4f 0232 	mov.w	r2, r2, rrx
     75e:	ebb6 0e02 	subs.w	lr, r6, r2
     762:	eb75 0e03 	sbcs.w	lr, r5, r3
     766:	bf22      	ittt	cs
     768:	1ab6      	subcs	r6, r6, r2
     76a:	4675      	movcs	r5, lr
     76c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
     770:	085b      	lsrs	r3, r3, #1
     772:	ea4f 0232 	mov.w	r2, r2, rrx
     776:	ebb6 0e02 	subs.w	lr, r6, r2
     77a:	eb75 0e03 	sbcs.w	lr, r5, r3
     77e:	bf22      	ittt	cs
     780:	1ab6      	subcs	r6, r6, r2
     782:	4675      	movcs	r5, lr
     784:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
     788:	ea55 0e06 	orrs.w	lr, r5, r6
     78c:	d018      	beq.n	7c0 <__aeabi_ddiv+0x114>
     78e:	ea4f 1505 	mov.w	r5, r5, lsl #4
     792:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
     796:	ea4f 1606 	mov.w	r6, r6, lsl #4
     79a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     79e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
     7a2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
     7a6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
     7aa:	d1c0      	bne.n	72e <__aeabi_ddiv+0x82>
     7ac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     7b0:	d10b      	bne.n	7ca <__aeabi_ddiv+0x11e>
     7b2:	ea41 0100 	orr.w	r1, r1, r0
     7b6:	f04f 0000 	mov.w	r0, #0
     7ba:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
     7be:	e7b6      	b.n	72e <__aeabi_ddiv+0x82>
     7c0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     7c4:	bf04      	itt	eq
     7c6:	4301      	orreq	r1, r0
     7c8:	2000      	moveq	r0, #0
     7ca:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     7ce:	bf88      	it	hi
     7d0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     7d4:	f63f aeaf 	bhi.w	536 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x22>
     7d8:	ebb5 0c03 	subs.w	ip, r5, r3
     7dc:	bf04      	itt	eq
     7de:	ebb6 0c02 	subseq.w	ip, r6, r2
     7e2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     7e6:	f150 0000 	adcs.w	r0, r0, #0
     7ea:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     7ee:	bd70      	pop	{r4, r5, r6, pc}
     7f0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
     7f4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
     7f8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
     7fc:	bfc2      	ittt	gt
     7fe:	ebd4 050c 	rsbsgt	r5, r4, ip
     802:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     806:	bd70      	popgt	{r4, r5, r6, pc}
     808:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     80c:	f04f 0e00 	mov.w	lr, #0
     810:	3c01      	subs	r4, #1
     812:	e690      	b.n	536 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x22>
     814:	ea45 0e06 	orr.w	lr, r5, r6
     818:	e68d      	b.n	536 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x22>
     81a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
     81e:	ea94 0f0c 	teq	r4, ip
     822:	bf08      	it	eq
     824:	ea95 0f0c 	teqeq	r5, ip
     828:	f43f af3b 	beq.w	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     82c:	ea94 0f0c 	teq	r4, ip
     830:	d10a      	bne.n	848 <CONFIG_ISR_STACK_SIZE+0x48>
     832:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     836:	f47f af34 	bne.w	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     83a:	ea95 0f0c 	teq	r5, ip
     83e:	f47f af25 	bne.w	68c <CONFIG_BT_HCI_TX_STACK_SIZE+0x8c>
     842:	4610      	mov	r0, r2
     844:	4619      	mov	r1, r3
     846:	e72c      	b.n	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     848:	ea95 0f0c 	teq	r5, ip
     84c:	d106      	bne.n	85c <CONFIG_ISR_STACK_SIZE+0x5c>
     84e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
     852:	f43f aefd 	beq.w	650 <CONFIG_BT_HCI_TX_STACK_SIZE+0x50>
     856:	4610      	mov	r0, r2
     858:	4619      	mov	r1, r3
     85a:	e722      	b.n	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>
     85c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
     860:	bf18      	it	ne
     862:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
     866:	f47f aec5 	bne.w	5f4 <CONFIG_BT_COMPANY_ID+0x3>
     86a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
     86e:	f47f af0d 	bne.w	68c <CONFIG_BT_HCI_TX_STACK_SIZE+0x8c>
     872:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
     876:	f47f aeeb 	bne.w	650 <CONFIG_BT_HCI_TX_STACK_SIZE+0x50>
     87a:	e712      	b.n	6a2 <CONFIG_BT_HCI_TX_STACK_SIZE+0xa2>

0000087c <__aeabi_d2f>:
     87c:	ea4f 0241 	mov.w	r2, r1, lsl #1
     880:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
     884:	bf24      	itt	cs
     886:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
     88a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
     88e:	d90d      	bls.n	8ac <__aeabi_d2f+0x30>
     890:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
     894:	ea4f 02c0 	mov.w	r2, r0, lsl #3
     898:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
     89c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
     8a0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
     8a4:	bf08      	it	eq
     8a6:	f020 0001 	biceq.w	r0, r0, #1
     8aa:	4770      	bx	lr
     8ac:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
     8b0:	d121      	bne.n	8f6 <__aeabi_d2f+0x7a>
     8b2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
     8b6:	bfbc      	itt	lt
     8b8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
     8bc:	4770      	bxlt	lr
     8be:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     8c2:	ea4f 5252 	mov.w	r2, r2, lsr #21
     8c6:	f1c2 0218 	rsb	r2, r2, #24
     8ca:	f1c2 0c20 	rsb	ip, r2, #32
     8ce:	fa10 f30c 	lsls.w	r3, r0, ip
     8d2:	fa20 f002 	lsr.w	r0, r0, r2
     8d6:	bf18      	it	ne
     8d8:	f040 0001 	orrne.w	r0, r0, #1
     8dc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
     8e0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
     8e4:	fa03 fc0c 	lsl.w	ip, r3, ip
     8e8:	ea40 000c 	orr.w	r0, r0, ip
     8ec:	fa23 f302 	lsr.w	r3, r3, r2
     8f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
     8f4:	e7cc      	b.n	890 <__aeabi_d2f+0x14>
     8f6:	ea7f 5362 	mvns.w	r3, r2, asr #21
     8fa:	d107      	bne.n	90c <__aeabi_d2f+0x90>
     8fc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
     900:	bf1e      	ittt	ne
     902:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
     906:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
     90a:	4770      	bxne	lr
     90c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
     910:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     914:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     918:	4770      	bx	lr
     91a:	bf00      	nop

0000091c <__aeabi_frsub>:
     91c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
     920:	e002      	b.n	928 <__addsf3>
     922:	bf00      	nop

00000924 <__aeabi_fsub>:
     924:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00000928 <__addsf3>:
     928:	0042      	lsls	r2, r0, #1
     92a:	bf1f      	itttt	ne
     92c:	ea5f 0341 	movsne.w	r3, r1, lsl #1
     930:	ea92 0f03 	teqne	r2, r3
     934:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
     938:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     93c:	d06a      	beq.n	a14 <__addsf3+0xec>
     93e:	ea4f 6212 	mov.w	r2, r2, lsr #24
     942:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
     946:	bfc1      	itttt	gt
     948:	18d2      	addgt	r2, r2, r3
     94a:	4041      	eorgt	r1, r0
     94c:	4048      	eorgt	r0, r1
     94e:	4041      	eorgt	r1, r0
     950:	bfb8      	it	lt
     952:	425b      	neglt	r3, r3
     954:	2b19      	cmp	r3, #25
     956:	bf88      	it	hi
     958:	4770      	bxhi	lr
     95a:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
     95e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     962:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     966:	bf18      	it	ne
     968:	4240      	negne	r0, r0
     96a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     96e:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
     972:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
     976:	bf18      	it	ne
     978:	4249      	negne	r1, r1
     97a:	ea92 0f03 	teq	r2, r3
     97e:	d03f      	beq.n	a00 <__addsf3+0xd8>
     980:	f1a2 0201 	sub.w	r2, r2, #1
     984:	fa41 fc03 	asr.w	ip, r1, r3
     988:	eb10 000c 	adds.w	r0, r0, ip
     98c:	f1c3 0320 	rsb	r3, r3, #32
     990:	fa01 f103 	lsl.w	r1, r1, r3
     994:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     998:	d502      	bpl.n	9a0 <__addsf3+0x78>
     99a:	4249      	negs	r1, r1
     99c:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
     9a0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
     9a4:	d313      	bcc.n	9ce <__addsf3+0xa6>
     9a6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
     9aa:	d306      	bcc.n	9ba <__addsf3+0x92>
     9ac:	0840      	lsrs	r0, r0, #1
     9ae:	ea4f 0131 	mov.w	r1, r1, rrx
     9b2:	f102 0201 	add.w	r2, r2, #1
     9b6:	2afe      	cmp	r2, #254	; 0xfe
     9b8:	d251      	bcs.n	a5e <__addsf3+0x136>
     9ba:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
     9be:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     9c2:	bf08      	it	eq
     9c4:	f020 0001 	biceq.w	r0, r0, #1
     9c8:	ea40 0003 	orr.w	r0, r0, r3
     9cc:	4770      	bx	lr
     9ce:	0049      	lsls	r1, r1, #1
     9d0:	eb40 0000 	adc.w	r0, r0, r0
     9d4:	3a01      	subs	r2, #1
     9d6:	bf28      	it	cs
     9d8:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
     9dc:	d2ed      	bcs.n	9ba <__addsf3+0x92>
     9de:	fab0 fc80 	clz	ip, r0
     9e2:	f1ac 0c08 	sub.w	ip, ip, #8
     9e6:	ebb2 020c 	subs.w	r2, r2, ip
     9ea:	fa00 f00c 	lsl.w	r0, r0, ip
     9ee:	bfaa      	itet	ge
     9f0:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
     9f4:	4252      	neglt	r2, r2
     9f6:	4318      	orrge	r0, r3
     9f8:	bfbc      	itt	lt
     9fa:	40d0      	lsrlt	r0, r2
     9fc:	4318      	orrlt	r0, r3
     9fe:	4770      	bx	lr
     a00:	f092 0f00 	teq	r2, #0
     a04:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
     a08:	bf06      	itte	eq
     a0a:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
     a0e:	3201      	addeq	r2, #1
     a10:	3b01      	subne	r3, #1
     a12:	e7b5      	b.n	980 <__addsf3+0x58>
     a14:	ea4f 0341 	mov.w	r3, r1, lsl #1
     a18:	ea7f 6c22 	mvns.w	ip, r2, asr #24
     a1c:	bf18      	it	ne
     a1e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     a22:	d021      	beq.n	a68 <__addsf3+0x140>
     a24:	ea92 0f03 	teq	r2, r3
     a28:	d004      	beq.n	a34 <__addsf3+0x10c>
     a2a:	f092 0f00 	teq	r2, #0
     a2e:	bf08      	it	eq
     a30:	4608      	moveq	r0, r1
     a32:	4770      	bx	lr
     a34:	ea90 0f01 	teq	r0, r1
     a38:	bf1c      	itt	ne
     a3a:	2000      	movne	r0, #0
     a3c:	4770      	bxne	lr
     a3e:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
     a42:	d104      	bne.n	a4e <__addsf3+0x126>
     a44:	0040      	lsls	r0, r0, #1
     a46:	bf28      	it	cs
     a48:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
     a4c:	4770      	bx	lr
     a4e:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
     a52:	bf3c      	itt	cc
     a54:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
     a58:	4770      	bxcc	lr
     a5a:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     a5e:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
     a62:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     a66:	4770      	bx	lr
     a68:	ea7f 6222 	mvns.w	r2, r2, asr #24
     a6c:	bf16      	itet	ne
     a6e:	4608      	movne	r0, r1
     a70:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
     a74:	4601      	movne	r1, r0
     a76:	0242      	lsls	r2, r0, #9
     a78:	bf06      	itte	eq
     a7a:	ea5f 2341 	movseq.w	r3, r1, lsl #9
     a7e:	ea90 0f01 	teqeq	r0, r1
     a82:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
     a86:	4770      	bx	lr

00000a88 <__aeabi_ui2f>:
     a88:	f04f 0300 	mov.w	r3, #0
     a8c:	e004      	b.n	a98 <__aeabi_i2f+0x8>
     a8e:	bf00      	nop

00000a90 <__aeabi_i2f>:
     a90:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
     a94:	bf48      	it	mi
     a96:	4240      	negmi	r0, r0
     a98:	ea5f 0c00 	movs.w	ip, r0
     a9c:	bf08      	it	eq
     a9e:	4770      	bxeq	lr
     aa0:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
     aa4:	4601      	mov	r1, r0
     aa6:	f04f 0000 	mov.w	r0, #0
     aaa:	e01c      	b.n	ae6 <__aeabi_l2f+0x2a>

00000aac <__aeabi_ul2f>:
     aac:	ea50 0201 	orrs.w	r2, r0, r1
     ab0:	bf08      	it	eq
     ab2:	4770      	bxeq	lr
     ab4:	f04f 0300 	mov.w	r3, #0
     ab8:	e00a      	b.n	ad0 <__aeabi_l2f+0x14>
     aba:	bf00      	nop

00000abc <__aeabi_l2f>:
     abc:	ea50 0201 	orrs.w	r2, r0, r1
     ac0:	bf08      	it	eq
     ac2:	4770      	bxeq	lr
     ac4:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
     ac8:	d502      	bpl.n	ad0 <__aeabi_l2f+0x14>
     aca:	4240      	negs	r0, r0
     acc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     ad0:	ea5f 0c01 	movs.w	ip, r1
     ad4:	bf02      	ittt	eq
     ad6:	4684      	moveq	ip, r0
     ad8:	4601      	moveq	r1, r0
     ada:	2000      	moveq	r0, #0
     adc:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
     ae0:	bf08      	it	eq
     ae2:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
     ae6:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
     aea:	fabc f28c 	clz	r2, ip
     aee:	3a08      	subs	r2, #8
     af0:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
     af4:	db10      	blt.n	b18 <__aeabi_l2f+0x5c>
     af6:	fa01 fc02 	lsl.w	ip, r1, r2
     afa:	4463      	add	r3, ip
     afc:	fa00 fc02 	lsl.w	ip, r0, r2
     b00:	f1c2 0220 	rsb	r2, r2, #32
     b04:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     b08:	fa20 f202 	lsr.w	r2, r0, r2
     b0c:	eb43 0002 	adc.w	r0, r3, r2
     b10:	bf08      	it	eq
     b12:	f020 0001 	biceq.w	r0, r0, #1
     b16:	4770      	bx	lr
     b18:	f102 0220 	add.w	r2, r2, #32
     b1c:	fa01 fc02 	lsl.w	ip, r1, r2
     b20:	f1c2 0220 	rsb	r2, r2, #32
     b24:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
     b28:	fa21 f202 	lsr.w	r2, r1, r2
     b2c:	eb43 0002 	adc.w	r0, r3, r2
     b30:	bf08      	it	eq
     b32:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
     b36:	4770      	bx	lr

00000b38 <__aeabi_ldivmod>:
     b38:	b97b      	cbnz	r3, b5a <__aeabi_ldivmod+0x22>
     b3a:	b972      	cbnz	r2, b5a <__aeabi_ldivmod+0x22>
     b3c:	2900      	cmp	r1, #0
     b3e:	bfbe      	ittt	lt
     b40:	2000      	movlt	r0, #0
     b42:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
     b46:	e006      	blt.n	b56 <__aeabi_ldivmod+0x1e>
     b48:	bf08      	it	eq
     b4a:	2800      	cmpeq	r0, #0
     b4c:	bf1c      	itt	ne
     b4e:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
     b52:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     b56:	f000 b997 	b.w	e88 <__aeabi_idiv0>
     b5a:	f1ad 0c08 	sub.w	ip, sp, #8
     b5e:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     b62:	2900      	cmp	r1, #0
     b64:	db09      	blt.n	b7a <__aeabi_ldivmod+0x42>
     b66:	2b00      	cmp	r3, #0
     b68:	db1a      	blt.n	ba0 <__aeabi_ldivmod+0x68>
     b6a:	f00b ff3f 	bl	c9ec <__udivmoddi4>
     b6e:	f8dd e004 	ldr.w	lr, [sp, #4]
     b72:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     b76:	b004      	add	sp, #16
     b78:	4770      	bx	lr
     b7a:	4240      	negs	r0, r0
     b7c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     b80:	2b00      	cmp	r3, #0
     b82:	db1b      	blt.n	bbc <__aeabi_ldivmod+0x84>
     b84:	f00b ff32 	bl	c9ec <__udivmoddi4>
     b88:	f8dd e004 	ldr.w	lr, [sp, #4]
     b8c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     b90:	b004      	add	sp, #16
     b92:	4240      	negs	r0, r0
     b94:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     b98:	4252      	negs	r2, r2
     b9a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     b9e:	4770      	bx	lr
     ba0:	4252      	negs	r2, r2
     ba2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     ba6:	f00b ff21 	bl	c9ec <__udivmoddi4>
     baa:	f8dd e004 	ldr.w	lr, [sp, #4]
     bae:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     bb2:	b004      	add	sp, #16
     bb4:	4240      	negs	r0, r0
     bb6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     bba:	4770      	bx	lr
     bbc:	4252      	negs	r2, r2
     bbe:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     bc2:	f00b ff13 	bl	c9ec <__udivmoddi4>
     bc6:	f8dd e004 	ldr.w	lr, [sp, #4]
     bca:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     bce:	b004      	add	sp, #16
     bd0:	4252      	negs	r2, r2
     bd2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     bd6:	4770      	bx	lr

00000bd8 <__aeabi_uldivmod>:
     bd8:	b953      	cbnz	r3, bf0 <__aeabi_uldivmod+0x18>
     bda:	b94a      	cbnz	r2, bf0 <__aeabi_uldivmod+0x18>
     bdc:	2900      	cmp	r1, #0
     bde:	bf08      	it	eq
     be0:	2800      	cmpeq	r0, #0
     be2:	bf1c      	itt	ne
     be4:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     be8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     bec:	f000 b94c 	b.w	e88 <__aeabi_idiv0>
     bf0:	f1ad 0c08 	sub.w	ip, sp, #8
     bf4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     bf8:	f00b fef8 	bl	c9ec <__udivmoddi4>
     bfc:	f8dd e004 	ldr.w	lr, [sp, #4]
     c00:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     c04:	b004      	add	sp, #16
     c06:	4770      	bx	lr

00000c08 <__mulsc3>:
     c08:	ee20 4a01 	vmul.f32	s8, s0, s2
     c0c:	ee60 4aa1 	vmul.f32	s9, s1, s3
     c10:	ee20 5a21 	vmul.f32	s10, s0, s3
     c14:	ee34 7a64 	vsub.f32	s14, s8, s9
     c18:	ee61 5a20 	vmul.f32	s11, s2, s1
     c1c:	eeb4 7a47 	vcmp.f32	s14, s14
     c20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c24:	ee75 6a25 	vadd.f32	s13, s10, s11
     c28:	f1c0 80c5 	bvc.w	db6 <__mulsc3+0x1ae>
     c2c:	eef4 6a66 	vcmp.f32	s13, s13
     c30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c34:	f1c0 80bf 	bvc.w	db6 <__mulsc3+0x1ae>
     c38:	eddf 7a8f 	vldr	s15, [pc, #572]	; e78 <__data_size+0x7b>
     c3c:	eeb0 6ac0 	vabs.f32	s12, s0
     c40:	eeb4 6a67 	vcmp.f32	s12, s15
     c44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c48:	eef0 3ae0 	vabs.f32	s7, s1
     c4c:	dc04      	bgt.n	c58 <__mulsc3+0x50>
     c4e:	eef4 3a67 	vcmp.f32	s7, s15
     c52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c56:	dd49      	ble.n	cec <__mulsc3+0xe4>
     c58:	eeb4 6a67 	vcmp.f32	s12, s15
     c5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c60:	bfcc      	ite	gt
     c62:	2301      	movgt	r3, #1
     c64:	2300      	movle	r3, #0
     c66:	ee06 3a10 	vmov	s12, r3
     c6a:	ee10 3a10 	vmov	r3, s0
     c6e:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     c72:	2b00      	cmp	r3, #0
     c74:	eeb0 6ac6 	vabs.f32	s12, s12
     c78:	eef4 3a67 	vcmp.f32	s7, s15
     c7c:	bfb8      	it	lt
     c7e:	eeb1 6a46 	vneglt.f32	s12, s12
     c82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     c86:	bfcc      	ite	gt
     c88:	2301      	movgt	r3, #1
     c8a:	2300      	movle	r3, #0
     c8c:	eeb0 0a46 	vmov.f32	s0, s12
     c90:	ee06 3a10 	vmov	s12, r3
     c94:	ee10 3a90 	vmov	r3, s1
     c98:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
     c9c:	2b00      	cmp	r3, #0
     c9e:	eeb0 6ac6 	vabs.f32	s12, s12
     ca2:	eeb4 1a41 	vcmp.f32	s2, s2
     ca6:	bfb8      	it	lt
     ca8:	eeb1 6a46 	vneglt.f32	s12, s12
     cac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     cb0:	eef0 0a46 	vmov.f32	s1, s12
     cb4:	d709      	bvc.n	cca <__mulsc3+0xc2>
     cb6:	ee11 3a10 	vmov	r3, s2
     cba:	ed9f 6a70 	vldr	s12, [pc, #448]	; e7c <__data_size+0x7f>
     cbe:	ed9f 1a70 	vldr	s2, [pc, #448]	; e80 <__data_size+0x83>
     cc2:	2b00      	cmp	r3, #0
     cc4:	bfa8      	it	ge
     cc6:	eeb0 1a46 	vmovge.f32	s2, s12
     cca:	eef4 1a61 	vcmp.f32	s3, s3
     cce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     cd2:	d709      	bvc.n	ce8 <__mulsc3+0xe0>
     cd4:	ee11 3a90 	vmov	r3, s3
     cd8:	ed9f 6a68 	vldr	s12, [pc, #416]	; e7c <__data_size+0x7f>
     cdc:	eddf 1a68 	vldr	s3, [pc, #416]	; e80 <__data_size+0x83>
     ce0:	2b00      	cmp	r3, #0
     ce2:	bfa8      	it	ge
     ce4:	eef0 1a46 	vmovge.f32	s3, s12
     ce8:	2301      	movs	r3, #1
     cea:	e000      	b.n	cee <__mulsc3+0xe6>
     cec:	2300      	movs	r3, #0
     cee:	eef0 3ac1 	vabs.f32	s7, s2
     cf2:	eef4 3a67 	vcmp.f32	s7, s15
     cf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     cfa:	eeb0 6ae1 	vabs.f32	s12, s3
     cfe:	dc04      	bgt.n	d0a <__mulsc3+0x102>
     d00:	eeb4 6a67 	vcmp.f32	s12, s15
     d04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d08:	dd5a      	ble.n	dc0 <__mulsc3+0x1b8>
     d0a:	eef4 3a67 	vcmp.f32	s7, s15
     d0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d12:	bfcc      	ite	gt
     d14:	2301      	movgt	r3, #1
     d16:	2300      	movle	r3, #0
     d18:	ee07 3a10 	vmov	s14, r3
     d1c:	ee11 3a10 	vmov	r3, s2
     d20:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
     d24:	2b00      	cmp	r3, #0
     d26:	eeb4 6a67 	vcmp.f32	s12, s15
     d2a:	eeb0 7ac7 	vabs.f32	s14, s14
     d2e:	bfb8      	it	lt
     d30:	eeb1 7a47 	vneglt.f32	s14, s14
     d34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d38:	bfcc      	ite	gt
     d3a:	2301      	movgt	r3, #1
     d3c:	2300      	movle	r3, #0
     d3e:	ee07 3a90 	vmov	s15, r3
     d42:	ee11 3a90 	vmov	r3, s3
     d46:	eef8 7ae7 	vcvt.f32.s32	s15, s15
     d4a:	2b00      	cmp	r3, #0
     d4c:	eef0 7ae7 	vabs.f32	s15, s15
     d50:	eeb4 0a40 	vcmp.f32	s0, s0
     d54:	bfb8      	it	lt
     d56:	eef1 7a67 	vneglt.f32	s15, s15
     d5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d5e:	eeb0 1a47 	vmov.f32	s2, s14
     d62:	eef0 1a67 	vmov.f32	s3, s15
     d66:	d709      	bvc.n	d7c <__mulsc3+0x174>
     d68:	ee10 3a10 	vmov	r3, s0
     d6c:	eddf 7a43 	vldr	s15, [pc, #268]	; e7c <__data_size+0x7f>
     d70:	ed9f 0a43 	vldr	s0, [pc, #268]	; e80 <__data_size+0x83>
     d74:	2b00      	cmp	r3, #0
     d76:	bfa8      	it	ge
     d78:	eeb0 0a67 	vmovge.f32	s0, s15
     d7c:	eef4 0a60 	vcmp.f32	s1, s1
     d80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     d84:	d709      	bvc.n	d9a <__mulsc3+0x192>
     d86:	ee10 3a90 	vmov	r3, s1
     d8a:	eddf 7a3c 	vldr	s15, [pc, #240]	; e7c <__data_size+0x7f>
     d8e:	eddf 0a3c 	vldr	s1, [pc, #240]	; e80 <__data_size+0x83>
     d92:	2b00      	cmp	r3, #0
     d94:	bfa8      	it	ge
     d96:	eef0 0a67 	vmovge.f32	s1, s15
     d9a:	ee21 7ae0 	vnmul.f32	s14, s3, s1
     d9e:	ee60 0a81 	vmul.f32	s1, s1, s2
     da2:	eea0 7a01 	vfma.f32	s14, s0, s2
     da6:	eee0 0a21 	vfma.f32	s1, s0, s3
     daa:	eddf 6a36 	vldr	s13, [pc, #216]	; e84 <__data_size+0x87>
     dae:	ee27 7a26 	vmul.f32	s14, s14, s13
     db2:	ee60 6aa6 	vmul.f32	s13, s1, s13
     db6:	eeb0 0a47 	vmov.f32	s0, s14
     dba:	eef0 0a66 	vmov.f32	s1, s13
     dbe:	4770      	bx	lr
     dc0:	2b00      	cmp	r3, #0
     dc2:	d1ea      	bne.n	d9a <__mulsc3+0x192>
     dc4:	eeb0 4ac4 	vabs.f32	s8, s8
     dc8:	eeb4 4a67 	vcmp.f32	s8, s15
     dcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     dd0:	dc14      	bgt.n	dfc <__mulsc3+0x1f4>
     dd2:	eef0 4ae4 	vabs.f32	s9, s9
     dd6:	eef4 4a67 	vcmp.f32	s9, s15
     dda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     dde:	dc0d      	bgt.n	dfc <__mulsc3+0x1f4>
     de0:	eeb0 5ac5 	vabs.f32	s10, s10
     de4:	eeb4 5a67 	vcmp.f32	s10, s15
     de8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     dec:	dc06      	bgt.n	dfc <__mulsc3+0x1f4>
     dee:	eef0 5ae5 	vabs.f32	s11, s11
     df2:	eef4 5a67 	vcmp.f32	s11, s15
     df6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     dfa:	dddc      	ble.n	db6 <__mulsc3+0x1ae>
     dfc:	eeb4 0a40 	vcmp.f32	s0, s0
     e00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     e04:	d709      	bvc.n	e1a <__data_size+0x1d>
     e06:	ee10 3a10 	vmov	r3, s0
     e0a:	eddf 7a1c 	vldr	s15, [pc, #112]	; e7c <__data_size+0x7f>
     e0e:	ed9f 0a1c 	vldr	s0, [pc, #112]	; e80 <__data_size+0x83>
     e12:	2b00      	cmp	r3, #0
     e14:	bfa8      	it	ge
     e16:	eeb0 0a67 	vmovge.f32	s0, s15
     e1a:	eef4 0a60 	vcmp.f32	s1, s1
     e1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     e22:	d709      	bvc.n	e38 <__data_size+0x3b>
     e24:	ee10 3a90 	vmov	r3, s1
     e28:	eddf 7a14 	vldr	s15, [pc, #80]	; e7c <__data_size+0x7f>
     e2c:	eddf 0a14 	vldr	s1, [pc, #80]	; e80 <__data_size+0x83>
     e30:	2b00      	cmp	r3, #0
     e32:	bfa8      	it	ge
     e34:	eef0 0a67 	vmovge.f32	s1, s15
     e38:	eeb4 1a41 	vcmp.f32	s2, s2
     e3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     e40:	d709      	bvc.n	e56 <__data_size+0x59>
     e42:	ee11 3a10 	vmov	r3, s2
     e46:	eddf 7a0d 	vldr	s15, [pc, #52]	; e7c <__data_size+0x7f>
     e4a:	ed9f 1a0d 	vldr	s2, [pc, #52]	; e80 <__data_size+0x83>
     e4e:	2b00      	cmp	r3, #0
     e50:	bfa8      	it	ge
     e52:	eeb0 1a67 	vmovge.f32	s2, s15
     e56:	eef4 1a61 	vcmp.f32	s3, s3
     e5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     e5e:	d79c      	bvc.n	d9a <__mulsc3+0x192>
     e60:	ee11 3a90 	vmov	r3, s3
     e64:	eddf 7a05 	vldr	s15, [pc, #20]	; e7c <__data_size+0x7f>
     e68:	eddf 1a05 	vldr	s3, [pc, #20]	; e80 <__data_size+0x83>
     e6c:	2b00      	cmp	r3, #0
     e6e:	bfa8      	it	ge
     e70:	eef0 1a67 	vmovge.f32	s3, s15
     e74:	e791      	b.n	d9a <__mulsc3+0x192>
     e76:	bf00      	nop
     e78:	7f7fffff 	.word	0x7f7fffff
     e7c:	00000000 	.word	0x00000000
     e80:	80000000 	.word	0x80000000
     e84:	7f800000 	.word	0x7f800000

00000e88 <__aeabi_idiv0>:
     e88:	4770      	bx	lr
     e8a:	bf00      	nop

00000e8c <ocrypto_bigint_add256>:
     e8c:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
     e90:	e891 07f8 	ldmia.w	r1, {r3, r4, r5, r6, r7, r8, r9, sl}
     e94:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     e98:	185b      	adds	r3, r3, r1
     e9a:	eb54 040c 	adcs.w	r4, r4, ip
     e9e:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     ea2:	414d      	adcs	r5, r1
     ea4:	eb56 060c 	adcs.w	r6, r6, ip
     ea8:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     eac:	414f      	adcs	r7, r1
     eae:	eb58 080c 	adcs.w	r8, r8, ip
     eb2:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     eb6:	eb59 0901 	adcs.w	r9, r9, r1
     eba:	eb5a 0a0c 	adcs.w	sl, sl, ip
     ebe:	e880 07f8 	stmia.w	r0, {r3, r4, r5, r6, r7, r8, r9, sl}
     ec2:	4180      	sbcs	r0, r0
     ec4:	3001      	adds	r0, #1
     ec6:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
     eca:	4770      	bx	lr

00000ecc <ocrypto_bigint_sub256>:
     ecc:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
     ed0:	e891 07f8 	ldmia.w	r1, {r3, r4, r5, r6, r7, r8, r9, sl}
     ed4:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     ed8:	1a5b      	subs	r3, r3, r1
     eda:	eb74 040c 	sbcs.w	r4, r4, ip
     ede:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     ee2:	418d      	sbcs	r5, r1
     ee4:	eb76 060c 	sbcs.w	r6, r6, ip
     ee8:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     eec:	418f      	sbcs	r7, r1
     eee:	eb78 080c 	sbcs.w	r8, r8, ip
     ef2:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
     ef6:	eb79 0901 	sbcs.w	r9, r9, r1
     efa:	eb7a 0a0c 	sbcs.w	sl, sl, ip
     efe:	e880 07f8 	stmia.w	r0, {r3, r4, r5, r6, r7, r8, r9, sl}
     f02:	4180      	sbcs	r0, r0
     f04:	4240      	negs	r0, r0
     f06:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
     f0a:	4770      	bx	lr

00000f0c <ocrypto_bigint_cadd256>:
     f0c:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
     f10:	4252      	negs	r2, r2
     f12:	e890 0078 	ldmia.w	r0, {r3, r4, r5, r6}
     f16:	e8b1 0780 	ldmia.w	r1!, {r7, r8, r9, sl}
     f1a:	4017      	ands	r7, r2
     f1c:	19db      	adds	r3, r3, r7
     f1e:	ea18 0802 	ands.w	r8, r8, r2
     f22:	eb54 0408 	adcs.w	r4, r4, r8
     f26:	ea19 0902 	ands.w	r9, r9, r2
     f2a:	eb55 0509 	adcs.w	r5, r5, r9
     f2e:	ea1a 0a02 	ands.w	sl, sl, r2
     f32:	eb56 060a 	adcs.w	r6, r6, sl
     f36:	c078      	stmia	r0!, {r3, r4, r5, r6}
     f38:	e890 0078 	ldmia.w	r0, {r3, r4, r5, r6}
     f3c:	e8b1 0780 	ldmia.w	r1!, {r7, r8, r9, sl}
     f40:	4017      	ands	r7, r2
     f42:	417b      	adcs	r3, r7
     f44:	ea18 0802 	ands.w	r8, r8, r2
     f48:	eb54 0408 	adcs.w	r4, r4, r8
     f4c:	ea19 0902 	ands.w	r9, r9, r2
     f50:	eb55 0509 	adcs.w	r5, r5, r9
     f54:	ea1a 0a02 	ands.w	sl, sl, r2
     f58:	eb56 060a 	adcs.w	r6, r6, sl
     f5c:	c078      	stmia	r0!, {r3, r4, r5, r6}
     f5e:	4180      	sbcs	r0, r0
     f60:	3001      	adds	r0, #1
     f62:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
     f66:	4770      	bx	lr

00000f68 <ocrypto_bigint_csub256>:
     f68:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
     f6c:	4252      	negs	r2, r2
     f6e:	e890 0078 	ldmia.w	r0, {r3, r4, r5, r6}
     f72:	e8b1 0780 	ldmia.w	r1!, {r7, r8, r9, sl}
     f76:	4017      	ands	r7, r2
     f78:	1bdb      	subs	r3, r3, r7
     f7a:	ea18 0802 	ands.w	r8, r8, r2
     f7e:	eb74 0408 	sbcs.w	r4, r4, r8
     f82:	ea19 0902 	ands.w	r9, r9, r2
     f86:	eb75 0509 	sbcs.w	r5, r5, r9
     f8a:	ea1a 0a02 	ands.w	sl, sl, r2
     f8e:	eb76 060a 	sbcs.w	r6, r6, sl
     f92:	c078      	stmia	r0!, {r3, r4, r5, r6}
     f94:	e890 0078 	ldmia.w	r0, {r3, r4, r5, r6}
     f98:	e8b1 0780 	ldmia.w	r1!, {r7, r8, r9, sl}
     f9c:	4017      	ands	r7, r2
     f9e:	41bb      	sbcs	r3, r7
     fa0:	ea18 0802 	ands.w	r8, r8, r2
     fa4:	eb74 0408 	sbcs.w	r4, r4, r8
     fa8:	ea19 0902 	ands.w	r9, r9, r2
     fac:	eb75 0509 	sbcs.w	r5, r5, r9
     fb0:	ea1a 0a02 	ands.w	sl, sl, r2
     fb4:	eb76 060a 	sbcs.w	r6, r6, sl
     fb8:	c078      	stmia	r0!, {r3, r4, r5, r6}
     fba:	4180      	sbcs	r0, r0
     fbc:	4240      	negs	r0, r0
     fbe:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
     fc2:	4770      	bx	lr

00000fc4 <ocrypto_bigint_cswap256>:
     fc4:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
     fc8:	4252      	negs	r2, r2
     fca:	f04f 0804 	mov.w	r8, #4

00000fce <cswap256_loop>:
     fce:	e890 0030 	ldmia.w	r0, {r4, r5}
     fd2:	e891 00c0 	ldmia.w	r1, {r6, r7}
     fd6:	1ba3      	subs	r3, r4, r6
     fd8:	4013      	ands	r3, r2
     fda:	1ae4      	subs	r4, r4, r3
     fdc:	18f6      	adds	r6, r6, r3
     fde:	1beb      	subs	r3, r5, r7
     fe0:	4013      	ands	r3, r2
     fe2:	1aed      	subs	r5, r5, r3
     fe4:	18ff      	adds	r7, r7, r3
     fe6:	c030      	stmia	r0!, {r4, r5}
     fe8:	c1c0      	stmia	r1!, {r6, r7}
     fea:	f1b8 0801 	subs.w	r8, r8, #1
     fee:	d1ee      	bne.n	fce <cswap256_loop>
     ff0:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
     ff4:	4770      	bx	lr
     ff6:	bf00      	nop

00000ff8 <ocrypto_mul256_noframe>:
     ff8:	b500      	push	{lr}
     ffa:	ec92 0a08 	vldmia	r2, {s0-s7}
     ffe:	e8b1 5780 	ldmia.w	r1!, {r7, r8, r9, sl, ip, lr}
    1002:	ee07 1a10 	vmov	s14, r1
    1006:	ec53 2a10 	vmov	r2, r3, s0, s1
    100a:	ec56 4a11 	vmov	r4, r6, s2, s3
    100e:	fba7 5102 	umull	r5, r1, r7, r2
    1012:	fba8 0b02 	umull	r0, fp, r8, r2
    1016:	fbe7 1063 	umaal	r1, r0, r7, r3
    101a:	fbe9 b062 	umaal	fp, r0, r9, r2
    101e:	ec41 5a14 	vmov	s8, s9, r5, r1
    1022:	fba8 5103 	umull	r5, r1, r8, r3
    1026:	fbea 0162 	umaal	r0, r1, sl, r2
    102a:	fbe7 b564 	umaal	fp, r5, r7, r4
    102e:	fbe7 0566 	umaal	r0, r5, r7, r6
    1032:	fbe8 1566 	umaal	r1, r5, r8, r6
    1036:	ee05 ba10 	vmov	s10, fp
    103a:	fba9 b603 	umull	fp, r6, r9, r3
    103e:	fbea 1663 	umaal	r1, r6, sl, r3
    1042:	fbec 5663 	umaal	r5, r6, ip, r3
    1046:	fbe8 0b64 	umaal	r0, fp, r8, r4
    104a:	fbe9 1b64 	umaal	r1, fp, r9, r4
    104e:	fbea 5b64 	umaal	r5, fp, sl, r4
    1052:	fbec 6b64 	umaal	r6, fp, ip, r4
    1056:	ee05 0a90 	vmov	s11, r0
    105a:	fbac 3002 	umull	r3, r0, ip, r2
    105e:	ee12 4a10 	vmov	r4, s4
    1062:	fbee 5062 	umaal	r5, r0, lr, r2
    1066:	fbe9 6064 	umaal	r6, r0, r9, r4
    106a:	fbea b064 	umaal	fp, r0, sl, r4
    106e:	fbe7 3164 	umaal	r3, r1, r7, r4
    1072:	fbe8 5164 	umaal	r5, r1, r8, r4
    1076:	ee12 4a90 	vmov	r4, s5
    107a:	fbe8 6164 	umaal	r6, r1, r8, r4
    107e:	fbe9 b164 	umaal	fp, r1, r9, r4
    1082:	fbea 0164 	umaal	r0, r1, sl, r4
    1086:	ee06 3a10 	vmov	s12, r3
    108a:	fba7 3204 	umull	r3, r2, r7, r4
    108e:	ee13 4a10 	vmov	r4, s6
    1092:	fbe7 6264 	umaal	r6, r2, r7, r4
    1096:	fbe8 b264 	umaal	fp, r2, r8, r4
    109a:	fbe9 0264 	umaal	r0, r2, r9, r4
    109e:	fbea 1264 	umaal	r1, r2, sl, r4
    10a2:	ee11 4a90 	vmov	r4, s3
    10a6:	fbe9 5364 	umaal	r5, r3, r9, r4
    10aa:	fbea 6364 	umaal	r6, r3, sl, r4
    10ae:	ee13 4a90 	vmov	r4, s7
    10b2:	fbe7 b364 	umaal	fp, r3, r7, r4
    10b6:	fbe8 0364 	umaal	r0, r3, r8, r4
    10ba:	fbe9 1364 	umaal	r1, r3, r9, r4
    10be:	fbea 2364 	umaal	r2, r3, sl, r4
    10c2:	ee06 5a90 	vmov	s13, r5
    10c6:	ee17 9a10 	vmov	r9, s14
    10ca:	e899 0600 	ldmia.w	r9, {r9, sl}
    10ce:	ee10 8a10 	vmov	r8, s0
    10d2:	fba9 5408 	umull	r5, r4, r9, r8
    10d6:	fbea b468 	umaal	fp, r4, sl, r8
    10da:	ee12 8a10 	vmov	r8, s4
    10de:	fbec 0468 	umaal	r0, r4, ip, r8
    10e2:	fbee 1468 	umaal	r1, r4, lr, r8
    10e6:	fbe9 2468 	umaal	r2, r4, r9, r8
    10ea:	fbea 3468 	umaal	r3, r4, sl, r8
    10ee:	ee10 8a90 	vmov	r8, s1
    10f2:	fbee 6568 	umaal	r6, r5, lr, r8
    10f6:	fbe9 b568 	umaal	fp, r5, r9, r8
    10fa:	fbea 0568 	umaal	r0, r5, sl, r8
    10fe:	ee12 8a90 	vmov	r8, s5
    1102:	fbec 1568 	umaal	r1, r5, ip, r8
    1106:	fbee 2568 	umaal	r2, r5, lr, r8
    110a:	fbe9 3568 	umaal	r3, r5, r9, r8
    110e:	fbea 4568 	umaal	r4, r5, sl, r8
    1112:	ee07 6a10 	vmov	s14, r6
    1116:	ee11 8a10 	vmov	r8, s2
    111a:	fbae 7608 	umull	r7, r6, lr, r8
    111e:	fbe9 0668 	umaal	r0, r6, r9, r8
    1122:	fbea 1668 	umaal	r1, r6, sl, r8
    1126:	ee13 8a10 	vmov	r8, s6
    112a:	fbec 2668 	umaal	r2, r6, ip, r8
    112e:	fbee 3668 	umaal	r3, r6, lr, r8
    1132:	fbe9 4668 	umaal	r4, r6, r9, r8
    1136:	fbea 5668 	umaal	r5, r6, sl, r8
    113a:	ee11 8a90 	vmov	r8, s3
    113e:	fbec b768 	umaal	fp, r7, ip, r8
    1142:	fbee 0768 	umaal	r0, r7, lr, r8
    1146:	fbe9 1768 	umaal	r1, r7, r9, r8
    114a:	fbea 2768 	umaal	r2, r7, sl, r8
    114e:	ee13 8a90 	vmov	r8, s7
    1152:	fbec 3768 	umaal	r3, r7, ip, r8
    1156:	fbee 4768 	umaal	r4, r7, lr, r8
    115a:	fbe9 5768 	umaal	r5, r7, r9, r8
    115e:	fbea 6768 	umaal	r6, r7, sl, r8
    1162:	bd00      	pop	{pc}

00001164 <ocrypto_bigint_mul256>:
    1164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1168:	ee07 0a90 	vmov	s15, r0
    116c:	f7ff ff44 	bl	ff8 <ocrypto_mul256_noframe>
    1170:	ee17 8a90 	vmov	r8, s15
    1174:	ee07 ba90 	vmov	s15, fp
    1178:	eca8 4a08 	vstmia	r8!, {s8-s15}
    117c:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
    1180:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001184 <ocrypto_sqr256_noframe>:
    1184:	b500      	push	{lr}
    1186:	e891 5798 	ldmia.w	r1, {r3, r4, r7, r8, r9, sl, ip, lr}
    118a:	fba3 5203 	umull	r5, r2, r3, r3
    118e:	fba3 0104 	umull	r0, r1, r3, r4
    1192:	fbe3 2064 	umaal	r2, r0, r3, r4
    1196:	fbe3 1067 	umaal	r1, r0, r3, r7
    119a:	ec42 5a14 	vmov	s8, s9, r5, r2
    119e:	fba3 5207 	umull	r5, r2, r3, r7
    11a2:	fbe3 0268 	umaal	r0, r2, r3, r8
    11a6:	fbe4 1564 	umaal	r1, r5, r4, r4
    11aa:	fbe3 0568 	umaal	r0, r5, r3, r8
    11ae:	fbe3 2569 	umaal	r2, r5, r3, r9
    11b2:	fba4 b607 	umull	fp, r6, r4, r7
    11b6:	fbe3 2669 	umaal	r2, r6, r3, r9
    11ba:	fbe3 566a 	umaal	r5, r6, r3, sl
    11be:	fbe4 0b67 	umaal	r0, fp, r4, r7
    11c2:	fbe4 2b68 	umaal	r2, fp, r4, r8
    11c6:	fbe3 5b6a 	umaal	r5, fp, r3, sl
    11ca:	fbe3 6b6c 	umaal	r6, fp, r3, ip
    11ce:	ec40 1a15 	vmov	s10, s11, r1, r0
    11d2:	fba4 1008 	umull	r1, r0, r4, r8
    11d6:	fbe4 5069 	umaal	r5, r0, r4, r9
    11da:	fbe3 606c 	umaal	r6, r0, r3, ip
    11de:	fbe3 b06e 	umaal	fp, r0, r3, lr
    11e2:	fbe7 2167 	umaal	r2, r1, r7, r7
    11e6:	fbe4 5169 	umaal	r5, r1, r4, r9
    11ea:	fbe4 616a 	umaal	r6, r1, r4, sl
    11ee:	fbe3 b16e 	umaal	fp, r1, r3, lr
    11f2:	fbe4 016e 	umaal	r0, r1, r4, lr
    11f6:	ee06 2a10 	vmov	s12, r2
    11fa:	fba7 3208 	umull	r3, r2, r7, r8
    11fe:	fbe4 626a 	umaal	r6, r2, r4, sl
    1202:	fbe4 b26c 	umaal	fp, r2, r4, ip
    1206:	fbe4 026e 	umaal	r0, r2, r4, lr
    120a:	fbe7 126e 	umaal	r1, r2, r7, lr
    120e:	fbe7 5368 	umaal	r5, r3, r7, r8
    1212:	fbe7 6369 	umaal	r6, r3, r7, r9
    1216:	fbe4 b36c 	umaal	fp, r3, r4, ip
    121a:	fbe7 036c 	umaal	r0, r3, r7, ip
    121e:	fbe7 136e 	umaal	r1, r3, r7, lr
    1222:	fbe8 236e 	umaal	r2, r3, r8, lr
    1226:	ee06 5a90 	vmov	s13, r5
    122a:	fba7 5409 	umull	r5, r4, r7, r9
    122e:	fbe7 b46a 	umaal	fp, r4, r7, sl
    1232:	fbe7 046c 	umaal	r0, r4, r7, ip
    1236:	fbe8 146c 	umaal	r1, r4, r8, ip
    123a:	fbe8 246e 	umaal	r2, r4, r8, lr
    123e:	fbe9 346e 	umaal	r3, r4, r9, lr
    1242:	fbe8 6568 	umaal	r6, r5, r8, r8
    1246:	fbe7 b56a 	umaal	fp, r5, r7, sl
    124a:	fbe8 056a 	umaal	r0, r5, r8, sl
    124e:	fbe8 156c 	umaal	r1, r5, r8, ip
    1252:	fbe9 256c 	umaal	r2, r5, r9, ip
    1256:	fbe9 356e 	umaal	r3, r5, r9, lr
    125a:	fbea 456e 	umaal	r4, r5, sl, lr
    125e:	ee07 6a10 	vmov	s14, r6
    1262:	fba8 7609 	umull	r7, r6, r8, r9
    1266:	fbe8 066a 	umaal	r0, r6, r8, sl
    126a:	fbe9 166a 	umaal	r1, r6, r9, sl
    126e:	fbe9 266c 	umaal	r2, r6, r9, ip
    1272:	fbea 366c 	umaal	r3, r6, sl, ip
    1276:	fbea 466e 	umaal	r4, r6, sl, lr
    127a:	fbec 566e 	umaal	r5, r6, ip, lr
    127e:	fbe8 b769 	umaal	fp, r7, r8, r9
    1282:	fbe9 0769 	umaal	r0, r7, r9, r9
    1286:	fbe9 176a 	umaal	r1, r7, r9, sl
    128a:	fbea 276a 	umaal	r2, r7, sl, sl
    128e:	fbea 376c 	umaal	r3, r7, sl, ip
    1292:	fbec 476c 	umaal	r4, r7, ip, ip
    1296:	fbec 576e 	umaal	r5, r7, ip, lr
    129a:	fbee 676e 	umaal	r6, r7, lr, lr
    129e:	bd00      	pop	{pc}

000012a0 <ocrypto_bigint_sqr256>:
    12a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    12a4:	ee07 0a90 	vmov	s15, r0
    12a8:	f7ff ff6c 	bl	1184 <ocrypto_sqr256_noframe>
    12ac:	ee17 8a90 	vmov	r8, s15
    12b0:	ee07 ba90 	vmov	s15, fp
    12b4:	eca8 4a08 	vstmia	r8!, {s8-s15}
    12b8:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
    12bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000012c0 <ocrypto_constant_time_equal>:
    12c0:	b430      	push	{r4, r5}
    12c2:	f04f 0300 	mov.w	r3, #0

000012c6 <constant_time_equal_loop>:
    12c6:	f810 4b01 	ldrb.w	r4, [r0], #1
    12ca:	f811 5b01 	ldrb.w	r5, [r1], #1
    12ce:	3a01      	subs	r2, #1
    12d0:	ea84 0405 	eor.w	r4, r4, r5
    12d4:	ea43 0304 	orr.w	r3, r3, r4
    12d8:	d1f5      	bne.n	12c6 <constant_time_equal_loop>
    12da:	f1a3 0301 	sub.w	r3, r3, #1
    12de:	ea4f 70d3 	mov.w	r0, r3, lsr #31
    12e2:	bc30      	pop	{r4, r5}
    12e4:	4770      	bx	lr
    12e6:	bf00      	nop

000012e8 <ocrypto_constant_time_is_zero>:
    12e8:	f04f 0300 	mov.w	r3, #0

000012ec <constant_time_is_zero_loop>:
    12ec:	f810 2b01 	ldrb.w	r2, [r0], #1
    12f0:	3901      	subs	r1, #1
    12f2:	ea43 0302 	orr.w	r3, r3, r2
    12f6:	d1f9      	bne.n	12ec <constant_time_is_zero_loop>
    12f8:	f1a3 0301 	sub.w	r3, r3, #1
    12fc:	ea4f 70d3 	mov.w	r0, r3, lsr #31
    1300:	4770      	bx	lr
    1302:	bf00      	nop

00001304 <ocrypto_constant_time_xor>:
    1304:	b430      	push	{r4, r5}

00001306 <constant_time_xor_loop>:
    1306:	f811 4b01 	ldrb.w	r4, [r1], #1
    130a:	f812 5b01 	ldrb.w	r5, [r2], #1
    130e:	406c      	eors	r4, r5
    1310:	f800 4b01 	strb.w	r4, [r0], #1
    1314:	3b01      	subs	r3, #1
    1316:	d1f6      	bne.n	1306 <constant_time_xor_loop>
    1318:	bc30      	pop	{r4, r5}
    131a:	4770      	bx	lr

0000131c <ocrypto_mod_p256_add>:
    131c:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
    1320:	e891 07f8 	ldmia.w	r1, {r3, r4, r5, r6, r7, r8, r9, sl}
    1324:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    1328:	185b      	adds	r3, r3, r1
    132a:	eb54 040c 	adcs.w	r4, r4, ip
    132e:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    1332:	414d      	adcs	r5, r1
    1334:	eb56 060c 	adcs.w	r6, r6, ip
    1338:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    133c:	414f      	adcs	r7, r1
    133e:	eb58 080c 	adcs.w	r8, r8, ip
    1342:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    1346:	eb59 0901 	adcs.w	r9, r9, r1
    134a:	eb5a 0a0c 	adcs.w	sl, sl, ip
    134e:	4189      	sbcs	r1, r1
    1350:	f1b3 33ff 	subs.w	r3, r3, #4294967295	; 0xffffffff
    1354:	f174 34ff 	sbcs.w	r4, r4, #4294967295	; 0xffffffff
    1358:	f175 35ff 	sbcs.w	r5, r5, #4294967295	; 0xffffffff
    135c:	f176 0600 	sbcs.w	r6, r6, #0
    1360:	f177 0700 	sbcs.w	r7, r7, #0
    1364:	f178 0800 	sbcs.w	r8, r8, #0
    1368:	f179 0901 	sbcs.w	r9, r9, #1
    136c:	f17a 3aff 	sbcs.w	sl, sl, #4294967295	; 0xffffffff
    1370:	f151 0100 	adcs.w	r1, r1, #0
    1374:	185b      	adds	r3, r3, r1
    1376:	414c      	adcs	r4, r1
    1378:	414d      	adcs	r5, r1
    137a:	f156 0600 	adcs.w	r6, r6, #0
    137e:	f157 0700 	adcs.w	r7, r7, #0
    1382:	f158 0800 	adcs.w	r8, r8, #0
    1386:	eb59 79d1 	adcs.w	r9, r9, r1, lsr #31
    138a:	eb5a 0a01 	adcs.w	sl, sl, r1
    138e:	e880 07f8 	stmia.w	r0, {r3, r4, r5, r6, r7, r8, r9, sl}
    1392:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
    1396:	4770      	bx	lr

00001398 <ocrypto_mod_p256_sub>:
    1398:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
    139c:	e891 07f8 	ldmia.w	r1, {r3, r4, r5, r6, r7, r8, r9, sl}
    13a0:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    13a4:	1a5b      	subs	r3, r3, r1
    13a6:	eb74 040c 	sbcs.w	r4, r4, ip
    13aa:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    13ae:	418d      	sbcs	r5, r1
    13b0:	eb76 060c 	sbcs.w	r6, r6, ip
    13b4:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    13b8:	418f      	sbcs	r7, r1
    13ba:	eb78 080c 	sbcs.w	r8, r8, ip
    13be:	e8b2 1002 	ldmia.w	r2!, {r1, ip}
    13c2:	eb79 0901 	sbcs.w	r9, r9, r1
    13c6:	eb7a 0a0c 	sbcs.w	sl, sl, ip
    13ca:	4189      	sbcs	r1, r1
    13cc:	185b      	adds	r3, r3, r1
    13ce:	414c      	adcs	r4, r1
    13d0:	414d      	adcs	r5, r1
    13d2:	f156 0600 	adcs.w	r6, r6, #0
    13d6:	f157 0700 	adcs.w	r7, r7, #0
    13da:	f158 0800 	adcs.w	r8, r8, #0
    13de:	eb59 79d1 	adcs.w	r9, r9, r1, lsr #31
    13e2:	eb5a 0a01 	adcs.w	sl, sl, r1
    13e6:	e880 07f8 	stmia.w	r0, {r3, r4, r5, r6, r7, r8, r9, sl}
    13ea:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
    13ee:	4770      	bx	lr

000013f0 <mul_reduce>:
    13f0:	eb18 0804 	adds.w	r8, r8, r4
    13f4:	eb59 0905 	adcs.w	r9, r9, r5
    13f8:	eb5a 0a06 	adcs.w	sl, sl, r6
    13fc:	eb5b 0b07 	adcs.w	fp, fp, r7
    1400:	f05f 0c00 	movs.w	ip, #0
    1404:	f14c 0c00 	adc.w	ip, ip, #0
    1408:	eb18 0805 	adds.w	r8, r8, r5
    140c:	eb59 0906 	adcs.w	r9, r9, r6
    1410:	eb5a 0a07 	adcs.w	sl, sl, r7
    1414:	eb5b 0b07 	adcs.w	fp, fp, r7
    1418:	eb50 000c 	adcs.w	r0, r0, ip
    141c:	f05f 0c00 	movs.w	ip, #0
    1420:	eb51 010c 	adcs.w	r1, r1, ip
    1424:	eb52 020c 	adcs.w	r2, r2, ip
    1428:	4163      	adcs	r3, r4
    142a:	f14c 0c00 	adc.w	ip, ip, #0
    142e:	ebb8 0807 	subs.w	r8, r8, r7
    1432:	f179 0900 	sbcs.w	r9, r9, #0
    1436:	f17a 0a00 	sbcs.w	sl, sl, #0
    143a:	eb7b 0b04 	sbcs.w	fp, fp, r4
    143e:	41a8      	sbcs	r0, r5
    1440:	41b1      	sbcs	r1, r6
    1442:	41a2      	sbcs	r2, r4
    1444:	41b3      	sbcs	r3, r6
    1446:	f16c 0c00 	sbc.w	ip, ip, #0
    144a:	ebbb 0b05 	subs.w	fp, fp, r5
    144e:	41b0      	sbcs	r0, r6
    1450:	41b9      	sbcs	r1, r7
    1452:	41aa      	sbcs	r2, r5
    1454:	41bb      	sbcs	r3, r7
    1456:	f16c 0c00 	sbc.w	ip, ip, #0
    145a:	ea6f 74ec 	mvn.w	r4, ip, asr #31
    145e:	ebb8 0804 	subs.w	r8, r8, r4
    1462:	eb79 0904 	sbcs.w	r9, r9, r4
    1466:	eb7a 0a04 	sbcs.w	sl, sl, r4
    146a:	f17b 0b00 	sbcs.w	fp, fp, #0
    146e:	f170 0000 	sbcs.w	r0, r0, #0
    1472:	f171 0100 	sbcs.w	r1, r1, #0
    1476:	eb72 72d4 	sbcs.w	r2, r2, r4, lsr #31
    147a:	41a3      	sbcs	r3, r4
    147c:	f16c 0c00 	sbc.w	ip, ip, #0
    1480:	eb18 78ec 	adds.w	r8, r8, ip, asr #31
    1484:	eb59 79ec 	adcs.w	r9, r9, ip, asr #31
    1488:	eb5a 7aec 	adcs.w	sl, sl, ip, asr #31
    148c:	f15b 0b00 	adcs.w	fp, fp, #0
    1490:	f150 0400 	adcs.w	r4, r0, #0
    1494:	f151 0500 	adcs.w	r5, r1, #0
    1498:	eb52 76dc 	adcs.w	r6, r2, ip, lsr #31
    149c:	eb53 77ec 	adcs.w	r7, r3, ip, asr #31
    14a0:	f14c 0c00 	adc.w	ip, ip, #0
    14a4:	eb18 70ec 	adds.w	r0, r8, ip, asr #31
    14a8:	eb59 71ec 	adcs.w	r1, r9, ip, asr #31
    14ac:	eb5a 72ec 	adcs.w	r2, sl, ip, asr #31
    14b0:	f15b 0300 	adcs.w	r3, fp, #0
    14b4:	f154 0400 	adcs.w	r4, r4, #0
    14b8:	f155 0500 	adcs.w	r5, r5, #0
    14bc:	eb56 76dc 	adcs.w	r6, r6, ip, lsr #31
    14c0:	eb57 77ec 	adcs.w	r7, r7, ip, asr #31
    14c4:	4770      	bx	lr
    14c6:	bf00      	nop

000014c8 <ocrypto_mod_p256_mul>:
    14c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    14cc:	ee07 0a90 	vmov	s15, r0
    14d0:	f7ff fd92 	bl	ff8 <ocrypto_mul256_noframe>
    14d4:	ec59 8a16 	vmov	r8, r9, s12, s13
    14d8:	ee17 aa10 	vmov	sl, s14
    14dc:	f7ff ff88 	bl	13f0 <mul_reduce>
    14e0:	ec59 8a14 	vmov	r8, r9, s8, s9
    14e4:	ec5b aa15 	vmov	sl, fp, s10, s11
    14e8:	f7ff ff82 	bl	13f0 <mul_reduce>
    14ec:	ee17 8a90 	vmov	r8, s15
    14f0:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
    14f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000014f8 <ocrypto_mod_p256_sqr>:
    14f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    14fc:	ee07 0a90 	vmov	s15, r0
    1500:	f7ff fe40 	bl	1184 <ocrypto_sqr256_noframe>
    1504:	ec59 8a16 	vmov	r8, r9, s12, s13
    1508:	ee17 aa10 	vmov	sl, s14
    150c:	f7ff ff70 	bl	13f0 <mul_reduce>
    1510:	ec59 8a14 	vmov	r8, r9, s8, s9
    1514:	ec5b aa15 	vmov	sl, fp, s10, s11
    1518:	f7ff ff6a 	bl	13f0 <mul_reduce>
    151c:	ee17 8a90 	vmov	r8, s15
    1520:	e888 00ff 	stmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, r7}
    1524:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001528 <sym_3NUECOSAIC227DBCPHAP4U7EQ3UBTGANU5ASIOA>:
    1528:	4801      	ldr	r0, [pc, #4]	; (1530 <sym_3NUECOSAIC227DBCPHAP4U7EQ3UBTGANU5ASIOA+0x8>)
    152a:	7800      	ldrb	r0, [r0, #0]
    152c:	4770      	bx	lr
    152e:	0000      	.short	0x0000
    1530:	20000028 	.word	0x20000028

00001534 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA>:
    1534:	b570      	push	{r4, r5, r6, lr}
    1536:	f00b fd07 	bl	cf48 <sym_SWIBDSDMHUYNCG5ZWLB52J7NETJIUBPCO5IIQFA>
    153a:	4c13      	ldr	r4, [pc, #76]	; (1588 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x54>)
    153c:	f06f 0527 	mvn.w	r5, #39	; 0x27
    1540:	b928      	cbnz	r0, 154e <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x1a>
    1542:	f00b fd37 	bl	cfb4 <sym_6PVOPWDLWTXOTRZZ7LP36TLYTLPTQHNAUQNFHEA>
    1546:	b910      	cbnz	r0, 154e <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x1a>
    1548:	f00b fd3e 	bl	cfc8 <sym_USR4MDT6VMTQLOGKNN4MALBZ3GJPD2KOEY4HFAQ>
    154c:	b120      	cbz	r0, 1558 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x24>
    154e:	480f      	ldr	r0, [pc, #60]	; (158c <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x58>)
    1550:	6060      	str	r0, [r4, #4]
    1552:	7065      	strb	r5, [r4, #1]
    1554:	2008      	movs	r0, #8
    1556:	e010      	b.n	157a <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x46>
    1558:	f00b fccb 	bl	cef2 <sym_BN6ZO2NBHRGKZ2NRQYWFBXVGKNG6Y5K55UNAWGA>
    155c:	b940      	cbnz	r0, 1570 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x3c>
    155e:	f00b fcd2 	bl	cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>
    1562:	b928      	cbnz	r0, 1570 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x3c>
    1564:	f00b fce6 	bl	cf34 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q>
    1568:	b910      	cbnz	r0, 1570 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x3c>
    156a:	f00b fcf7 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    156e:	b130      	cbz	r0, 157e <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x4a>
    1570:	4806      	ldr	r0, [pc, #24]	; (158c <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA+0x58>)
    1572:	3031      	adds	r0, #49	; 0x31
    1574:	6060      	str	r0, [r4, #4]
    1576:	7065      	strb	r5, [r4, #1]
    1578:	2004      	movs	r0, #4
    157a:	70a0      	strb	r0, [r4, #2]
    157c:	bd70      	pop	{r4, r5, r6, pc}
    157e:	21e8      	movs	r1, #232	; 0xe8
    1580:	2074      	movs	r0, #116	; 0x74
    1582:	f003 fb17 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1586:	0000      	.short	0x0000
    1588:	20000028 	.word	0x20000028
    158c:	00010db6 	.word	0x00010db6

00001590 <mpsl_tx_power_radio_supported_power_adjust>:
    1590:	4907      	ldr	r1, [pc, #28]	; (15b0 <mpsl_tx_power_radio_supported_power_adjust+0x20>)
    1592:	f991 2002 	ldrsb.w	r2, [r1, #2]
    1596:	4290      	cmp	r0, r2
    1598:	da03      	bge.n	15a2 <mpsl_tx_power_radio_supported_power_adjust+0x12>
    159a:	f991 2001 	ldrsb.w	r2, [r1, #1]
    159e:	4290      	cmp	r0, r2
    15a0:	dc01      	bgt.n	15a6 <mpsl_tx_power_radio_supported_power_adjust+0x16>
    15a2:	4610      	mov	r0, r2
    15a4:	4770      	bx	lr
    15a6:	6849      	ldr	r1, [r1, #4]
    15a8:	1a80      	subs	r0, r0, r2
    15aa:	5608      	ldrsb	r0, [r1, r0]
    15ac:	4770      	bx	lr
    15ae:	0000      	.short	0x0000
    15b0:	20000028 	.word	0x20000028

000015b4 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ>:
    15b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    15b8:	461c      	mov	r4, r3
    15ba:	4690      	mov	r8, r2
    15bc:	460d      	mov	r5, r1
    15be:	4606      	mov	r6, r0
    15c0:	f06f 0715 	mvn.w	r7, #21
    15c4:	2804      	cmp	r0, #4
    15c6:	d804      	bhi.n	15d2 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x1e>
    15c8:	b11c      	cbz	r4, 15d2 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x1e>
    15ca:	f00b fb76 	bl	ccba <strlen+0x10>
    15ce:	42a8      	cmp	r0, r5
    15d0:	d802      	bhi.n	15d8 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x24>
    15d2:	4638      	mov	r0, r7
    15d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    15d8:	4805      	ldr	r0, [pc, #20]	; (15f0 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x3c>)
    15da:	4642      	mov	r2, r8
    15dc:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
    15e0:	b118      	cbz	r0, 15ea <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x36>
    15e2:	5740      	ldrsb	r0, [r0, r5]
    15e4:	4282      	cmp	r2, r0
    15e6:	dd00      	ble.n	15ea <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x36>
    15e8:	4602      	mov	r2, r0
    15ea:	7022      	strb	r2, [r4, #0]
    15ec:	2000      	movs	r0, #0
    15ee:	e7f1      	b.n	15d4 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ+0x20>
    15f0:	200011b8 	.word	0x200011b8

000015f4 <sym_SKFSQME5SGNPYLL7B75KY7PHXFYWSRI2HSTT45A>:
    15f4:	4801      	ldr	r0, [pc, #4]	; (15fc <sym_SKFSQME5SGNPYLL7B75KY7PHXFYWSRI2HSTT45A+0x8>)
    15f6:	7800      	ldrb	r0, [r0, #0]
    15f8:	4770      	bx	lr
    15fa:	0000      	.short	0x0000
    15fc:	20000030 	.word	0x20000030

00001600 <sym_4RNEPYYQOFM4LAOGLN2TB27X7L3XBISTGAWYOHQ>:
    1600:	4905      	ldr	r1, [pc, #20]	; (1618 <sym_4RNEPYYQOFM4LAOGLN2TB27X7L3XBISTGAWYOHQ+0x18>)
    1602:	780a      	ldrb	r2, [r1, #0]
    1604:	4290      	cmp	r0, r2
    1606:	d301      	bcc.n	160c <sym_4RNEPYYQOFM4LAOGLN2TB27X7L3XBISTGAWYOHQ+0xc>
    1608:	2000      	movs	r0, #0
    160a:	4770      	bx	lr
    160c:	6849      	ldr	r1, [r1, #4]
    160e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    1612:	eb01 1000 	add.w	r0, r1, r0, lsl #4
    1616:	4770      	bx	lr
    1618:	20000030 	.word	0x20000030

0000161c <MPSL_IRQ_RADIO_Handler>:
    161c:	490e      	ldr	r1, [pc, #56]	; (1658 <MPSL_IRQ_RADIO_Handler+0x3c>)
    161e:	b510      	push	{r4, lr}
    1620:	f891 002d 	ldrb.w	r0, [r1, #45]	; 0x2d
    1624:	2820      	cmp	r0, #32
    1626:	d012      	beq.n	164e <MPSL_IRQ_RADIO_Handler+0x32>
    1628:	f891 002d 	ldrb.w	r0, [r1, #45]	; 0x2d
    162c:	f5a1 6280 	sub.w	r2, r1, #1024	; 0x400
    1630:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    1634:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    1638:	f891 102d 	ldrb.w	r1, [r1, #45]	; 0x2d
    163c:	6840      	ldr	r0, [r0, #4]
    163e:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    1642:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    1646:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    164a:	2104      	movs	r1, #4
    164c:	4710      	bx	r2
    164e:	f640 0187 	movw	r1, #2183	; 0x887
    1652:	2070      	movs	r0, #112	; 0x70
    1654:	f003 faae 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1658:	200015cc 	.word	0x200015cc
    165c:	b570      	push	{r4, r5, r6, lr}
    165e:	4605      	mov	r5, r0
    1660:	2a20      	cmp	r2, #32
    1662:	d028      	beq.n	16b6 <MPSL_IRQ_RADIO_Handler+0x9a>
    1664:	4819      	ldr	r0, [pc, #100]	; (16cc <MPSL_IRQ_RADIO_Handler+0xb0>)
    1666:	4c1a      	ldr	r4, [pc, #104]	; (16d0 <MPSL_IRQ_RADIO_Handler+0xb4>)
    1668:	eb00 1c83 	add.w	ip, r0, r3, lsl #6
    166c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1670:	eb0c 0042 	add.w	r0, ip, r2, lsl #1
    1674:	4423      	add	r3, r4
    1676:	2920      	cmp	r1, #32
    1678:	d022      	beq.n	16c0 <MPSL_IRQ_RADIO_Handler+0xa4>
    167a:	eb0c 0141 	add.w	r1, ip, r1, lsl #1
    167e:	7840      	ldrb	r0, [r0, #1]
    1680:	784c      	ldrb	r4, [r1, #1]
    1682:	7048      	strb	r0, [r1, #1]
    1684:	4620      	mov	r0, r4
    1686:	4601      	mov	r1, r0
    1688:	eb0c 0041 	add.w	r0, ip, r1, lsl #1
    168c:	4291      	cmp	r1, r2
    168e:	7005      	strb	r5, [r0, #0]
    1690:	7840      	ldrb	r0, [r0, #1]
    1692:	d1f8      	bne.n	1686 <MPSL_IRQ_RADIO_Handler+0x6a>
    1694:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
    1698:	2a20      	cmp	r2, #32
    169a:	bf1a      	itte	ne
    169c:	eb0c 0242 	addne.w	r2, ip, r2, lsl #1
    16a0:	7054      	strbne	r4, [r2, #1]
    16a2:	f883 4021 	strbeq.w	r4, [r3, #33]	; 0x21
    16a6:	2220      	movs	r2, #32
    16a8:	eb0c 0c41 	add.w	ip, ip, r1, lsl #1
    16ac:	f88c 2001 	strb.w	r2, [ip, #1]
    16b0:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
    16b4:	bd70      	pop	{r4, r5, r6, pc}
    16b6:	f240 2192 	movw	r1, #658	; 0x292
    16ba:	2070      	movs	r0, #112	; 0x70
    16bc:	f003 fa7a 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    16c0:	f893 4020 	ldrb.w	r4, [r3, #32]
    16c4:	7840      	ldrb	r0, [r0, #1]
    16c6:	f883 0020 	strb.w	r0, [r3, #32]
    16ca:	e7db      	b.n	1684 <MPSL_IRQ_RADIO_Handler+0x68>
    16cc:	2000154c 	.word	0x2000154c
    16d0:	200015cc 	.word	0x200015cc
    16d4:	e92d 4fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    16d8:	b085      	sub	sp, #20
    16da:	4615      	mov	r5, r2
    16dc:	460c      	mov	r4, r1
    16de:	f002 f9c5 	bl	3a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>
    16e2:	4428      	add	r0, r5
    16e4:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    16e8:	9102      	str	r1, [sp, #8]
    16ea:	6820      	ldr	r0, [r4, #0]
    16ec:	1a40      	subs	r0, r0, r1
    16ee:	0200      	lsls	r0, r0, #8
    16f0:	17c1      	asrs	r1, r0, #31
    16f2:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    16f6:	1200      	asrs	r0, r0, #8
    16f8:	2800      	cmp	r0, #0
    16fa:	f300 80f0 	bgt.w	18de <MPSL_IRQ_RADIO_Handler+0x2c2>
    16fe:	f8dd 8020 	ldr.w	r8, [sp, #32]
    1702:	48ca      	ldr	r0, [pc, #808]	; (1a2c <MPSL_IRQ_RADIO_Handler+0x410>)
    1704:	eb08 0148 	add.w	r1, r8, r8, lsl #1
    1708:	4408      	add	r0, r1
    170a:	9003      	str	r0, [sp, #12]
    170c:	f890 5020 	ldrb.w	r5, [r0, #32]
    1710:	2020      	movs	r0, #32
    1712:	4ec7      	ldr	r6, [pc, #796]	; (1a30 <MPSL_IRQ_RADIO_Handler+0x414>)
    1714:	46ea      	mov	sl, sp
    1716:	f10d 0904 	add.w	r9, sp, #4
    171a:	f88d 0000 	strb.w	r0, [sp]
    171e:	2d20      	cmp	r5, #32
    1720:	bf1c      	itt	ne
    1722:	48c4      	ldrne	r0, [pc, #784]	; (1a34 <MPSL_IRQ_RADIO_Handler+0x418>)
    1724:	eb00 1b88 	addne.w	fp, r0, r8, lsl #6
    1728:	d039      	beq.n	179e <MPSL_IRQ_RADIO_Handler+0x182>
    172a:	bf00      	nop
    172c:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    1730:	eb06 0080 	add.w	r0, r6, r0, lsl #2
    1734:	f100 0108 	add.w	r1, r0, #8
    1738:	68c0      	ldr	r0, [r0, #12]
    173a:	6827      	ldr	r7, [r4, #0]
    173c:	1a38      	subs	r0, r7, r0
    173e:	0200      	lsls	r0, r0, #8
    1740:	17c2      	asrs	r2, r0, #31
    1742:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1746:	1200      	asrs	r0, r0, #8
    1748:	d429      	bmi.n	179e <MPSL_IRQ_RADIO_Handler+0x182>
    174a:	89e0      	ldrh	r0, [r4, #14]
    174c:	b300      	cbz	r0, 1790 <MPSL_IRQ_RADIO_Handler+0x174>
    174e:	89c8      	ldrh	r0, [r1, #14]
    1750:	b9f0      	cbnz	r0, 1790 <MPSL_IRQ_RADIO_Handler+0x174>
    1752:	6808      	ldr	r0, [r1, #0]
    1754:	9004      	str	r0, [sp, #16]
    1756:	f003 f883 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    175a:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    175e:	bf08      	it	eq
    1760:	200d      	moveq	r0, #13
    1762:	d00b      	beq.n	177c <MPSL_IRQ_RADIO_Handler+0x160>
    1764:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1768:	3856      	subs	r0, #86	; 0x56
    176a:	bf08      	it	eq
    176c:	201c      	moveq	r0, #28
    176e:	d005      	beq.n	177c <MPSL_IRQ_RADIO_Handler+0x160>
    1770:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1774:	389f      	subs	r0, #159	; 0x9f
    1776:	bf14      	ite	ne
    1778:	2000      	movne	r0, #0
    177a:	2032      	moveq	r0, #50	; 0x32
    177c:	1c41      	adds	r1, r0, #1
    177e:	9804      	ldr	r0, [sp, #16]
    1780:	1a38      	subs	r0, r7, r0
    1782:	0200      	lsls	r0, r0, #8
    1784:	17c2      	asrs	r2, r0, #31
    1786:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    178a:	1200      	asrs	r0, r0, #8
    178c:	4288      	cmp	r0, r1
    178e:	db06      	blt.n	179e <MPSL_IRQ_RADIO_Handler+0x182>
    1790:	eb0b 0045 	add.w	r0, fp, r5, lsl #1
    1794:	f88a 5000 	strb.w	r5, [sl]
    1798:	7845      	ldrb	r5, [r0, #1]
    179a:	2d20      	cmp	r5, #32
    179c:	d1c6      	bne.n	172c <MPSL_IRQ_RADIO_Handler+0x110>
    179e:	f89a 0000 	ldrb.w	r0, [sl]
    17a2:	f889 0000 	strb.w	r0, [r9]
    17a6:	2d20      	cmp	r5, #32
    17a8:	bf1c      	itt	ne
    17aa:	48a2      	ldrne	r0, [pc, #648]	; (1a34 <MPSL_IRQ_RADIO_Handler+0x418>)
    17ac:	eb00 1b88 	addne.w	fp, r0, r8, lsl #6
    17b0:	f000 8138 	beq.w	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    17b4:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    17b8:	eb06 0780 	add.w	r7, r6, r0, lsl #2
    17bc:	6860      	ldr	r0, [r4, #4]
    17be:	f8d7 8008 	ldr.w	r8, [r7, #8]
    17c2:	f107 0108 	add.w	r1, r7, #8
    17c6:	eba8 0000 	sub.w	r0, r8, r0
    17ca:	0200      	lsls	r0, r0, #8
    17cc:	17c2      	asrs	r2, r0, #31
    17ce:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    17d2:	1200      	asrs	r0, r0, #8
    17d4:	d427      	bmi.n	1826 <MPSL_IRQ_RADIO_Handler+0x20a>
    17d6:	89c8      	ldrh	r0, [r1, #14]
    17d8:	2800      	cmp	r0, #0
    17da:	f000 8123 	beq.w	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    17de:	89e0      	ldrh	r0, [r4, #14]
    17e0:	2800      	cmp	r0, #0
    17e2:	f040 811f 	bne.w	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    17e6:	f8d4 a000 	ldr.w	sl, [r4]
    17ea:	f003 f839 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    17ee:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    17f2:	bf08      	it	eq
    17f4:	200d      	moveq	r0, #13
    17f6:	d00b      	beq.n	1810 <MPSL_IRQ_RADIO_Handler+0x1f4>
    17f8:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    17fc:	3856      	subs	r0, #86	; 0x56
    17fe:	bf08      	it	eq
    1800:	201c      	moveq	r0, #28
    1802:	d005      	beq.n	1810 <MPSL_IRQ_RADIO_Handler+0x1f4>
    1804:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1808:	389f      	subs	r0, #159	; 0x9f
    180a:	bf14      	ite	ne
    180c:	2000      	movne	r0, #0
    180e:	2032      	moveq	r0, #50	; 0x32
    1810:	1c41      	adds	r1, r0, #1
    1812:	eba8 000a 	sub.w	r0, r8, sl
    1816:	0200      	lsls	r0, r0, #8
    1818:	17c2      	asrs	r2, r0, #31
    181a:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    181e:	1200      	asrs	r0, r0, #8
    1820:	4288      	cmp	r0, r1
    1822:	f280 80ff 	bge.w	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    1826:	f889 5000 	strb.w	r5, [r9]
    182a:	7e39      	ldrb	r1, [r7, #24]
    182c:	7c20      	ldrb	r0, [r4, #16]
    182e:	4281      	cmp	r1, r0
    1830:	d906      	bls.n	1840 <MPSL_IRQ_RADIO_Handler+0x224>
    1832:	eb0b 0045 	add.w	r0, fp, r5, lsl #1
    1836:	7845      	ldrb	r5, [r0, #1]
    1838:	2d20      	cmp	r5, #32
    183a:	d1bb      	bne.n	17b4 <MPSL_IRQ_RADIO_Handler+0x198>
    183c:	f000 b8f2 	b.w	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    1840:	f89d 0004 	ldrb.w	r0, [sp, #4]
    1844:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    1848:	eb06 0080 	add.w	r0, r6, r0, lsl #2
    184c:	8ac1      	ldrh	r1, [r0, #22]
    184e:	68c5      	ldr	r5, [r0, #12]
    1850:	bbe1      	cbnz	r1, 18cc <MPSL_IRQ_RADIO_Handler+0x2b0>
    1852:	89e1      	ldrh	r1, [r4, #14]
    1854:	b3d1      	cbz	r1, 18cc <MPSL_IRQ_RADIO_Handler+0x2b0>
    1856:	6887      	ldr	r7, [r0, #8]
    1858:	f003 f802 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    185c:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1860:	bf08      	it	eq
    1862:	200d      	moveq	r0, #13
    1864:	d00b      	beq.n	187e <MPSL_IRQ_RADIO_Handler+0x262>
    1866:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    186a:	3856      	subs	r0, #86	; 0x56
    186c:	bf08      	it	eq
    186e:	201c      	moveq	r0, #28
    1870:	d005      	beq.n	187e <MPSL_IRQ_RADIO_Handler+0x262>
    1872:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1876:	389f      	subs	r0, #159	; 0x9f
    1878:	bf14      	ite	ne
    187a:	2000      	movne	r0, #0
    187c:	2032      	moveq	r0, #50	; 0x32
    187e:	1c41      	adds	r1, r0, #1
    1880:	1be8      	subs	r0, r5, r7
    1882:	0200      	lsls	r0, r0, #8
    1884:	17c2      	asrs	r2, r0, #31
    1886:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    188a:	1200      	asrs	r0, r0, #8
    188c:	4288      	cmp	r0, r1
    188e:	da1d      	bge.n	18cc <MPSL_IRQ_RADIO_Handler+0x2b0>
    1890:	f002 ffe6 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    1894:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1898:	bf08      	it	eq
    189a:	200d      	moveq	r0, #13
    189c:	d00b      	beq.n	18b6 <MPSL_IRQ_RADIO_Handler+0x29a>
    189e:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    18a2:	3856      	subs	r0, #86	; 0x56
    18a4:	bf08      	it	eq
    18a6:	201c      	moveq	r0, #28
    18a8:	d005      	beq.n	18b6 <MPSL_IRQ_RADIO_Handler+0x29a>
    18aa:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    18ae:	389f      	subs	r0, #159	; 0x9f
    18b0:	bf14      	ite	ne
    18b2:	2000      	movne	r0, #0
    18b4:	2032      	moveq	r0, #50	; 0x32
    18b6:	f89d 1004 	ldrb.w	r1, [sp, #4]
    18ba:	1c40      	adds	r0, r0, #1
    18bc:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    18c0:	eb06 0181 	add.w	r1, r6, r1, lsl #2
    18c4:	6889      	ldr	r1, [r1, #8]
    18c6:	4408      	add	r0, r1
    18c8:	f020 457f 	bic.w	r5, r0, #4278190080	; 0xff000000
    18cc:	9802      	ldr	r0, [sp, #8]
    18ce:	1a28      	subs	r0, r5, r0
    18d0:	0200      	lsls	r0, r0, #8
    18d2:	17c1      	asrs	r1, r0, #31
    18d4:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    18d8:	1200      	asrs	r0, r0, #8
    18da:	2800      	cmp	r0, #0
    18dc:	dd03      	ble.n	18e6 <MPSL_IRQ_RADIO_Handler+0x2ca>
    18de:	b009      	add	sp, #36	; 0x24
    18e0:	2000      	movs	r0, #0
    18e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    18e6:	e9d4 1000 	ldrd	r1, r0, [r4]
    18ea:	1a40      	subs	r0, r0, r1
    18ec:	4428      	add	r0, r5
    18ee:	f025 417f 	bic.w	r1, r5, #4278190080	; 0xff000000
    18f2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    18f6:	e9c4 1000 	strd	r1, r0, [r4]
    18fa:	9808      	ldr	r0, [sp, #32]
    18fc:	9004      	str	r0, [sp, #16]
    18fe:	9803      	ldr	r0, [sp, #12]
    1900:	46ea      	mov	sl, sp
    1902:	f10d 0804 	add.w	r8, sp, #4
    1906:	f890 5020 	ldrb.w	r5, [r0, #32]
    190a:	2020      	movs	r0, #32
    190c:	f88d 0000 	strb.w	r0, [sp]
    1910:	2d20      	cmp	r5, #32
    1912:	d03c      	beq.n	198e <MPSL_IRQ_RADIO_Handler+0x372>
    1914:	4847      	ldr	r0, [pc, #284]	; (1a34 <MPSL_IRQ_RADIO_Handler+0x418>)
    1916:	9904      	ldr	r1, [sp, #16]
    1918:	eb00 1b81 	add.w	fp, r0, r1, lsl #6
    191c:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    1920:	eb06 0080 	add.w	r0, r6, r0, lsl #2
    1924:	f100 0108 	add.w	r1, r0, #8
    1928:	68c0      	ldr	r0, [r0, #12]
    192a:	6827      	ldr	r7, [r4, #0]
    192c:	1a38      	subs	r0, r7, r0
    192e:	0200      	lsls	r0, r0, #8
    1930:	17c2      	asrs	r2, r0, #31
    1932:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1936:	1200      	asrs	r0, r0, #8
    1938:	d429      	bmi.n	198e <MPSL_IRQ_RADIO_Handler+0x372>
    193a:	89e0      	ldrh	r0, [r4, #14]
    193c:	b300      	cbz	r0, 1980 <MPSL_IRQ_RADIO_Handler+0x364>
    193e:	89c8      	ldrh	r0, [r1, #14]
    1940:	b9f0      	cbnz	r0, 1980 <MPSL_IRQ_RADIO_Handler+0x364>
    1942:	f8d1 9000 	ldr.w	r9, [r1]
    1946:	f002 ff8b 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    194a:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    194e:	bf08      	it	eq
    1950:	200d      	moveq	r0, #13
    1952:	d00b      	beq.n	196c <MPSL_IRQ_RADIO_Handler+0x350>
    1954:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1958:	3856      	subs	r0, #86	; 0x56
    195a:	bf08      	it	eq
    195c:	201c      	moveq	r0, #28
    195e:	d005      	beq.n	196c <MPSL_IRQ_RADIO_Handler+0x350>
    1960:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1964:	389f      	subs	r0, #159	; 0x9f
    1966:	bf14      	ite	ne
    1968:	2000      	movne	r0, #0
    196a:	2032      	moveq	r0, #50	; 0x32
    196c:	1c41      	adds	r1, r0, #1
    196e:	eba7 0009 	sub.w	r0, r7, r9
    1972:	0200      	lsls	r0, r0, #8
    1974:	17c2      	asrs	r2, r0, #31
    1976:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    197a:	1200      	asrs	r0, r0, #8
    197c:	4288      	cmp	r0, r1
    197e:	db06      	blt.n	198e <MPSL_IRQ_RADIO_Handler+0x372>
    1980:	eb0b 0045 	add.w	r0, fp, r5, lsl #1
    1984:	f88a 5000 	strb.w	r5, [sl]
    1988:	7845      	ldrb	r5, [r0, #1]
    198a:	2d20      	cmp	r5, #32
    198c:	d1c6      	bne.n	191c <MPSL_IRQ_RADIO_Handler+0x300>
    198e:	f89a 0000 	ldrb.w	r0, [sl]
    1992:	f888 0000 	strb.w	r0, [r8]
    1996:	9804      	ldr	r0, [sp, #16]
    1998:	2d20      	cmp	r5, #32
    199a:	bf1c      	itt	ne
    199c:	4925      	ldrne	r1, [pc, #148]	; (1a34 <MPSL_IRQ_RADIO_Handler+0x418>)
    199e:	eb01 1b80 	addne.w	fp, r1, r0, lsl #6
    19a2:	d03f      	beq.n	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    19a4:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    19a8:	eb06 0780 	add.w	r7, r6, r0, lsl #2
    19ac:	6861      	ldr	r1, [r4, #4]
    19ae:	f8d7 9008 	ldr.w	r9, [r7, #8]
    19b2:	f107 0008 	add.w	r0, r7, #8
    19b6:	eba9 0101 	sub.w	r1, r9, r1
    19ba:	0209      	lsls	r1, r1, #8
    19bc:	17ca      	asrs	r2, r1, #31
    19be:	eb01 6112 	add.w	r1, r1, r2, lsr #24
    19c2:	1209      	asrs	r1, r1, #8
    19c4:	d422      	bmi.n	1a0c <MPSL_IRQ_RADIO_Handler+0x3f0>
    19c6:	89c0      	ldrh	r0, [r0, #14]
    19c8:	b360      	cbz	r0, 1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    19ca:	89e0      	ldrh	r0, [r4, #14]
    19cc:	bb50      	cbnz	r0, 1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    19ce:	f8d4 a000 	ldr.w	sl, [r4]
    19d2:	f002 ff45 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    19d6:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    19da:	bf08      	it	eq
    19dc:	200d      	moveq	r0, #13
    19de:	d00b      	beq.n	19f8 <MPSL_IRQ_RADIO_Handler+0x3dc>
    19e0:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    19e4:	3856      	subs	r0, #86	; 0x56
    19e6:	bf08      	it	eq
    19e8:	201c      	moveq	r0, #28
    19ea:	d005      	beq.n	19f8 <MPSL_IRQ_RADIO_Handler+0x3dc>
    19ec:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    19f0:	389f      	subs	r0, #159	; 0x9f
    19f2:	bf14      	ite	ne
    19f4:	2000      	movne	r0, #0
    19f6:	2032      	moveq	r0, #50	; 0x32
    19f8:	1c41      	adds	r1, r0, #1
    19fa:	eba9 000a 	sub.w	r0, r9, sl
    19fe:	0200      	lsls	r0, r0, #8
    1a00:	17c2      	asrs	r2, r0, #31
    1a02:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1a06:	1200      	asrs	r0, r0, #8
    1a08:	4288      	cmp	r0, r1
    1a0a:	da0b      	bge.n	1a24 <MPSL_IRQ_RADIO_Handler+0x408>
    1a0c:	f888 5000 	strb.w	r5, [r8]
    1a10:	7e38      	ldrb	r0, [r7, #24]
    1a12:	7c21      	ldrb	r1, [r4, #16]
    1a14:	4288      	cmp	r0, r1
    1a16:	f67f af13 	bls.w	1840 <MPSL_IRQ_RADIO_Handler+0x224>
    1a1a:	eb0b 0045 	add.w	r0, fp, r5, lsl #1
    1a1e:	7845      	ldrb	r5, [r0, #1]
    1a20:	2d20      	cmp	r5, #32
    1a22:	d1bf      	bne.n	19a4 <MPSL_IRQ_RADIO_Handler+0x388>
    1a24:	b009      	add	sp, #36	; 0x24
    1a26:	2001      	movs	r0, #1
    1a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1a2c:	200015cc 	.word	0x200015cc
    1a30:	200011cc 	.word	0x200011cc
    1a34:	2000154c 	.word	0x2000154c
    1a38:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1a3c:	460f      	mov	r7, r1
    1a3e:	4606      	mov	r6, r0
    1a40:	eb01 0047 	add.w	r0, r1, r7, lsl #1
    1a44:	494b      	ldr	r1, [pc, #300]	; (1b74 <MPSL_IRQ_RADIO_Handler+0x558>)
    1a46:	4699      	mov	r9, r3
    1a48:	4408      	add	r0, r1
    1a4a:	4692      	mov	sl, r2
    1a4c:	f890 4020 	ldrb.w	r4, [r0, #32]
    1a50:	2020      	movs	r0, #32
    1a52:	7010      	strb	r0, [r2, #0]
    1a54:	f5a1 6880 	sub.w	r8, r1, #1024	; 0x400
    1a58:	2c20      	cmp	r4, #32
    1a5a:	bf1c      	itt	ne
    1a5c:	4846      	ldrne	r0, [pc, #280]	; (1b78 <MPSL_IRQ_RADIO_Handler+0x55c>)
    1a5e:	eb00 1b87 	addne.w	fp, r0, r7, lsl #6
    1a62:	d038      	beq.n	1ad6 <MPSL_IRQ_RADIO_Handler+0x4ba>
    1a64:	ebc4 00c4 	rsb	r0, r4, r4, lsl #3
    1a68:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    1a6c:	f100 0108 	add.w	r1, r0, #8
    1a70:	68c0      	ldr	r0, [r0, #12]
    1a72:	6835      	ldr	r5, [r6, #0]
    1a74:	1a28      	subs	r0, r5, r0
    1a76:	0200      	lsls	r0, r0, #8
    1a78:	17c2      	asrs	r2, r0, #31
    1a7a:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1a7e:	1200      	asrs	r0, r0, #8
    1a80:	d429      	bmi.n	1ad6 <MPSL_IRQ_RADIO_Handler+0x4ba>
    1a82:	89f0      	ldrh	r0, [r6, #14]
    1a84:	b300      	cbz	r0, 1ac8 <MPSL_IRQ_RADIO_Handler+0x4ac>
    1a86:	89c8      	ldrh	r0, [r1, #14]
    1a88:	b9f0      	cbnz	r0, 1ac8 <MPSL_IRQ_RADIO_Handler+0x4ac>
    1a8a:	6808      	ldr	r0, [r1, #0]
    1a8c:	9000      	str	r0, [sp, #0]
    1a8e:	f002 fee7 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    1a92:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1a96:	bf08      	it	eq
    1a98:	200d      	moveq	r0, #13
    1a9a:	d00b      	beq.n	1ab4 <MPSL_IRQ_RADIO_Handler+0x498>
    1a9c:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1aa0:	3856      	subs	r0, #86	; 0x56
    1aa2:	bf08      	it	eq
    1aa4:	201c      	moveq	r0, #28
    1aa6:	d005      	beq.n	1ab4 <MPSL_IRQ_RADIO_Handler+0x498>
    1aa8:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1aac:	389f      	subs	r0, #159	; 0x9f
    1aae:	bf14      	ite	ne
    1ab0:	2000      	movne	r0, #0
    1ab2:	2032      	moveq	r0, #50	; 0x32
    1ab4:	1c41      	adds	r1, r0, #1
    1ab6:	9800      	ldr	r0, [sp, #0]
    1ab8:	1a28      	subs	r0, r5, r0
    1aba:	0200      	lsls	r0, r0, #8
    1abc:	17c2      	asrs	r2, r0, #31
    1abe:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1ac2:	1200      	asrs	r0, r0, #8
    1ac4:	4288      	cmp	r0, r1
    1ac6:	db06      	blt.n	1ad6 <MPSL_IRQ_RADIO_Handler+0x4ba>
    1ac8:	eb0b 0044 	add.w	r0, fp, r4, lsl #1
    1acc:	f88a 4000 	strb.w	r4, [sl]
    1ad0:	7844      	ldrb	r4, [r0, #1]
    1ad2:	2c20      	cmp	r4, #32
    1ad4:	d1c6      	bne.n	1a64 <MPSL_IRQ_RADIO_Handler+0x448>
    1ad6:	f89a 0000 	ldrb.w	r0, [sl]
    1ada:	f889 0000 	strb.w	r0, [r9]
    1ade:	2c20      	cmp	r4, #32
    1ae0:	bf1c      	itt	ne
    1ae2:	4825      	ldrne	r0, [pc, #148]	; (1b78 <MPSL_IRQ_RADIO_Handler+0x55c>)
    1ae4:	eb00 1a87 	addne.w	sl, r0, r7, lsl #6
    1ae8:	d040      	beq.n	1b6c <MPSL_IRQ_RADIO_Handler+0x550>
    1aea:	bf00      	nop
    1aec:	ebc4 00c4 	rsb	r0, r4, r4, lsl #3
    1af0:	eb08 0780 	add.w	r7, r8, r0, lsl #2
    1af4:	6870      	ldr	r0, [r6, #4]
    1af6:	68bd      	ldr	r5, [r7, #8]
    1af8:	f107 0108 	add.w	r1, r7, #8
    1afc:	1a28      	subs	r0, r5, r0
    1afe:	0200      	lsls	r0, r0, #8
    1b00:	17c2      	asrs	r2, r0, #31
    1b02:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1b06:	1200      	asrs	r0, r0, #8
    1b08:	d422      	bmi.n	1b50 <MPSL_IRQ_RADIO_Handler+0x534>
    1b0a:	89c8      	ldrh	r0, [r1, #14]
    1b0c:	b370      	cbz	r0, 1b6c <MPSL_IRQ_RADIO_Handler+0x550>
    1b0e:	89f0      	ldrh	r0, [r6, #14]
    1b10:	bb60      	cbnz	r0, 1b6c <MPSL_IRQ_RADIO_Handler+0x550>
    1b12:	f8d6 b000 	ldr.w	fp, [r6]
    1b16:	f002 fea3 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    1b1a:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1b1e:	bf08      	it	eq
    1b20:	200d      	moveq	r0, #13
    1b22:	d00b      	beq.n	1b3c <MPSL_IRQ_RADIO_Handler+0x520>
    1b24:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1b28:	3856      	subs	r0, #86	; 0x56
    1b2a:	bf08      	it	eq
    1b2c:	201c      	moveq	r0, #28
    1b2e:	d005      	beq.n	1b3c <MPSL_IRQ_RADIO_Handler+0x520>
    1b30:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1b34:	389f      	subs	r0, #159	; 0x9f
    1b36:	bf14      	ite	ne
    1b38:	2000      	movne	r0, #0
    1b3a:	2032      	moveq	r0, #50	; 0x32
    1b3c:	1c41      	adds	r1, r0, #1
    1b3e:	eba5 000b 	sub.w	r0, r5, fp
    1b42:	0200      	lsls	r0, r0, #8
    1b44:	17c2      	asrs	r2, r0, #31
    1b46:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    1b4a:	1200      	asrs	r0, r0, #8
    1b4c:	4288      	cmp	r0, r1
    1b4e:	da0d      	bge.n	1b6c <MPSL_IRQ_RADIO_Handler+0x550>
    1b50:	f889 4000 	strb.w	r4, [r9]
    1b54:	7e38      	ldrb	r0, [r7, #24]
    1b56:	7c31      	ldrb	r1, [r6, #16]
    1b58:	4288      	cmp	r0, r1
    1b5a:	d802      	bhi.n	1b62 <MPSL_IRQ_RADIO_Handler+0x546>
    1b5c:	2000      	movs	r0, #0
    1b5e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1b62:	eb0a 0044 	add.w	r0, sl, r4, lsl #1
    1b66:	7844      	ldrb	r4, [r0, #1]
    1b68:	2c20      	cmp	r4, #32
    1b6a:	d1bf      	bne.n	1aec <MPSL_IRQ_RADIO_Handler+0x4d0>
    1b6c:	2001      	movs	r0, #1
    1b6e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1b72:	0000      	.short	0x0000
    1b74:	200015cc 	.word	0x200015cc
    1b78:	2000154c 	.word	0x2000154c
    1b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1b80:	b082      	sub	sp, #8
    1b82:	4605      	mov	r5, r0
    1b84:	4614      	mov	r4, r2
    1b86:	4688      	mov	r8, r1
    1b88:	89d0      	ldrh	r0, [r2, #14]
    1b8a:	aa01      	add	r2, sp, #4
    1b8c:	4669      	mov	r1, sp
    1b8e:	f001 ff89 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    1b92:	f002 fc97 	bl	44c4 <sym_HUWGHJMM42MANQTSVL3EY7E3VE4XM4JTQUIQAII>
    1b96:	f001 ff69 	bl	3a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>
    1b9a:	4607      	mov	r7, r0
    1b9c:	4820      	ldr	r0, [pc, #128]	; (1c20 <MPSL_IRQ_RADIO_Handler+0x604>)
    1b9e:	f890 102d 	ldrb.w	r1, [r0, #45]	; 0x2d
    1ba2:	2920      	cmp	r1, #32
    1ba4:	d004      	beq.n	1bb0 <MPSL_IRQ_RADIO_Handler+0x594>
    1ba6:	68c0      	ldr	r0, [r0, #12]
    1ba8:	1d40      	adds	r0, r0, #5
    1baa:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    1bae:	e024      	b.n	1bfa <MPSL_IRQ_RADIO_Handler+0x5de>
    1bb0:	89e0      	ldrh	r0, [r4, #14]
    1bb2:	f105 0609 	add.w	r6, r5, #9
    1bb6:	b1b0      	cbz	r0, 1be6 <MPSL_IRQ_RADIO_Handler+0x5ca>
    1bb8:	f002 ff84 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    1bbc:	b998      	cbnz	r0, 1be6 <MPSL_IRQ_RADIO_Handler+0x5ca>
    1bbe:	f002 fe4f 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    1bc2:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1bc6:	bf08      	it	eq
    1bc8:	200d      	moveq	r0, #13
    1bca:	d00b      	beq.n	1be4 <MPSL_IRQ_RADIO_Handler+0x5c8>
    1bcc:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1bd0:	3856      	subs	r0, #86	; 0x56
    1bd2:	bf08      	it	eq
    1bd4:	201c      	moveq	r0, #28
    1bd6:	d005      	beq.n	1be4 <MPSL_IRQ_RADIO_Handler+0x5c8>
    1bd8:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1bdc:	389f      	subs	r0, #159	; 0x9f
    1bde:	bf14      	ite	ne
    1be0:	2000      	movne	r0, #0
    1be2:	2032      	moveq	r0, #50	; 0x32
    1be4:	4406      	add	r6, r0
    1be6:	f1b8 0f00 	cmp.w	r8, #0
    1bea:	d104      	bne.n	1bf6 <MPSL_IRQ_RADIO_Handler+0x5da>
    1bec:	9800      	ldr	r0, [sp, #0]
    1bee:	4287      	cmp	r7, r0
    1bf0:	bf84      	itt	hi
    1bf2:	1a38      	subhi	r0, r7, r0
    1bf4:	4406      	addhi	r6, r0
    1bf6:	f026 417f 	bic.w	r1, r6, #4278190080	; 0xff000000
    1bfa:	e9d4 2000 	ldrd	r2, r0, [r4]
    1bfe:	1a80      	subs	r0, r0, r2
    1c00:	4408      	add	r0, r1
    1c02:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1c06:	e9c4 1000 	strd	r1, r0, [r4]
    1c0a:	42a9      	cmp	r1, r5
    1c0c:	bf24      	itt	cs
    1c0e:	b002      	addcs	sp, #8
    1c10:	e8bd 81f0 	ldmiacs.w	sp!, {r4, r5, r6, r7, r8, pc}
    1c14:	68a0      	ldr	r0, [r4, #8]
    1c16:	1c40      	adds	r0, r0, #1
    1c18:	60a0      	str	r0, [r4, #8]
    1c1a:	b002      	add	sp, #8
    1c1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1c20:	200015cc 	.word	0x200015cc
    1c24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1c28:	b097      	sub	sp, #92	; 0x5c
    1c2a:	4617      	mov	r7, r2
    1c2c:	468b      	mov	fp, r1
    1c2e:	4605      	mov	r5, r0
    1c30:	f002 f9ca 	bl	3fc8 <sym_RUQO26WM5KVVEW7O3OHCXPO7LLLXRBDPIPSWIWY>
    1c34:	4604      	mov	r4, r0
    1c36:	f002 fc45 	bl	44c4 <sym_HUWGHJMM42MANQTSVL3EY7E3VE4XM4JTQUIQAII>
    1c3a:	4606      	mov	r6, r0
    1c3c:	f1bb 0f01 	cmp.w	fp, #1
    1c40:	bf18      	it	ne
    1c42:	f1bb 0f02 	cmpne.w	fp, #2
    1c46:	d005      	beq.n	1c54 <MPSL_IRQ_RADIO_Handler+0x638>
    1c48:	f640 115d 	movw	r1, #2397	; 0x95d
    1c4c:	f04f 0070 	mov.w	r0, #112	; 0x70
    1c50:	f002 ffb0 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1c54:	49f7      	ldr	r1, [pc, #988]	; (2034 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2e8>)
    1c56:	2001      	movs	r0, #1
    1c58:	6008      	str	r0, [r1, #0]
    1c5a:	49f7      	ldr	r1, [pc, #988]	; (2038 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2ec>)
    1c5c:	6889      	ldr	r1, [r1, #8]
    1c5e:	6008      	str	r0, [r1, #0]
    1c60:	2000      	movs	r0, #0
    1c62:	f88d 004e 	strb.w	r0, [sp, #78]	; 0x4e
    1c66:	900c      	str	r0, [sp, #48]	; 0x30
    1c68:	1e40      	subs	r0, r0, #1
    1c6a:	900d      	str	r0, [sp, #52]	; 0x34
    1c6c:	48f3      	ldr	r0, [pc, #972]	; (203c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f0>)
    1c6e:	ebc7 01c7 	rsb	r1, r7, r7, lsl #3
    1c72:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
    1c76:	f10c 0c08 	add.w	ip, ip, #8
    1c7a:	f10d 0838 	add.w	r8, sp, #56	; 0x38
    1c7e:	e89c 100f 	ldmia.w	ip, {r0, r1, r2, r3, ip}
    1c82:	e888 100f 	stmia.w	r8, {r0, r1, r2, r3, ip}
    1c86:	a80e      	add	r0, sp, #56	; 0x38
    1c88:	f000 fbc2 	bl	2410 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6c4>
    1c8c:	9007      	str	r0, [sp, #28]
    1c8e:	48ec      	ldr	r0, [pc, #944]	; (2040 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f4>)
    1c90:	f8bd 8046 	ldrh.w	r8, [sp, #70]	; 0x46
    1c94:	8b80      	ldrh	r0, [r0, #28]
    1c96:	f8ad 004c 	strh.w	r0, [sp, #76]	; 0x4c
    1c9a:	f1b8 0f00 	cmp.w	r8, #0
    1c9e:	bf04      	itt	eq
    1ca0:	2000      	moveq	r0, #0
    1ca2:	9006      	streq	r0, [sp, #24]
    1ca4:	d00b      	beq.n	1cbe <MPSL_IRQ_RADIO_Handler+0x6a2>
    1ca6:	2001      	movs	r0, #1
    1ca8:	9006      	str	r0, [sp, #24]
    1caa:	48e5      	ldr	r0, [pc, #916]	; (2040 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f4>)
    1cac:	f890 002a 	ldrb.w	r0, [r0, #42]	; 0x2a
    1cb0:	b928      	cbnz	r0, 1cbe <MPSL_IRQ_RADIO_Handler+0x6a2>
    1cb2:	f002 ff07 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    1cb6:	2800      	cmp	r0, #0
    1cb8:	bf08      	it	eq
    1cba:	2701      	moveq	r7, #1
    1cbc:	d000      	beq.n	1cc0 <MPSL_IRQ_RADIO_Handler+0x6a4>
    1cbe:	2700      	movs	r7, #0
    1cc0:	f002 fdce 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    1cc4:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1cc8:	bf08      	it	eq
    1cca:	200d      	moveq	r0, #13
    1ccc:	d00b      	beq.n	1ce6 <MPSL_IRQ_RADIO_Handler+0x6ca>
    1cce:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1cd2:	3856      	subs	r0, #86	; 0x56
    1cd4:	bf08      	it	eq
    1cd6:	201c      	moveq	r0, #28
    1cd8:	d005      	beq.n	1ce6 <MPSL_IRQ_RADIO_Handler+0x6ca>
    1cda:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1cde:	389f      	subs	r0, #159	; 0x9f
    1ce0:	bf14      	ite	ne
    1ce2:	2000      	movne	r0, #0
    1ce4:	2032      	moveq	r0, #50	; 0x32
    1ce6:	f04f 0900 	mov.w	r9, #0
    1cea:	46ca      	mov	sl, r9
    1cec:	900b      	str	r0, [sp, #44]	; 0x2c
    1cee:	4546      	cmp	r6, r8
    1cf0:	d938      	bls.n	1d64 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x18>
    1cf2:	9907      	ldr	r1, [sp, #28]
    1cf4:	f8df 934c 	ldr.w	r9, [pc, #844]	; 2044 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f8>
    1cf8:	ea6f 0c06 	mvn.w	ip, r6
    1cfc:	466b      	mov	r3, sp
    1cfe:	aa16      	add	r2, sp, #88	; 0x58
    1d00:	eb01 000c 	add.w	r0, r1, ip
    1d04:	4549      	cmp	r1, r9
    1d06:	d904      	bls.n	1d12 <MPSL_IRQ_RADIO_Handler+0x6f6>
    1d08:	f240 516f 	movw	r1, #1391	; 0x56f
    1d0c:	2070      	movs	r0, #112	; 0x70
    1d0e:	f002 ff51 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1d12:	49cd      	ldr	r1, [pc, #820]	; (2048 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2fc>)
    1d14:	458c      	cmp	ip, r1
    1d16:	dd04      	ble.n	1d22 <MPSL_IRQ_RADIO_Handler+0x706>
    1d18:	f44f 61ae 	mov.w	r1, #1392	; 0x570
    1d1c:	2070      	movs	r0, #112	; 0x70
    1d1e:	f002 ff49 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1d22:	49ca      	ldr	r1, [pc, #808]	; (204c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x300>)
    1d24:	458c      	cmp	ip, r1
    1d26:	da04      	bge.n	1d32 <MPSL_IRQ_RADIO_Handler+0x716>
    1d28:	f240 5171 	movw	r1, #1393	; 0x571
    1d2c:	2070      	movs	r0, #112	; 0x70
    1d2e:	f002 ff41 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1d32:	49c7      	ldr	r1, [pc, #796]	; (2050 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x304>)
    1d34:	4281      	cmp	r1, r0
    1d36:	bfdc      	itt	le
    1d38:	f500 00f7 	addle.w	r0, r0, #8093696	; 0x7b8000
    1d3c:	f1a0 50f8 	suble.w	r0, r0, #520093696	; 0x1f000000
    1d40:	dd05      	ble.n	1d4e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2>
    1d42:	2800      	cmp	r0, #0
    1d44:	bfbc      	itt	lt
    1d46:	f5a0 00f7 	sublt.w	r0, r0, #8093696	; 0x7b8000
    1d4a:	f100 50f8 	addlt.w	r0, r0, #520093696	; 0x1f000000
    1d4e:	4619      	mov	r1, r3
    1d50:	f001 fea8 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    1d54:	9800      	ldr	r0, [sp, #0]
    1d56:	990e      	ldr	r1, [sp, #56]	; 0x38
    1d58:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1d5c:	9000      	str	r0, [sp, #0]
    1d5e:	1a08      	subs	r0, r1, r0
    1d60:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
    1d64:	2f00      	cmp	r7, #0
    1d66:	bf18      	it	ne
    1d68:	f8dd a02c 	ldrne.w	sl, [sp, #44]	; 0x2c
    1d6c:	d105      	bne.n	1d7a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2e>
    1d6e:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
    1d72:	2800      	cmp	r0, #0
    1d74:	bf18      	it	ne
    1d76:	f04f 0a02 	movne.w	sl, #2
    1d7a:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
    1d7e:	d008      	beq.n	1d92 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x46>
    1d80:	980e      	ldr	r0, [sp, #56]	; 0x38
    1d82:	1b00      	subs	r0, r0, r4
    1d84:	0200      	lsls	r0, r0, #8
    1d86:	17c1      	asrs	r1, r0, #31
    1d88:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    1d8c:	1200      	asrs	r0, r0, #8
    1d8e:	2801      	cmp	r0, #1
    1d90:	da01      	bge.n	1d96 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4a>
    1d92:	2003      	movs	r0, #3
    1d94:	e00d      	b.n	1db2 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x66>
    1d96:	b157      	cbz	r7, 1dae <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x62>
    1d98:	48a9      	ldr	r0, [pc, #676]	; (2040 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f4>)
    1d9a:	f890 002b 	ldrb.w	r0, [r0, #43]	; 0x2b
    1d9e:	b130      	cbz	r0, 1dae <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x62>
    1da0:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
    1da4:	f110 0a00 	adds.w	sl, r0, #0
    1da8:	bf18      	it	ne
    1daa:	f04f 0a02 	movne.w	sl, #2
    1dae:	4625      	mov	r5, r4
    1db0:	2000      	movs	r0, #0
    1db2:	4482      	add	sl, r0
    1db4:	980e      	ldr	r0, [sp, #56]	; 0x38
    1db6:	eba0 0009 	sub.w	r0, r0, r9
    1dba:	f020 427f 	bic.w	r2, r0, #4278190080	; 0xff000000
    1dbe:	1e50      	subs	r0, r2, #1
    1dc0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1dc4:	1b41      	subs	r1, r0, r5
    1dc6:	0209      	lsls	r1, r1, #8
    1dc8:	17cb      	asrs	r3, r1, #31
    1dca:	eb01 6113 	add.w	r1, r1, r3, lsr #24
    1dce:	1209      	asrs	r1, r1, #8
    1dd0:	4551      	cmp	r1, sl
    1dd2:	db04      	blt.n	1dde <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x92>
    1dd4:	f1b9 0f00 	cmp.w	r9, #0
    1dd8:	bf18      	it	ne
    1dda:	920e      	strne	r2, [sp, #56]	; 0x38
    1ddc:	e02d      	b.n	1e3a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xee>
    1dde:	f1b9 0f00 	cmp.w	r9, #0
    1de2:	d005      	beq.n	1df0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xa4>
    1de4:	f89d 004d 	ldrb.w	r0, [sp, #77]	; 0x4d
    1de8:	b920      	cbnz	r0, 1df4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xa8>
    1dea:	f002 fb61 	bl	44b0 <sym_7TCBS6SSQW4V3WJBKAXLOSA2HN4KF7UYAM2QFKI>
    1dee:	b108      	cbz	r0, 1df4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xa8>
    1df0:	b9af      	cbnz	r7, 1e1e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xd2>
    1df2:	e00c      	b.n	1e0e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xc2>
    1df4:	b92f      	cbnz	r7, 1e02 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xb6>
    1df6:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
    1dfa:	2800      	cmp	r0, #0
    1dfc:	bf18      	it	ne
    1dfe:	f1aa 0a02 	subne.w	sl, sl, #2
    1e02:	f04f 0900 	mov.w	r9, #0
    1e06:	f88d 904c 	strb.w	r9, [sp, #76]	; 0x4c
    1e0a:	464e      	mov	r6, r9
    1e0c:	e007      	b.n	1e1e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xd2>
    1e0e:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
    1e12:	b120      	cbz	r0, 1e1e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0xd2>
    1e14:	2000      	movs	r0, #0
    1e16:	f88d 004c 	strb.w	r0, [sp, #76]	; 0x4c
    1e1a:	f1aa 0a02 	sub.w	sl, sl, #2
    1e1e:	980e      	ldr	r0, [sp, #56]	; 0x38
    1e20:	eba0 0009 	sub.w	r0, r0, r9
    1e24:	1e40      	subs	r0, r0, #1
    1e26:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1e2a:	1b41      	subs	r1, r0, r5
    1e2c:	0209      	lsls	r1, r1, #8
    1e2e:	17ca      	asrs	r2, r1, #31
    1e30:	eb01 6112 	add.w	r1, r1, r2, lsr #24
    1e34:	1209      	asrs	r1, r1, #8
    1e36:	4551      	cmp	r1, sl
    1e38:	db7e      	blt.n	1f38 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x1ec>
    1e3a:	9714      	str	r7, [sp, #80]	; 0x50
    1e3c:	4605      	mov	r5, r0
    1e3e:	f04f 0900 	mov.w	r9, #0
    1e42:	9f06      	ldr	r7, [sp, #24]
    1e44:	f001 ff98 	bl	3d78 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY>
    1e48:	1a28      	subs	r0, r5, r0
    1e4a:	0200      	lsls	r0, r0, #8
    1e4c:	17c1      	asrs	r1, r0, #31
    1e4e:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    1e52:	ea4f 2a20 	mov.w	sl, r0, asr #8
    1e56:	f002 fd03 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    1e5a:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    1e5e:	bf08      	it	eq
    1e60:	200d      	moveq	r0, #13
    1e62:	d00b      	beq.n	1e7c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x130>
    1e64:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    1e68:	3856      	subs	r0, #86	; 0x56
    1e6a:	bf08      	it	eq
    1e6c:	201c      	moveq	r0, #28
    1e6e:	d005      	beq.n	1e7c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x130>
    1e70:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    1e74:	389f      	subs	r0, #159	; 0x9f
    1e76:	bf14      	ite	ne
    1e78:	2000      	movne	r0, #0
    1e7a:	2032      	moveq	r0, #50	; 0x32
    1e7c:	300b      	adds	r0, #11
    1e7e:	4582      	cmp	sl, r0
    1e80:	da20      	bge.n	1ec4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x178>
    1e82:	f1bb 0f01 	cmp.w	fp, #1
    1e86:	d002      	beq.n	1e8e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x142>
    1e88:	9814      	ldr	r0, [sp, #80]	; 0x50
    1e8a:	b140      	cbz	r0, 1e9e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x152>
    1e8c:	e012      	b.n	1eb4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x168>
    1e8e:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
    1e92:	d11c      	bne.n	1ece <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x182>
    1e94:	f640 01de 	movw	r1, #2270	; 0x8de
    1e98:	2070      	movs	r0, #112	; 0x70
    1e9a:	f002 fe8b 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1e9e:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
    1ea2:	d007      	beq.n	1eb4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x168>
    1ea4:	1b60      	subs	r0, r4, r5
    1ea6:	0200      	lsls	r0, r0, #8
    1ea8:	17c1      	asrs	r1, r0, #31
    1eaa:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    1eae:	1200      	asrs	r0, r0, #8
    1eb0:	2804      	cmp	r0, #4
    1eb2:	dd04      	ble.n	1ebe <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x172>
    1eb4:	462c      	mov	r4, r5
    1eb6:	4620      	mov	r0, r4
    1eb8:	f001 ff84 	bl	3dc4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ>
    1ebc:	e007      	b.n	1ece <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x182>
    1ebe:	2800      	cmp	r0, #0
    1ec0:	dc63      	bgt.n	1f8a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x23e>
    1ec2:	e004      	b.n	1ece <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x182>
    1ec4:	462c      	mov	r4, r5
    1ec6:	4620      	mov	r0, r4
    1ec8:	f001 ff7c 	bl	3dc4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ>
    1ecc:	46b9      	mov	r9, r7
    1ece:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
    1ed2:	d055      	beq.n	1f80 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x234>
    1ed4:	980e      	ldr	r0, [sp, #56]	; 0x38
    1ed6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    1ed8:	1b00      	subs	r0, r0, r4
    1eda:	1b12      	subs	r2, r2, r4
    1edc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    1ee0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    1ee4:	2801      	cmp	r0, #1
    1ee6:	d350      	bcc.n	1f8a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x23e>
    1ee8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    1eec:	bf98      	it	ls
    1eee:	f5b2 0f00 	cmpls.w	r2, #8388608	; 0x800000
    1ef2:	d84a      	bhi.n	1f8a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x23e>
    1ef4:	4620      	mov	r0, r4
    1ef6:	f00a ff17 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    1efa:	9907      	ldr	r1, [sp, #28]
    1efc:	4a52      	ldr	r2, [pc, #328]	; (2048 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2fc>)
    1efe:	1a0d      	subs	r5, r1, r0
    1f00:	f04f 0a00 	mov.w	sl, #0
    1f04:	1aaa      	subs	r2, r5, r2
    1f06:	f17a 0200 	sbcs.w	r2, sl, #0
    1f0a:	d318      	bcc.n	1f3e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x1f2>
    1f0c:	4b4e      	ldr	r3, [pc, #312]	; (2048 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2fc>)
    1f0e:	1a42      	subs	r2, r0, r1
    1f10:	1ad3      	subs	r3, r2, r3
    1f12:	f17a 0300 	sbcs.w	r3, sl, #0
    1f16:	d312      	bcc.n	1f3e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x1f2>
    1f18:	4b4a      	ldr	r3, [pc, #296]	; (2044 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f8>)
    1f1a:	42ab      	cmp	r3, r5
    1f1c:	bf3e      	ittt	cc
    1f1e:	f5c0 2090 	rsbcc	r0, r0, #294912	; 0x48000
    1f22:	f100 50f4 	addcc.w	r0, r0, #511705088	; 0x1e800000
    1f26:	1845      	addcc	r5, r0, r1
    1f28:	d309      	bcc.n	1f3e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x1f2>
    1f2a:	4293      	cmp	r3, r2
    1f2c:	d231      	bcs.n	1f92 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x246>
    1f2e:	f5c1 2190 	rsb	r1, r1, #294912	; 0x48000
    1f32:	f101 51f4 	add.w	r1, r1, #511705088	; 0x1e800000
    1f36:	e000      	b.n	1f3a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x1ee>
    1f38:	e027      	b.n	1f8a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x23e>
    1f3a:	4408      	add	r0, r1
    1f3c:	4245      	negs	r5, r0
    1f3e:	4f40      	ldr	r7, [pc, #256]	; (2040 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2f4>)
    1f40:	7fb8      	ldrb	r0, [r7, #30]
    1f42:	b358      	cbz	r0, 1f9c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x250>
    1f44:	f1bb 0f01 	cmp.w	fp, #1
    1f48:	d005      	beq.n	1f56 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x20a>
    1f4a:	2002      	movs	r0, #2
    1f4c:	f002 f976 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    1f50:	2001      	movs	r0, #1
    1f52:	f002 f973 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    1f56:	45b0      	cmp	r8, r6
    1f58:	d22c      	bcs.n	1fb4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x268>
    1f5a:	eba5 0106 	sub.w	r1, r5, r6
    1f5e:	f04f 0002 	mov.w	r0, #2
    1f62:	f002 f8b5 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    1f66:	b390      	cbz	r0, 1fce <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x282>
    1f68:	f1b8 0f00 	cmp.w	r8, #0
    1f6c:	bf1c      	itt	ne
    1f6e:	eba5 0108 	subne.w	r1, r5, r8
    1f72:	2001      	movne	r0, #1
    1f74:	d034      	beq.n	1fe0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x294>
    1f76:	bf00      	nop
    1f78:	f002 f8aa 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    1f7c:	b338      	cbz	r0, 1fce <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x282>
    1f7e:	e02f      	b.n	1fe0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x294>
    1f80:	f640 11f1 	movw	r1, #2545	; 0x9f1
    1f84:	2070      	movs	r0, #112	; 0x70
    1f86:	f002 fe15 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1f8a:	b017      	add	sp, #92	; 0x5c
    1f8c:	2000      	movs	r0, #0
    1f8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1f92:	f640 21c2 	movw	r1, #2754	; 0xac2
    1f96:	2070      	movs	r0, #112	; 0x70
    1f98:	f002 fe0c 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1f9c:	45b0      	cmp	r8, r6
    1f9e:	bf34      	ite	cc
    1fa0:	4630      	movcc	r0, r6
    1fa2:	4640      	movcs	r0, r8
    1fa4:	301e      	adds	r0, #30
    1fa6:	42a8      	cmp	r0, r5
    1fa8:	dbcc      	blt.n	1f44 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x1f8>
    1faa:	f640 2105 	movw	r1, #2565	; 0xa05
    1fae:	2070      	movs	r0, #112	; 0x70
    1fb0:	f002 fe00 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1fb4:	d90c      	bls.n	1fd0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x284>
    1fb6:	eba5 0108 	sub.w	r1, r5, r8
    1fba:	2001      	movs	r0, #1
    1fbc:	f002 f888 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    1fc0:	b128      	cbz	r0, 1fce <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x282>
    1fc2:	2e00      	cmp	r6, #0
    1fc4:	bf1c      	itt	ne
    1fc6:	1ba9      	subne	r1, r5, r6
    1fc8:	2002      	movne	r0, #2
    1fca:	d009      	beq.n	1fe0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x294>
    1fcc:	e7d4      	b.n	1f78 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x22c>
    1fce:	e030      	b.n	2032 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2e6>
    1fd0:	ea56 0008 	orrs.w	r0, r6, r8
    1fd4:	d004      	beq.n	1fe0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x294>
    1fd6:	f640 1141 	movw	r1, #2369	; 0x941
    1fda:	2070      	movs	r0, #112	; 0x70
    1fdc:	f002 fdea 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    1fe0:	4629      	mov	r1, r5
    1fe2:	2000      	movs	r0, #0
    1fe4:	f002 f874 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    1fe8:	b318      	cbz	r0, 2032 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2e6>
    1fea:	9806      	ldr	r0, [sp, #24]
    1fec:	2601      	movs	r6, #1
    1fee:	2800      	cmp	r0, #0
    1ff0:	bf04      	itt	eq
    1ff2:	f897 002b 	ldrbeq.w	r0, [r7, #43]	; 0x2b
    1ff6:	2800      	cmpeq	r0, #0
    1ff8:	d002      	beq.n	2000 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2b4>
    1ffa:	f1b9 0f00 	cmp.w	r9, #0
    1ffe:	d033      	beq.n	2068 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x31c>
    2000:	f897 002a 	ldrb.w	r0, [r7, #42]	; 0x2a
    2004:	b118      	cbz	r0, 200e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2c2>
    2006:	f002 fc31 	bl	486c <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ>
    200a:	f887 a02a 	strb.w	sl, [r7, #42]	; 0x2a
    200e:	f1b9 0f00 	cmp.w	r9, #0
    2012:	d02c      	beq.n	206e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x322>
    2014:	980b      	ldr	r0, [sp, #44]	; 0x2c
    2016:	1a20      	subs	r0, r4, r0
    2018:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    201c:	2005      	movs	r0, #5
    201e:	f002 f857 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    2022:	b3e0      	cbz	r0, 209e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x352>
    2024:	f897 002b 	ldrb.w	r0, [r7, #43]	; 0x2b
    2028:	2800      	cmp	r0, #0
    202a:	bf08      	it	eq
    202c:	f887 602b 	strbeq.w	r6, [r7, #43]	; 0x2b
    2030:	e025      	b.n	207e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x332>
    2032:	e00f      	b.n	2054 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x308>
    2034:	40000508 	.word	0x40000508
    2038:	20000038 	.word	0x20000038
    203c:	200011cc 	.word	0x200011cc
    2040:	200015cc 	.word	0x200015cc
    2044:	1e847fff 	.word	0x1e847fff
    2048:	0f424000 	.word	0x0f424000
    204c:	f0bdc000 	.word	0xf0bdc000
    2050:	1e848000 	.word	0x1e848000
    2054:	2002      	movs	r0, #2
    2056:	f002 f8f1 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    205a:	2001      	movs	r0, #1
    205c:	f002 f8ee 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    2060:	b017      	add	sp, #92	; 0x5c
    2062:	2000      	movs	r0, #0
    2064:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2068:	f897 002a 	ldrb.w	r0, [r7, #42]	; 0x2a
    206c:	b190      	cbz	r0, 2094 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x348>
    206e:	f897 002b 	ldrb.w	r0, [r7, #43]	; 0x2b
    2072:	b120      	cbz	r0, 207e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x332>
    2074:	2005      	movs	r0, #5
    2076:	f002 f8e1 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    207a:	f887 a02b 	strb.w	sl, [r7, #43]	; 0x2b
    207e:	eba5 0008 	sub.w	r0, r5, r8
    2082:	f1a0 0119 	sub.w	r1, r0, #25
    2086:	2900      	cmp	r1, #0
    2088:	dc0f      	bgt.n	20aa <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x35e>
    208a:	f640 212e 	movw	r1, #2606	; 0xa2e
    208e:	2070      	movs	r0, #112	; 0x70
    2090:	f002 fd90 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2094:	f002 fc06 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    2098:	f887 602a 	strb.w	r6, [r7, #42]	; 0x2a
    209c:	e7b7      	b.n	200e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x2c2>
    209e:	e7ff      	b.n	20a0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x354>
    20a0:	f240 21f2 	movw	r1, #754	; 0x2f2
    20a4:	2070      	movs	r0, #112	; 0x70
    20a6:	f002 fd85 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    20aa:	2003      	movs	r0, #3
    20ac:	f002 f810 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    20b0:	b1b8      	cbz	r0, 20e2 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x396>
    20b2:	480e      	ldr	r0, [pc, #56]	; (20ec <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x3a0>)
    20b4:	6880      	ldr	r0, [r0, #8]
    20b6:	f8c0 a000 	str.w	sl, [r0]
    20ba:	480d      	ldr	r0, [pc, #52]	; (20f0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x3a4>)
    20bc:	f8c0 a000 	str.w	sl, [r0]
    20c0:	f10d 0830 	add.w	r8, sp, #48	; 0x30
    20c4:	e898 107f 	ldmia.w	r8, {r0, r1, r2, r3, r4, r5, r6, ip}
    20c8:	6038      	str	r0, [r7, #0]
    20ca:	6079      	str	r1, [r7, #4]
    20cc:	60ba      	str	r2, [r7, #8]
    20ce:	60fb      	str	r3, [r7, #12]
    20d0:	613c      	str	r4, [r7, #16]
    20d2:	617d      	str	r5, [r7, #20]
    20d4:	61be      	str	r6, [r7, #24]
    20d6:	f8c7 c01c 	str.w	ip, [r7, #28]
    20da:	b017      	add	sp, #92	; 0x5c
    20dc:	2001      	movs	r0, #1
    20de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    20e2:	f640 2136 	movw	r1, #2614	; 0xa36
    20e6:	2070      	movs	r0, #112	; 0x70
    20e8:	f002 fd64 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    20ec:	20000038 	.word	0x20000038
    20f0:	40000508 	.word	0x40000508
    20f4:	e92d 5ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    20f8:	4606      	mov	r6, r0
    20fa:	7808      	ldrb	r0, [r1, #0]
    20fc:	7490      	strb	r0, [r2, #18]
    20fe:	7ac8      	ldrb	r0, [r1, #11]
    2100:	7450      	strb	r0, [r2, #17]
    2102:	7a88      	ldrb	r0, [r1, #10]
    2104:	7410      	strb	r0, [r2, #16]
    2106:	8908      	ldrh	r0, [r1, #8]
    2108:	81d0      	strh	r0, [r2, #14]
    210a:	f8df 8198 	ldr.w	r8, [pc, #408]	; 22a4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x558>
    210e:	6870      	ldr	r0, [r6, #4]
    2110:	469a      	mov	sl, r3
    2112:	fba0 7908 	umull	r7, r9, r0, r8
    2116:	4614      	mov	r4, r2
    2118:	460d      	mov	r5, r1
    211a:	6830      	ldr	r0, [r6, #0]
    211c:	f00a fe04 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    2120:	19c1      	adds	r1, r0, r7
    2122:	7828      	ldrb	r0, [r5, #0]
    2124:	ea4f 0c68 	mov.w	ip, r8, asr #1
    2128:	f149 0200 	adc.w	r2, r9, #0
    212c:	f1a8 0e01 	sub.w	lr, r8, #1
    2130:	f1cc 0b00 	rsb	fp, ip, #0
    2134:	b168      	cbz	r0, 2152 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x406>
    2136:	89e0      	ldrh	r0, [r4, #14]
    2138:	7c67      	ldrb	r7, [r4, #17]
    213a:	43c0      	mvns	r0, r0
    213c:	f8d5 9004 	ldr.w	r9, [r5, #4]
    2140:	f104 020c 	add.w	r2, r4, #12
    2144:	4560      	cmp	r0, ip
    2146:	dd5f      	ble.n	2208 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4bc>
    2148:	f44f 61ae 	mov.w	r1, #1392	; 0x570
    214c:	2070      	movs	r0, #112	; 0x70
    214e:	f002 fd31 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2152:	f8df 9154 	ldr.w	r9, [pc, #340]	; 22a8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x55c>
    2156:	e9d5 0304 	ldrd	r0, r3, [r5, #16]
    215a:	eb11 0a09 	adds.w	sl, r1, r9
    215e:	f142 0900 	adc.w	r9, r2, #0
    2162:	ebb0 0a0a 	subs.w	sl, r0, sl
    2166:	eb73 0909 	sbcs.w	r9, r3, r9
    216a:	d245      	bcs.n	21f8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4ac>
    216c:	1a41      	subs	r1, r0, r1
    216e:	eb73 0102 	sbcs.w	r1, r3, r2
    2172:	d341      	bcc.n	21f8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4ac>
    2174:	1bc7      	subs	r7, r0, r7
    2176:	6870      	ldr	r0, [r6, #4]
    2178:	60a0      	str	r0, [r4, #8]
    217a:	4547      	cmp	r7, r8
    217c:	d305      	bcc.n	218a <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x43e>
    217e:	1c40      	adds	r0, r0, #1
    2180:	f1a7 57f4 	sub.w	r7, r7, #511705088	; 0x1e800000
    2184:	f5a7 2790 	sub.w	r7, r7, #294912	; 0x48000
    2188:	60a0      	str	r0, [r4, #8]
    218a:	89e0      	ldrh	r0, [r4, #14]
    218c:	686d      	ldr	r5, [r5, #4]
    218e:	43c1      	mvns	r1, r0
    2190:	7c66      	ldrb	r6, [r4, #17]
    2192:	1878      	adds	r0, r7, r1
    2194:	f104 020c 	add.w	r2, r4, #12
    2198:	4577      	cmp	r7, lr
    219a:	d904      	bls.n	21a6 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x45a>
    219c:	f240 516f 	movw	r1, #1391	; 0x56f
    21a0:	2070      	movs	r0, #112	; 0x70
    21a2:	f002 fd07 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    21a6:	4561      	cmp	r1, ip
    21a8:	dcce      	bgt.n	2148 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x3fc>
    21aa:	4559      	cmp	r1, fp
    21ac:	db2f      	blt.n	220e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4c2>
    21ae:	4580      	cmp	r8, r0
    21b0:	bfdc      	itt	le
    21b2:	f500 00f7 	addle.w	r0, r0, #8093696	; 0x7b8000
    21b6:	f1a0 50f8 	suble.w	r0, r0, #520093696	; 0x1f000000
    21ba:	dd05      	ble.n	21c8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x47c>
    21bc:	2800      	cmp	r0, #0
    21be:	bfbc      	itt	lt
    21c0:	f5a0 00f7 	sublt.w	r0, r0, #8093696	; 0x7b8000
    21c4:	f100 50f8 	addlt.w	r0, r0, #520093696	; 0x1f000000
    21c8:	4621      	mov	r1, r4
    21ca:	f001 fc6b 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    21ce:	6820      	ldr	r0, [r4, #0]
    21d0:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    21d4:	1978      	adds	r0, r7, r5
    21d6:	1c40      	adds	r0, r0, #1
    21d8:	6021      	str	r1, [r4, #0]
    21da:	2e00      	cmp	r6, #0
    21dc:	bf08      	it	eq
    21de:	307a      	addeq	r0, #122	; 0x7a
    21e0:	d003      	beq.n	21ea <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x49e>
    21e2:	2e01      	cmp	r6, #1
    21e4:	bf08      	it	eq
    21e6:	3048      	addeq	r0, #72	; 0x48
    21e8:	d134      	bne.n	2254 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x508>
    21ea:	f001 fc3f 	bl	3a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>
    21ee:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    21f2:	6060      	str	r0, [r4, #4]
    21f4:	e8bd 9ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
    21f8:	6830      	ldr	r0, [r6, #0]
    21fa:	1e40      	subs	r0, r0, #1
    21fc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    2200:	6020      	str	r0, [r4, #0]
    2202:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
    2206:	e7f4      	b.n	21f2 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4a6>
    2208:	4601      	mov	r1, r0
    220a:	4558      	cmp	r0, fp
    220c:	da04      	bge.n	2218 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4cc>
    220e:	f240 5171 	movw	r1, #1393	; 0x571
    2212:	2070      	movs	r0, #112	; 0x70
    2214:	f002 fcce 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2218:	4580      	cmp	r8, r0
    221a:	bfdc      	itt	le
    221c:	f1a1 50f4 	suble.w	r0, r1, #511705088	; 0x1e800000
    2220:	f5a0 2090 	suble.w	r0, r0, #294912	; 0x48000
    2224:	dd05      	ble.n	2232 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x4e6>
    2226:	2800      	cmp	r0, #0
    2228:	bfbc      	itt	lt
    222a:	f101 50f4 	addlt.w	r0, r1, #511705088	; 0x1e800000
    222e:	f500 2090 	addlt.w	r0, r0, #294912	; 0x48000
    2232:	4621      	mov	r1, r4
    2234:	f001 fc36 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    2238:	6820      	ldr	r0, [r4, #0]
    223a:	2f00      	cmp	r7, #0
    223c:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    2240:	f109 0001 	add.w	r0, r9, #1
    2244:	6021      	str	r1, [r4, #0]
    2246:	bf08      	it	eq
    2248:	307a      	addeq	r0, #122	; 0x7a
    224a:	d008      	beq.n	225e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x512>
    224c:	2f01      	cmp	r7, #1
    224e:	bf08      	it	eq
    2250:	3048      	addeq	r0, #72	; 0x48
    2252:	d004      	beq.n	225e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x512>
    2254:	f240 6124 	movw	r1, #1572	; 0x624
    2258:	2070      	movs	r0, #112	; 0x70
    225a:	f002 fcab 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    225e:	f001 fc05 	bl	3a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>
    2262:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    2266:	6061      	str	r1, [r4, #4]
    2268:	6870      	ldr	r0, [r6, #4]
    226a:	60a0      	str	r0, [r4, #8]
    226c:	2100      	movs	r1, #0
    226e:	4622      	mov	r2, r4
    2270:	6830      	ldr	r0, [r6, #0]
    2272:	f7ff fc83 	bl	1b7c <MPSL_IRQ_RADIO_Handler+0x560>
    2276:	6832      	ldr	r2, [r6, #0]
    2278:	4653      	mov	r3, sl
    227a:	4621      	mov	r1, r4
    227c:	6928      	ldr	r0, [r5, #16]
    227e:	f7ff fa29 	bl	16d4 <MPSL_IRQ_RADIO_Handler+0xb8>
    2282:	2800      	cmp	r0, #0
    2284:	bf18      	it	ne
    2286:	e8bd 9ff0 	ldmiane.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
    228a:	e9d4 2100 	ldrd	r2, r1, [r4]
    228e:	6830      	ldr	r0, [r6, #0]
    2290:	1a89      	subs	r1, r1, r2
    2292:	f020 427f 	bic.w	r2, r0, #4278190080	; 0xff000000
    2296:	4408      	add	r0, r1
    2298:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    229c:	e9c4 2000 	strd	r2, r0, [r4]
    22a0:	e8bd 9ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
    22a4:	1e848000 	.word	0x1e848000
    22a8:	0f424000 	.word	0x0f424000
    22ac:	b570      	push	{r4, r5, r6, lr}
    22ae:	4d1e      	ldr	r5, [pc, #120]	; (2328 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x5dc>)
    22b0:	f895 002d 	ldrb.w	r0, [r5, #45]	; 0x2d
    22b4:	2820      	cmp	r0, #32
    22b6:	bf18      	it	ne
    22b8:	bd70      	popne	{r4, r5, r6, pc}
    22ba:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
    22be:	eb02 0042 	add.w	r0, r2, r2, lsl #1
    22c2:	4428      	add	r0, r5
    22c4:	f890 4020 	ldrb.w	r4, [r0, #32]
    22c8:	2c20      	cmp	r4, #32
    22ca:	d027      	beq.n	231c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x5d0>
    22cc:	4b17      	ldr	r3, [pc, #92]	; (232c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x5e0>)
    22ce:	eb03 1182 	add.w	r1, r3, r2, lsl #6
    22d2:	eb01 0144 	add.w	r1, r1, r4, lsl #1
    22d6:	7849      	ldrb	r1, [r1, #1]
    22d8:	f880 1020 	strb.w	r1, [r0, #32]
    22dc:	20ff      	movs	r0, #255	; 0xff
    22de:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
    22e2:	f885 402d 	strb.w	r4, [r5, #45]	; 0x2d
    22e6:	4621      	mov	r1, r4
    22e8:	2002      	movs	r0, #2
    22ea:	f000 f8cb 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    22ee:	2000      	movs	r0, #0
    22f0:	f885 0028 	strb.w	r0, [r5, #40]	; 0x28
    22f4:	77a8      	strb	r0, [r5, #30]
    22f6:	490e      	ldr	r1, [pc, #56]	; (2330 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x5e4>)
    22f8:	ebc4 00c4 	rsb	r0, r4, r4, lsl #3
    22fc:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    2300:	7e00      	ldrb	r0, [r0, #24]
    2302:	2800      	cmp	r0, #0
    2304:	bf08      	it	eq
    2306:	f002 fdaf 	bleq	4e68 <sym_FLYO2O6PDDEK6WCFFGJRAPCMRB5FFHTEEHI4Z2Q>
    230a:	2000      	movs	r0, #0
    230c:	4909      	ldr	r1, [pc, #36]	; (2334 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x5e8>)
    230e:	6849      	ldr	r1, [r1, #4]
    2310:	2900      	cmp	r1, #0
    2312:	bf08      	it	eq
    2314:	bd70      	popeq	{r4, r5, r6, pc}
    2316:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    231a:	4708      	bx	r1
    231c:	f44f 714b 	mov.w	r1, #812	; 0x32c
    2320:	2070      	movs	r0, #112	; 0x70
    2322:	f002 fc47 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2326:	0000      	.short	0x0000
    2328:	200015cc 	.word	0x200015cc
    232c:	2000154c 	.word	0x2000154c
    2330:	200011cc 	.word	0x200011cc
    2334:	20000038 	.word	0x20000038
    2338:	e92d 5ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    233c:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 2400 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6b4>
    2340:	f898 502c 	ldrb.w	r5, [r8, #44]	; 0x2c
    2344:	eb05 0045 	add.w	r0, r5, r5, lsl #1
    2348:	4440      	add	r0, r8
    234a:	f890 4021 	ldrb.w	r4, [r0, #33]	; 0x21
    234e:	2c20      	cmp	r4, #32
    2350:	bf08      	it	eq
    2352:	e8bd 9ff0 	ldmiaeq.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
    2356:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 2404 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6b8>
    235a:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 2408 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6bc>
    235e:	f5aa 7960 	sub.w	r9, sl, #896	; 0x380
    2362:	eb0a 1785 	add.w	r7, sl, r5, lsl #6
    2366:	2607      	movs	r6, #7
    2368:	f817 0014 	ldrb.w	r0, [r7, r4, lsl #1]
    236c:	2801      	cmp	r0, #1
    236e:	d00e      	beq.n	238e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x642>
    2370:	2804      	cmp	r0, #4
    2372:	bf08      	it	eq
    2374:	2602      	moveq	r6, #2
    2376:	d00a      	beq.n	238e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x642>
    2378:	2805      	cmp	r0, #5
    237a:	bf0c      	ite	eq
    237c:	2603      	moveq	r6, #3
    237e:	2806      	cmpne	r0, #6
    2380:	d005      	beq.n	238e <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x642>
    2382:	f640 01a8 	movw	r1, #2216	; 0x8a8
    2386:	f04f 0070 	mov.w	r0, #112	; 0x70
    238a:	f002 fc13 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    238e:	f1bb 0f00 	cmp.w	fp, #0
    2392:	bf18      	it	ne
    2394:	f3af 8000 	nopne.w
    2398:	f3ef 8010 	mrs	r0, PRIMASK
    239c:	b672      	cpsid	i
    239e:	eb07 0144 	add.w	r1, r7, r4, lsl #1
    23a2:	784a      	ldrb	r2, [r1, #1]
    23a4:	eb05 0145 	add.w	r1, r5, r5, lsl #1
    23a8:	4441      	add	r1, r8
    23aa:	f881 2021 	strb.w	r2, [r1, #33]	; 0x21
    23ae:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
    23b2:	42a2      	cmp	r2, r4
    23b4:	bf04      	itt	eq
    23b6:	2220      	moveq	r2, #32
    23b8:	f881 2022 	strbeq.w	r2, [r1, #34]	; 0x22
    23bc:	b1c0      	cbz	r0, 23f0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6a4>
    23be:	462a      	mov	r2, r5
    23c0:	4621      	mov	r1, r4
    23c2:	2001      	movs	r0, #1
    23c4:	f000 f85e 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    23c8:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    23cc:	eb09 0081 	add.w	r0, r9, r1, lsl #2
    23d0:	f859 2021 	ldr.w	r2, [r9, r1, lsl #2]
    23d4:	6840      	ldr	r0, [r0, #4]
    23d6:	4631      	mov	r1, r6
    23d8:	4790      	blx	r2
    23da:	f898 502c 	ldrb.w	r5, [r8, #44]	; 0x2c
    23de:	eb05 0045 	add.w	r0, r5, r5, lsl #1
    23e2:	4440      	add	r0, r8
    23e4:	f890 4021 	ldrb.w	r4, [r0, #33]	; 0x21
    23e8:	2c20      	cmp	r4, #32
    23ea:	d1ba      	bne.n	2362 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x616>
    23ec:	e8bd 9ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
    23f0:	4806      	ldr	r0, [pc, #24]	; (240c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6c0>)
    23f2:	2800      	cmp	r0, #0
    23f4:	bf18      	it	ne
    23f6:	f3af 8000 	nopne.w
    23fa:	b662      	cpsie	i
    23fc:	e7df      	b.n	23be <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x672>
    23fe:	0000      	.short	0x0000
    2400:	200015cc 	.word	0x200015cc
    2404:	00000000 	.word	0x00000000
    2408:	2000154c 	.word	0x2000154c
    240c:	00000000 	.word	0x00000000
    2410:	b510      	push	{r4, lr}
    2412:	4604      	mov	r4, r0
    2414:	6800      	ldr	r0, [r0, #0]
    2416:	f00a fc87 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    241a:	4602      	mov	r2, r0
    241c:	89e0      	ldrh	r0, [r4, #14]
    241e:	7b21      	ldrb	r1, [r4, #12]
    2420:	4b14      	ldr	r3, [pc, #80]	; (2474 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x728>)
    2422:	4408      	add	r0, r1
    2424:	1c41      	adds	r1, r0, #1
    2426:	1850      	adds	r0, r2, r1
    2428:	429a      	cmp	r2, r3
    242a:	d904      	bls.n	2436 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6ea>
    242c:	f240 516f 	movw	r1, #1391	; 0x56f
    2430:	2070      	movs	r0, #112	; 0x70
    2432:	f002 fbbf 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2436:	4a10      	ldr	r2, [pc, #64]	; (2478 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x72c>)
    2438:	4291      	cmp	r1, r2
    243a:	dd04      	ble.n	2446 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6fa>
    243c:	f44f 61ae 	mov.w	r1, #1392	; 0x570
    2440:	2070      	movs	r0, #112	; 0x70
    2442:	f002 fbb7 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2446:	4a0d      	ldr	r2, [pc, #52]	; (247c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x730>)
    2448:	4291      	cmp	r1, r2
    244a:	da04      	bge.n	2456 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x70a>
    244c:	f240 5171 	movw	r1, #1393	; 0x571
    2450:	2070      	movs	r0, #112	; 0x70
    2452:	f002 fbaf 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2456:	490a      	ldr	r1, [pc, #40]	; (2480 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x734>)
    2458:	4281      	cmp	r1, r0
    245a:	bfde      	ittt	le
    245c:	f500 00f7 	addle.w	r0, r0, #8093696	; 0x7b8000
    2460:	f1a0 50f8 	suble.w	r0, r0, #520093696	; 0x1f000000
    2464:	bd10      	pople	{r4, pc}
    2466:	2800      	cmp	r0, #0
    2468:	bfbc      	itt	lt
    246a:	f5a0 00f7 	sublt.w	r0, r0, #8093696	; 0x7b8000
    246e:	f100 50f8 	addlt.w	r0, r0, #520093696	; 0x1f000000
    2472:	bd10      	pop	{r4, pc}
    2474:	1e847fff 	.word	0x1e847fff
    2478:	0f424000 	.word	0x0f424000
    247c:	f0bdc000 	.word	0xf0bdc000
    2480:	1e848000 	.word	0x1e848000
    2484:	f8df c058 	ldr.w	ip, [pc, #88]	; 24e0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x794>
    2488:	b510      	push	{r4, lr}
    248a:	2300      	movs	r3, #0
    248c:	eb0c 1c82 	add.w	ip, ip, r2, lsl #6
    2490:	2807      	cmp	r0, #7
    2492:	d21f      	bcs.n	24d4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x788>
    2494:	e8df f000 	tbb	[pc, r0]
    2498:	05050505 	.word	0x05050505
    249c:	00040404 	.word	0x00040404
    24a0:	2301      	movs	r3, #1
    24a2:	f80c 0011 	strb.w	r0, [ip, r1, lsl #1]
    24a6:	2b00      	cmp	r3, #0
    24a8:	bf08      	it	eq
    24aa:	bd10      	popeq	{r4, pc}
    24ac:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    24b0:	480c      	ldr	r0, [pc, #48]	; (24e4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x798>)
    24b2:	4402      	add	r2, r0
    24b4:	f892 0022 	ldrb.w	r0, [r2, #34]	; 0x22
    24b8:	2820      	cmp	r0, #32
    24ba:	bf0e      	itee	eq
    24bc:	f882 1021 	strbeq.w	r1, [r2, #33]	; 0x21
    24c0:	eb0c 0040 	addne.w	r0, ip, r0, lsl #1
    24c4:	7041      	strbne	r1, [r0, #1]
    24c6:	2020      	movs	r0, #32
    24c8:	eb0c 0341 	add.w	r3, ip, r1, lsl #1
    24cc:	7058      	strb	r0, [r3, #1]
    24ce:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
    24d2:	bd10      	pop	{r4, pc}
    24d4:	f44f 711a 	mov.w	r1, #616	; 0x268
    24d8:	2070      	movs	r0, #112	; 0x70
    24da:	f002 fb6b 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    24de:	0000      	.short	0x0000
    24e0:	2000154c 	.word	0x2000154c
    24e4:	200015cc 	.word	0x200015cc
    24e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    24ec:	4617      	mov	r7, r2
    24ee:	f8df a158 	ldr.w	sl, [pc, #344]	; 2648 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x8fc>
    24f2:	eb02 0047 	add.w	r0, r2, r7, lsl #1
    24f6:	4450      	add	r0, sl
    24f8:	4688      	mov	r8, r1
    24fa:	f890 4020 	ldrb.w	r4, [r0, #32]
    24fe:	2901      	cmp	r1, #1
    2500:	4625      	mov	r5, r4
    2502:	bf18      	it	ne
    2504:	f1b8 0f02 	cmpne.w	r8, #2
    2508:	d005      	beq.n	2516 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x7ca>
    250a:	f640 216c 	movw	r1, #2668	; 0xa6c
    250e:	f04f 0070 	mov.w	r0, #112	; 0x70
    2512:	f002 fb4f 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2516:	f04f 0b00 	mov.w	fp, #0
    251a:	2d20      	cmp	r5, #32
    251c:	d044      	beq.n	25a8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x85c>
    251e:	f89a 001e 	ldrb.w	r0, [sl, #30]
    2522:	2600      	movs	r6, #0
    2524:	2800      	cmp	r0, #0
    2526:	bf08      	it	eq
    2528:	2602      	moveq	r6, #2
    252a:	f001 fc25 	bl	3d78 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY>
    252e:	4b47      	ldr	r3, [pc, #284]	; (264c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x900>)
    2530:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    2534:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    2538:	688a      	ldr	r2, [r1, #8]
    253a:	68c9      	ldr	r1, [r1, #12]
    253c:	1a12      	subs	r2, r2, r0
    253e:	1a09      	subs	r1, r1, r0
    2540:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    2544:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    2548:	4296      	cmp	r6, r2
    254a:	bf99      	ittee	ls
    254c:	f5b2 0f00 	cmpls.w	r2, #8388608	; 0x800000
    2550:	f5b1 0f00 	cmpls.w	r1, #8388608	; 0x800000
    2554:	4a3e      	ldrhi	r2, [pc, #248]	; (2650 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x904>)
    2556:	eb02 1987 	addhi.w	r9, r2, r7, lsl #6
    255a:	d923      	bls.n	25a4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x858>
    255c:	4622      	mov	r2, r4
    255e:	eb09 0142 	add.w	r1, r9, r2, lsl #1
    2562:	784c      	ldrb	r4, [r1, #1]
    2564:	2c20      	cmp	r4, #32
    2566:	d015      	beq.n	2594 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x848>
    2568:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    256c:	eb03 0c81 	add.w	ip, r3, r1, lsl #2
    2570:	f8dc 1008 	ldr.w	r1, [ip, #8]
    2574:	f8dc c00c 	ldr.w	ip, [ip, #12]
    2578:	1a09      	subs	r1, r1, r0
    257a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    257e:	ebac 0c00 	sub.w	ip, ip, r0
    2582:	f02c 4c7f 	bic.w	ip, ip, #4278190080	; 0xff000000
    2586:	428e      	cmp	r6, r1
    2588:	bf9c      	itt	ls
    258a:	f5b1 0f00 	cmpls.w	r1, #8388608	; 0x800000
    258e:	f5bc 0f00 	cmpls.w	ip, #8388608	; 0x800000
    2592:	d8e3      	bhi.n	255c <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x810>
    2594:	2a20      	cmp	r2, #32
    2596:	d005      	beq.n	25a4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x858>
    2598:	463b      	mov	r3, r7
    259a:	2120      	movs	r1, #32
    259c:	2004      	movs	r0, #4
    259e:	f7ff f85d 	bl	165c <MPSL_IRQ_RADIO_Handler+0x40>
    25a2:	4604      	mov	r4, r0
    25a4:	42ac      	cmp	r4, r5
    25a6:	d10f      	bne.n	25c8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x87c>
    25a8:	f89a 002e 	ldrb.w	r0, [sl, #46]	; 0x2e
    25ac:	2820      	cmp	r0, #32
    25ae:	d00f      	beq.n	25d0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x884>
    25b0:	9900      	ldr	r1, [sp, #0]
    25b2:	f8da 0008 	ldr.w	r0, [sl, #8]
    25b6:	1c89      	adds	r1, r1, #2
    25b8:	1a08      	subs	r0, r1, r0
    25ba:	0200      	lsls	r0, r0, #8
    25bc:	17c1      	asrs	r1, r0, #31
    25be:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    25c2:	1200      	asrs	r0, r0, #8
    25c4:	2800      	cmp	r0, #0
    25c6:	dd03      	ble.n	25d0 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x884>
    25c8:	b003      	add	sp, #12
    25ca:	2000      	movs	r0, #0
    25cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    25d0:	2d20      	cmp	r5, #32
    25d2:	d016      	beq.n	2602 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x8b6>
    25d4:	462a      	mov	r2, r5
    25d6:	4641      	mov	r1, r8
    25d8:	9800      	ldr	r0, [sp, #0]
    25da:	f7ff fb23 	bl	1c24 <MPSL_IRQ_RADIO_Handler+0x608>
    25de:	2800      	cmp	r0, #0
    25e0:	bf1f      	itttt	ne
    25e2:	f88a 502e 	strbne.w	r5, [sl, #46]	; 0x2e
    25e6:	2002      	movne	r0, #2
    25e8:	b003      	addne	sp, #12
    25ea:	e8bd 8ff0 	ldmiane.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    25ee:	463b      	mov	r3, r7
    25f0:	462a      	mov	r2, r5
    25f2:	2120      	movs	r1, #32
    25f4:	2004      	movs	r0, #4
    25f6:	f7ff f831 	bl	165c <MPSL_IRQ_RADIO_Handler+0x40>
    25fa:	b003      	add	sp, #12
    25fc:	2000      	movs	r0, #0
    25fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2602:	f89a 002a 	ldrb.w	r0, [sl, #42]	; 0x2a
    2606:	b118      	cbz	r0, 2610 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x8c4>
    2608:	f002 f930 	bl	486c <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ>
    260c:	f88a b02a 	strb.w	fp, [sl, #42]	; 0x2a
    2610:	f89a 002b 	ldrb.w	r0, [sl, #43]	; 0x2b
    2614:	b120      	cbz	r0, 2620 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x8d4>
    2616:	2005      	movs	r0, #5
    2618:	f001 fe10 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    261c:	f88a b02b 	strb.w	fp, [sl, #43]	; 0x2b
    2620:	2004      	movs	r0, #4
    2622:	f001 fe0b 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    2626:	f001 fe79 	bl	431c <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q>
    262a:	2020      	movs	r0, #32
    262c:	f88a 002e 	strb.w	r0, [sl, #46]	; 0x2e
    2630:	4808      	ldr	r0, [pc, #32]	; (2654 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x908>)
    2632:	6880      	ldr	r0, [r0, #8]
    2634:	f8c0 b000 	str.w	fp, [r0]
    2638:	4807      	ldr	r0, [pc, #28]	; (2658 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x90c>)
    263a:	f8c0 b000 	str.w	fp, [r0]
    263e:	b003      	add	sp, #12
    2640:	2001      	movs	r0, #1
    2642:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2646:	0000      	.short	0x0000
    2648:	200015cc 	.word	0x200015cc
    264c:	200011cc 	.word	0x200011cc
    2650:	2000154c 	.word	0x2000154c
    2654:	20000038 	.word	0x20000038
    2658:	40000508 	.word	0x40000508

0000265c <sym_RWBLK2534FJMTER76IYUPZQ3YF74JEALZ2OBIDI>:
    265c:	4906      	ldr	r1, [pc, #24]	; (2678 <sym_RWBLK2534FJMTER76IYUPZQ3YF74JEALZ2OBIDI+0x1c>)
    265e:	b510      	push	{r4, lr}
    2660:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    2664:	2a20      	cmp	r2, #32
    2666:	bf1c      	itt	ne
    2668:	7788      	strbne	r0, [r1, #30]
    266a:	bd10      	popne	{r4, pc}
    266c:	f240 317a 	movw	r1, #890	; 0x37a
    2670:	2070      	movs	r0, #112	; 0x70
    2672:	f002 fa9f 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2676:	0000      	.short	0x0000
    2678:	200015cc 	.word	0x200015cc

0000267c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ>:
    267c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2680:	4e69      	ldr	r6, [pc, #420]	; (2828 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1ac>)
    2682:	4607      	mov	r7, r0
    2684:	b08d      	sub	sp, #52	; 0x34
    2686:	f896 002d 	ldrb.w	r0, [r6, #45]	; 0x2d
    268a:	4688      	mov	r8, r1
    268c:	2820      	cmp	r0, #32
    268e:	d055      	beq.n	273c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xc0>
    2690:	f896 002d 	ldrb.w	r0, [r6, #45]	; 0x2d
    2694:	f106 0408 	add.w	r4, r6, #8
    2698:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    269c:	f5a6 6980 	sub.w	r9, r6, #1024	; 0x400
    26a0:	eb09 0a80 	add.w	sl, r9, r0, lsl #2
    26a4:	2020      	movs	r0, #32
    26a6:	f88d 0020 	strb.w	r0, [sp, #32]
    26aa:	f896 002c 	ldrb.w	r0, [r6, #44]	; 0x2c
    26ae:	aa0a      	add	r2, sp, #40	; 0x28
    26b0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    26b4:	4430      	add	r0, r6
    26b6:	a909      	add	r1, sp, #36	; 0x24
    26b8:	f890 5020 	ldrb.w	r5, [r0, #32]
    26bc:	68f0      	ldr	r0, [r6, #12]
    26be:	9002      	str	r0, [sp, #8]
    26c0:	6830      	ldr	r0, [r6, #0]
    26c2:	4438      	add	r0, r7
    26c4:	f001 f9ee 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    26c8:	f8da 000c 	ldr.w	r0, [sl, #12]
    26cc:	9909      	ldr	r1, [sp, #36]	; 0x24
    26ce:	2f65      	cmp	r7, #101	; 0x65
    26d0:	4408      	add	r0, r1
    26d2:	d338      	bcc.n	2746 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xca>
    26d4:	4a55      	ldr	r2, [pc, #340]	; (282c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1b0>)
    26d6:	2100      	movs	r1, #0
    26d8:	1bd2      	subs	r2, r2, r7
    26da:	eb71 0201 	sbcs.w	r2, r1, r1
    26de:	d332      	bcc.n	2746 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xca>
    26e0:	6822      	ldr	r2, [r4, #0]
    26e2:	1a82      	subs	r2, r0, r2
    26e4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    26e8:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    26ec:	d82b      	bhi.n	2746 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xca>
    26ee:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    26f2:	6060      	str	r0, [r4, #4]
    26f4:	4630      	mov	r0, r6
    26f6:	f884 8010 	strb.w	r8, [r4, #16]
    26fa:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
    26fe:	f10d 0a20 	add.w	sl, sp, #32
    2702:	2d20      	cmp	r5, #32
    2704:	bf1c      	itt	ne
    2706:	494a      	ldrne	r1, [pc, #296]	; (2830 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1b4>)
    2708:	eb01 1b80 	addne.w	fp, r1, r0, lsl #6
    270c:	d050      	beq.n	27b0 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x134>
    270e:	bf00      	nop
    2710:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    2714:	eb09 0880 	add.w	r8, r9, r0, lsl #2
    2718:	6861      	ldr	r1, [r4, #4]
    271a:	f8d8 6008 	ldr.w	r6, [r8, #8]
    271e:	f108 0008 	add.w	r0, r8, #8
    2722:	1a71      	subs	r1, r6, r1
    2724:	0209      	lsls	r1, r1, #8
    2726:	17ca      	asrs	r2, r1, #31
    2728:	eb01 6112 	add.w	r1, r1, r2, lsr #24
    272c:	1209      	asrs	r1, r1, #8
    272e:	d42d      	bmi.n	278c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x110>
    2730:	89c0      	ldrh	r0, [r0, #14]
    2732:	2800      	cmp	r0, #0
    2734:	d03c      	beq.n	27b0 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x134>
    2736:	89e0      	ldrh	r0, [r4, #14]
    2738:	b148      	cbz	r0, 274e <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xd2>
    273a:	e039      	b.n	27b0 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x134>
    273c:	f44f 6133 	mov.w	r1, #2864	; 0xb30
    2740:	2070      	movs	r0, #112	; 0x70
    2742:	f002 fa37 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2746:	b00d      	add	sp, #52	; 0x34
    2748:	2001      	movs	r0, #1
    274a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    274e:	6820      	ldr	r0, [r4, #0]
    2750:	900c      	str	r0, [sp, #48]	; 0x30
    2752:	f002 f885 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    2756:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    275a:	bf08      	it	eq
    275c:	200d      	moveq	r0, #13
    275e:	d00b      	beq.n	2778 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xfc>
    2760:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    2764:	3856      	subs	r0, #86	; 0x56
    2766:	bf08      	it	eq
    2768:	201c      	moveq	r0, #28
    276a:	d005      	beq.n	2778 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0xfc>
    276c:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    2770:	389f      	subs	r0, #159	; 0x9f
    2772:	bf14      	ite	ne
    2774:	2000      	movne	r0, #0
    2776:	2032      	moveq	r0, #50	; 0x32
    2778:	1c41      	adds	r1, r0, #1
    277a:	980c      	ldr	r0, [sp, #48]	; 0x30
    277c:	1a30      	subs	r0, r6, r0
    277e:	0200      	lsls	r0, r0, #8
    2780:	17c2      	asrs	r2, r0, #31
    2782:	eb00 6012 	add.w	r0, r0, r2, lsr #24
    2786:	1200      	asrs	r0, r0, #8
    2788:	4288      	cmp	r0, r1
    278a:	da11      	bge.n	27b0 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x134>
    278c:	f88a 5000 	strb.w	r5, [sl]
    2790:	f898 1018 	ldrb.w	r1, [r8, #24]
    2794:	7c20      	ldrb	r0, [r4, #16]
    2796:	4281      	cmp	r1, r0
    2798:	d805      	bhi.n	27a6 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x12a>
    279a:	9802      	ldr	r0, [sp, #8]
    279c:	6060      	str	r0, [r4, #4]
    279e:	b00d      	add	sp, #52	; 0x34
    27a0:	2002      	movs	r0, #2
    27a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    27a6:	eb0b 0045 	add.w	r0, fp, r5, lsl #1
    27aa:	7845      	ldrb	r5, [r0, #1]
    27ac:	2d20      	cmp	r5, #32
    27ae:	d1af      	bne.n	2710 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x94>
    27b0:	2005      	movs	r0, #5
    27b2:	f001 fd43 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    27b6:	4c1c      	ldr	r4, [pc, #112]	; (2828 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1ac>)
    27b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    27bc:	6060      	str	r0, [r4, #4]
    27be:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    27c2:	f89d 2020 	ldrb.w	r2, [sp, #32]
    27c6:	2120      	movs	r1, #32
    27c8:	2a20      	cmp	r2, #32
    27ca:	d003      	beq.n	27d4 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x158>
    27cc:	2005      	movs	r0, #5
    27ce:	f7fe ff45 	bl	165c <MPSL_IRQ_RADIO_Handler+0x40>
    27d2:	e004      	b.n	27de <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x162>
    27d4:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    27d8:	4420      	add	r0, r4
    27da:	f890 0020 	ldrb.w	r0, [r0, #32]
    27de:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
    27e2:	4913      	ldr	r1, [pc, #76]	; (2830 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1b4>)
    27e4:	eb01 1182 	add.w	r1, r1, r2, lsl #6
    27e8:	f894 202d 	ldrb.w	r2, [r4, #45]	; 0x2d
    27ec:	eb01 0142 	add.w	r1, r1, r2, lsl #1
    27f0:	7048      	strb	r0, [r1, #1]
    27f2:	6820      	ldr	r0, [r4, #0]
    27f4:	4438      	add	r0, r7
    27f6:	6020      	str	r0, [r4, #0]
    27f8:	20ff      	movs	r0, #255	; 0xff
    27fa:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
    27fe:	7e60      	ldrb	r0, [r4, #25]
    2800:	2801      	cmp	r0, #1
    2802:	d105      	bne.n	2810 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x194>
    2804:	68e0      	ldr	r0, [r4, #12]
    2806:	1e40      	subs	r0, r0, #1
    2808:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    280c:	f001 fb7a 	bl	3f04 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI>
    2810:	f89d 0020 	ldrb.w	r0, [sp, #32]
    2814:	2820      	cmp	r0, #32
    2816:	d003      	beq.n	2820 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1a4>
    2818:	4806      	ldr	r0, [pc, #24]	; (2834 <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ+0x1b8>)
    281a:	7840      	ldrb	r0, [r0, #1]
    281c:	f002 fa9e 	bl	4d5c <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q>
    2820:	b00d      	add	sp, #52	; 0x34
    2822:	2000      	movs	r0, #0
    2824:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2828:	200015cc 	.word	0x200015cc
    282c:	0f424000 	.word	0x0f424000
    2830:	2000154c 	.word	0x2000154c
    2834:	20000038 	.word	0x20000038

00002838 <sym_HVFGTYCGAECGUJHOFSPMGUV2G4PTWWUYTJVAPNA>:
    2838:	4806      	ldr	r0, [pc, #24]	; (2854 <sym_HVFGTYCGAECGUJHOFSPMGUV2G4PTWWUYTJVAPNA+0x1c>)
    283a:	b510      	push	{r4, lr}
    283c:	f890 102d 	ldrb.w	r1, [r0, #45]	; 0x2d
    2840:	2920      	cmp	r1, #32
    2842:	bf1c      	itt	ne
    2844:	7e00      	ldrbne	r0, [r0, #24]
    2846:	bd10      	popne	{r4, pc}
    2848:	f640 312a 	movw	r1, #2858	; 0xb2a
    284c:	2070      	movs	r0, #112	; 0x70
    284e:	f002 f9b1 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2852:	0000      	.short	0x0000
    2854:	200015cc 	.word	0x200015cc

00002858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>:
    2858:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    285a:	4d6b      	ldr	r5, [pc, #428]	; (2a08 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x1b0>)
    285c:	4a6b      	ldr	r2, [pc, #428]	; (2a0c <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x1b4>)
    285e:	f505 6480 	add.w	r4, r5, #1024	; 0x400
    2862:	2601      	movs	r6, #1
    2864:	f894 102a 	ldrb.w	r1, [r4, #42]	; 0x2a
    2868:	2808      	cmp	r0, #8
    286a:	d27c      	bcs.n	2966 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x10e>
    286c:	e8df f000 	tbb	[pc, r0]
    2870:	a9977004 	.word	0xa9977004
    2874:	b3ae41c7 	.word	0xb3ae41c7
    2878:	b919      	cbnz	r1, 2882 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x2a>
    287a:	f002 f813 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    287e:	f884 602a 	strb.w	r6, [r4, #42]	; 0x2a
    2882:	8ae0      	ldrh	r0, [r4, #22]
    2884:	b110      	cbz	r0, 288c <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x34>
    2886:	f002 f91d 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    288a:	b180      	cbz	r0, 28ae <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x56>
    288c:	f7ff fd0e 	bl	22ac <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x560>
    2890:	20ff      	movs	r0, #255	; 0xff
    2892:	f884 0027 	strb.w	r0, [r4, #39]	; 0x27
    2896:	6861      	ldr	r1, [r4, #4]
    2898:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    289c:	d003      	beq.n	28a6 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x4e>
    289e:	2005      	movs	r0, #5
    28a0:	f001 fc16 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    28a4:	b140      	cbz	r0, 28b8 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x60>
    28a6:	7e60      	ldrb	r0, [r4, #25]
    28a8:	2801      	cmp	r0, #1
    28aa:	d110      	bne.n	28ce <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x76>
    28ac:	e009      	b.n	28c2 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x6a>
    28ae:	f640 0134 	movw	r1, #2100	; 0x834
    28b2:	2070      	movs	r0, #112	; 0x70
    28b4:	f002 f97e 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    28b8:	f640 0139 	movw	r1, #2105	; 0x839
    28bc:	2070      	movs	r0, #112	; 0x70
    28be:	f002 f979 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    28c2:	68e0      	ldr	r0, [r4, #12]
    28c4:	1e40      	subs	r0, r0, #1
    28c6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    28ca:	f001 fb1b 	bl	3f04 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI>
    28ce:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    28d2:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    28d6:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    28da:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    28de:	6840      	ldr	r0, [r0, #4]
    28e0:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    28e4:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
    28e8:	b001      	add	sp, #4
    28ea:	2101      	movs	r1, #1
    28ec:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    28f0:	4710      	bx	r2
    28f2:	f894 002b 	ldrb.w	r0, [r4, #43]	; 0x2b
    28f6:	b140      	cbz	r0, 290a <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0xb2>
    28f8:	b919      	cbnz	r1, 2902 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0xaa>
    28fa:	f001 ffd3 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    28fe:	f884 602a 	strb.w	r6, [r4, #42]	; 0x2a
    2902:	2000      	movs	r0, #0
    2904:	f884 002b 	strb.w	r0, [r4, #43]	; 0x2b
    2908:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    290a:	f7ff fccf 	bl	22ac <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x560>
    290e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2912:	6060      	str	r0, [r4, #4]
    2914:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
    2918:	f88d 0000 	strb.w	r0, [sp]
    291c:	f89d 0000 	ldrb.w	r0, [sp]
    2920:	b188      	cbz	r0, 2946 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0xee>
    2922:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    2926:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    292a:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    292e:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    2932:	6840      	ldr	r0, [r0, #4]
    2934:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    2938:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
    293c:	b001      	add	sp, #4
    293e:	2106      	movs	r1, #6
    2940:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    2944:	4710      	bx	r2
    2946:	f44f 6105 	mov.w	r1, #2128	; 0x850
    294a:	2070      	movs	r0, #112	; 0x70
    294c:	f002 f932 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2950:	f7ff fcac 	bl	22ac <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x560>
    2954:	f884 6026 	strb.w	r6, [r4, #38]	; 0x26
    2958:	f002 f8b4 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    295c:	b120      	cbz	r0, 2968 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x110>
    295e:	f894 002a 	ldrb.w	r0, [r4, #42]	; 0x2a
    2962:	b130      	cbz	r0, 2972 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x11a>
    2964:	e009      	b.n	297a <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x122>
    2966:	e04a      	b.n	29fe <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x1a6>
    2968:	f640 015e 	movw	r1, #2142	; 0x85e
    296c:	2070      	movs	r0, #112	; 0x70
    296e:	f002 f921 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2972:	f001 ff97 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    2976:	f884 602a 	strb.w	r6, [r4, #42]	; 0x2a
    297a:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    297e:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    2982:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    2986:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    298a:	6840      	ldr	r0, [r0, #4]
    298c:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    2990:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
    2994:	b001      	add	sp, #4
    2996:	2100      	movs	r1, #0
    2998:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    299c:	4710      	bx	r2
    299e:	f001 fd73 	bl	4488 <sym_52O7VXVVZYQGD3Z6C3FDJLGBNMQQ6XC5LJ3IFRQ>
    29a2:	8ae0      	ldrh	r0, [r4, #22]
    29a4:	b110      	cbz	r0, 29ac <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x154>
    29a6:	f002 f88d 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    29aa:	b128      	cbz	r0, 29b8 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x160>
    29ac:	f001 fd80 	bl	44b0 <sym_7TCBS6SSQW4V3WJBKAXLOSA2HN4KF7UYAM2QFKI>
    29b0:	2800      	cmp	r0, #0
    29b2:	bf18      	it	ne
    29b4:	7766      	strbne	r6, [r4, #29]
    29b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    29b8:	f640 0168 	movw	r1, #2152	; 0x868
    29bc:	2070      	movs	r0, #112	; 0x70
    29be:	f002 f8f9 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    29c2:	4813      	ldr	r0, [pc, #76]	; (2a10 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA+0x1b8>)
    29c4:	6006      	str	r6, [r0, #0]
    29c6:	6890      	ldr	r0, [r2, #8]
    29c8:	6006      	str	r6, [r0, #0]
    29ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    29cc:	7810      	ldrb	r0, [r2, #0]
    29ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    29d2:	f002 b9c3 	b.w	4d5c <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q>
    29d6:	f7ff fc69 	bl	22ac <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x560>
    29da:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    29de:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    29e2:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    29e6:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    29ea:	6840      	ldr	r0, [r0, #4]
    29ec:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    29f0:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
    29f4:	b001      	add	sp, #4
    29f6:	2105      	movs	r1, #5
    29f8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    29fc:	4710      	bx	r2
    29fe:	f640 017b 	movw	r1, #2171	; 0x87b
    2a02:	2070      	movs	r0, #112	; 0x70
    2a04:	f002 f8d6 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2a08:	200011cc 	.word	0x200011cc
    2a0c:	20000038 	.word	0x20000038
    2a10:	40000508 	.word	0x40000508

00002a14 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY>:
    2a14:	e92d 4ff3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2a18:	4682      	mov	sl, r0
    2a1a:	48ee      	ldr	r0, [pc, #952]	; (2dd4 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3c0>)
    2a1c:	b08d      	sub	sp, #52	; 0x34
    2a1e:	6800      	ldr	r0, [r0, #0]
    2a20:	4ded      	ldr	r5, [pc, #948]	; (2dd8 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3c4>)
    2a22:	05c0      	lsls	r0, r0, #23
    2a24:	0dc0      	lsrs	r0, r0, #23
    2a26:	d00e      	beq.n	2a46 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x32>
    2a28:	3810      	subs	r0, #16
    2a2a:	b240      	sxtb	r0, r0
    2a2c:	2800      	cmp	r0, #0
    2a2e:	bfb8      	it	lt
    2a30:	f000 000f 	andlt.w	r0, r0, #15
    2a34:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    2a38:	bfac      	ite	ge
    2a3a:	f890 0400 	ldrbge.w	r0, [r0, #1024]	; 0x400
    2a3e:	f890 0d14 	ldrblt.w	r0, [r0, #3348]	; 0xd14
    2a42:	0940      	lsrs	r0, r0, #5
    2a44:	d00d      	beq.n	2a62 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x4e>
    2a46:	980e      	ldr	r0, [sp, #56]	; 0x38
    2a48:	f04f 0b00 	mov.w	fp, #0
    2a4c:	7800      	ldrb	r0, [r0, #0]
    2a4e:	2800      	cmp	r0, #0
    2a50:	bf18      	it	ne
    2a52:	2801      	cmpne	r0, #1
    2a54:	d018      	beq.n	2a88 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x74>
    2a56:	f240 7104 	movw	r1, #1796	; 0x704
    2a5a:	f04f 0070 	mov.w	r0, #112	; 0x70
    2a5e:	f002 f8a9 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2a62:	f895 002d 	ldrb.w	r0, [r5, #45]	; 0x2d
    2a66:	f04f 0b01 	mov.w	fp, #1
    2a6a:	2820      	cmp	r0, #32
    2a6c:	d007      	beq.n	2a7e <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x6a>
    2a6e:	980e      	ldr	r0, [sp, #56]	; 0x38
    2a70:	7800      	ldrb	r0, [r0, #0]
    2a72:	b148      	cbz	r0, 2a88 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x74>
    2a74:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    2a78:	2070      	movs	r0, #112	; 0x70
    2a7a:	f002 f89b 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2a7e:	f240 61fd 	movw	r1, #1789	; 0x6fd
    2a82:	2070      	movs	r0, #112	; 0x70
    2a84:	f002 f896 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    2a88:	4cd4      	ldr	r4, [pc, #848]	; (2ddc <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3c8>)
    2a8a:	b124      	cbz	r4, 2a96 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x82>
    2a8c:	2100      	movs	r1, #0
    2a8e:	f240 7007 	movw	r0, #1799	; 0x707
    2a92:	f3af 8000 	nop.w
    2a96:	2000      	movs	r0, #0
    2a98:	e9cd 000a 	strd	r0, r0, [sp, #40]	; 0x28
    2a9c:	49d0      	ldr	r1, [pc, #832]	; (2de0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3cc>)
    2a9e:	ebca 00ca 	rsb	r0, sl, sl, lsl #3
    2aa2:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    2aa6:	f04f 0901 	mov.w	r9, #1
    2aaa:	9000      	str	r0, [sp, #0]
    2aac:	b124      	cbz	r4, 2ab8 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0xa4>
    2aae:	2100      	movs	r1, #0
    2ab0:	f240 7012 	movw	r0, #1810	; 0x712
    2ab4:	f3af 8000 	nop.w
    2ab8:	f1b9 0f00 	cmp.w	r9, #0
    2abc:	d00a      	beq.n	2ad4 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0xc0>
    2abe:	bf00      	nop
    2ac0:	f895 602c 	ldrb.w	r6, [r5, #44]	; 0x2c
    2ac4:	f04f 0800 	mov.w	r8, #0
    2ac8:	f885 8029 	strb.w	r8, [r5, #41]	; 0x29
    2acc:	f1bb 0f00 	cmp.w	fp, #0
    2ad0:	d007      	beq.n	2ae2 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0xce>
    2ad2:	e038      	b.n	2b46 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x132>
    2ad4:	48c3      	ldr	r0, [pc, #780]	; (2de4 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3d0>)
    2ad6:	2800      	cmp	r0, #0
    2ad8:	bf18      	it	ne
    2ada:	f3af 8000 	nopne.w
    2ade:	b662      	cpsie	i
    2ae0:	e7ee      	b.n	2ac0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0xac>
    2ae2:	4637      	mov	r7, r6
    2ae4:	2001      	movs	r0, #1
    2ae6:	ea20 0607 	bic.w	r6, r0, r7
    2aea:	48bf      	ldr	r0, [pc, #764]	; (2de8 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3d4>)
    2aec:	2240      	movs	r2, #64	; 0x40
    2aee:	eb00 1187 	add.w	r1, r0, r7, lsl #6
    2af2:	eb00 1086 	add.w	r0, r0, r6, lsl #6
    2af6:	f00a fa71 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    2afa:	b124      	cbz	r4, 2b06 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0xf2>
    2afc:	2100      	movs	r1, #0
    2afe:	f240 502f 	movw	r0, #1327	; 0x52f
    2b02:	f3af 8000 	nop.w
    2b06:	eb07 0147 	add.w	r1, r7, r7, lsl #1
    2b0a:	eb06 0046 	add.w	r0, r6, r6, lsl #1
    2b0e:	4429      	add	r1, r5
    2b10:	4428      	add	r0, r5
    2b12:	8c0a      	ldrh	r2, [r1, #32]
    2b14:	8402      	strh	r2, [r0, #32]
    2b16:	f891 1022 	ldrb.w	r1, [r1, #34]	; 0x22
    2b1a:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
    2b1e:	b124      	cbz	r4, 2b2a <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x116>
    2b20:	2100      	movs	r1, #0
    2b22:	f240 5033 	movw	r0, #1331	; 0x533
    2b26:	f3af 8000 	nop.w
    2b2a:	b124      	cbz	r4, 2b36 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x122>
    2b2c:	2100      	movs	r1, #0
    2b2e:	f240 701c 	movw	r0, #1820	; 0x71c
    2b32:	f3af 8000 	nop.w
    2b36:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
    2b3a:	f88d 0018 	strb.w	r0, [sp, #24]
    2b3e:	f89d 0018 	ldrb.w	r0, [sp, #24]
    2b42:	2800      	cmp	r0, #0
    2b44:	d1b2      	bne.n	2aac <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x98>
    2b46:	b124      	cbz	r4, 2b52 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x13e>
    2b48:	2100      	movs	r1, #0
    2b4a:	f240 7026 	movw	r0, #1830	; 0x726
    2b4e:	f3af 8000 	nop.w
    2b52:	a806      	add	r0, sp, #24
    2b54:	f001 f916 	bl	3d84 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ>
    2b58:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    2b5c:	e9cd 0108 	strd	r0, r1, [sp, #32]
    2b60:	4633      	mov	r3, r6
    2b62:	aa01      	add	r2, sp, #4
    2b64:	a808      	add	r0, sp, #32
    2b66:	990e      	ldr	r1, [sp, #56]	; 0x38
    2b68:	f7ff fac4 	bl	20f4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x3a8>
    2b6c:	b124      	cbz	r4, 2b78 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x164>
    2b6e:	2100      	movs	r1, #0
    2b70:	f240 702d 	movw	r0, #1837	; 0x72d
    2b74:	f3af 8000 	nop.w
    2b78:	4a9b      	ldr	r2, [pc, #620]	; (2de8 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3d4>)
    2b7a:	9908      	ldr	r1, [sp, #32]
    2b7c:	eb02 1786 	add.w	r7, r2, r6, lsl #6
    2b80:	a801      	add	r0, sp, #4
    2b82:	f817 201a 	ldrb.w	r2, [r7, sl, lsl #1]
    2b86:	2a01      	cmp	r2, #1
    2b88:	bf18      	it	ne
    2b8a:	2a02      	cmpne	r2, #2
    2b8c:	d138      	bne.n	2c00 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x1ec>
    2b8e:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    2b92:	9a01      	ldr	r2, [sp, #4]
    2b94:	9b02      	ldr	r3, [sp, #8]
    2b96:	eba2 0201 	sub.w	r2, r2, r1
    2b9a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    2b9e:	eba3 0101 	sub.w	r1, r3, r1
    2ba2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    2ba6:	2a02      	cmp	r2, #2
    2ba8:	d360      	bcc.n	2c6c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x258>
    2baa:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    2bae:	bf98      	it	ls
    2bb0:	f5b1 0f00 	cmpls.w	r1, #8388608	; 0x800000
    2bb4:	d85a      	bhi.n	2c6c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x258>
    2bb6:	f04f 0801 	mov.w	r8, #1
    2bba:	ab07      	add	r3, sp, #28
    2bbc:	aa06      	add	r2, sp, #24
    2bbe:	4631      	mov	r1, r6
    2bc0:	f7fe ff3a 	bl	1a38 <MPSL_IRQ_RADIO_Handler+0x41c>
    2bc4:	2800      	cmp	r0, #0
    2bc6:	d059      	beq.n	2c7c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x268>
    2bc8:	f89d 1018 	ldrb.w	r1, [sp, #24]
    2bcc:	f89d 201c 	ldrb.w	r2, [sp, #28]
    2bd0:	4633      	mov	r3, r6
    2bd2:	428a      	cmp	r2, r1
    2bd4:	d056      	beq.n	2c84 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x270>
    2bd6:	2005      	movs	r0, #5
    2bd8:	f7fe fd40 	bl	165c <MPSL_IRQ_RADIO_Handler+0x40>
    2bdc:	eb07 014a 	add.w	r1, r7, sl, lsl #1
    2be0:	7048      	strb	r0, [r1, #1]
    2be2:	f89d 0018 	ldrb.w	r0, [sp, #24]
    2be6:	2820      	cmp	r0, #32
    2be8:	bf1c      	itt	ne
    2bea:	eb07 0040 	addne.w	r0, r7, r0, lsl #1
    2bee:	f880 a001 	strbne.w	sl, [r0, #1]
    2bf2:	d053      	beq.n	2c9c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x288>
    2bf4:	4632      	mov	r2, r6
    2bf6:	4651      	mov	r1, sl
    2bf8:	f05f 0003 	movs.w	r0, #3
    2bfc:	f7ff fc42 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    2c00:	b124      	cbz	r4, 2c0c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x1f8>
    2c02:	2100      	movs	r1, #0
    2c04:	f240 7032 	movw	r0, #1842	; 0x732
    2c08:	f3af 8000 	nop.w
    2c0c:	4877      	ldr	r0, [pc, #476]	; (2dec <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3d8>)
    2c0e:	2800      	cmp	r0, #0
    2c10:	bf18      	it	ne
    2c12:	f3af 8000 	nopne.w
    2c16:	f3ef 8910 	mrs	r9, PRIMASK
    2c1a:	b672      	cpsid	i
    2c1c:	b124      	cbz	r4, 2c28 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x214>
    2c1e:	2100      	movs	r1, #0
    2c20:	f44f 60e7 	mov.w	r0, #1848	; 0x738
    2c24:	f3af 8000 	nop.w
    2c28:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
    2c2c:	f88d 0018 	strb.w	r0, [sp, #24]
    2c30:	f89d 0018 	ldrb.w	r0, [sp, #24]
    2c34:	2800      	cmp	r0, #0
    2c36:	f47f af39 	bne.w	2aac <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x98>
    2c3a:	b124      	cbz	r4, 2c46 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x232>
    2c3c:	2100      	movs	r1, #0
    2c3e:	f44f 60e8 	mov.w	r0, #1856	; 0x740
    2c42:	f3af 8000 	nop.w
    2c46:	e89d 108f 	ldmia.w	sp, {r0, r1, r2, r3, r7, ip}
    2c4a:	f100 0008 	add.w	r0, r0, #8
    2c4e:	f1b8 0f00 	cmp.w	r8, #0
    2c52:	e880 108e 	stmia.w	r0, {r1, r2, r3, r7, ip}
    2c56:	d053      	beq.n	2d00 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2ec>
    2c58:	b124      	cbz	r4, 2c64 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x250>
    2c5a:	2100      	movs	r1, #0
    2c5c:	f240 704d 	movw	r0, #1869	; 0x74d
    2c60:	f3af 8000 	nop.w
    2c64:	f1bb 0f00 	cmp.w	fp, #0
    2c68:	d13a      	bne.n	2ce0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2cc>
    2c6a:	e01f      	b.n	2cac <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x298>
    2c6c:	4632      	mov	r2, r6
    2c6e:	4651      	mov	r1, sl
    2c70:	2004      	movs	r0, #4
    2c72:	f7ff fc07 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    2c76:	f04f 0801 	mov.w	r8, #1
    2c7a:	e7c1      	b.n	2c00 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x1ec>
    2c7c:	4632      	mov	r2, r6
    2c7e:	4651      	mov	r1, sl
    2c80:	2004      	movs	r0, #4
    2c82:	e7bb      	b.n	2bfc <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x1e8>
    2c84:	2920      	cmp	r1, #32
    2c86:	bf19      	ittee	ne
    2c88:	eb07 0041 	addne.w	r0, r7, r1, lsl #1
    2c8c:	7840      	ldrbne	r0, [r0, #1]
    2c8e:	eb06 0046 	addeq.w	r0, r6, r6, lsl #1
    2c92:	4428      	addeq	r0, r5
    2c94:	bf08      	it	eq
    2c96:	f890 0020 	ldrbeq.w	r0, [r0, #32]
    2c9a:	e79f      	b.n	2bdc <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x1c8>
    2c9c:	eb06 0146 	add.w	r1, r6, r6, lsl #1
    2ca0:	4429      	add	r1, r5
    2ca2:	f881 a020 	strb.w	sl, [r1, #32]
    2ca6:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    2caa:	e7a3      	b.n	2bf4 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x1e0>
    2cac:	980b      	ldr	r0, [sp, #44]	; 0x2c
    2cae:	f010 0fff 	tst.w	r0, #255	; 0xff
    2cb2:	d015      	beq.n	2ce0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2cc>
    2cb4:	f895 002d 	ldrb.w	r0, [r5, #45]	; 0x2d
    2cb8:	2820      	cmp	r0, #32
    2cba:	d111      	bne.n	2ce0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2cc>
    2cbc:	b124      	cbz	r4, 2cc8 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2b4>
    2cbe:	2100      	movs	r1, #0
    2cc0:	f240 7052 	movw	r0, #1874	; 0x752
    2cc4:	f3af 8000 	nop.w
    2cc8:	4632      	mov	r2, r6
    2cca:	2102      	movs	r1, #2
    2ccc:	9808      	ldr	r0, [sp, #32]
    2cce:	f7ff fc0b 	bl	24e8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x79c>
    2cd2:	900a      	str	r0, [sp, #40]	; 0x28
    2cd4:	b920      	cbnz	r0, 2ce0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2cc>
    2cd6:	980e      	ldr	r0, [sp, #56]	; 0x38
    2cd8:	7800      	ldrb	r0, [r0, #0]
    2cda:	b1f0      	cbz	r0, 2d1a <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x306>
    2cdc:	2801      	cmp	r0, #1
    2cde:	d02b      	beq.n	2d38 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x324>
    2ce0:	b124      	cbz	r4, 2cec <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2d8>
    2ce2:	2100      	movs	r1, #0
    2ce4:	f240 706f 	movw	r0, #1903	; 0x76f
    2ce8:	f3af 8000 	nop.w
    2cec:	20ff      	movs	r0, #255	; 0xff
    2cee:	f1bb 0f00 	cmp.w	fp, #0
    2cf2:	bf18      	it	ne
    2cf4:	f885 0029 	strbne.w	r0, [r5, #41]	; 0x29
    2cf8:	d027      	beq.n	2d4a <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x336>
    2cfa:	bf00      	nop
    2cfc:	f04f 0801 	mov.w	r8, #1
    2d00:	b124      	cbz	r4, 2d0c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2f8>
    2d02:	2100      	movs	r1, #0
    2d04:	f44f 60f0 	mov.w	r0, #1920	; 0x780
    2d08:	f3af 8000 	nop.w
    2d0c:	980a      	ldr	r0, [sp, #40]	; 0x28
    2d0e:	4e38      	ldr	r6, [pc, #224]	; (2df0 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3dc>)
    2d10:	2802      	cmp	r0, #2
    2d12:	d023      	beq.n	2d5c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x348>
    2d14:	2801      	cmp	r0, #1
    2d16:	d029      	beq.n	2d6c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x358>
    2d18:	e02d      	b.n	2d76 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x362>
    2d1a:	b124      	cbz	r4, 2d26 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x312>
    2d1c:	2100      	movs	r1, #0
    2d1e:	f240 705a 	movw	r0, #1882	; 0x75a
    2d22:	f3af 8000 	nop.w
    2d26:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
    2d2a:	4651      	mov	r1, sl
    2d2c:	2004      	movs	r0, #4
    2d2e:	f7ff fba9 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    2d32:	f04f 0801 	mov.w	r8, #1
    2d36:	e7e3      	b.n	2d00 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2ec>
    2d38:	2c00      	cmp	r4, #0
    2d3a:	f43f aeb7 	beq.w	2aac <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x98>
    2d3e:	2100      	movs	r1, #0
    2d40:	f240 7065 	movw	r0, #1893	; 0x765
    2d44:	f3af 8000 	nop.w
    2d48:	e6b0      	b.n	2aac <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x98>
    2d4a:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
    2d4e:	2101      	movs	r1, #1
    2d50:	4391      	bics	r1, r2
    2d52:	f885 102c 	strb.w	r1, [r5, #44]	; 0x2c
    2d56:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
    2d5a:	e7cf      	b.n	2cfc <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x2e8>
    2d5c:	68a8      	ldr	r0, [r5, #8]
    2d5e:	9908      	ldr	r1, [sp, #32]
    2d60:	1a40      	subs	r0, r0, r1
    2d62:	f009 ffe1 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    2d66:	6871      	ldr	r1, [r6, #4]
    2d68:	b921      	cbnz	r1, 2d74 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x360>
    2d6a:	e004      	b.n	2d76 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x362>
    2d6c:	6871      	ldr	r1, [r6, #4]
    2d6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2d72:	b101      	cbz	r1, 2d76 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x362>
    2d74:	4788      	blx	r1
    2d76:	f1b9 0f00 	cmp.w	r9, #0
    2d7a:	d024      	beq.n	2dc6 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3b2>
    2d7c:	b124      	cbz	r4, 2d88 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x374>
    2d7e:	2100      	movs	r1, #0
    2d80:	f44f 60f2 	mov.w	r0, #1936	; 0x790
    2d84:	f3af 8000 	nop.w
    2d88:	f1b8 0f00 	cmp.w	r8, #0
    2d8c:	d011      	beq.n	2db2 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x39e>
    2d8e:	f895 002c 	ldrb.w	r0, [r5, #44]	; 0x2c
    2d92:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    2d96:	4428      	add	r0, r5
    2d98:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
    2d9c:	2820      	cmp	r0, #32
    2d9e:	d008      	beq.n	2db2 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x39e>
    2da0:	b124      	cbz	r4, 2dac <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x398>
    2da2:	2100      	movs	r1, #0
    2da4:	f240 7097 	movw	r0, #1943	; 0x797
    2da8:	f3af 8000 	nop.w
    2dac:	7870      	ldrb	r0, [r6, #1]
    2dae:	f001 ffd5 	bl	4d5c <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q>
    2db2:	b124      	cbz	r4, 2dbe <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3aa>
    2db4:	2100      	movs	r1, #0
    2db6:	f240 709c 	movw	r0, #1948	; 0x79c
    2dba:	f3af 8000 	nop.w
    2dbe:	b00f      	add	sp, #60	; 0x3c
    2dc0:	4640      	mov	r0, r8
    2dc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2dc6:	4807      	ldr	r0, [pc, #28]	; (2de4 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x3d0>)
    2dc8:	2800      	cmp	r0, #0
    2dca:	bf18      	it	ne
    2dcc:	f3af 8000 	nopne.w
    2dd0:	b662      	cpsie	i
    2dd2:	e7d3      	b.n	2d7c <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY+0x368>
    2dd4:	e000ed04 	.word	0xe000ed04
    2dd8:	200015cc 	.word	0x200015cc
    2ddc:	00000000 	.word	0x00000000
    2de0:	200011cc 	.word	0x200011cc
    2de4:	00000000 	.word	0x00000000
    2de8:	2000154c 	.word	0x2000154c
    2dec:	00000000 	.word	0x00000000
    2df0:	20000038 	.word	0x20000038

00002df4 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI>:
    2df4:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2df8:	48c9      	ldr	r0, [pc, #804]	; (3120 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x32c>)
    2dfa:	b08a      	sub	sp, #40	; 0x28
    2dfc:	6800      	ldr	r0, [r0, #0]
    2dfe:	05c0      	lsls	r0, r0, #23
    2e00:	0dc0      	lsrs	r0, r0, #23
    2e02:	d011      	beq.n	2e28 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x34>
    2e04:	3810      	subs	r0, #16
    2e06:	b240      	sxtb	r0, r0
    2e08:	2800      	cmp	r0, #0
    2e0a:	bfb8      	it	lt
    2e0c:	f000 000f 	andlt.w	r0, r0, #15
    2e10:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    2e14:	bfac      	ite	ge
    2e16:	f890 0400 	ldrbge.w	r0, [r0, #1024]	; 0x400
    2e1a:	f890 0d14 	ldrblt.w	r0, [r0, #3348]	; 0xd14
    2e1e:	0940      	lsrs	r0, r0, #5
    2e20:	bf08      	it	eq
    2e22:	f04f 0b01 	moveq.w	fp, #1
    2e26:	d001      	beq.n	2e2c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x38>
    2e28:	f04f 0b00 	mov.w	fp, #0
    2e2c:	980a      	ldr	r0, [sp, #40]	; 0x28
    2e2e:	7800      	ldrb	r0, [r0, #0]
    2e30:	2800      	cmp	r0, #0
    2e32:	bf1e      	ittt	ne
    2e34:	2000      	movne	r0, #0
    2e36:	b00b      	addne	sp, #44	; 0x2c
    2e38:	e8bd 8ff0 	ldmiane.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2e3c:	f04f 0a00 	mov.w	sl, #0
    2e40:	4db8      	ldr	r5, [pc, #736]	; (3124 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x330>)
    2e42:	4cb9      	ldr	r4, [pc, #740]	; (3128 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x334>)
    2e44:	46d1      	mov	r9, sl
    2e46:	b125      	cbz	r5, 2e52 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x5e>
    2e48:	2100      	movs	r1, #0
    2e4a:	f240 50b9 	movw	r0, #1465	; 0x5b9
    2e4e:	f3af 8000 	nop.w
    2e52:	f894 602c 	ldrb.w	r6, [r4, #44]	; 0x2c
    2e56:	f884 9029 	strb.w	r9, [r4, #41]	; 0x29
    2e5a:	f04f 0800 	mov.w	r8, #0
    2e5e:	b125      	cbz	r5, 2e6a <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x76>
    2e60:	2100      	movs	r1, #0
    2e62:	f240 50be 	movw	r0, #1470	; 0x5be
    2e66:	f3af 8000 	nop.w
    2e6a:	f1bb 0f00 	cmp.w	fp, #0
    2e6e:	d123      	bne.n	2eb8 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0xc4>
    2e70:	4637      	mov	r7, r6
    2e72:	2001      	movs	r0, #1
    2e74:	ea20 0607 	bic.w	r6, r0, r7
    2e78:	48ac      	ldr	r0, [pc, #688]	; (312c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x338>)
    2e7a:	2240      	movs	r2, #64	; 0x40
    2e7c:	eb00 1187 	add.w	r1, r0, r7, lsl #6
    2e80:	eb00 1086 	add.w	r0, r0, r6, lsl #6
    2e84:	f00a f8aa 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    2e88:	b125      	cbz	r5, 2e94 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0xa0>
    2e8a:	2100      	movs	r1, #0
    2e8c:	f240 502f 	movw	r0, #1327	; 0x52f
    2e90:	f3af 8000 	nop.w
    2e94:	eb07 0147 	add.w	r1, r7, r7, lsl #1
    2e98:	eb06 0046 	add.w	r0, r6, r6, lsl #1
    2e9c:	4421      	add	r1, r4
    2e9e:	4420      	add	r0, r4
    2ea0:	8c0a      	ldrh	r2, [r1, #32]
    2ea2:	8402      	strh	r2, [r0, #32]
    2ea4:	f891 1022 	ldrb.w	r1, [r1, #34]	; 0x22
    2ea8:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
    2eac:	b125      	cbz	r5, 2eb8 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0xc4>
    2eae:	2100      	movs	r1, #0
    2eb0:	f240 5033 	movw	r0, #1331	; 0x533
    2eb4:	f3af 8000 	nop.w
    2eb8:	b125      	cbz	r5, 2ec4 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0xd0>
    2eba:	2100      	movs	r1, #0
    2ebc:	f240 50c6 	movw	r0, #1478	; 0x5c6
    2ec0:	f3af 8000 	nop.w
    2ec4:	a808      	add	r0, sp, #32
    2ec6:	f000 ff5d 	bl	3d84 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ>
    2eca:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    2ece:	e9cd 0106 	strd	r0, r1, [sp, #24]
    2ed2:	4633      	mov	r3, r6
    2ed4:	466a      	mov	r2, sp
    2ed6:	a806      	add	r0, sp, #24
    2ed8:	990a      	ldr	r1, [sp, #40]	; 0x28
    2eda:	f7ff f90b 	bl	20f4 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x3a8>
    2ede:	b125      	cbz	r5, 2eea <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0xf6>
    2ee0:	2100      	movs	r1, #0
    2ee2:	f240 50cc 	movw	r0, #1484	; 0x5cc
    2ee6:	f3af 8000 	nop.w
    2eea:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    2eee:	2820      	cmp	r0, #32
    2ef0:	d019      	beq.n	2f26 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x132>
    2ef2:	68e0      	ldr	r0, [r4, #12]
    2ef4:	9900      	ldr	r1, [sp, #0]
    2ef6:	1a09      	subs	r1, r1, r0
    2ef8:	0209      	lsls	r1, r1, #8
    2efa:	17ca      	asrs	r2, r1, #31
    2efc:	eb01 6112 	add.w	r1, r1, r2, lsr #24
    2f00:	1209      	asrs	r1, r1, #8
    2f02:	d510      	bpl.n	2f26 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x132>
    2f04:	e9dd 2100 	ldrd	r2, r1, [sp]
    2f08:	1a89      	subs	r1, r1, r2
    2f0a:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
    2f0e:	4408      	add	r0, r1
    2f10:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    2f14:	e9cd 3000 	strd	r3, r0, [sp]
    2f18:	4293      	cmp	r3, r2
    2f1a:	d202      	bcs.n	2f22 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x12e>
    2f1c:	9802      	ldr	r0, [sp, #8]
    2f1e:	1c40      	adds	r0, r0, #1
    2f20:	9002      	str	r0, [sp, #8]
    2f22:	f04f 0801 	mov.w	r8, #1
    2f26:	b14d      	cbz	r5, 2f3c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x148>
    2f28:	2100      	movs	r1, #0
    2f2a:	f240 50df 	movw	r0, #1503	; 0x5df
    2f2e:	f3af 8000 	nop.w
    2f32:	2100      	movs	r1, #0
    2f34:	f240 50e5 	movw	r0, #1509	; 0x5e5
    2f38:	f3af 8000 	nop.w
    2f3c:	9900      	ldr	r1, [sp, #0]
    2f3e:	9806      	ldr	r0, [sp, #24]
    2f40:	9a01      	ldr	r2, [sp, #4]
    2f42:	1a09      	subs	r1, r1, r0
    2f44:	1a10      	subs	r0, r2, r0
    2f46:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    2f4a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    2f4e:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    2f52:	bf98      	it	ls
    2f54:	f5b0 0f00 	cmpls.w	r0, #8388608	; 0x800000
    2f58:	d803      	bhi.n	2f62 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x16e>
    2f5a:	f1bb 0f00 	cmp.w	fp, #0
    2f5e:	d10c      	bne.n	2f7a <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x186>
    2f60:	e003      	b.n	2f6a <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x176>
    2f62:	f1bb 0f00 	cmp.w	fp, #0
    2f66:	d039      	beq.n	2fdc <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x1e8>
    2f68:	e0c0      	b.n	30ec <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2f8>
    2f6a:	4633      	mov	r3, r6
    2f6c:	4669      	mov	r1, sp
    2f6e:	4870      	ldr	r0, [pc, #448]	; (3130 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x33c>)
    2f70:	9a06      	ldr	r2, [sp, #24]
    2f72:	f7fe fbaf 	bl	16d4 <MPSL_IRQ_RADIO_Handler+0xb8>
    2f76:	ea48 0800 	orr.w	r8, r8, r0
    2f7a:	f1b8 0f00 	cmp.w	r8, #0
    2f7e:	d023      	beq.n	2fc8 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x1d4>
    2f80:	9800      	ldr	r0, [sp, #0]
    2f82:	f009 fed1 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    2f86:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    2f8a:	f89d 200c 	ldrb.w	r2, [sp, #12]
    2f8e:	4b69      	ldr	r3, [pc, #420]	; (3134 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x340>)
    2f90:	4411      	add	r1, r2
    2f92:	1c49      	adds	r1, r1, #1
    2f94:	1842      	adds	r2, r0, r1
    2f96:	4298      	cmp	r0, r3
    2f98:	d856      	bhi.n	3048 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x254>
    2f9a:	4865      	ldr	r0, [pc, #404]	; (3130 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x33c>)
    2f9c:	4281      	cmp	r1, r0
    2f9e:	dc7c      	bgt.n	309a <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2a6>
    2fa0:	4240      	negs	r0, r0
    2fa2:	4281      	cmp	r1, r0
    2fa4:	db7a      	blt.n	309c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2a8>
    2fa6:	1c58      	adds	r0, r3, #1
    2fa8:	4290      	cmp	r0, r2
    2faa:	bfdc      	itt	le
    2fac:	f502 02f7 	addle.w	r2, r2, #8093696	; 0x7b8000
    2fb0:	f1a2 52f8 	suble.w	r2, r2, #520093696	; 0x1f000000
    2fb4:	dd05      	ble.n	2fc2 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x1ce>
    2fb6:	2a00      	cmp	r2, #0
    2fb8:	bfbc      	itt	lt
    2fba:	f5a2 02f7 	sublt.w	r2, r2, #8093696	; 0x7b8000
    2fbe:	f102 52f8 	addlt.w	r2, r2, #520093696	; 0x1f000000
    2fc2:	980a      	ldr	r0, [sp, #40]	; 0x28
    2fc4:	e9c0 2904 	strd	r2, r9, [r0, #16]
    2fc8:	f04f 0a01 	mov.w	sl, #1
    2fcc:	2d00      	cmp	r5, #0
    2fce:	d07c      	beq.n	30ca <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2d6>
    2fd0:	2100      	movs	r1, #0
    2fd2:	f44f 60bf 	mov.w	r0, #1528	; 0x5f8
    2fd6:	f3af 8000 	nop.w
    2fda:	e087      	b.n	30ec <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2f8>
    2fdc:	9807      	ldr	r0, [sp, #28]
    2fde:	9002      	str	r0, [sp, #8]
    2fe0:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    2fe4:	aa08      	add	r2, sp, #32
    2fe6:	a905      	add	r1, sp, #20
    2fe8:	f8dd 8018 	ldr.w	r8, [sp, #24]
    2fec:	f000 fd5a 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    2ff0:	f001 fa68 	bl	44c4 <sym_HUWGHJMM42MANQTSVL3EY7E3VE4XM4JTQUIQAII>
    2ff4:	f000 fd3a 	bl	3a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>
    2ff8:	4607      	mov	r7, r0
    2ffa:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    2ffe:	2820      	cmp	r0, #32
    3000:	d027      	beq.n	3052 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x25e>
    3002:	68e0      	ldr	r0, [r4, #12]
    3004:	1d40      	adds	r0, r0, #5
    3006:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    300a:	bf00      	nop
    300c:	e9dd 2100 	ldrd	r2, r1, [sp]
    3010:	1a89      	subs	r1, r1, r2
    3012:	9000      	str	r0, [sp, #0]
    3014:	4408      	add	r0, r1
    3016:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    301a:	9001      	str	r0, [sp, #4]
    301c:	9800      	ldr	r0, [sp, #0]
    301e:	4540      	cmp	r0, r8
    3020:	d202      	bcs.n	3028 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x234>
    3022:	9802      	ldr	r0, [sp, #8]
    3024:	1c40      	adds	r0, r0, #1
    3026:	9002      	str	r0, [sp, #8]
    3028:	201f      	movs	r0, #31
    302a:	f88d 000c 	strb.w	r0, [sp, #12]
    302e:	9800      	ldr	r0, [sp, #0]
    3030:	f009 fe7a 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    3034:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    3038:	f89d 200c 	ldrb.w	r2, [sp, #12]
    303c:	4b3d      	ldr	r3, [pc, #244]	; (3134 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x340>)
    303e:	4411      	add	r1, r2
    3040:	1c49      	adds	r1, r1, #1
    3042:	1842      	adds	r2, r0, r1
    3044:	4298      	cmp	r0, r3
    3046:	d92a      	bls.n	309e <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2aa>
    3048:	f240 516f 	movw	r1, #1391	; 0x56f
    304c:	2070      	movs	r0, #112	; 0x70
    304e:	f001 fdb1 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3052:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    3056:	f108 0609 	add.w	r6, r8, #9
    305a:	b1b0      	cbz	r0, 308a <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x296>
    305c:	f001 fd32 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    3060:	b998      	cbnz	r0, 308a <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x296>
    3062:	f001 fbfd 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    3066:	f5b0 7fc6 	cmp.w	r0, #396	; 0x18c
    306a:	bf08      	it	eq
    306c:	200d      	moveq	r0, #13
    306e:	d00b      	beq.n	3088 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x294>
    3070:	f5a0 7040 	sub.w	r0, r0, #768	; 0x300
    3074:	3856      	subs	r0, #86	; 0x56
    3076:	bf08      	it	eq
    3078:	201c      	moveq	r0, #28
    307a:	d005      	beq.n	3088 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x294>
    307c:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
    3080:	389f      	subs	r0, #159	; 0x9f
    3082:	bf14      	ite	ne
    3084:	4648      	movne	r0, r9
    3086:	2032      	moveq	r0, #50	; 0x32
    3088:	4406      	add	r6, r0
    308a:	9805      	ldr	r0, [sp, #20]
    308c:	4287      	cmp	r7, r0
    308e:	bf84      	itt	hi
    3090:	1a38      	subhi	r0, r7, r0
    3092:	4406      	addhi	r6, r0
    3094:	f026 407f 	bic.w	r0, r6, #4278190080	; 0xff000000
    3098:	e7b8      	b.n	300c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x218>
    309a:	e003      	b.n	30a4 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2b0>
    309c:	e00a      	b.n	30b4 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2c0>
    309e:	4824      	ldr	r0, [pc, #144]	; (3130 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x33c>)
    30a0:	4281      	cmp	r1, r0
    30a2:	dd04      	ble.n	30ae <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2ba>
    30a4:	f44f 61ae 	mov.w	r1, #1392	; 0x570
    30a8:	2070      	movs	r0, #112	; 0x70
    30aa:	f001 fd83 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    30ae:	4822      	ldr	r0, [pc, #136]	; (3138 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x344>)
    30b0:	4281      	cmp	r1, r0
    30b2:	da04      	bge.n	30be <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2ca>
    30b4:	f240 5171 	movw	r1, #1393	; 0x571
    30b8:	2070      	movs	r0, #112	; 0x70
    30ba:	f001 fd7b 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    30be:	481f      	ldr	r0, [pc, #124]	; (313c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x348>)
    30c0:	4290      	cmp	r0, r2
    30c2:	bfd8      	it	le
    30c4:	f502 02f7 	addle.w	r2, r2, #8093696	; 0x7b8000
    30c8:	e000      	b.n	30cc <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2d8>
    30ca:	e00f      	b.n	30ec <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2f8>
    30cc:	bfd8      	it	le
    30ce:	f1a2 52f8 	suble.w	r2, r2, #520093696	; 0x1f000000
    30d2:	dd05      	ble.n	30e0 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x2ec>
    30d4:	2a00      	cmp	r2, #0
    30d6:	bfbc      	itt	lt
    30d8:	f5a2 02f7 	sublt.w	r2, r2, #8093696	; 0x7b8000
    30dc:	f102 52f8 	addlt.w	r2, r2, #520093696	; 0x1f000000
    30e0:	980a      	ldr	r0, [sp, #40]	; 0x28
    30e2:	f04f 0a01 	mov.w	sl, #1
    30e6:	46d0      	mov	r8, sl
    30e8:	e9c0 2904 	strd	r2, r9, [r0, #16]
    30ec:	ea1a 0f08 	tst.w	sl, r8
    30f0:	d009      	beq.n	3106 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x312>
    30f2:	980a      	ldr	r0, [sp, #40]	; 0x28
    30f4:	4911      	ldr	r1, [pc, #68]	; (313c <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x348>)
    30f6:	9b02      	ldr	r3, [sp, #8]
    30f8:	e9d0 2004 	ldrd	r2, r0, [r0, #16]
    30fc:	fbe3 2001 	umlal	r2, r0, r3, r1
    3100:	990a      	ldr	r1, [sp, #40]	; 0x28
    3102:	e9c1 2004 	strd	r2, r0, [r1, #16]
    3106:	f894 0029 	ldrb.w	r0, [r4, #41]	; 0x29
    310a:	f88d 0014 	strb.w	r0, [sp, #20]
    310e:	f89d 0014 	ldrb.w	r0, [sp, #20]
    3112:	2800      	cmp	r0, #0
    3114:	f47f ae97 	bne.w	2e46 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI+0x52>
    3118:	b00b      	add	sp, #44	; 0x2c
    311a:	4650      	mov	r0, sl
    311c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3120:	e000ed04 	.word	0xe000ed04
    3124:	00000000 	.word	0x00000000
    3128:	200015cc 	.word	0x200015cc
    312c:	2000154c 	.word	0x2000154c
    3130:	0f424000 	.word	0x0f424000
    3134:	1e847fff 	.word	0x1e847fff
    3138:	f0bdc000 	.word	0xf0bdc000
    313c:	1e848000 	.word	0x1e848000

00003140 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY>:
    3140:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3144:	4d94      	ldr	r5, [pc, #592]	; (3398 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x258>)
    3146:	b08c      	sub	sp, #48	; 0x30
    3148:	f895 002c 	ldrb.w	r0, [r5, #44]	; 0x2c
    314c:	2000      	movs	r0, #0
    314e:	9009      	str	r0, [sp, #36]	; 0x24
    3150:	9006      	str	r0, [sp, #24]
    3152:	2001      	movs	r0, #1
    3154:	f1a5 0980 	sub.w	r9, r5, #128	; 0x80
    3158:	f04f 0800 	mov.w	r8, #0
    315c:	4607      	mov	r7, r0
    315e:	4c8f      	ldr	r4, [pc, #572]	; (339c <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x25c>)
    3160:	f8cd 001c 	str.w	r0, [sp, #28]
    3164:	f000 fe08 	bl	3d78 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY>
    3168:	9008      	str	r0, [sp, #32]
    316a:	b124      	cbz	r4, 3176 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x36>
    316c:	2100      	movs	r1, #0
    316e:	f44f 60f6 	mov.w	r0, #1968	; 0x7b0
    3172:	f3af 8000 	nop.w
    3176:	9807      	ldr	r0, [sp, #28]
    3178:	2800      	cmp	r0, #0
    317a:	d03c      	beq.n	31f6 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0xb6>
    317c:	f885 8029 	strb.w	r8, [r5, #41]	; 0x29
    3180:	b124      	cbz	r4, 318c <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x4c>
    3182:	2100      	movs	r1, #0
    3184:	f240 70b5 	movw	r0, #1973	; 0x7b5
    3188:	f3af 8000 	nop.w
    318c:	f895 a02c 	ldrb.w	sl, [r5, #44]	; 0x2c
    3190:	2240      	movs	r2, #64	; 0x40
    3192:	ea27 060a 	bic.w	r6, r7, sl
    3196:	eb09 1086 	add.w	r0, r9, r6, lsl #6
    319a:	eb09 118a 	add.w	r1, r9, sl, lsl #6
    319e:	4683      	mov	fp, r0
    31a0:	f009 ff1c 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    31a4:	b124      	cbz	r4, 31b0 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x70>
    31a6:	2100      	movs	r1, #0
    31a8:	f240 502f 	movw	r0, #1327	; 0x52f
    31ac:	f3af 8000 	nop.w
    31b0:	eb06 0046 	add.w	r0, r6, r6, lsl #1
    31b4:	eb0a 014a 	add.w	r1, sl, sl, lsl #1
    31b8:	4428      	add	r0, r5
    31ba:	4429      	add	r1, r5
    31bc:	9000      	str	r0, [sp, #0]
    31be:	8c0a      	ldrh	r2, [r1, #32]
    31c0:	8402      	strh	r2, [r0, #32]
    31c2:	f891 1022 	ldrb.w	r1, [r1, #34]	; 0x22
    31c6:	f880 1022 	strb.w	r1, [r0, #34]	; 0x22
    31ca:	b124      	cbz	r4, 31d6 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x96>
    31cc:	2100      	movs	r1, #0
    31ce:	f240 5033 	movw	r0, #1331	; 0x533
    31d2:	f3af 8000 	nop.w
    31d6:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
    31da:	f88d 0008 	strb.w	r0, [sp, #8]
    31de:	f89d 0008 	ldrb.w	r0, [sp, #8]
    31e2:	b178      	cbz	r0, 3204 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0xc4>
    31e4:	2c00      	cmp	r4, #0
    31e6:	bf1c      	itt	ne
    31e8:	2100      	movne	r1, #0
    31ea:	f240 70bb 	movwne	r0, #1979	; 0x7bb
    31ee:	d0b9      	beq.n	3164 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x24>
    31f0:	f3af 8000 	nop.w
    31f4:	e7b6      	b.n	3164 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x24>
    31f6:	486a      	ldr	r0, [pc, #424]	; (33a0 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x260>)
    31f8:	2800      	cmp	r0, #0
    31fa:	bf18      	it	ne
    31fc:	f3af 8000 	nopne.w
    3200:	b662      	cpsie	i
    3202:	e7bb      	b.n	317c <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x3c>
    3204:	b124      	cbz	r4, 3210 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0xd0>
    3206:	2100      	movs	r1, #0
    3208:	f240 70bf 	movw	r0, #1983	; 0x7bf
    320c:	f3af 8000 	nop.w
    3210:	980c      	ldr	r0, [sp, #48]	; 0x30
    3212:	f81b 0010 	ldrb.w	r0, [fp, r0, lsl #1]
    3216:	2803      	cmp	r0, #3
    3218:	d17d      	bne.n	3316 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1d6>
    321a:	9a00      	ldr	r2, [sp, #0]
    321c:	990c      	ldr	r1, [sp, #48]	; 0x30
    321e:	f892 0020 	ldrb.w	r0, [r2, #32]
    3222:	4288      	cmp	r0, r1
    3224:	bf14      	ite	ne
    3226:	f04f 0a00 	movne.w	sl, #0
    322a:	f04f 0a01 	moveq.w	sl, #1
    322e:	f102 0c20 	add.w	ip, r2, #32
    3232:	4683      	mov	fp, r0
    3234:	2220      	movs	r2, #32
    3236:	eb09 1386 	add.w	r3, r9, r6, lsl #6
    323a:	e003      	b.n	3244 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x104>
    323c:	4602      	mov	r2, r0
    323e:	eb03 0042 	add.w	r0, r3, r2, lsl #1
    3242:	7840      	ldrb	r0, [r0, #1]
    3244:	4288      	cmp	r0, r1
    3246:	d002      	beq.n	324e <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x10e>
    3248:	2820      	cmp	r0, #32
    324a:	d00a      	beq.n	3262 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x122>
    324c:	e7f6      	b.n	323c <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0xfc>
    324e:	2820      	cmp	r0, #32
    3250:	d007      	beq.n	3262 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x122>
    3252:	4583      	cmp	fp, r0
    3254:	d107      	bne.n	3266 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x126>
    3256:	eb03 004b 	add.w	r0, r3, fp, lsl #1
    325a:	7840      	ldrb	r0, [r0, #1]
    325c:	f88c 0000 	strb.w	r0, [ip]
    3260:	e007      	b.n	3272 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x132>
    3262:	4640      	mov	r0, r8
    3264:	e00c      	b.n	3280 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x140>
    3266:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    326a:	eb03 0142 	add.w	r1, r3, r2, lsl #1
    326e:	7840      	ldrb	r0, [r0, #1]
    3270:	7048      	strb	r0, [r1, #1]
    3272:	b124      	cbz	r4, 327e <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x13e>
    3274:	2100      	movs	r1, #0
    3276:	f240 409a 	movw	r0, #1178	; 0x49a
    327a:	f3af 8000 	nop.w
    327e:	4638      	mov	r0, r7
    3280:	46c3      	mov	fp, r8
    3282:	ea10 0f0a 	tst.w	r0, sl
    3286:	bf18      	it	ne
    3288:	46bb      	movne	fp, r7
    328a:	2800      	cmp	r0, #0
    328c:	d04f      	beq.n	332e <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1ee>
    328e:	b124      	cbz	r4, 329a <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x15a>
    3290:	2100      	movs	r1, #0
    3292:	f240 70c4 	movw	r0, #1988	; 0x7c4
    3296:	f3af 8000 	nop.w
    329a:	4632      	mov	r2, r6
    329c:	2001      	movs	r0, #1
    329e:	990c      	ldr	r1, [sp, #48]	; 0x30
    32a0:	f7ff f8f0 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    32a4:	b124      	cbz	r4, 32b0 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x170>
    32a6:	2100      	movs	r1, #0
    32a8:	f240 70cd 	movw	r0, #1997	; 0x7cd
    32ac:	f3af 8000 	nop.w
    32b0:	483c      	ldr	r0, [pc, #240]	; (33a4 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x264>)
    32b2:	2800      	cmp	r0, #0
    32b4:	bf18      	it	ne
    32b6:	f3af 8000 	nopne.w
    32ba:	f3ef 8010 	mrs	r0, PRIMASK
    32be:	b672      	cpsid	i
    32c0:	9007      	str	r0, [sp, #28]
    32c2:	b124      	cbz	r4, 32ce <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x18e>
    32c4:	2100      	movs	r1, #0
    32c6:	f240 70d2 	movw	r0, #2002	; 0x7d2
    32ca:	f3af 8000 	nop.w
    32ce:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
    32d2:	f88d 0008 	strb.w	r0, [sp, #8]
    32d6:	f89d 0008 	ldrb.w	r0, [sp, #8]
    32da:	b138      	cbz	r0, 32ec <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1ac>
    32dc:	2c00      	cmp	r4, #0
    32de:	bf1c      	itt	ne
    32e0:	2100      	movne	r1, #0
    32e2:	f240 70d6 	movwne	r0, #2006	; 0x7d6
    32e6:	f43f af3d 	beq.w	3164 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x24>
    32ea:	e781      	b.n	31f0 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0xb0>
    32ec:	f1bb 0f00 	cmp.w	fp, #0
    32f0:	d00a      	beq.n	3308 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1c8>
    32f2:	f895 002d 	ldrb.w	r0, [r5, #45]	; 0x2d
    32f6:	2820      	cmp	r0, #32
    32f8:	d106      	bne.n	3308 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1c8>
    32fa:	4632      	mov	r2, r6
    32fc:	2102      	movs	r1, #2
    32fe:	9808      	ldr	r0, [sp, #32]
    3300:	f7ff f8f2 	bl	24e8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x79c>
    3304:	9006      	str	r0, [sp, #24]
    3306:	b1f8      	cbz	r0, 3348 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x208>
    3308:	b124      	cbz	r4, 3314 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1d4>
    330a:	2100      	movs	r1, #0
    330c:	f240 70ea 	movw	r0, #2026	; 0x7ea
    3310:	f3af 8000 	nop.w
    3314:	e000      	b.n	3318 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1d8>
    3316:	e00a      	b.n	332e <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1ee>
    3318:	f895 002c 	ldrb.w	r0, [r5, #44]	; 0x2c
    331c:	ea27 0000 	bic.w	r0, r7, r0
    3320:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
    3324:	20ff      	movs	r0, #255	; 0xff
    3326:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
    332a:	2001      	movs	r0, #1
    332c:	9009      	str	r0, [sp, #36]	; 0x24
    332e:	b124      	cbz	r4, 333a <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1fa>
    3330:	2100      	movs	r1, #0
    3332:	f240 70f3 	movw	r0, #2035	; 0x7f3
    3336:	f3af 8000 	nop.w
    333a:	9806      	ldr	r0, [sp, #24]
    333c:	4e1a      	ldr	r6, [pc, #104]	; (33a8 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x268>)
    333e:	2802      	cmp	r0, #2
    3340:	d009      	beq.n	3356 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x216>
    3342:	2801      	cmp	r0, #1
    3344:	d00f      	beq.n	3366 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x226>
    3346:	e013      	b.n	3370 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x230>
    3348:	b194      	cbz	r4, 3370 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x230>
    334a:	2100      	movs	r1, #0
    334c:	f240 70e5 	movw	r0, #2021	; 0x7e5
    3350:	f3af 8000 	nop.w
    3354:	e7ec      	b.n	3330 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x1f0>
    3356:	68a9      	ldr	r1, [r5, #8]
    3358:	9808      	ldr	r0, [sp, #32]
    335a:	1a08      	subs	r0, r1, r0
    335c:	f009 fce4 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    3360:	6871      	ldr	r1, [r6, #4]
    3362:	b921      	cbnz	r1, 336e <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x22e>
    3364:	e004      	b.n	3370 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x230>
    3366:	6871      	ldr	r1, [r6, #4]
    3368:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    336c:	b101      	cbz	r1, 3370 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x230>
    336e:	4788      	blx	r1
    3370:	9807      	ldr	r0, [sp, #28]
    3372:	b148      	cbz	r0, 3388 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x248>
    3374:	b124      	cbz	r4, 3380 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x240>
    3376:	2100      	movs	r1, #0
    3378:	f640 0007 	movw	r0, #2055	; 0x807
    337c:	f3af 8000 	nop.w
    3380:	9809      	ldr	r0, [sp, #36]	; 0x24
    3382:	b00d      	add	sp, #52	; 0x34
    3384:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3388:	4805      	ldr	r0, [pc, #20]	; (33a0 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x260>)
    338a:	2800      	cmp	r0, #0
    338c:	bf18      	it	ne
    338e:	f3af 8000 	nopne.w
    3392:	b662      	cpsie	i
    3394:	e7ee      	b.n	3374 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY+0x234>
    3396:	0000      	.short	0x0000
    3398:	200015cc 	.word	0x200015cc
	...
    33a8:	20000038 	.word	0x20000038

000033ac <sym_MLZNDMDYRI6WNTNQ4RIQGPD423CK7RT4YVI5CAI>:
    33ac:	2820      	cmp	r0, #32
    33ae:	bf24      	itt	cs
    33b0:	2000      	movcs	r0, #0
    33b2:	4770      	bxcs	lr
    33b4:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    33b8:	4b03      	ldr	r3, [pc, #12]	; (33c8 <sym_MLZNDMDYRI6WNTNQ4RIQGPD423CK7RT4YVI5CAI+0x1c>)
    33ba:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
    33be:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    33c2:	6042      	str	r2, [r0, #4]
    33c4:	2001      	movs	r0, #1
    33c6:	4770      	bx	lr
    33c8:	200011cc 	.word	0x200011cc

000033cc <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y>:
    33cc:	b510      	push	{r4, lr}
    33ce:	2820      	cmp	r0, #32
    33d0:	d211      	bcs.n	33f6 <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y+0x2a>
    33d2:	490e      	ldr	r1, [pc, #56]	; (340c <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y+0x40>)
    33d4:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
    33d8:	f1a1 0280 	sub.w	r2, r1, #128	; 0x80
    33dc:	eb02 1c83 	add.w	ip, r2, r3, lsl #6
    33e0:	f81c 3010 	ldrb.w	r3, [ip, r0, lsl #1]
    33e4:	b13b      	cbz	r3, 33f6 <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y+0x2a>
    33e6:	f891 302c 	ldrb.w	r3, [r1, #44]	; 0x2c
    33ea:	eb02 1283 	add.w	r2, r2, r3, lsl #6
    33ee:	f812 2010 	ldrb.w	r2, [r2, r0, lsl #1]
    33f2:	2a01      	cmp	r2, #1
    33f4:	d001      	beq.n	33fa <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y+0x2e>
    33f6:	2000      	movs	r0, #0
    33f8:	bd10      	pop	{r4, pc}
    33fa:	f891 202c 	ldrb.w	r2, [r1, #44]	; 0x2c
    33fe:	4601      	mov	r1, r0
    3400:	2000      	movs	r0, #0
    3402:	f7ff f83f 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    3406:	2001      	movs	r0, #1
    3408:	bd10      	pop	{r4, pc}
    340a:	0000      	.short	0x0000
    340c:	200015cc 	.word	0x200015cc

00003410 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI>:
    3410:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3414:	4e86      	ldr	r6, [pc, #536]	; (3630 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x220>)
    3416:	4680      	mov	r8, r0
    3418:	f896 002c 	ldrb.w	r0, [r6, #44]	; 0x2c
    341c:	f1a6 0780 	sub.w	r7, r6, #128	; 0x80
    3420:	eb07 1080 	add.w	r0, r7, r0, lsl #6
    3424:	f810 0018 	ldrb.w	r0, [r0, r8, lsl #1]
    3428:	2800      	cmp	r0, #0
    342a:	d071      	beq.n	3510 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x100>
    342c:	f896 902c 	ldrb.w	r9, [r6, #44]	; 0x2c
    3430:	4d80      	ldr	r5, [pc, #512]	; (3634 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x224>)
    3432:	b125      	cbz	r5, 343e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x2e>
    3434:	2100      	movs	r1, #0
    3436:	f640 3076 	movw	r0, #2934	; 0xb76
    343a:	f3af 8000 	nop.w
    343e:	eb07 1489 	add.w	r4, r7, r9, lsl #6
    3442:	f814 0018 	ldrb.w	r0, [r4, r8, lsl #1]
    3446:	2801      	cmp	r0, #1
    3448:	d018      	beq.n	347c <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x6c>
    344a:	b2c0      	uxtb	r0, r0
    344c:	2804      	cmp	r0, #4
    344e:	bf1c      	itt	ne
    3450:	2805      	cmpne	r0, #5
    3452:	2806      	cmpne	r0, #6
    3454:	d061      	beq.n	351a <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x10a>
    3456:	b12d      	cbz	r5, 3464 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x54>
    3458:	f04f 0100 	mov.w	r1, #0
    345c:	f640 3082 	movw	r0, #2946	; 0xb82
    3460:	f3af 8000 	nop.w
    3464:	f001 fcd0 	bl	4e08 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA>
    3468:	b125      	cbz	r5, 3474 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x64>
    346a:	2100      	movs	r1, #0
    346c:	f640 3086 	movw	r0, #2950	; 0xb86
    3470:	f3af 8000 	nop.w
    3474:	f814 0018 	ldrb.w	r0, [r4, r8, lsl #1]
    3478:	2801      	cmp	r0, #1
    347a:	d1e6      	bne.n	344a <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x3a>
    347c:	2401      	movs	r4, #1
    347e:	b125      	cbz	r5, 348a <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x7a>
    3480:	2100      	movs	r1, #0
    3482:	f640 308d 	movw	r0, #2957	; 0xb8d
    3486:	f3af 8000 	nop.w
    348a:	2c00      	cmp	r4, #0
    348c:	d04b      	beq.n	3526 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x116>
    348e:	2000      	movs	r0, #0
    3490:	f886 0029 	strb.w	r0, [r6, #41]	; 0x29
    3494:	b125      	cbz	r5, 34a0 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x90>
    3496:	2100      	movs	r1, #0
    3498:	f640 3092 	movw	r0, #2962	; 0xb92
    349c:	f3af 8000 	nop.w
    34a0:	f896 b02c 	ldrb.w	fp, [r6, #44]	; 0x2c
    34a4:	2001      	movs	r0, #1
    34a6:	ea20 090b 	bic.w	r9, r0, fp
    34aa:	eb07 118b 	add.w	r1, r7, fp, lsl #6
    34ae:	eb07 1089 	add.w	r0, r7, r9, lsl #6
    34b2:	2240      	movs	r2, #64	; 0x40
    34b4:	f009 fd92 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    34b8:	b125      	cbz	r5, 34c4 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0xb4>
    34ba:	2100      	movs	r1, #0
    34bc:	f240 502f 	movw	r0, #1327	; 0x52f
    34c0:	f3af 8000 	nop.w
    34c4:	eb09 0049 	add.w	r0, r9, r9, lsl #1
    34c8:	eb00 0a06 	add.w	sl, r0, r6
    34cc:	eb0b 004b 	add.w	r0, fp, fp, lsl #1
    34d0:	4430      	add	r0, r6
    34d2:	8c01      	ldrh	r1, [r0, #32]
    34d4:	f8aa 1020 	strh.w	r1, [sl, #32]
    34d8:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
    34dc:	f88a 0022 	strb.w	r0, [sl, #34]	; 0x22
    34e0:	b125      	cbz	r5, 34ec <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0xdc>
    34e2:	2100      	movs	r1, #0
    34e4:	f240 5033 	movw	r0, #1331	; 0x533
    34e8:	f3af 8000 	nop.w
    34ec:	f896 0029 	ldrb.w	r0, [r6, #41]	; 0x29
    34f0:	f88d 0000 	strb.w	r0, [sp]
    34f4:	f89d 0000 	ldrb.w	r0, [sp]
    34f8:	b1e0      	cbz	r0, 3534 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x124>
    34fa:	2d00      	cmp	r5, #0
    34fc:	bf1c      	itt	ne
    34fe:	2100      	movne	r1, #0
    3500:	f640 3098 	movwne	r0, #2968	; 0xb98
    3504:	d0bb      	beq.n	347e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x6e>
    3506:	bf00      	nop
    3508:	f3af 8000 	nop.w
    350c:	e7b7      	b.n	347e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x6e>
    350e:	e7ff      	b.n	3510 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x100>
    3510:	f640 316d 	movw	r1, #2925	; 0xb6d
    3514:	2070      	movs	r0, #112	; 0x70
    3516:	f001 fb4d 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    351a:	464a      	mov	r2, r9
    351c:	4641      	mov	r1, r8
    351e:	2001      	movs	r0, #1
    3520:	f7fe ffb0 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    3524:	e7a0      	b.n	3468 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x58>
    3526:	4844      	ldr	r0, [pc, #272]	; (3638 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x228>)
    3528:	2800      	cmp	r0, #0
    352a:	bf18      	it	ne
    352c:	f3af 8000 	nopne.w
    3530:	b662      	cpsie	i
    3532:	e7ac      	b.n	348e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x7e>
    3534:	b125      	cbz	r5, 3540 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x130>
    3536:	2100      	movs	r1, #0
    3538:	f640 309c 	movw	r0, #2972	; 0xb9c
    353c:	f3af 8000 	nop.w
    3540:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
    3544:	f10a 0121 	add.w	r1, sl, #33	; 0x21
    3548:	4640      	mov	r0, r8
    354a:	461c      	mov	r4, r3
    354c:	f04f 0b20 	mov.w	fp, #32
    3550:	eb07 1289 	add.w	r2, r7, r9, lsl #6
    3554:	f10a 0a22 	add.w	sl, sl, #34	; 0x22
    3558:	e004      	b.n	3564 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x154>
    355a:	46a3      	mov	fp, r4
    355c:	eb02 0c4b 	add.w	ip, r2, fp, lsl #1
    3560:	f89c 4001 	ldrb.w	r4, [ip, #1]
    3564:	4284      	cmp	r4, r0
    3566:	d002      	beq.n	356e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x15e>
    3568:	2c20      	cmp	r4, #32
    356a:	d02b      	beq.n	35c4 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1b4>
    356c:	e7f5      	b.n	355a <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x14a>
    356e:	2c20      	cmp	r4, #32
    3570:	d028      	beq.n	35c4 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1b4>
    3572:	42a3      	cmp	r3, r4
    3574:	d104      	bne.n	3580 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x170>
    3576:	eb02 0043 	add.w	r0, r2, r3, lsl #1
    357a:	7840      	ldrb	r0, [r0, #1]
    357c:	7008      	strb	r0, [r1, #0]
    357e:	e005      	b.n	358c <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x17c>
    3580:	eb02 0044 	add.w	r0, r2, r4, lsl #1
    3584:	eb02 014b 	add.w	r1, r2, fp, lsl #1
    3588:	7840      	ldrb	r0, [r0, #1]
    358a:	7048      	strb	r0, [r1, #1]
    358c:	f1ba 0f00 	cmp.w	sl, #0
    3590:	d011      	beq.n	35b6 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1a6>
    3592:	b125      	cbz	r5, 359e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x18e>
    3594:	2100      	movs	r1, #0
    3596:	f240 4092 	movw	r0, #1170	; 0x492
    359a:	f3af 8000 	nop.w
    359e:	f89a 0000 	ldrb.w	r0, [sl]
    35a2:	42a0      	cmp	r0, r4
    35a4:	d107      	bne.n	35b6 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1a6>
    35a6:	b125      	cbz	r5, 35b2 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1a2>
    35a8:	2100      	movs	r1, #0
    35aa:	f240 4095 	movw	r0, #1173	; 0x495
    35ae:	f3af 8000 	nop.w
    35b2:	f88a b000 	strb.w	fp, [sl]
    35b6:	b15d      	cbz	r5, 35d0 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1c0>
    35b8:	2100      	movs	r1, #0
    35ba:	f240 409a 	movw	r0, #1178	; 0x49a
    35be:	f3af 8000 	nop.w
    35c2:	e000      	b.n	35c6 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1b6>
    35c4:	b125      	cbz	r5, 35d0 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1c0>
    35c6:	2100      	movs	r1, #0
    35c8:	f44f 603a 	mov.w	r0, #2976	; 0xba0
    35cc:	f3af 8000 	nop.w
    35d0:	481a      	ldr	r0, [pc, #104]	; (363c <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x22c>)
    35d2:	2800      	cmp	r0, #0
    35d4:	bf18      	it	ne
    35d6:	f3af 8000 	nopne.w
    35da:	f3ef 8410 	mrs	r4, PRIMASK
    35de:	b672      	cpsid	i
    35e0:	f896 0029 	ldrb.w	r0, [r6, #41]	; 0x29
    35e4:	f88d 0000 	strb.w	r0, [sp]
    35e8:	f89d 0000 	ldrb.w	r0, [sp]
    35ec:	b138      	cbz	r0, 35fe <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1ee>
    35ee:	2d00      	cmp	r5, #0
    35f0:	bf1c      	itt	ne
    35f2:	2100      	movne	r1, #0
    35f4:	f640 30a6 	movwne	r0, #2982	; 0xba6
    35f8:	f43f af41 	beq.w	347e <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x6e>
    35fc:	e784      	b.n	3508 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0xf8>
    35fe:	f886 902c 	strb.w	r9, [r6, #44]	; 0x2c
    3602:	20ff      	movs	r0, #255	; 0xff
    3604:	f886 0029 	strb.w	r0, [r6, #41]	; 0x29
    3608:	b154      	cbz	r4, 3620 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x210>
    360a:	2d00      	cmp	r5, #0
    360c:	bf08      	it	eq
    360e:	e8bd 8ff8 	ldmiaeq.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3612:	2100      	movs	r1, #0
    3614:	f640 30b3 	movw	r0, #2995	; 0xbb3
    3618:	f3af 8000 	nop.w
    361c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3620:	4805      	ldr	r0, [pc, #20]	; (3638 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x228>)
    3622:	2800      	cmp	r0, #0
    3624:	bf18      	it	ne
    3626:	f3af 8000 	nopne.w
    362a:	b662      	cpsie	i
    362c:	e7ed      	b.n	360a <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI+0x1fa>
    362e:	0000      	.short	0x0000
    3630:	200015cc 	.word	0x200015cc
	...

00003640 <sym_RPHL2J7CVNKM6GKLDIFI4NVAPZE2FHTYW4VJSJI>:
    3640:	b570      	push	{r4, r5, r6, lr}
    3642:	460d      	mov	r5, r1
    3644:	4606      	mov	r6, r0
    3646:	f001 fa2b 	bl	4aa0 <sym_4PX37LW4KIUYQZ73JWLPH5GAGIRWAKTV3E6F62Q>
    364a:	480f      	ldr	r0, [pc, #60]	; (3688 <sym_RPHL2J7CVNKM6GKLDIFI4NVAPZE2FHTYW4VJSJI+0x48>)
    364c:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
    3650:	2400      	movs	r4, #0
    3652:	3880      	subs	r0, #128	; 0x80
    3654:	eb00 1082 	add.w	r0, r0, r2, lsl #6
    3658:	f810 1014 	ldrb.w	r1, [r0, r4, lsl #1]
    365c:	b129      	cbz	r1, 366a <sym_RPHL2J7CVNKM6GKLDIFI4NVAPZE2FHTYW4VJSJI+0x2a>
    365e:	1c61      	adds	r1, r4, #1
    3660:	b2cc      	uxtb	r4, r1
    3662:	2c20      	cmp	r4, #32
    3664:	d3f8      	bcc.n	3658 <sym_RPHL2J7CVNKM6GKLDIFI4NVAPZE2FHTYW4VJSJI+0x18>
    3666:	2020      	movs	r0, #32
    3668:	bd70      	pop	{r4, r5, r6, pc}
    366a:	4808      	ldr	r0, [pc, #32]	; (368c <sym_RPHL2J7CVNKM6GKLDIFI4NVAPZE2FHTYW4VJSJI+0x4c>)
    366c:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    3670:	f840 6021 	str.w	r6, [r0, r1, lsl #2]
    3674:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    3678:	4621      	mov	r1, r4
    367a:	6045      	str	r5, [r0, #4]
    367c:	2001      	movs	r0, #1
    367e:	f7fe ff01 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    3682:	4620      	mov	r0, r4
    3684:	bd70      	pop	{r4, r5, r6, pc}
    3686:	0000      	.short	0x0000
    3688:	200015cc 	.word	0x200015cc
    368c:	200011cc 	.word	0x200011cc

00003690 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y>:
    3690:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3694:	f000 fb70 	bl	3d78 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY>
    3698:	4605      	mov	r5, r0
    369a:	f000 fe3f 	bl	431c <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q>
    369e:	4c60      	ldr	r4, [pc, #384]	; (3820 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x190>)
    36a0:	6860      	ldr	r0, [r4, #4]
    36a2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    36a6:	bf1c      	itt	ne
    36a8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    36ac:	6060      	strne	r0, [r4, #4]
    36ae:	7fa0      	ldrb	r0, [r4, #30]
    36b0:	4f5c      	ldr	r7, [pc, #368]	; (3824 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x194>)
    36b2:	b990      	cbnz	r0, 36da <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x4a>
    36b4:	e9d4 1002 	ldrd	r1, r0, [r4, #8]
    36b8:	1a40      	subs	r0, r0, r1
    36ba:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    36be:	f44f 710c 	mov.w	r1, #560	; 0x230
    36c2:	f009 fb5c 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    36c6:	68e1      	ldr	r1, [r4, #12]
    36c8:	4408      	add	r0, r1
    36ca:	1a28      	subs	r0, r5, r0
    36cc:	0200      	lsls	r0, r0, #8
    36ce:	17c1      	asrs	r1, r0, #31
    36d0:	eb00 6011 	add.w	r0, r0, r1, lsr #24
    36d4:	1200      	asrs	r0, r0, #8
    36d6:	0fc0      	lsrs	r0, r0, #31
    36d8:	d012      	beq.n	3700 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x70>
    36da:	7e60      	ldrb	r0, [r4, #25]
    36dc:	b320      	cbz	r0, 3728 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x98>
    36de:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
    36e2:	f88d 0000 	strb.w	r0, [sp]
    36e6:	f89d 0000 	ldrb.w	r0, [sp]
    36ea:	b1e8      	cbz	r0, 3728 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x98>
    36ec:	f000 fc72 	bl	3fd4 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA>
    36f0:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
    36f4:	b1f0      	cbz	r0, 3734 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0xa4>
    36f6:	f240 31d5 	movw	r1, #981	; 0x3d5
    36fa:	2070      	movs	r0, #112	; 0x70
    36fc:	f001 fa5a 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3700:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    3704:	f894 102d 	ldrb.w	r1, [r4, #45]	; 0x2d
    3708:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    370c:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    3710:	6840      	ldr	r0, [r0, #4]
    3712:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    3716:	f857 2021 	ldr.w	r2, [r7, r1, lsl #2]
    371a:	2108      	movs	r1, #8
    371c:	4790      	blx	r2
    371e:	f240 31bd 	movw	r1, #957	; 0x3bd
    3722:	2070      	movs	r0, #112	; 0x70
    3724:	f001 fa46 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3728:	1ce8      	adds	r0, r5, #3
    372a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    372e:	f000 fb49 	bl	3dc4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ>
    3732:	e7dd      	b.n	36f0 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x60>
    3734:	2001      	movs	r0, #1
    3736:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
    373a:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    373e:	2820      	cmp	r0, #32
    3740:	d021      	beq.n	3786 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0xf6>
    3742:	f894 902d 	ldrb.w	r9, [r4, #45]	; 0x2d
    3746:	2020      	movs	r0, #32
    3748:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    374c:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
    3750:	2600      	movs	r6, #0
    3752:	f884 6026 	strb.w	r6, [r4, #38]	; 0x26
    3756:	f884 6027 	strb.w	r6, [r4, #39]	; 0x27
    375a:	6026      	str	r6, [r4, #0]
    375c:	f000 feb8 	bl	44d0 <sym_3RLTHYPNUGF2GJUCXUGLNFS6UK7UWZOBB6PWVDI>
    3760:	7720      	strb	r0, [r4, #28]
    3762:	f894 802c 	ldrb.w	r8, [r4, #44]	; 0x2c
    3766:	eb08 0048 	add.w	r0, r8, r8, lsl #1
    376a:	eb00 0a04 	add.w	sl, r0, r4
    376e:	f89a 0020 	ldrb.w	r0, [sl, #32]
    3772:	2820      	cmp	r0, #32
    3774:	d012      	beq.n	379c <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x10c>
    3776:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    377a:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    377e:	7e81      	ldrb	r1, [r0, #26]
    3780:	2901      	cmp	r1, #1
    3782:	d005      	beq.n	3790 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x100>
    3784:	e00a      	b.n	379c <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x10c>
    3786:	f44f 7176 	mov.w	r1, #984	; 0x3d8
    378a:	2070      	movs	r0, #112	; 0x70
    378c:	f001 fa12 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3790:	f100 0208 	add.w	r2, r0, #8
    3794:	2101      	movs	r1, #1
    3796:	4628      	mov	r0, r5
    3798:	f7fe f9f0 	bl	1b7c <MPSL_IRQ_RADIO_Handler+0x560>
    379c:	4642      	mov	r2, r8
    379e:	2101      	movs	r1, #1
    37a0:	4628      	mov	r0, r5
    37a2:	f7fe fea1 	bl	24e8 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x79c>
    37a6:	0007      	movs	r7, r0
    37a8:	d0f8      	beq.n	379c <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x10c>
    37aa:	481f      	ldr	r0, [pc, #124]	; (3828 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x198>)
    37ac:	eb00 1088 	add.w	r0, r0, r8, lsl #6
    37b0:	f810 0019 	ldrb.w	r0, [r0, r9, lsl #1]
    37b4:	2802      	cmp	r0, #2
    37b6:	d104      	bne.n	37c2 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x132>
    37b8:	4642      	mov	r2, r8
    37ba:	4649      	mov	r1, r9
    37bc:	2006      	movs	r0, #6
    37be:	f7fe fe61 	bl	2484 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x738>
    37c2:	20ff      	movs	r0, #255	; 0xff
    37c4:	f884 0029 	strb.w	r0, [r4, #41]	; 0x29
    37c8:	f89a 0021 	ldrb.w	r0, [sl, #33]	; 0x21
    37cc:	f8df 805c 	ldr.w	r8, [pc, #92]	; 382c <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x19c>
    37d0:	2820      	cmp	r0, #32
    37d2:	bf1c      	itt	ne
    37d4:	f898 0001 	ldrbne.w	r0, [r8, #1]
    37d8:	f001 fac0 	blne	4d5c <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q>
    37dc:	7f20      	ldrb	r0, [r4, #28]
    37de:	b118      	cbz	r0, 37e8 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x158>
    37e0:	f000 fe52 	bl	4488 <sym_52O7VXVVZYQGD3Z6C3FDJLGBNMQQ6XC5LJ3IFRQ>
    37e4:	7726      	strb	r6, [r4, #28]
    37e6:	7766      	strb	r6, [r4, #29]
    37e8:	2f02      	cmp	r7, #2
    37ea:	d00f      	beq.n	380c <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x17c>
    37ec:	2f01      	cmp	r7, #1
    37ee:	bf18      	it	ne
    37f0:	e8bd 8ff8 	ldmiane.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    37f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    37f8:	f8d8 1004 	ldr.w	r1, [r8, #4]
    37fc:	2900      	cmp	r1, #0
    37fe:	bf08      	it	eq
    3800:	e8bd 8ff8 	ldmiaeq.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3804:	b001      	add	sp, #4
    3806:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    380a:	4708      	bx	r1
    380c:	68a0      	ldr	r0, [r4, #8]
    380e:	1b40      	subs	r0, r0, r5
    3810:	f009 fa8a 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    3814:	f8d8 1004 	ldr.w	r1, [r8, #4]
    3818:	2900      	cmp	r1, #0
    381a:	d1f3      	bne.n	3804 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y+0x174>
    381c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3820:	200015cc 	.word	0x200015cc
    3824:	200011cc 	.word	0x200011cc
    3828:	2000154c 	.word	0x2000154c
    382c:	20000038 	.word	0x20000038

00003830 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY>:
    3830:	b530      	push	{r4, r5, lr}
    3832:	4c36      	ldr	r4, [pc, #216]	; (390c <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0xdc>)
    3834:	4605      	mov	r5, r0
    3836:	b083      	sub	sp, #12
    3838:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    383c:	2820      	cmp	r0, #32
    383e:	d008      	beq.n	3852 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0x22>
    3840:	6860      	ldr	r0, [r4, #4]
    3842:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    3846:	d009      	beq.n	385c <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0x2c>
    3848:	f640 21a1 	movw	r1, #2721	; 0xaa1
    384c:	2070      	movs	r0, #112	; 0x70
    384e:	f001 f9b1 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3852:	f44f 612a 	mov.w	r1, #2720	; 0xaa0
    3856:	2070      	movs	r0, #112	; 0x70
    3858:	f001 f9ac 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    385c:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
    3860:	492b      	ldr	r1, [pc, #172]	; (3910 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0xe0>)
    3862:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    3866:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    386a:	3008      	adds	r0, #8
    386c:	f7fe fdd0 	bl	2410 <CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT+0x6c4>
    3870:	4601      	mov	r1, r0
    3872:	4a28      	ldr	r2, [pc, #160]	; (3914 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0xe4>)
    3874:	4428      	add	r0, r5
    3876:	4291      	cmp	r1, r2
    3878:	d904      	bls.n	3884 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0x54>
    387a:	f240 516f 	movw	r1, #1391	; 0x56f
    387e:	2070      	movs	r0, #112	; 0x70
    3880:	f001 f998 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3884:	4924      	ldr	r1, [pc, #144]	; (3918 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0xe8>)
    3886:	428d      	cmp	r5, r1
    3888:	dd04      	ble.n	3894 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0x64>
    388a:	f44f 61ae 	mov.w	r1, #1392	; 0x570
    388e:	2070      	movs	r0, #112	; 0x70
    3890:	f001 f990 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3894:	4921      	ldr	r1, [pc, #132]	; (391c <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0xec>)
    3896:	428d      	cmp	r5, r1
    3898:	da04      	bge.n	38a4 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0x74>
    389a:	f240 5171 	movw	r1, #1393	; 0x571
    389e:	2070      	movs	r0, #112	; 0x70
    38a0:	f001 f988 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    38a4:	491e      	ldr	r1, [pc, #120]	; (3920 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0xf0>)
    38a6:	4281      	cmp	r1, r0
    38a8:	bfdc      	itt	le
    38aa:	f500 00f7 	addle.w	r0, r0, #8093696	; 0x7b8000
    38ae:	f1a0 50f8 	suble.w	r0, r0, #520093696	; 0x1f000000
    38b2:	dd05      	ble.n	38c0 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY+0x90>
    38b4:	2800      	cmp	r0, #0
    38b6:	bfbc      	itt	lt
    38b8:	f5a0 00f7 	sublt.w	r0, r0, #8093696	; 0x7b8000
    38bc:	f100 50f8 	addlt.w	r0, r0, #520093696	; 0x1f000000
    38c0:	aa01      	add	r2, sp, #4
    38c2:	4669      	mov	r1, sp
    38c4:	f000 f8ee 	bl	3aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>
    38c8:	f89d 0004 	ldrb.w	r0, [sp, #4]
    38cc:	280f      	cmp	r0, #15
    38ce:	bf8c      	ite	hi
    38d0:	2001      	movhi	r0, #1
    38d2:	2000      	movls	r0, #0
    38d4:	9900      	ldr	r1, [sp, #0]
    38d6:	4408      	add	r0, r1
    38d8:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
    38dc:	6061      	str	r1, [r4, #4]
    38de:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
    38e2:	f88d 0000 	strb.w	r0, [sp]
    38e6:	f89d 0000 	ldrb.w	r0, [sp]
    38ea:	2800      	cmp	r0, #0
    38ec:	bf04      	itt	eq
    38ee:	b003      	addeq	sp, #12
    38f0:	bd30      	popeq	{r4, r5, pc}
    38f2:	2005      	movs	r0, #5
    38f4:	f000 fbec 	bl	40d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>
    38f8:	2800      	cmp	r0, #0
    38fa:	bf1c      	itt	ne
    38fc:	b003      	addne	sp, #12
    38fe:	bd30      	popne	{r4, r5, pc}
    3900:	f640 21a8 	movw	r1, #2728	; 0xaa8
    3904:	2070      	movs	r0, #112	; 0x70
    3906:	f001 f955 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    390a:	0000      	.short	0x0000
    390c:	200015cc 	.word	0x200015cc
    3910:	200011cc 	.word	0x200011cc
    3914:	1e847fff 	.word	0x1e847fff
    3918:	0f424000 	.word	0x0f424000
    391c:	f0bdc000 	.word	0xf0bdc000
    3920:	1e848000 	.word	0x1e848000

00003924 <sym_ZC6NJBPUISWILQK6OTOBMJVVUT63JRIDGH5WNCY>:
    3924:	b570      	push	{r4, r5, r6, lr}
    3926:	4c1c      	ldr	r4, [pc, #112]	; (3998 <sym_ZC6NJBPUISWILQK6OTOBMJVVUT63JRIDGH5WNCY+0x74>)
    3928:	2120      	movs	r1, #32
    392a:	f884 1020 	strb.w	r1, [r4, #32]
    392e:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
    3932:	f884 1022 	strb.w	r1, [r4, #34]	; 0x22
    3936:	2000      	movs	r0, #0
    3938:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    393c:	f884 102d 	strb.w	r1, [r4, #45]	; 0x2d
    3940:	1e42      	subs	r2, r0, #1
    3942:	e9c4 0200 	strd	r0, r2, [r4]
    3946:	77a0      	strb	r0, [r4, #30]
    3948:	f884 0026 	strb.w	r0, [r4, #38]	; 0x26
    394c:	f884 0027 	strb.w	r0, [r4, #39]	; 0x27
    3950:	7720      	strb	r0, [r4, #28]
    3952:	7760      	strb	r0, [r4, #29]
    3954:	f884 102e 	strb.w	r1, [r4, #46]	; 0x2e
    3958:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
    395c:	f884 002b 	strb.w	r0, [r4, #43]	; 0x2b
    3960:	f1a4 0182 	sub.w	r1, r4, #130	; 0x82
    3964:	2210      	movs	r2, #16
    3966:	7088      	strb	r0, [r1, #2]
    3968:	f801 0f04 	strb.w	r0, [r1, #4]!
    396c:	1e52      	subs	r2, r2, #1
    396e:	d1fa      	bne.n	3966 <sym_ZC6NJBPUISWILQK6OTOBMJVVUT63JRIDGH5WNCY+0x42>
    3970:	f000 fdb8 	bl	44e4 <sym_476ZEBCLN4VRBESFX6B7F6TMVQVNPVCGXRXSHHY>
    3974:	4d09      	ldr	r5, [pc, #36]	; (399c <sym_ZC6NJBPUISWILQK6OTOBMJVVUT63JRIDGH5WNCY+0x78>)
    3976:	2601      	movs	r6, #1
    3978:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28
    397c:	20ff      	movs	r0, #255	; 0xff
    397e:	7028      	strb	r0, [r5, #0]
    3980:	4807      	ldr	r0, [pc, #28]	; (39a0 <sym_ZC6NJBPUISWILQK6OTOBMJVVUT63JRIDGH5WNCY+0x7c>)
    3982:	f001 f9cd 	bl	4d20 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA>
    3986:	7068      	strb	r0, [r5, #1]
    3988:	f001 fa28 	bl	4ddc <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY>
    398c:	60a8      	str	r0, [r5, #8]
    398e:	f000 fd33 	bl	43f8 <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI>
    3992:	f884 602f 	strb.w	r6, [r4, #47]	; 0x2f
    3996:	bd70      	pop	{r4, r5, r6, pc}
    3998:	200015cc 	.word	0x200015cc
    399c:	20000038 	.word	0x20000038
    39a0:	00002339 	.word	0x00002339

000039a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>:
    39a4:	b500      	push	{lr}
    39a6:	b083      	sub	sp, #12
    39a8:	4668      	mov	r0, sp
    39aa:	f000 f9eb 	bl	3d84 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ>
    39ae:	9800      	ldr	r0, [sp, #0]
    39b0:	f009 f9ba 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    39b4:	9a01      	ldr	r2, [sp, #4]
    39b6:	4b03      	ldr	r3, [pc, #12]	; (39c4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q+0x20>)
    39b8:	2100      	movs	r1, #0
    39ba:	fbe2 0103 	umlal	r0, r1, r2, r3
    39be:	b003      	add	sp, #12
    39c0:	bd00      	pop	{pc}
    39c2:	0000      	.short	0x0000
    39c4:	1e848000 	.word	0x1e848000

000039c8 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ>:
    39c8:	b570      	push	{r4, r5, r6, lr}
    39ca:	4606      	mov	r6, r0
    39cc:	b082      	sub	sp, #8
    39ce:	461d      	mov	r5, r3
    39d0:	4610      	mov	r0, r2
    39d2:	f009 f9a9 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    39d6:	4604      	mov	r4, r0
    39d8:	4668      	mov	r0, sp
    39da:	f000 f9d3 	bl	3d84 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ>
    39de:	4920      	ldr	r1, [pc, #128]	; (3a60 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x98>)
    39e0:	9801      	ldr	r0, [sp, #4]
    39e2:	fba0 0201 	umull	r0, r2, r0, r1
    39e6:	1a30      	subs	r0, r6, r0
    39e8:	bf44      	itt	mi
    39ea:	f5a0 00f7 	submi.w	r0, r0, #8093696	; 0x7b8000
    39ee:	f110 50f8 	addsmi.w	r0, r0, #520093696	; 0x1f000000
    39f2:	d504      	bpl.n	39fe <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x36>
    39f4:	f640 31c8 	movw	r1, #3016	; 0xbc8
    39f8:	2070      	movs	r0, #112	; 0x70
    39fa:	f001 f8db 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    39fe:	4288      	cmp	r0, r1
    3a00:	db04      	blt.n	3a0c <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x44>
    3a02:	f640 31c9 	movw	r1, #3017	; 0xbc9
    3a06:	2070      	movs	r0, #112	; 0x70
    3a08:	f001 f8d4 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3a0c:	4a15      	ldr	r2, [pc, #84]	; (3a64 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x9c>)
    3a0e:	1a21      	subs	r1, r4, r0
    3a10:	2300      	movs	r3, #0
    3a12:	1a8a      	subs	r2, r1, r2
    3a14:	f173 0200 	sbcs.w	r2, r3, #0
    3a18:	d318      	bcc.n	3a4c <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x84>
    3a1a:	f8df c048 	ldr.w	ip, [pc, #72]	; 3a64 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x9c>
    3a1e:	1b02      	subs	r2, r0, r4
    3a20:	ebb2 0c0c 	subs.w	ip, r2, ip
    3a24:	f173 0300 	sbcs.w	r3, r3, #0
    3a28:	d310      	bcc.n	3a4c <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x84>
    3a2a:	4b0f      	ldr	r3, [pc, #60]	; (3a68 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0xa0>)
    3a2c:	428b      	cmp	r3, r1
    3a2e:	bf3e      	ittt	cc
    3a30:	f5c0 2090 	rsbcc	r0, r0, #294912	; 0x48000
    3a34:	f100 50f4 	addcc.w	r0, r0, #511705088	; 0x1e800000
    3a38:	1901      	addcc	r1, r0, r4
    3a3a:	d307      	bcc.n	3a4c <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x84>
    3a3c:	4293      	cmp	r3, r2
    3a3e:	d20a      	bcs.n	3a56 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ+0x8e>
    3a40:	f5c4 2190 	rsb	r1, r4, #294912	; 0x48000
    3a44:	f101 51f4 	add.w	r1, r1, #511705088	; 0x1e800000
    3a48:	4408      	add	r0, r1
    3a4a:	4241      	negs	r1, r0
    3a4c:	f101 000f 	add.w	r0, r1, #15
    3a50:	b002      	add	sp, #8
    3a52:	1a28      	subs	r0, r5, r0
    3a54:	bd70      	pop	{r4, r5, r6, pc}
    3a56:	f640 21c2 	movw	r1, #2754	; 0xac2
    3a5a:	2070      	movs	r0, #112	; 0x70
    3a5c:	f001 f8aa 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3a60:	1e848000 	.word	0x1e848000
    3a64:	0f424000 	.word	0x0f424000
    3a68:	1e847fff 	.word	0x1e847fff

00003a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>:
    3a6c:	0b41      	lsrs	r1, r0, #13
    3a6e:	f248 6237 	movw	r2, #34359	; 0x8637
    3a72:	4351      	muls	r1, r2
    3a74:	0c0a      	lsrs	r2, r1, #16
    3a76:	4b09      	ldr	r3, [pc, #36]	; (3a9c <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x4>)
    3a78:	0251      	lsls	r1, r2, #9
    3a7a:	fb02 0203 	mla	r2, r2, r3, r0
    3a7e:	4808      	ldr	r0, [pc, #32]	; (3aa0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x8>)
    3a80:	4350      	muls	r0, r2
    3a82:	f500 3086 	add.w	r0, r0, #68608	; 0x10c00
    3a86:	306e      	adds	r0, #110	; 0x6e
    3a88:	0d40      	lsrs	r0, r0, #21
    3a8a:	425b      	negs	r3, r3
    3a8c:	fb10 f303 	smulbb	r3, r0, r3
    3a90:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
    3a94:	bf88      	it	hi
    3a96:	1c49      	addhi	r1, r1, #1
    3a98:	4408      	add	r0, r1
    3a9a:	4770      	bx	lr
    3a9c:	ffffc2f7 	.word	0xffffc2f7
    3aa0:	00010c6f 	.word	0x00010c6f

00003aa4 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI>:
    3aa4:	0b43      	lsrs	r3, r0, #13
    3aa6:	f248 6c37 	movw	ip, #34359	; 0x8637
    3aaa:	fb03 f30c 	mul.w	r3, r3, ip
    3aae:	b430      	push	{r4, r5}
    3ab0:	0c1b      	lsrs	r3, r3, #16
    3ab2:	f8df c044 	ldr.w	ip, [pc, #68]	; 3af8 <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI+0x54>
    3ab6:	025c      	lsls	r4, r3, #9
    3ab8:	fb03 030c 	mla	r3, r3, ip, r0
    3abc:	480f      	ldr	r0, [pc, #60]	; (3afc <sym_AOU55ZK756JLPLCLZ5TZSSVKOAWWFUNQZATBXUI+0x58>)
    3abe:	4358      	muls	r0, r3
    3ac0:	ea4f 5c50 	mov.w	ip, r0, lsr #21
    3ac4:	eb04 000c 	add.w	r0, r4, ip
    3ac8:	f643 5409 	movw	r4, #15625	; 0x3d09
    3acc:	fb1c f404 	smulbb	r4, ip, r4
    3ad0:	f504 7c80 	add.w	ip, r4, #256	; 0x100
    3ad4:	f643 5508 	movw	r5, #15624	; 0x3d08
    3ad8:	eba3 2c5c 	sub.w	ip, r3, ip, lsr #9
    3adc:	442c      	add	r4, r5
    3ade:	f00c 0cff 	and.w	ip, ip, #255	; 0xff
    3ae2:	ebb3 2f54 	cmp.w	r3, r4, lsr #9
    3ae6:	bf84      	itt	hi
    3ae8:	f04f 0c00 	movhi.w	ip, #0
    3aec:	1c40      	addhi	r0, r0, #1
    3aee:	6008      	str	r0, [r1, #0]
    3af0:	f882 c000 	strb.w	ip, [r2]
    3af4:	bc30      	pop	{r4, r5}
    3af6:	4770      	bx	lr
    3af8:	ffffc2f7 	.word	0xffffc2f7
    3afc:	00010c6f 	.word	0x00010c6f

00003b00 <MPSL_IRQ_RTC0_Handler>:
    3b00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3b04:	4d3b      	ldr	r5, [pc, #236]	; (3bf4 <MPSL_IRQ_RTC0_Handler+0xf4>)
    3b06:	f8d5 0304 	ldr.w	r0, [r5, #772]	; 0x304
    3b0a:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 3bf8 <MPSL_IRQ_RTC0_Handler+0xf8>
    3b0e:	f410 3f80 	tst.w	r0, #65536	; 0x10000
    3b12:	f44f 6600 	mov.w	r6, #2048	; 0x800
    3b16:	f04f 27e0 	mov.w	r7, #3758153728	; 0xe000e000
    3b1a:	f04f 0400 	mov.w	r4, #0
    3b1e:	d019      	beq.n	3b54 <MPSL_IRQ_RTC0_Handler+0x54>
    3b20:	4836      	ldr	r0, [pc, #216]	; (3bfc <MPSL_IRQ_RTC0_Handler+0xfc>)
    3b22:	6800      	ldr	r0, [r0, #0]
    3b24:	b1b0      	cbz	r0, 3b54 <MPSL_IRQ_RTC0_Handler+0x54>
    3b26:	f8c5 4140 	str.w	r4, [r5, #320]	; 0x140
    3b2a:	f8c7 6280 	str.w	r6, [r7, #640]	; 0x280
    3b2e:	f8d5 0540 	ldr.w	r0, [r5, #1344]	; 0x540
    3b32:	f8d8 1000 	ldr.w	r1, [r8]
    3b36:	1a40      	subs	r0, r0, r1
    3b38:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    3b3c:	2802      	cmp	r0, #2
    3b3e:	d302      	bcc.n	3b46 <MPSL_IRQ_RTC0_Handler+0x46>
    3b40:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    3b44:	d906      	bls.n	3b54 <MPSL_IRQ_RTC0_Handler+0x54>
    3b46:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    3b4a:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
    3b4e:	2004      	movs	r0, #4
    3b50:	f7fe fe82 	bl	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3b54:	f8d5 0304 	ldr.w	r0, [r5, #772]	; 0x304
    3b58:	f410 3f00 	tst.w	r0, #131072	; 0x20000
    3b5c:	d01a      	beq.n	3b94 <MPSL_IRQ_RTC0_Handler+0x94>
    3b5e:	4828      	ldr	r0, [pc, #160]	; (3c00 <MPSL_IRQ_RTC0_Handler+0x100>)
    3b60:	6800      	ldr	r0, [r0, #0]
    3b62:	b1b8      	cbz	r0, 3b94 <MPSL_IRQ_RTC0_Handler+0x94>
    3b64:	f8c5 4144 	str.w	r4, [r5, #324]	; 0x144
    3b68:	f8c7 6280 	str.w	r6, [r7, #640]	; 0x280
    3b6c:	4825      	ldr	r0, [pc, #148]	; (3c04 <MPSL_IRQ_RTC0_Handler+0x104>)
    3b6e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
    3b72:	f8d8 1000 	ldr.w	r1, [r8]
    3b76:	1a40      	subs	r0, r0, r1
    3b78:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    3b7c:	2802      	cmp	r0, #2
    3b7e:	d302      	bcc.n	3b86 <MPSL_IRQ_RTC0_Handler+0x86>
    3b80:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    3b84:	d906      	bls.n	3b94 <MPSL_IRQ_RTC0_Handler+0x94>
    3b86:	f44f 3000 	mov.w	r0, #131072	; 0x20000
    3b8a:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
    3b8e:	2005      	movs	r0, #5
    3b90:	f7fe fe62 	bl	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3b94:	f8d5 0304 	ldr.w	r0, [r5, #772]	; 0x304
    3b98:	f410 2f80 	tst.w	r0, #262144	; 0x40000
    3b9c:	d01a      	beq.n	3bd4 <MPSL_IRQ_RTC0_Handler+0xd4>
    3b9e:	481a      	ldr	r0, [pc, #104]	; (3c08 <MPSL_IRQ_RTC0_Handler+0x108>)
    3ba0:	6800      	ldr	r0, [r0, #0]
    3ba2:	b1b8      	cbz	r0, 3bd4 <MPSL_IRQ_RTC0_Handler+0xd4>
    3ba4:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    3ba8:	f8c7 6280 	str.w	r6, [r7, #640]	; 0x280
    3bac:	4817      	ldr	r0, [pc, #92]	; (3c0c <MPSL_IRQ_RTC0_Handler+0x10c>)
    3bae:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
    3bb2:	f8d8 1000 	ldr.w	r1, [r8]
    3bb6:	1a40      	subs	r0, r0, r1
    3bb8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    3bbc:	2802      	cmp	r0, #2
    3bbe:	d302      	bcc.n	3bc6 <MPSL_IRQ_RTC0_Handler+0xc6>
    3bc0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    3bc4:	d906      	bls.n	3bd4 <MPSL_IRQ_RTC0_Handler+0xd4>
    3bc6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    3bca:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
    3bce:	2006      	movs	r0, #6
    3bd0:	f7fe fe42 	bl	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3bd4:	f8d5 0104 	ldr.w	r0, [r5, #260]	; 0x104
    3bd8:	2800      	cmp	r0, #0
    3bda:	bf08      	it	eq
    3bdc:	e8bd 81f0 	ldmiaeq.w	sp!, {r4, r5, r6, r7, r8, pc}
    3be0:	f8c5 4104 	str.w	r4, [r5, #260]	; 0x104
    3be4:	f8c7 6280 	str.w	r6, [r7, #640]	; 0x280
    3be8:	4809      	ldr	r0, [pc, #36]	; (3c10 <MPSL_IRQ_RTC0_Handler+0x110>)
    3bea:	68c1      	ldr	r1, [r0, #12]
    3bec:	1c49      	adds	r1, r1, #1
    3bee:	60c1      	str	r1, [r0, #12]
    3bf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3bf4:	4000b000 	.word	0x4000b000
    3bf8:	4000b504 	.word	0x4000b504
    3bfc:	4000b140 	.word	0x4000b140
    3c00:	4000b144 	.word	0x4000b144
    3c04:	4000b004 	.word	0x4000b004
    3c08:	4000b148 	.word	0x4000b148
    3c0c:	4000b008 	.word	0x4000b008
    3c10:	20000044 	.word	0x20000044

00003c14 <MPSL_IRQ_TIMER0_Handler>:
    3c14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3c18:	4d38      	ldr	r5, [pc, #224]	; (3cfc <MPSL_IRQ_TIMER0_Handler+0xe8>)
    3c1a:	7828      	ldrb	r0, [r5, #0]
    3c1c:	2804      	cmp	r0, #4
    3c1e:	d068      	beq.n	3cf2 <MPSL_IRQ_TIMER0_Handler+0xde>
    3c20:	1ca8      	adds	r0, r5, #2
    3c22:	2201      	movs	r2, #1
    3c24:	7801      	ldrb	r1, [r0, #0]
    3c26:	b159      	cbz	r1, 3c40 <MPSL_IRQ_TIMER0_Handler+0x2c>
    3c28:	2901      	cmp	r1, #1
    3c2a:	bf08      	it	eq
    3c2c:	706a      	strbeq	r2, [r5, #1]
    3c2e:	d002      	beq.n	3c36 <MPSL_IRQ_TIMER0_Handler+0x22>
    3c30:	7869      	ldrb	r1, [r5, #1]
    3c32:	2900      	cmp	r1, #0
    3c34:	d058      	beq.n	3ce8 <MPSL_IRQ_TIMER0_Handler+0xd4>
    3c36:	2102      	movs	r1, #2
    3c38:	7001      	strb	r1, [r0, #0]
    3c3a:	7840      	ldrb	r0, [r0, #1]
    3c3c:	f000 fafe 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    3c40:	4c2f      	ldr	r4, [pc, #188]	; (3d00 <MPSL_IRQ_TIMER0_Handler+0xec>)
    3c42:	f8d4 0304 	ldr.w	r0, [r4, #772]	; 0x304
    3c46:	f04f 0800 	mov.w	r8, #0
    3c4a:	f410 2f00 	tst.w	r0, #524288	; 0x80000
    3c4e:	f44f 7780 	mov.w	r7, #256	; 0x100
    3c52:	f04f 26e0 	mov.w	r6, #3758153728	; 0xe000e000
    3c56:	d00a      	beq.n	3c6e <MPSL_IRQ_TIMER0_Handler+0x5a>
    3c58:	482a      	ldr	r0, [pc, #168]	; (3d04 <MPSL_IRQ_TIMER0_Handler+0xf0>)
    3c5a:	6800      	ldr	r0, [r0, #0]
    3c5c:	b138      	cbz	r0, 3c6e <MPSL_IRQ_TIMER0_Handler+0x5a>
    3c5e:	2003      	movs	r0, #3
    3c60:	f000 faec 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    3c64:	f8c6 7280 	str.w	r7, [r6, #640]	; 0x280
    3c68:	2003      	movs	r0, #3
    3c6a:	f7fe fdf5 	bl	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3c6e:	f8d4 0304 	ldr.w	r0, [r4, #772]	; 0x304
    3c72:	f410 2f80 	tst.w	r0, #262144	; 0x40000
    3c76:	d00a      	beq.n	3c8e <MPSL_IRQ_TIMER0_Handler+0x7a>
    3c78:	4823      	ldr	r0, [pc, #140]	; (3d08 <MPSL_IRQ_TIMER0_Handler+0xf4>)
    3c7a:	6800      	ldr	r0, [r0, #0]
    3c7c:	b138      	cbz	r0, 3c8e <MPSL_IRQ_TIMER0_Handler+0x7a>
    3c7e:	2002      	movs	r0, #2
    3c80:	f000 fadc 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    3c84:	f8c6 7280 	str.w	r7, [r6, #640]	; 0x280
    3c88:	2002      	movs	r0, #2
    3c8a:	f7fe fde5 	bl	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3c8e:	f8d4 0304 	ldr.w	r0, [r4, #772]	; 0x304
    3c92:	f410 3f00 	tst.w	r0, #131072	; 0x20000
    3c96:	d00a      	beq.n	3cae <MPSL_IRQ_TIMER0_Handler+0x9a>
    3c98:	481c      	ldr	r0, [pc, #112]	; (3d0c <MPSL_IRQ_TIMER0_Handler+0xf8>)
    3c9a:	6800      	ldr	r0, [r0, #0]
    3c9c:	b138      	cbz	r0, 3cae <MPSL_IRQ_TIMER0_Handler+0x9a>
    3c9e:	2001      	movs	r0, #1
    3ca0:	f000 facc 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    3ca4:	f8c6 7280 	str.w	r7, [r6, #640]	; 0x280
    3ca8:	2001      	movs	r0, #1
    3caa:	f7fe fdd5 	bl	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3cae:	f8d4 0304 	ldr.w	r0, [r4, #772]	; 0x304
    3cb2:	f410 3f80 	tst.w	r0, #65536	; 0x10000
    3cb6:	bf08      	it	eq
    3cb8:	e8bd 81f0 	ldmiaeq.w	sp!, {r4, r5, r6, r7, r8, pc}
    3cbc:	4814      	ldr	r0, [pc, #80]	; (3d10 <MPSL_IRQ_TIMER0_Handler+0xfc>)
    3cbe:	6800      	ldr	r0, [r0, #0]
    3cc0:	2800      	cmp	r0, #0
    3cc2:	bf08      	it	eq
    3cc4:	e8bd 81f0 	ldmiaeq.w	sp!, {r4, r5, r6, r7, r8, pc}
    3cc8:	2000      	movs	r0, #0
    3cca:	f000 fab7 	bl	423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>
    3cce:	f8c6 7280 	str.w	r7, [r6, #640]	; 0x280
    3cd2:	2004      	movs	r0, #4
    3cd4:	7028      	strb	r0, [r5, #0]
    3cd6:	f8c5 8004 	str.w	r8, [r5, #4]
    3cda:	f8c4 8200 	str.w	r8, [r4, #512]	; 0x200
    3cde:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    3ce2:	2000      	movs	r0, #0
    3ce4:	f7fe bdb8 	b.w	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3ce8:	f240 419f 	movw	r1, #1183	; 0x49f
    3cec:	206c      	movs	r0, #108	; 0x6c
    3cee:	f000 ff61 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3cf2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    3cf6:	2007      	movs	r0, #7
    3cf8:	f7fe bdae 	b.w	2858 <sym_J5F7QGRFPKMLWRNSXZXS5YI7BM4DUTISCOASCOA>
    3cfc:	20000044 	.word	0x20000044
    3d00:	40008000 	.word	0x40008000
    3d04:	4000814c 	.word	0x4000814c
    3d08:	40008148 	.word	0x40008148
    3d0c:	40008144 	.word	0x40008144
    3d10:	40008140 	.word	0x40008140
    3d14:	2201      	movs	r2, #1
    3d16:	0211      	lsls	r1, r2, #8
    3d18:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    3d1c:	2000      	movs	r0, #0
    3d1e:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    3d22:	f503 73c0 	add.w	r3, r3, #384	; 0x180
    3d26:	f3bf 8f4f 	dsb	sy
    3d2a:	f3bf 8f6f 	isb	sy
    3d2e:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    3d32:	490e      	ldr	r1, [pc, #56]	; (3d6c <MPSL_IRQ_TIMER0_Handler+0x158>)
    3d34:	f841 2f04 	str.w	r2, [r1, #4]!
    3d38:	1e43      	subs	r3, r0, #1
    3d3a:	f8c1 3304 	str.w	r3, [r1, #772]	; 0x304
    3d3e:	f8c1 053c 	str.w	r0, [r1, #1340]	; 0x53c
    3d42:	f8c1 013c 	str.w	r0, [r1, #316]	; 0x13c
    3d46:	4b0a      	ldr	r3, [pc, #40]	; (3d70 <MPSL_IRQ_TIMER0_Handler+0x15c>)
    3d48:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    3d4c:	f8c1 0140 	str.w	r0, [r1, #320]	; 0x140
    3d50:	1d1b      	adds	r3, r3, #4
    3d52:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    3d56:	f8c1 0144 	str.w	r0, [r1, #324]	; 0x144
    3d5a:	1d1b      	adds	r3, r3, #4
    3d5c:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    3d60:	f8c1 0148 	str.w	r0, [r1, #328]	; 0x148
    3d64:	60ca      	str	r2, [r1, #12]
    3d66:	4903      	ldr	r1, [pc, #12]	; (3d74 <MPSL_IRQ_TIMER0_Handler+0x160>)
    3d68:	7048      	strb	r0, [r1, #1]
    3d6a:	4770      	bx	lr
    3d6c:	40008000 	.word	0x40008000
    3d70:	40008004 	.word	0x40008004
    3d74:	20000044 	.word	0x20000044

00003d78 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY>:
    3d78:	4801      	ldr	r0, [pc, #4]	; (3d80 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY+0x8>)
    3d7a:	6800      	ldr	r0, [r0, #0]
    3d7c:	4770      	bx	lr
    3d7e:	0000      	.short	0x0000
    3d80:	4000b504 	.word	0x4000b504

00003d84 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ>:
    3d84:	b430      	push	{r4, r5}
    3d86:	f3ef 8c10 	mrs	ip, PRIMASK
    3d8a:	b672      	cpsid	i
    3d8c:	2500      	movs	r5, #0
    3d8e:	4b0b      	ldr	r3, [pc, #44]	; (3dbc <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ+0x38>)
    3d90:	4a0b      	ldr	r2, [pc, #44]	; (3dc0 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ+0x3c>)
    3d92:	bf00      	nop
    3d94:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
    3d98:	f8d3 4104 	ldr.w	r4, [r3, #260]	; 0x104
    3d9c:	b12c      	cbz	r4, 3daa <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ+0x26>
    3d9e:	68d1      	ldr	r1, [r2, #12]
    3da0:	1c49      	adds	r1, r1, #1
    3da2:	60d1      	str	r1, [r2, #12]
    3da4:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
    3da8:	e7f4      	b.n	3d94 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ+0x10>
    3daa:	68d2      	ldr	r2, [r2, #12]
    3dac:	f1bc 0f00 	cmp.w	ip, #0
    3db0:	d100      	bne.n	3db4 <sym_ER2LFPTHTSYOYONJR4JS5HXOBOW2Y522PSIGIAQ+0x30>
    3db2:	b662      	cpsie	i
    3db4:	e9c0 1200 	strd	r1, r2, [r0]
    3db8:	bc30      	pop	{r4, r5}
    3dba:	4770      	bx	lr
    3dbc:	4000b000 	.word	0x4000b000
    3dc0:	20000044 	.word	0x20000044

00003dc4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ>:
    3dc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3dc8:	4e46      	ldr	r6, [pc, #280]	; (3ee4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x120>)
    3dca:	4605      	mov	r5, r0
    3dcc:	1eb7      	subs	r7, r6, #2
    3dce:	7833      	ldrb	r3, [r6, #0]
    3dd0:	68b9      	ldr	r1, [r7, #8]
    3dd2:	2b01      	cmp	r3, #1
    3dd4:	bf04      	itt	eq
    3dd6:	42a9      	cmpeq	r1, r5
    3dd8:	e8bd 87f0 	ldmiaeq.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3ddc:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
    3de0:	4a41      	ldr	r2, [pc, #260]	; (3ee8 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x124>)
    3de2:	6010      	str	r0, [r2, #0]
    3de4:	4a42      	ldr	r2, [pc, #264]	; (3ef0 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x12c>)
    3de6:	4841      	ldr	r0, [pc, #260]	; (3eec <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x128>)
    3de8:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    3dec:	f102 0c04 	add.w	ip, r2, #4
    3df0:	f04f 0400 	mov.w	r4, #0
    3df4:	2b00      	cmp	r3, #0
    3df6:	d062      	beq.n	3ebe <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0xfa>
    3df8:	483e      	ldr	r0, [pc, #248]	; (3ef4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x130>)
    3dfa:	f8c2 0348 	str.w	r0, [r2, #840]	; 0x348
    3dfe:	f8cc 4540 	str.w	r4, [ip, #1344]	; 0x540
    3e02:	f8c2 4144 	str.w	r4, [r2, #324]	; 0x144
    3e06:	bf00      	nop
    3e08:	f8d2 0148 	ldr.w	r0, [r2, #328]	; 0x148
    3e0c:	f04f 29e0 	mov.w	r9, #3758153728	; 0xe000e000
    3e10:	f04f 0801 	mov.w	r8, #1
    3e14:	2800      	cmp	r0, #0
    3e16:	bf01      	itttt	eq
    3e18:	f8d2 0104 	ldreq.w	r0, [r2, #260]	; 0x104
    3e1c:	2800      	cmpeq	r0, #0
    3e1e:	f44f 6000 	moveq.w	r0, #2048	; 0x800
    3e22:	f8c9 0280 	streq.w	r0, [r9, #640]	; 0x280
    3e26:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    3e2a:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    3e2e:	f8c2 0348 	str.w	r0, [r2, #840]	; 0x348
    3e32:	f8c2 4140 	str.w	r4, [r2, #320]	; 0x140
    3e36:	4830      	ldr	r0, [pc, #192]	; (3ef8 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x134>)
    3e38:	f8d0 c000 	ldr.w	ip, [r0]
    3e3c:	eba5 0c0c 	sub.w	ip, r5, ip
    3e40:	f02c 4c7f 	bic.w	ip, ip, #4278190080	; 0xff000000
    3e44:	f1bc 0f02 	cmp.w	ip, #2
    3e48:	d344      	bcc.n	3ed4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x110>
    3e4a:	f5bc 0f00 	cmp.w	ip, #8388608	; 0x800000
    3e4e:	d841      	bhi.n	3ed4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x110>
    3e50:	f8c2 5540 	str.w	r5, [r2, #1344]	; 0x540
    3e54:	f44f 3c80 	mov.w	ip, #65536	; 0x10000
    3e58:	f8c2 c344 	str.w	ip, [r2, #836]	; 0x344
    3e5c:	b12b      	cbz	r3, 3e6a <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0xa6>
    3e5e:	6802      	ldr	r2, [r0, #0]
    3e60:	1a8a      	subs	r2, r1, r2
    3e62:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    3e66:	2a02      	cmp	r2, #2
    3e68:	d3f9      	bcc.n	3e5e <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x9a>
    3e6a:	f8c7 8004 	str.w	r8, [r7, #4]
    3e6e:	703c      	strb	r4, [r7, #0]
    3e70:	f7ff ff50 	bl	3d14 <MPSL_IRQ_TIMER0_Handler+0x100>
    3e74:	4821      	ldr	r0, [pc, #132]	; (3efc <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x138>)
    3e76:	f8d0 1504 	ldr.w	r1, [r0, #1284]	; 0x504
    3e7a:	f364 0101 	bfi	r1, r4, #0, #2
    3e7e:	f8c0 1504 	str.w	r1, [r0, #1284]	; 0x504
    3e82:	f8d0 2508 	ldr.w	r2, [r0, #1288]	; 0x508
    3e86:	2102      	movs	r1, #2
    3e88:	f361 0201 	bfi	r2, r1, #0, #2
    3e8c:	f8c0 2508 	str.w	r2, [r0, #1288]	; 0x508
    3e90:	2104      	movs	r1, #4
    3e92:	f8c0 1510 	str.w	r1, [r0, #1296]	; 0x510
    3e96:	f8c0 800c 	str.w	r8, [r0, #12]
    3e9a:	6879      	ldr	r1, [r7, #4]
    3e9c:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
    3ea0:	1580      	asrs	r0, r0, #22
    3ea2:	f8c9 0280 	str.w	r0, [r9, #640]	; 0x280
    3ea6:	f8c9 0100 	str.w	r0, [r9, #256]	; 0x100
    3eaa:	4915      	ldr	r1, [pc, #84]	; (3f00 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x13c>)
    3eac:	05c0      	lsls	r0, r0, #23
    3eae:	6008      	str	r0, [r1, #0]
    3eb0:	2004      	movs	r0, #4
    3eb2:	60bd      	str	r5, [r7, #8]
    3eb4:	7070      	strb	r0, [r6, #1]
    3eb6:	f886 8000 	strb.w	r8, [r6]
    3eba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3ebe:	f8c2 0348 	str.w	r0, [r2, #840]	; 0x348
    3ec2:	f8c2 4540 	str.w	r4, [r2, #1344]	; 0x540
    3ec6:	f8c2 4140 	str.w	r4, [r2, #320]	; 0x140
    3eca:	f8cc 4540 	str.w	r4, [ip, #1344]	; 0x540
    3ece:	f8c2 4144 	str.w	r4, [r2, #324]	; 0x144
    3ed2:	e799      	b.n	3e08 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ+0x44>
    3ed4:	2000      	movs	r0, #0
    3ed6:	f8c2 0540 	str.w	r0, [r2, #1344]	; 0x540
    3eda:	f240 2193 	movw	r1, #659	; 0x293
    3ede:	206c      	movs	r0, #108	; 0x6c
    3ee0:	f000 fe68 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3ee4:	20000046 	.word	0x20000046
    3ee8:	4001f508 	.word	0x4001f508
    3eec:	fffbfffd 	.word	0xfffbfffd
    3ef0:	4000b000 	.word	0x4000b000
    3ef4:	fffafffd 	.word	0xfffafffd
    3ef8:	4000b504 	.word	0x4000b504
    3efc:	40008000 	.word	0x40008000
    3f00:	4001f504 	.word	0x4001f504

00003f04 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI>:
    3f04:	b570      	push	{r4, r5, r6, lr}
    3f06:	4c2a      	ldr	r4, [pc, #168]	; (3fb0 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0xac>)
    3f08:	68a1      	ldr	r1, [r4, #8]
    3f0a:	4281      	cmp	r1, r0
    3f0c:	bf14      	ite	ne
    3f0e:	2201      	movne	r2, #1
    3f10:	2200      	moveq	r2, #0
    3f12:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 3fb4 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0xb0>
    3f16:	f89c 5000 	ldrb.w	r5, [ip]
    3f1a:	2d02      	cmp	r5, #2
    3f1c:	d002      	beq.n	3f24 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x20>
    3f1e:	2a00      	cmp	r2, #0
    3f20:	d034      	beq.n	3f8c <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x88>
    3f22:	e002      	b.n	3f2a <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x26>
    3f24:	2a00      	cmp	r2, #0
    3f26:	bf08      	it	eq
    3f28:	bd70      	popeq	{r4, r5, r6, pc}
    3f2a:	7862      	ldrb	r2, [r4, #1]
    3f2c:	b39a      	cbz	r2, 3f96 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x92>
    3f2e:	4b22      	ldr	r3, [pc, #136]	; (3fb8 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0xb4>)
    3f30:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3f34:	601a      	str	r2, [r3, #0]
    3f36:	4b21      	ldr	r3, [pc, #132]	; (3fbc <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0xb8>)
    3f38:	1392      	asrs	r2, r2, #14
    3f3a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    3f3e:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
    3f42:	2200      	movs	r2, #0
    3f44:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    3f48:	4a1d      	ldr	r2, [pc, #116]	; (3fc0 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0xbc>)
    3f4a:	6816      	ldr	r6, [r2, #0]
    3f4c:	1b86      	subs	r6, r0, r6
    3f4e:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
    3f52:	2e02      	cmp	r6, #2
    3f54:	d324      	bcc.n	3fa0 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x9c>
    3f56:	f5b6 0f00 	cmp.w	r6, #8388608	; 0x800000
    3f5a:	d821      	bhi.n	3fa0 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x9c>
    3f5c:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    3f60:	f44f 3680 	mov.w	r6, #65536	; 0x10000
    3f64:	f8c3 6344 	str.w	r6, [r3, #836]	; 0x344
    3f68:	b12d      	cbz	r5, 3f76 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x72>
    3f6a:	6813      	ldr	r3, [r2, #0]
    3f6c:	1acb      	subs	r3, r1, r3
    3f6e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    3f72:	2b02      	cmp	r3, #2
    3f74:	d3f9      	bcc.n	3f6a <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0x66>
    3f76:	4b13      	ldr	r3, [pc, #76]	; (3fc4 <sym_UGOJA475OXR5HR5WFINUK27HP5BRGNWCZXQLKDI+0xc0>)
    3f78:	2102      	movs	r1, #2
    3f7a:	074a      	lsls	r2, r1, #29
    3f7c:	601a      	str	r2, [r3, #0]
    3f7e:	60a0      	str	r0, [r4, #8]
    3f80:	2004      	movs	r0, #4
    3f82:	f88c 0001 	strb.w	r0, [ip, #1]
    3f86:	f88c 1000 	strb.w	r1, [ip]
    3f8a:	bd70      	pop	{r4, r5, r6, pc}
    3f8c:	f240 21a1 	movw	r1, #673	; 0x2a1
    3f90:	206c      	movs	r0, #108	; 0x6c
    3f92:	f000 fe0f 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3f96:	f240 21a5 	movw	r1, #677	; 0x2a5
    3f9a:	206c      	movs	r0, #108	; 0x6c
    3f9c:	f000 fe0a 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3fa0:	2000      	movs	r0, #0
    3fa2:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    3fa6:	f240 21b1 	movw	r1, #689	; 0x2b1
    3faa:	206c      	movs	r0, #108	; 0x6c
    3fac:	f000 fe02 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    3fb0:	20000044 	.word	0x20000044
    3fb4:	20000046 	.word	0x20000046
    3fb8:	4001f508 	.word	0x4001f508
    3fbc:	4000b000 	.word	0x4000b000
    3fc0:	4000b504 	.word	0x4000b504
    3fc4:	4001f504 	.word	0x4001f504

00003fc8 <sym_RUQO26WM5KVVEW7O3OHCXPO7LLLXRBDPIPSWIWY>:
    3fc8:	4801      	ldr	r0, [pc, #4]	; (3fd0 <sym_RUQO26WM5KVVEW7O3OHCXPO7LLLXRBDPIPSWIWY+0x8>)
    3fca:	6880      	ldr	r0, [r0, #8]
    3fcc:	4770      	bx	lr
    3fce:	0000      	.short	0x0000
    3fd0:	20000044 	.word	0x20000044

00003fd4 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA>:
    3fd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3fd8:	4836      	ldr	r0, [pc, #216]	; (40b4 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xe0>)
    3fda:	4a35      	ldr	r2, [pc, #212]	; (40b0 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xdc>)
    3fdc:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
    3fe0:	f8df c0d4 	ldr.w	ip, [pc, #212]	; 40b8 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xe4>
    3fe4:	1d03      	adds	r3, r0, #4
    3fe6:	2100      	movs	r1, #0
    3fe8:	f89c 4000 	ldrb.w	r4, [ip]
    3fec:	b184      	cbz	r4, 4010 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x3c>
    3fee:	4a33      	ldr	r2, [pc, #204]	; (40bc <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xe8>)
    3ff0:	f8c0 2348 	str.w	r2, [r0, #840]	; 0x348
    3ff4:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
    3ff8:	f8c0 1144 	str.w	r1, [r0, #324]	; 0x144
    3ffc:	f8d0 2148 	ldr.w	r2, [r0, #328]	; 0x148
    4000:	2301      	movs	r3, #1
    4002:	2a00      	cmp	r2, #0
    4004:	bf04      	itt	eq
    4006:	f8d0 0104 	ldreq.w	r0, [r0, #260]	; 0x104
    400a:	2800      	cmpeq	r0, #0
    400c:	d111      	bne.n	4032 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x5e>
    400e:	e00a      	b.n	4026 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x52>
    4010:	f8c0 2348 	str.w	r2, [r0, #840]	; 0x348
    4014:	f8c0 1540 	str.w	r1, [r0, #1344]	; 0x540
    4018:	f8c0 1140 	str.w	r1, [r0, #320]	; 0x140
    401c:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
    4020:	f8c0 1144 	str.w	r1, [r0, #324]	; 0x144
    4024:	e7ea      	b.n	3ffc <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x28>
    4026:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    402a:	f44f 6000 	mov.w	r0, #2048	; 0x800
    402e:	f8c2 0280 	str.w	r0, [r2, #640]	; 0x280
    4032:	2c02      	cmp	r4, #2
    4034:	d004      	beq.n	4040 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x6c>
    4036:	f240 21bd 	movw	r1, #701	; 0x2bd
    403a:	206c      	movs	r0, #108	; 0x6c
    403c:	f000 fdba 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    4040:	4e1f      	ldr	r6, [pc, #124]	; (40c0 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xec>)
    4042:	6830      	ldr	r0, [r6, #0]
    4044:	4c1f      	ldr	r4, [pc, #124]	; (40c4 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xf0>)
    4046:	1cc0      	adds	r0, r0, #3
    4048:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    404c:	68a2      	ldr	r2, [r4, #8]
    404e:	4d1e      	ldr	r5, [pc, #120]	; (40c8 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xf4>)
    4050:	4290      	cmp	r0, r2
    4052:	d00b      	beq.n	406c <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x98>
    4054:	6837      	ldr	r7, [r6, #0]
    4056:	1bd7      	subs	r7, r2, r7
    4058:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
    405c:	2f04      	cmp	r7, #4
    405e:	d305      	bcc.n	406c <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x98>
    4060:	f5b7 0f00 	cmp.w	r7, #8388608	; 0x800000
    4064:	d802      	bhi.n	406c <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0x98>
    4066:	f7ff fead 	bl	3dc4 <sym_2ZDZA75WOMRNSQ6XL7IZWAQKYFFSRJOGBGKPTIQ>
    406a:	e01b      	b.n	40a4 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xd0>
    406c:	6830      	ldr	r0, [r6, #0]
    406e:	1a10      	subs	r0, r2, r0
    4070:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    4074:	2802      	cmp	r0, #2
    4076:	d313      	bcc.n	40a0 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xcc>
    4078:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    407c:	d810      	bhi.n	40a0 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xcc>
    407e:	4a13      	ldr	r2, [pc, #76]	; (40cc <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xf8>)
    4080:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    4084:	6010      	str	r0, [r2, #0]
    4086:	6063      	str	r3, [r4, #4]
    4088:	7021      	strb	r1, [r4, #0]
    408a:	606b      	str	r3, [r5, #4]
    408c:	60eb      	str	r3, [r5, #12]
    408e:	0040      	lsls	r0, r0, #1
    4090:	1f11      	subs	r1, r2, #4
    4092:	6008      	str	r0, [r1, #0]
    4094:	2004      	movs	r0, #4
    4096:	f88c 0001 	strb.w	r0, [ip, #1]
    409a:	f88c 3000 	strb.w	r3, [ip]
    409e:	e001      	b.n	40a4 <sym_QUBGY7RMPG7R5F6DVNURH4AVGDAWMK46YXU4DRA+0xd0>
    40a0:	6063      	str	r3, [r4, #4]
    40a2:	7021      	strb	r1, [r4, #0]
    40a4:	6860      	ldr	r0, [r4, #4]
    40a6:	f8c5 0200 	str.w	r0, [r5, #512]	; 0x200
    40aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    40ae:	0000      	.short	0x0000
    40b0:	fffbfffd 	.word	0xfffbfffd
    40b4:	4000b000 	.word	0x4000b000
    40b8:	20000046 	.word	0x20000046
    40bc:	fffafffd 	.word	0xfffafffd
    40c0:	4000b504 	.word	0x4000b504
    40c4:	20000044 	.word	0x20000044
    40c8:	40008000 	.word	0x40008000
    40cc:	4001f508 	.word	0x4001f508

000040d0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ>:
    40d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    40d4:	4a54      	ldr	r2, [pc, #336]	; (4228 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x158>)
    40d6:	2500      	movs	r5, #0
    40d8:	2401      	movs	r4, #1
    40da:	f892 c000 	ldrb.w	ip, [r2]
    40de:	7853      	ldrb	r3, [r2, #1]
    40e0:	f44f 76a0 	mov.w	r6, #320	; 0x140
    40e4:	2807      	cmp	r0, #7
    40e6:	d27d      	bcs.n	41e4 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x114>
    40e8:	e8df f000 	tbb	[pc, r0]
    40ec:	04040404 	.word	0x04040404
    40f0:	00585858 	.word	0x00585858
    40f4:	4a4d      	ldr	r2, [pc, #308]	; (422c <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x15c>)
    40f6:	6897      	ldr	r7, [r2, #8]
    40f8:	f1b7 7f80 	cmp.w	r7, #16777216	; 0x1000000
    40fc:	bf04      	itt	eq
    40fe:	7852      	ldrbeq	r2, [r2, #1]
    4100:	2a00      	cmpeq	r2, #0
    4102:	d003      	beq.n	410c <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x3c>
    4104:	f1bc 0f02 	cmp.w	ip, #2
    4108:	d005      	beq.n	4116 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x46>
    410a:	e026      	b.n	415a <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x8a>
    410c:	f240 314d 	movw	r1, #845	; 0x34d
    4110:	206c      	movs	r0, #108	; 0x6c
    4112:	f000 fd4f 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    4116:	1f1a      	subs	r2, r3, #4
    4118:	b2d2      	uxtb	r2, r2
    411a:	eb06 0282 	add.w	r2, r6, r2, lsl #2
    411e:	f102 4680 	add.w	r6, r2, #1073741824	; 0x40000000
    4122:	f506 4630 	add.w	r6, r6, #45056	; 0xb000
    4126:	2200      	movs	r2, #0
    4128:	f1bc 0f01 	cmp.w	ip, #1
    412c:	d003      	beq.n	4136 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x66>
    412e:	f1bc 0f02 	cmp.w	ip, #2
    4132:	d008      	beq.n	4146 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x76>
    4134:	e00e      	b.n	4154 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x84>
    4136:	2b04      	cmp	r3, #4
    4138:	bf24      	itt	cs
    413a:	6837      	ldrcs	r7, [r6, #0]
    413c:	2f00      	cmpcs	r7, #0
    413e:	bf08      	it	eq
    4140:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
    4144:	e006      	b.n	4154 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x84>
    4146:	2b04      	cmp	r3, #4
    4148:	bf24      	itt	cs
    414a:	6837      	ldrcs	r7, [r6, #0]
    414c:	2f00      	cmpcs	r7, #0
    414e:	bf08      	it	eq
    4150:	f042 4280 	orreq.w	r2, r2, #1073741824	; 0x40000000
    4154:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
    4158:	d1e5      	bne.n	4126 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x56>
    415a:	f8df c0d4 	ldr.w	ip, [pc, #212]	; 4230 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x160>
    415e:	f100 0210 	add.w	r2, r0, #16
    4162:	fa04 f202 	lsl.w	r2, r4, r2
    4166:	f8cc 2308 	str.w	r2, [ip, #776]	; 0x308
    416a:	f04f 0340 	mov.w	r3, #64	; 0x40
    416e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    4172:	b2db      	uxtb	r3, r3
    4174:	4463      	add	r3, ip
    4176:	601c      	str	r4, [r3, #0]
    4178:	eb0c 0080 	add.w	r0, ip, r0, lsl #2
    417c:	f8d0 3540 	ldr.w	r3, [r0, #1344]	; 0x540
    4180:	eba1 0303 	sub.w	r3, r1, r3
    4184:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4188:	2b03      	cmp	r3, #3
    418a:	bf26      	itte	cs
    418c:	f8c0 1540 	strcs.w	r1, [r0, #1344]	; 0x540
    4190:	f8cc 2304 	strcs.w	r2, [ip, #772]	; 0x304
    4194:	f8c0 5540 	strcc.w	r5, [r0, #1344]	; 0x540
    4198:	d237      	bcs.n	420a <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x13a>
    419a:	e03c      	b.n	4216 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x146>
    419c:	f1bc 0f00 	cmp.w	ip, #0
    41a0:	d006      	beq.n	41b0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0xe0>
    41a2:	4283      	cmp	r3, r0
    41a4:	d104      	bne.n	41b0 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0xe0>
    41a6:	f240 316d 	movw	r1, #877	; 0x36d
    41aa:	206c      	movs	r0, #108	; 0x6c
    41ac:	f000 fd02 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    41b0:	1f02      	subs	r2, r0, #4
    41b2:	b2d3      	uxtb	r3, r2
    41b4:	2b03      	cmp	r3, #3
    41b6:	d304      	bcc.n	41c2 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0xf2>
    41b8:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
    41bc:	206c      	movs	r0, #108	; 0x6c
    41be:	f000 fcf9 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    41c2:	f8df c070 	ldr.w	ip, [pc, #112]	; 4234 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x164>
    41c6:	f103 0210 	add.w	r2, r3, #16
    41ca:	fa04 f202 	lsl.w	r2, r4, r2
    41ce:	f8cc 2308 	str.w	r2, [ip, #776]	; 0x308
    41d2:	f8cc 2348 	str.w	r2, [ip, #840]	; 0x348
    41d6:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    41da:	f84c 5003 	str.w	r5, [ip, r3]
    41de:	4b16      	ldr	r3, [pc, #88]	; (4238 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x168>)
    41e0:	681b      	ldr	r3, [r3, #0]
    41e2:	e000      	b.n	41e6 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x116>
    41e4:	e01a      	b.n	421c <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x14c>
    41e6:	1f00      	subs	r0, r0, #4
    41e8:	1acb      	subs	r3, r1, r3
    41ea:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    41ee:	b2c0      	uxtb	r0, r0
    41f0:	eb0c 0080 	add.w	r0, ip, r0, lsl #2
    41f4:	2b02      	cmp	r3, #2
    41f6:	d30b      	bcc.n	4210 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x140>
    41f8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    41fc:	d808      	bhi.n	4210 <sym_X2K67YH6UCW6TFK6NTLPZZFGWYHTTPZYK5PXHNQ+0x140>
    41fe:	f8c0 1540 	str.w	r1, [r0, #1344]	; 0x540
    4202:	f8cc 2304 	str.w	r2, [ip, #772]	; 0x304
    4206:	f8cc 2344 	str.w	r2, [ip, #836]	; 0x344
    420a:	2001      	movs	r0, #1
    420c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4210:	2100      	movs	r1, #0
    4212:	f8c0 1540 	str.w	r1, [r0, #1344]	; 0x540
    4216:	2000      	movs	r0, #0
    4218:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    421c:	f240 3171 	movw	r1, #881	; 0x371
    4220:	206c      	movs	r0, #108	; 0x6c
    4222:	f000 fcc7 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    4226:	0000      	.short	0x0000
    4228:	20000046 	.word	0x20000046
    422c:	20000044 	.word	0x20000044
    4230:	40008000 	.word	0x40008000
    4234:	4000b000 	.word	0x4000b000
    4238:	4000b504 	.word	0x4000b504

0000423c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY>:
    423c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4240:	2601      	movs	r6, #1
    4242:	2700      	movs	r7, #0
    4244:	f44f 78a0 	mov.w	r8, #320	; 0x140
    4248:	2807      	cmp	r0, #7
    424a:	d251      	bcs.n	42f0 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xb4>
    424c:	e8df f000 	tbb	[pc, r0]
    4250:	04040404 	.word	0x04040404
    4254:	00191919 	.word	0x00191919
    4258:	f100 0110 	add.w	r1, r0, #16
    425c:	fa06 f201 	lsl.w	r2, r6, r1
    4260:	4926      	ldr	r1, [pc, #152]	; (42fc <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xc0>)
    4262:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    4266:	eb01 0380 	add.w	r3, r1, r0, lsl #2
    426a:	2200      	movs	r2, #0
    426c:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    4270:	eb08 0280 	add.w	r2, r8, r0, lsl #2
    4274:	508f      	str	r7, [r1, r2]
    4276:	4922      	ldr	r1, [pc, #136]	; (4300 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xc4>)
    4278:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    427c:	9000      	str	r0, [sp, #0]
    427e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4282:	4d20      	ldr	r5, [pc, #128]	; (4304 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xc8>)
    4284:	1f01      	subs	r1, r0, #4
    4286:	b2cc      	uxtb	r4, r1
    4288:	7829      	ldrb	r1, [r5, #0]
    428a:	b179      	cbz	r1, 42ac <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0x70>
    428c:	786a      	ldrb	r2, [r5, #1]
    428e:	4282      	cmp	r2, r0
    4290:	d10c      	bne.n	42ac <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0x70>
    4292:	4a1d      	ldr	r2, [pc, #116]	; (4308 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xcc>)
    4294:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
    4298:	6010      	str	r0, [r2, #0]
    429a:	2901      	cmp	r1, #1
    429c:	bf08      	it	eq
    429e:	f7ff fd39 	bleq	3d14 <MPSL_IRQ_TIMER0_Handler+0x100>
    42a2:	702f      	strb	r7, [r5, #0]
    42a4:	4919      	ldr	r1, [pc, #100]	; (430c <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xd0>)
    42a6:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
    42aa:	6088      	str	r0, [r1, #8]
    42ac:	4918      	ldr	r1, [pc, #96]	; (4310 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xd4>)
    42ae:	f104 0010 	add.w	r0, r4, #16
    42b2:	fa06 f000 	lsl.w	r0, r6, r0
    42b6:	f8c1 0308 	str.w	r0, [r1, #776]	; 0x308
    42ba:	f8c1 0348 	str.w	r0, [r1, #840]	; 0x348
    42be:	00a0      	lsls	r0, r4, #2
    42c0:	4408      	add	r0, r1
    42c2:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
    42c6:	4a13      	ldr	r2, [pc, #76]	; (4314 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xd8>)
    42c8:	6812      	ldr	r2, [r2, #0]
    42ca:	1a80      	subs	r0, r0, r2
    42cc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    42d0:	2802      	cmp	r0, #2
    42d2:	d307      	bcc.n	42e4 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xa8>
    42d4:	eb01 0284 	add.w	r2, r1, r4, lsl #2
    42d8:	2000      	movs	r0, #0
    42da:	f8c2 0540 	str.w	r0, [r2, #1344]	; 0x540
    42de:	eb08 0084 	add.w	r0, r8, r4, lsl #2
    42e2:	500f      	str	r7, [r1, r0]
    42e4:	480c      	ldr	r0, [pc, #48]	; (4318 <sym_TSYEIN5CZPQE3YK6VECZD5C2M4LMXKKH6O7LNAY+0xdc>)
    42e6:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
    42ea:	9000      	str	r0, [sp, #0]
    42ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    42f0:	f240 31f5 	movw	r1, #1013	; 0x3f5
    42f4:	206c      	movs	r0, #108	; 0x6c
    42f6:	f000 fc5d 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    42fa:	0000      	.short	0x0000
    42fc:	40008000 	.word	0x40008000
    4300:	40008140 	.word	0x40008140
    4304:	20000046 	.word	0x20000046
    4308:	4001f508 	.word	0x4001f508
    430c:	20000044 	.word	0x20000044
    4310:	4000b000 	.word	0x4000b000
    4314:	4000b504 	.word	0x4000b504
    4318:	4000b140 	.word	0x4000b140

0000431c <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q>:
    431c:	4825      	ldr	r0, [pc, #148]	; (43b4 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x98>)
    431e:	4a24      	ldr	r2, [pc, #144]	; (43b0 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x94>)
    4320:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
    4324:	4924      	ldr	r1, [pc, #144]	; (43b8 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x9c>)
    4326:	1d03      	adds	r3, r0, #4
    4328:	f891 c000 	ldrb.w	ip, [r1]
    432c:	2100      	movs	r1, #0
    432e:	f1bc 0f00 	cmp.w	ip, #0
    4332:	d010      	beq.n	4356 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x3a>
    4334:	4a21      	ldr	r2, [pc, #132]	; (43bc <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0xa0>)
    4336:	f8c0 2348 	str.w	r2, [r0, #840]	; 0x348
    433a:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
    433e:	f8c0 1144 	str.w	r1, [r0, #324]	; 0x144
    4342:	bf00      	nop
    4344:	f8d0 2148 	ldr.w	r2, [r0, #328]	; 0x148
    4348:	2a00      	cmp	r2, #0
    434a:	bf04      	itt	eq
    434c:	f8d0 0104 	ldreq.w	r0, [r0, #260]	; 0x104
    4350:	2800      	cmpeq	r0, #0
    4352:	d111      	bne.n	4378 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x5c>
    4354:	e00a      	b.n	436c <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x50>
    4356:	f8c0 2348 	str.w	r2, [r0, #840]	; 0x348
    435a:	f8c0 1540 	str.w	r1, [r0, #1344]	; 0x540
    435e:	f8c0 1140 	str.w	r1, [r0, #320]	; 0x140
    4362:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
    4366:	f8c0 1144 	str.w	r1, [r0, #324]	; 0x144
    436a:	e7eb      	b.n	4344 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0x28>
    436c:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    4370:	f44f 6000 	mov.w	r0, #2048	; 0x800
    4374:	f8c2 0280 	str.w	r0, [r2, #640]	; 0x280
    4378:	4811      	ldr	r0, [pc, #68]	; (43c0 <sym_OLTN5HGCU3P74AJAQRGNYBUXASUKWF3RI2Q3H5Q+0xa4>)
    437a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    437e:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
    4382:	f8c0 1540 	str.w	r1, [r0, #1344]	; 0x540
    4386:	f8c0 1140 	str.w	r1, [r0, #320]	; 0x140
    438a:	f100 0204 	add.w	r2, r0, #4
    438e:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
    4392:	f8c0 1144 	str.w	r1, [r0, #324]	; 0x144
    4396:	f102 0204 	add.w	r2, r2, #4
    439a:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
    439e:	f8c0 1148 	str.w	r1, [r0, #328]	; 0x148
    43a2:	f102 0204 	add.w	r2, r2, #4
    43a6:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
    43aa:	f8c0 114c 	str.w	r1, [r0, #332]	; 0x14c
    43ae:	4770      	bx	lr
    43b0:	fffbfffd 	.word	0xfffbfffd
    43b4:	4000b000 	.word	0x4000b000
    43b8:	20000046 	.word	0x20000046
    43bc:	fffafffd 	.word	0xfffafffd
    43c0:	40008000 	.word	0x40008000

000043c4 <sym_DY4TH3UYBBOUULSDPZZ7Y6J5DTNRGWFEBHJXKVA>:
    43c4:	b510      	push	{r4, lr}
    43c6:	2807      	cmp	r0, #7
    43c8:	d20d      	bcs.n	43e6 <sym_DY4TH3UYBBOUULSDPZZ7Y6J5DTNRGWFEBHJXKVA+0x22>
    43ca:	e8df f000 	tbb	[pc, r0]
    43ce:	0404      	.short	0x0404
    43d0:	06060404 	.word	0x06060404
    43d4:	0006      	.short	0x0006
    43d6:	4906      	ldr	r1, [pc, #24]	; (43f0 <sym_DY4TH3UYBBOUULSDPZZ7Y6J5DTNRGWFEBHJXKVA+0x2c>)
    43d8:	e002      	b.n	43e0 <sym_DY4TH3UYBBOUULSDPZZ7Y6J5DTNRGWFEBHJXKVA+0x1c>
    43da:	1f00      	subs	r0, r0, #4
    43dc:	4905      	ldr	r1, [pc, #20]	; (43f4 <sym_DY4TH3UYBBOUULSDPZZ7Y6J5DTNRGWFEBHJXKVA+0x30>)
    43de:	b2c0      	uxtb	r0, r0
    43e0:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    43e4:	bd10      	pop	{r4, pc}
    43e6:	f240 3195 	movw	r1, #917	; 0x395
    43ea:	206c      	movs	r0, #108	; 0x6c
    43ec:	f000 fbe2 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    43f0:	40008140 	.word	0x40008140
    43f4:	4000b140 	.word	0x4000b140

000043f8 <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI>:
    43f8:	b570      	push	{r4, r5, r6, lr}
    43fa:	481f      	ldr	r0, [pc, #124]	; (4478 <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI+0x80>)
    43fc:	2400      	movs	r4, #0
    43fe:	2104      	movs	r1, #4
    4400:	7004      	strb	r4, [r0, #0]
    4402:	1e80      	subs	r0, r0, #2
    4404:	7001      	strb	r1, [r0, #0]
    4406:	0589      	lsls	r1, r1, #22
    4408:	60c4      	str	r4, [r0, #12]
    440a:	6081      	str	r1, [r0, #8]
    440c:	f7ff fc82 	bl	3d14 <MPSL_IRQ_TIMER0_Handler+0x100>
    4410:	2501      	movs	r5, #1
    4412:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
    4416:	02eb      	lsls	r3, r5, #11
    4418:	f8cc 3180 	str.w	r3, [ip, #384]	; 0x180
    441c:	f3bf 8f4f 	dsb	sy
    4420:	f3bf 8f6f 	isb	sy
    4424:	f8cc 3280 	str.w	r3, [ip, #640]	; 0x280
    4428:	4814      	ldr	r0, [pc, #80]	; (447c <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI+0x84>)
    442a:	6045      	str	r5, [r0, #4]
    442c:	6085      	str	r5, [r0, #8]
    442e:	4914      	ldr	r1, [pc, #80]	; (4480 <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI+0x88>)
    4430:	680a      	ldr	r2, [r1, #0]
    4432:	2a00      	cmp	r2, #0
    4434:	d1fc      	bne.n	4430 <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI+0x38>
    4436:	1e51      	subs	r1, r2, #1
    4438:	f8c0 1308 	str.w	r1, [r0, #776]	; 0x308
    443c:	f8c0 1348 	str.w	r1, [r0, #840]	; 0x348
    4440:	f8c0 4540 	str.w	r4, [r0, #1344]	; 0x540
    4444:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
    4448:	490e      	ldr	r1, [pc, #56]	; (4484 <sym_3SK52U5TD4ACVVYKWS6UI6ZPWKSLV6BW5IGCPJI+0x8c>)
    444a:	f8c1 4540 	str.w	r4, [r1, #1344]	; 0x540
    444e:	f8c0 4144 	str.w	r4, [r0, #324]	; 0x144
    4452:	1d09      	adds	r1, r1, #4
    4454:	f8c1 4540 	str.w	r4, [r1, #1344]	; 0x540
    4458:	f8c0 4148 	str.w	r4, [r0, #328]	; 0x148
    445c:	f8c0 4104 	str.w	r4, [r0, #260]	; 0x104
    4460:	f8cc 3100 	str.w	r3, [ip, #256]	; 0x100
    4464:	6005      	str	r5, [r0, #0]
    4466:	f44f 7182 	mov.w	r1, #260	; 0x104
    446a:	f8c0 1344 	str.w	r1, [r0, #836]	; 0x344
    446e:	2102      	movs	r1, #2
    4470:	f8c0 1304 	str.w	r1, [r0, #772]	; 0x304
    4474:	bd70      	pop	{r4, r5, r6, pc}
    4476:	0000      	.short	0x0000
    4478:	20000046 	.word	0x20000046
    447c:	4000b000 	.word	0x4000b000
    4480:	4000b504 	.word	0x4000b504
    4484:	4000b004 	.word	0x4000b004

00004488 <sym_52O7VXVVZYQGD3Z6C3FDJLGBNMQQ6XC5LJ3IFRQ>:
    4488:	4808      	ldr	r0, [pc, #32]	; (44ac <sym_52O7VXVVZYQGD3Z6C3FDJLGBNMQQ6XC5LJ3IFRQ+0x24>)
    448a:	f990 0000 	ldrsb.w	r0, [r0]
    448e:	2800      	cmp	r0, #0
    4490:	bfb8      	it	lt
    4492:	4770      	bxlt	lr
    4494:	f000 011f 	and.w	r1, r0, #31
    4498:	2201      	movs	r2, #1
    449a:	fa02 f101 	lsl.w	r1, r2, r1
    449e:	0940      	lsrs	r0, r0, #5
    44a0:	0080      	lsls	r0, r0, #2
    44a2:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    44a6:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
    44aa:	4770      	bx	lr
    44ac:	20000324 	.word	0x20000324

000044b0 <sym_7TCBS6SSQW4V3WJBKAXLOSA2HN4KF7UYAM2QFKI>:
    44b0:	4803      	ldr	r0, [pc, #12]	; (44c0 <sym_7TCBS6SSQW4V3WJBKAXLOSA2HN4KF7UYAM2QFKI+0x10>)
    44b2:	7800      	ldrb	r0, [r0, #0]
    44b4:	2803      	cmp	r0, #3
    44b6:	bf0c      	ite	eq
    44b8:	2001      	moveq	r0, #1
    44ba:	2000      	movne	r0, #0
    44bc:	4770      	bx	lr
    44be:	0000      	.short	0x0000
    44c0:	20000310 	.word	0x20000310

000044c4 <sym_HUWGHJMM42MANQTSVL3EY7E3VE4XM4JTQUIQAII>:
    44c4:	4801      	ldr	r0, [pc, #4]	; (44cc <sym_HUWGHJMM42MANQTSVL3EY7E3VE4XM4JTQUIQAII+0x8>)
    44c6:	8840      	ldrh	r0, [r0, #2]
    44c8:	4770      	bx	lr
    44ca:	0000      	.short	0x0000
    44cc:	20000310 	.word	0x20000310

000044d0 <sym_3RLTHYPNUGF2GJUCXUGLNFS6UK7UWZOBB6PWVDI>:
    44d0:	4803      	ldr	r0, [pc, #12]	; (44e0 <sym_3RLTHYPNUGF2GJUCXUGLNFS6UK7UWZOBB6PWVDI+0x10>)
    44d2:	7800      	ldrb	r0, [r0, #0]
    44d4:	2802      	cmp	r0, #2
    44d6:	bf16      	itet	ne
    44d8:	2803      	cmpne	r0, #3
    44da:	2001      	moveq	r0, #1
    44dc:	2000      	movne	r0, #0
    44de:	4770      	bx	lr
    44e0:	20000310 	.word	0x20000310

000044e4 <sym_476ZEBCLN4VRBESFX6B7F6TMVQVNPVCGXRXSHHY>:
    44e4:	4802      	ldr	r0, [pc, #8]	; (44f0 <sym_476ZEBCLN4VRBESFX6B7F6TMVQVNPVCGXRXSHHY+0xc>)
    44e6:	2100      	movs	r1, #0
    44e8:	7001      	strb	r1, [r0, #0]
    44ea:	8041      	strh	r1, [r0, #2]
    44ec:	4770      	bx	lr
    44ee:	0000      	.short	0x0000
    44f0:	20000310 	.word	0x20000310

000044f4 <MPSL_IRQ_CLOCK_Handler>:
    44f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    44f8:	4c16      	ldr	r4, [pc, #88]	; (4554 <MPSL_IRQ_CLOCK_Handler+0x60>)
    44fa:	7a60      	ldrb	r0, [r4, #9]
    44fc:	2800      	cmp	r0, #0
    44fe:	d027      	beq.n	4550 <MPSL_IRQ_CLOCK_Handler+0x5c>
    4500:	f44f 7180 	mov.w	r1, #256	; 0x100
    4504:	058d      	lsls	r5, r1, #22
    4506:	4628      	mov	r0, r5
    4508:	f008 fc5d 	bl	cdc6 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x48>
    450c:	4680      	mov	r8, r0
    450e:	f44f 7182 	mov.w	r1, #260	; 0x104
    4512:	4628      	mov	r0, r5
    4514:	f008 fc57 	bl	cdc6 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x48>
    4518:	2600      	movs	r6, #0
    451a:	4607      	mov	r7, r0
    451c:	f1b8 0f00 	cmp.w	r8, #0
    4520:	d009      	beq.n	4536 <MPSL_IRQ_CLOCK_Handler+0x42>
    4522:	2001      	movs	r0, #1
    4524:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
    4528:	7920      	ldrb	r0, [r4, #4]
    452a:	b120      	cbz	r0, 4536 <MPSL_IRQ_CLOCK_Handler+0x42>
    452c:	7126      	strb	r6, [r4, #4]
    452e:	69e0      	ldr	r0, [r4, #28]
    4530:	b108      	cbz	r0, 4536 <MPSL_IRQ_CLOCK_Handler+0x42>
    4532:	4780      	blx	r0
    4534:	61e6      	str	r6, [r4, #28]
    4536:	b137      	cbz	r7, 4546 <MPSL_IRQ_CLOCK_Handler+0x52>
    4538:	f8c5 6104 	str.w	r6, [r5, #260]	; 0x104
    453c:	2002      	movs	r0, #2
    453e:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
    4542:	f000 fa6b 	bl	4a1c <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q>
    4546:	4640      	mov	r0, r8
    4548:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    454c:	f000 b858 	b.w	4600 <MPSL_IRQ_CLOCK_Handler+0x10c>
    4550:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4554:	20000054 	.word	0x20000054
    4558:	b510      	push	{r4, lr}
    455a:	f008 fcde 	bl	cf1a <sym_NQG4U7UYIQILZLC5ENYCA4NQMQM6PBAZC345PPA>
    455e:	b930      	cbnz	r0, 456e <MPSL_IRQ_CLOCK_Handler+0x7a>
    4560:	f008 fcfc 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    4564:	b918      	cbnz	r0, 456e <MPSL_IRQ_CLOCK_Handler+0x7a>
    4566:	f008 fd2f 	bl	cfc8 <sym_USR4MDT6VMTQLOGKNN4MALBZ3GJPD2KOEY4HFAQ>
    456a:	2800      	cmp	r0, #0
    456c:	d002      	beq.n	4574 <MPSL_IRQ_CLOCK_Handler+0x80>
    456e:	4902      	ldr	r1, [pc, #8]	; (4578 <MPSL_IRQ_CLOCK_Handler+0x84>)
    4570:	2002      	movs	r0, #2
    4572:	6008      	str	r0, [r1, #0]
    4574:	bd10      	pop	{r4, pc}
    4576:	0000      	.short	0x0000
    4578:	40000c34 	.word	0x40000c34
    457c:	b570      	push	{r4, r5, r6, lr}
    457e:	f000 f991 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    4582:	f000 fa9f 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    4586:	4c09      	ldr	r4, [pc, #36]	; (45ac <MPSL_IRQ_CLOCK_Handler+0xb8>)
    4588:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    458c:	b130      	cbz	r0, 459c <MPSL_IRQ_CLOCK_Handler+0xa8>
    458e:	f7ff ffe3 	bl	4558 <MPSL_IRQ_CLOCK_Handler+0x64>
    4592:	2001      	movs	r0, #1
    4594:	6128      	str	r0, [r5, #16]
    4596:	2004      	movs	r0, #4
    4598:	72a0      	strb	r0, [r4, #10]
    459a:	e004      	b.n	45a6 <MPSL_IRQ_CLOCK_Handler+0xb2>
    459c:	2003      	movs	r0, #3
    459e:	72a0      	strb	r0, [r4, #10]
    45a0:	2001      	movs	r0, #1
    45a2:	f8c5 0304 	str.w	r0, [r5, #772]	; 0x304
    45a6:	2000      	movs	r0, #0
    45a8:	71e0      	strb	r0, [r4, #7]
    45aa:	bd70      	pop	{r4, r5, r6, pc}
    45ac:	20000054 	.word	0x20000054
    45b0:	b570      	push	{r4, r5, r6, lr}
    45b2:	4c12      	ldr	r4, [pc, #72]	; (45fc <MPSL_IRQ_CLOCK_Handler+0x108>)
    45b4:	79a0      	ldrb	r0, [r4, #6]
    45b6:	b1e0      	cbz	r0, 45f2 <MPSL_IRQ_CLOCK_Handler+0xfe>
    45b8:	79e1      	ldrb	r1, [r4, #7]
    45ba:	1e40      	subs	r0, r0, #1
    45bc:	4281      	cmp	r1, r0
    45be:	da18      	bge.n	45f2 <MPSL_IRQ_CLOCK_Handler+0xfe>
    45c0:	f000 fa80 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    45c4:	4605      	mov	r5, r0
    45c6:	f000 fb69 	bl	4c9c <mpsl_temperature_get>
    45ca:	79a1      	ldrb	r1, [r4, #6]
    45cc:	2901      	cmp	r1, #1
    45ce:	d902      	bls.n	45d6 <MPSL_IRQ_CLOCK_Handler+0xe2>
    45d0:	79e1      	ldrb	r1, [r4, #7]
    45d2:	1c49      	adds	r1, r1, #1
    45d4:	71e1      	strb	r1, [r4, #7]
    45d6:	b10d      	cbz	r5, 45dc <MPSL_IRQ_CLOCK_Handler+0xe8>
    45d8:	6961      	ldr	r1, [r4, #20]
    45da:	e000      	b.n	45de <MPSL_IRQ_CLOCK_Handler+0xea>
    45dc:	6921      	ldr	r1, [r4, #16]
    45de:	1a41      	subs	r1, r0, r1
    45e0:	2902      	cmp	r1, #2
    45e2:	da02      	bge.n	45ea <MPSL_IRQ_CLOCK_Handler+0xf6>
    45e4:	f111 0f02 	cmn.w	r1, #2
    45e8:	dc07      	bgt.n	45fa <MPSL_IRQ_CLOCK_Handler+0x106>
    45ea:	b10d      	cbz	r5, 45f0 <MPSL_IRQ_CLOCK_Handler+0xfc>
    45ec:	6160      	str	r0, [r4, #20]
    45ee:	e000      	b.n	45f2 <MPSL_IRQ_CLOCK_Handler+0xfe>
    45f0:	6120      	str	r0, [r4, #16]
    45f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    45f6:	f7ff bfc1 	b.w	457c <MPSL_IRQ_CLOCK_Handler+0x88>
    45fa:	bd70      	pop	{r4, r5, r6, pc}
    45fc:	20000054 	.word	0x20000054
    4600:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4604:	4606      	mov	r6, r0
    4606:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    460a:	f44f 7186 	mov.w	r1, #268	; 0x10c
    460e:	4628      	mov	r0, r5
    4610:	f008 fbd9 	bl	cdc6 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x48>
    4614:	4680      	mov	r8, r0
    4616:	f44f 7188 	mov.w	r1, #272	; 0x110
    461a:	4628      	mov	r0, r5
    461c:	f008 fbd3 	bl	cdc6 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x48>
    4620:	4c27      	ldr	r4, [pc, #156]	; (46c0 <MPSL_IRQ_CLOCK_Handler+0x1cc>)
    4622:	4682      	mov	sl, r0
    4624:	7827      	ldrb	r7, [r4, #0]
    4626:	f104 0008 	add.w	r0, r4, #8
    462a:	f008 fc40 	bl	ceae <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA>
    462e:	b110      	cbz	r0, 4636 <MPSL_IRQ_CLOCK_Handler+0x142>
    4630:	f240 11b9 	movw	r1, #441	; 0x1b9
    4634:	e016      	b.n	4664 <MPSL_IRQ_CLOCK_Handler+0x170>
    4636:	f04f 0901 	mov.w	r9, #1
    463a:	b146      	cbz	r6, 464e <MPSL_IRQ_CLOCK_Handler+0x15a>
    463c:	7aa0      	ldrb	r0, [r4, #10]
    463e:	2803      	cmp	r0, #3
    4640:	d105      	bne.n	464e <MPSL_IRQ_CLOCK_Handler+0x15a>
    4642:	2004      	movs	r0, #4
    4644:	72a0      	strb	r0, [r4, #10]
    4646:	f7ff ff87 	bl	4558 <MPSL_IRQ_CLOCK_Handler+0x64>
    464a:	f8c5 9010 	str.w	r9, [r5, #16]
    464e:	2600      	movs	r6, #0
    4650:	f1b8 0f00 	cmp.w	r8, #0
    4654:	d018      	beq.n	4688 <MPSL_IRQ_CLOCK_Handler+0x194>
    4656:	f8c5 610c 	str.w	r6, [r5, #268]	; 0x10c
    465a:	7aa0      	ldrb	r0, [r4, #10]
    465c:	2804      	cmp	r0, #4
    465e:	d004      	beq.n	466a <MPSL_IRQ_CLOCK_Handler+0x176>
    4660:	f240 11cb 	movw	r1, #459	; 0x1cb
    4664:	206d      	movs	r0, #109	; 0x6d
    4666:	f000 faa5 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    466a:	f008 fc56 	bl	cf1a <sym_NQG4U7UYIQILZLC5ENYCA4NQMQM6PBAZC345PPA>
    466e:	b928      	cbnz	r0, 467c <MPSL_IRQ_CLOCK_Handler+0x188>
    4670:	f008 fc74 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    4674:	b910      	cbnz	r0, 467c <MPSL_IRQ_CLOCK_Handler+0x188>
    4676:	f008 fca7 	bl	cfc8 <sym_USR4MDT6VMTQLOGKNN4MALBZ3GJPD2KOEY4HFAQ>
    467a:	b108      	cbz	r0, 4680 <MPSL_IRQ_CLOCK_Handler+0x18c>
    467c:	4811      	ldr	r0, [pc, #68]	; (46c4 <MPSL_IRQ_CLOCK_Handler+0x1d0>)
    467e:	6006      	str	r6, [r0, #0]
    4680:	2002      	movs	r0, #2
    4682:	72a0      	strb	r0, [r4, #10]
    4684:	f000 f8f2 	bl	486c <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ>
    4688:	f1ba 0f00 	cmp.w	sl, #0
    468c:	d008      	beq.n	46a0 <MPSL_IRQ_CLOCK_Handler+0x1ac>
    468e:	f8c5 6110 	str.w	r6, [r5, #272]	; 0x110
    4692:	7aa0      	ldrb	r0, [r4, #10]
    4694:	2802      	cmp	r0, #2
    4696:	d101      	bne.n	469c <MPSL_IRQ_CLOCK_Handler+0x1a8>
    4698:	f7ff ff8a 	bl	45b0 <MPSL_IRQ_CLOCK_Handler+0xbc>
    469c:	f8c5 9014 	str.w	r9, [r5, #20]
    46a0:	b13f      	cbz	r7, 46b2 <MPSL_IRQ_CLOCK_Handler+0x1be>
    46a2:	7026      	strb	r6, [r4, #0]
    46a4:	7aa0      	ldrb	r0, [r4, #10]
    46a6:	2802      	cmp	r0, #2
    46a8:	d101      	bne.n	46ae <MPSL_IRQ_CLOCK_Handler+0x1ba>
    46aa:	f7ff ff67 	bl	457c <MPSL_IRQ_CLOCK_Handler+0x88>
    46ae:	f000 f8dd 	bl	486c <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ>
    46b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    46b6:	4802      	ldr	r0, [pc, #8]	; (46c0 <MPSL_IRQ_CLOCK_Handler+0x1cc>)
    46b8:	3008      	adds	r0, #8
    46ba:	f008 bc0f 	b.w	cedc <sym_OWJYSTADR5I36MIHWNPICVB7CMCWNSFIZPFXQ2Q>
    46be:	0000      	.short	0x0000
    46c0:	20000054 	.word	0x20000054
    46c4:	40000c34 	.word	0x40000c34
    46c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    46cc:	4c5f      	ldr	r4, [pc, #380]	; (484c <MPSL_IRQ_CLOCK_Handler+0x358>)
    46ce:	2700      	movs	r7, #0
    46d0:	4606      	mov	r6, r0
    46d2:	61a7      	str	r7, [r4, #24]
    46d4:	7842      	ldrb	r2, [r0, #1]
    46d6:	7881      	ldrb	r1, [r0, #2]
    46d8:	7800      	ldrb	r0, [r0, #0]
    46da:	72e0      	strb	r0, [r4, #11]
    46dc:	7162      	strb	r2, [r4, #5]
    46de:	71a1      	strb	r1, [r4, #6]
    46e0:	71e7      	strb	r7, [r4, #7]
    46e2:	f04f 0801 	mov.w	r8, #1
    46e6:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    46ea:	2805      	cmp	r0, #5
    46ec:	d225      	bcs.n	473a <MPSL_IRQ_CLOCK_Handler+0x246>
    46ee:	e8df f000 	tbb	[pc, r0]
    46f2:	0310      	.short	0x0310
    46f4:	00222006 	.word	0x00222006
    46f8:	f8c4 8018 	str.w	r8, [r4, #24]
    46fc:	e009      	b.n	4712 <MPSL_IRQ_CLOCK_Handler+0x21e>
    46fe:	f000 f8d1 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    4702:	2101      	movs	r1, #1
    4704:	4628      	mov	r0, r5
    4706:	f008 fb63 	bl	cdd0 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x52>
    470a:	2800      	cmp	r0, #0
    470c:	d0f9      	beq.n	4702 <MPSL_IRQ_CLOCK_Handler+0x20e>
    470e:	2002      	movs	r0, #2
    4710:	61a0      	str	r0, [r4, #24]
    4712:	f008 fb89 	bl	ce28 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA>
    4716:	b1b0      	cbz	r0, 4746 <MPSL_IRQ_CLOCK_Handler+0x252>
    4718:	f000 f9ee 	bl	4af8 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI>
    471c:	7e21      	ldrb	r1, [r4, #24]
    471e:	f001 0103 	and.w	r1, r1, #3
    4722:	4288      	cmp	r0, r1
    4724:	d10f      	bne.n	4746 <MPSL_IRQ_CLOCK_Handler+0x252>
    4726:	79b0      	ldrb	r0, [r6, #6]
    4728:	b150      	cbz	r0, 4740 <MPSL_IRQ_CLOCK_Handler+0x24c>
    472a:	2002      	movs	r0, #2
    472c:	f8c5 0304 	str.w	r0, [r5, #772]	; 0x304
    4730:	e070      	b.n	4814 <MPSL_IRQ_CLOCK_Handler+0x320>
    4732:	4847      	ldr	r0, [pc, #284]	; (4850 <MPSL_IRQ_CLOCK_Handler+0x35c>)
    4734:	e7ec      	b.n	4710 <MPSL_IRQ_CLOCK_Handler+0x21c>
    4736:	4847      	ldr	r0, [pc, #284]	; (4854 <MPSL_IRQ_CLOCK_Handler+0x360>)
    4738:	e7ea      	b.n	4710 <MPSL_IRQ_CLOCK_Handler+0x21c>
    473a:	f240 313a 	movw	r1, #826	; 0x33a
    473e:	e04d      	b.n	47dc <MPSL_IRQ_CLOCK_Handler+0x2e8>
    4740:	f000 f9ae 	bl	4aa0 <sym_4PX37LW4KIUYQZ73JWLPH5GAGIRWAKTV3E6F62Q>
    4744:	e066      	b.n	4814 <MPSL_IRQ_CLOCK_Handler+0x320>
    4746:	f8c5 800c 	str.w	r8, [r5, #12]
    474a:	f44f 7a82 	mov.w	sl, #260	; 0x104
    474e:	f8c5 7104 	str.w	r7, [r5, #260]	; 0x104
    4752:	69a0      	ldr	r0, [r4, #24]
    4754:	f8c5 0518 	str.w	r0, [r5, #1304]	; 0x518
    4758:	f008 fbcb 	bl	cef2 <sym_BN6ZO2NBHRGKZ2NRQYWFBXVGKNG6Y5K55UNAWGA>
    475c:	b940      	cbnz	r0, 4770 <MPSL_IRQ_CLOCK_Handler+0x27c>
    475e:	f008 fbd2 	bl	cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>
    4762:	b928      	cbnz	r0, 4770 <MPSL_IRQ_CLOCK_Handler+0x27c>
    4764:	f008 fbe6 	bl	cf34 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q>
    4768:	b910      	cbnz	r0, 4770 <MPSL_IRQ_CLOCK_Handler+0x27c>
    476a:	f008 fbf7 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    476e:	b138      	cbz	r0, 4780 <MPSL_IRQ_CLOCK_Handler+0x28c>
    4770:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    4774:	f8d0 0244 	ldr.w	r0, [r0, #580]	; 0x244
    4778:	4937      	ldr	r1, [pc, #220]	; (4858 <MPSL_IRQ_CLOCK_Handler+0x364>)
    477a:	f3c0 3042 	ubfx	r0, r0, #13, #3
    477e:	6008      	str	r0, [r1, #0]
    4780:	f008 fbb7 	bl	cef2 <sym_BN6ZO2NBHRGKZ2NRQYWFBXVGKNG6Y5K55UNAWGA>
    4784:	b940      	cbnz	r0, 4798 <MPSL_IRQ_CLOCK_Handler+0x2a4>
    4786:	f008 fbbe 	bl	cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>
    478a:	b928      	cbnz	r0, 4798 <MPSL_IRQ_CLOCK_Handler+0x2a4>
    478c:	f008 fbd2 	bl	cf34 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q>
    4790:	b910      	cbnz	r0, 4798 <MPSL_IRQ_CLOCK_Handler+0x2a4>
    4792:	f008 fbe3 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    4796:	b118      	cbz	r0, 47a0 <MPSL_IRQ_CLOCK_Handler+0x2ac>
    4798:	492f      	ldr	r1, [pc, #188]	; (4858 <MPSL_IRQ_CLOCK_Handler+0x364>)
    479a:	3110      	adds	r1, #16
    479c:	f8c1 8000 	str.w	r8, [r1]
    47a0:	f8c5 8008 	str.w	r8, [r5, #8]
    47a4:	2002      	movs	r0, #2
    47a6:	f8c5 0304 	str.w	r0, [r5, #772]	; 0x304
    47aa:	79b0      	ldrb	r0, [r6, #6]
    47ac:	bb90      	cbnz	r0, 4814 <MPSL_IRQ_CLOCK_Handler+0x320>
    47ae:	f8d5 0304 	ldr.w	r0, [r5, #772]	; 0x304
    47b2:	f010 0f02 	tst.w	r0, #2
    47b6:	d00f      	beq.n	47d8 <MPSL_IRQ_CLOCK_Handler+0x2e4>
    47b8:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 485c <MPSL_IRQ_CLOCK_Handler+0x368>
    47bc:	f8d9 1000 	ldr.w	r1, [r9]
    47c0:	43c9      	mvns	r1, r1
    47c2:	f341 1100 	sbfx	r1, r1, #4, #1
    47c6:	f101 0801 	add.w	r8, r1, #1
    47ca:	f8d9 1000 	ldr.w	r1, [r9]
    47ce:	f041 0110 	orr.w	r1, r1, #16
    47d2:	f8c9 1000 	str.w	r1, [r9]
    47d6:	e007      	b.n	47e8 <MPSL_IRQ_CLOCK_Handler+0x2f4>
    47d8:	f240 21fb 	movw	r1, #763	; 0x2fb
    47dc:	206d      	movs	r0, #109	; 0x6d
    47de:	f000 f9e9 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    47e2:	bf00      	nop
    47e4:	f000 fb10 	bl	4e08 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA>
    47e8:	4651      	mov	r1, sl
    47ea:	4628      	mov	r0, r5
    47ec:	f008 faeb 	bl	cdc6 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x48>
    47f0:	2800      	cmp	r0, #0
    47f2:	d0f7      	beq.n	47e4 <MPSL_IRQ_CLOCK_Handler+0x2f0>
    47f4:	f000 f954 	bl	4aa0 <sym_4PX37LW4KIUYQZ73JWLPH5GAGIRWAKTV3E6F62Q>
    47f8:	f1b8 0f00 	cmp.w	r8, #0
    47fc:	d105      	bne.n	480a <MPSL_IRQ_CLOCK_Handler+0x316>
    47fe:	f8d9 1000 	ldr.w	r1, [r9]
    4802:	f021 0110 	bic.w	r1, r1, #16
    4806:	f8c9 1000 	str.w	r1, [r9]
    480a:	2002      	movs	r0, #2
    480c:	f8c5 0308 	str.w	r0, [r5, #776]	; 0x308
    4810:	f8c5 7104 	str.w	r7, [r5, #260]	; 0x104
    4814:	79a0      	ldrb	r0, [r4, #6]
    4816:	b170      	cbz	r0, 4836 <MPSL_IRQ_CLOCK_Handler+0x342>
    4818:	7830      	ldrb	r0, [r6, #0]
    481a:	b960      	cbnz	r0, 4836 <MPSL_IRQ_CLOCK_Handler+0x342>
    481c:	f000 f952 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    4820:	4606      	mov	r6, r0
    4822:	f000 fa3b 	bl	4c9c <mpsl_temperature_get>
    4826:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    482a:	b116      	cbz	r6, 4832 <MPSL_IRQ_CLOCK_Handler+0x33e>
    482c:	e9c4 1004 	strd	r1, r0, [r4, #16]
    4830:	e001      	b.n	4836 <MPSL_IRQ_CLOCK_Handler+0x342>
    4832:	e9c4 0104 	strd	r0, r1, [r4, #16]
    4836:	2101      	movs	r1, #1
    4838:	4628      	mov	r0, r5
    483a:	f008 fac9 	bl	cdd0 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x52>
    483e:	b108      	cbz	r0, 4844 <MPSL_IRQ_CLOCK_Handler+0x350>
    4840:	f000 f93a 	bl	4ab8 <sym_PIRI3CTIHOPR5MPDQRHBJRRZEA2NVOD4J3GXGOA>
    4844:	72a7      	strb	r7, [r4, #10]
    4846:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    484a:	0000      	.short	0x0000
    484c:	20000054 	.word	0x20000054
    4850:	00020001 	.word	0x00020001
    4854:	00030001 	.word	0x00030001
    4858:	4000053c 	.word	0x4000053c
    485c:	e000ed10 	.word	0xe000ed10

00004860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>:
    4860:	4801      	ldr	r0, [pc, #4]	; (4868 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q+0x8>)
    4862:	89c0      	ldrh	r0, [r0, #14]
    4864:	4770      	bx	lr
    4866:	0000      	.short	0x0000
    4868:	20000054 	.word	0x20000054

0000486c <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ>:
    486c:	b510      	push	{r4, lr}
    486e:	f3ef 8410 	mrs	r4, PRIMASK
    4872:	b672      	cpsid	i
    4874:	480a      	ldr	r0, [pc, #40]	; (48a0 <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ+0x34>)
    4876:	7841      	ldrb	r1, [r0, #1]
    4878:	b129      	cbz	r1, 4886 <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ+0x1a>
    487a:	7841      	ldrb	r1, [r0, #1]
    487c:	1e49      	subs	r1, r1, #1
    487e:	7041      	strb	r1, [r0, #1]
    4880:	7841      	ldrb	r1, [r0, #1]
    4882:	b129      	cbz	r1, 4890 <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ+0x24>
    4884:	e008      	b.n	4898 <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ+0x2c>
    4886:	f44f 718e 	mov.w	r1, #284	; 0x11c
    488a:	206d      	movs	r0, #109	; 0x6d
    488c:	f000 f992 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    4890:	7880      	ldrb	r0, [r0, #2]
    4892:	b908      	cbnz	r0, 4898 <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ+0x2c>
    4894:	f000 f924 	bl	4ae0 <sym_XK3TMLCZALCYYWGULGHQIRSOBMPIIPJ7HEMOZIQ>
    4898:	2c00      	cmp	r4, #0
    489a:	d100      	bne.n	489e <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ+0x32>
    489c:	b662      	cpsie	i
    489e:	bd10      	pop	{r4, pc}
    48a0:	20000054 	.word	0x20000054

000048a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>:
    48a4:	b510      	push	{r4, lr}
    48a6:	f3ef 8410 	mrs	r4, PRIMASK
    48aa:	b672      	cpsid	i
    48ac:	4806      	ldr	r0, [pc, #24]	; (48c8 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ+0x24>)
    48ae:	7841      	ldrb	r1, [r0, #1]
    48b0:	1c49      	adds	r1, r1, #1
    48b2:	7041      	strb	r1, [r0, #1]
    48b4:	7840      	ldrb	r0, [r0, #1]
    48b6:	2801      	cmp	r0, #1
    48b8:	d101      	bne.n	48be <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ+0x1a>
    48ba:	f008 faa0 	bl	cdfe <sym_IFJHPQV3B4EIN6OIUP3LZSPJBF5HLX2VYD323GA>
    48be:	2c00      	cmp	r4, #0
    48c0:	d100      	bne.n	48c4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ+0x20>
    48c2:	b662      	cpsie	i
    48c4:	bd10      	pop	{r4, pc}
    48c6:	0000      	.short	0x0000
    48c8:	20000054 	.word	0x20000054

000048cc <mpsl_clock_hfclk_release>:
    48cc:	4805      	ldr	r0, [pc, #20]	; (48e4 <mpsl_clock_hfclk_release+0x18>)
    48ce:	b510      	push	{r4, lr}
    48d0:	78c1      	ldrb	r1, [r0, #3]
    48d2:	b121      	cbz	r1, 48de <mpsl_clock_hfclk_release+0x12>
    48d4:	2100      	movs	r1, #0
    48d6:	7101      	strb	r1, [r0, #4]
    48d8:	70c1      	strb	r1, [r0, #3]
    48da:	f7ff ffc7 	bl	486c <sym_AF5XKA2WT4DMFZTLKHOBWE7E2EZAMLDDFPQGGTQ>
    48de:	2000      	movs	r0, #0
    48e0:	bd10      	pop	{r4, pc}
    48e2:	0000      	.short	0x0000
    48e4:	20000054 	.word	0x20000054

000048e8 <mpsl_clock_hfclk_request>:
    48e8:	b570      	push	{r4, r5, r6, lr}
    48ea:	4c0c      	ldr	r4, [pc, #48]	; (491c <mpsl_clock_hfclk_request+0x34>)
    48ec:	78e1      	ldrb	r1, [r4, #3]
    48ee:	b961      	cbnz	r1, 490a <mpsl_clock_hfclk_request+0x22>
    48f0:	2501      	movs	r5, #1
    48f2:	70e5      	strb	r5, [r4, #3]
    48f4:	61e0      	str	r0, [r4, #28]
    48f6:	f7ff ffd5 	bl	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    48fa:	f000 f8e3 	bl	4ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>
    48fe:	b130      	cbz	r0, 490e <mpsl_clock_hfclk_request+0x26>
    4900:	69e0      	ldr	r0, [r4, #28]
    4902:	b110      	cbz	r0, 490a <mpsl_clock_hfclk_request+0x22>
    4904:	4780      	blx	r0
    4906:	2000      	movs	r0, #0
    4908:	61e0      	str	r0, [r4, #28]
    490a:	2000      	movs	r0, #0
    490c:	bd70      	pop	{r4, r5, r6, pc}
    490e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    4912:	7125      	strb	r5, [r4, #4]
    4914:	f8c0 5304 	str.w	r5, [r0, #772]	; 0x304
    4918:	e7f7      	b.n	490a <mpsl_clock_hfclk_request+0x22>
    491a:	0000      	.short	0x0000
    491c:	20000054 	.word	0x20000054

00004920 <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I>:
    4920:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4924:	0005      	movs	r5, r0
    4926:	f06f 0015 	mvn.w	r0, #21
    492a:	d03f      	beq.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    492c:	7829      	ldrb	r1, [r5, #0]
    492e:	2904      	cmp	r1, #4
    4930:	d83c      	bhi.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    4932:	2900      	cmp	r1, #0
    4934:	7869      	ldrb	r1, [r5, #1]
    4936:	d03b      	beq.n	49b0 <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x90>
    4938:	2900      	cmp	r1, #0
    493a:	d137      	bne.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    493c:	78a9      	ldrb	r1, [r5, #2]
    493e:	2900      	cmp	r1, #0
    4940:	d134      	bne.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    4942:	2000      	movs	r0, #0
    4944:	f008 fa0a 	bl	cd5c <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI+0x34>
    4948:	2000      	movs	r0, #0
    494a:	f008 f9fa 	bl	cd42 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI+0x1a>
    494e:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
    4952:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4956:	f8c8 1308 	str.w	r1, [r8, #776]	; 0x308
    495a:	2600      	movs	r6, #0
    495c:	f8c8 6100 	str.w	r6, [r8, #256]	; 0x100
    4960:	f8c8 6104 	str.w	r6, [r8, #260]	; 0x104
    4964:	f8c8 610c 	str.w	r6, [r8, #268]	; 0x10c
    4968:	f8c8 6110 	str.w	r6, [r8, #272]	; 0x110
    496c:	4c14      	ldr	r4, [pc, #80]	; (49c0 <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0xa0>)
    496e:	7066      	strb	r6, [r4, #1]
    4970:	88a8      	ldrh	r0, [r5, #4]
    4972:	81a0      	strh	r0, [r4, #12]
    4974:	f008 fa3a 	bl	cdec <sym_TIWHB6UQGI33JQCQDL7C2BRAEXCRAFYENVN6QEI>
    4978:	2701      	movs	r7, #1
    497a:	b108      	cbz	r0, 4980 <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x60>
    497c:	70e7      	strb	r7, [r4, #3]
    497e:	7067      	strb	r7, [r4, #1]
    4980:	2101      	movs	r1, #1
    4982:	4640      	mov	r0, r8
    4984:	f008 fa24 	bl	cdd0 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x52>
    4988:	b108      	cbz	r0, 498e <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x6e>
    498a:	f000 f895 	bl	4ab8 <sym_PIRI3CTIHOPR5MPDQRHBJRRZEA2NVOD4J3GXGOA>
    498e:	f240 50f5 	movw	r0, #1525	; 0x5f5
    4992:	81e0      	strh	r0, [r4, #14]
    4994:	4628      	mov	r0, r5
    4996:	f7ff fe97 	bl	46c8 <MPSL_IRQ_CLOCK_Handler+0x1d4>
    499a:	7267      	strb	r7, [r4, #9]
    499c:	2000      	movs	r0, #0
    499e:	f008 f9d0 	bl	cd42 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI+0x1a>
    49a2:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    49a6:	4630      	mov	r0, r6
    49a8:	f8c1 7100 	str.w	r7, [r1, #256]	; 0x100
    49ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    49b0:	2900      	cmp	r1, #0
    49b2:	d0fb      	beq.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    49b4:	2920      	cmp	r1, #32
    49b6:	d8f9      	bhi.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    49b8:	78a9      	ldrb	r1, [r5, #2]
    49ba:	2921      	cmp	r1, #33	; 0x21
    49bc:	d9c1      	bls.n	4942 <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x22>
    49be:	e7f5      	b.n	49ac <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I+0x8c>
    49c0:	20000054 	.word	0x20000054

000049c4 <sym_ETIE3PCEXQYLK2GIVZENQ6V7PLBRV57MB7BDMNY>:
    49c4:	4801      	ldr	r0, [pc, #4]	; (49cc <sym_ETIE3PCEXQYLK2GIVZENQ6V7PLBRV57MB7BDMNY+0x8>)
    49c6:	8980      	ldrh	r0, [r0, #12]
    49c8:	4770      	bx	lr
    49ca:	0000      	.short	0x0000
    49cc:	20000054 	.word	0x20000054

000049d0 <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA>:
    49d0:	b510      	push	{r4, lr}
    49d2:	480d      	ldr	r0, [pc, #52]	; (4a08 <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA+0x38>)
    49d4:	f008 fa6b 	bl	ceae <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA>
    49d8:	490b      	ldr	r1, [pc, #44]	; (4a08 <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA+0x38>)
    49da:	3908      	subs	r1, #8
    49dc:	b148      	cbz	r0, 49f2 <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA+0x22>
    49de:	2001      	movs	r0, #1
    49e0:	7008      	strb	r0, [r1, #0]
    49e2:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    49e6:	f8c1 0200 	str.w	r0, [r1, #512]	; 0x200
    49ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    49ee:	f7ff bf59 	b.w	48a4 <sym_PEUB6CZG5CWXXD4M2S6OVBXZGDFOG4XII7USUDQ>
    49f2:	7a88      	ldrb	r0, [r1, #10]
    49f4:	2802      	cmp	r0, #2
    49f6:	d101      	bne.n	49fc <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA+0x2c>
    49f8:	f7ff fdc0 	bl	457c <MPSL_IRQ_CLOCK_Handler+0x88>
    49fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4a00:	4801      	ldr	r0, [pc, #4]	; (4a08 <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA+0x38>)
    4a02:	f008 ba6b 	b.w	cedc <sym_OWJYSTADR5I36MIHWNPICVB7CMCWNSFIZPFXQ2Q>
    4a06:	0000      	.short	0x0000
    4a08:	2000005c 	.word	0x2000005c

00004a0c <sym_4CZSFTTT34WDYFZKE2NSCSVSYLPHLZYN7QUTGHY>:
    4a0c:	4802      	ldr	r0, [pc, #8]	; (4a18 <sym_4CZSFTTT34WDYFZKE2NSCSVSYLPHLZYN7QUTGHY+0xc>)
    4a0e:	7a80      	ldrb	r0, [r0, #10]
    4a10:	2800      	cmp	r0, #0
    4a12:	d000      	beq.n	4a16 <sym_4CZSFTTT34WDYFZKE2NSCSVSYLPHLZYN7QUTGHY+0xa>
    4a14:	2001      	movs	r0, #1
    4a16:	4770      	bx	lr
    4a18:	20000054 	.word	0x20000054

00004a1c <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q>:
    4a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4a1e:	4d1f      	ldr	r5, [pc, #124]	; (4a9c <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x80>)
    4a20:	7ae8      	ldrb	r0, [r5, #11]
    4a22:	2800      	cmp	r0, #0
    4a24:	d10f      	bne.n	4a46 <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x2a>
    4a26:	7e28      	ldrb	r0, [r5, #24]
    4a28:	f000 0003 	and.w	r0, r0, #3
    4a2c:	f008 f9ec 	bl	ce08 <sym_LZEJCP3HZIBKMJQC47UQXAHGCQ52QF47EXOH2WA>
    4a30:	2800      	cmp	r0, #0
    4a32:	d008      	beq.n	4a46 <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x2a>
    4a34:	f3ef 8110 	mrs	r1, PRIMASK
    4a38:	b672      	cpsid	i
    4a3a:	f7ff ffe7 	bl	4a0c <sym_4CZSFTTT34WDYFZKE2NSCSVSYLPHLZYN7QUTGHY>
    4a3e:	b118      	cbz	r0, 4a48 <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x2c>
    4a40:	2900      	cmp	r1, #0
    4a42:	d100      	bne.n	4a46 <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x2a>
    4a44:	b662      	cpsie	i
    4a46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4a48:	2601      	movs	r6, #1
    4a4a:	72ae      	strb	r6, [r5, #10]
    4a4c:	b901      	cbnz	r1, 4a50 <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x34>
    4a4e:	b662      	cpsie	i
    4a50:	2018      	movs	r0, #24
    4a52:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    4a56:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    4a5a:	61a6      	str	r6, [r4, #24]
    4a5c:	f44f 7020 	mov.w	r0, #640	; 0x280
    4a60:	f8ad 0000 	strh.w	r0, [sp]
    4a64:	f8bd 0000 	ldrh.w	r0, [sp]
    4a68:	1e41      	subs	r1, r0, #1
    4a6a:	f8ad 1000 	strh.w	r1, [sp]
    4a6e:	d2f9      	bcs.n	4a64 <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x48>
    4a70:	2700      	movs	r7, #0
    4a72:	f8c4 710c 	str.w	r7, [r4, #268]	; 0x10c
    4a76:	f8c4 7110 	str.w	r7, [r4, #272]	; 0x110
    4a7a:	4808      	ldr	r0, [pc, #32]	; (4a9c <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q+0x80>)
    4a7c:	3008      	adds	r0, #8
    4a7e:	f008 fa29 	bl	ced4 <sym_YS3AHD7GWBHZEQHPIQANPGALEXB4QGY5O2DQKRY>
    4a82:	702f      	strb	r7, [r5, #0]
    4a84:	f7ff fd7a 	bl	457c <MPSL_IRQ_CLOCK_Handler+0x88>
    4a88:	6166      	str	r6, [r4, #20]
    4a8a:	7968      	ldrb	r0, [r5, #5]
    4a8c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    4a90:	f8c4 0538 	str.w	r0, [r4, #1336]	; 0x538
    4a94:	2018      	movs	r0, #24
    4a96:	f8c4 0304 	str.w	r0, [r4, #772]	; 0x304
    4a9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4a9c:	20000054 	.word	0x20000054

00004aa0 <sym_4PX37LW4KIUYQZ73JWLPH5GAGIRWAKTV3E6F62Q>:
    4aa0:	b510      	push	{r4, lr}
    4aa2:	4c04      	ldr	r4, [pc, #16]	; (4ab4 <sym_4PX37LW4KIUYQZ73JWLPH5GAGIRWAKTV3E6F62Q+0x14>)
    4aa4:	7e20      	ldrb	r0, [r4, #24]
    4aa6:	f000 0003 	and.w	r0, r0, #3
    4aaa:	f008 f9ad 	bl	ce08 <sym_LZEJCP3HZIBKMJQC47UQXAHGCQ52QF47EXOH2WA>
    4aae:	2800      	cmp	r0, #0
    4ab0:	d0f8      	beq.n	4aa4 <sym_4PX37LW4KIUYQZ73JWLPH5GAGIRWAKTV3E6F62Q+0x4>
    4ab2:	bd10      	pop	{r4, pc}
    4ab4:	20000054 	.word	0x20000054

00004ab8 <sym_PIRI3CTIHOPR5MPDQRHBJRRZEA2NVOD4J3GXGOA>:
    4ab8:	4901      	ldr	r1, [pc, #4]	; (4ac0 <sym_PIRI3CTIHOPR5MPDQRHBJRRZEA2NVOD4J3GXGOA+0x8>)
    4aba:	2001      	movs	r0, #1
    4abc:	7008      	strb	r0, [r1, #0]
    4abe:	4770      	bx	lr
    4ac0:	20000325 	.word	0x20000325

00004ac4 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY>:
    4ac4:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    4ac8:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
    4acc:	b918      	cbnz	r0, 4ad6 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY+0x12>
    4ace:	4803      	ldr	r0, [pc, #12]	; (4adc <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY+0x18>)
    4ad0:	7800      	ldrb	r0, [r0, #0]
    4ad2:	2800      	cmp	r0, #0
    4ad4:	d000      	beq.n	4ad8 <sym_LIY23QT3GHIV7NCGJ6ZW6LB2ZUSI56CIFCL6HUY+0x14>
    4ad6:	2001      	movs	r0, #1
    4ad8:	4770      	bx	lr
    4ada:	0000      	.short	0x0000
    4adc:	20000325 	.word	0x20000325

00004ae0 <sym_XK3TMLCZALCYYWGULGHQIRSOBMPIIPJ7HEMOZIQ>:
    4ae0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    4ae4:	2101      	movs	r1, #1
    4ae6:	6041      	str	r1, [r0, #4]
    4ae8:	2100      	movs	r1, #0
    4aea:	f8c0 1100 	str.w	r1, [r0, #256]	; 0x100
    4aee:	4801      	ldr	r0, [pc, #4]	; (4af4 <sym_XK3TMLCZALCYYWGULGHQIRSOBMPIIPJ7HEMOZIQ+0x14>)
    4af0:	7001      	strb	r1, [r0, #0]
    4af2:	4770      	bx	lr
    4af4:	20000325 	.word	0x20000325

00004af8 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI>:
    4af8:	4802      	ldr	r0, [pc, #8]	; (4b04 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0xc>)
    4afa:	6800      	ldr	r0, [r0, #0]
    4afc:	f000 0003 	and.w	r0, r0, #3
    4b00:	4770      	bx	lr
    4b02:	0000      	.short	0x0000
    4b04:	4000041c 	.word	0x4000041c
    4b08:	b510      	push	{r4, lr}
    4b0a:	b131      	cbz	r1, 4b1a <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x22>
    4b0c:	2901      	cmp	r1, #1
    4b0e:	d007      	beq.n	4b20 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x28>
    4b10:	f240 3102 	movw	r1, #770	; 0x302
    4b14:	a005      	add	r0, pc, #20	; (adr r0, 4b2c <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x34>)
    4b16:	f000 f821 	bl	4b5c <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI>
    4b1a:	f8d0 0414 	ldr.w	r0, [r0, #1044]	; 0x414
    4b1e:	e001      	b.n	4b24 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x2c>
    4b20:	f8d0 0408 	ldr.w	r0, [r0, #1032]	; 0x408
    4b24:	f000 0001 	and.w	r0, r0, #1
    4b28:	bd10      	pop	{r4, pc}
    4b2a:	0000      	.short	0x0000
    4b2c:	5f66726e 	.word	0x5f66726e
    4b30:	636f6c63 	.word	0x636f6c63
    4b34:	00682e6b 	.word	0x00682e6b
    4b38:	f3bf 8f4f 	dsb	sy
    4b3c:	4805      	ldr	r0, [pc, #20]	; (4b54 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x5c>)
    4b3e:	6801      	ldr	r1, [r0, #0]
    4b40:	4a05      	ldr	r2, [pc, #20]	; (4b58 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x60>)
    4b42:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
    4b46:	4311      	orrs	r1, r2
    4b48:	6001      	str	r1, [r0, #0]
    4b4a:	f3bf 8f4f 	dsb	sy
    4b4e:	bf00      	nop
    4b50:	e7fd      	b.n	4b4e <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x56>
    4b52:	0000      	.short	0x0000
    4b54:	e000ed0c 	.word	0xe000ed0c
    4b58:	05fa0004 	.word	0x05fa0004

00004b5c <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI>:
    4b5c:	b672      	cpsid	i
    4b5e:	4a03      	ldr	r2, [pc, #12]	; (4b6c <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI+0x10>)
    4b60:	6852      	ldr	r2, [r2, #4]
    4b62:	b102      	cbz	r2, 4b66 <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI+0xa>
    4b64:	4790      	blx	r2
    4b66:	f7ff ffe7 	bl	4b38 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x40>
    4b6a:	0000      	.short	0x0000
    4b6c:	20000074 	.word	0x20000074
    4b70:	4806      	ldr	r0, [pc, #24]	; (4b8c <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI+0x30>)
    4b72:	b510      	push	{r4, lr}
    4b74:	2100      	movs	r1, #0
    4b76:	6001      	str	r1, [r0, #0]
    4b78:	2101      	movs	r1, #1
    4b7a:	6001      	str	r1, [r0, #0]
    4b7c:	4608      	mov	r0, r1
    4b7e:	f008 f96a 	bl	ce56 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x2e>
    4b82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4b86:	2001      	movs	r0, #1
    4b88:	f008 b958 	b.w	ce3c <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x14>
    4b8c:	40001ffc 	.word	0x40001ffc
    4b90:	4807      	ldr	r0, [pc, #28]	; (4bb0 <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI+0x54>)
    4b92:	b510      	push	{r4, lr}
    4b94:	2101      	movs	r1, #1
    4b96:	6041      	str	r1, [r0, #4]
    4b98:	1e89      	subs	r1, r1, #2
    4b9a:	f8c0 1308 	str.w	r1, [r0, #776]	; 0x308
    4b9e:	200c      	movs	r0, #12
    4ba0:	f008 f959 	bl	ce56 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x2e>
    4ba4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4ba8:	200c      	movs	r0, #12
    4baa:	f008 b947 	b.w	ce3c <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x14>
    4bae:	0000      	.short	0x0000
    4bb0:	4000c000 	.word	0x4000c000

00004bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>:
    4bb4:	b50e      	push	{r1, r2, r3, lr}
    4bb6:	b672      	cpsid	i
    4bb8:	4a0f      	ldr	r2, [pc, #60]	; (4bf8 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q+0x44>)
    4bba:	6855      	ldr	r5, [r2, #4]
    4bbc:	b1d5      	cbz	r5, 4bf4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q+0x40>
    4bbe:	2200      	movs	r2, #0
    4bc0:	4603      	mov	r3, r0
    4bc2:	466e      	mov	r6, sp
    4bc4:	240a      	movs	r4, #10
    4bc6:	e003      	b.n	4bd0 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q+0x1c>
    4bc8:	fbb0 f0f4 	udiv	r0, r0, r4
    4bcc:	1c52      	adds	r2, r2, #1
    4bce:	b2d2      	uxtb	r2, r2
    4bd0:	2800      	cmp	r0, #0
    4bd2:	d1f9      	bne.n	4bc8 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q+0x14>
    4bd4:	54b0      	strb	r0, [r6, r2]
    4bd6:	e009      	b.n	4bec <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q+0x38>
    4bd8:	fbb3 f0f4 	udiv	r0, r3, r4
    4bdc:	fb04 3010 	mls	r0, r4, r0, r3
    4be0:	fbb3 f3f4 	udiv	r3, r3, r4
    4be4:	1e52      	subs	r2, r2, #1
    4be6:	b2d2      	uxtb	r2, r2
    4be8:	3030      	adds	r0, #48	; 0x30
    4bea:	54b0      	strb	r0, [r6, r2]
    4bec:	2a00      	cmp	r2, #0
    4bee:	d1f3      	bne.n	4bd8 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q+0x24>
    4bf0:	4630      	mov	r0, r6
    4bf2:	47a8      	blx	r5
    4bf4:	f7ff ffa0 	bl	4b38 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x40>
    4bf8:	20000074 	.word	0x20000074

00004bfc <mpsl_init>:
    4bfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4c00:	4c18      	ldr	r4, [pc, #96]	; (4c64 <mpsl_init+0x68>)
    4c02:	4606      	mov	r6, r0
    4c04:	4617      	mov	r7, r2
    4c06:	7860      	ldrb	r0, [r4, #1]
    4c08:	460d      	mov	r5, r1
    4c0a:	b118      	cbz	r0, 4c14 <mpsl_init+0x18>
    4c0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4c10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4c14:	f7fc fc8e 	bl	1534 <sym_JBMIQXYLJQQB56KLSIZ2WVKBMEMRZHLRBGLEPTA>
    4c18:	b906      	cbnz	r6, 4c1c <mpsl_init+0x20>
    4c1a:	4e13      	ldr	r6, [pc, #76]	; (4c68 <mpsl_init+0x6c>)
    4c1c:	6067      	str	r7, [r4, #4]
    4c1e:	7025      	strb	r5, [r4, #0]
    4c20:	f7ff ffa6 	bl	4b70 <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI+0x14>
    4c24:	f7ff ffb4 	bl	4b90 <sym_4JLKMM32SOXCP6XBYAWZDUIMUJIYXLKKDBOFLHI+0x34>
    4c28:	4630      	mov	r0, r6
    4c2a:	f7ff fe79 	bl	4920 <sym_FYHKZOVAJN6VDDHY43FT7PF4YLRDHWRTEWHFG6I>
    4c2e:	0006      	movs	r6, r0
    4c30:	d1ee      	bne.n	4c10 <mpsl_init+0x14>
    4c32:	f7fe fe77 	bl	3924 <sym_ZC6NJBPUISWILQK6OTOBMJVVUT63JRIDGH5WNCY>
    4c36:	f7ff fef1 	bl	4a1c <sym_A4JUKJUCTJV55V2WD6TXU63VO5GAMB4XA4EE56Q>
    4c3a:	f008 f851 	bl	cce0 <sym_47MBMNER75N2M6YIZRIF4DAHSAATJOMK3LAIDCY>
    4c3e:	4628      	mov	r0, r5
    4c40:	f008 f8fc 	bl	ce3c <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x14>
    4c44:	2001      	movs	r0, #1
    4c46:	2d00      	cmp	r5, #0
    4c48:	db09      	blt.n	4c5e <mpsl_init+0x62>
    4c4a:	f005 011f 	and.w	r1, r5, #31
    4c4e:	fa00 f101 	lsl.w	r1, r0, r1
    4c52:	096a      	lsrs	r2, r5, #5
    4c54:	0092      	lsls	r2, r2, #2
    4c56:	f102 22e0 	add.w	r2, r2, #3758153728	; 0xe000e000
    4c5a:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
    4c5e:	7060      	strb	r0, [r4, #1]
    4c60:	4630      	mov	r0, r6
    4c62:	e7d5      	b.n	4c10 <mpsl_init+0x14>
    4c64:	20000074 	.word	0x20000074
    4c68:	0000ce78 	.word	0x0000ce78

00004c6c <mpsl_is_initialized>:
    4c6c:	4801      	ldr	r0, [pc, #4]	; (4c74 <mpsl_is_initialized+0x8>)
    4c6e:	7840      	ldrb	r0, [r0, #1]
    4c70:	4770      	bx	lr
    4c72:	0000      	.short	0x0000
    4c74:	20000074 	.word	0x20000074

00004c78 <sym_XR32KBBIVYD5OVRJM2RBQ57EGCCM2C3F5IY6OHQ>:
    4c78:	4807      	ldr	r0, [pc, #28]	; (4c98 <sym_XR32KBBIVYD5OVRJM2RBQ57EGCCM2C3F5IY6OHQ+0x20>)
    4c7a:	f990 0000 	ldrsb.w	r0, [r0]
    4c7e:	2800      	cmp	r0, #0
    4c80:	db09      	blt.n	4c96 <sym_XR32KBBIVYD5OVRJM2RBQ57EGCCM2C3F5IY6OHQ+0x1e>
    4c82:	f000 021f 	and.w	r2, r0, #31
    4c86:	2101      	movs	r1, #1
    4c88:	4091      	lsls	r1, r2
    4c8a:	0940      	lsrs	r0, r0, #5
    4c8c:	0080      	lsls	r0, r0, #2
    4c8e:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    4c92:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
    4c96:	4770      	bx	lr
    4c98:	20000074 	.word	0x20000074

00004c9c <mpsl_temperature_get>:
    4c9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ca0:	2601      	movs	r6, #1
    4ca2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    4ca6:	0331      	lsls	r1, r6, #12
    4ca8:	f04f 0800 	mov.w	r8, #0
    4cac:	4640      	mov	r0, r8
    4cae:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    4cb2:	f3bf 8f4f 	dsb	sy
    4cb6:	f3bf 8f6f 	isb	sy
    4cba:	4c16      	ldr	r4, [pc, #88]	; (4d14 <mpsl_temperature_get+0x78>)
    4cbc:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
    4cc0:	200c      	movs	r0, #12
    4cc2:	f008 f8e7 	bl	ce94 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x6c>
    4cc6:	4d14      	ldr	r5, [pc, #80]	; (4d18 <mpsl_temperature_get+0x7c>)
    4cc8:	6828      	ldr	r0, [r5, #0]
    4cca:	43c0      	mvns	r0, r0
    4ccc:	f340 1700 	sbfx	r7, r0, #4, #1
    4cd0:	6828      	ldr	r0, [r5, #0]
    4cd2:	f040 0010 	orr.w	r0, r0, #16
    4cd6:	6028      	str	r0, [r5, #0]
    4cd8:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
    4cdc:	6026      	str	r6, [r4, #0]
    4cde:	1c7f      	adds	r7, r7, #1
    4ce0:	e002      	b.n	4ce8 <mpsl_temperature_get+0x4c>
    4ce2:	bf00      	nop
    4ce4:	f000 f890 	bl	4e08 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA>
    4ce8:	f8d4 0100 	ldr.w	r0, [r4, #256]	; 0x100
    4cec:	2800      	cmp	r0, #0
    4cee:	d0f9      	beq.n	4ce4 <mpsl_temperature_get+0x48>
    4cf0:	b91f      	cbnz	r7, 4cfa <mpsl_temperature_get+0x5e>
    4cf2:	6828      	ldr	r0, [r5, #0]
    4cf4:	f020 0010 	bic.w	r0, r0, #16
    4cf8:	6028      	str	r0, [r5, #0]
    4cfa:	4808      	ldr	r0, [pc, #32]	; (4d1c <mpsl_temperature_get+0x80>)
    4cfc:	6805      	ldr	r5, [r0, #0]
    4cfe:	6066      	str	r6, [r4, #4]
    4d00:	f8c4 6308 	str.w	r6, [r4, #776]	; 0x308
    4d04:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
    4d08:	200c      	movs	r0, #12
    4d0a:	f008 f8c3 	bl	ce94 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x6c>
    4d0e:	4628      	mov	r0, r5
    4d10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4d14:	4000c000 	.word	0x4000c000
    4d18:	e000ed10 	.word	0xe000ed10
    4d1c:	4000c508 	.word	0x4000c508

00004d20 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA>:
    4d20:	b510      	push	{r4, lr}
    4d22:	4602      	mov	r2, r0
    4d24:	2005      	movs	r0, #5
    4d26:	490c      	ldr	r1, [pc, #48]	; (4d58 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA+0x38>)
    4d28:	e004      	b.n	4d34 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA+0x14>
    4d2a:	bf00      	nop
    4d2c:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
    4d30:	791b      	ldrb	r3, [r3, #4]
    4d32:	b133      	cbz	r3, 4d42 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA+0x22>
    4d34:	1e40      	subs	r0, r0, #1
    4d36:	b2c0      	uxtb	r0, r0
    4d38:	d2f8      	bcs.n	4d2c <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA+0xc>
    4d3a:	2148      	movs	r1, #72	; 0x48
    4d3c:	2069      	movs	r0, #105	; 0x69
    4d3e:	f7ff ff39 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    4d42:	f841 2030 	str.w	r2, [r1, r0, lsl #3]
    4d46:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
    4d4a:	2200      	movs	r2, #0
    4d4c:	714a      	strb	r2, [r1, #5]
    4d4e:	718a      	strb	r2, [r1, #6]
    4d50:	2201      	movs	r2, #1
    4d52:	710a      	strb	r2, [r1, #4]
    4d54:	bd10      	pop	{r4, pc}
    4d56:	0000      	.short	0x0000
    4d58:	200015fc 	.word	0x200015fc

00004d5c <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q>:
    4d5c:	b510      	push	{r4, lr}
    4d5e:	2805      	cmp	r0, #5
    4d60:	d301      	bcc.n	4d66 <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q+0xa>
    4d62:	2158      	movs	r1, #88	; 0x58
    4d64:	e006      	b.n	4d74 <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q+0x18>
    4d66:	490a      	ldr	r1, [pc, #40]	; (4d90 <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q+0x34>)
    4d68:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
    4d6c:	7901      	ldrb	r1, [r0, #4]
    4d6e:	2901      	cmp	r1, #1
    4d70:	d003      	beq.n	4d7a <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q+0x1e>
    4d72:	2159      	movs	r1, #89	; 0x59
    4d74:	2069      	movs	r0, #105	; 0x69
    4d76:	f7ff ff1d 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    4d7a:	7941      	ldrb	r1, [r0, #5]
    4d7c:	7982      	ldrb	r2, [r0, #6]
    4d7e:	1c49      	adds	r1, r1, #1
    4d80:	b2c9      	uxtb	r1, r1
    4d82:	428a      	cmp	r2, r1
    4d84:	d000      	beq.n	4d88 <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q+0x2c>
    4d86:	7141      	strb	r1, [r0, #5]
    4d88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4d8c:	f7ff bf74 	b.w	4c78 <sym_XR32KBBIVYD5OVRJM2RBQ57EGCCM2C3F5IY6OHQ>
    4d90:	200015fc 	.word	0x200015fc

00004d94 <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ>:
    4d94:	b570      	push	{r4, r5, r6, lr}
    4d96:	2505      	movs	r5, #5
    4d98:	4e0e      	ldr	r6, [pc, #56]	; (4dd4 <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0x40>)
    4d9a:	4c0f      	ldr	r4, [pc, #60]	; (4dd8 <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0x44>)
    4d9c:	e016      	b.n	4dcc <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0x38>
    4d9e:	7821      	ldrb	r1, [r4, #0]
    4da0:	eb06 00c1 	add.w	r0, r6, r1, lsl #3
    4da4:	7902      	ldrb	r2, [r0, #4]
    4da6:	2a01      	cmp	r2, #1
    4da8:	d108      	bne.n	4dbc <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0x28>
    4daa:	7942      	ldrb	r2, [r0, #5]
    4dac:	7983      	ldrb	r3, [r0, #6]
    4dae:	429a      	cmp	r2, r3
    4db0:	d004      	beq.n	4dbc <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0x28>
    4db2:	7942      	ldrb	r2, [r0, #5]
    4db4:	7182      	strb	r2, [r0, #6]
    4db6:	f856 0031 	ldr.w	r0, [r6, r1, lsl #3]
    4dba:	4780      	blx	r0
    4dbc:	7820      	ldrb	r0, [r4, #0]
    4dbe:	1c40      	adds	r0, r0, #1
    4dc0:	b2c0      	uxtb	r0, r0
    4dc2:	7020      	strb	r0, [r4, #0]
    4dc4:	2805      	cmp	r0, #5
    4dc6:	d301      	bcc.n	4dcc <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0x38>
    4dc8:	2000      	movs	r0, #0
    4dca:	7020      	strb	r0, [r4, #0]
    4dcc:	1e6d      	subs	r5, r5, #1
    4dce:	b2ed      	uxtb	r5, r5
    4dd0:	d2e5      	bcs.n	4d9e <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ+0xa>
    4dd2:	bd70      	pop	{r4, r5, r6, pc}
    4dd4:	200015fc 	.word	0x200015fc
    4dd8:	20000326 	.word	0x20000326

00004ddc <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY>:
    4ddc:	b500      	push	{lr}
    4dde:	f008 f888 	bl	cef2 <sym_BN6ZO2NBHRGKZ2NRQYWFBXVGKNG6Y5K55UNAWGA>
    4de2:	b940      	cbnz	r0, 4df6 <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY+0x1a>
    4de4:	f008 f88f 	bl	cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>
    4de8:	b928      	cbnz	r0, 4df6 <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY+0x1a>
    4dea:	f008 f8a3 	bl	cf34 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q>
    4dee:	b910      	cbnz	r0, 4df6 <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY+0x1a>
    4df0:	f008 f8b4 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    4df4:	b108      	cbz	r0, 4dfa <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY+0x1e>
    4df6:	4802      	ldr	r0, [pc, #8]	; (4e00 <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY+0x24>)
    4df8:	bd00      	pop	{pc}
    4dfa:	4802      	ldr	r0, [pc, #8]	; (4e04 <sym_4WL3TG4Q7RCTFEMPQ2CQTOL4PAKUULDPJUM5DTY+0x28>)
    4dfc:	bd00      	pop	{pc}
    4dfe:	0000      	.short	0x0000
    4e00:	4000050c 	.word	0x4000050c
    4e04:	4001e700 	.word	0x4001e700

00004e08 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA>:
    4e08:	b510      	push	{r4, lr}
    4e0a:	f008 f8a7 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    4e0e:	b330      	cbz	r0, 4e5e <CONFIG_HEAP_MEM_POOL_SIZE+0x3e>
    4e10:	f3ef 8010 	mrs	r0, PRIMASK
    4e14:	b1c8      	cbz	r0, 4e4a <CONFIG_HEAP_MEM_POOL_SIZE+0x2a>
    4e16:	2100      	movs	r1, #0
    4e18:	b672      	cpsid	i
    4e1a:	4812      	ldr	r0, [pc, #72]	; (4e64 <CONFIG_HEAP_MEM_POOL_SIZE+0x44>)
    4e1c:	6802      	ldr	r2, [r0, #0]
    4e1e:	6803      	ldr	r3, [r0, #0]
    4e20:	f3c2 1200 	ubfx	r2, r2, #4, #1
    4e24:	f043 0310 	orr.w	r3, r3, #16
    4e28:	6003      	str	r3, [r0, #0]
    4e2a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    4e2e:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    4e32:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
    4e36:	431c      	orrs	r4, r3
    4e38:	d000      	beq.n	4e3c <CONFIG_HEAP_MEM_POOL_SIZE+0x1c>
    4e3a:	bf40      	sev
    4e3c:	bf20      	wfe
    4e3e:	bf00      	nop
    4e40:	bf00      	nop
    4e42:	bf00      	nop
    4e44:	bf00      	nop
    4e46:	b112      	cbz	r2, 4e4e <CONFIG_HEAP_MEM_POOL_SIZE+0x2e>
    4e48:	e005      	b.n	4e56 <CONFIG_HEAP_MEM_POOL_SIZE+0x36>
    4e4a:	2101      	movs	r1, #1
    4e4c:	e7e4      	b.n	4e18 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA+0x10>
    4e4e:	6802      	ldr	r2, [r0, #0]
    4e50:	f022 0210 	bic.w	r2, r2, #16
    4e54:	6002      	str	r2, [r0, #0]
    4e56:	2900      	cmp	r1, #0
    4e58:	d000      	beq.n	4e5c <CONFIG_HEAP_MEM_POOL_SIZE+0x3c>
    4e5a:	b662      	cpsie	i
    4e5c:	bd10      	pop	{r4, pc}
    4e5e:	bf20      	wfe
    4e60:	bd10      	pop	{r4, pc}
    4e62:	0000      	.short	0x0000
    4e64:	e000ed10 	.word	0xe000ed10

00004e68 <sym_FLYO2O6PDDEK6WCFFGJRAPCMRB5FFHTEEHI4Z2Q>:
    4e68:	4901      	ldr	r1, [pc, #4]	; (4e70 <sym_FLYO2O6PDDEK6WCFFGJRAPCMRB5FFHTEEHI4Z2Q+0x8>)
    4e6a:	2001      	movs	r0, #1
    4e6c:	7088      	strb	r0, [r1, #2]
    4e6e:	4770      	bx	lr
    4e70:	2000007c 	.word	0x2000007c

00004e74 <sym_NIQMZN22R7GGCSNM3BZ25GTCR6D457XB3DIUGWA>:
    4e74:	0000d1a9 0000d1e1 0000d1cb 0000d1b9     ................
    4e84:	0000d1c5 0000d1b3 0000d1a7 0000d1a5     ................
    4e94:	0000d1dd 0000d1d1 0000d1bf 0000d1ad     ................
    4ea4:	0000d19f 0000d197 0000d19b 0000d191     ................

00004eb4 <mpsl_fem_disable>:
    4eb4:	4801      	ldr	r0, [pc, #4]	; (4ebc <mpsl_fem_disable+0x8>)
    4eb6:	6800      	ldr	r0, [r0, #0]
    4eb8:	6800      	ldr	r0, [r0, #0]
    4eba:	4700      	bx	r0
    4ebc:	20000090 	.word	0x20000090

00004ec0 <mpsl_fem_lna_configuration_clear>:
    4ec0:	4801      	ldr	r0, [pc, #4]	; (4ec8 <mpsl_fem_lna_configuration_clear+0x8>)
    4ec2:	6800      	ldr	r0, [r0, #0]
    4ec4:	6940      	ldr	r0, [r0, #20]
    4ec6:	4700      	bx	r0
    4ec8:	20000090 	.word	0x20000090

00004ecc <mpsl_fem_lna_configuration_set>:
    4ecc:	4a01      	ldr	r2, [pc, #4]	; (4ed4 <mpsl_fem_lna_configuration_set+0x8>)
    4ece:	6812      	ldr	r2, [r2, #0]
    4ed0:	68d2      	ldr	r2, [r2, #12]
    4ed2:	4710      	bx	r2
    4ed4:	20000090 	.word	0x20000090

00004ed8 <mpsl_fem_lna_is_configured>:
    4ed8:	4901      	ldr	r1, [pc, #4]	; (4ee0 <mpsl_fem_lna_is_configured+0x8>)
    4eda:	6809      	ldr	r1, [r1, #0]
    4edc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    4ede:	4708      	bx	r1
    4ee0:	20000090 	.word	0x20000090

00004ee4 <mpsl_fem_pa_configuration_clear>:
    4ee4:	4801      	ldr	r0, [pc, #4]	; (4eec <mpsl_fem_pa_configuration_clear+0x8>)
    4ee6:	6800      	ldr	r0, [r0, #0]
    4ee8:	6900      	ldr	r0, [r0, #16]
    4eea:	4700      	bx	r0
    4eec:	20000090 	.word	0x20000090

00004ef0 <mpsl_fem_pa_configuration_set>:
    4ef0:	4a01      	ldr	r2, [pc, #4]	; (4ef8 <mpsl_fem_pa_configuration_set+0x8>)
    4ef2:	6812      	ldr	r2, [r2, #0]
    4ef4:	6892      	ldr	r2, [r2, #8]
    4ef6:	4710      	bx	r2
    4ef8:	20000090 	.word	0x20000090

00004efc <mpsl_fem_pa_gain_set>:
    4efc:	4901      	ldr	r1, [pc, #4]	; (4f04 <mpsl_fem_pa_gain_set+0x8>)
    4efe:	6809      	ldr	r1, [r1, #0]
    4f00:	6a49      	ldr	r1, [r1, #36]	; 0x24
    4f02:	4708      	bx	r1
    4f04:	20000090 	.word	0x20000090

00004f08 <mpsl_fem_pa_is_configured>:
    4f08:	4901      	ldr	r1, [pc, #4]	; (4f10 <mpsl_fem_pa_is_configured+0x8>)
    4f0a:	6809      	ldr	r1, [r1, #0]
    4f0c:	6a89      	ldr	r1, [r1, #40]	; 0x28
    4f0e:	4708      	bx	r1
    4f10:	20000090 	.word	0x20000090

00004f14 <mpsl_fem_tx_power_split>:
    4f14:	4b01      	ldr	r3, [pc, #4]	; (4f1c <mpsl_fem_tx_power_split+0x8>)
    4f16:	681b      	ldr	r3, [r3, #0]
    4f18:	685b      	ldr	r3, [r3, #4]
    4f1a:	4718      	bx	r3
    4f1c:	20000090 	.word	0x20000090

00004f20 <mpsl_fem_device_config_254_apply_get>:
    4f20:	4801      	ldr	r0, [pc, #4]	; (4f28 <mpsl_fem_device_config_254_apply_get+0x8>)
    4f22:	7800      	ldrb	r0, [r0, #0]
    4f24:	4770      	bx	lr
    4f26:	0000      	.short	0x0000
    4f28:	20000327 	.word	0x20000327
    4f2c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    4f2e:	4c14      	ldr	r4, [pc, #80]	; (4f80 <mpsl_fem_device_config_254_apply_get+0x60>)
    4f30:	7a20      	ldrb	r0, [r4, #8]
    4f32:	f88d 0001 	strb.w	r0, [sp, #1]
    4f36:	79e0      	ldrb	r0, [r4, #7]
    4f38:	f88d 0000 	strb.w	r0, [sp]
    4f3c:	79a0      	ldrb	r0, [r4, #6]
    4f3e:	f8ad 0004 	strh.w	r0, [sp, #4]
    4f42:	7960      	ldrb	r0, [r4, #5]
    4f44:	f8ad 0002 	strh.w	r0, [sp, #2]
    4f48:	4668      	mov	r0, sp
    4f4a:	f006 f895 	bl	b078 <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI>
    4f4e:	b108      	cbz	r0, 4f54 <mpsl_fem_device_config_254_apply_get+0x34>
    4f50:	2183      	movs	r1, #131	; 0x83
    4f52:	e010      	b.n	4f76 <mpsl_fem_device_config_254_apply_get+0x56>
    4f54:	68e0      	ldr	r0, [r4, #12]
    4f56:	9002      	str	r0, [sp, #8]
    4f58:	a802      	add	r0, sp, #8
    4f5a:	f006 f8a3 	bl	b0a4 <sym_DVVOECRRYK6EAGDREB2UKKQZT5MAOOUK66XNPTA>
    4f5e:	b108      	cbz	r0, 4f64 <mpsl_fem_device_config_254_apply_get+0x44>
    4f60:	2187      	movs	r1, #135	; 0x87
    4f62:	e008      	b.n	4f76 <mpsl_fem_device_config_254_apply_get+0x56>
    4f64:	4807      	ldr	r0, [pc, #28]	; (4f84 <mpsl_fem_device_config_254_apply_get+0x64>)
    4f66:	6800      	ldr	r0, [r0, #0]
    4f68:	9003      	str	r0, [sp, #12]
    4f6a:	a803      	add	r0, sp, #12
    4f6c:	f00b fa7c 	bl	10468 <sym_J2SUO2NMPPNDQZAGB2FE5TAXJFMJ5FZXKAPNVFQ>
    4f70:	2800      	cmp	r0, #0
    4f72:	d003      	beq.n	4f7c <mpsl_fem_device_config_254_apply_get+0x5c>
    4f74:	218b      	movs	r1, #139	; 0x8b
    4f76:	2003      	movs	r0, #3
    4f78:	f000 f8ec 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    4f7c:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    4f7e:	0000      	.short	0x0000
    4f80:	20001624 	.word	0x20001624
    4f84:	00005260 	.word	0x00005260

00004f88 <sdc_build_revision_get>:
    4f88:	b510      	push	{r4, lr}
    4f8a:	b128      	cbz	r0, 4f98 <sdc_build_revision_get+0x10>
    4f8c:	2214      	movs	r2, #20
    4f8e:	4904      	ldr	r1, [pc, #16]	; (4fa0 <sdc_build_revision_get+0x18>)
    4f90:	f008 f824 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    4f94:	2000      	movs	r0, #0
    4f96:	bd10      	pop	{r4, pc}
    4f98:	f06f 0015 	mvn.w	r0, #21
    4f9c:	bd10      	pop	{r4, pc}
    4f9e:	0000      	.short	0x0000
    4fa0:	0000527c 	.word	0x0000527c

00004fa4 <sdc_cfg_set>:
    4fa4:	b570      	push	{r4, r5, r6, lr}
    4fa6:	0003      	movs	r3, r0
    4fa8:	f06f 002c 	mvn.w	r0, #44	; 0x2c
    4fac:	d103      	bne.n	4fb6 <sdc_cfg_set+0x12>
    4fae:	4c2e      	ldr	r4, [pc, #184]	; (5068 <sdc_cfg_set+0xc4>)
    4fb0:	7863      	ldrb	r3, [r4, #1]
    4fb2:	b10b      	cbz	r3, 4fb8 <sdc_cfg_set+0x14>
    4fb4:	1180      	asrs	r0, r0, #6
    4fb6:	bd70      	pop	{r4, r5, r6, pc}
    4fb8:	b301      	cbz	r1, 4ffc <sdc_cfg_set+0x58>
    4fba:	f06f 0515 	mvn.w	r5, #21
    4fbe:	b38a      	cbz	r2, 5024 <sdc_cfg_set+0x80>
    4fc0:	4b2a      	ldr	r3, [pc, #168]	; (506c <sdc_cfg_set+0xc8>)
    4fc2:	290c      	cmp	r1, #12
    4fc4:	d24b      	bcs.n	505e <sdc_cfg_set+0xba>
    4fc6:	e8df f001 	tbb	[pc, r1]
    4fca:	064a      	.short	0x064a
    4fcc:	1d1a0c09 	.word	0x1d1a0c09
    4fd0:	31202e25 	.word	0x31202e25
    4fd4:	3b36      	.short	0x3b36
    4fd6:	7810      	ldrb	r0, [r2, #0]
    4fd8:	7018      	strb	r0, [r3, #0]
    4fda:	e035      	b.n	5048 <sdc_cfg_set+0xa4>
    4fdc:	7810      	ldrb	r0, [r2, #0]
    4fde:	7058      	strb	r0, [r3, #1]
    4fe0:	e032      	b.n	5048 <sdc_cfg_set+0xa4>
    4fe2:	7890      	ldrb	r0, [r2, #2]
    4fe4:	b1f0      	cbz	r0, 5024 <sdc_cfg_set+0x80>
    4fe6:	78d0      	ldrb	r0, [r2, #3]
    4fe8:	b1e0      	cbz	r0, 5024 <sdc_cfg_set+0x80>
    4fea:	7810      	ldrb	r0, [r2, #0]
    4fec:	281b      	cmp	r0, #27
    4fee:	d336      	bcc.n	505e <sdc_cfg_set+0xba>
    4ff0:	7850      	ldrb	r0, [r2, #1]
    4ff2:	281b      	cmp	r0, #27
    4ff4:	d333      	bcc.n	505e <sdc_cfg_set+0xba>
    4ff6:	6810      	ldr	r0, [r2, #0]
    4ff8:	f8c3 0005 	str.w	r0, [r3, #5]
    4ffc:	e024      	b.n	5048 <sdc_cfg_set+0xa4>
    4ffe:	6810      	ldr	r0, [r2, #0]
    5000:	60d8      	str	r0, [r3, #12]
    5002:	e021      	b.n	5048 <sdc_cfg_set+0xa4>
    5004:	7810      	ldrb	r0, [r2, #0]
    5006:	7098      	strb	r0, [r3, #2]
    5008:	e01e      	b.n	5048 <sdc_cfg_set+0xa4>
    500a:	7811      	ldrb	r1, [r2, #0]
    500c:	2900      	cmp	r1, #0
    500e:	d1d2      	bne.n	4fb6 <sdc_cfg_set+0x12>
    5010:	70d9      	strb	r1, [r3, #3]
    5012:	e019      	b.n	5048 <sdc_cfg_set+0xa4>
    5014:	78e0      	ldrb	r0, [r4, #3]
    5016:	b110      	cbz	r0, 501e <sdc_cfg_set+0x7a>
    5018:	7810      	ldrb	r0, [r2, #0]
    501a:	2802      	cmp	r0, #2
    501c:	d31f      	bcc.n	505e <sdc_cfg_set+0xba>
    501e:	7810      	ldrb	r0, [r2, #0]
    5020:	7418      	strb	r0, [r3, #16]
    5022:	e011      	b.n	5048 <sdc_cfg_set+0xa4>
    5024:	e01b      	b.n	505e <sdc_cfg_set+0xba>
    5026:	8810      	ldrh	r0, [r2, #0]
    5028:	8258      	strh	r0, [r3, #18]
    502a:	e00d      	b.n	5048 <sdc_cfg_set+0xa4>
    502c:	7811      	ldrb	r1, [r2, #0]
    502e:	2900      	cmp	r1, #0
    5030:	d1c1      	bne.n	4fb6 <sdc_cfg_set+0x12>
    5032:	7119      	strb	r1, [r3, #4]
    5034:	e008      	b.n	5048 <sdc_cfg_set+0xa4>
    5036:	7810      	ldrb	r0, [r2, #0]
    5038:	2802      	cmp	r0, #2
    503a:	d310      	bcc.n	505e <sdc_cfg_set+0xba>
    503c:	7518      	strb	r0, [r3, #20]
    503e:	e003      	b.n	5048 <sdc_cfg_set+0xa4>
    5040:	7811      	ldrb	r1, [r2, #0]
    5042:	2900      	cmp	r1, #0
    5044:	d1b7      	bne.n	4fb6 <sdc_cfg_set+0x12>
    5046:	7559      	strb	r1, [r3, #21]
    5048:	2201      	movs	r2, #1
    504a:	4908      	ldr	r1, [pc, #32]	; (506c <sdc_cfg_set+0xc8>)
    504c:	2000      	movs	r0, #0
    504e:	f008 f8e1 	bl	d214 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x2e>
    5052:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    5056:	db04      	blt.n	5062 <sdc_cfg_set+0xbe>
    5058:	f06f 000b 	mvn.w	r0, #11
    505c:	bd70      	pop	{r4, r5, r6, pc}
    505e:	4628      	mov	r0, r5
    5060:	bd70      	pop	{r4, r5, r6, pc}
    5062:	2101      	movs	r1, #1
    5064:	70a1      	strb	r1, [r4, #2]
    5066:	bd70      	pop	{r4, r5, r6, pc}
    5068:	20000094 	.word	0x20000094
    506c:	20001624 	.word	0x20001624

00005070 <sdc_enable>:
    5070:	b570      	push	{r4, r5, r6, lr}
    5072:	460c      	mov	r4, r1
    5074:	0005      	movs	r5, r0
    5076:	d019      	beq.n	50ac <sdc_enable+0x3c>
    5078:	b1c4      	cbz	r4, 50ac <sdc_enable+0x3c>
    507a:	f000 f925 	bl	52c8 <sym_EZ7BAEZZMYJFIJAONX254JF3WPGEXUT4NMP2WJQ>
    507e:	b1c0      	cbz	r0, 50b2 <sdc_enable+0x42>
    5080:	4628      	mov	r0, r5
    5082:	f7ff fe4d 	bl	4d20 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA>
    5086:	4d0c      	ldr	r5, [pc, #48]	; (50b8 <sdc_enable+0x48>)
    5088:	2200      	movs	r2, #0
    508a:	490c      	ldr	r1, [pc, #48]	; (50bc <sdc_enable+0x4c>)
    508c:	7028      	strb	r0, [r5, #0]
    508e:	4620      	mov	r0, r4
    5090:	f008 f8c0 	bl	d214 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x2e>
    5094:	f00b fe20 	bl	10cd8 <sym_BIDMG7YHRFQNLIKRFVSOGOT6IXZCQ6UEJKN52VI>
    5098:	2100      	movs	r1, #0
    509a:	7828      	ldrb	r0, [r5, #0]
    509c:	f006 fa4a 	bl	b534 <sym_G4TIIR7KO3GHFF45HCHTIL3RIPRK2LVDQADUYJQ>
    50a0:	f7ff ff44 	bl	4f2c <mpsl_fem_device_config_254_apply_get+0xc>
    50a4:	2001      	movs	r0, #1
    50a6:	7068      	strb	r0, [r5, #1]
    50a8:	2000      	movs	r0, #0
    50aa:	bd70      	pop	{r4, r5, r6, pc}
    50ac:	f06f 0015 	mvn.w	r0, #21
    50b0:	bd70      	pop	{r4, r5, r6, pc}
    50b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    50b6:	bd70      	pop	{r4, r5, r6, pc}
    50b8:	20000094 	.word	0x20000094
    50bc:	20001624 	.word	0x20001624

000050c0 <sdc_init>:
    50c0:	b530      	push	{r4, r5, lr}
    50c2:	b087      	sub	sp, #28
    50c4:	0005      	movs	r5, r0
    50c6:	d00c      	beq.n	50e2 <sdc_init+0x22>
    50c8:	f7ff fdd0 	bl	4c6c <mpsl_is_initialized>
    50cc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    50d0:	b120      	cbz	r0, 50dc <sdc_init+0x1c>
    50d2:	f7ff fc77 	bl	49c4 <sym_ETIE3PCEXQYLK2GIVZENQ6V7PLBRV57MB7BDMNY>
    50d6:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
    50da:	d905      	bls.n	50e8 <sdc_init+0x28>
    50dc:	4620      	mov	r0, r4
    50de:	b007      	add	sp, #28
    50e0:	bd30      	pop	{r4, r5, pc}
    50e2:	f06f 0015 	mvn.w	r0, #21
    50e6:	e7fa      	b.n	50de <sdc_init+0x1e>
    50e8:	4c15      	ldr	r4, [pc, #84]	; (5140 <sdc_init+0x80>)
    50ea:	4816      	ldr	r0, [pc, #88]	; (5144 <sdc_init+0x84>)
    50ec:	6065      	str	r5, [r4, #4]
    50ee:	f000 f9f5 	bl	54dc <sym_G3KVRHCJDVHL7HV53526V3YI3DTK2IW2CADUWZQ>
    50f2:	2000      	movs	r0, #0
    50f4:	7060      	strb	r0, [r4, #1]
    50f6:	70a0      	strb	r0, [r4, #2]
    50f8:	70e0      	strb	r0, [r4, #3]
    50fa:	4601      	mov	r1, r0
    50fc:	2218      	movs	r2, #24
    50fe:	4668      	mov	r0, sp
    5100:	f007 ffe6 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    5104:	2218      	movs	r2, #24
    5106:	4910      	ldr	r1, [pc, #64]	; (5148 <sdc_init+0x88>)
    5108:	4668      	mov	r0, sp
    510a:	f007 ff67 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    510e:	2218      	movs	r2, #24
    5110:	4669      	mov	r1, sp
    5112:	480e      	ldr	r0, [pc, #56]	; (514c <sdc_init+0x8c>)
    5114:	f007 ff62 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    5118:	f3ef 8410 	mrs	r4, PRIMASK
    511c:	b672      	cpsid	i
    511e:	f06f 000c 	mvn.w	r0, #12
    5122:	f000 fd57 	bl	5bd4 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ>
    5126:	480a      	ldr	r0, [pc, #40]	; (5150 <sdc_init+0x90>)
    5128:	f000 fe22 	bl	5d70 <sym_QFSP7NEBRUPCXI7KU3RYDOWD7SSPVNXVSULPYYY>
    512c:	b118      	cbz	r0, 5136 <sdc_init+0x76>
    512e:	219e      	movs	r1, #158	; 0x9e
    5130:	2003      	movs	r0, #3
    5132:	f000 f80f 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5136:	b904      	cbnz	r4, 513a <sdc_init+0x7a>
    5138:	b662      	cpsie	i
    513a:	2000      	movs	r0, #0
    513c:	e7cf      	b.n	50de <sdc_init+0x1e>
    513e:	0000      	.short	0x0000
    5140:	20000094 	.word	0x20000094
    5144:	00004f2d 	.word	0x00004f2d
    5148:	00005264 	.word	0x00005264
    514c:	20001624 	.word	0x20001624
    5150:	000052f5 	.word	0x000052f5

00005154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>:
    5154:	b50e      	push	{r1, r2, r3, lr}
    5156:	b672      	cpsid	i
    5158:	4a15      	ldr	r2, [pc, #84]	; (51b0 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x5c>)
    515a:	6855      	ldr	r5, [r2, #4]
    515c:	b1dd      	cbz	r5, 5196 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x42>
    515e:	2200      	movs	r2, #0
    5160:	4603      	mov	r3, r0
    5162:	466e      	mov	r6, sp
    5164:	240a      	movs	r4, #10
    5166:	e003      	b.n	5170 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x1c>
    5168:	fbb0 f0f4 	udiv	r0, r0, r4
    516c:	1c52      	adds	r2, r2, #1
    516e:	b2d2      	uxtb	r2, r2
    5170:	2800      	cmp	r0, #0
    5172:	d1f9      	bne.n	5168 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x14>
    5174:	54b0      	strb	r0, [r6, r2]
    5176:	e00a      	b.n	518e <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x3a>
    5178:	b2d8      	uxtb	r0, r3
    517a:	fbb0 f7f4 	udiv	r7, r0, r4
    517e:	fbb3 f3f4 	udiv	r3, r3, r4
    5182:	fb04 0017 	mls	r0, r4, r7, r0
    5186:	1e52      	subs	r2, r2, #1
    5188:	b2d2      	uxtb	r2, r2
    518a:	3030      	adds	r0, #48	; 0x30
    518c:	54b0      	strb	r0, [r6, r2]
    518e:	2a00      	cmp	r2, #0
    5190:	d1f2      	bne.n	5178 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x24>
    5192:	4630      	mov	r0, r6
    5194:	47a8      	blx	r5
    5196:	f3bf 8f4f 	dsb	sy
    519a:	4806      	ldr	r0, [pc, #24]	; (51b4 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x60>)
    519c:	6801      	ldr	r1, [r0, #0]
    519e:	4a06      	ldr	r2, [pc, #24]	; (51b8 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x64>)
    51a0:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
    51a4:	4311      	orrs	r1, r2
    51a6:	6001      	str	r1, [r0, #0]
    51a8:	f3bf 8f4f 	dsb	sy
    51ac:	bf00      	nop
    51ae:	e7fd      	b.n	51ac <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI+0x58>
    51b0:	20000094 	.word	0x20000094
    51b4:	e000ed0c 	.word	0xe000ed0c
    51b8:	05fa0004 	.word	0x05fa0004

000051bc <sdc_support_adv>:
    51bc:	4806      	ldr	r0, [pc, #24]	; (51d8 <sdc_support_adv+0x1c>)
    51be:	b510      	push	{r4, lr}
    51c0:	7881      	ldrb	r1, [r0, #2]
    51c2:	7840      	ldrb	r0, [r0, #1]
    51c4:	4301      	orrs	r1, r0
    51c6:	d002      	beq.n	51ce <sdc_support_adv+0x12>
    51c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    51cc:	bd10      	pop	{r4, pc}
    51ce:	f006 f9cf 	bl	b570 <sym_EANB2LFFCPDZUHTPF7SNNYVWVGG3AE7JVOONSTY>
    51d2:	2000      	movs	r0, #0
    51d4:	bd10      	pop	{r4, pc}
    51d6:	0000      	.short	0x0000
    51d8:	20000094 	.word	0x20000094

000051dc <sdc_support_dle_peripheral>:
    51dc:	4806      	ldr	r0, [pc, #24]	; (51f8 <sdc_support_dle_peripheral+0x1c>)
    51de:	b510      	push	{r4, lr}
    51e0:	7881      	ldrb	r1, [r0, #2]
    51e2:	7840      	ldrb	r0, [r0, #1]
    51e4:	4301      	orrs	r1, r0
    51e6:	d002      	beq.n	51ee <sdc_support_dle_peripheral+0x12>
    51e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    51ec:	bd10      	pop	{r4, pc}
    51ee:	f005 ff71 	bl	b0d4 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI>
    51f2:	2000      	movs	r0, #0
    51f4:	bd10      	pop	{r4, pc}
    51f6:	0000      	.short	0x0000
    51f8:	20000094 	.word	0x20000094

000051fc <sdc_support_le_2m_phy>:
    51fc:	4807      	ldr	r0, [pc, #28]	; (521c <sdc_support_le_2m_phy+0x20>)
    51fe:	b510      	push	{r4, lr}
    5200:	7881      	ldrb	r1, [r0, #2]
    5202:	7840      	ldrb	r0, [r0, #1]
    5204:	4301      	orrs	r1, r0
    5206:	d002      	beq.n	520e <sdc_support_le_2m_phy+0x12>
    5208:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    520c:	bd10      	pop	{r4, pc}
    520e:	f00b faf8 	bl	10802 <sym_266BMVQDBLXULMLATXWWN2P23YFP57RBL2ZNQ7A>
    5212:	f00b fb06 	bl	10822 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA>
    5216:	2000      	movs	r0, #0
    5218:	bd10      	pop	{r4, pc}
    521a:	0000      	.short	0x0000
    521c:	20000094 	.word	0x20000094

00005220 <sdc_support_peripheral>:
    5220:	4806      	ldr	r0, [pc, #24]	; (523c <sdc_support_peripheral+0x1c>)
    5222:	b510      	push	{r4, lr}
    5224:	7881      	ldrb	r1, [r0, #2]
    5226:	7840      	ldrb	r0, [r0, #1]
    5228:	4301      	orrs	r1, r0
    522a:	d002      	beq.n	5232 <sdc_support_peripheral+0x12>
    522c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5230:	bd10      	pop	{r4, pc}
    5232:	f006 f9af 	bl	b594 <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA>
    5236:	2000      	movs	r0, #0
    5238:	bd10      	pop	{r4, pc}
    523a:	0000      	.short	0x0000
    523c:	20000094 	.word	0x20000094

00005240 <sdc_support_phy_update_peripheral>:
    5240:	4806      	ldr	r0, [pc, #24]	; (525c <sdc_support_phy_update_peripheral+0x1c>)
    5242:	b510      	push	{r4, lr}
    5244:	7881      	ldrb	r1, [r0, #2]
    5246:	7840      	ldrb	r0, [r0, #1]
    5248:	4301      	orrs	r1, r0
    524a:	d002      	beq.n	5252 <sdc_support_phy_update_peripheral+0x12>
    524c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5250:	bd10      	pop	{r4, pc}
    5252:	f00b fae6 	bl	10822 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA>
    5256:	2000      	movs	r0, #0
    5258:	bd10      	pop	{r4, pc}
    525a:	0000      	.short	0x0000
    525c:	20000094 	.word	0x20000094
    5260:	00000001 	.word	0x00000001
    5264:	00010101 	.word	0x00010101
    5268:	031b1b00 	.word	0x031b1b00
    526c:	00000002 	.word	0x00000002
    5270:	00001d4c 	.word	0x00001d4c
    5274:	001f0003 	.word	0x001f0003
    5278:	00000000 	.word	0x00000000
    527c:	6f5fe7f2 	.word	0x6f5fe7f2
    5280:	e8f3a223 	.word	0xe8f3a223
    5284:	35c32f10 	.word	0x35c32f10
    5288:	fe1dd79e 	.word	0xfe1dd79e
    528c:	f942808f 	.word	0xf942808f

00005290 <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA>:
    5290:	4a05      	ldr	r2, [pc, #20]	; (52a8 <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA+0x18>)
    5292:	b510      	push	{r4, lr}
    5294:	6852      	ldr	r2, [r2, #4]
    5296:	b112      	cbz	r2, 529e <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA+0xe>
    5298:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    529c:	4710      	bx	r2
    529e:	2192      	movs	r1, #146	; 0x92
    52a0:	2004      	movs	r0, #4
    52a2:	f7ff ff57 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    52a6:	0000      	.short	0x0000
    52a8:	2000163c 	.word	0x2000163c

000052ac <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA>:
    52ac:	4a05      	ldr	r2, [pc, #20]	; (52c4 <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA+0x18>)
    52ae:	b510      	push	{r4, lr}
    52b0:	6892      	ldr	r2, [r2, #8]
    52b2:	b112      	cbz	r2, 52ba <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA+0xe>
    52b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    52b8:	4710      	bx	r2
    52ba:	2198      	movs	r1, #152	; 0x98
    52bc:	2004      	movs	r0, #4
    52be:	f7ff ff49 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    52c2:	0000      	.short	0x0000
    52c4:	2000163c 	.word	0x2000163c

000052c8 <sym_EZ7BAEZZMYJFIJAONX254JF3WPGEXUT4NMP2WJQ>:
    52c8:	4805      	ldr	r0, [pc, #20]	; (52e0 <sym_EZ7BAEZZMYJFIJAONX254JF3WPGEXUT4NMP2WJQ+0x18>)
    52ca:	6801      	ldr	r1, [r0, #0]
    52cc:	b129      	cbz	r1, 52da <sym_EZ7BAEZZMYJFIJAONX254JF3WPGEXUT4NMP2WJQ+0x12>
    52ce:	6841      	ldr	r1, [r0, #4]
    52d0:	b119      	cbz	r1, 52da <sym_EZ7BAEZZMYJFIJAONX254JF3WPGEXUT4NMP2WJQ+0x12>
    52d2:	6880      	ldr	r0, [r0, #8]
    52d4:	b108      	cbz	r0, 52da <sym_EZ7BAEZZMYJFIJAONX254JF3WPGEXUT4NMP2WJQ+0x12>
    52d6:	2001      	movs	r0, #1
    52d8:	4770      	bx	lr
    52da:	2000      	movs	r0, #0
    52dc:	4770      	bx	lr
    52de:	0000      	.short	0x0000
    52e0:	2000163c 	.word	0x2000163c

000052e4 <sdc_rand_source_register>:
    52e4:	4902      	ldr	r1, [pc, #8]	; (52f0 <sdc_rand_source_register+0xc>)
    52e6:	c80d      	ldmia	r0, {r0, r2, r3}
    52e8:	e881 000d 	stmia.w	r1, {r0, r2, r3}
    52ec:	2000      	movs	r0, #0
    52ee:	4770      	bx	lr
    52f0:	2000163c 	.word	0x2000163c

000052f4 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI>:
    52f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    52f6:	4c12      	ldr	r4, [pc, #72]	; (5340 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x4c>)
    52f8:	2600      	movs	r6, #0
    52fa:	6825      	ldr	r5, [r4, #0]
    52fc:	e011      	b.n	5322 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x2e>
    52fe:	9800      	ldr	r0, [sp, #0]
    5300:	2802      	cmp	r0, #2
    5302:	d002      	beq.n	530a <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x16>
    5304:	2803      	cmp	r0, #3
    5306:	d10c      	bne.n	5322 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x2e>
    5308:	e006      	b.n	5318 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x24>
    530a:	6820      	ldr	r0, [r4, #0]
    530c:	b110      	cbz	r0, 5314 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x20>
    530e:	2000      	movs	r0, #0
    5310:	6026      	str	r6, [r4, #0]
    5312:	e005      	b.n	5320 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x2c>
    5314:	2128      	movs	r1, #40	; 0x28
    5316:	e00c      	b.n	5332 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x3e>
    5318:	6820      	ldr	r0, [r4, #0]
    531a:	b168      	cbz	r0, 5338 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x44>
    531c:	2001      	movs	r0, #1
    531e:	6026      	str	r6, [r4, #0]
    5320:	47a8      	blx	r5
    5322:	4668      	mov	r0, sp
    5324:	f000 fcf6 	bl	5d14 <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI>
    5328:	2800      	cmp	r0, #0
    532a:	d0e8      	beq.n	52fe <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xa>
    532c:	2805      	cmp	r0, #5
    532e:	d005      	beq.n	533c <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x48>
    5330:	2135      	movs	r1, #53	; 0x35
    5332:	2004      	movs	r0, #4
    5334:	f7ff ff0e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5338:	212d      	movs	r1, #45	; 0x2d
    533a:	e7fa      	b.n	5332 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x3e>
    533c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    533e:	0000      	.short	0x0000
    5340:	2000009c 	.word	0x2000009c
    5344:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    5346:	4c1f      	ldr	r4, [pc, #124]	; (53c4 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xd0>)
    5348:	4605      	mov	r5, r0
    534a:	7820      	ldrb	r0, [r4, #0]
    534c:	b140      	cbz	r0, 5360 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x6c>
    534e:	78a2      	ldrb	r2, [r4, #2]
    5350:	1c61      	adds	r1, r4, #1
    5352:	4628      	mov	r0, r5
    5354:	1c92      	adds	r2, r2, #2
    5356:	f007 fe41 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    535a:	2000      	movs	r0, #0
    535c:	7020      	strb	r0, [r4, #0]
    535e:	e021      	b.n	53a4 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xb0>
    5360:	4819      	ldr	r0, [pc, #100]	; (53c8 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xd4>)
    5362:	f001 ff43 	bl	71ec <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q>
    5366:	2800      	cmp	r0, #0
    5368:	d01d      	beq.n	53a6 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xb2>
    536a:	4c17      	ldr	r4, [pc, #92]	; (53c8 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xd4>)
    536c:	7820      	ldrb	r0, [r4, #0]
    536e:	2811      	cmp	r0, #17
    5370:	d104      	bne.n	537c <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x88>
    5372:	210a      	movs	r1, #10
    5374:	203e      	movs	r0, #62	; 0x3e
    5376:	f007 ffbb 	bl	d2f0 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x1e>
    537a:	b118      	cbz	r0, 5384 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x90>
    537c:	7820      	ldrb	r0, [r4, #0]
    537e:	2808      	cmp	r0, #8
    5380:	d005      	beq.n	538e <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x9a>
    5382:	e009      	b.n	5398 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xa4>
    5384:	4910      	ldr	r1, [pc, #64]	; (53c8 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xd4>)
    5386:	4628      	mov	r0, r5
    5388:	f008 f9bb 	bl	d702 <sym_3TBFCFZXCYDY6GUKVOWTISOQWWIRT2CJTYIBX5Y>
    538c:	e00a      	b.n	53a4 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xb0>
    538e:	2105      	movs	r1, #5
    5390:	203e      	movs	r0, #62	; 0x3e
    5392:	f007 ffad 	bl	d2f0 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x1e>
    5396:	b138      	cbz	r0, 53a8 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xb4>
    5398:	490b      	ldr	r1, [pc, #44]	; (53c8 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xd4>)
    539a:	4628      	mov	r0, r5
    539c:	f008 f804 	bl	d3a8 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI>
    53a0:	2800      	cmp	r0, #0
    53a2:	d000      	beq.n	53a6 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xb2>
    53a4:	2001      	movs	r0, #1
    53a6:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    53a8:	88a0      	ldrh	r0, [r4, #4]
    53aa:	f8ad 0000 	strh.w	r0, [sp]
    53ae:	a901      	add	r1, sp, #4
    53b0:	4668      	mov	r0, sp
    53b2:	f008 fad5 	bl	d960 <sdc_hci_cmd_le_long_term_key_request_negative_reply>
    53b6:	2800      	cmp	r0, #0
    53b8:	d0f5      	beq.n	53a6 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xb2>
    53ba:	219c      	movs	r1, #156	; 0x9c
    53bc:	2008      	movs	r0, #8
    53be:	f7ff fec9 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    53c2:	0000      	.short	0x0000
    53c4:	200017da 	.word	0x200017da
    53c8:	200016d8 	.word	0x200016d8
    53cc:	b570      	push	{r4, r5, r6, lr}
    53ce:	780a      	ldrb	r2, [r1, #0]
    53d0:	7082      	strb	r2, [r0, #2]
    53d2:	b33a      	cbz	r2, 5424 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x130>
    53d4:	2a01      	cmp	r2, #1
    53d6:	d825      	bhi.n	5424 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x130>
    53d8:	2313      	movs	r3, #19
    53da:	7003      	strb	r3, [r0, #0]
    53dc:	2300      	movs	r3, #0
    53de:	e00a      	b.n	53f6 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x102>
    53e0:	eb01 0443 	add.w	r4, r1, r3, lsl #1
    53e4:	eb00 0543 	add.w	r5, r0, r3, lsl #1
    53e8:	78a6      	ldrb	r6, [r4, #2]
    53ea:	70ee      	strb	r6, [r5, #3]
    53ec:	8864      	ldrh	r4, [r4, #2]
    53ee:	0a24      	lsrs	r4, r4, #8
    53f0:	1c5b      	adds	r3, r3, #1
    53f2:	712c      	strb	r4, [r5, #4]
    53f4:	b2db      	uxtb	r3, r3
    53f6:	4293      	cmp	r3, r2
    53f8:	d3f2      	bcc.n	53e0 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xec>
    53fa:	2300      	movs	r3, #0
    53fc:	e00b      	b.n	5416 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x122>
    53fe:	bf00      	nop
    5400:	eb01 0543 	add.w	r5, r1, r3, lsl #1
    5404:	eb00 0443 	add.w	r4, r0, r3, lsl #1
    5408:	792e      	ldrb	r6, [r5, #4]
    540a:	7166      	strb	r6, [r4, #5]
    540c:	88ad      	ldrh	r5, [r5, #4]
    540e:	0a2d      	lsrs	r5, r5, #8
    5410:	1c5b      	adds	r3, r3, #1
    5412:	71a5      	strb	r5, [r4, #6]
    5414:	b2db      	uxtb	r3, r3
    5416:	4293      	cmp	r3, r2
    5418:	d3f2      	bcc.n	5400 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x10c>
    541a:	2101      	movs	r1, #1
    541c:	eb01 0082 	add.w	r0, r1, r2, lsl #2
    5420:	b2c0      	uxtb	r0, r0
    5422:	bd70      	pop	{r4, r5, r6, pc}
    5424:	2000      	movs	r0, #0
    5426:	bd70      	pop	{r4, r5, r6, pc}

00005428 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY>:
    5428:	2840      	cmp	r0, #64	; 0x40
    542a:	d203      	bcs.n	5434 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY+0xc>
    542c:	1e40      	subs	r0, r0, #1
    542e:	b2c1      	uxtb	r1, r0
    5430:	4805      	ldr	r0, [pc, #20]	; (5448 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY+0x20>)
    5432:	e005      	b.n	5440 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY+0x18>
    5434:	28ff      	cmp	r0, #255	; 0xff
    5436:	d005      	beq.n	5444 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY+0x1c>
    5438:	3840      	subs	r0, #64	; 0x40
    543a:	b2c1      	uxtb	r1, r0
    543c:	4802      	ldr	r0, [pc, #8]	; (5448 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY+0x20>)
    543e:	3008      	adds	r0, #8
    5440:	f008 b989 	b.w	d756 <sym_3TBFCFZXCYDY6GUKVOWTISOQWWIRT2CJTYIBX5Y+0x54>
    5444:	2001      	movs	r0, #1
    5446:	4770      	bx	lr
    5448:	200000a0 	.word	0x200000a0

0000544c <sym_CEENVC5DZRUT7MGF5LABXKT4NV7YUL5F6EX6TEQ>:
    544c:	1e40      	subs	r0, r0, #1
    544e:	b2c1      	uxtb	r1, r0
    5450:	4801      	ldr	r0, [pc, #4]	; (5458 <sym_CEENVC5DZRUT7MGF5LABXKT4NV7YUL5F6EX6TEQ+0xc>)
    5452:	f008 b980 	b.w	d756 <sym_3TBFCFZXCYDY6GUKVOWTISOQWWIRT2CJTYIBX5Y+0x54>
    5456:	0000      	.short	0x0000
    5458:	200000b0 	.word	0x200000b0

0000545c <sym_PPT6FEOF2T6DRALMCRRTUI7CHLEPBAN25HYV3KQ>:
    545c:	4902      	ldr	r1, [pc, #8]	; (5468 <sym_PPT6FEOF2T6DRALMCRRTUI7CHLEPBAN25HYV3KQ+0xc>)
    545e:	6802      	ldr	r2, [r0, #0]
    5460:	610a      	str	r2, [r1, #16]
    5462:	6840      	ldr	r0, [r0, #4]
    5464:	6148      	str	r0, [r1, #20]
    5466:	4770      	bx	lr
    5468:	200000a0 	.word	0x200000a0

0000546c <sym_TU2SMBIUC7JL6C3K2XB6727DQLBLV5LEGIMZAFQ>:
    546c:	4905      	ldr	r1, [pc, #20]	; (5484 <sym_TU2SMBIUC7JL6C3K2XB6727DQLBLV5LEGIMZAFQ+0x18>)
    546e:	6802      	ldr	r2, [r0, #0]
    5470:	600a      	str	r2, [r1, #0]
    5472:	6840      	ldr	r0, [r0, #4]
    5474:	f442 228c 	orr.w	r2, r2, #286720	; 0x46000
    5478:	600a      	str	r2, [r1, #0]
    547a:	4a03      	ldr	r2, [pc, #12]	; (5488 <sym_TU2SMBIUC7JL6C3K2XB6727DQLBLV5LEGIMZAFQ+0x1c>)
    547c:	4310      	orrs	r0, r2
    547e:	6048      	str	r0, [r1, #4]
    5480:	4770      	bx	lr
    5482:	0000      	.short	0x0000
    5484:	200000a0 	.word	0x200000a0
    5488:	024007f8 	.word	0x024007f8

0000548c <sym_CIVMWIRGIOQ374UFFPIFNN4ZGKYK2FRKTT6YRYA>:
    548c:	4902      	ldr	r1, [pc, #8]	; (5498 <sym_CIVMWIRGIOQ374UFFPIFNN4ZGKYK2FRKTT6YRYA+0xc>)
    548e:	6802      	ldr	r2, [r0, #0]
    5490:	608a      	str	r2, [r1, #8]
    5492:	6840      	ldr	r0, [r0, #4]
    5494:	60c8      	str	r0, [r1, #12]
    5496:	4770      	bx	lr
    5498:	200000a0 	.word	0x200000a0

0000549c <sym_TG7NSIC2UKHCUBZWZ4K4EMD5QRI2QVSKVKV6CFQ>:
    549c:	4807      	ldr	r0, [pc, #28]	; (54bc <sym_TG7NSIC2UKHCUBZWZ4K4EMD5QRI2QVSKVKV6CFQ+0x20>)
    549e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    54a2:	2200      	movs	r2, #0
    54a4:	6001      	str	r1, [r0, #0]
    54a6:	0cc9      	lsrs	r1, r1, #19
    54a8:	6041      	str	r1, [r0, #4]
    54aa:	f100 0108 	add.w	r1, r0, #8
    54ae:	201f      	movs	r0, #31
    54b0:	600a      	str	r2, [r1, #0]
    54b2:	604a      	str	r2, [r1, #4]
    54b4:	3108      	adds	r1, #8
    54b6:	e9c1 0200 	strd	r0, r2, [r1]
    54ba:	4770      	bx	lr
    54bc:	200000a0 	.word	0x200000a0

000054c0 <sdc_hci_cmd_cb_reset>:
    54c0:	b510      	push	{r4, lr}
    54c2:	f7ff ffeb 	bl	549c <sym_TG7NSIC2UKHCUBZWZ4K4EMD5QRI2QVSKVKV6CFQ>
    54c6:	f00b f915 	bl	106f4 <sym_QA2HTUWXDQAGJZ32BSTQMVSMKKNETZBUHL37LYA>
    54ca:	4604      	mov	r4, r0
    54cc:	4802      	ldr	r0, [pc, #8]	; (54d8 <sdc_hci_cmd_cb_reset+0x18>)
    54ce:	6800      	ldr	r0, [r0, #0]
    54d0:	b100      	cbz	r0, 54d4 <sdc_hci_cmd_cb_reset+0x14>
    54d2:	4780      	blx	r0
    54d4:	4620      	mov	r0, r4
    54d6:	bd10      	pop	{r4, pc}
    54d8:	200000b8 	.word	0x200000b8

000054dc <sym_G3KVRHCJDVHL7HV53526V3YI3DTK2IW2CADUWZQ>:
    54dc:	4901      	ldr	r1, [pc, #4]	; (54e4 <sym_G3KVRHCJDVHL7HV53526V3YI3DTK2IW2CADUWZQ+0x8>)
    54de:	6008      	str	r0, [r1, #0]
    54e0:	4770      	bx	lr
    54e2:	0000      	.short	0x0000
    54e4:	200000b8 	.word	0x200000b8

000054e8 <sdc_hci_cmd_vs_zephyr_read_version_info>:
    54e8:	2102      	movs	r1, #2
    54ea:	8001      	strh	r1, [r0, #0]
    54ec:	8041      	strh	r1, [r0, #2]
    54ee:	2100      	movs	r1, #0
    54f0:	7101      	strb	r1, [r0, #4]
    54f2:	21f2      	movs	r1, #242	; 0xf2
    54f4:	7141      	strb	r1, [r0, #5]
    54f6:	f645 71e7 	movw	r1, #24551	; 0x5fe7
    54fa:	80c1      	strh	r1, [r0, #6]
    54fc:	4901      	ldr	r1, [pc, #4]	; (5504 <sdc_hci_cmd_vs_zephyr_read_version_info+0x1c>)
    54fe:	6081      	str	r1, [r0, #8]
    5500:	2000      	movs	r0, #0
    5502:	4770      	bx	lr
    5504:	f3a2236f 	.word	0xf3a2236f

00005508 <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A>:
    5508:	b53e      	push	{r1, r2, r3, r4, r5, lr}
    550a:	4604      	mov	r4, r0
    550c:	4669      	mov	r1, sp
    550e:	f008 fd76 	bl	dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>
    5512:	b170      	cbz	r0, 5532 <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A+0x2a>
    5514:	f240 215a 	movw	r1, #602	; 0x25a
    5518:	e008      	b.n	552c <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A+0x24>
    551a:	bf00      	nop
    551c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
    5520:	4621      	mov	r1, r4
    5522:	f000 f8ab 	bl	567c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY>
    5526:	b120      	cbz	r0, 5532 <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A+0x2a>
    5528:	f240 215f 	movw	r1, #607	; 0x25f
    552c:	2017      	movs	r0, #23
    552e:	f7ff fe11 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5532:	4668      	mov	r0, sp
    5534:	f000 f852 	bl	55dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>
    5538:	2800      	cmp	r0, #0
    553a:	d0ef      	beq.n	551c <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A+0x14>
    553c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	...

00005540 <sym_XHE47EZYHONCPR22HUAZULMCALDJINMYREOFDEI>:
    5540:	b510      	push	{r4, lr}
    5542:	2802      	cmp	r0, #2
    5544:	d304      	bcc.n	5550 <sym_XHE47EZYHONCPR22HUAZULMCALDJINMYREOFDEI+0x10>
    5546:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
    554a:	2017      	movs	r0, #23
    554c:	f7ff fe02 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5550:	4901      	ldr	r1, [pc, #4]	; (5558 <sym_XHE47EZYHONCPR22HUAZULMCALDJINMYREOFDEI+0x18>)
    5552:	5c08      	ldrb	r0, [r1, r0]
    5554:	bd10      	pop	{r4, pc}
    5556:	0000      	.short	0x0000
    5558:	20001648 	.word	0x20001648

0000555c <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA>:
    555c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    555e:	0005      	movs	r5, r0
    5560:	9500      	str	r5, [sp, #0]
    5562:	d010      	beq.n	5586 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x2a>
    5564:	2600      	movs	r6, #0
    5566:	7808      	ldrb	r0, [r1, #0]
    5568:	7849      	ldrb	r1, [r1, #1]
    556a:	4604      	mov	r4, r0
    556c:	42a1      	cmp	r1, r4
    556e:	d900      	bls.n	5572 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x16>
    5570:	460c      	mov	r4, r1
    5572:	1cea      	adds	r2, r5, #3
    5574:	f022 0203 	bic.w	r2, r2, #3
    5578:	42aa      	cmp	r2, r5
    557a:	d006      	beq.n	558a <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x2e>
    557c:	f240 1179 	movw	r1, #377	; 0x179
    5580:	2017      	movs	r0, #23
    5582:	f7ff fde7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5586:	2601      	movs	r6, #1
    5588:	e7ed      	b.n	5566 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0xa>
    558a:	4f13      	ldr	r7, [pc, #76]	; (55d8 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x7c>)
    558c:	7038      	strb	r0, [r7, #0]
    558e:	7079      	strb	r1, [r7, #1]
    5590:	4631      	mov	r1, r6
    5592:	4668      	mov	r0, sp
    5594:	f000 f8ee 	bl	5774 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xf8>
    5598:	2100      	movs	r1, #0
    559a:	460b      	mov	r3, r1
    559c:	9800      	ldr	r0, [sp, #0]
    559e:	1cc0      	adds	r0, r0, #3
    55a0:	f020 0003 	bic.w	r0, r0, #3
    55a4:	9000      	str	r0, [sp, #0]
    55a6:	b96e      	cbnz	r6, 55c4 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x68>
    55a8:	eb07 0281 	add.w	r2, r7, r1, lsl #2
    55ac:	60d0      	str	r0, [r2, #12]
    55ae:	2000      	movs	r0, #0
    55b0:	e006      	b.n	55c0 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x64>
    55b2:	bf00      	nop
    55b4:	f8d2 c00c 	ldr.w	ip, [r2, #12]
    55b8:	f84c 3020 	str.w	r3, [ip, r0, lsl #2]
    55bc:	1c40      	adds	r0, r0, #1
    55be:	b2c0      	uxtb	r0, r0
    55c0:	42a0      	cmp	r0, r4
    55c2:	d3f7      	bcc.n	55b4 <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x58>
    55c4:	9800      	ldr	r0, [sp, #0]
    55c6:	1c49      	adds	r1, r1, #1
    55c8:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    55cc:	b2c9      	uxtb	r1, r1
    55ce:	9000      	str	r0, [sp, #0]
    55d0:	2902      	cmp	r1, #2
    55d2:	d3e3      	bcc.n	559c <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA+0x40>
    55d4:	1b40      	subs	r0, r0, r5
    55d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    55d8:	20001648 	.word	0x20001648

000055dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>:
    55dc:	b570      	push	{r4, r5, r6, lr}
    55de:	4604      	mov	r4, r0
    55e0:	f008 febc 	bl	e35c <sym_RFDF52I45CER5LUFD5R474FWGPTOSAHNLW6EPTI>
    55e4:	b108      	cbz	r0, 55ea <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA+0xe>
    55e6:	2010      	movs	r0, #16
    55e8:	bd70      	pop	{r4, r5, r6, pc}
    55ea:	7825      	ldrb	r5, [r4, #0]
    55ec:	f000 f8fe 	bl	57ec <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x170>
    55f0:	4602      	mov	r2, r0
    55f2:	480c      	ldr	r0, [pc, #48]	; (5624 <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA+0x48>)
    55f4:	8861      	ldrh	r1, [r4, #2]
    55f6:	eb00 0085 	add.w	r0, r0, r5, lsl #2
    55fa:	e00e      	b.n	561a <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA+0x3e>
    55fc:	68c3      	ldr	r3, [r0, #12]
    55fe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    5602:	b143      	cbz	r3, 5616 <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA+0x3a>
    5604:	1c4a      	adds	r2, r1, #1
    5606:	8062      	strh	r2, [r4, #2]
    5608:	80a1      	strh	r1, [r4, #4]
    560a:	68c0      	ldr	r0, [r0, #12]
    560c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    5610:	60a0      	str	r0, [r4, #8]
    5612:	2000      	movs	r0, #0
    5614:	bd70      	pop	{r4, r5, r6, pc}
    5616:	1c49      	adds	r1, r1, #1
    5618:	b289      	uxth	r1, r1
    561a:	4291      	cmp	r1, r2
    561c:	d3ee      	bcc.n	55fc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA+0x20>
    561e:	8061      	strh	r1, [r4, #2]
    5620:	2005      	movs	r0, #5
    5622:	bd70      	pop	{r4, r5, r6, pc}
    5624:	20001648 	.word	0x20001648

00005628 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ>:
    5628:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    562c:	b121      	cbz	r1, 5638 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0x10>
    562e:	2901      	cmp	r1, #1
    5630:	d002      	beq.n	5638 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0x10>
    5632:	2000      	movs	r0, #0
    5634:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5638:	4c0f      	ldr	r4, [pc, #60]	; (5678 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0x50>)
    563a:	2700      	movs	r7, #0
    563c:	463b      	mov	r3, r7
    563e:	f64f 76ff 	movw	r6, #65535	; 0xffff
    5642:	eb04 0581 	add.w	r5, r4, r1, lsl #2
    5646:	f814 c001 	ldrb.w	ip, [r4, r1]
    564a:	e00a      	b.n	5662 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0x3a>
    564c:	19dc      	adds	r4, r3, r7
    564e:	f8d5 e00c 	ldr.w	lr, [r5, #12]
    5652:	b2a4      	uxth	r4, r4
    5654:	f85e e024 	ldr.w	lr, [lr, r4, lsl #2]
    5658:	f1be 0f00 	cmp.w	lr, #0
    565c:	d004      	beq.n	5668 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0x40>
    565e:	1c5b      	adds	r3, r3, #1
    5660:	b29b      	uxth	r3, r3
    5662:	459c      	cmp	ip, r3
    5664:	d8f2      	bhi.n	564c <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0x24>
    5666:	4634      	mov	r4, r6
    5668:	8004      	strh	r4, [r0, #0]
    566a:	4620      	mov	r0, r4
    566c:	42b4      	cmp	r4, r6
    566e:	d0e0      	beq.n	5632 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ+0xa>
    5670:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    5674:	f000 b834 	b.w	56e0 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x64>
    5678:	20001648 	.word	0x20001648

0000567c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY>:
    567c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5680:	4606      	mov	r6, r0
    5682:	f5a0 407f 	sub.w	r0, r0, #65280	; 0xff00
    5686:	460c      	mov	r4, r1
    5688:	f243 0702 	movw	r7, #12290	; 0x3002
    568c:	38ff      	subs	r0, #255	; 0xff
    568e:	d020      	beq.n	56d2 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x56>
    5690:	2c02      	cmp	r4, #2
    5692:	d302      	bcc.n	569a <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x1e>
    5694:	2007      	movs	r0, #7
    5696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    569a:	4630      	mov	r0, r6
    569c:	f000 f85a 	bl	5754 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xd8>
    56a0:	0005      	movs	r5, r0
    56a2:	d016      	beq.n	56d2 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x56>
    56a4:	480c      	ldr	r0, [pc, #48]	; (56d8 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x5c>)
    56a6:	4629      	mov	r1, r5
    56a8:	f850 2024 	ldr.w	r2, [r0, r4, lsl #2]
    56ac:	4630      	mov	r0, r6
    56ae:	4790      	blx	r2
    56b0:	480a      	ldr	r0, [pc, #40]	; (56dc <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x60>)
    56b2:	2100      	movs	r1, #0
    56b4:	eb00 0784 	add.w	r7, r0, r4, lsl #2
    56b8:	68f8      	ldr	r0, [r7, #12]
    56ba:	f840 1026 	str.w	r1, [r0, r6, lsl #2]
    56be:	4620      	mov	r0, r4
    56c0:	f000 f88a 	bl	57d8 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x15c>
    56c4:	4602      	mov	r2, r0
    56c6:	4629      	mov	r1, r5
    56c8:	6878      	ldr	r0, [r7, #4]
    56ca:	f008 fc77 	bl	dfbc <sym_B627VJPECYREV5OY4VJ652ISBA4XGPKVOUJ747A>
    56ce:	2000      	movs	r0, #0
    56d0:	e7e1      	b.n	5696 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x1a>
    56d2:	4638      	mov	r0, r7
    56d4:	e7df      	b.n	5696 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x1a>
    56d6:	0000      	.short	0x0000
    56d8:	0000580c 	.word	0x0000580c
    56dc:	20001648 	.word	0x20001648
    56e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    56e4:	4690      	mov	r8, r2
    56e6:	460d      	mov	r5, r1
    56e8:	4607      	mov	r7, r0
    56ea:	f008 fc99 	bl	e020 <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY+0x22>
    56ee:	b148      	cbz	r0, 5704 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x88>
    56f0:	4816      	ldr	r0, [pc, #88]	; (574c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xd0>)
    56f2:	eb00 0685 	add.w	r6, r0, r5, lsl #2
    56f6:	68f0      	ldr	r0, [r6, #12]
    56f8:	f850 0027 	ldr.w	r0, [r0, r7, lsl #2]
    56fc:	b128      	cbz	r0, 570a <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x8e>
    56fe:	f44f 719d 	mov.w	r1, #314	; 0x13a
    5702:	e015      	b.n	5730 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xb4>
    5704:	f240 1139 	movw	r1, #313	; 0x139
    5708:	e012      	b.n	5730 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xb4>
    570a:	6870      	ldr	r0, [r6, #4]
    570c:	2800      	cmp	r0, #0
    570e:	d01a      	beq.n	5746 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xca>
    5710:	4628      	mov	r0, r5
    5712:	f000 f861 	bl	57d8 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x15c>
    5716:	4601      	mov	r1, r0
    5718:	6870      	ldr	r0, [r6, #4]
    571a:	f008 fbf7 	bl	df0c <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ>
    571e:	0004      	movs	r4, r0
    5720:	d010      	beq.n	5744 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xc8>
    5722:	68f0      	ldr	r0, [r6, #12]
    5724:	2d02      	cmp	r5, #2
    5726:	f840 4027 	str.w	r4, [r0, r7, lsl #2]
    572a:	d304      	bcc.n	5736 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xba>
    572c:	f240 1145 	movw	r1, #325	; 0x145
    5730:	2017      	movs	r0, #23
    5732:	f7ff fd0f 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5736:	4806      	ldr	r0, [pc, #24]	; (5750 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xd4>)
    5738:	4642      	mov	r2, r8
    573a:	4621      	mov	r1, r4
    573c:	f850 3025 	ldr.w	r3, [r0, r5, lsl #2]
    5740:	4638      	mov	r0, r7
    5742:	4798      	blx	r3
    5744:	4620      	mov	r0, r4
    5746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    574a:	0000      	.short	0x0000
    574c:	20001648 	.word	0x20001648
    5750:	00005804 	.word	0x00005804
    5754:	b570      	push	{r4, r5, r6, lr}
    5756:	460c      	mov	r4, r1
    5758:	4605      	mov	r5, r0
    575a:	f008 fc61 	bl	e020 <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY+0x22>
    575e:	2800      	cmp	r0, #0
    5760:	d005      	beq.n	576e <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xf2>
    5762:	4803      	ldr	r0, [pc, #12]	; (5770 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xf4>)
    5764:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    5768:	68c0      	ldr	r0, [r0, #12]
    576a:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
    576e:	bd70      	pop	{r4, r5, r6, pc}
    5770:	20001648 	.word	0x20001648
    5774:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5778:	4e16      	ldr	r6, [pc, #88]	; (57d4 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x158>)
    577a:	4688      	mov	r8, r1
    577c:	4605      	mov	r5, r0
    577e:	2400      	movs	r4, #0
    5780:	6828      	ldr	r0, [r5, #0]
    5782:	1cc0      	adds	r0, r0, #3
    5784:	f020 0003 	bic.w	r0, r0, #3
    5788:	6028      	str	r0, [r5, #0]
    578a:	4620      	mov	r0, r4
    578c:	f000 f824 	bl	57d8 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x15c>
    5790:	5d31      	ldrb	r1, [r6, r4]
    5792:	4348      	muls	r0, r1
    5794:	f1b8 0f00 	cmp.w	r8, #0
    5798:	d001      	beq.n	579e <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x122>
    579a:	2200      	movs	r2, #0
    579c:	e000      	b.n	57a0 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x124>
    579e:	682a      	ldr	r2, [r5, #0]
    57a0:	4601      	mov	r1, r0
    57a2:	9200      	str	r2, [sp, #0]
    57a4:	b132      	cbz	r2, 57b4 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x138>
    57a6:	2700      	movs	r7, #0
    57a8:	ea4f 000d 	mov.w	r0, sp
    57ac:	f008 fbdf 	bl	df6e <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY>
    57b0:	b11f      	cbz	r7, 57ba <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x13e>
    57b2:	e006      	b.n	57c2 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x146>
    57b4:	2701      	movs	r7, #1
    57b6:	2000      	movs	r0, #0
    57b8:	e7f8      	b.n	57ac <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x130>
    57ba:	eb06 0184 	add.w	r1, r6, r4, lsl #2
    57be:	9a00      	ldr	r2, [sp, #0]
    57c0:	604a      	str	r2, [r1, #4]
    57c2:	6829      	ldr	r1, [r5, #0]
    57c4:	1c64      	adds	r4, r4, #1
    57c6:	4408      	add	r0, r1
    57c8:	b2e4      	uxtb	r4, r4
    57ca:	6028      	str	r0, [r5, #0]
    57cc:	2c02      	cmp	r4, #2
    57ce:	d3d7      	bcc.n	5780 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x104>
    57d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    57d4:	20001648 	.word	0x20001648
    57d8:	4903      	ldr	r1, [pc, #12]	; (57e8 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x16c>)
    57da:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
    57de:	f64f 71fc 	movw	r1, #65532	; 0xfffc
    57e2:	1cc0      	adds	r0, r0, #3
    57e4:	4008      	ands	r0, r1
    57e6:	4770      	bx	lr
    57e8:	00005800 	.word	0x00005800
    57ec:	4903      	ldr	r1, [pc, #12]	; (57fc <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x180>)
    57ee:	7808      	ldrb	r0, [r1, #0]
    57f0:	7849      	ldrb	r1, [r1, #1]
    57f2:	4288      	cmp	r0, r1
    57f4:	d200      	bcs.n	57f8 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x17c>
    57f6:	4608      	mov	r0, r1
    57f8:	4770      	bx	lr
    57fa:	0000      	.short	0x0000
    57fc:	20001648 	.word	0x20001648
    5800:	011002a0 	.word	0x011002a0
    5804:	0000e035 	.word	0x0000e035
    5808:	0000e035 	.word	0x0000e035
    580c:	0000fe85 	.word	0x0000fe85
    5810:	0000f1a5 	.word	0x0000f1a5

00005814 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA>:
    5814:	e92d 4fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5818:	4c27      	ldr	r4, [pc, #156]	; (58b8 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0xa4>)
    581a:	4606      	mov	r6, r0
    581c:	b081      	sub	sp, #4
    581e:	6820      	ldr	r0, [r4, #0]
    5820:	469a      	mov	sl, r3
    5822:	4693      	mov	fp, r2
    5824:	b158      	cbz	r0, 583e <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0x2a>
    5826:	7a01      	ldrb	r1, [r0, #8]
    5828:	42b1      	cmp	r1, r6
    582a:	d903      	bls.n	5834 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0x20>
    582c:	6840      	ldr	r0, [r0, #4]
    582e:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
    5832:	b140      	cbz	r0, 5846 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0x32>
    5834:	f243 0002 	movw	r0, #12290	; 0x3002
    5838:	b005      	add	sp, #20
    583a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    583e:	21a5      	movs	r1, #165	; 0xa5
    5840:	2018      	movs	r0, #24
    5842:	f7ff fc87 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5846:	4619      	mov	r1, r3
    5848:	9802      	ldr	r0, [sp, #8]
    584a:	f008 fc0d 	bl	e068 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x32>
    584e:	4680      	mov	r8, r0
    5850:	4658      	mov	r0, fp
    5852:	990e      	ldr	r1, [sp, #56]	; 0x38
    5854:	f008 fbfe 	bl	e054 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x1e>
    5858:	4605      	mov	r5, r0
    585a:	eb08 0005 	add.w	r0, r8, r5
    585e:	1d00      	adds	r0, r0, #4
    5860:	b287      	uxth	r7, r0
    5862:	6820      	ldr	r0, [r4, #0]
    5864:	46a1      	mov	r9, r4
    5866:	4639      	mov	r1, r7
    5868:	6800      	ldr	r0, [r0, #0]
    586a:	f008 fb4f 	bl	df0c <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ>
    586e:	0004      	movs	r4, r0
    5870:	d01f      	beq.n	58b2 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0x9e>
    5872:	8067      	strh	r7, [r4, #2]
    5874:	8025      	strh	r5, [r4, #0]
    5876:	4629      	mov	r1, r5
    5878:	1d20      	adds	r0, r4, #4
    587a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    587c:	4607      	mov	r7, r0
    587e:	465a      	mov	r2, fp
    5880:	2301      	movs	r3, #1
    5882:	9500      	str	r5, [sp, #0]
    5884:	f008 faa1 	bl	ddca <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ>
    5888:	8820      	ldrh	r0, [r4, #0]
    588a:	4641      	mov	r1, r8
    588c:	4438      	add	r0, r7
    588e:	230a      	movs	r3, #10
    5890:	9a02      	ldr	r2, [sp, #8]
    5892:	f8cd a000 	str.w	sl, [sp]
    5896:	f008 fa98 	bl	ddca <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ>
    589a:	8820      	ldrh	r0, [r4, #0]
    589c:	19c1      	adds	r1, r0, r7
    589e:	4638      	mov	r0, r7
    58a0:	f008 fac4 	bl	de2c <sym_SSKIYGWPVDNEN7KR2D37H7PSUNCWATTS2JUNCZI>
    58a4:	f8d9 0000 	ldr.w	r0, [r9]
    58a8:	6840      	ldr	r0, [r0, #4]
    58aa:	f840 4026 	str.w	r4, [r0, r6, lsl #2]
    58ae:	2000      	movs	r0, #0
    58b0:	e7c2      	b.n	5838 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0x24>
    58b2:	2004      	movs	r0, #4
    58b4:	e7c0      	b.n	5838 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA+0x24>
    58b6:	0000      	.short	0x0000
    58b8:	200000bc 	.word	0x200000bc

000058bc <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ>:
    58bc:	b570      	push	{r4, r5, r6, lr}
    58be:	4c14      	ldr	r4, [pc, #80]	; (5910 <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x54>)
    58c0:	6823      	ldr	r3, [r4, #0]
    58c2:	b18b      	cbz	r3, 58e8 <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x2c>
    58c4:	7a19      	ldrb	r1, [r3, #8]
    58c6:	4281      	cmp	r1, r0
    58c8:	d912      	bls.n	58f0 <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x34>
    58ca:	685a      	ldr	r2, [r3, #4]
    58cc:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
    58d0:	b171      	cbz	r1, 58f0 <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x34>
    58d2:	2500      	movs	r5, #0
    58d4:	f842 5020 	str.w	r5, [r2, r0, lsl #2]
    58d8:	884a      	ldrh	r2, [r1, #2]
    58da:	6818      	ldr	r0, [r3, #0]
    58dc:	f008 fb6e 	bl	dfbc <sym_B627VJPECYREV5OY4VJ652ISBA4XGPKVOUJ747A>
    58e0:	6821      	ldr	r1, [r4, #0]
    58e2:	2000      	movs	r0, #0
    58e4:	7a0a      	ldrb	r2, [r1, #8]
    58e6:	e00c      	b.n	5902 <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x46>
    58e8:	21c8      	movs	r1, #200	; 0xc8
    58ea:	2018      	movs	r0, #24
    58ec:	f7ff fc32 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    58f0:	f243 0002 	movw	r0, #12290	; 0x3002
    58f4:	bd70      	pop	{r4, r5, r6, pc}
    58f6:	684b      	ldr	r3, [r1, #4]
    58f8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    58fc:	b933      	cbnz	r3, 590c <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x50>
    58fe:	1c40      	adds	r0, r0, #1
    5900:	b2c0      	uxtb	r0, r0
    5902:	4282      	cmp	r2, r0
    5904:	d8f7      	bhi.n	58f6 <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ+0x3a>
    5906:	6808      	ldr	r0, [r1, #0]
    5908:	f008 fb4d 	bl	dfa6 <sym_4FRIF7JGOVTE7JZ3KYQVPKX5PKSXGKCIHE6GQDY>
    590c:	2000      	movs	r0, #0
    590e:	bd70      	pop	{r4, r5, r6, pc}
    5910:	200000bc 	.word	0x200000bc

00005914 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA>:
    5914:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5918:	460d      	mov	r5, r1
    591a:	0004      	movs	r4, r0
    591c:	4690      	mov	r8, r2
    591e:	f04f 0600 	mov.w	r6, #0
    5922:	d009      	beq.n	5938 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA+0x24>
    5924:	2700      	movs	r7, #0
    5926:	1ce0      	adds	r0, r4, #3
    5928:	f020 0003 	bic.w	r0, r0, #3
    592c:	42a0      	cmp	r0, r4
    592e:	d005      	beq.n	593c <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA+0x28>
    5930:	2186      	movs	r1, #134	; 0x86
    5932:	2018      	movs	r0, #24
    5934:	f7ff fc0e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5938:	2701      	movs	r7, #1
    593a:	e7f4      	b.n	5926 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA+0x12>
    593c:	b1cd      	cbz	r5, 5972 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA+0x5e>
    593e:	4611      	mov	r1, r2
    5940:	2000      	movs	r0, #0
    5942:	f008 fb14 	bl	df6e <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY>
    5946:	300c      	adds	r0, #12
    5948:	eb00 0685 	add.w	r6, r0, r5, lsl #2
    594c:	b98f      	cbnz	r7, 5972 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA+0x5e>
    594e:	4f0a      	ldr	r7, [pc, #40]	; (5978 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA+0x64>)
    5950:	f104 000c 	add.w	r0, r4, #12
    5954:	00aa      	lsls	r2, r5, #2
    5956:	603c      	str	r4, [r7, #0]
    5958:	7225      	strb	r5, [r4, #8]
    595a:	6060      	str	r0, [r4, #4]
    595c:	eb00 0085 	add.w	r0, r0, r5, lsl #2
    5960:	6020      	str	r0, [r4, #0]
    5962:	2100      	movs	r1, #0
    5964:	6860      	ldr	r0, [r4, #4]
    5966:	f007 fbb3 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    596a:	4641      	mov	r1, r8
    596c:	6838      	ldr	r0, [r7, #0]
    596e:	f008 fafe 	bl	df6e <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY>
    5972:	4630      	mov	r0, r6
    5974:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5978:	200000bc 	.word	0x200000bc

0000597c <sym_NOQRMQ5IH6SQFJEPI5A3UBMITO54HG4WO4DTTXA>:
    597c:	b570      	push	{r4, r5, r6, lr}
    597e:	4d08      	ldr	r5, [pc, #32]	; (59a0 <sym_NOQRMQ5IH6SQFJEPI5A3UBMITO54HG4WO4DTTXA+0x24>)
    5980:	6828      	ldr	r0, [r5, #0]
    5982:	2800      	cmp	r0, #0
    5984:	d00a      	beq.n	599c <sym_NOQRMQ5IH6SQFJEPI5A3UBMITO54HG4WO4DTTXA+0x20>
    5986:	2400      	movs	r4, #0
    5988:	e004      	b.n	5994 <sym_NOQRMQ5IH6SQFJEPI5A3UBMITO54HG4WO4DTTXA+0x18>
    598a:	4620      	mov	r0, r4
    598c:	f7ff ff96 	bl	58bc <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ>
    5990:	1c64      	adds	r4, r4, #1
    5992:	b2e4      	uxtb	r4, r4
    5994:	6828      	ldr	r0, [r5, #0]
    5996:	7a00      	ldrb	r0, [r0, #8]
    5998:	42a0      	cmp	r0, r4
    599a:	d8f6      	bhi.n	598a <sym_NOQRMQ5IH6SQFJEPI5A3UBMITO54HG4WO4DTTXA+0xe>
    599c:	bd70      	pop	{r4, r5, r6, pc}
    599e:	0000      	.short	0x0000
    59a0:	200000bc 	.word	0x200000bc

000059a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>:
    59a4:	4909      	ldr	r1, [pc, #36]	; (59cc <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ+0x28>)
    59a6:	b510      	push	{r4, lr}
    59a8:	4602      	mov	r2, r0
    59aa:	6809      	ldr	r1, [r1, #0]
    59ac:	2000      	movs	r0, #0
    59ae:	b149      	cbz	r1, 59c4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ+0x20>
    59b0:	7a0b      	ldrb	r3, [r1, #8]
    59b2:	4293      	cmp	r3, r2
    59b4:	d905      	bls.n	59c2 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ+0x1e>
    59b6:	6849      	ldr	r1, [r1, #4]
    59b8:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
    59bc:	2900      	cmp	r1, #0
    59be:	d000      	beq.n	59c2 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ+0x1e>
    59c0:	1d08      	adds	r0, r1, #4
    59c2:	bd10      	pop	{r4, pc}
    59c4:	21ee      	movs	r1, #238	; 0xee
    59c6:	2018      	movs	r0, #24
    59c8:	f7ff fbc4 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    59cc:	200000bc 	.word	0x200000bc

000059d0 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA>:
    59d0:	490a      	ldr	r1, [pc, #40]	; (59fc <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x2c>)
    59d2:	b510      	push	{r4, lr}
    59d4:	4602      	mov	r2, r0
    59d6:	6809      	ldr	r1, [r1, #0]
    59d8:	2000      	movs	r0, #0
    59da:	b159      	cbz	r1, 59f4 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x24>
    59dc:	7a0b      	ldrb	r3, [r1, #8]
    59de:	4293      	cmp	r3, r2
    59e0:	d907      	bls.n	59f2 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x22>
    59e2:	6849      	ldr	r1, [r1, #4]
    59e4:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
    59e8:	2900      	cmp	r1, #0
    59ea:	d002      	beq.n	59f2 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x22>
    59ec:	f831 0b04 	ldrh.w	r0, [r1], #4
    59f0:	4408      	add	r0, r1
    59f2:	bd10      	pop	{r4, pc}
    59f4:	21fc      	movs	r1, #252	; 0xfc
    59f6:	2018      	movs	r0, #24
    59f8:	f7ff fbac 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    59fc:	200000bc 	.word	0x200000bc
    5a00:	b570      	push	{r4, r5, r6, lr}
    5a02:	4b1e      	ldr	r3, [pc, #120]	; (5a7c <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0xac>)
    5a04:	6845      	ldr	r5, [r0, #4]
    5a06:	4604      	mov	r4, r0
    5a08:	2200      	movs	r2, #0
    5a0a:	b1a1      	cbz	r1, 5a36 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x66>
    5a0c:	2001      	movs	r0, #1
    5a0e:	7060      	strb	r0, [r4, #1]
    5a10:	8858      	ldrh	r0, [r3, #2]
    5a12:	0881      	lsrs	r1, r0, #2
    5a14:	f05f 0000 	movs.w	r0, #0
    5a18:	eb04 0340 	add.w	r3, r4, r0, lsl #1
    5a1c:	eb04 0680 	add.w	r6, r4, r0, lsl #2
    5a20:	831a      	strh	r2, [r3, #24]
    5a22:	8419      	strh	r1, [r3, #32]
    5a24:	fb00 5301 	mla	r3, r0, r1, r5
    5a28:	6073      	str	r3, [r6, #4]
    5a2a:	1823      	adds	r3, r4, r0
    5a2c:	1c40      	adds	r0, r0, #1
    5a2e:	751a      	strb	r2, [r3, #20]
    5a30:	2804      	cmp	r0, #4
    5a32:	d3f1      	bcc.n	5a18 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x48>
    5a34:	bd70      	pop	{r4, r5, r6, pc}
    5a36:	7062      	strb	r2, [r4, #1]
    5a38:	f05f 0000 	movs.w	r0, #0
    5a3c:	eb04 0140 	add.w	r1, r4, r0, lsl #1
    5a40:	830a      	strh	r2, [r1, #24]
    5a42:	840a      	strh	r2, [r1, #32]
    5a44:	eb04 0180 	add.w	r1, r4, r0, lsl #2
    5a48:	604a      	str	r2, [r1, #4]
    5a4a:	1821      	adds	r1, r4, r0
    5a4c:	1c40      	adds	r0, r0, #1
    5a4e:	750a      	strb	r2, [r1, #20]
    5a50:	2804      	cmp	r0, #4
    5a52:	d3f3      	bcc.n	5a3c <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x6c>
    5a54:	8858      	ldrh	r0, [r3, #2]
    5a56:	f5b0 7fff 	cmp.w	r0, #510	; 0x1fe
    5a5a:	d201      	bcs.n	5a60 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x90>
    5a5c:	0846      	lsrs	r6, r0, #1
    5a5e:	e000      	b.n	5a62 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x92>
    5a60:	26ff      	movs	r6, #255	; 0xff
    5a62:	f008 fb75 	bl	e150 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x11a>
    5a66:	6065      	str	r5, [r4, #4]
    5a68:	8420      	strh	r0, [r4, #32]
    5a6a:	1829      	adds	r1, r5, r0
    5a6c:	60a1      	str	r1, [r4, #8]
    5a6e:	8466      	strh	r6, [r4, #34]	; 0x22
    5a70:	60e5      	str	r5, [r4, #12]
    5a72:	84a0      	strh	r0, [r4, #36]	; 0x24
    5a74:	6121      	str	r1, [r4, #16]
    5a76:	84e6      	strh	r6, [r4, #38]	; 0x26
    5a78:	bd70      	pop	{r4, r5, r6, pc}
    5a7a:	0000      	.short	0x0000
    5a7c:	200000c0 	.word	0x200000c0

00005a80 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ>:
    5a80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5a84:	b170      	cbz	r0, 5aa4 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x24>
    5a86:	2500      	movs	r5, #0
    5a88:	4411      	add	r1, r2
    5a8a:	b2cc      	uxtb	r4, r1
    5a8c:	4e25      	ldr	r6, [pc, #148]	; (5b24 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0xa4>)
    5a8e:	1cc1      	adds	r1, r0, #3
    5a90:	2700      	movs	r7, #0
    5a92:	f021 0103 	bic.w	r1, r1, #3
    5a96:	7034      	strb	r4, [r6, #0]
    5a98:	4281      	cmp	r1, r0
    5a9a:	d005      	beq.n	5aa8 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x28>
    5a9c:	214e      	movs	r1, #78	; 0x4e
    5a9e:	2009      	movs	r0, #9
    5aa0:	f7ff fb58 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5aa4:	2501      	movs	r5, #1
    5aa6:	e7ef      	b.n	5a88 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x8>
    5aa8:	2b1f      	cmp	r3, #31
    5aaa:	d804      	bhi.n	5ab6 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x36>
    5aac:	f64f 71ff 	movw	r1, #65535	; 0xffff
    5ab0:	ea01 0183 	and.w	r1, r1, r3, lsl #2
    5ab4:	e009      	b.n	5aca <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x4a>
    5ab6:	0059      	lsls	r1, r3, #1
    5ab8:	2bff      	cmp	r3, #255	; 0xff
    5aba:	d90c      	bls.n	5ad6 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x56>
    5abc:	f103 02ff 	add.w	r2, r3, #255	; 0xff
    5ac0:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    5ac4:	d200      	bcs.n	5ac8 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x48>
    5ac6:	4611      	mov	r1, r2
    5ac8:	b289      	uxth	r1, r1
    5aca:	f64f 72fc 	movw	r2, #65532	; 0xfffc
    5ace:	1cc9      	adds	r1, r1, #3
    5ad0:	4011      	ands	r1, r2
    5ad2:	b135      	cbz	r5, 5ae2 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x62>
    5ad4:	e007      	b.n	5ae6 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x66>
    5ad6:	227c      	movs	r2, #124	; 0x7c
    5ad8:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    5adc:	d3f4      	bcc.n	5ac8 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x48>
    5ade:	217c      	movs	r1, #124	; 0x7c
    5ae0:	e7f2      	b.n	5ac8 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x48>
    5ae2:	6070      	str	r0, [r6, #4]
    5ae4:	8071      	strh	r1, [r6, #2]
    5ae6:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    5aea:	eb07 03c2 	add.w	r3, r7, r2, lsl #3
    5aee:	2200      	movs	r2, #0
    5af0:	6876      	ldr	r6, [r6, #4]
    5af2:	f04f 0c01 	mov.w	ip, #1
    5af6:	e00d      	b.n	5b14 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x94>
    5af8:	b94d      	cbnz	r5, 5b0e <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x8e>
    5afa:	eb02 0782 	add.w	r7, r2, r2, lsl #2
    5afe:	eb00 0e03 	add.w	lr, r0, r3
    5b02:	f806 c037 	strb.w	ip, [r6, r7, lsl #3]
    5b06:	eb06 07c7 	add.w	r7, r6, r7, lsl #3
    5b0a:	f8c7 e004 	str.w	lr, [r7, #4]
    5b0e:	1c52      	adds	r2, r2, #1
    5b10:	440b      	add	r3, r1
    5b12:	b2d2      	uxtb	r2, r2
    5b14:	42a2      	cmp	r2, r4
    5b16:	d3ef      	bcc.n	5af8 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ+0x78>
    5b18:	1ddb      	adds	r3, r3, #7
    5b1a:	f023 0007 	bic.w	r0, r3, #7
    5b1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5b22:	0000      	.short	0x0000
    5b24:	200000c0 	.word	0x200000c0

00005b28 <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ>:
    5b28:	b570      	push	{r4, r5, r6, lr}
    5b2a:	4a10      	ldr	r2, [pc, #64]	; (5b6c <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ+0x44>)
    5b2c:	2000      	movs	r0, #0
    5b2e:	6851      	ldr	r1, [r2, #4]
    5b30:	7812      	ldrb	r2, [r2, #0]
    5b32:	e014      	b.n	5b5e <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ+0x36>
    5b34:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    5b38:	f811 3033 	ldrb.w	r3, [r1, r3, lsl #3]
    5b3c:	b16b      	cbz	r3, 5b5a <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ+0x32>
    5b3e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    5b42:	eb11 04c0 	adds.w	r4, r1, r0, lsl #3
    5b46:	d00c      	beq.n	5b62 <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ+0x3a>
    5b48:	2500      	movs	r5, #0
    5b4a:	70a5      	strb	r5, [r4, #2]
    5b4c:	2101      	movs	r1, #1
    5b4e:	4620      	mov	r0, r4
    5b50:	f7ff ff56 	bl	5a00 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x30>
    5b54:	7025      	strb	r5, [r4, #0]
    5b56:	4620      	mov	r0, r4
    5b58:	bd70      	pop	{r4, r5, r6, pc}
    5b5a:	1c40      	adds	r0, r0, #1
    5b5c:	b2c0      	uxtb	r0, r0
    5b5e:	4290      	cmp	r0, r2
    5b60:	d3e8      	bcc.n	5b34 <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ+0xc>
    5b62:	21a9      	movs	r1, #169	; 0xa9
    5b64:	2009      	movs	r0, #9
    5b66:	f7ff faf5 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5b6a:	0000      	.short	0x0000
    5b6c:	200000c0 	.word	0x200000c0

00005b70 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ>:
    5b70:	4804      	ldr	r0, [pc, #16]	; (5b84 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x14>)
    5b72:	b510      	push	{r4, lr}
    5b74:	8840      	ldrh	r0, [r0, #2]
    5b76:	0884      	lsrs	r4, r0, #2
    5b78:	f008 faea 	bl	e150 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x11a>
    5b7c:	4284      	cmp	r4, r0
    5b7e:	d300      	bcc.n	5b82 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x12>
    5b80:	4620      	mov	r0, r4
    5b82:	bd10      	pop	{r4, pc}
    5b84:	200000c0 	.word	0x200000c0
    5b88:	b530      	push	{r4, r5, lr}
    5b8a:	490d      	ldr	r1, [pc, #52]	; (5bc0 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x50>)
    5b8c:	2001      	movs	r0, #1
    5b8e:	6048      	str	r0, [r1, #4]
    5b90:	1e82      	subs	r2, r0, #2
    5b92:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    5b96:	490b      	ldr	r1, [pc, #44]	; (5bc4 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x54>)
    5b98:	6088      	str	r0, [r1, #8]
    5b9a:	2300      	movs	r3, #0
    5b9c:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
    5ba0:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    5ba4:	4c08      	ldr	r4, [pc, #32]	; (5bc8 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x58>)
    5ba6:	6023      	str	r3, [r4, #0]
    5ba8:	1d25      	adds	r5, r4, #4
    5baa:	6028      	str	r0, [r5, #0]
    5bac:	6088      	str	r0, [r1, #8]
    5bae:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    5bb2:	6023      	str	r3, [r4, #0]
    5bb4:	6028      	str	r0, [r5, #0]
    5bb6:	4906      	ldr	r1, [pc, #24]	; (5bd0 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x60>)
    5bb8:	4804      	ldr	r0, [pc, #16]	; (5bcc <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x5c>)
    5bba:	6008      	str	r0, [r1, #0]
    5bbc:	bd30      	pop	{r4, r5, pc}
    5bbe:	0000      	.short	0x0000
    5bc0:	4000e000 	.word	0x4000e000
    5bc4:	4000f000 	.word	0x4000f000
    5bc8:	4000f500 	.word	0x4000f500
    5bcc:	3ff60000 	.word	0x3ff60000
    5bd0:	4001f508 	.word	0x4001f508

00005bd4 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ>:
    5bd4:	b510      	push	{r4, lr}
    5bd6:	4604      	mov	r4, r0
    5bd8:	f7ff ffd6 	bl	5b88 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ+0x18>
    5bdc:	f008 fb8b 	bl	e2f6 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x42>
    5be0:	f000 f888 	bl	5cf4 <sym_RZ4KEX57U2ASIFFSRQDHBCB7WVJNTOCZSYKJFSA>
    5be4:	4905      	ldr	r1, [pc, #20]	; (5bfc <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x28>)
    5be6:	4804      	ldr	r0, [pc, #16]	; (5bf8 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x24>)
    5be8:	6008      	str	r0, [r1, #0]
    5bea:	4620      	mov	r0, r4
    5bec:	f000 f8b8 	bl	5d60 <sym_7YLXP6BHTAWWWMXLB5XOZU3Q27WEPTH5PONOKOI>
    5bf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    5bf4:	f000 b8d0 	b.w	5d98 <sym_O2AFZAWKVBYRIBDK67CHKRSMY4WR2S6V2VOPETI>
    5bf8:	3ff60000 	.word	0x3ff60000
    5bfc:	4001f508 	.word	0x4001f508
    5c00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5c04:	4682      	mov	sl, r0
    5c06:	4838      	ldr	r0, [pc, #224]	; (5ce8 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x114>)
    5c08:	f007 f951 	bl	ceae <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA>
    5c0c:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 5ce8 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x114>
    5c10:	b128      	cbz	r0, 5c1e <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x4a>
    5c12:	2601      	movs	r6, #1
    5c14:	f10b 0001 	add.w	r0, fp, #1
    5c18:	21ff      	movs	r1, #255	; 0xff
    5c1a:	7001      	strb	r1, [r0, #0]
    5c1c:	e000      	b.n	5c20 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x4c>
    5c1e:	2600      	movs	r6, #0
    5c20:	f44f 7580 	mov.w	r5, #256	; 0x100
    5c24:	4c31      	ldr	r4, [pc, #196]	; (5cec <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x118>)
    5c26:	f04f 0800 	mov.w	r8, #0
    5c2a:	1d2f      	adds	r7, r5, #4
    5c2c:	2101      	movs	r1, #1
    5c2e:	6061      	str	r1, [r4, #4]
    5c30:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
    5c34:	f8c4 8104 	str.w	r8, [r4, #260]	; 0x104
    5c38:	f8c4 a504 	str.w	sl, [r4, #1284]	; 0x504
    5c3c:	6021      	str	r1, [r4, #0]
    5c3e:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 5cf0 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x11c>
    5c42:	e01c      	b.n	5c7e <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xaa>
    5c44:	f8d9 0000 	ldr.w	r0, [r9]
    5c48:	06c0      	lsls	r0, r0, #27
    5c4a:	d518      	bpl.n	5c7e <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xaa>
    5c4c:	200e      	movs	r0, #14
    5c4e:	f008 fb61 	bl	e314 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x60>
    5c52:	f3ef 8010 	mrs	r0, PRIMASK
    5c56:	9000      	str	r0, [sp, #0]
    5c58:	b672      	cpsid	i
    5c5a:	2103      	movs	r1, #3
    5c5c:	4620      	mov	r0, r4
    5c5e:	f8c4 1304 	str.w	r1, [r4, #772]	; 0x304
    5c62:	4629      	mov	r1, r5
    5c64:	f008 fb63 	bl	e32e <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x7a>
    5c68:	b930      	cbnz	r0, 5c78 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xa4>
    5c6a:	4639      	mov	r1, r7
    5c6c:	4620      	mov	r0, r4
    5c6e:	f008 fb5e 	bl	e32e <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x7a>
    5c72:	b908      	cbnz	r0, 5c78 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xa4>
    5c74:	f7ff f8c8 	bl	4e08 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA>
    5c78:	9800      	ldr	r0, [sp, #0]
    5c7a:	b900      	cbnz	r0, 5c7e <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xaa>
    5c7c:	b662      	cpsie	i
    5c7e:	4629      	mov	r1, r5
    5c80:	4620      	mov	r0, r4
    5c82:	f008 fb54 	bl	e32e <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x7a>
    5c86:	b928      	cbnz	r0, 5c94 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xc0>
    5c88:	4639      	mov	r1, r7
    5c8a:	4620      	mov	r0, r4
    5c8c:	f008 fb4f 	bl	e32e <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x7a>
    5c90:	2800      	cmp	r0, #0
    5c92:	d0d7      	beq.n	5c44 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x70>
    5c94:	4639      	mov	r1, r7
    5c96:	4620      	mov	r0, r4
    5c98:	f008 fb49 	bl	e32e <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x7a>
    5c9c:	2800      	cmp	r0, #0
    5c9e:	d1c5      	bne.n	5c2c <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x58>
    5ca0:	bb06      	cbnz	r6, 5ce4 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x110>
    5ca2:	f89b 1001 	ldrb.w	r1, [fp, #1]
    5ca6:	f88d 1000 	strb.w	r1, [sp]
    5caa:	9900      	ldr	r1, [sp, #0]
    5cac:	9100      	str	r1, [sp, #0]
    5cae:	f89d 1000 	ldrb.w	r1, [sp]
    5cb2:	b109      	cbz	r1, 5cb8 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xe4>
    5cb4:	2501      	movs	r5, #1
    5cb6:	e000      	b.n	5cba <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0xe6>
    5cb8:	2500      	movs	r5, #0
    5cba:	f10b 0001 	add.w	r0, fp, #1
    5cbe:	f880 8000 	strb.w	r8, [r0]
    5cc2:	2003      	movs	r0, #3
    5cc4:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    5cc8:	f8c4 8104 	str.w	r8, [r4, #260]	; 0x104
    5ccc:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
    5cd0:	200e      	movs	r0, #14
    5cd2:	f008 fb1f 	bl	e314 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x60>
    5cd6:	4804      	ldr	r0, [pc, #16]	; (5ce8 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x114>)
    5cd8:	f007 f900 	bl	cedc <sym_OWJYSTADR5I36MIHWNPICVB7CMCWNSFIZPFXQ2Q>
    5cdc:	b115      	cbz	r5, 5ce4 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x110>
    5cde:	2011      	movs	r0, #17
    5ce0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5ce4:	2000      	movs	r0, #0
    5ce6:	e7fb      	b.n	5ce0 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x10c>
    5ce8:	20000328 	.word	0x20000328
    5cec:	4000e000 	.word	0x4000e000
    5cf0:	e000ed10 	.word	0xe000ed10

00005cf4 <sym_RZ4KEX57U2ASIFFSRQDHBCB7WVJNTOCZSYKJFSA>:
    5cf4:	b510      	push	{r4, lr}
    5cf6:	4806      	ldr	r0, [pc, #24]	; (5d10 <sym_RZ4KEX57U2ASIFFSRQDHBCB7WVJNTOCZSYKJFSA+0x1c>)
    5cf8:	f007 f8ec 	bl	ced4 <sym_YS3AHD7GWBHZEQHPIQANPGALEXB4QGY5O2DQKRY>
    5cfc:	b118      	cbz	r0, 5d06 <sym_RZ4KEX57U2ASIFFSRQDHBCB7WVJNTOCZSYKJFSA+0x12>
    5cfe:	2127      	movs	r1, #39	; 0x27
    5d00:	201d      	movs	r0, #29
    5d02:	f7ff fa27 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5d06:	4802      	ldr	r0, [pc, #8]	; (5d10 <sym_RZ4KEX57U2ASIFFSRQDHBCB7WVJNTOCZSYKJFSA+0x1c>)
    5d08:	2100      	movs	r1, #0
    5d0a:	7041      	strb	r1, [r0, #1]
    5d0c:	bd10      	pop	{r4, pc}
    5d0e:	0000      	.short	0x0000
    5d10:	20000328 	.word	0x20000328

00005d14 <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI>:
    5d14:	b570      	push	{r4, r5, r6, lr}
    5d16:	4911      	ldr	r1, [pc, #68]	; (5d5c <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI+0x48>)
    5d18:	680a      	ldr	r2, [r1, #0]
    5d1a:	b1ea      	cbz	r2, 5d58 <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI+0x44>
    5d1c:	2300      	movs	r3, #0
    5d1e:	461d      	mov	r5, r3
    5d20:	2401      	movs	r4, #1
    5d22:	684a      	ldr	r2, [r1, #4]
    5d24:	1c52      	adds	r2, r2, #1
    5d26:	604a      	str	r2, [r1, #4]
    5d28:	2a09      	cmp	r2, #9
    5d2a:	d300      	bcc.n	5d2e <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI+0x1a>
    5d2c:	604d      	str	r5, [r1, #4]
    5d2e:	790e      	ldrb	r6, [r1, #4]
    5d30:	fa04 f206 	lsl.w	r2, r4, r6
    5d34:	680e      	ldr	r6, [r1, #0]
    5d36:	4216      	tst	r6, r2
    5d38:	d00b      	beq.n	5d52 <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI+0x3e>
    5d3a:	f3ef 8310 	mrs	r3, PRIMASK
    5d3e:	b672      	cpsid	i
    5d40:	680c      	ldr	r4, [r1, #0]
    5d42:	4394      	bics	r4, r2
    5d44:	600c      	str	r4, [r1, #0]
    5d46:	b903      	cbnz	r3, 5d4a <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI+0x36>
    5d48:	b662      	cpsie	i
    5d4a:	6849      	ldr	r1, [r1, #4]
    5d4c:	6001      	str	r1, [r0, #0]
    5d4e:	2000      	movs	r0, #0
    5d50:	bd70      	pop	{r4, r5, r6, pc}
    5d52:	1c5b      	adds	r3, r3, #1
    5d54:	2b09      	cmp	r3, #9
    5d56:	d3e4      	bcc.n	5d22 <sym_YRXVGCYVFXOSIQO43AC5UEELHEXP2A4UAFUQRPI+0xe>
    5d58:	2005      	movs	r0, #5
    5d5a:	bd70      	pop	{r4, r5, r6, pc}
    5d5c:	200000c8 	.word	0x200000c8

00005d60 <sym_7YLXP6BHTAWWWMXLB5XOZU3Q27WEPTH5PONOKOI>:
    5d60:	4802      	ldr	r0, [pc, #8]	; (5d6c <sym_7YLXP6BHTAWWWMXLB5XOZU3Q27WEPTH5PONOKOI+0xc>)
    5d62:	2100      	movs	r1, #0
    5d64:	6001      	str	r1, [r0, #0]
    5d66:	6041      	str	r1, [r0, #4]
    5d68:	4770      	bx	lr
    5d6a:	0000      	.short	0x0000
    5d6c:	200000c8 	.word	0x200000c8

00005d70 <sym_QFSP7NEBRUPCXI7KU3RYDOWD7SSPVNXVSULPYYY>:
    5d70:	b510      	push	{r4, lr}
    5d72:	4c08      	ldr	r4, [pc, #32]	; (5d94 <sym_QFSP7NEBRUPCXI7KU3RYDOWD7SSPVNXVSULPYYY+0x24>)
    5d74:	7861      	ldrb	r1, [r4, #1]
    5d76:	b109      	cbz	r1, 5d7c <sym_QFSP7NEBRUPCXI7KU3RYDOWD7SSPVNXVSULPYYY+0xc>
    5d78:	200f      	movs	r0, #15
    5d7a:	bd10      	pop	{r4, pc}
    5d7c:	f7fe ffd0 	bl	4d20 <sym_W7ROFHNOSDKPIRUKDGIZZ5YR3MC3DAM2YLJOUIA>
    5d80:	7020      	strb	r0, [r4, #0]
    5d82:	28ff      	cmp	r0, #255	; 0xff
    5d84:	d001      	beq.n	5d8a <sym_QFSP7NEBRUPCXI7KU3RYDOWD7SSPVNXVSULPYYY+0x1a>
    5d86:	2000      	movs	r0, #0
    5d88:	bd10      	pop	{r4, pc}
    5d8a:	2178      	movs	r1, #120	; 0x78
    5d8c:	201f      	movs	r0, #31
    5d8e:	f7ff f9e1 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5d92:	0000      	.short	0x0000
    5d94:	20000000 	.word	0x20000000

00005d98 <sym_O2AFZAWKVBYRIBDK67CHKRSMY4WR2S6V2VOPETI>:
    5d98:	4901      	ldr	r1, [pc, #4]	; (5da0 <sym_O2AFZAWKVBYRIBDK67CHKRSMY4WR2S6V2VOPETI+0x8>)
    5d9a:	2000      	movs	r0, #0
    5d9c:	7048      	strb	r0, [r1, #1]
    5d9e:	4770      	bx	lr
    5da0:	20000000 	.word	0x20000000

00005da4 <sym_V7MOOXL5SOLISKFFGWJC7M3XDITU574WBQOXGWY>:
    5da4:	4806      	ldr	r0, [pc, #24]	; (5dc0 <sym_V7MOOXL5SOLISKFFGWJC7M3XDITU574WBQOXGWY+0x1c>)
    5da6:	4a07      	ldr	r2, [pc, #28]	; (5dc4 <sym_V7MOOXL5SOLISKFFGWJC7M3XDITU574WBQOXGWY+0x20>)
    5da8:	8c81      	ldrh	r1, [r0, #36]	; 0x24
    5daa:	8852      	ldrh	r2, [r2, #2]
    5dac:	4291      	cmp	r1, r2
    5dae:	d104      	bne.n	5dba <sym_V7MOOXL5SOLISKFFGWJC7M3XDITU574WBQOXGWY+0x16>
    5db0:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
    5db4:	b108      	cbz	r0, 5dba <sym_V7MOOXL5SOLISKFFGWJC7M3XDITU574WBQOXGWY+0x16>
    5db6:	2000      	movs	r0, #0
    5db8:	4770      	bx	lr
    5dba:	2001      	movs	r0, #1
    5dbc:	4770      	bx	lr
    5dbe:	0000      	.short	0x0000
    5dc0:	200018dc 	.word	0x200018dc
    5dc4:	20000314 	.word	0x20000314

00005dc8 <sym_IXGTNRGKILIZPWG2NJIZ2ALUPW2IM3XFVCGJW2I>:
    5dc8:	4901      	ldr	r1, [pc, #4]	; (5dd0 <sym_IXGTNRGKILIZPWG2NJIZ2ALUPW2IM3XFVCGJW2I+0x8>)
    5dca:	8048      	strh	r0, [r1, #2]
    5dcc:	4770      	bx	lr
    5dce:	0000      	.short	0x0000
    5dd0:	20000314 	.word	0x20000314

00005dd4 <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y>:
    5dd4:	4808      	ldr	r0, [pc, #32]	; (5df8 <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y+0x24>)
    5dd6:	4a09      	ldr	r2, [pc, #36]	; (5dfc <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y+0x28>)
    5dd8:	8c81      	ldrh	r1, [r0, #36]	; 0x24
    5dda:	8852      	ldrh	r2, [r2, #2]
    5ddc:	4291      	cmp	r1, r2
    5dde:	d109      	bne.n	5df4 <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y+0x20>
    5de0:	f64f 71ff 	movw	r1, #65535	; 0xffff
    5de4:	8481      	strh	r1, [r0, #36]	; 0x24
    5de6:	f810 1f22 	ldrb.w	r1, [r0, #34]!
    5dea:	b119      	cbz	r1, 5df4 <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y+0x20>
    5dec:	2100      	movs	r1, #0
    5dee:	7001      	strb	r1, [r0, #0]
    5df0:	2001      	movs	r0, #1
    5df2:	4770      	bx	lr
    5df4:	2000      	movs	r0, #0
    5df6:	4770      	bx	lr
    5df8:	200018dc 	.word	0x200018dc
    5dfc:	20000314 	.word	0x20000314

00005e00 <sym_AGWGY6I3YKHHV6TMAWL24HN4IKGOB7PZYXPWBRA>:
    5e00:	4807      	ldr	r0, [pc, #28]	; (5e20 <sym_AGWGY6I3YKHHV6TMAWL24HN4IKGOB7PZYXPWBRA+0x20>)
    5e02:	f810 1f22 	ldrb.w	r1, [r0, #34]!
    5e06:	2901      	cmp	r1, #1
    5e08:	d007      	beq.n	5e1a <sym_AGWGY6I3YKHHV6TMAWL24HN4IKGOB7PZYXPWBRA+0x1a>
    5e0a:	2101      	movs	r1, #1
    5e0c:	7001      	strb	r1, [r0, #0]
    5e0e:	4805      	ldr	r0, [pc, #20]	; (5e24 <sym_AGWGY6I3YKHHV6TMAWL24HN4IKGOB7PZYXPWBRA+0x24>)
    5e10:	4903      	ldr	r1, [pc, #12]	; (5e20 <sym_AGWGY6I3YKHHV6TMAWL24HN4IKGOB7PZYXPWBRA+0x20>)
    5e12:	8800      	ldrh	r0, [r0, #0]
    5e14:	8488      	strh	r0, [r1, #36]	; 0x24
    5e16:	2001      	movs	r0, #1
    5e18:	4770      	bx	lr
    5e1a:	2000      	movs	r0, #0
    5e1c:	4770      	bx	lr
    5e1e:	0000      	.short	0x0000
    5e20:	200018dc 	.word	0x200018dc
    5e24:	20000314 	.word	0x20000314

00005e28 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI>:
    5e28:	4906      	ldr	r1, [pc, #24]	; (5e44 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI+0x1c>)
    5e2a:	4b07      	ldr	r3, [pc, #28]	; (5e48 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI+0x20>)
    5e2c:	8c8a      	ldrh	r2, [r1, #36]	; 0x24
    5e2e:	885b      	ldrh	r3, [r3, #2]
    5e30:	429a      	cmp	r2, r3
    5e32:	d105      	bne.n	5e40 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI+0x18>
    5e34:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
    5e38:	b112      	cbz	r2, 5e40 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI+0x18>
    5e3a:	6001      	str	r1, [r0, #0]
    5e3c:	2001      	movs	r0, #1
    5e3e:	4770      	bx	lr
    5e40:	2000      	movs	r0, #0
    5e42:	4770      	bx	lr
    5e44:	200018dc 	.word	0x200018dc
    5e48:	20000314 	.word	0x20000314

00005e4c <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI>:
    5e4c:	4909      	ldr	r1, [pc, #36]	; (5e74 <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI+0x28>)
    5e4e:	8c8a      	ldrh	r2, [r1, #36]	; 0x24
    5e50:	f5a2 437f 	sub.w	r3, r2, #65280	; 0xff00
    5e54:	3bff      	subs	r3, #255	; 0xff
    5e56:	d002      	beq.n	5e5e <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI+0x12>
    5e58:	2100      	movs	r1, #0
    5e5a:	6001      	str	r1, [r0, #0]
    5e5c:	e007      	b.n	5e6e <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI+0x22>
    5e5e:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
    5e62:	4904      	ldr	r1, [pc, #16]	; (5e74 <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI+0x28>)
    5e64:	2a01      	cmp	r2, #1
    5e66:	d002      	beq.n	5e6e <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI+0x22>
    5e68:	6001      	str	r1, [r0, #0]
    5e6a:	2001      	movs	r0, #1
    5e6c:	4770      	bx	lr
    5e6e:	2000      	movs	r0, #0
    5e70:	4770      	bx	lr
    5e72:	0000      	.short	0x0000
    5e74:	200018dc 	.word	0x200018dc

00005e78 <sym_NKFCLZ5HTE6KVHDV5DGZ6TJP4KSZI43SYBECPRY>:
    5e78:	4901      	ldr	r1, [pc, #4]	; (5e80 <sym_NKFCLZ5HTE6KVHDV5DGZ6TJP4KSZI43SYBECPRY+0x8>)
    5e7a:	8008      	strh	r0, [r1, #0]
    5e7c:	4770      	bx	lr
    5e7e:	0000      	.short	0x0000
    5e80:	20000314 	.word	0x20000314

00005e84 <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY>:
    5e84:	4905      	ldr	r1, [pc, #20]	; (5e9c <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY+0x18>)
    5e86:	2000      	movs	r0, #0
    5e88:	f881 0022 	strb.w	r0, [r1, #34]	; 0x22
    5e8c:	f64f 70ff 	movw	r0, #65535	; 0xffff
    5e90:	8488      	strh	r0, [r1, #36]	; 0x24
    5e92:	4903      	ldr	r1, [pc, #12]	; (5ea0 <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY+0x1c>)
    5e94:	8008      	strh	r0, [r1, #0]
    5e96:	8048      	strh	r0, [r1, #2]
    5e98:	4770      	bx	lr
    5e9a:	0000      	.short	0x0000
    5e9c:	200018dc 	.word	0x200018dc
    5ea0:	20000314 	.word	0x20000314
    5ea4:	4905      	ldr	r1, [pc, #20]	; (5ebc <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY+0x38>)
    5ea6:	8c8a      	ldrh	r2, [r1, #36]	; 0x24
    5ea8:	4282      	cmp	r2, r0
    5eaa:	d105      	bne.n	5eb8 <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY+0x34>
    5eac:	2000      	movs	r0, #0
    5eae:	f881 0022 	strb.w	r0, [r1, #34]	; 0x22
    5eb2:	f64f 70ff 	movw	r0, #65535	; 0xffff
    5eb6:	8488      	strh	r0, [r1, #36]	; 0x24
    5eb8:	4770      	bx	lr
    5eba:	0000      	.short	0x0000
    5ebc:	200018dc 	.word	0x200018dc

00005ec0 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI>:
    5ec0:	4a0a      	ldr	r2, [pc, #40]	; (5eec <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0x2c>)
    5ec2:	b110      	cbz	r0, 5eca <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0xa>
    5ec4:	2801      	cmp	r0, #1
    5ec6:	d007      	beq.n	5ed8 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0x18>
    5ec8:	e00e      	b.n	5ee8 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0x28>
    5eca:	7850      	ldrb	r0, [r2, #1]
    5ecc:	b160      	cbz	r0, 5ee8 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0x28>
    5ece:	f8d2 0002 	ldr.w	r0, [r2, #2]
    5ed2:	6008      	str	r0, [r1, #0]
    5ed4:	88d0      	ldrh	r0, [r2, #6]
    5ed6:	e004      	b.n	5ee2 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0x22>
    5ed8:	7810      	ldrb	r0, [r2, #0]
    5eda:	b128      	cbz	r0, 5ee8 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI+0x28>
    5edc:	6890      	ldr	r0, [r2, #8]
    5ede:	6008      	str	r0, [r1, #0]
    5ee0:	8990      	ldrh	r0, [r2, #12]
    5ee2:	8088      	strh	r0, [r1, #4]
    5ee4:	2001      	movs	r0, #1
    5ee6:	4770      	bx	lr
    5ee8:	2000      	movs	r0, #0
    5eea:	4770      	bx	lr
    5eec:	2000032a 	.word	0x2000032a

00005ef0 <sym_QKSVBALUN2V4XT4OCC56LE75IAYLDFRRIVLBZ2Q>:
    5ef0:	4a08      	ldr	r2, [pc, #32]	; (5f14 <sym_QKSVBALUN2V4XT4OCC56LE75IAYLDFRRIVLBZ2Q+0x24>)
    5ef2:	2301      	movs	r3, #1
    5ef4:	b138      	cbz	r0, 5f06 <sym_QKSVBALUN2V4XT4OCC56LE75IAYLDFRRIVLBZ2Q+0x16>
    5ef6:	2801      	cmp	r0, #1
    5ef8:	d104      	bne.n	5f04 <sym_QKSVBALUN2V4XT4OCC56LE75IAYLDFRRIVLBZ2Q+0x14>
    5efa:	7013      	strb	r3, [r2, #0]
    5efc:	6808      	ldr	r0, [r1, #0]
    5efe:	6090      	str	r0, [r2, #8]
    5f00:	8888      	ldrh	r0, [r1, #4]
    5f02:	8190      	strh	r0, [r2, #12]
    5f04:	4770      	bx	lr
    5f06:	7053      	strb	r3, [r2, #1]
    5f08:	6808      	ldr	r0, [r1, #0]
    5f0a:	f8c2 0002 	str.w	r0, [r2, #2]
    5f0e:	8888      	ldrh	r0, [r1, #4]
    5f10:	80d0      	strh	r0, [r2, #6]
    5f12:	4770      	bx	lr
    5f14:	2000032a 	.word	0x2000032a

00005f18 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A>:
    5f18:	4906      	ldr	r1, [pc, #24]	; (5f34 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A+0x1c>)
    5f1a:	b110      	cbz	r0, 5f22 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A+0xa>
    5f1c:	2801      	cmp	r0, #1
    5f1e:	d002      	beq.n	5f26 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A+0xe>
    5f20:	e005      	b.n	5f2e <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A+0x16>
    5f22:	7848      	ldrb	r0, [r1, #1]
    5f24:	e000      	b.n	5f28 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A+0x10>
    5f26:	7808      	ldrb	r0, [r1, #0]
    5f28:	b108      	cbz	r0, 5f2e <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A+0x16>
    5f2a:	2001      	movs	r0, #1
    5f2c:	4770      	bx	lr
    5f2e:	2000      	movs	r0, #0
    5f30:	4770      	bx	lr
    5f32:	0000      	.short	0x0000
    5f34:	2000032a 	.word	0x2000032a

00005f38 <sym_4UMPVHCMNEM5ENBBHCLGXZREGEKKHKHZOKNMH2I>:
    5f38:	4901      	ldr	r1, [pc, #4]	; (5f40 <sym_4UMPVHCMNEM5ENBBHCLGXZREGEKKHKHZOKNMH2I+0x8>)
    5f3a:	7708      	strb	r0, [r1, #28]
    5f3c:	4770      	bx	lr
    5f3e:	0000      	.short	0x0000
    5f40:	20001192 	.word	0x20001192

00005f44 <sym_IHWHOAENEU2EYZP2UWQTUC6SSXGS5NNQSIFSEAQ>:
    5f44:	4801      	ldr	r0, [pc, #4]	; (5f4c <sym_IHWHOAENEU2EYZP2UWQTUC6SSXGS5NNQSIFSEAQ+0x8>)
    5f46:	78c0      	ldrb	r0, [r0, #3]
    5f48:	4770      	bx	lr
    5f4a:	0000      	.short	0x0000
    5f4c:	200000d0 	.word	0x200000d0

00005f50 <sym_Q3RLGT2MQM6S4H2ODVJHPDU44HGSYVXJV7676ZY>:
    5f50:	4801      	ldr	r0, [pc, #4]	; (5f58 <sym_Q3RLGT2MQM6S4H2ODVJHPDU44HGSYVXJV7676ZY+0x8>)
    5f52:	7900      	ldrb	r0, [r0, #4]
    5f54:	4770      	bx	lr
    5f56:	0000      	.short	0x0000
    5f58:	200000d0 	.word	0x200000d0

00005f5c <sym_TMJZXA73A2C5DMM5JAVJMETINB7KCHBEWVPWZQI>:
    5f5c:	4608      	mov	r0, r1
    5f5e:	2100      	movs	r1, #0
    5f60:	7041      	strb	r1, [r0, #1]
    5f62:	211a      	movs	r1, #26
    5f64:	f800 1b04 	strb.w	r1, [r0], #4
    5f68:	220e      	movs	r2, #14
    5f6a:	4901      	ldr	r1, [pc, #4]	; (5f70 <sym_TMJZXA73A2C5DMM5JAVJMETINB7KCHBEWVPWZQI+0x14>)
    5f6c:	f007 b836 	b.w	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    5f70:	200011a0 	.word	0x200011a0

00005f74 <sym_ULQ236TSMK6UJATLJCXSX5JBKSVB4ZM2NNU74PA>:
    5f74:	b510      	push	{r4, lr}
    5f76:	4604      	mov	r4, r0
    5f78:	f000 f952 	bl	6220 <sym_CZFK26FRDZ53FUV75DOIMFWVD4RTHYB6I22U4LA>
    5f7c:	b118      	cbz	r0, 5f86 <sym_ULQ236TSMK6UJATLJCXSX5JBKSVB4ZM2NNU74PA+0x12>
    5f7e:	21c2      	movs	r1, #194	; 0xc2
    5f80:	2027      	movs	r0, #39	; 0x27
    5f82:	f7ff f8e7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    5f86:	4803      	ldr	r0, [pc, #12]	; (5f94 <sym_ULQ236TSMK6UJATLJCXSX5JBKSVB4ZM2NNU74PA+0x20>)
    5f88:	2101      	movs	r1, #1
    5f8a:	f008 fddb 	bl	eb44 <sym_KWWW3Q4Z6LMHA6EXR6CMFCOS3QXXZ636XUAHVBY>
    5f8e:	4802      	ldr	r0, [pc, #8]	; (5f98 <sym_ULQ236TSMK6UJATLJCXSX5JBKSVB4ZM2NNU74PA+0x24>)
    5f90:	62c4      	str	r4, [r0, #44]	; 0x2c
    5f92:	bd10      	pop	{r4, pc}
    5f94:	20001170 	.word	0x20001170
    5f98:	200000d0 	.word	0x200000d0

00005f9c <sym_4OWM6DBJ6JLAWH2MVU52MKC56VOOJLN34T33LQA>:
    5f9c:	4901      	ldr	r1, [pc, #4]	; (5fa4 <sym_4OWM6DBJ6JLAWH2MVU52MKC56VOOJLN34T33LQA+0x8>)
    5f9e:	2001      	movs	r0, #1
    5fa0:	7188      	strb	r0, [r1, #6]
    5fa2:	4770      	bx	lr
    5fa4:	200000d0 	.word	0x200000d0

00005fa8 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q>:
    5fa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5fac:	4c5e      	ldr	r4, [pc, #376]	; (6128 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x180>)
    5fae:	9d06      	ldr	r5, [sp, #24]
    5fb0:	7826      	ldrb	r6, [r4, #0]
    5fb2:	2e00      	cmp	r6, #0
    5fb4:	d16b      	bne.n	608e <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xe6>
    5fb6:	2a00      	cmp	r2, #0
    5fb8:	d069      	beq.n	608e <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xe6>
    5fba:	2b00      	cmp	r3, #0
    5fbc:	d067      	beq.n	608e <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xe6>
    5fbe:	2d00      	cmp	r5, #0
    5fc0:	d065      	beq.n	608e <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xe6>
    5fc2:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
    5fc6:	f104 0614 	add.w	r6, r4, #20
    5fca:	2000      	movs	r0, #0
    5fcc:	e886 002c 	stmia.w	r6, {r2, r3, r5}
    5fd0:	71a0      	strb	r0, [r4, #6]
    5fd2:	7160      	strb	r0, [r4, #5]
    5fd4:	70e0      	strb	r0, [r4, #3]
    5fd6:	70a0      	strb	r0, [r4, #2]
    5fd8:	7120      	strb	r0, [r4, #4]
    5fda:	81a0      	strh	r0, [r4, #12]
    5fdc:	81e0      	strh	r0, [r4, #14]
    5fde:	f000 f957 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    5fe2:	4606      	mov	r6, r0
    5fe4:	f000 f94e 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    5fe8:	4605      	mov	r5, r0
    5fea:	f005 ff35 	bl	be58 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI>
    5fee:	f005 fc8d 	bl	b90c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ>
    5ff2:	f995 0072 	ldrsb.w	r0, [r5, #114]	; 0x72
    5ff6:	f005 ffb3 	bl	bf60 <sym_HE5JGYEZFIITGQL7PMATDHSORSCK7HJIY5UXOZA>
    5ffa:	f105 001c 	add.w	r0, r5, #28
    5ffe:	f006 f885 	bl	c10c <sym_XD56LJG2JTRU4Q2V7WCY72EI3VTZICA3O4ERV2A>
    6002:	6968      	ldr	r0, [r5, #20]
    6004:	f006 f878 	bl	c0f8 <sym_YLRTPBVG5ROXKOW4KXUYITRUY3FD2MVZW5LF7ZA>
    6008:	f896 0024 	ldrb.w	r0, [r6, #36]	; 0x24
    600c:	f006 f8b2 	bl	c174 <sym_ZQE76VUU7S5U7DETTZA65E75LHFWL5PGRN4JPHI>
    6010:	f104 0038 	add.w	r0, r4, #56	; 0x38
    6014:	6840      	ldr	r0, [r0, #4]
    6016:	f890 01c6 	ldrb.w	r0, [r0, #454]	; 0x1c6
    601a:	b108      	cbz	r0, 6020 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x78>
    601c:	f005 fe9c 	bl	bd58 <sym_YUNWMAOOL6VPZ57LS54EAM7TJ65IEHYU7XKGKUI>
    6020:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
    6024:	2001      	movs	r0, #1
    6026:	f005 fddb 	bl	bbe0 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I>
    602a:	2800      	cmp	r0, #0
    602c:	d075      	beq.n	611a <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x172>
    602e:	483f      	ldr	r0, [pc, #252]	; (612c <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x184>)
    6030:	f005 fe42 	bl	bcb8 <sym_YG4UROEKVB7ZBE5TWHLNJHYKSFBTXGBYAX3RXRI>
    6034:	8828      	ldrh	r0, [r5, #0]
    6036:	f7ff fccb 	bl	59d0 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA>
    603a:	6320      	str	r0, [r4, #48]	; 0x30
    603c:	8828      	ldrh	r0, [r5, #0]
    603e:	f7ff fcb1 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    6042:	6360      	str	r0, [r4, #52]	; 0x34
    6044:	3678      	adds	r6, #120	; 0x78
    6046:	483a      	ldr	r0, [pc, #232]	; (6130 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x188>)
    6048:	ce8e      	ldmia	r6!, {r1, r2, r3, r7}
    604a:	f100 0808 	add.w	r8, r0, #8
    604e:	e888 008e 	stmia.w	r8, {r1, r2, r3, r7}
    6052:	f856 1b04 	ldr.w	r1, [r6], #4
    6056:	f8c0 1021 	str.w	r1, [r0, #33]	; 0x21
    605a:	f856 198c 	ldr.w	r1, [r6], #-140
    605e:	f8c0 1025 	str.w	r1, [r0, #37]	; 0x25
    6062:	f000 f999 	bl	6398 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x15c>
    6066:	4601      	mov	r1, r0
    6068:	8fa8      	ldrh	r0, [r5, #60]	; 0x3c
    606a:	f008 fadc 	bl	e626 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y>
    606e:	8f29      	ldrh	r1, [r5, #56]	; 0x38
    6070:	4281      	cmp	r1, r0
    6072:	d200      	bcs.n	6076 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xce>
    6074:	4608      	mov	r0, r1
    6076:	7220      	strb	r0, [r4, #8]
    6078:	46a0      	mov	r8, r4
    607a:	f895 106f 	ldrb.w	r1, [r5, #111]	; 0x6f
    607e:	f8b5 0042 	ldrh.w	r0, [r5, #66]	; 0x42
    6082:	7d37      	ldrb	r7, [r6, #20]
    6084:	f8b5 4040 	ldrh.w	r4, [r5, #64]	; 0x40
    6088:	2908      	cmp	r1, #8
    608a:	d104      	bne.n	6096 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xee>
    608c:	e002      	b.n	6094 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xec>
    608e:	f44f 718d 	mov.w	r1, #282	; 0x11a
    6092:	e046      	b.n	6122 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x17a>
    6094:	2104      	movs	r1, #4
    6096:	f008 fac6 	bl	e626 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y>
    609a:	b90f      	cbnz	r7, 60a0 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xf8>
    609c:	1d00      	adds	r0, r0, #4
    609e:	b280      	uxth	r0, r0
    60a0:	4284      	cmp	r4, r0
    60a2:	d200      	bcs.n	60a6 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0xfe>
    60a4:	4620      	mov	r0, r4
    60a6:	b2c4      	uxtb	r4, r0
    60a8:	f888 4009 	strb.w	r4, [r8, #9]
    60ac:	7d31      	ldrb	r1, [r6, #20]
    60ae:	2900      	cmp	r1, #0
    60b0:	d002      	beq.n	60b8 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x110>
    60b2:	bf00      	nop
    60b4:	f04f 0104 	mov.w	r1, #4
    60b8:	4421      	add	r1, r4
    60ba:	f888 1007 	strb.w	r1, [r8, #7]
    60be:	d014      	beq.n	60ea <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x142>
    60c0:	481b      	ldr	r0, [pc, #108]	; (6130 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x188>)
    60c2:	f04f 0701 	mov.w	r7, #1
    60c6:	f100 0008 	add.w	r0, r0, #8
    60ca:	7607      	strb	r7, [r0, #24]
    60cc:	e9d6 121c 	ldrd	r1, r2, [r6, #112]	; 0x70
    60d0:	e9c0 1204 	strd	r1, r2, [r0, #16]
    60d4:	f895 006f 	ldrb.w	r0, [r5, #111]	; 0x6f
    60d8:	f008 f9ba 	bl	e450 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x18>
    60dc:	4914      	ldr	r1, [pc, #80]	; (6130 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x188>)
    60de:	4603      	mov	r3, r0
    60e0:	4622      	mov	r2, r4
    60e2:	3108      	adds	r1, #8
    60e4:	4638      	mov	r0, r7
    60e6:	f005 fb7d 	bl	b7e4 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA>
    60ea:	2001      	movs	r0, #1
    60ec:	f000 fb9a 	bl	6824 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5e8>
    60f0:	4810      	ldr	r0, [pc, #64]	; (6134 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x18c>)
    60f2:	6800      	ldr	r0, [r0, #0]
    60f4:	2803      	cmp	r0, #3
    60f6:	d012      	beq.n	611e <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x176>
    60f8:	280b      	cmp	r0, #11
    60fa:	d010      	beq.n	611e <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x176>
    60fc:	480c      	ldr	r0, [pc, #48]	; (6130 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x188>)
    60fe:	220e      	movs	r2, #14
    6100:	2100      	movs	r1, #0
    6102:	3052      	adds	r0, #82	; 0x52
    6104:	f006 ffe4 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    6108:	4809      	ldr	r0, [pc, #36]	; (6130 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q+0x188>)
    610a:	88b1      	ldrh	r1, [r6, #4]
    610c:	3052      	adds	r0, #82	; 0x52
    610e:	8041      	strh	r1, [r0, #2]
    6110:	8829      	ldrh	r1, [r5, #0]
    6112:	8001      	strh	r1, [r0, #0]
    6114:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
    6118:	7101      	strb	r1, [r0, #4]
    611a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    611e:	f240 11d5 	movw	r1, #469	; 0x1d5
    6122:	2027      	movs	r0, #39	; 0x27
    6124:	f7ff f816 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6128:	200000d0 	.word	0x200000d0
    612c:	00006a24 	.word	0x00006a24
    6130:	20001140 	.word	0x20001140
    6134:	40001550 	.word	0x40001550

00006138 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ>:
    6138:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    613c:	4605      	mov	r5, r0
    613e:	f000 f8a7 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    6142:	4e32      	ldr	r6, [pc, #200]	; (620c <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xd4>)
    6144:	4604      	mov	r4, r0
    6146:	f04f 0800 	mov.w	r8, #0
    614a:	6a70      	ldr	r0, [r6, #36]	; 0x24
    614c:	7847      	ldrb	r7, [r0, #1]
    614e:	b10d      	cbz	r5, 6154 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x1c>
    6150:	2d01      	cmp	r5, #1
    6152:	d101      	bne.n	6158 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x20>
    6154:	f886 8001 	strb.w	r8, [r6, #1]
    6158:	7870      	ldrb	r0, [r6, #1]
    615a:	f04f 0901 	mov.w	r9, #1
    615e:	b150      	cbz	r0, 6176 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x3e>
    6160:	2801      	cmp	r0, #1
    6162:	d01a      	beq.n	619a <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x62>
    6164:	2802      	cmp	r0, #2
    6166:	d034      	beq.n	61d2 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x9a>
    6168:	2803      	cmp	r0, #3
    616a:	d048      	beq.n	61fe <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xc6>
    616c:	f240 411d 	movw	r1, #1053	; 0x41d
    6170:	2027      	movs	r0, #39	; 0x27
    6172:	f7fe ffef 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6176:	2d01      	cmp	r5, #1
    6178:	d032      	beq.n	61e0 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xa8>
    617a:	f000 f8f9 	bl	6370 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x134>
    617e:	4639      	mov	r1, r7
    6180:	2201      	movs	r2, #1
    6182:	6b70      	ldr	r0, [r6, #52]	; 0x34
    6184:	f007 fcbe 	bl	db04 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y>
    6188:	e028      	b.n	61dc <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xa4>
    618a:	bf00      	nop
    618c:	f884 8008 	strb.w	r8, [r4, #8]
    6190:	e031      	b.n	61f6 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xbe>
    6192:	bf00      	nop
    6194:	f884 9008 	strb.w	r9, [r4, #8]
    6198:	e02d      	b.n	61f6 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xbe>
    619a:	2d01      	cmp	r5, #1
    619c:	d008      	beq.n	61b0 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x78>
    619e:	f000 f8e7 	bl	6370 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x134>
    61a2:	4639      	mov	r1, r7
    61a4:	2200      	movs	r2, #0
    61a6:	6b70      	ldr	r0, [r6, #52]	; 0x34
    61a8:	f007 fcac 	bl	db04 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y>
    61ac:	2d02      	cmp	r5, #2
    61ae:	d00b      	beq.n	61c8 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x90>
    61b0:	e9d4 011c 	ldrd	r0, r1, [r4, #112]	; 0x70
    61b4:	1c40      	adds	r0, r0, #1
    61b6:	f141 0100 	adc.w	r1, r1, #0
    61ba:	e9c4 011c 	strd	r0, r1, [r4, #112]	; 0x70
    61be:	7a20      	ldrb	r0, [r4, #8]
    61c0:	2801      	cmp	r0, #1
    61c2:	d003      	beq.n	61cc <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x94>
    61c4:	f884 9008 	strb.w	r9, [r4, #8]
    61c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    61cc:	f884 8008 	strb.w	r8, [r4, #8]
    61d0:	e7fa      	b.n	61c8 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x90>
    61d2:	2d01      	cmp	r5, #1
    61d4:	d004      	beq.n	61e0 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xa8>
    61d6:	6b70      	ldr	r0, [r6, #52]	; 0x34
    61d8:	f007 fe93 	bl	df02 <sym_W4P456NK4DQPUF5QVP3W7JSFZJTVGAOKAMSTNSQ>
    61dc:	2d02      	cmp	r5, #2
    61de:	d0f3      	beq.n	61c8 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x90>
    61e0:	e9d4 011c 	ldrd	r0, r1, [r4, #112]	; 0x70
    61e4:	1c40      	adds	r0, r0, #1
    61e6:	f141 0100 	adc.w	r1, r1, #0
    61ea:	e9c4 011c 	strd	r0, r1, [r4, #112]	; 0x70
    61ee:	7a20      	ldrb	r0, [r4, #8]
    61f0:	2801      	cmp	r0, #1
    61f2:	d1cf      	bne.n	6194 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x5c>
    61f4:	e7ca      	b.n	618c <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x54>
    61f6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    61fa:	f001 b8a5 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    61fe:	2d01      	cmp	r5, #1
    6200:	d0e2      	beq.n	61c8 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0x90>
    6202:	6b70      	ldr	r0, [r6, #52]	; 0x34
    6204:	f007 fe7d 	bl	df02 <sym_W4P456NK4DQPUF5QVP3W7JSFZJTVGAOKAMSTNSQ>
    6208:	e7f5      	b.n	61f6 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ+0xbe>
    620a:	0000      	.short	0x0000
    620c:	200000d0 	.word	0x200000d0

00006210 <sym_ZWLSMB33C6NPFOBZGVPV4PN4UKQGSPLLR4WLDFI>:
    6210:	4802      	ldr	r0, [pc, #8]	; (621c <sym_ZWLSMB33C6NPFOBZGVPV4PN4UKQGSPLLR4WLDFI+0xc>)
    6212:	89c0      	ldrh	r0, [r0, #14]
    6214:	f3c0 2080 	ubfx	r0, r0, #10, #1
    6218:	4770      	bx	lr
    621a:	0000      	.short	0x0000
    621c:	200000d0 	.word	0x200000d0

00006220 <sym_CZFK26FRDZ53FUV75DOIMFWVD4RTHYB6I22U4LA>:
    6220:	4804      	ldr	r0, [pc, #16]	; (6234 <sym_CZFK26FRDZ53FUV75DOIMFWVD4RTHYB6I22U4LA+0x14>)
    6222:	7800      	ldrb	r0, [r0, #0]
    6224:	b108      	cbz	r0, 622a <sym_CZFK26FRDZ53FUV75DOIMFWVD4RTHYB6I22U4LA+0xa>
    6226:	200c      	movs	r0, #12
    6228:	4770      	bx	lr
    622a:	4903      	ldr	r1, [pc, #12]	; (6238 <sym_CZFK26FRDZ53FUV75DOIMFWVD4RTHYB6I22U4LA+0x18>)
    622c:	2000      	movs	r0, #0
    622e:	7708      	strb	r0, [r1, #28]
    6230:	4770      	bx	lr
    6232:	0000      	.short	0x0000
    6234:	200000d0 	.word	0x200000d0
    6238:	20001192 	.word	0x20001192

0000623c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ>:
    623c:	480c      	ldr	r0, [pc, #48]	; (6270 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x34>)
    623e:	b510      	push	{r4, lr}
    6240:	7801      	ldrb	r1, [r0, #0]
    6242:	b149      	cbz	r1, 6258 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1c>
    6244:	f100 0138 	add.w	r1, r0, #56	; 0x38
    6248:	7800      	ldrb	r0, [r0, #0]
    624a:	2802      	cmp	r0, #2
    624c:	d008      	beq.n	6260 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x24>
    624e:	f240 11f1 	movw	r1, #497	; 0x1f1
    6252:	2027      	movs	r0, #39	; 0x27
    6254:	f7fe ff7e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6258:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    625c:	f000 b9fe 	b.w	665c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x420>
    6260:	6848      	ldr	r0, [r1, #4]
    6262:	f8d0 01d8 	ldr.w	r0, [r0, #472]	; 0x1d8
    6266:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    626a:	f005 bd2d 	b.w	bcc8 <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA>
    626e:	0000      	.short	0x0000
    6270:	200000d0 	.word	0x200000d0
    6274:	4a02      	ldr	r2, [pc, #8]	; (6280 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x44>)
    6276:	8993      	ldrh	r3, [r2, #12]
    6278:	4303      	orrs	r3, r0
    627a:	8193      	strh	r3, [r2, #12]
    627c:	6952      	ldr	r2, [r2, #20]
    627e:	4710      	bx	r2
    6280:	200000d0 	.word	0x200000d0
    6284:	4801      	ldr	r0, [pc, #4]	; (628c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x50>)
    6286:	6840      	ldr	r0, [r0, #4]
    6288:	4770      	bx	lr
    628a:	0000      	.short	0x0000
    628c:	20000108 	.word	0x20000108
    6290:	4801      	ldr	r0, [pc, #4]	; (6298 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5c>)
    6292:	6840      	ldr	r0, [r0, #4]
    6294:	3078      	adds	r0, #120	; 0x78
    6296:	4770      	bx	lr
    6298:	20000108 	.word	0x20000108
    629c:	4a01      	ldr	r2, [pc, #4]	; (62a4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x68>)
    629e:	2100      	movs	r1, #0
    62a0:	6952      	ldr	r2, [r2, #20]
    62a2:	4710      	bx	r2
    62a4:	200000d0 	.word	0x200000d0
    62a8:	b570      	push	{r4, r5, r6, lr}
    62aa:	f7ff fff1 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    62ae:	4604      	mov	r4, r0
    62b0:	f7ff ffe8 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    62b4:	4605      	mov	r5, r0
    62b6:	4621      	mov	r1, r4
    62b8:	f008 fa46 	bl	e748 <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II>
    62bc:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
    62c0:	2901      	cmp	r1, #1
    62c2:	d112      	bne.n	62ea <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xae>
    62c4:	2800      	cmp	r0, #0
    62c6:	d010      	beq.n	62ea <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xae>
    62c8:	4808      	ldr	r0, [pc, #32]	; (62ec <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xb0>)
    62ca:	882a      	ldrh	r2, [r5, #0]
    62cc:	6841      	ldr	r1, [r0, #4]
    62ce:	f501 7096 	add.w	r0, r1, #300	; 0x12c
    62d2:	8142      	strh	r2, [r0, #10]
    62d4:	7a62      	ldrb	r2, [r4, #9]
    62d6:	7302      	strb	r2, [r0, #12]
    62d8:	7aa2      	ldrb	r2, [r4, #10]
    62da:	7342      	strb	r2, [r0, #13]
    62dc:	2218      	movs	r2, #24
    62de:	f000 ff61 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    62e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    62e6:	f001 b82f 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    62ea:	bd70      	pop	{r4, r5, r6, pc}
    62ec:	20000108 	.word	0x20000108
    62f0:	b570      	push	{r4, r5, r6, lr}
    62f2:	4605      	mov	r5, r0
    62f4:	2901      	cmp	r1, #1
    62f6:	d818      	bhi.n	632a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xee>
    62f8:	4c12      	ldr	r4, [pc, #72]	; (6344 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x108>)
    62fa:	69a1      	ldr	r1, [r4, #24]
    62fc:	4788      	blx	r1
    62fe:	b1a0      	cbz	r0, 632a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xee>
    6300:	7960      	ldrb	r0, [r4, #5]
    6302:	b990      	cbnz	r0, 632a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xee>
    6304:	b9e5      	cbnz	r5, 6340 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x104>
    6306:	f104 0010 	add.w	r0, r4, #16
    630a:	7801      	ldrb	r1, [r0, #0]
    630c:	06c8      	lsls	r0, r1, #27
    630e:	d405      	bmi.n	631c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xe0>
    6310:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    6312:	7800      	ldrb	r0, [r0, #0]
    6314:	06c0      	lsls	r0, r0, #27
    6316:	d401      	bmi.n	631c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xe0>
    6318:	2001      	movs	r0, #1
    631a:	e000      	b.n	631e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xe2>
    631c:	2000      	movs	r0, #0
    631e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    6320:	b92a      	cbnz	r2, 632e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xf2>
    6322:	8962      	ldrh	r2, [r4, #10]
    6324:	b11a      	cbz	r2, 632e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xf2>
    6326:	06c9      	lsls	r1, r1, #27
    6328:	d401      	bmi.n	632e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xf2>
    632a:	2001      	movs	r0, #1
    632c:	bd70      	pop	{r4, r5, r6, pc}
    632e:	89a1      	ldrh	r1, [r4, #12]
    6330:	078a      	lsls	r2, r1, #30
    6332:	d503      	bpl.n	633c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x100>
    6334:	6a22      	ldr	r2, [r4, #32]
    6336:	78d2      	ldrb	r2, [r2, #3]
    6338:	2a02      	cmp	r2, #2
    633a:	d001      	beq.n	6340 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x104>
    633c:	4308      	orrs	r0, r1
    633e:	d1f4      	bne.n	632a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xee>
    6340:	2000      	movs	r0, #0
    6342:	bd70      	pop	{r4, r5, r6, pc}
    6344:	200000d0 	.word	0x200000d0
    6348:	b530      	push	{r4, r5, lr}
    634a:	4b08      	ldr	r3, [pc, #32]	; (636c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x130>)
    634c:	88dd      	ldrh	r5, [r3, #6]
    634e:	891c      	ldrh	r4, [r3, #8]
    6350:	b12a      	cbz	r2, 635e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x122>
    6352:	b908      	cbnz	r0, 6358 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x11c>
    6354:	b905      	cbnz	r5, 6358 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x11c>
    6356:	b114      	cbz	r4, 635e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x122>
    6358:	8958      	ldrh	r0, [r3, #10]
    635a:	1c40      	adds	r0, r0, #1
    635c:	8158      	strh	r0, [r3, #10]
    635e:	b111      	cbz	r1, 6366 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x12a>
    6360:	1c6d      	adds	r5, r5, #1
    6362:	80dd      	strh	r5, [r3, #6]
    6364:	bd30      	pop	{r4, r5, pc}
    6366:	1c64      	adds	r4, r4, #1
    6368:	811c      	strh	r4, [r3, #8]
    636a:	bd30      	pop	{r4, r5, pc}
    636c:	20001192 	.word	0x20001192
    6370:	b510      	push	{r4, lr}
    6372:	4c08      	ldr	r4, [pc, #32]	; (6394 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x158>)
    6374:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    6376:	b138      	cbz	r0, 6388 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x14c>
    6378:	8962      	ldrh	r2, [r4, #10]
    637a:	6a61      	ldr	r1, [r4, #36]	; 0x24
    637c:	1cd2      	adds	r2, r2, #3
    637e:	f006 fe2d 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    6382:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    6384:	6260      	str	r0, [r4, #36]	; 0x24
    6386:	bd10      	pop	{r4, pc}
    6388:	f240 4163 	movw	r1, #1123	; 0x463
    638c:	2027      	movs	r0, #39	; 0x27
    638e:	f7fe fee1 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6392:	0000      	.short	0x0000
    6394:	200000d0 	.word	0x200000d0
    6398:	b510      	push	{r4, lr}
    639a:	f7ff ff73 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    639e:	4604      	mov	r4, r0
    63a0:	f7ff ff76 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    63a4:	4601      	mov	r1, r0
    63a6:	7b42      	ldrb	r2, [r0, #13]
    63a8:	4815      	ldr	r0, [pc, #84]	; (6400 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1c4>)
    63aa:	2a24      	cmp	r2, #36	; 0x24
    63ac:	d00e      	beq.n	63cc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x190>
    63ae:	7b89      	ldrb	r1, [r1, #14]
    63b0:	2924      	cmp	r1, #36	; 0x24
    63b2:	d00b      	beq.n	63cc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x190>
    63b4:	2a1f      	cmp	r2, #31
    63b6:	d00d      	beq.n	63d4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x198>
    63b8:	2a20      	cmp	r2, #32
    63ba:	d00b      	beq.n	63d4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x198>
    63bc:	2922      	cmp	r1, #34	; 0x22
    63be:	d00f      	beq.n	63e0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1a4>
    63c0:	f894 006e 	ldrb.w	r0, [r4, #110]	; 0x6e
    63c4:	2804      	cmp	r0, #4
    63c6:	d100      	bne.n	63ca <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x18e>
    63c8:	2008      	movs	r0, #8
    63ca:	bd10      	pop	{r4, pc}
    63cc:	6840      	ldr	r0, [r0, #4]
    63ce:	f890 1276 	ldrb.w	r1, [r0, #630]	; 0x276
    63d2:	e00e      	b.n	63f2 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1b6>
    63d4:	2922      	cmp	r1, #34	; 0x22
    63d6:	d003      	beq.n	63e0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1a4>
    63d8:	6840      	ldr	r0, [r0, #4]
    63da:	f890 0126 	ldrb.w	r0, [r0, #294]	; 0x126
    63de:	e005      	b.n	63ec <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1b0>
    63e0:	6841      	ldr	r1, [r0, #4]
    63e2:	f891 0126 	ldrb.w	r0, [r1, #294]	; 0x126
    63e6:	f891 1067 	ldrb.w	r1, [r1, #103]	; 0x67
    63ea:	4008      	ands	r0, r1
    63ec:	f008 f826 	bl	e43c <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x4>
    63f0:	4601      	mov	r1, r0
    63f2:	f894 006e 	ldrb.w	r0, [r4, #110]	; 0x6e
    63f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    63fa:	f008 b837 	b.w	e46c <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x34>
    63fe:	0000      	.short	0x0000
    6400:	20000108 	.word	0x20000108
    6404:	e92d 5ffc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    6408:	468b      	mov	fp, r1
    640a:	4607      	mov	r7, r0
    640c:	f7ff ff40 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    6410:	f04f 0900 	mov.w	r9, #0
    6414:	4c61      	ldr	r4, [pc, #388]	; (659c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x360>)
    6416:	4605      	mov	r5, r0
    6418:	f88d 9000 	strb.w	r9, [sp]
    641c:	f8cd 9004 	str.w	r9, [sp, #4]
    6420:	7820      	ldrb	r0, [r4, #0]
    6422:	464e      	mov	r6, r9
    6424:	2802      	cmp	r0, #2
    6426:	d004      	beq.n	6432 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x1f6>
    6428:	f240 41ea 	movw	r1, #1258	; 0x4ea
    642c:	2027      	movs	r0, #39	; 0x27
    642e:	f7fe fe91 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6432:	7ba0      	ldrb	r0, [r4, #14]
    6434:	0640      	lsls	r0, r0, #25
    6436:	d406      	bmi.n	6446 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x20a>
    6438:	2040      	movs	r0, #64	; 0x40
    643a:	f7ff ff2f 	bl	629c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x60>
    643e:	89e0      	ldrh	r0, [r4, #14]
    6440:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    6444:	81e0      	strh	r0, [r4, #14]
    6446:	7d28      	ldrb	r0, [r5, #20]
    6448:	b3df      	cbz	r7, 64c2 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x286>
    644a:	b180      	cbz	r0, 646e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x232>
    644c:	f005 fa98 	bl	b980 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI>
    6450:	f005 fa72 	bl	b938 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA>
    6454:	b958      	cbnz	r0, 646e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x232>
    6456:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6458:	7841      	ldrb	r1, [r0, #1]
    645a:	b141      	cbz	r1, 646e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x232>
    645c:	7800      	ldrb	r0, [r0, #0]
    645e:	7a29      	ldrb	r1, [r5, #8]
    6460:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    6464:	4288      	cmp	r0, r1
    6466:	d102      	bne.n	646e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x232>
    6468:	2001      	movs	r0, #1
    646a:	70a0      	strb	r0, [r4, #2]
    646c:	e092      	b.n	6594 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x358>
    646e:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6470:	7841      	ldrb	r1, [r0, #1]
    6472:	8161      	strh	r1, [r4, #10]
    6474:	b121      	cbz	r1, 6480 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x244>
    6476:	6b60      	ldr	r0, [r4, #52]	; 0x34
    6478:	f007 fd10 	bl	de9c <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI>
    647c:	62a0      	str	r0, [r4, #40]	; 0x28
    647e:	e000      	b.n	6482 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x246>
    6480:	62a6      	str	r6, [r4, #40]	; 0x28
    6482:	89e0      	ldrh	r0, [r4, #14]
    6484:	f440 7080 	orr.w	r0, r0, #256	; 0x100
    6488:	81e0      	strh	r0, [r4, #14]
    648a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    648c:	79e9      	ldrb	r1, [r5, #7]
    648e:	7800      	ldrb	r0, [r0, #0]
    6490:	f3c0 0080 	ubfx	r0, r0, #2, #1
    6494:	4288      	cmp	r0, r1
    6496:	d007      	beq.n	64a8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x26c>
    6498:	a801      	add	r0, sp, #4
    649a:	f000 f975 	bl	6788 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54c>
    649e:	89e0      	ldrh	r0, [r4, #14]
    64a0:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
    64a4:	81e0      	strh	r0, [r4, #14]
    64a6:	e001      	b.n	64ac <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x270>
    64a8:	f04f 0901 	mov.w	r9, #1
    64ac:	6a60      	ldr	r0, [r4, #36]	; 0x24
    64ae:	7a29      	ldrb	r1, [r5, #8]
    64b0:	7800      	ldrb	r0, [r0, #0]
    64b2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    64b6:	4288      	cmp	r0, r1
    64b8:	d10e      	bne.n	64d8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x29c>
    64ba:	4668      	mov	r0, sp
    64bc:	f000 f926 	bl	670c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4d0>
    64c0:	e00a      	b.n	64d8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x29c>
    64c2:	e7ff      	b.n	64c4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x288>
    64c4:	b108      	cbz	r0, 64ca <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x28e>
    64c6:	f005 fa55 	bl	b974 <sym_QQVHHHKNBN5TJBK4NCDSUYAMXMOEHFSL7HE7RRA>
    64ca:	78e0      	ldrb	r0, [r4, #3]
    64cc:	1c40      	adds	r0, r0, #1
    64ce:	70e0      	strb	r0, [r4, #3]
    64d0:	89e0      	ldrh	r0, [r4, #14]
    64d2:	f440 7000 	orr.w	r0, r0, #512	; 0x200
    64d6:	81e0      	strh	r0, [r4, #14]
    64d8:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 659c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x360>
    64dc:	7ce8      	ldrb	r0, [r5, #19]
    64de:	f10a 0a38 	add.w	sl, sl, #56	; 0x38
    64e2:	b188      	cbz	r0, 6508 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x2cc>
    64e4:	f7ff fece 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    64e8:	492d      	ldr	r1, [pc, #180]	; (65a0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x364>)
    64ea:	760e      	strb	r6, [r1, #24]
    64ec:	e9d5 231a 	ldrd	r2, r3, [r5, #104]	; 0x68
    64f0:	e9c1 2304 	strd	r2, r3, [r1, #16]
    64f4:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
    64f8:	f007 ffaa 	bl	e450 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x18>
    64fc:	4603      	mov	r3, r0
    64fe:	22fb      	movs	r2, #251	; 0xfb
    6500:	4927      	ldr	r1, [pc, #156]	; (65a0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x364>)
    6502:	4630      	mov	r0, r6
    6504:	f005 f96e 	bl	b7e4 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA>
    6508:	f04f 0800 	mov.w	r8, #0
    650c:	f1bb 0f00 	cmp.w	fp, #0
    6510:	d104      	bne.n	651c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x2e0>
    6512:	78e1      	ldrb	r1, [r4, #3]
    6514:	2001      	movs	r0, #1
    6516:	f7ff feeb 	bl	62f0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xb4>
    651a:	b198      	cbz	r0, 6544 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x308>
    651c:	f005 fdd8 	bl	c0d0 <sym_VEC44ISWPJAJ32J57NYIBEMC7Q6QEP7J6SVR4BQ>
    6520:	f89d 0000 	ldrb.w	r0, [sp]
    6524:	b110      	cbz	r0, 652c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x2f0>
    6526:	2000      	movs	r0, #0
    6528:	f7ff fe06 	bl	6138 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ>
    652c:	88a8      	ldrh	r0, [r5, #4]
    652e:	464a      	mov	r2, r9
    6530:	4639      	mov	r1, r7
    6532:	f7ff ff09 	bl	6348 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x10c>
    6536:	b117      	cbz	r7, 653e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x302>
    6538:	70e6      	strb	r6, [r4, #3]
    653a:	f7ff feb5 	bl	62a8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6c>
    653e:	f04f 0801 	mov.w	r8, #1
    6542:	e017      	b.n	6574 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x338>
    6544:	f89d 0000 	ldrb.w	r0, [sp]
    6548:	b110      	cbz	r0, 6550 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x314>
    654a:	2001      	movs	r0, #1
    654c:	f7ff fdf4 	bl	6138 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ>
    6550:	2000      	movs	r0, #0
    6552:	f000 f9a3 	bl	689c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x660>
    6556:	f89d 0000 	ldrb.w	r0, [sp]
    655a:	b110      	cbz	r0, 6562 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x326>
    655c:	2002      	movs	r0, #2
    655e:	f7ff fdeb 	bl	6138 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ>
    6562:	88a8      	ldrh	r0, [r5, #4]
    6564:	464a      	mov	r2, r9
    6566:	4639      	mov	r1, r7
    6568:	f7ff feee 	bl	6348 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x10c>
    656c:	b117      	cbz	r7, 6574 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x338>
    656e:	70e6      	strb	r6, [r4, #3]
    6570:	f7ff fe9a 	bl	62a8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6c>
    6574:	9801      	ldr	r0, [sp, #4]
    6576:	b150      	cbz	r0, 658e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x352>
    6578:	f007 fb1c 	bl	dbb4 <sym_UPAEGKLCM3QW7VHROMMVD5MIRBTM2NGCYENWSLI>
    657c:	f8da 1004 	ldr.w	r1, [sl, #4]
    6580:	1c40      	adds	r0, r0, #1
    6582:	7206      	strb	r6, [r0, #8]
    6584:	220b      	movs	r2, #11
    6586:	f000 fe0d 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    658a:	f000 fedd 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    658e:	f1b8 0f00 	cmp.w	r8, #0
    6592:	d001      	beq.n	6598 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x35c>
    6594:	f000 f862 	bl	665c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x420>
    6598:	e8bd 9ffc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
    659c:	200000d0 	.word	0x200000d0
    65a0:	20001148 	.word	0x20001148
    65a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    65a8:	460f      	mov	r7, r1
    65aa:	4680      	mov	r8, r0
    65ac:	f7ff fe70 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    65b0:	4d28      	ldr	r5, [pc, #160]	; (6654 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x418>)
    65b2:	4604      	mov	r4, r0
    65b4:	7828      	ldrb	r0, [r5, #0]
    65b6:	2801      	cmp	r0, #1
    65b8:	d004      	beq.n	65c4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x388>
    65ba:	f240 4172 	movw	r1, #1138	; 0x472
    65be:	2027      	movs	r0, #39	; 0x27
    65c0:	f7fe fdc8 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    65c4:	7821      	ldrb	r1, [r4, #0]
    65c6:	2000      	movs	r0, #0
    65c8:	2601      	movs	r6, #1
    65ca:	b129      	cbz	r1, 65d8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x39c>
    65cc:	7020      	strb	r0, [r4, #0]
    65ce:	2100      	movs	r1, #0
    65d0:	2004      	movs	r0, #4
    65d2:	f7ff fe4f 	bl	6274 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x38>
    65d6:	70a6      	strb	r6, [r4, #2]
    65d8:	6a29      	ldr	r1, [r5, #32]
    65da:	7808      	ldrb	r0, [r1, #0]
    65dc:	43c0      	mvns	r0, r0
    65de:	0780      	lsls	r0, r0, #30
    65e0:	d109      	bne.n	65f6 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x3ba>
    65e2:	79a0      	ldrb	r0, [r4, #6]
    65e4:	bb78      	cbnz	r0, 6646 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x40a>
    65e6:	2002      	movs	r0, #2
    65e8:	f7ff fe44 	bl	6274 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x38>
    65ec:	6a28      	ldr	r0, [r5, #32]
    65ee:	7800      	ldrb	r0, [r0, #0]
    65f0:	43c0      	mvns	r0, r0
    65f2:	0780      	lsls	r0, r0, #30
    65f4:	d027      	beq.n	6646 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x40a>
    65f6:	6a28      	ldr	r0, [r5, #32]
    65f8:	7840      	ldrb	r0, [r0, #1]
    65fa:	b110      	cbz	r0, 6602 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x3c6>
    65fc:	2002      	movs	r0, #2
    65fe:	71a0      	strb	r0, [r4, #6]
    6600:	e000      	b.n	6604 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x3c8>
    6602:	71a6      	strb	r6, [r4, #6]
    6604:	7d20      	ldrb	r0, [r4, #20]
    6606:	b190      	cbz	r0, 662e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x3f2>
    6608:	f7ff fe3c 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    660c:	4912      	ldr	r1, [pc, #72]	; (6658 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x41c>)
    660e:	7a6d      	ldrb	r5, [r5, #9]
    6610:	760e      	strb	r6, [r1, #24]
    6612:	e9d4 231c 	ldrd	r2, r3, [r4, #112]	; 0x70
    6616:	e9c1 2304 	strd	r2, r3, [r1, #16]
    661a:	f890 006f 	ldrb.w	r0, [r0, #111]	; 0x6f
    661e:	f007 ff17 	bl	e450 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x18>
    6622:	4603      	mov	r3, r0
    6624:	462a      	mov	r2, r5
    6626:	490c      	ldr	r1, [pc, #48]	; (6658 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x41c>)
    6628:	4630      	mov	r0, r6
    662a:	f005 f8db 	bl	b7e4 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA>
    662e:	ea37 0708 	bics.w	r7, r7, r8
    6632:	d004      	beq.n	663e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x402>
    6634:	2100      	movs	r1, #0
    6636:	4608      	mov	r0, r1
    6638:	f7ff fe5a 	bl	62f0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0xb4>
    663c:	b128      	cbz	r0, 664a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x40e>
    663e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    6642:	f000 b80b 	b.w	665c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x420>
    6646:	2003      	movs	r0, #3
    6648:	e7d9      	b.n	65fe <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x3c2>
    664a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    664e:	2000      	movs	r0, #0
    6650:	f000 b8e8 	b.w	6824 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5e8>
    6654:	200000d0 	.word	0x200000d0
    6658:	20001148 	.word	0x20001148
    665c:	b510      	push	{r4, lr}
    665e:	f005 fa35 	bl	bacc <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y>
    6662:	f005 f953 	bl	b90c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ>
    6666:	4c0e      	ldr	r4, [pc, #56]	; (66a0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x464>)
    6668:	89e0      	ldrh	r0, [r4, #14]
    666a:	f7ff fe17 	bl	629c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x60>
    666e:	69e2      	ldr	r2, [r4, #28]
    6670:	7961      	ldrb	r1, [r4, #5]
    6672:	78a0      	ldrb	r0, [r4, #2]
    6674:	4790      	blx	r2
    6676:	480b      	ldr	r0, [pc, #44]	; (66a4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x468>)
    6678:	7f00      	ldrb	r0, [r0, #28]
    667a:	b168      	cbz	r0, 6698 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x45c>
    667c:	4909      	ldr	r1, [pc, #36]	; (66a4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x468>)
    667e:	220e      	movs	r2, #14
    6680:	f101 000e 	add.w	r0, r1, #14
    6684:	f006 fcaa 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    6688:	4806      	ldr	r0, [pc, #24]	; (66a4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x468>)
    668a:	221d      	movs	r2, #29
    668c:	2100      	movs	r1, #0
    668e:	301d      	adds	r0, #29
    6690:	f000 fd88 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    6694:	f000 fe58 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    6698:	2000      	movs	r0, #0
    669a:	7020      	strb	r0, [r4, #0]
    669c:	bd10      	pop	{r4, pc}
    669e:	0000      	.short	0x0000
    66a0:	200000d0 	.word	0x200000d0
    66a4:	20001192 	.word	0x20001192
    66a8:	4808      	ldr	r0, [pc, #32]	; (66cc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x490>)
    66aa:	b510      	push	{r4, lr}
    66ac:	7800      	ldrb	r0, [r0, #0]
    66ae:	2802      	cmp	r0, #2
    66b0:	d004      	beq.n	66bc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x480>
    66b2:	f240 212a 	movw	r1, #554	; 0x22a
    66b6:	2027      	movs	r0, #39	; 0x27
    66b8:	f7fe fd4c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    66bc:	4904      	ldr	r1, [pc, #16]	; (66d0 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x494>)
    66be:	2001      	movs	r0, #1
    66c0:	7308      	strb	r0, [r1, #12]
    66c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    66c6:	f7ff bfc9 	b.w	665c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x420>
    66ca:	0000      	.short	0x0000
    66cc:	200000d0 	.word	0x200000d0
    66d0:	20001192 	.word	0x20001192
    66d4:	4b0c      	ldr	r3, [pc, #48]	; (6708 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4cc>)
    66d6:	b430      	push	{r4, r5}
    66d8:	79db      	ldrb	r3, [r3, #7]
    66da:	b93a      	cbnz	r2, 66ec <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4b0>
    66dc:	2bff      	cmp	r3, #255	; 0xff
    66de:	d105      	bne.n	66ec <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4b0>
    66e0:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
    66e4:	f890 406e 	ldrb.w	r4, [r0, #110]	; 0x6e
    66e8:	42a2      	cmp	r2, r4
    66ea:	d00a      	beq.n	6702 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4c6>
    66ec:	b129      	cbz	r1, 66fa <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4be>
    66ee:	f890 106f 	ldrb.w	r1, [r0, #111]	; 0x6f
    66f2:	bc30      	pop	{r4, r5}
    66f4:	4618      	mov	r0, r3
    66f6:	f005 bd13 	b.w	c120 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ>
    66fa:	23ff      	movs	r3, #255	; 0xff
    66fc:	f890 106e 	ldrb.w	r1, [r0, #110]	; 0x6e
    6700:	e7f7      	b.n	66f2 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x4b6>
    6702:	bc30      	pop	{r4, r5}
    6704:	4770      	bx	lr
    6706:	0000      	.short	0x0000
    6708:	200000d0 	.word	0x200000d0
    670c:	b570      	push	{r4, r5, r6, lr}
    670e:	4606      	mov	r6, r0
    6710:	f7ff fdbe 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    6714:	4a1b      	ldr	r2, [pc, #108]	; (6784 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x548>)
    6716:	4604      	mov	r4, r0
    6718:	2501      	movs	r5, #1
    671a:	6a51      	ldr	r1, [r2, #36]	; 0x24
    671c:	7808      	ldrb	r0, [r1, #0]
    671e:	f000 0003 	and.w	r0, r0, #3
    6722:	2801      	cmp	r0, #1
    6724:	d00c      	beq.n	6740 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x504>
    6726:	2802      	cmp	r0, #2
    6728:	d00a      	beq.n	6740 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x504>
    672a:	2803      	cmp	r0, #3
    672c:	d121      	bne.n	6772 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x536>
    672e:	7025      	strb	r5, [r4, #0]
    6730:	89d0      	ldrh	r0, [r2, #14]
    6732:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
    6736:	81d0      	strh	r0, [r2, #14]
    6738:	2001      	movs	r0, #1
    673a:	f7ff fd9b 	bl	6274 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x38>
    673e:	e018      	b.n	6772 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x536>
    6740:	7848      	ldrb	r0, [r1, #1]
    6742:	b1b0      	cbz	r0, 6772 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x536>
    6744:	89d1      	ldrh	r1, [r2, #14]
    6746:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
    674a:	81d1      	strh	r1, [r2, #14]
    674c:	6a91      	ldr	r1, [r2, #40]	; 0x28
    674e:	2900      	cmp	r1, #0
    6750:	d009      	beq.n	6766 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x52a>
    6752:	28fb      	cmp	r0, #251	; 0xfb
    6754:	d808      	bhi.n	6768 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x52c>
    6756:	7990      	ldrb	r0, [r2, #6]
    6758:	b120      	cbz	r0, 6764 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x528>
    675a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    675e:	2020      	movs	r0, #32
    6760:	f7ff bd9c 	b.w	629c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x60>
    6764:	7035      	strb	r5, [r6, #0]
    6766:	bd70      	pop	{r4, r5, r6, pc}
    6768:	7950      	ldrb	r0, [r2, #5]
    676a:	f040 0010 	orr.w	r0, r0, #16
    676e:	7150      	strb	r0, [r2, #5]
    6770:	bd70      	pop	{r4, r5, r6, pc}
    6772:	7a20      	ldrb	r0, [r4, #8]
    6774:	2801      	cmp	r0, #1
    6776:	d001      	beq.n	677c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x540>
    6778:	7225      	strb	r5, [r4, #8]
    677a:	bd70      	pop	{r4, r5, r6, pc}
    677c:	2000      	movs	r0, #0
    677e:	7220      	strb	r0, [r4, #8]
    6780:	bd70      	pop	{r4, r5, r6, pc}
    6782:	0000      	.short	0x0000
    6784:	200000d0 	.word	0x200000d0
    6788:	b570      	push	{r4, r5, r6, lr}
    678a:	4605      	mov	r5, r0
    678c:	f7ff fd80 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    6790:	4604      	mov	r4, r0
    6792:	7980      	ldrb	r0, [r0, #6]
    6794:	2800      	cmp	r0, #0
    6796:	d02d      	beq.n	67f4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5b8>
    6798:	2802      	cmp	r0, #2
    679a:	d10c      	bne.n	67b6 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x57a>
    679c:	481b      	ldr	r0, [pc, #108]	; (680c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5d0>)
    679e:	4629      	mov	r1, r5
    67a0:	6b00      	ldr	r0, [r0, #48]	; 0x30
    67a2:	f007 f983 	bl	daac <sym_UOYZDE3MDLGPDL5S5WKUFLPYH4DJIMF3BJSBDYA>
    67a6:	b330      	cbz	r0, 67f6 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5ba>
    67a8:	e9d4 011a 	ldrd	r0, r1, [r4, #104]	; 0x68
    67ac:	1c40      	adds	r0, r0, #1
    67ae:	f141 0100 	adc.w	r1, r1, #0
    67b2:	e9c4 011a 	strd	r0, r1, [r4, #104]	; 0x68
    67b6:	2500      	movs	r5, #0
    67b8:	71a5      	strb	r5, [r4, #6]
    67ba:	78a0      	ldrb	r0, [r4, #2]
    67bc:	b120      	cbz	r0, 67c8 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x58c>
    67be:	70a5      	strb	r5, [r4, #2]
    67c0:	2100      	movs	r1, #0
    67c2:	2010      	movs	r0, #16
    67c4:	f7ff fd56 	bl	6274 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x38>
    67c8:	7860      	ldrb	r0, [r4, #1]
    67ca:	b170      	cbz	r0, 67ea <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5ae>
    67cc:	7065      	strb	r5, [r4, #1]
    67ce:	f7ff fb01 	bl	5dd4 <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y>
    67d2:	b198      	cbz	r0, 67fc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5c0>
    67d4:	2100      	movs	r1, #0
    67d6:	2008      	movs	r0, #8
    67d8:	f7ff fd4c 	bl	6274 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x38>
    67dc:	e9d4 011a 	ldrd	r0, r1, [r4, #104]	; 0x68
    67e0:	1c40      	adds	r0, r0, #1
    67e2:	f141 0100 	adc.w	r1, r1, #0
    67e6:	e9c4 011a 	strd	r0, r1, [r4, #104]	; 0x68
    67ea:	79e0      	ldrb	r0, [r4, #7]
    67ec:	2801      	cmp	r0, #1
    67ee:	d00a      	beq.n	6806 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5ca>
    67f0:	2001      	movs	r0, #1
    67f2:	71e0      	strb	r0, [r4, #7]
    67f4:	bd70      	pop	{r4, r5, r6, pc}
    67f6:	f240 31b9 	movw	r1, #953	; 0x3b9
    67fa:	e001      	b.n	6800 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5c4>
    67fc:	f44f 7174 	mov.w	r1, #976	; 0x3d0
    6800:	2027      	movs	r0, #39	; 0x27
    6802:	f7fe fca7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6806:	71e5      	strb	r5, [r4, #7]
    6808:	bd70      	pop	{r4, r5, r6, pc}
    680a:	0000      	.short	0x0000
    680c:	200000d0 	.word	0x200000d0
    6810:	4803      	ldr	r0, [pc, #12]	; (6820 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5e4>)
    6812:	7800      	ldrb	r0, [r0, #0]
    6814:	2800      	cmp	r0, #0
    6816:	d001      	beq.n	681c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x5e0>
    6818:	f7ff bf20 	b.w	665c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x420>
    681c:	4770      	bx	lr
    681e:	0000      	.short	0x0000
    6820:	200000d0 	.word	0x200000d0
    6824:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6828:	4606      	mov	r6, r0
    682a:	f7ff fd2b 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    682e:	4680      	mov	r8, r0
    6830:	f7ff fd2e 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    6834:	4c16      	ldr	r4, [pc, #88]	; (6890 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x654>)
    6836:	4605      	mov	r5, r0
    6838:	4632      	mov	r2, r6
    683a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    683c:	6260      	str	r0, [r4, #36]	; 0x24
    683e:	2101      	movs	r1, #1
    6840:	4640      	mov	r0, r8
    6842:	f7ff ff47 	bl	66d4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x498>
    6846:	7d28      	ldrb	r0, [r5, #20]
    6848:	2700      	movs	r7, #0
    684a:	b170      	cbz	r0, 686a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x62e>
    684c:	4811      	ldr	r0, [pc, #68]	; (6894 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x658>)
    684e:	f005 fba9 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    6852:	4811      	ldr	r0, [pc, #68]	; (6898 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x65c>)
    6854:	2101      	movs	r1, #1
    6856:	7601      	strb	r1, [r0, #24]
    6858:	e9d5 121c 	ldrd	r1, r2, [r5, #112]	; 0x70
    685c:	e9c0 1204 	strd	r1, r2, [r0, #16]
    6860:	490c      	ldr	r1, [pc, #48]	; (6894 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x658>)
    6862:	6a60      	ldr	r0, [r4, #36]	; 0x24
    6864:	f005 f810 	bl	b888 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA>
    6868:	e004      	b.n	6874 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x638>
    686a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    686c:	f005 fb9a 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    6870:	f005 f84c 	bl	b90c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ>
    6874:	b916      	cbnz	r6, 687c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x640>
    6876:	4638      	mov	r0, r7
    6878:	f005 fa4a 	bl	bd10 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY>
    687c:	2100      	movs	r1, #0
    687e:	f898 206e 	ldrb.w	r2, [r8, #110]	; 0x6e
    6882:	4608      	mov	r0, r1
    6884:	f005 fc06 	bl	c094 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q>
    6888:	2002      	movs	r0, #2
    688a:	7020      	strb	r0, [r4, #0]
    688c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6890:	200000d0 	.word	0x200000d0
    6894:	20001040 	.word	0x20001040
    6898:	20001148 	.word	0x20001148
    689c:	e92d 47fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    68a0:	4604      	mov	r4, r0
    68a2:	f7ff fcf5 	bl	6290 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x54>
    68a6:	4605      	mov	r5, r0
    68a8:	f7ff fcec 	bl	6284 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x48>
    68ac:	2700      	movs	r7, #0
    68ae:	4606      	mov	r6, r0
    68b0:	f8df 9164 	ldr.w	r9, [pc, #356]	; 6a18 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7dc>
    68b4:	f88d 7000 	strb.w	r7, [sp]
    68b8:	4622      	mov	r2, r4
    68ba:	4639      	mov	r1, r7
    68bc:	f7ff ff0a 	bl	66d4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x498>
    68c0:	79a8      	ldrb	r0, [r5, #6]
    68c2:	f04f 0801 	mov.w	r8, #1
    68c6:	f1a9 0420 	sub.w	r4, r9, #32
    68ca:	b140      	cbz	r0, 68de <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6a2>
    68cc:	2801      	cmp	r0, #1
    68ce:	d020      	beq.n	6912 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6d6>
    68d0:	2802      	cmp	r0, #2
    68d2:	d02f      	beq.n	6934 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6f8>
    68d4:	2803      	cmp	r0, #3
    68d6:	d03b      	beq.n	6950 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x714>
    68d8:	f240 21d5 	movw	r1, #725	; 0x2d5
    68dc:	e057      	b.n	698e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x752>
    68de:	7a20      	ldrb	r0, [r4, #8]
    68e0:	2154      	movs	r1, #84	; 0x54
    68e2:	f8ad 0004 	strh.w	r0, [sp, #4]
    68e6:	5388      	strh	r0, [r1, r6]
    68e8:	4648      	mov	r0, r9
    68ea:	f7ff fa9d 	bl	5e28 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI>
    68ee:	b130      	cbz	r0, 68fe <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6c2>
    68f0:	2080      	movs	r0, #128	; 0x80
    68f2:	6a21      	ldr	r1, [r4, #32]
    68f4:	f7ff fcbe 	bl	6274 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x38>
    68f8:	f885 8001 	strb.w	r8, [r5, #1]
    68fc:	e02c      	b.n	6958 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x71c>
    68fe:	466a      	mov	r2, sp
    6900:	a901      	add	r1, sp, #4
    6902:	6b20      	ldr	r0, [r4, #48]	; 0x30
    6904:	f007 fdbc 	bl	e480 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x48>
    6908:	6220      	str	r0, [r4, #32]
    690a:	b110      	cbz	r0, 6912 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6d6>
    690c:	f895 104b 	ldrb.w	r1, [r5, #75]	; 0x4b
    6910:	b111      	cbz	r1, 6918 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6dc>
    6912:	4842      	ldr	r0, [pc, #264]	; (6a1c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7e0>)
    6914:	6220      	str	r0, [r4, #32]
    6916:	e01f      	b.n	6958 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x71c>
    6918:	f89d 1000 	ldrb.w	r1, [sp]
    691c:	b921      	cbnz	r1, 6928 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x6ec>
    691e:	8007      	strh	r7, [r0, #0]
    6920:	7087      	strb	r7, [r0, #2]
    6922:	2101      	movs	r1, #1
    6924:	f008 f90e 	bl	eb44 <sym_KWWW3Q4Z6LMHA6EXR6CMFCOS3QXXZ636XUAHVBY>
    6928:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    692c:	6a20      	ldr	r0, [r4, #32]
    692e:	f008 f8bd 	bl	eaac <sym_Z7V4WMT2JDSQSNPCH2UEJH6H44L3L7UHMRIWAOA>
    6932:	e011      	b.n	6958 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x71c>
    6934:	f8b6 0054 	ldrh.w	r0, [r6, #84]	; 0x54
    6938:	f8ad 0004 	strh.w	r0, [sp, #4]
    693c:	466a      	mov	r2, sp
    693e:	a901      	add	r1, sp, #4
    6940:	6b20      	ldr	r0, [r4, #48]	; 0x30
    6942:	f007 fd9d 	bl	e480 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x48>
    6946:	6220      	str	r0, [r4, #32]
    6948:	b930      	cbnz	r0, 6958 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x71c>
    694a:	f240 21c6 	movw	r1, #710	; 0x2c6
    694e:	e01e      	b.n	698e <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x752>
    6950:	4648      	mov	r0, r9
    6952:	f7ff fa69 	bl	5e28 <sym_JHXS4T25BAYOMDDZMWPX3HMPENRV73GSV2RYHAI>
    6956:	b1c0      	cbz	r0, 698a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x74e>
    6958:	6a20      	ldr	r0, [r4, #32]
    695a:	2308      	movs	r3, #8
    695c:	7801      	ldrb	r1, [r0, #0]
    695e:	f001 01f7 	and.w	r1, r1, #247	; 0xf7
    6962:	7001      	strb	r1, [r0, #0]
    6964:	79ea      	ldrb	r2, [r5, #7]
    6966:	ea03 02c2 	and.w	r2, r3, r2, lsl #3
    696a:	4311      	orrs	r1, r2
    696c:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
    6970:	7001      	strb	r1, [r0, #0]
    6972:	7a2a      	ldrb	r2, [r5, #8]
    6974:	2304      	movs	r3, #4
    6976:	ea03 0282 	and.w	r2, r3, r2, lsl #2
    697a:	4311      	orrs	r1, r2
    697c:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    6980:	7001      	strb	r1, [r0, #0]
    6982:	43c9      	mvns	r1, r1
    6984:	0789      	lsls	r1, r1, #30
    6986:	d005      	beq.n	6994 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x758>
    6988:	e007      	b.n	699a <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x75e>
    698a:	f240 21cf 	movw	r1, #719	; 0x2cf
    698e:	2027      	movs	r0, #39	; 0x27
    6990:	f7fe fbe0 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6994:	78c0      	ldrb	r0, [r0, #3]
    6996:	2802      	cmp	r0, #2
    6998:	d00f      	beq.n	69ba <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x77e>
    699a:	6b20      	ldr	r0, [r4, #48]	; 0x30
    699c:	f007 f9a0 	bl	dce0 <sym_4WKKRRMMNLQOCTRGC2MVIREG5QOCFUEL67TBUQY>
    69a0:	b108      	cbz	r0, 69a6 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x76a>
    69a2:	2101      	movs	r1, #1
    69a4:	e00a      	b.n	69bc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x780>
    69a6:	6a20      	ldr	r0, [r4, #32]
    69a8:	7800      	ldrb	r0, [r0, #0]
    69aa:	43c0      	mvns	r0, r0
    69ac:	0780      	lsls	r0, r0, #30
    69ae:	d004      	beq.n	69ba <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x77e>
    69b0:	f7ff f9f8 	bl	5da4 <sym_V7MOOXL5SOLISKFFGWJC7M3XDITU574WBQOXGWY>
    69b4:	f080 0101 	eor.w	r1, r0, #1
    69b8:	e000      	b.n	69bc <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x780>
    69ba:	2100      	movs	r1, #0
    69bc:	6a20      	ldr	r0, [r4, #32]
    69be:	7802      	ldrb	r2, [r0, #0]
    69c0:	ea42 1101 	orr.w	r1, r2, r1, lsl #4
    69c4:	7001      	strb	r1, [r0, #0]
    69c6:	7ce9      	ldrb	r1, [r5, #19]
    69c8:	b181      	cbz	r1, 69ec <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7b0>
    69ca:	7841      	ldrb	r1, [r0, #1]
    69cc:	b171      	cbz	r1, 69ec <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7b0>
    69ce:	4814      	ldr	r0, [pc, #80]	; (6a20 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7e4>)
    69d0:	f005 fae8 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    69d4:	4811      	ldr	r0, [pc, #68]	; (6a1c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7e0>)
    69d6:	3828      	subs	r0, #40	; 0x28
    69d8:	7607      	strb	r7, [r0, #24]
    69da:	e9d5 121a 	ldrd	r1, r2, [r5, #104]	; 0x68
    69de:	e9c0 1204 	strd	r1, r2, [r0, #16]
    69e2:	480f      	ldr	r0, [pc, #60]	; (6a20 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7e4>)
    69e4:	6a21      	ldr	r1, [r4, #32]
    69e6:	f004 ff4f 	bl	b888 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA>
    69ea:	e003      	b.n	69f4 <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x7b8>
    69ec:	f005 fada 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    69f0:	f004 ff8c 	bl	b90c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ>
    69f4:	f896 206f 	ldrb.w	r2, [r6, #111]	; 0x6f
    69f8:	2101      	movs	r1, #1
    69fa:	2000      	movs	r0, #0
    69fc:	f005 fb4a 	bl	c094 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q>
    6a00:	f884 8004 	strb.w	r8, [r4, #4]
    6a04:	6a21      	ldr	r1, [r4, #32]
    6a06:	880a      	ldrh	r2, [r1, #0]
    6a08:	8222      	strh	r2, [r4, #16]
    6a0a:	7889      	ldrb	r1, [r1, #2]
    6a0c:	74a1      	strb	r1, [r4, #18]
    6a0e:	f884 8000 	strb.w	r8, [r4]
    6a12:	e8bd 87fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
    6a16:	0000      	.short	0x0000
    6a18:	200000f0 	.word	0x200000f0
    6a1c:	20001170 	.word	0x20001170
    6a20:	20001040 	.word	0x20001040
    6a24:	000066a9 	.word	0x000066a9
    6a28:	00006405 	.word	0x00006405
    6a2c:	000065a5 	.word	0x000065a5
    6a30:	00006811 	.word	0x00006811

00006a34 <sym_3Q2UQ65DVTXA3EZPN34QXGGEFSEA6HOSHLFXCMI>:
    6a34:	4800      	ldr	r0, [pc, #0]	; (6a38 <sym_3Q2UQ65DVTXA3EZPN34QXGGEFSEA6HOSHLFXCMI+0x4>)
    6a36:	4770      	bx	lr
    6a38:	20001ad5 	.word	0x20001ad5

00006a3c <sym_BAUTABQSJLBAZ6GNH7KOF4MJMAA6NF7CDAZNOEQ>:
    6a3c:	4904      	ldr	r1, [pc, #16]	; (6a50 <sym_BAUTABQSJLBAZ6GNH7KOF4MJMAA6NF7CDAZNOEQ+0x14>)
    6a3e:	788a      	ldrb	r2, [r1, #2]
    6a40:	4282      	cmp	r2, r0
    6a42:	d903      	bls.n	6a4c <sym_BAUTABQSJLBAZ6GNH7KOF4MJMAA6NF7CDAZNOEQ+0x10>
    6a44:	4408      	add	r0, r1
    6a46:	f890 0143 	ldrb.w	r0, [r0, #323]	; 0x143
    6a4a:	4770      	bx	lr
    6a4c:	2000      	movs	r0, #0
    6a4e:	4770      	bx	lr
    6a50:	20001902 	.word	0x20001902

00006a54 <sym_F2LWAH27IT4H2IA7TZWGNABUCWINGT6MWXH2WIA>:
    6a54:	4904      	ldr	r1, [pc, #16]	; (6a68 <sym_F2LWAH27IT4H2IA7TZWGNABUCWINGT6MWXH2WIA+0x14>)
    6a56:	788a      	ldrb	r2, [r1, #2]
    6a58:	4282      	cmp	r2, r0
    6a5a:	d903      	bls.n	6a64 <sym_F2LWAH27IT4H2IA7TZWGNABUCWINGT6MWXH2WIA+0x10>
    6a5c:	eb01 1000 	add.w	r0, r1, r0, lsl #4
    6a60:	3083      	adds	r0, #131	; 0x83
    6a62:	4770      	bx	lr
    6a64:	2000      	movs	r0, #0
    6a66:	4770      	bx	lr
    6a68:	20001902 	.word	0x20001902

00006a6c <sym_GV7ZEDU63KACGR6K3NXW7W7XARTADNTCQ3P2HLA>:
    6a6c:	4a05      	ldr	r2, [pc, #20]	; (6a84 <sym_GV7ZEDU63KACGR6K3NXW7W7XARTADNTCQ3P2HLA+0x18>)
    6a6e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    6a72:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    6a76:	6802      	ldr	r2, [r0, #0]
    6a78:	f8c1 210b 	str.w	r2, [r1, #267]	; 0x10b
    6a7c:	8880      	ldrh	r0, [r0, #4]
    6a7e:	f8a1 010f 	strh.w	r0, [r1, #271]	; 0x10f
    6a82:	4770      	bx	lr
    6a84:	20001902 	.word	0x20001902

00006a88 <sym_PLOW4TMGVQT52FP2ERNRL6S5EELE2YO563WRPJA>:
    6a88:	4904      	ldr	r1, [pc, #16]	; (6a9c <sym_PLOW4TMGVQT52FP2ERNRL6S5EELE2YO563WRPJA+0x14>)
    6a8a:	788a      	ldrb	r2, [r1, #2]
    6a8c:	4282      	cmp	r2, r0
    6a8e:	d903      	bls.n	6a98 <sym_PLOW4TMGVQT52FP2ERNRL6S5EELE2YO563WRPJA+0x10>
    6a90:	eb01 1000 	add.w	r0, r1, r0, lsl #4
    6a94:	1cc0      	adds	r0, r0, #3
    6a96:	4770      	bx	lr
    6a98:	2000      	movs	r0, #0
    6a9a:	4770      	bx	lr
    6a9c:	20001902 	.word	0x20001902

00006aa0 <sym_62DUXM4M5AM4URNPP7IKDX3NCPAODBT4BMADGAY>:
    6aa0:	b510      	push	{r4, lr}
    6aa2:	f240 12d3 	movw	r2, #467	; 0x1d3
    6aa6:	2100      	movs	r1, #0
    6aa8:	4808      	ldr	r0, [pc, #32]	; (6acc <sym_62DUXM4M5AM4URNPP7IKDX3NCPAODBT4BMADGAY+0x2c>)
    6aaa:	f006 fb11 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    6aae:	2208      	movs	r2, #8
    6ab0:	21ff      	movs	r1, #255	; 0xff
    6ab2:	4807      	ldr	r0, [pc, #28]	; (6ad0 <sym_62DUXM4M5AM4URNPP7IKDX3NCPAODBT4BMADGAY+0x30>)
    6ab4:	f006 fb0c 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    6ab8:	4805      	ldr	r0, [pc, #20]	; (6ad0 <sym_62DUXM4M5AM4URNPP7IKDX3NCPAODBT4BMADGAY+0x30>)
    6aba:	2100      	movs	r1, #0
    6abc:	1f00      	subs	r0, r0, #4
    6abe:	7001      	strb	r1, [r0, #0]
    6ac0:	7041      	strb	r1, [r0, #1]
    6ac2:	f44f 7161 	mov.w	r1, #900	; 0x384
    6ac6:	8041      	strh	r1, [r0, #2]
    6ac8:	bd10      	pop	{r4, pc}
    6aca:	0000      	.short	0x0000
    6acc:	20001902 	.word	0x20001902
    6ad0:	2000031c 	.word	0x2000031c

00006ad4 <sym_YAOI5BW7G2C6EUUY2B4S7A3CWX63A6MP2T3O5KA>:
    6ad4:	4b0b      	ldr	r3, [pc, #44]	; (6b04 <sym_YAOI5BW7G2C6EUUY2B4S7A3CWX63A6MP2T3O5KA+0x30>)
    6ad6:	b510      	push	{r4, lr}
    6ad8:	789c      	ldrb	r4, [r3, #2]
    6ada:	4284      	cmp	r4, r0
    6adc:	d90f      	bls.n	6afe <sym_YAOI5BW7G2C6EUUY2B4S7A3CWX63A6MP2T3O5KA+0x2a>
    6ade:	4418      	add	r0, r3
    6ae0:	f890 0103 	ldrb.w	r0, [r0, #259]	; 0x103
    6ae4:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    6ae8:	f890 3153 	ldrb.w	r3, [r0, #339]	; 0x153
    6aec:	700b      	strb	r3, [r1, #0]
    6aee:	f8d0 1154 	ldr.w	r1, [r0, #340]	; 0x154
    6af2:	6011      	str	r1, [r2, #0]
    6af4:	f8b0 0158 	ldrh.w	r0, [r0, #344]	; 0x158
    6af8:	8090      	strh	r0, [r2, #4]
    6afa:	2001      	movs	r0, #1
    6afc:	bd10      	pop	{r4, pc}
    6afe:	2000      	movs	r0, #0
    6b00:	bd10      	pop	{r4, pc}
    6b02:	0000      	.short	0x0000
    6b04:	20001902 	.word	0x20001902

00006b08 <sym_IJTA37LCLZMYZVQ3I74HRUK4JDZEZR23VU3JFJI>:
    6b08:	4907      	ldr	r1, [pc, #28]	; (6b28 <sym_IJTA37LCLZMYZVQ3I74HRUK4JDZEZR23VU3JFJI+0x20>)
    6b0a:	788a      	ldrb	r2, [r1, #2]
    6b0c:	4282      	cmp	r2, r0
    6b0e:	d909      	bls.n	6b24 <sym_IJTA37LCLZMYZVQ3I74HRUK4JDZEZR23VU3JFJI+0x1c>
    6b10:	4408      	add	r0, r1
    6b12:	f890 0103 	ldrb.w	r0, [r0, #259]	; 0x103
    6b16:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
    6b1a:	f890 015a 	ldrb.w	r0, [r0, #346]	; 0x15a
    6b1e:	f000 0001 	and.w	r0, r0, #1
    6b22:	4770      	bx	lr
    6b24:	2000      	movs	r0, #0
    6b26:	4770      	bx	lr
    6b28:	20001902 	.word	0x20001902

00006b2c <sym_RHRHCWPUPZHCOID576WBS7QZ2KAUT2GASS2T3QY>:
    6b2c:	4801      	ldr	r0, [pc, #4]	; (6b34 <sym_RHRHCWPUPZHCOID576WBS7QZ2KAUT2GASS2T3QY+0x8>)
    6b2e:	8840      	ldrh	r0, [r0, #2]
    6b30:	4770      	bx	lr
    6b32:	0000      	.short	0x0000
    6b34:	20000318 	.word	0x20000318

00006b38 <sym_QEQGMTIGG3AOZQY7JM4T2FY2O3KM2UFUMT6Q7PI>:
    6b38:	4905      	ldr	r1, [pc, #20]	; (6b50 <sym_QEQGMTIGG3AOZQY7JM4T2FY2O3KM2UFUMT6Q7PI+0x18>)
    6b3a:	788a      	ldrb	r2, [r1, #2]
    6b3c:	4282      	cmp	r2, r0
    6b3e:	d903      	bls.n	6b48 <sym_QEQGMTIGG3AOZQY7JM4T2FY2O3KM2UFUMT6Q7PI+0x10>
    6b40:	4408      	add	r0, r1
    6b42:	f890 013b 	ldrb.w	r0, [r0, #315]	; 0x13b
    6b46:	b108      	cbz	r0, 6b4c <sym_QEQGMTIGG3AOZQY7JM4T2FY2O3KM2UFUMT6Q7PI+0x14>
    6b48:	2000      	movs	r0, #0
    6b4a:	4770      	bx	lr
    6b4c:	2001      	movs	r0, #1
    6b4e:	4770      	bx	lr
    6b50:	20001902 	.word	0x20001902

00006b54 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ>:
    6b54:	b570      	push	{r4, r5, r6, lr}
    6b56:	460d      	mov	r5, r1
    6b58:	4606      	mov	r6, r0
    6b5a:	f000 f8c1 	bl	6ce0 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x104>
    6b5e:	4c10      	ldr	r4, [pc, #64]	; (6ba0 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x4c>)
    6b60:	2810      	cmp	r0, #16
    6b62:	d007      	beq.n	6b74 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x20>
    6b64:	eb04 01c0 	add.w	r1, r4, r0, lsl #3
    6b68:	f891 115a 	ldrb.w	r1, [r1, #346]	; 0x15a
    6b6c:	07c9      	lsls	r1, r1, #31
    6b6e:	d001      	beq.n	6b74 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x20>
    6b70:	2001      	movs	r0, #1
    6b72:	bd70      	pop	{r4, r5, r6, pc}
    6b74:	7861      	ldrb	r1, [r4, #1]
    6b76:	2908      	cmp	r1, #8
    6b78:	d210      	bcs.n	6b9c <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x48>
    6b7a:	2810      	cmp	r0, #16
    6b7c:	d008      	beq.n	6b90 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x3c>
    6b7e:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    6b82:	2101      	movs	r1, #1
    6b84:	f880 115a 	strb.w	r1, [r0, #346]	; 0x15a
    6b88:	7860      	ldrb	r0, [r4, #1]
    6b8a:	1c40      	adds	r0, r0, #1
    6b8c:	7060      	strb	r0, [r4, #1]
    6b8e:	e7ef      	b.n	6b70 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x1c>
    6b90:	2201      	movs	r2, #1
    6b92:	4629      	mov	r1, r5
    6b94:	4630      	mov	r0, r6
    6b96:	f000 f887 	bl	6ca8 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xcc>
    6b9a:	e7f5      	b.n	6b88 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ+0x34>
    6b9c:	2000      	movs	r0, #0
    6b9e:	bd70      	pop	{r4, r5, r6, pc}
    6ba0:	20001902 	.word	0x20001902

00006ba4 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY>:
    6ba4:	b570      	push	{r4, r5, r6, lr}
    6ba6:	4d0b      	ldr	r5, [pc, #44]	; (6bd4 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY+0x30>)
    6ba8:	7828      	ldrb	r0, [r5, #0]
    6baa:	1e40      	subs	r0, r0, #1
    6bac:	b244      	sxtb	r4, r0
    6bae:	e00a      	b.n	6bc6 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY+0x22>
    6bb0:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
    6bb4:	f890 015a 	ldrb.w	r0, [r0, #346]	; 0x15a
    6bb8:	07c0      	lsls	r0, r0, #31
    6bba:	d002      	beq.n	6bc2 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY+0x1e>
    6bbc:	b2e0      	uxtb	r0, r4
    6bbe:	f000 f8ed 	bl	6d9c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1c0>
    6bc2:	1e64      	subs	r4, r4, #1
    6bc4:	b264      	sxtb	r4, r4
    6bc6:	2c00      	cmp	r4, #0
    6bc8:	daf2      	bge.n	6bb0 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY+0xc>
    6bca:	4903      	ldr	r1, [pc, #12]	; (6bd8 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY+0x34>)
    6bcc:	2000      	movs	r0, #0
    6bce:	7048      	strb	r0, [r1, #1]
    6bd0:	bd70      	pop	{r4, r5, r6, pc}
    6bd2:	0000      	.short	0x0000
    6bd4:	20001902 	.word	0x20001902
    6bd8:	20000318 	.word	0x20000318

00006bdc <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY>:
    6bdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6be0:	2400      	movs	r4, #0
    6be2:	4625      	mov	r5, r4
    6be4:	4e18      	ldr	r6, [pc, #96]	; (6c48 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x6c>)
    6be6:	e029      	b.n	6c3c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x60>
    6be8:	eb06 07c5 	add.w	r7, r6, r5, lsl #3
    6bec:	f897 015a 	ldrb.w	r0, [r7, #346]	; 0x15a
    6bf0:	07c0      	lsls	r0, r0, #31
    6bf2:	d021      	beq.n	6c38 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x5c>
    6bf4:	4628      	mov	r0, r5
    6bf6:	f000 f843 	bl	6c80 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xa4>
    6bfa:	4603      	mov	r3, r0
    6bfc:	f7ff ff44 	bl	6a88 <sym_PLOW4TMGVQT52FP2ERNRL6S5EELE2YO563WRPJA>
    6c00:	4601      	mov	r1, r0
    6c02:	2000      	movs	r0, #0
    6c04:	2b10      	cmp	r3, #16
    6c06:	d009      	beq.n	6c1c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x40>
    6c08:	18f2      	adds	r2, r6, r3
    6c0a:	f892 c13b 	ldrb.w	ip, [r2, #315]	; 0x13b
    6c0e:	f1bc 0f01 	cmp.w	ip, #1
    6c12:	d002      	beq.n	6c1a <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x3e>
    6c14:	f892 214b 	ldrb.w	r2, [r2, #331]	; 0x14b
    6c18:	b102      	cbz	r2, 6c1c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x40>
    6c1a:	2001      	movs	r0, #1
    6c1c:	1e40      	subs	r0, r0, #1
    6c1e:	4201      	tst	r1, r0
    6c20:	d10a      	bne.n	6c38 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x5c>
    6c22:	480a      	ldr	r0, [pc, #40]	; (6c4c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x70>)
    6c24:	f507 71aa 	add.w	r1, r7, #340	; 0x154
    6c28:	5503      	strb	r3, [r0, r4]
    6c2a:	4620      	mov	r0, r4
    6c2c:	1c64      	adds	r4, r4, #1
    6c2e:	f897 2153 	ldrb.w	r2, [r7, #339]	; 0x153
    6c32:	b2e4      	uxtb	r4, r4
    6c34:	f005 fb56 	bl	c2e4 <sym_53FPWJRYQVPJEOZPLNZO6VOSTP72TYV5A36KFIY>
    6c38:	1c6d      	adds	r5, r5, #1
    6c3a:	b2ed      	uxtb	r5, r5
    6c3c:	7830      	ldrb	r0, [r6, #0]
    6c3e:	42a8      	cmp	r0, r5
    6c40:	d8d2      	bhi.n	6be8 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xc>
    6c42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6c46:	0000      	.short	0x0000
    6c48:	20001902 	.word	0x20001902
    6c4c:	2000031c 	.word	0x2000031c
    6c50:	4602      	mov	r2, r0
    6c52:	4809      	ldr	r0, [pc, #36]	; (6c78 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x9c>)
    6c54:	b510      	push	{r4, lr}
    6c56:	7800      	ldrb	r0, [r0, #0]
    6c58:	460b      	mov	r3, r1
    6c5a:	b158      	cbz	r0, 6c74 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x98>
    6c5c:	4807      	ldr	r0, [pc, #28]	; (6c7c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xa0>)
    6c5e:	7881      	ldrb	r1, [r0, #2]
    6c60:	b141      	cbz	r1, 6c74 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x98>
    6c62:	b10b      	cbz	r3, 6c68 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x8c>
    6c64:	1cc0      	adds	r0, r0, #3
    6c66:	e001      	b.n	6c6c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x90>
    6c68:	4804      	ldr	r0, [pc, #16]	; (6c7c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xa0>)
    6c6a:	3083      	adds	r0, #131	; 0x83
    6c6c:	f004 fd14 	bl	b698 <sym_MDF364N4PQDEA5ZGP5CB3ZDZVZM5Q32KSEZZ5HI>
    6c70:	2001      	movs	r0, #1
    6c72:	bd10      	pop	{r4, pc}
    6c74:	2000      	movs	r0, #0
    6c76:	bd10      	pop	{r4, pc}
    6c78:	20000318 	.word	0x20000318
    6c7c:	20001902 	.word	0x20001902
    6c80:	4908      	ldr	r1, [pc, #32]	; (6ca4 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xc8>)
    6c82:	b510      	push	{r4, lr}
    6c84:	4603      	mov	r3, r0
    6c86:	2000      	movs	r0, #0
    6c88:	788a      	ldrb	r2, [r1, #2]
    6c8a:	e006      	b.n	6c9a <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xbe>
    6c8c:	180c      	adds	r4, r1, r0
    6c8e:	f894 4103 	ldrb.w	r4, [r4, #259]	; 0x103
    6c92:	429c      	cmp	r4, r3
    6c94:	d004      	beq.n	6ca0 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xc4>
    6c96:	1c40      	adds	r0, r0, #1
    6c98:	b2c0      	uxtb	r0, r0
    6c9a:	4282      	cmp	r2, r0
    6c9c:	d8f6      	bhi.n	6c8c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xb0>
    6c9e:	2010      	movs	r0, #16
    6ca0:	bd10      	pop	{r4, pc}
    6ca2:	0000      	.short	0x0000
    6ca4:	20001902 	.word	0x20001902
    6ca8:	b570      	push	{r4, r5, r6, lr}
    6caa:	4b0c      	ldr	r3, [pc, #48]	; (6cdc <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x100>)
    6cac:	4604      	mov	r4, r0
    6cae:	7818      	ldrb	r0, [r3, #0]
    6cb0:	1c45      	adds	r5, r0, #1
    6cb2:	701d      	strb	r5, [r3, #0]
    6cb4:	2810      	cmp	r0, #16
    6cb6:	d303      	bcc.n	6cc0 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xe4>
    6cb8:	2146      	movs	r1, #70	; 0x46
    6cba:	2028      	movs	r0, #40	; 0x28
    6cbc:	f7fe fa4a 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6cc0:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    6cc4:	680d      	ldr	r5, [r1, #0]
    6cc6:	f8c3 5154 	str.w	r5, [r3, #340]	; 0x154
    6cca:	8889      	ldrh	r1, [r1, #4]
    6ccc:	f8a3 1158 	strh.w	r1, [r3, #344]	; 0x158
    6cd0:	f883 4153 	strb.w	r4, [r3, #339]	; 0x153
    6cd4:	f883 215a 	strb.w	r2, [r3, #346]	; 0x15a
    6cd8:	bd70      	pop	{r4, r5, r6, pc}
    6cda:	0000      	.short	0x0000
    6cdc:	20001902 	.word	0x20001902
    6ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
    6ce2:	4c1a      	ldr	r4, [pc, #104]	; (6d4c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x170>)
    6ce4:	4603      	mov	r3, r0
    6ce6:	2000      	movs	r0, #0
    6ce8:	7825      	ldrb	r5, [r4, #0]
    6cea:	e02a      	b.n	6d42 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x166>
    6cec:	eb04 02c0 	add.w	r2, r4, r0, lsl #3
    6cf0:	780f      	ldrb	r7, [r1, #0]
    6cf2:	f892 c154 	ldrb.w	ip, [r2, #340]	; 0x154
    6cf6:	f892 6153 	ldrb.w	r6, [r2, #339]	; 0x153
    6cfa:	ea87 070c 	eor.w	r7, r7, ip
    6cfe:	405e      	eors	r6, r3
    6d00:	443e      	add	r6, r7
    6d02:	784f      	ldrb	r7, [r1, #1]
    6d04:	f892 c155 	ldrb.w	ip, [r2, #341]	; 0x155
    6d08:	ea87 070c 	eor.w	r7, r7, ip
    6d0c:	443e      	add	r6, r7
    6d0e:	788f      	ldrb	r7, [r1, #2]
    6d10:	f892 c156 	ldrb.w	ip, [r2, #342]	; 0x156
    6d14:	ea87 070c 	eor.w	r7, r7, ip
    6d18:	443e      	add	r6, r7
    6d1a:	78cf      	ldrb	r7, [r1, #3]
    6d1c:	f892 c157 	ldrb.w	ip, [r2, #343]	; 0x157
    6d20:	ea87 070c 	eor.w	r7, r7, ip
    6d24:	443e      	add	r6, r7
    6d26:	790f      	ldrb	r7, [r1, #4]
    6d28:	f892 c158 	ldrb.w	ip, [r2, #344]	; 0x158
    6d2c:	f892 2159 	ldrb.w	r2, [r2, #345]	; 0x159
    6d30:	ea87 070c 	eor.w	r7, r7, ip
    6d34:	443e      	add	r6, r7
    6d36:	794f      	ldrb	r7, [r1, #5]
    6d38:	4057      	eors	r7, r2
    6d3a:	42f7      	cmn	r7, r6
    6d3c:	d004      	beq.n	6d48 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x16c>
    6d3e:	1c40      	adds	r0, r0, #1
    6d40:	b2c0      	uxtb	r0, r0
    6d42:	4285      	cmp	r5, r0
    6d44:	d8d2      	bhi.n	6cec <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x110>
    6d46:	2010      	movs	r0, #16
    6d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6d4a:	0000      	.short	0x0000
    6d4c:	20001902 	.word	0x20001902
    6d50:	b570      	push	{r4, r5, r6, lr}
    6d52:	4605      	mov	r5, r0
    6d54:	f7ff ff94 	bl	6c80 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xa4>
    6d58:	2810      	cmp	r0, #16
    6d5a:	d11c      	bne.n	6d96 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1ba>
    6d5c:	4c0e      	ldr	r4, [pc, #56]	; (6d98 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1bc>)
    6d5e:	7820      	ldrb	r0, [r4, #0]
    6d60:	1e40      	subs	r0, r0, #1
    6d62:	b2c0      	uxtb	r0, r0
    6d64:	7020      	strb	r0, [r4, #0]
    6d66:	42a8      	cmp	r0, r5
    6d68:	d015      	beq.n	6d96 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1ba>
    6d6a:	eb04 02c0 	add.w	r2, r4, r0, lsl #3
    6d6e:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
    6d72:	f502 7080 	add.w	r0, r2, #256	; 0x100
    6d76:	f8d2 2153 	ldr.w	r2, [r2, #339]	; 0x153
    6d7a:	f8c1 2153 	str.w	r2, [r1, #339]	; 0x153
    6d7e:	f8d0 0057 	ldr.w	r0, [r0, #87]	; 0x57
    6d82:	f8c1 0157 	str.w	r0, [r1, #343]	; 0x157
    6d86:	7820      	ldrb	r0, [r4, #0]
    6d88:	f7ff ff7a 	bl	6c80 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xa4>
    6d8c:	2810      	cmp	r0, #16
    6d8e:	d002      	beq.n	6d96 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1ba>
    6d90:	4420      	add	r0, r4
    6d92:	f880 5103 	strb.w	r5, [r0, #259]	; 0x103
    6d96:	bd70      	pop	{r4, r5, r6, pc}
    6d98:	20001902 	.word	0x20001902
    6d9c:	4905      	ldr	r1, [pc, #20]	; (6db4 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1d8>)
    6d9e:	784a      	ldrb	r2, [r1, #1]
    6da0:	1e52      	subs	r2, r2, #1
    6da2:	704a      	strb	r2, [r1, #1]
    6da4:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
    6da8:	2200      	movs	r2, #0
    6daa:	f881 215a 	strb.w	r2, [r1, #346]	; 0x15a
    6dae:	f7ff bfcf 	b.w	6d50 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x174>
    6db2:	0000      	.short	0x0000
    6db4:	20001902 	.word	0x20001902

00006db8 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI>:
    6db8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6dbc:	4604      	mov	r4, r0
    6dbe:	f04f 0801 	mov.w	r8, #1
    6dc2:	b181      	cbz	r1, 6de6 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x2e>
    6dc4:	f104 068f 	add.w	r6, r4, #143	; 0x8f
    6dc8:	1e75      	subs	r5, r6, #1
    6dca:	f104 0078 	add.w	r0, r4, #120	; 0x78
    6dce:	2901      	cmp	r1, #1
    6dd0:	d022      	beq.n	6e18 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x60>
    6dd2:	2902      	cmp	r1, #2
    6dd4:	d045      	beq.n	6e62 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0xaa>
    6dd6:	2903      	cmp	r1, #3
    6dd8:	d11c      	bne.n	6e14 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x5c>
    6dda:	4631      	mov	r1, r6
    6ddc:	4628      	mov	r0, r5
    6dde:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    6de2:	f007 bd6f 	b.w	e8c4 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I>
    6de6:	f44f 7228 	mov.w	r2, #672	; 0x2a0
    6dea:	2100      	movs	r1, #0
    6dec:	f006 f970 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    6df0:	f884 808e 	strb.w	r8, [r4, #142]	; 0x8e
    6df4:	3484      	adds	r4, #132	; 0x84
    6df6:	f004 fc1f 	bl	b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>
    6dfa:	f644 122b 	movw	r2, #18731	; 0x492b
    6dfe:	4010      	ands	r0, r2
    6e00:	6520      	str	r0, [r4, #80]	; 0x50
    6e02:	f001 0106 	and.w	r1, r1, #6
    6e06:	6561      	str	r1, [r4, #84]	; 0x54
    6e08:	20fe      	movs	r0, #254	; 0xfe
    6e0a:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88
    6e0e:	207f      	movs	r0, #127	; 0x7f
    6e10:	f804 0c03 	strb.w	r0, [r4, #-3]
    6e14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6e18:	2700      	movs	r7, #0
    6e1a:	f8a4 71de 	strh.w	r7, [r4, #478]	; 0x1de
    6e1e:	f884 71d3 	strb.w	r7, [r4, #467]	; 0x1d3
    6e22:	4a14      	ldr	r2, [pc, #80]	; (6e74 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0xbc>)
    6e24:	6921      	ldr	r1, [r4, #16]
    6e26:	440a      	add	r2, r1
    6e28:	fbb2 f2f1 	udiv	r2, r2, r1
    6e2c:	f8c4 20ac 	str.w	r2, [r4, #172]	; 0xac
    6e30:	f640 32b8 	movw	r2, #3000	; 0xbb8
    6e34:	f8a4 20b0 	strh.w	r2, [r4, #176]	; 0xb0
    6e38:	8b63      	ldrh	r3, [r4, #26]
    6e3a:	460a      	mov	r2, r1
    6e3c:	f000 f81c 	bl	6e78 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0xc0>
    6e40:	4631      	mov	r1, r6
    6e42:	4628      	mov	r0, r5
    6e44:	f007 fd3e 	bl	e8c4 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I>
    6e48:	f006 f8a4 	bl	cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>
    6e4c:	b118      	cbz	r0, 6e56 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x9e>
    6e4e:	6960      	ldr	r0, [r4, #20]
    6e50:	f000 fbae 	bl	75b0 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY>
    6e54:	b110      	cbz	r0, 6e5c <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0xa4>
    6e56:	f884 71c6 	strb.w	r7, [r4, #454]	; 0x1c6
    6e5a:	e7db      	b.n	6e14 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x5c>
    6e5c:	f884 81c6 	strb.w	r8, [r4, #454]	; 0x1c6
    6e60:	e7d8      	b.n	6e14 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x5c>
    6e62:	f8b4 3282 	ldrh.w	r3, [r4, #642]	; 0x282
    6e66:	f8d4 227c 	ldr.w	r2, [r4, #636]	; 0x27c
    6e6a:	6921      	ldr	r1, [r4, #16]
    6e6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    6e70:	f000 b802 	b.w	6e78 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0xc0>
    6e74:	01c9c37f 	.word	0x01c9c37f
    6e78:	b530      	push	{r4, r5, lr}
    6e7a:	2400      	movs	r4, #0
    6e7c:	8784      	strh	r4, [r0, #60]	; 0x3c
    6e7e:	f8b0 4040 	ldrh.w	r4, [r0, #64]	; 0x40
    6e82:	4d15      	ldr	r5, [pc, #84]	; (6ed8 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x120>)
    6e84:	434c      	muls	r4, r1
    6e86:	fbb4 f4f2 	udiv	r4, r4, r2
    6e8a:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
    6e8e:	f242 7410 	movw	r4, #10000	; 0x2710
    6e92:	4363      	muls	r3, r4
    6e94:	fbb3 f3f2 	udiv	r3, r3, r2
    6e98:	1c5b      	adds	r3, r3, #1
    6e9a:	b29b      	uxth	r3, r3
    6e9c:	fb03 f402 	mul.w	r4, r3, r2
    6ea0:	87c3      	strh	r3, [r0, #62]	; 0x3e
    6ea2:	42ac      	cmp	r4, r5
    6ea4:	d901      	bls.n	6eaa <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0xf2>
    6ea6:	1e5b      	subs	r3, r3, #1
    6ea8:	87c3      	strh	r3, [r0, #62]	; 0x3e
    6eaa:	4b0c      	ldr	r3, [pc, #48]	; (6edc <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI+0x124>)
    6eac:	f240 2471 	movw	r4, #625	; 0x271
    6eb0:	fbb3 f3f2 	udiv	r3, r3, r2
    6eb4:	1c5b      	adds	r3, r3, #1
    6eb6:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
    6eba:	8f03      	ldrh	r3, [r0, #56]	; 0x38
    6ebc:	4363      	muls	r3, r4
    6ebe:	eb02 1303 	add.w	r3, r2, r3, lsl #4
    6ec2:	1e5b      	subs	r3, r3, #1
    6ec4:	fbb3 f3f2 	udiv	r3, r3, r2
    6ec8:	6343      	str	r3, [r0, #52]	; 0x34
    6eca:	6b03      	ldr	r3, [r0, #48]	; 0x30
    6ecc:	434b      	muls	r3, r1
    6ece:	fbb3 f1f2 	udiv	r1, r3, r2
    6ed2:	6301      	str	r1, [r0, #48]	; 0x30
    6ed4:	bd30      	pop	{r4, r5, pc}
    6ed6:	0000      	.short	0x0000
    6ed8:	01e84800 	.word	0x01e84800
    6edc:	02625a00 	.word	0x02625a00

00006ee0 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ>:
    6ee0:	b570      	push	{r4, r5, r6, lr}
    6ee2:	ea81 4111 	eor.w	r1, r1, r1, lsr #16
    6ee6:	b28b      	uxth	r3, r1
    6ee8:	7ac5      	ldrb	r5, [r0, #11]
    6eea:	ea83 0102 	eor.w	r1, r3, r2
    6eee:	2200      	movs	r2, #0
    6ef0:	b2cc      	uxtb	r4, r1
    6ef2:	0a09      	lsrs	r1, r1, #8
    6ef4:	fa94 f4a4 	rbit	r4, r4
    6ef8:	fa91 f1a1 	rbit	r1, r1
    6efc:	0e24      	lsrs	r4, r4, #24
    6efe:	0e09      	lsrs	r1, r1, #24
    6f00:	ea44 2101 	orr.w	r1, r4, r1, lsl #8
    6f04:	eb01 1101 	add.w	r1, r1, r1, lsl #4
    6f08:	1c52      	adds	r2, r2, #1
    6f0a:	4419      	add	r1, r3
    6f0c:	b2d2      	uxtb	r2, r2
    6f0e:	b289      	uxth	r1, r1
    6f10:	2a03      	cmp	r2, #3
    6f12:	d3ed      	bcc.n	6ef0 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x10>
    6f14:	4059      	eors	r1, r3
    6f16:	2225      	movs	r2, #37	; 0x25
    6f18:	fbb1 f3f2 	udiv	r3, r1, r2
    6f1c:	fb02 1213 	mls	r2, r2, r3, r1
    6f20:	eb00 03d2 	add.w	r3, r0, r2, lsr #3
    6f24:	f002 0607 	and.w	r6, r2, #7
    6f28:	785b      	ldrb	r3, [r3, #1]
    6f2a:	2401      	movs	r4, #1
    6f2c:	fa04 f606 	lsl.w	r6, r4, r6
    6f30:	4233      	tst	r3, r6
    6f32:	d001      	beq.n	6f38 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x58>
    6f34:	4610      	mov	r0, r2
    6f36:	bd70      	pop	{r4, r5, r6, pc}
    6f38:	434d      	muls	r5, r1
    6f3a:	0c29      	lsrs	r1, r5, #16
    6f3c:	1c49      	adds	r1, r1, #1
    6f3e:	b2c9      	uxtb	r1, r1
    6f40:	2200      	movs	r2, #0
    6f42:	1885      	adds	r5, r0, r2
    6f44:	79ab      	ldrb	r3, [r5, #6]
    6f46:	428b      	cmp	r3, r1
    6f48:	d312      	bcc.n	6f70 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x90>
    6f4a:	f895 5001 	ldrb.w	r5, [r5, #1]
    6f4e:	2300      	movs	r3, #0
    6f50:	fa04 f603 	lsl.w	r6, r4, r3
    6f54:	4235      	tst	r5, r6
    6f56:	d001      	beq.n	6f5c <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x7c>
    6f58:	1e49      	subs	r1, r1, #1
    6f5a:	b2c9      	uxtb	r1, r1
    6f5c:	b121      	cbz	r1, 6f68 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x88>
    6f5e:	1c5b      	adds	r3, r3, #1
    6f60:	b2db      	uxtb	r3, r3
    6f62:	2b08      	cmp	r3, #8
    6f64:	d3f4      	bcc.n	6f50 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x70>
    6f66:	e005      	b.n	6f74 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x94>
    6f68:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
    6f6c:	b2c0      	uxtb	r0, r0
    6f6e:	bd70      	pop	{r4, r5, r6, pc}
    6f70:	1ac9      	subs	r1, r1, r3
    6f72:	b2c9      	uxtb	r1, r1
    6f74:	1c52      	adds	r2, r2, #1
    6f76:	b2d2      	uxtb	r2, r2
    6f78:	2a05      	cmp	r2, #5
    6f7a:	d3e2      	bcc.n	6f42 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x62>
    6f7c:	f240 110d 	movw	r1, #269	; 0x10d
    6f80:	2046      	movs	r0, #70	; 0x46
    6f82:	f7fe f8e7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    6f86:	0000      	movs	r0, r0
    6f88:	b570      	push	{r4, r5, r6, lr}
    6f8a:	f890 2023 	ldrb.w	r2, [r0, #35]	; 0x23
    6f8e:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
    6f92:	2401      	movs	r4, #1
    6f94:	fb03 2101 	mla	r1, r3, r1, r2
    6f98:	2225      	movs	r2, #37	; 0x25
    6f9a:	fbb1 f3f2 	udiv	r3, r1, r2
    6f9e:	fb02 1113 	mls	r1, r2, r3, r1
    6fa2:	eb00 02d1 	add.w	r2, r0, r1, lsr #3
    6fa6:	f880 1023 	strb.w	r1, [r0, #35]	; 0x23
    6faa:	f001 0307 	and.w	r3, r1, #7
    6fae:	7dd2      	ldrb	r2, [r2, #23]
    6fb0:	fa04 f303 	lsl.w	r3, r4, r3
    6fb4:	421a      	tst	r2, r3
    6fb6:	d003      	beq.n	6fc0 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0xe0>
    6fb8:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
    6fbc:	2000      	movs	r0, #0
    6fbe:	bd70      	pop	{r4, r5, r6, pc}
    6fc0:	f890 2021 	ldrb.w	r2, [r0, #33]	; 0x21
    6fc4:	fbb1 f3f2 	udiv	r3, r1, r2
    6fc8:	fb02 1113 	mls	r1, r2, r3, r1
    6fcc:	1c49      	adds	r1, r1, #1
    6fce:	b2c9      	uxtb	r1, r1
    6fd0:	2300      	movs	r3, #0
    6fd2:	18c5      	adds	r5, r0, r3
    6fd4:	7f2a      	ldrb	r2, [r5, #28]
    6fd6:	428a      	cmp	r2, r1
    6fd8:	d311      	bcc.n	6ffe <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x11e>
    6fda:	f895 5017 	ldrb.w	r5, [r5, #23]
    6fde:	2200      	movs	r2, #0
    6fe0:	fa04 f602 	lsl.w	r6, r4, r2
    6fe4:	4235      	tst	r5, r6
    6fe6:	d001      	beq.n	6fec <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x10c>
    6fe8:	1e49      	subs	r1, r1, #1
    6fea:	b2c9      	uxtb	r1, r1
    6fec:	b121      	cbz	r1, 6ff8 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x118>
    6fee:	1c52      	adds	r2, r2, #1
    6ff0:	b2d2      	uxtb	r2, r2
    6ff2:	2a08      	cmp	r2, #8
    6ff4:	d3f4      	bcc.n	6fe0 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0x100>
    6ff6:	e004      	b.n	7002 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2>
    6ff8:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    6ffc:	e7dc      	b.n	6fb8 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0xd8>
    6ffe:	1a89      	subs	r1, r1, r2
    7000:	b2c9      	uxtb	r1, r1
    7002:	1c5b      	adds	r3, r3, #1
    7004:	b2db      	uxtb	r3, r3
    7006:	2b05      	cmp	r3, #5
    7008:	d3e3      	bcc.n	6fd2 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0xf2>
    700a:	201f      	movs	r0, #31
    700c:	bd70      	pop	{r4, r5, r6, pc}
	...

00007010 <sym_AQNKAYNIT4GTGTVAKOZJZSWZBN4I6FFKO6L5AXA>:
    7010:	7841      	ldrb	r1, [r0, #1]
    7012:	b141      	cbz	r1, 7026 <sym_AQNKAYNIT4GTGTVAKOZJZSWZBN4I6FFKO6L5AXA+0x16>
    7014:	78c0      	ldrb	r0, [r0, #3]
    7016:	2826      	cmp	r0, #38	; 0x26
    7018:	d203      	bcs.n	7022 <sym_AQNKAYNIT4GTGTVAKOZJZSWZBN4I6FFKO6L5AXA+0x12>
    701a:	4a04      	ldr	r2, [pc, #16]	; (702c <sym_AQNKAYNIT4GTGTVAKOZJZSWZBN4I6FFKO6L5AXA+0x1c>)
    701c:	5c10      	ldrb	r0, [r2, r0]
    701e:	4288      	cmp	r0, r1
    7020:	d101      	bne.n	7026 <sym_AQNKAYNIT4GTGTVAKOZJZSWZBN4I6FFKO6L5AXA+0x16>
    7022:	2001      	movs	r0, #1
    7024:	4770      	bx	lr
    7026:	2000      	movs	r0, #0
    7028:	4770      	bx	lr
    702a:	0000      	.short	0x0000
    702c:	00010e14 	.word	0x00010e14

00007030 <sym_ASSU5HSD7LU7BXC2C2QNNVLB6AOHO4SQ3KK3OJY>:
    7030:	b510      	push	{r4, lr}
    7032:	2201      	movs	r2, #1
    7034:	70c1      	strb	r1, [r0, #3]
    7036:	2926      	cmp	r1, #38	; 0x26
    7038:	d202      	bcs.n	7040 <sym_ASSU5HSD7LU7BXC2C2QNNVLB6AOHO4SQ3KK3OJY+0x10>
    703a:	4a06      	ldr	r2, [pc, #24]	; (7054 <sym_ASSU5HSD7LU7BXC2C2QNNVLB6AOHO4SQ3KK3OJY+0x24>)
    703c:	5c52      	ldrb	r2, [r2, r1]
    703e:	e006      	b.n	704e <sym_ASSU5HSD7LU7BXC2C2QNNVLB6AOHO4SQ3KK3OJY+0x1e>
    7040:	29ff      	cmp	r1, #255	; 0xff
    7042:	d004      	beq.n	704e <sym_ASSU5HSD7LU7BXC2C2QNNVLB6AOHO4SQ3KK3OJY+0x1e>
    7044:	f240 411d 	movw	r1, #1053	; 0x41d
    7048:	202a      	movs	r0, #42	; 0x2a
    704a:	f7fe f883 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    704e:	7042      	strb	r2, [r0, #1]
    7050:	bd10      	pop	{r4, pc}
    7052:	0000      	.short	0x0000
    7054:	00010e14 	.word	0x00010e14

00007058 <sym_5INKXEHJ7NSOP6JSEWOYQNB6PUCWPUG5RVXPDVA>:
    7058:	4904      	ldr	r1, [pc, #16]	; (706c <sym_5INKXEHJ7NSOP6JSEWOYQNB6PUCWPUG5RVXPDVA+0x14>)
    705a:	7c89      	ldrb	r1, [r1, #18]
    705c:	0749      	lsls	r1, r1, #29
    705e:	d400      	bmi.n	7062 <sym_5INKXEHJ7NSOP6JSEWOYQNB6PUCWPUG5RVXPDVA+0xa>
    7060:	b108      	cbz	r0, 7066 <sym_5INKXEHJ7NSOP6JSEWOYQNB6PUCWPUG5RVXPDVA+0xe>
    7062:	2000      	movs	r0, #0
    7064:	4770      	bx	lr
    7066:	2001      	movs	r0, #1
    7068:	4770      	bx	lr
    706a:	0000      	.short	0x0000
    706c:	2000165c 	.word	0x2000165c

00007070 <sym_56NG23UACCBJRJHKQI4X4VNMARWQXHUE4R3NK7I>:
    7070:	4803      	ldr	r0, [pc, #12]	; (7080 <sym_56NG23UACCBJRJHKQI4X4VNMARWQXHUE4R3NK7I+0x10>)
    7072:	7c80      	ldrb	r0, [r0, #18]
    7074:	0780      	lsls	r0, r0, #30
    7076:	d401      	bmi.n	707c <sym_56NG23UACCBJRJHKQI4X4VNMARWQXHUE4R3NK7I+0xc>
    7078:	2001      	movs	r0, #1
    707a:	4770      	bx	lr
    707c:	2000      	movs	r0, #0
    707e:	4770      	bx	lr
    7080:	2000165c 	.word	0x2000165c

00007084 <sym_N2NJCIBZFHVP7II7LSOD6U4WPOYSC3U3IRJ6NLY>:
    7084:	4803      	ldr	r0, [pc, #12]	; (7094 <sym_N2NJCIBZFHVP7II7LSOD6U4WPOYSC3U3IRJ6NLY+0x10>)
    7086:	7c80      	ldrb	r0, [r0, #18]
    7088:	07c0      	lsls	r0, r0, #31
    708a:	d001      	beq.n	7090 <sym_N2NJCIBZFHVP7II7LSOD6U4WPOYSC3U3IRJ6NLY+0xc>
    708c:	2000      	movs	r0, #0
    708e:	4770      	bx	lr
    7090:	2001      	movs	r0, #1
    7092:	4770      	bx	lr
    7094:	2000165c 	.word	0x2000165c

00007098 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA>:
    7098:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    709c:	4c12      	ldr	r4, [pc, #72]	; (70e8 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x50>)
    709e:	4607      	mov	r7, r0
    70a0:	460e      	mov	r6, r1
    70a2:	7da0      	ldrb	r0, [r4, #22]
    70a4:	b110      	cbz	r0, 70ac <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x14>
    70a6:	8b20      	ldrh	r0, [r4, #24]
    70a8:	2800      	cmp	r0, #0
    70aa:	d012      	beq.n	70d2 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x3a>
    70ac:	480e      	ldr	r0, [pc, #56]	; (70e8 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x50>)
    70ae:	3014      	adds	r0, #20
    70b0:	4680      	mov	r8, r0
    70b2:	f007 fdc6 	bl	ec42 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I>
    70b6:	b9a8      	cbnz	r0, 70e4 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x4c>
    70b8:	8aa5      	ldrh	r5, [r4, #20]
    70ba:	8aa0      	ldrh	r0, [r4, #20]
    70bc:	4632      	mov	r2, r6
    70be:	4639      	mov	r1, r7
    70c0:	f007 fe03 	bl	ecca <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x2e>
    70c4:	b138      	cbz	r0, 70d6 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x3e>
    70c6:	7da0      	ldrb	r0, [r4, #22]
    70c8:	b110      	cbz	r0, 70d0 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x38>
    70ca:	8b20      	ldrh	r0, [r4, #24]
    70cc:	1e40      	subs	r0, r0, #1
    70ce:	8320      	strh	r0, [r4, #24]
    70d0:	2001      	movs	r0, #1
    70d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    70d6:	4640      	mov	r0, r8
    70d8:	f007 fdb3 	bl	ec42 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I>
    70dc:	b910      	cbnz	r0, 70e4 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x4c>
    70de:	8aa0      	ldrh	r0, [r4, #20]
    70e0:	42a8      	cmp	r0, r5
    70e2:	d1ea      	bne.n	70ba <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x22>
    70e4:	2000      	movs	r0, #0
    70e6:	e7f4      	b.n	70d2 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x3a>
    70e8:	2000165c 	.word	0x2000165c
    70ec:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    70f0:	468a      	mov	sl, r1
    70f2:	4699      	mov	r9, r3
    70f4:	4615      	mov	r5, r2
    70f6:	4604      	mov	r4, r0
    70f8:	a901      	add	r1, sp, #4
    70fa:	f007 fa04 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    70fe:	bbe0      	cbnz	r0, 717a <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xe2>
    7100:	9f02      	ldr	r7, [sp, #8]
    7102:	f04f 0800 	mov.w	r8, #0
    7106:	3778      	adds	r7, #120	; 0x78
    7108:	b18d      	cbz	r5, 712e <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x96>
    710a:	4620      	mov	r0, r4
    710c:	f7fe fc60 	bl	59d0 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA>
    7110:	0004      	movs	r4, r0
    7112:	d00f      	beq.n	7134 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x9c>
    7114:	4629      	mov	r1, r5
    7116:	f006 fdb5 	bl	dc84 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY>
    711a:	0006      	movs	r6, r0
    711c:	d003      	beq.n	7126 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x8e>
    711e:	481d      	ldr	r0, [pc, #116]	; (7194 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xfc>)
    7120:	8840      	ldrh	r0, [r0, #2]
    7122:	42a8      	cmp	r0, r5
    7124:	d208      	bcs.n	7138 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xa0>
    7126:	2000      	movs	r0, #0
    7128:	b004      	add	sp, #16
    712a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    712e:	2001      	movs	r0, #1
    7130:	7578      	strb	r0, [r7, #21]
    7132:	e029      	b.n	7188 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xf0>
    7134:	216e      	movs	r1, #110	; 0x6e
    7136:	e02a      	b.n	718e <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xf6>
    7138:	4620      	mov	r0, r4
    713a:	4631      	mov	r1, r6
    713c:	aa03      	add	r2, sp, #12
    713e:	f006 fd9a 	bl	dc76 <sym_DY52YMZFQPMDNFDSVZDQLPFIWKOSXIQIEKUVZNY>
    7142:	9803      	ldr	r0, [sp, #12]
    7144:	f8a0 8000 	strh.w	r8, [r0]
    7148:	f880 8002 	strb.w	r8, [r0, #2]
    714c:	7d79      	ldrb	r1, [r7, #21]
    714e:	b109      	cbz	r1, 7154 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xbc>
    7150:	f04f 0a02 	mov.w	sl, #2
    7154:	4651      	mov	r1, sl
    7156:	f007 fcf5 	bl	eb44 <sym_KWWW3Q4Z6LMHA6EXR6CMFCOS3QXXZ636XUAHVBY>
    715a:	4631      	mov	r1, r6
    715c:	2603      	movs	r6, #3
    715e:	4620      	mov	r0, r4
    7160:	464a      	mov	r2, r9
    7162:	462b      	mov	r3, r5
    7164:	9600      	str	r6, [sp, #0]
    7166:	f006 fc7a 	bl	da5e <sym_KYAZRCYN475PHPCZD6L3YCVO72SQVA3SBOAY44Q>
    716a:	4620      	mov	r0, r4
    716c:	4629      	mov	r1, r5
    716e:	f006 fd3b 	bl	dbe8 <sym_TDLIKQLE652KPCFAMYL33G6BKGPHRLYLWNEOTHQ>
    7172:	b158      	cbz	r0, 718c <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xf4>
    7174:	4644      	mov	r4, r8
    7176:	a801      	add	r0, sp, #4
    7178:	e000      	b.n	717c <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xe4>
    717a:	e005      	b.n	7188 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0xf0>
    717c:	f007 fd82 	bl	ec84 <sym_24AALTDC2IQ6VNWU2ALOY4V3RG5R2RARTUG4AZY>
    7180:	9802      	ldr	r0, [sp, #8]
    7182:	f8a0 41ca 	strh.w	r4, [r0, #458]	; 0x1ca
    7186:	757c      	strb	r4, [r7, #21]
    7188:	2001      	movs	r0, #1
    718a:	e7cd      	b.n	7128 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x90>
    718c:	2184      	movs	r1, #132	; 0x84
    718e:	202b      	movs	r0, #43	; 0x2b
    7190:	f7fd ffe0 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    7194:	2000165c 	.word	0x2000165c

00007198 <sym_HHT5YV37VWRBGUMO4AOJUKOJARZKAH2OUWPZF7Q>:
    7198:	4901      	ldr	r1, [pc, #4]	; (71a0 <sym_HHT5YV37VWRBGUMO4AOJUKOJARZKAH2OUWPZF7Q+0x8>)
    719a:	2001      	movs	r0, #1
    719c:	7008      	strb	r0, [r1, #0]
    719e:	4770      	bx	lr
    71a0:	20001ae5 	.word	0x20001ae5

000071a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>:
    71a4:	b538      	push	{r3, r4, r5, lr}
    71a6:	b198      	cbz	r0, 71d0 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA+0x2c>
    71a8:	7a03      	ldrb	r3, [r0, #8]
    71aa:	f88d 3000 	strb.w	r3, [sp]
    71ae:	9b00      	ldr	r3, [sp, #0]
    71b0:	9300      	str	r3, [sp, #0]
    71b2:	f89d 3000 	ldrb.w	r3, [sp]
    71b6:	2b00      	cmp	r3, #0
    71b8:	d114      	bne.n	71e4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA+0x40>
    71ba:	6003      	str	r3, [r0, #0]
    71bc:	6041      	str	r1, [r0, #4]
    71be:	f3ef 8310 	mrs	r3, PRIMASK
    71c2:	b672      	cpsid	i
    71c4:	4908      	ldr	r1, [pc, #32]	; (71e8 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA+0x44>)
    71c6:	680c      	ldr	r4, [r1, #0]
    71c8:	b13c      	cbz	r4, 71da <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA+0x36>
    71ca:	684c      	ldr	r4, [r1, #4]
    71cc:	6020      	str	r0, [r4, #0]
    71ce:	e005      	b.n	71dc <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA+0x38>
    71d0:	f240 4141 	movw	r1, #1089	; 0x441
    71d4:	2010      	movs	r0, #16
    71d6:	f7fd ffbd 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    71da:	6008      	str	r0, [r1, #0]
    71dc:	6048      	str	r0, [r1, #4]
    71de:	b903      	cbnz	r3, 71e2 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA+0x3e>
    71e0:	b662      	cpsie	i
    71e2:	7202      	strb	r2, [r0, #8]
    71e4:	bd38      	pop	{r3, r4, r5, pc}
    71e6:	0000      	.short	0x0000
    71e8:	20000114 	.word	0x20000114

000071ec <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q>:
    71ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    71f0:	0004      	movs	r4, r0
    71f2:	d00a      	beq.n	720a <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x1e>
    71f4:	484d      	ldr	r0, [pc, #308]	; (732c <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x140>)
    71f6:	2600      	movs	r6, #0
    71f8:	7801      	ldrb	r1, [r0, #0]
    71fa:	b149      	cbz	r1, 7210 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x24>
    71fc:	7066      	strb	r6, [r4, #1]
    71fe:	2103      	movs	r1, #3
    7200:	7021      	strb	r1, [r4, #0]
    7202:	2101      	movs	r1, #1
    7204:	7121      	strb	r1, [r4, #4]
    7206:	7006      	strb	r6, [r0, #0]
    7208:	e08d      	b.n	7326 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x13a>
    720a:	f240 315d 	movw	r1, #861	; 0x35d
    720e:	e050      	b.n	72b2 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xc6>
    7210:	f8df 811c 	ldr.w	r8, [pc, #284]	; 7330 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x144>
    7214:	f88d 6000 	strb.w	r6, [sp]
    7218:	4668      	mov	r0, sp
    721a:	f000 f8b9 	bl	7390 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x2c>
    721e:	f89d 1000 	ldrb.w	r1, [sp]
    7222:	2900      	cmp	r1, #0
    7224:	d1f8      	bne.n	7218 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x2c>
    7226:	2800      	cmp	r0, #0
    7228:	d07e      	beq.n	7328 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x13c>
    722a:	4605      	mov	r5, r0
    722c:	7a00      	ldrb	r0, [r0, #8]
    722e:	f88d 0000 	strb.w	r0, [sp]
    7232:	9800      	ldr	r0, [sp, #0]
    7234:	9000      	str	r0, [sp, #0]
    7236:	f89d 7000 	ldrb.w	r7, [sp]
    723a:	2f1f      	cmp	r7, #31
    723c:	d26e      	bcs.n	731c <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x130>
    723e:	e8df f007 	tbb	[pc, r7]
    7242:	3d6d      	.short	0x3d6d
    7244:	3d6d106d 	.word	0x3d6d106d
    7248:	3d3d4d3d 	.word	0x3d3d4d3d
    724c:	6d3d3d3d 	.word	0x6d3d3d3d
    7250:	3d3d6d10 	.word	0x3d3d6d10
    7254:	6d6d6d10 	.word	0x6d6d6d10
    7258:	103d3d6d 	.word	0x103d3d6d
    725c:	626d3d3d 	.word	0x626d3d3d
    7260:	0010      	.short	0x0010
    7262:	4834      	ldr	r0, [pc, #208]	; (7334 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x148>)
    7264:	6803      	ldr	r3, [r0, #0]
    7266:	2b00      	cmp	r3, #0
    7268:	d05c      	beq.n	7324 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x138>
    726a:	6868      	ldr	r0, [r5, #4]
    726c:	463a      	mov	r2, r7
    726e:	4621      	mov	r1, r4
    7270:	4798      	blx	r3
    7272:	7820      	ldrb	r0, [r4, #0]
    7274:	6869      	ldr	r1, [r5, #4]
    7276:	2811      	cmp	r0, #17
    7278:	d002      	beq.n	7280 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x94>
    727a:	2814      	cmp	r0, #20
    727c:	d003      	beq.n	7286 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x9a>
    727e:	e01b      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7280:	7920      	ldrb	r0, [r4, #4]
    7282:	b930      	cbnz	r0, 7292 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xa6>
    7284:	e018      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7286:	7920      	ldrb	r0, [r4, #4]
    7288:	b1b0      	cbz	r0, 72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    728a:	4608      	mov	r0, r1
    728c:	f008 f831 	bl	f2f2 <sym_XRU76NANM3C4EMKWQU3DF6CELSRNDV6766IKPJI>
    7290:	b990      	cbnz	r0, 72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7292:	88e4      	ldrh	r4, [r4, #6]
    7294:	2100      	movs	r1, #0
    7296:	4620      	mov	r0, r4
    7298:	f006 fea7 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
    729c:	b160      	cbz	r0, 72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    729e:	8800      	ldrh	r0, [r0, #0]
    72a0:	f007 f861 	bl	e366 <sym_REO6MG4FRJTNQQ56RDJDYGEWFEO5TFVYGRW6OLI>
    72a4:	2100      	movs	r1, #0
    72a6:	4620      	mov	r0, r4
    72a8:	f7fe f9e8 	bl	567c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY>
    72ac:	b120      	cbz	r0, 72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    72ae:	f44f 71af 	mov.w	r1, #350	; 0x15e
    72b2:	2010      	movs	r0, #16
    72b4:	f7fd ff4e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    72b8:	722e      	strb	r6, [r5, #8]
    72ba:	e034      	b.n	7326 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x13a>
    72bc:	f8d8 0000 	ldr.w	r0, [r8]
    72c0:	b358      	cbz	r0, 731a <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x12e>
    72c2:	463a      	mov	r2, r7
    72c4:	4629      	mov	r1, r5
    72c6:	4620      	mov	r0, r4
    72c8:	f000 f892 	bl	73f0 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x8c>
    72cc:	b110      	cbz	r0, 72d4 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xe8>
    72ce:	2f0b      	cmp	r7, #11
    72d0:	d029      	beq.n	7326 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x13a>
    72d2:	e7f1      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    72d4:	2f0b      	cmp	r7, #11
    72d6:	d026      	beq.n	7326 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x13a>
    72d8:	722e      	strb	r6, [r5, #8]
    72da:	e79b      	b.n	7214 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x28>
    72dc:	f8d8 0000 	ldr.w	r0, [r8]
    72e0:	b180      	cbz	r0, 7304 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x118>
    72e2:	6868      	ldr	r0, [r5, #4]
    72e4:	7066      	strb	r6, [r4, #1]
    72e6:	2108      	movs	r1, #8
    72e8:	7021      	strb	r1, [r4, #0]
    72ea:	8801      	ldrh	r1, [r0, #0]
    72ec:	80a1      	strh	r1, [r4, #4]
    72ee:	f8d0 1290 	ldr.w	r1, [r0, #656]	; 0x290
    72f2:	f8c4 1006 	str.w	r1, [r4, #6]
    72f6:	f8d0 1294 	ldr.w	r1, [r0, #660]	; 0x294
    72fa:	f8c4 100a 	str.w	r1, [r4, #10]
    72fe:	f8b0 0298 	ldrh.w	r0, [r0, #664]	; 0x298
    7302:	81e0      	strh	r0, [r4, #14]
    7304:	e7d8      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7306:	480c      	ldr	r0, [pc, #48]	; (7338 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x14c>)
    7308:	6803      	ldr	r3, [r0, #0]
    730a:	b11b      	cbz	r3, 7314 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x128>
    730c:	2200      	movs	r2, #0
    730e:	4621      	mov	r1, r4
    7310:	4610      	mov	r0, r2
    7312:	4798      	blx	r3
    7314:	e7d0      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7316:	e007      	b.n	7328 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x13c>
    7318:	e000      	b.n	731c <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x130>
    731a:	e002      	b.n	7322 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0x136>
    731c:	f240 412d 	movw	r1, #1069	; 0x42d
    7320:	e7c7      	b.n	72b2 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xc6>
    7322:	e7c9      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7324:	e7c8      	b.n	72b8 <sym_XOOTGCSEAKA3PUKZW3QYB4DCVC2FKUP2TS5AZ5Q+0xcc>
    7326:	2001      	movs	r0, #1
    7328:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    732c:	20001ae5 	.word	0x20001ae5
    7330:	20000120 	.word	0x20000120
    7334:	2000011c 	.word	0x2000011c
    7338:	20000124 	.word	0x20000124

0000733c <sym_VKBDHCW5KWYFAEZJJBKQNHH4JDURIHHEJCK4SOA>:
    733c:	4901      	ldr	r1, [pc, #4]	; (7344 <sym_VKBDHCW5KWYFAEZJJBKQNHH4JDURIHHEJCK4SOA+0x8>)
    733e:	7008      	strb	r0, [r1, #0]
    7340:	f000 b928 	b.w	7594 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x230>
    7344:	20000110 	.word	0x20000110

00007348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>:
    7348:	4801      	ldr	r0, [pc, #4]	; (7350 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI+0x8>)
    734a:	7800      	ldrb	r0, [r0, #0]
    734c:	f7fd bd06 	b.w	4d5c <sym_GURZ3AH6X65RGSKYMYNWZVP6HM56LA5MRAQWT6Q>
    7350:	20000110 	.word	0x20000110

00007354 <sym_2ZDP75C7NTGGQLOC7B3VQWZBDYTVYDPXMMVG73Q>:
    7354:	4902      	ldr	r1, [pc, #8]	; (7360 <sym_2ZDP75C7NTGGQLOC7B3VQWZBDYTVYDPXMMVG73Q+0xc>)
    7356:	4801      	ldr	r0, [pc, #4]	; (735c <sym_2ZDP75C7NTGGQLOC7B3VQWZBDYTVYDPXMMVG73Q+0x8>)
    7358:	6008      	str	r0, [r1, #0]
    735a:	4770      	bx	lr
    735c:	0000f21d 	.word	0x0000f21d
    7360:	2000011c 	.word	0x2000011c

00007364 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q>:
    7364:	4905      	ldr	r1, [pc, #20]	; (737c <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x18>)
    7366:	4804      	ldr	r0, [pc, #16]	; (7378 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x14>)
    7368:	6008      	str	r0, [r1, #0]
    736a:	4906      	ldr	r1, [pc, #24]	; (7384 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x20>)
    736c:	4804      	ldr	r0, [pc, #16]	; (7380 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1c>)
    736e:	6008      	str	r0, [r1, #0]
    7370:	4906      	ldr	r1, [pc, #24]	; (738c <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x28>)
    7372:	4805      	ldr	r0, [pc, #20]	; (7388 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x24>)
    7374:	6008      	str	r0, [r1, #0]
    7376:	4770      	bx	lr
    7378:	0000f21d 	.word	0x0000f21d
    737c:	2000011c 	.word	0x2000011c
    7380:	0000ed5d 	.word	0x0000ed5d
    7384:	20000120 	.word	0x20000120
    7388:	00005f5d 	.word	0x00005f5d
    738c:	20000124 	.word	0x20000124
    7390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7392:	4605      	mov	r5, r0
    7394:	4c15      	ldr	r4, [pc, #84]	; (73ec <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x88>)
    7396:	2000      	movs	r0, #0
    7398:	7028      	strb	r0, [r5, #0]
    739a:	6820      	ldr	r0, [r4, #0]
    739c:	2800      	cmp	r0, #0
    739e:	d023      	beq.n	73e8 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x84>
    73a0:	7a01      	ldrb	r1, [r0, #8]
    73a2:	2601      	movs	r6, #1
    73a4:	f88d 1000 	strb.w	r1, [sp]
    73a8:	9900      	ldr	r1, [sp, #0]
    73aa:	9100      	str	r1, [sp, #0]
    73ac:	f89d 1000 	ldrb.w	r1, [sp]
    73b0:	2908      	cmp	r1, #8
    73b2:	d107      	bne.n	73c4 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x60>
    73b4:	6840      	ldr	r0, [r0, #4]
    73b6:	8800      	ldrh	r0, [r0, #0]
    73b8:	f7fe faf4 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    73bc:	f006 fb66 	bl	da8c <sym_B62EJKCCJ4JFC5I4BFTUJG7GNOKGWQ4KKFBS6RI>
    73c0:	2800      	cmp	r0, #0
    73c2:	d011      	beq.n	73e8 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x84>
    73c4:	f3ef 8110 	mrs	r1, PRIMASK
    73c8:	6820      	ldr	r0, [r4, #0]
    73ca:	b672      	cpsid	i
    73cc:	6802      	ldr	r2, [r0, #0]
    73ce:	6022      	str	r2, [r4, #0]
    73d0:	b901      	cbnz	r1, 73d4 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x70>
    73d2:	b662      	cpsie	i
    73d4:	7a01      	ldrb	r1, [r0, #8]
    73d6:	f88d 1000 	strb.w	r1, [sp]
    73da:	9900      	ldr	r1, [sp, #0]
    73dc:	9100      	str	r1, [sp, #0]
    73de:	f89d 1000 	ldrb.w	r1, [sp]
    73e2:	2900      	cmp	r1, #0
    73e4:	d100      	bne.n	73e8 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x84>
    73e6:	702e      	strb	r6, [r5, #0]
    73e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    73ea:	0000      	.short	0x0000
    73ec:	20000114 	.word	0x20000114
    73f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    73f4:	b086      	sub	sp, #24
    73f6:	000f      	movs	r7, r1
    73f8:	4604      	mov	r4, r0
    73fa:	4691      	mov	r9, r2
    73fc:	d013      	beq.n	7426 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0xc2>
    73fe:	6878      	ldr	r0, [r7, #4]
    7400:	b188      	cbz	r0, 7426 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0xc2>
    7402:	f100 0578 	add.w	r5, r0, #120	; 0x78
    7406:	f500 7196 	add.w	r1, r0, #300	; 0x12c
    740a:	8806      	ldrh	r6, [r0, #0]
    740c:	4610      	mov	r0, r2
    740e:	f04f 0800 	mov.w	r8, #0
    7412:	2a10      	cmp	r2, #16
    7414:	d079      	beq.n	750a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1a6>
    7416:	dc09      	bgt.n	742c <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0xc8>
    7418:	f04f 0a01 	mov.w	sl, #1
    741c:	2801      	cmp	r0, #1
    741e:	d00a      	beq.n	7436 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0xd2>
    7420:	2a0b      	cmp	r2, #11
    7422:	d171      	bne.n	7508 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1a4>
    7424:	e01a      	b.n	745c <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0xf8>
    7426:	f240 2182 	movw	r1, #642	; 0x282
    742a:	e0ad      	b.n	7588 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x224>
    742c:	281a      	cmp	r0, #26
    742e:	d04d      	beq.n	74cc <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x168>
    7430:	2a1b      	cmp	r2, #27
    7432:	d169      	bne.n	7508 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1a4>
    7434:	e027      	b.n	7486 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x122>
    7436:	2d00      	cmp	r5, #0
    7438:	d00f      	beq.n	745a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0xf6>
    743a:	f884 8001 	strb.w	r8, [r4, #1]
    743e:	f884 a000 	strb.w	sl, [r4]
    7442:	f884 8004 	strb.w	r8, [r4, #4]
    7446:	f8a4 6005 	strh.w	r6, [r4, #5]
    744a:	f895 0057 	ldrb.w	r0, [r5, #87]	; 0x57
    744e:	71e0      	strb	r0, [r4, #7]
    7450:	f835 0f58 	ldrh.w	r0, [r5, #88]!
    7454:	8120      	strh	r0, [r4, #8]
    7456:	8868      	ldrh	r0, [r5, #2]
    7458:	8160      	strh	r0, [r4, #10]
    745a:	e076      	b.n	754a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1e6>
    745c:	4630      	mov	r0, r6
    745e:	f7fe fab7 	bl	59d0 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA>
    7462:	b168      	cbz	r0, 7480 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x11c>
    7464:	f884 8001 	strb.w	r8, [r4, #1]
    7468:	220d      	movs	r2, #13
    746a:	7022      	strb	r2, [r4, #0]
    746c:	80e6      	strh	r6, [r4, #6]
    746e:	4641      	mov	r1, r8
    7470:	f8a4 a008 	strh.w	sl, [r4, #8]
    7474:	f884 a004 	strb.w	sl, [r4, #4]
    7478:	460a      	mov	r2, r1
    747a:	f006 fcda 	bl	de32 <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II>
    747e:	e064      	b.n	754a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1e6>
    7480:	f44f 71ce 	mov.w	r1, #412	; 0x19c
    7484:	e080      	b.n	7588 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x224>
    7486:	f7ff fdfd 	bl	7084 <sym_N2NJCIBZFHVP7II7LSOD6U4WPOYSC3U3IRJ6NLY>
    748a:	b3e8      	cbz	r0, 7508 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1a4>
    748c:	f887 8008 	strb.w	r8, [r7, #8]
    7490:	4630      	mov	r0, r6
    7492:	f8ad 6000 	strh.w	r6, [sp]
    7496:	a902      	add	r1, sp, #8
    7498:	f007 f835 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    749c:	b110      	cbz	r0, 74a4 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x140>
    749e:	f44f 71b7 	mov.w	r1, #366	; 0x16e
    74a2:	e071      	b.n	7588 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x224>
    74a4:	9803      	ldr	r0, [sp, #12]
    74a6:	f810 1f6a 	ldrb.w	r1, [r0, #106]!
    74aa:	f88d 1002 	strb.w	r1, [sp, #2]
    74ae:	7841      	ldrb	r1, [r0, #1]
    74b0:	f88d 1003 	strb.w	r1, [sp, #3]
    74b4:	8840      	ldrh	r0, [r0, #2]
    74b6:	f8ad 0004 	strh.w	r0, [sp, #4]
    74ba:	2102      	movs	r1, #2
    74bc:	4668      	mov	r0, sp
    74be:	f009 f940 	bl	10742 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ>
    74c2:	2800      	cmp	r0, #0
    74c4:	d034      	beq.n	7530 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1cc>
    74c6:	f44f 71c2 	mov.w	r1, #388	; 0x184
    74ca:	e05d      	b.n	7588 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x224>
    74cc:	f7ff fdd0 	bl	7070 <sym_56NG23UACCBJRJHKQI4X4VNMARWQXHUE4R3NK7I>
    74d0:	b1d0      	cbz	r0, 7508 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1a4>
    74d2:	f887 8008 	strb.w	r8, [r7, #8]
    74d6:	a903      	add	r1, sp, #12
    74d8:	4630      	mov	r0, r6
    74da:	f008 ffa9 	bl	10430 <sym_4DOGMDZGTALJPSDK26RDOFYJAUF2WWYUQSK5XNA>
    74de:	b110      	cbz	r0, 74e6 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x182>
    74e0:	f240 118b 	movw	r1, #395	; 0x18b
    74e4:	e050      	b.n	7588 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x224>
    74e6:	f8ad 6000 	strh.w	r6, [sp]
    74ea:	f8bd 0012 	ldrh.w	r0, [sp, #18]
    74ee:	f8ad 0002 	strh.w	r0, [sp, #2]
    74f2:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    74f6:	f8ad 0004 	strh.w	r0, [sp, #4]
    74fa:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    74fe:	f8ad 0006 	strh.w	r0, [sp, #6]
    7502:	f8bd 0010 	ldrh.w	r0, [sp, #16]
    7506:	e001      	b.n	750c <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1a8>
    7508:	e015      	b.n	7536 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1d2>
    750a:	e009      	b.n	7520 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1bc>
    750c:	f8ad 0008 	strh.w	r0, [sp, #8]
    7510:	4668      	mov	r0, sp
    7512:	f008 ffb1 	bl	10478 <sym_M6MZU5PVUKHQMWMMC4UT23L7SRBW44JZLP26X4I>
    7516:	2800      	cmp	r0, #0
    7518:	d00a      	beq.n	7530 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1cc>
    751a:	f44f 71ca 	mov.w	r1, #404	; 0x194
    751e:	e033      	b.n	7588 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x224>
    7520:	f891 002c 	ldrb.w	r0, [r1, #44]	; 0x2c
    7524:	f000 0001 	and.w	r0, r0, #1
    7528:	f7ff fd96 	bl	7058 <sym_5INKXEHJ7NSOP6JSEWOYQNB6PUCWPUG5RVXPDVA>
    752c:	b130      	cbz	r0, 753c <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1d8>
    752e:	2000      	movs	r0, #0
    7530:	b006      	add	sp, #24
    7532:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7536:	f1b9 0f08 	cmp.w	r9, #8
    753a:	d008      	beq.n	754e <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1ea>
    753c:	4814      	ldr	r0, [pc, #80]	; (7590 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x22c>)
    753e:	6803      	ldr	r3, [r0, #0]
    7540:	b11b      	cbz	r3, 754a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1e6>
    7542:	6878      	ldr	r0, [r7, #4]
    7544:	464a      	mov	r2, r9
    7546:	4621      	mov	r1, r4
    7548:	4798      	blx	r3
    754a:	2001      	movs	r0, #1
    754c:	e7f0      	b.n	7530 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1cc>
    754e:	4630      	mov	r0, r6
    7550:	f7fe fa28 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    7554:	f006 fa9a 	bl	da8c <sym_B62EJKCCJ4JFC5I4BFTUJG7GNOKGWQ4KKFBS6RI>
    7558:	b1a0      	cbz	r0, 7584 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x220>
    755a:	4630      	mov	r0, r6
    755c:	f006 ff03 	bl	e366 <sym_REO6MG4FRJTNQQ56RDJDYGEWFEO5TFVYGRW6OLI>
    7560:	2100      	movs	r1, #0
    7562:	4630      	mov	r0, r6
    7564:	f7fe f88a 	bl	567c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY>
    7568:	2d00      	cmp	r5, #0
    756a:	d0ee      	beq.n	754a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1e6>
    756c:	f884 8001 	strb.w	r8, [r4, #1]
    7570:	210a      	movs	r1, #10
    7572:	7021      	strb	r1, [r4, #0]
    7574:	f884 8004 	strb.w	r8, [r4, #4]
    7578:	f8a4 6005 	strh.w	r6, [r4, #5]
    757c:	f895 002e 	ldrb.w	r0, [r5, #46]	; 0x2e
    7580:	71e0      	strb	r0, [r4, #7]
    7582:	e7e2      	b.n	754a <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x1e6>
    7584:	f240 21c3 	movw	r1, #707	; 0x2c3
    7588:	2010      	movs	r0, #16
    758a:	f7fd fde3 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    758e:	0000      	.short	0x0000
    7590:	20000120 	.word	0x20000120
    7594:	4904      	ldr	r1, [pc, #16]	; (75a8 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x244>)
    7596:	2000      	movs	r0, #0
    7598:	6048      	str	r0, [r1, #4]
    759a:	6088      	str	r0, [r1, #8]
    759c:	4903      	ldr	r1, [pc, #12]	; (75ac <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x248>)
    759e:	6008      	str	r0, [r1, #0]
    75a0:	6048      	str	r0, [r1, #4]
    75a2:	8108      	strh	r0, [r1, #8]
    75a4:	4770      	bx	lr
    75a6:	0000      	.short	0x0000
    75a8:	20000110 	.word	0x20000110
    75ac:	20001ae5 	.word	0x20001ae5

000075b0 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY>:
    75b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    75b2:	f06f 021f 	mvn.w	r2, #31
    75b6:	0c01      	lsrs	r1, r0, #16
    75b8:	ea02 2690 	and.w	r6, r2, r0, lsr #10
    75bc:	251f      	movs	r5, #31
    75be:	f5a1 40aa 	sub.w	r0, r1, #21760	; 0x5500
    75c2:	3854      	subs	r0, #84	; 0x54
    75c4:	d00d      	beq.n	75e2 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x32>
    75c6:	f5a1 40aa 	sub.w	r0, r1, #21760	; 0x5500
    75ca:	3855      	subs	r0, #85	; 0x55
    75cc:	d009      	beq.n	75e2 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x32>
    75ce:	f5a1 5028 	sub.w	r0, r1, #10752	; 0x2a00
    75d2:	38aa      	subs	r0, #170	; 0xaa
    75d4:	d005      	beq.n	75e2 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x32>
    75d6:	f5a1 402a 	sub.w	r0, r1, #43520	; 0xaa00
    75da:	38aa      	subs	r0, #170	; 0xaa
    75dc:	d001      	beq.n	75e2 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x32>
    75de:	2001      	movs	r0, #1
    75e0:	e000      	b.n	75e4 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x34>
    75e2:	2000      	movs	r0, #0
    75e4:	2200      	movs	r2, #0
    75e6:	4613      	mov	r3, r2
    75e8:	ea4f 0402 	mov.w	r4, r2
    75ec:	ea82 0701 	eor.w	r7, r2, r1
    75f0:	43ff      	mvns	r7, r7
    75f2:	431f      	orrs	r7, r3
    75f4:	1c7f      	adds	r7, r7, #1
    75f6:	d00f      	beq.n	7618 <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x68>
    75f8:	f006 0701 	and.w	r7, r6, #1
    75fc:	0852      	lsrs	r2, r2, #1
    75fe:	ea42 32c7 	orr.w	r2, r2, r7, lsl #15
    7602:	f005 0701 	and.w	r7, r5, #1
    7606:	085b      	lsrs	r3, r3, #1
    7608:	0876      	lsrs	r6, r6, #1
    760a:	086d      	lsrs	r5, r5, #1
    760c:	1c64      	adds	r4, r4, #1
    760e:	ea43 33c7 	orr.w	r3, r3, r7, lsl #15
    7612:	2c16      	cmp	r4, #22
    7614:	d3ea      	bcc.n	75ec <sym_HRCF6LWSDWPWEZA7S5YQFCNRDXXCJA6WGOZECRY+0x3c>
    7616:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7618:	2000      	movs	r0, #0
    761a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000761c <sym_77ICNIHY2R2L3JRP4ZLMOWZSS3UZRKJXJOBWTWI>:
    761c:	b510      	push	{r4, lr}
    761e:	4804      	ldr	r0, [pc, #16]	; (7630 <sym_77ICNIHY2R2L3JRP4ZLMOWZSS3UZRKJXJOBWTWI+0x14>)
    7620:	f007 fd66 	bl	f0f0 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xb4>
    7624:	4802      	ldr	r0, [pc, #8]	; (7630 <sym_77ICNIHY2R2L3JRP4ZLMOWZSS3UZRKJXJOBWTWI+0x14>)
    7626:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    762a:	3008      	adds	r0, #8
    762c:	f007 bd60 	b.w	f0f0 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xb4>
    7630:	20000128 	.word	0x20000128

00007634 <sym_K5GMJMBHBYPRCUIWKNEXGPSNQEZKEMBAP4JWHBQ>:
    7634:	4801      	ldr	r0, [pc, #4]	; (763c <sym_K5GMJMBHBYPRCUIWKNEXGPSNQEZKEMBAP4JWHBQ+0x8>)
    7636:	f000 b809 	b.w	764c <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY+0xc>
    763a:	0000      	.short	0x0000
    763c:	20000128 	.word	0x20000128

00007640 <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY>:
    7640:	4801      	ldr	r0, [pc, #4]	; (7648 <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY+0x8>)
    7642:	f000 b803 	b.w	764c <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY+0xc>
    7646:	0000      	.short	0x0000
    7648:	20000130 	.word	0x20000130
    764c:	b510      	push	{r4, lr}
    764e:	e9d0 2100 	ldrd	r2, r1, [r0]
    7652:	4b09      	ldr	r3, [pc, #36]	; (7678 <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY+0x38>)
    7654:	4c09      	ldr	r4, [pc, #36]	; (767c <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY+0x3c>)
    7656:	4353      	muls	r3, r2
    7658:	4354      	muls	r4, r2
    765a:	4051      	eors	r1, r2
    765c:	ea81 12b2 	eor.w	r2, r1, r2, ror #6
    7660:	ea82 2241 	eor.w	r2, r2, r1, lsl #9
    7664:	ea4f 41f1 	mov.w	r1, r1, ror #19
    7668:	e9c0 2100 	strd	r2, r1, [r0]
    766c:	ea43 63d4 	orr.w	r3, r3, r4, lsr #27
    7670:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    7674:	4618      	mov	r0, r3
    7676:	bd10      	pop	{r4, pc}
    7678:	c6ef3760 	.word	0xc6ef3760
    767c:	9e3779bb 	.word	0x9e3779bb

00007680 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ>:
    7680:	b570      	push	{r4, r5, r6, lr}
    7682:	4604      	mov	r4, r0
    7684:	7c00      	ldrb	r0, [r0, #16]
    7686:	b300      	cbz	r0, 76ca <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x4a>
    7688:	2802      	cmp	r0, #2
    768a:	d01e      	beq.n	76ca <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x4a>
    768c:	f05f 0001 	movs.w	r0, #1
    7690:	f104 0149 	add.w	r1, r4, #73	; 0x49
    7694:	f884 0048 	strb.w	r0, [r4, #72]	; 0x48
    7698:	460d      	mov	r5, r1
    769a:	b1c0      	cbz	r0, 76ce <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x4e>
    769c:	7de0      	ldrb	r0, [r4, #23]
    769e:	b1f0      	cbz	r0, 76de <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x5e>
    76a0:	f8d4 0011 	ldr.w	r0, [r4, #17]
    76a4:	f8c4 0049 	str.w	r0, [r4, #73]	; 0x49
    76a8:	f8b4 0015 	ldrh.w	r0, [r4, #21]
    76ac:	f8a4 004d 	strh.w	r0, [r4, #77]	; 0x4d
    76b0:	7c20      	ldrb	r0, [r4, #16]
    76b2:	f007 fd3e 	bl	f132 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xf6>
    76b6:	7620      	strb	r0, [r4, #24]
    76b8:	2008      	movs	r0, #8
    76ba:	7660      	strb	r0, [r4, #25]
    76bc:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
    76c0:	4629      	mov	r1, r5
    76c2:	f007 fd22 	bl	f10a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xce>
    76c6:	b9a8      	cbnz	r0, 76f4 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x74>
    76c8:	e00e      	b.n	76e8 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x68>
    76ca:	2000      	movs	r0, #0
    76cc:	e7e0      	b.n	7690 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x10>
    76ce:	2000      	movs	r0, #0
    76d0:	f7fe fbf6 	bl	5ec0 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI>
    76d4:	2800      	cmp	r0, #0
    76d6:	d1eb      	bne.n	76b0 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x30>
    76d8:	f240 418a 	movw	r1, #1162	; 0x48a
    76dc:	e001      	b.n	76e2 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x62>
    76de:	f240 418e 	movw	r1, #1166	; 0x48e
    76e2:	202d      	movs	r0, #45	; 0x2d
    76e4:	f7fd fd36 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    76e8:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
    76ec:	4629      	mov	r1, r5
    76ee:	f007 fd15 	bl	f11c <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xe0>
    76f2:	b100      	cbz	r0, 76f6 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x76>
    76f4:	2001      	movs	r0, #1
    76f6:	76a0      	strb	r0, [r4, #26]
    76f8:	7e20      	ldrb	r0, [r4, #24]
    76fa:	b130      	cbz	r0, 770a <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0x8a>
    76fc:	f894 004f 	ldrb.w	r0, [r4, #79]	; 0x4f
    7700:	f104 0150 	add.w	r1, r4, #80	; 0x50
    7704:	f006 fecb 	bl	e49e <sym_QW6JOH7RCJIC2YFNJEURX5QNB5EIQT646EHIWEA>
    7708:	7660      	strb	r0, [r4, #25]
    770a:	f7ff fa0f 	bl	6b2c <sym_RHRHCWPUPZHCOID576WBS7QZ2KAUT2GASS2T3QY>
    770e:	490c      	ldr	r1, [pc, #48]	; (7740 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0xc0>)
    7710:	fba0 2301 	umull	r2, r3, r0, r1
    7714:	f104 0040 	add.w	r0, r4, #64	; 0x40
    7718:	f007 fea4 	bl	f464 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xe0>
    771c:	2100      	movs	r1, #0
    771e:	4620      	mov	r0, r4
    7720:	f007 fe4e 	bl	f3c0 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x3c>
    7724:	2000      	movs	r0, #0
    7726:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    772a:	78a0      	ldrb	r0, [r4, #2]
    772c:	0740      	lsls	r0, r0, #29
    772e:	d505      	bpl.n	773c <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ+0xbc>
    7730:	4620      	mov	r0, r4
    7732:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    7736:	2100      	movs	r1, #0
    7738:	f000 bdac 	b.w	8294 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x294>
    773c:	bd70      	pop	{r4, r5, r6, pc}
    773e:	0000      	.short	0x0000
    7740:	000f4240 	.word	0x000f4240

00007744 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA>:
    7744:	b530      	push	{r4, r5, lr}
    7746:	460c      	mov	r4, r1
    7748:	b08d      	sub	sp, #52	; 0x34
    774a:	4605      	mov	r5, r0
    774c:	4601      	mov	r1, r0
    774e:	2220      	movs	r2, #32
    7750:	a802      	add	r0, sp, #8
    7752:	f005 fc43 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    7756:	a80a      	add	r0, sp, #40	; 0x28
    7758:	f007 feea 	bl	f530 <sym_32MURW7CSXICOYPMCVOPRARLMRLK4UASNCF4JWQ>
    775c:	7aa0      	ldrb	r0, [r4, #10]
    775e:	f88d 0018 	strb.w	r0, [sp, #24]
    7762:	7820      	ldrb	r0, [r4, #0]
    7764:	f88d 0008 	strb.w	r0, [sp, #8]
    7768:	f8b4 0001 	ldrh.w	r0, [r4, #1]
    776c:	f8ad 0000 	strh.w	r0, [sp]
    7770:	f89d 0000 	ldrb.w	r0, [sp]
    7774:	f000 0101 	and.w	r1, r0, #1
    7778:	f3c0 0240 	ubfx	r2, r0, #1, #1
    777c:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
    7780:	f3c0 0280 	ubfx	r2, r0, #2, #1
    7784:	ea41 0182 	orr.w	r1, r1, r2, lsl #2
    7788:	f3c0 02c0 	ubfx	r2, r0, #3, #1
    778c:	ea41 01c2 	orr.w	r1, r1, r2, lsl #3
    7790:	f3c0 1200 	ubfx	r2, r0, #4, #1
    7794:	ea41 1102 	orr.w	r1, r1, r2, lsl #4
    7798:	f3c0 1240 	ubfx	r2, r0, #5, #1
    779c:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
    77a0:	f3c0 1080 	ubfx	r0, r0, #6, #1
    77a4:	ea41 1080 	orr.w	r0, r1, r0, lsl #6
    77a8:	f8ad 000a 	strh.w	r0, [sp, #10]
    77ac:	7d20      	ldrb	r0, [r4, #20]
    77ae:	2801      	cmp	r0, #1
    77b0:	d006      	beq.n	77c0 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x7c>
    77b2:	2802      	cmp	r0, #2
    77b4:	d004      	beq.n	77c0 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x7c>
    77b6:	f240 21bb 	movw	r1, #699	; 0x2bb
    77ba:	2006      	movs	r0, #6
    77bc:	f7fd fcca 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    77c0:	f88d 000c 	strb.w	r0, [sp, #12]
    77c4:	7a61      	ldrb	r1, [r4, #9]
    77c6:	a80a      	add	r0, sp, #40	; 0x28
    77c8:	f007 fe99 	bl	f4fe <sym_YZ554N3225FHWC7CK3UNRUMI3O4SGFLKXVRCFXA>
    77cc:	7d20      	ldrb	r0, [r4, #20]
    77ce:	2101      	movs	r1, #1
    77d0:	2802      	cmp	r0, #2
    77d2:	d102      	bne.n	77da <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x96>
    77d4:	7d60      	ldrb	r0, [r4, #21]
    77d6:	1c40      	adds	r0, r0, #1
    77d8:	b2c1      	uxtb	r1, r0
    77da:	7ea0      	ldrb	r0, [r4, #26]
    77dc:	1c40      	adds	r0, r0, #1
    77de:	b2c2      	uxtb	r2, r0
    77e0:	a80a      	add	r0, sp, #40	; 0x28
    77e2:	f007 fe53 	bl	f48c <sym_XD3FX5TVO57NBJG4QV33FUOBCL7SNGB4OOT7C3Y>
    77e6:	f8bd 000a 	ldrh.w	r0, [sp, #10]
    77ea:	0700      	lsls	r0, r0, #28
    77ec:	d501      	bpl.n	77f2 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0xae>
    77ee:	2000      	movs	r0, #0
    77f0:	e020      	b.n	7834 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0xf0>
    77f2:	a80a      	add	r0, sp, #40	; 0x28
    77f4:	f007 fe5c 	bl	f4b0 <sym_STP6UONGXHZIIGYZLLHSWZFO5DU7227CCUKBTDQ>
    77f8:	f8bd 100a 	ldrh.w	r1, [sp, #10]
    77fc:	2228      	movs	r2, #40	; 0x28
    77fe:	f000 fdef 	bl	83e0 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY>
    7802:	f240 2171 	movw	r1, #625	; 0x271
    7806:	f200 20d9 	addw	r0, r0, #729	; 0x2d9
    780a:	fbb0 f0f1 	udiv	r0, r0, r1
    780e:	4348      	muls	r0, r1
    7810:	f8d4 1002 	ldr.w	r1, [r4, #2]
    7814:	f240 2371 	movw	r3, #625	; 0x271
    7818:	0a0a      	lsrs	r2, r1, #8
    781a:	f240 2171 	movw	r1, #625	; 0x271
    781e:	434a      	muls	r2, r1
    7820:	f8d4 1005 	ldr.w	r1, [r4, #5]
    7824:	0a09      	lsrs	r1, r1, #8
    7826:	4359      	muls	r1, r3
    7828:	4290      	cmp	r0, r2
    782a:	d801      	bhi.n	7830 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0xec>
    782c:	9204      	str	r2, [sp, #16]
    782e:	e004      	b.n	783a <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0xf6>
    7830:	4288      	cmp	r0, r1
    7832:	d801      	bhi.n	7838 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0xf4>
    7834:	9004      	str	r0, [sp, #16]
    7836:	e000      	b.n	783a <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0xf6>
    7838:	9104      	str	r1, [sp, #16]
    783a:	7ca0      	ldrb	r0, [r4, #18]
    783c:	f88d 0017 	strb.w	r0, [sp, #23]
    7840:	7e20      	ldrb	r0, [r4, #24]
    7842:	2801      	cmp	r0, #1
    7844:	d000      	beq.n	7848 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x104>
    7846:	2000      	movs	r0, #0
    7848:	f88d 0014 	strb.w	r0, [sp, #20]
    784c:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    784e:	f006 fc8d 	bl	e16c <sym_RIJIFYF46ZRKFDPA3GKV7WCH2VGEUEP6MVN4JFI>
    7852:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    7854:	f006 fd2e 	bl	e2b4 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ>
    7858:	2220      	movs	r2, #32
    785a:	a902      	add	r1, sp, #8
    785c:	4628      	mov	r0, r5
    785e:	f005 fbbd 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    7862:	980a      	ldr	r0, [sp, #40]	; 0x28
    7864:	6228      	str	r0, [r5, #32]
    7866:	f8bd 002c 	ldrh.w	r0, [sp, #44]	; 0x2c
    786a:	84a8      	strh	r0, [r5, #36]	; 0x24
    786c:	7ae0      	ldrb	r0, [r4, #11]
    786e:	b168      	cbz	r0, 788c <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x148>
    7870:	2802      	cmp	r0, #2
    7872:	d00b      	beq.n	788c <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x148>
    7874:	f05f 0001 	movs.w	r0, #1
    7878:	f885 004f 	strb.w	r0, [r5, #79]	; 0x4f
    787c:	68e0      	ldr	r0, [r4, #12]
    787e:	6528      	str	r0, [r5, #80]	; 0x50
    7880:	8a20      	ldrh	r0, [r4, #16]
    7882:	f8a5 0054 	strh.w	r0, [r5, #84]	; 0x54
    7886:	b00d      	add	sp, #52	; 0x34
    7888:	2000      	movs	r0, #0
    788a:	bd30      	pop	{r4, r5, pc}
    788c:	2000      	movs	r0, #0
    788e:	e7f3      	b.n	7878 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA+0x134>

00007890 <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY>:
    7890:	4a0a      	ldr	r2, [pc, #40]	; (78bc <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY+0x2c>)
    7892:	b510      	push	{r4, lr}
    7894:	2100      	movs	r1, #0
    7896:	7011      	strb	r1, [r2, #0]
    7898:	4c09      	ldr	r4, [pc, #36]	; (78c0 <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY+0x30>)
    789a:	6060      	str	r0, [r4, #4]
    789c:	f000 f822 	bl	78e4 <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ>
    78a0:	b110      	cbz	r0, 78a8 <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY+0x18>
    78a2:	f240 310a 	movw	r1, #778	; 0x30a
    78a6:	e004      	b.n	78b2 <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY+0x22>
    78a8:	68a0      	ldr	r0, [r4, #8]
    78aa:	2800      	cmp	r0, #0
    78ac:	d104      	bne.n	78b8 <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY+0x28>
    78ae:	f240 310d 	movw	r1, #781	; 0x30d
    78b2:	202d      	movs	r0, #45	; 0x2d
    78b4:	f7fd fc4e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    78b8:	bd10      	pop	{r4, pc}
    78ba:	0000      	.short	0x0000
    78bc:	20001678 	.word	0x20001678
    78c0:	20000138 	.word	0x20000138

000078c4 <sym_BPVIPCP3IMFHHNRASYWRUQPTOXIXQGWP3DTKXWI>:
    78c4:	4902      	ldr	r1, [pc, #8]	; (78d0 <sym_BPVIPCP3IMFHHNRASYWRUQPTOXIXQGWP3DTKXWI+0xc>)
    78c6:	4801      	ldr	r0, [pc, #4]	; (78cc <sym_BPVIPCP3IMFHHNRASYWRUQPTOXIXQGWP3DTKXWI+0x8>)
    78c8:	6088      	str	r0, [r1, #8]
    78ca:	4770      	bx	lr
    78cc:	000083c8 	.word	0x000083c8
    78d0:	20000138 	.word	0x20000138

000078d4 <sym_PY5KUATPBYOYJBMP6H7AVRPSEO7BZX2JK524O6A>:
    78d4:	4902      	ldr	r1, [pc, #8]	; (78e0 <sym_PY5KUATPBYOYJBMP6H7AVRPSEO7BZX2JK524O6A+0xc>)
    78d6:	6008      	str	r0, [r1, #0]
    78d8:	6889      	ldr	r1, [r1, #8]
    78da:	6809      	ldr	r1, [r1, #0]
    78dc:	4708      	bx	r1
    78de:	0000      	.short	0x0000
    78e0:	20000138 	.word	0x20000138

000078e4 <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ>:
    78e4:	4808      	ldr	r0, [pc, #32]	; (7908 <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ+0x24>)
    78e6:	b510      	push	{r4, lr}
    78e8:	7800      	ldrb	r0, [r0, #0]
    78ea:	b110      	cbz	r0, 78f2 <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ+0xe>
    78ec:	240c      	movs	r4, #12
    78ee:	4620      	mov	r0, r4
    78f0:	bd10      	pop	{r4, pc}
    78f2:	2400      	movs	r4, #0
    78f4:	2218      	movs	r2, #24
    78f6:	4621      	mov	r1, r4
    78f8:	4803      	ldr	r0, [pc, #12]	; (7908 <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ+0x24>)
    78fa:	f005 fbe9 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    78fe:	f004 f8bd 	bl	ba7c <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y>
    7902:	f003 fee1 	bl	b6c8 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI>
    7906:	e7f2      	b.n	78ee <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ+0xa>
    7908:	20001678 	.word	0x20001678

0000790c <sym_ID5SI2L6AD3KMSDR72YSJZGVIA6DEYQZU7WJI3I>:
    790c:	4904      	ldr	r1, [pc, #16]	; (7920 <sym_ID5SI2L6AD3KMSDR72YSJZGVIA6DEYQZU7WJI3I+0x14>)
    790e:	b510      	push	{r4, lr}
    7910:	7809      	ldrb	r1, [r1, #0]
    7912:	2901      	cmp	r1, #1
    7914:	d101      	bne.n	791a <sym_ID5SI2L6AD3KMSDR72YSJZGVIA6DEYQZU7WJI3I+0xe>
    7916:	f000 fb7b 	bl	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
    791a:	2000      	movs	r0, #0
    791c:	bd10      	pop	{r4, pc}
    791e:	0000      	.short	0x0000
    7920:	20001678 	.word	0x20001678

00007924 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY>:
    7924:	4902      	ldr	r1, [pc, #8]	; (7930 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xc>)
    7926:	4801      	ldr	r0, [pc, #4]	; (792c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x8>)
    7928:	6008      	str	r0, [r1, #0]
    792a:	4770      	bx	lr
    792c:	0000814d 	.word	0x0000814d
    7930:	20000144 	.word	0x20000144
    7934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7938:	000f      	movs	r7, r1
    793a:	4604      	mov	r4, r0
    793c:	d023      	beq.n	7986 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x62>
    793e:	f104 0020 	add.w	r0, r4, #32
    7942:	4605      	mov	r5, r0
    7944:	f007 fddd 	bl	f502 <sym_4U2RA2RXIRU5BEMWZTHT3PETZK6K62P2SAJVWHA>
    7948:	b9b0      	cbnz	r0, 7978 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x54>
    794a:	78a0      	ldrb	r0, [r4, #2]
    794c:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    7950:	b350      	cbz	r0, 79a8 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x84>
    7952:	4628      	mov	r0, r5
    7954:	f007 fdac 	bl	f4b0 <sym_STP6UONGXHZIIGYZLLHSWZFO5DU7227CCUKBTDQ>
    7958:	4606      	mov	r6, r0
    795a:	4628      	mov	r0, r5
    795c:	f007 fdd1 	bl	f502 <sym_4U2RA2RXIRU5BEMWZTHT3PETZK6K62P2SAJVWHA>
    7960:	1a30      	subs	r0, r6, r0
    7962:	b2c0      	uxtb	r0, r0
    7964:	f007 fe22 	bl	f5ac <sym_FHGEXLJ7V34P3MECCDTYSDEZTZHFJ2TXYSFZQHQ>
    7968:	4601      	mov	r1, r0
    796a:	4835      	ldr	r0, [pc, #212]	; (7a40 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x11c>)
    796c:	6842      	ldr	r2, [r0, #4]
    796e:	4411      	add	r1, r2
    7970:	6041      	str	r1, [r0, #4]
    7972:	4628      	mov	r0, r5
    7974:	f007 fde3 	bl	f53e <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ>
    7978:	4628      	mov	r0, r5
    797a:	f007 fda5 	bl	f4c8 <sym_GDGGQ5EKEJNZBTEWASFQ2LUSL4TZGNXHPD7BDQA>
    797e:	4601      	mov	r1, r0
    7980:	4620      	mov	r0, r4
    7982:	f007 fd59 	bl	f438 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xb4>
    7986:	4d2f      	ldr	r5, [pc, #188]	; (7a44 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x120>)
    7988:	f894 6056 	ldrb.w	r6, [r4, #86]	; 0x56
    798c:	2100      	movs	r1, #0
    798e:	6868      	ldr	r0, [r5, #4]
    7990:	8001      	strh	r1, [r0, #0]
    7992:	f007 fd72 	bl	f47a <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xf6>
    7996:	8860      	ldrh	r0, [r4, #2]
    7998:	2813      	cmp	r0, #19
    799a:	d013      	beq.n	79c4 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xa0>
    799c:	dc09      	bgt.n	79b2 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x8e>
    799e:	2810      	cmp	r0, #16
    79a0:	d036      	beq.n	7a10 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xec>
    79a2:	2812      	cmp	r0, #18
    79a4:	d109      	bne.n	79ba <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x96>
    79a6:	e031      	b.n	7a0c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xe8>
    79a8:	4620      	mov	r0, r4
    79aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    79ae:	f000 bb2f 	b.w	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
    79b2:	2815      	cmp	r0, #21
    79b4:	d00f      	beq.n	79d6 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xb2>
    79b6:	281d      	cmp	r0, #29
    79b8:	d00d      	beq.n	79d6 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xb2>
    79ba:	f240 614a 	movw	r1, #1610	; 0x64a
    79be:	202d      	movs	r0, #45	; 0x2d
    79c0:	f7fd fbc8 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    79c4:	2100      	movs	r1, #0
    79c6:	6868      	ldr	r0, [r5, #4]
    79c8:	f007 f8f4 	bl	ebb4 <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY>
    79cc:	2101      	movs	r1, #1
    79ce:	6868      	ldr	r0, [r5, #4]
    79d0:	f007 fd53 	bl	f47a <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xf6>
    79d4:	e020      	b.n	7a18 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xf4>
    79d6:	2101      	movs	r1, #1
    79d8:	6868      	ldr	r0, [r5, #4]
    79da:	f007 f8eb 	bl	ebb4 <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY>
    79de:	2101      	movs	r1, #1
    79e0:	6868      	ldr	r0, [r5, #4]
    79e2:	f007 fd4a 	bl	f47a <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xf6>
    79e6:	b136      	cbz	r6, 79f6 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xd2>
    79e8:	f104 0157 	add.w	r1, r4, #87	; 0x57
    79ec:	6868      	ldr	r0, [r5, #4]
    79ee:	f007 f8fc 	bl	ebea <sym_6GC7CC2BUFLCMQVOZDACHKZEET4WUCXSLEMHSCY>
    79f2:	2101      	movs	r1, #1
    79f4:	e006      	b.n	7a04 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xe0>
    79f6:	f104 0150 	add.w	r1, r4, #80	; 0x50
    79fa:	6868      	ldr	r0, [r5, #4]
    79fc:	f007 f8f5 	bl	ebea <sym_6GC7CC2BUFLCMQVOZDACHKZEET4WUCXSLEMHSCY>
    7a00:	f894 104f 	ldrb.w	r1, [r4, #79]	; 0x4f
    7a04:	6868      	ldr	r0, [r5, #4]
    7a06:	f007 f8f6 	bl	ebf6 <sym_6FJEZEEBKMCAKI6FMPGNQ7TUXYDPYPEPSNJFOMQ>
    7a0a:	e005      	b.n	7a18 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xf4>
    7a0c:	2106      	movs	r1, #6
    7a0e:	e000      	b.n	7a12 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0xee>
    7a10:	2102      	movs	r1, #2
    7a12:	6868      	ldr	r0, [r5, #4]
    7a14:	f007 f8ce 	bl	ebb4 <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY>
    7a18:	4620      	mov	r0, r4
    7a1a:	f000 fcb1 	bl	8380 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x380>
    7a1e:	8860      	ldrh	r0, [r4, #2]
    7a20:	281d      	cmp	r0, #29
    7a22:	d007      	beq.n	7a34 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x110>
    7a24:	2815      	cmp	r0, #21
    7a26:	d005      	beq.n	7a34 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x110>
    7a28:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    7a2c:	6b21      	ldr	r1, [r4, #48]	; 0x30
    7a2e:	6868      	ldr	r0, [r5, #4]
    7a30:	f007 f8b0 	bl	eb94 <sym_AIYUY22PH5CFYGFYYYX5TRDP6GAU3UXOBISKF2I>
    7a34:	4639      	mov	r1, r7
    7a36:	4620      	mov	r0, r4
    7a38:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7a3c:	f000 b9e4 	b.w	7e08 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x1d4>
    7a40:	20001678 	.word	0x20001678
    7a44:	20000138 	.word	0x20000138
    7a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7a4c:	4d2e      	ldr	r5, [pc, #184]	; (7b08 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1e4>)
    7a4e:	4607      	mov	r7, r0
    7a50:	7828      	ldrb	r0, [r5, #0]
    7a52:	2802      	cmp	r0, #2
    7a54:	d005      	beq.n	7a62 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x13e>
    7a56:	7828      	ldrb	r0, [r5, #0]
    7a58:	2803      	cmp	r0, #3
    7a5a:	d002      	beq.n	7a62 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x13e>
    7a5c:	f640 41b9 	movw	r1, #3257	; 0xcb9
    7a60:	e028      	b.n	7ab4 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x190>
    7a62:	4c2a      	ldr	r4, [pc, #168]	; (7b0c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1e8>)
    7a64:	6820      	ldr	r0, [r4, #0]
    7a66:	7b01      	ldrb	r1, [r0, #12]
    7a68:	b109      	cbz	r1, 7a6e <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x14a>
    7a6a:	f007 fcf0 	bl	f44e <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xca>
    7a6e:	f8d4 c004 	ldr.w	ip, [r4, #4]
    7a72:	f04f 0800 	mov.w	r8, #0
    7a76:	f89c 0000 	ldrb.w	r0, [ip]
    7a7a:	f000 060f 	and.w	r6, r0, #15
    7a7e:	b33f      	cbz	r7, 7ad0 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1ac>
    7a80:	6821      	ldr	r1, [r4, #0]
    7a82:	09c0      	lsrs	r0, r0, #7
    7a84:	f101 0349 	add.w	r3, r1, #73	; 0x49
    7a88:	f891 2048 	ldrb.w	r2, [r1, #72]	; 0x48
    7a8c:	f10c 0109 	add.w	r1, ip, #9
    7a90:	f006 fc6d 	bl	e36e <sym_4ZZLWI6QQY4KJYYVP4RVDTJJJ6MW72AL2TJDVOI>
    7a94:	b1e0      	cbz	r0, 7ad0 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1ac>
    7a96:	4641      	mov	r1, r8
    7a98:	6860      	ldr	r0, [r4, #4]
    7a9a:	f007 f86b 	bl	eb74 <sym_7FFMBSDVRVZYH5XO7CHX33376QMIMFS3BQD5N7I>
    7a9e:	b1b8      	cbz	r0, 7ad0 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1ac>
    7aa0:	782a      	ldrb	r2, [r5, #0]
    7aa2:	6820      	ldr	r0, [r4, #0]
    7aa4:	4631      	mov	r1, r6
    7aa6:	2a02      	cmp	r2, #2
    7aa8:	d007      	beq.n	7aba <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x196>
    7aaa:	782a      	ldrb	r2, [r5, #0]
    7aac:	2a03      	cmp	r2, #3
    7aae:	d004      	beq.n	7aba <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x196>
    7ab0:	f640 4192 	movw	r1, #3218	; 0xc92
    7ab4:	202d      	movs	r0, #45	; 0x2d
    7ab6:	f7fd fb4d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    7aba:	68a2      	ldr	r2, [r4, #8]
    7abc:	782b      	ldrb	r3, [r5, #0]
    7abe:	6952      	ldr	r2, [r2, #20]
    7ac0:	f06f 0607 	mvn.w	r6, #7
    7ac4:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    7ac8:	58d2      	ldr	r2, [r2, r3]
    7aca:	4790      	blx	r2
    7acc:	4606      	mov	r6, r0
    7ace:	e000      	b.n	7ad2 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1ae>
    7ad0:	2601      	movs	r6, #1
    7ad2:	7ba8      	ldrb	r0, [r5, #14]
    7ad4:	b118      	cbz	r0, 7ade <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1ba>
    7ad6:	f003 ffd1 	bl	ba7c <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y>
    7ada:	f003 fdf5 	bl	b6c8 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI>
    7ade:	2e00      	cmp	r6, #0
    7ae0:	d00f      	beq.n	7b02 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1de>
    7ae2:	6820      	ldr	r0, [r4, #0]
    7ae4:	f007 fd78 	bl	f5d8 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ>
    7ae8:	b130      	cbz	r0, 7af8 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1d4>
    7aea:	f003 ffef 	bl	bacc <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y>
    7aee:	68a0      	ldr	r0, [r4, #8]
    7af0:	6880      	ldr	r0, [r0, #8]
    7af2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7af6:	4700      	bx	r0
    7af8:	6820      	ldr	r0, [r4, #0]
    7afa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7afe:	f000 ba87 	b.w	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
    7b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7b06:	0000      	.short	0x0000
    7b08:	20001678 	.word	0x20001678
    7b0c:	20000138 	.word	0x20000138
    7b10:	b510      	push	{r4, lr}
    7b12:	2903      	cmp	r1, #3
    7b14:	d002      	beq.n	7b1c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1f8>
    7b16:	2905      	cmp	r1, #5
    7b18:	d10a      	bne.n	7b30 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x20c>
    7b1a:	e002      	b.n	7b22 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x1fe>
    7b1c:	f000 fb7e 	bl	821c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x21c>
    7b20:	e003      	b.n	7b2a <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x206>
    7b22:	4904      	ldr	r1, [pc, #16]	; (7b34 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x210>)
    7b24:	6809      	ldr	r1, [r1, #0]
    7b26:	b109      	cbz	r1, 7b2c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x208>
    7b28:	4788      	blx	r1
    7b2a:	b108      	cbz	r0, 7b30 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x20c>
    7b2c:	2000      	movs	r0, #0
    7b2e:	bd10      	pop	{r4, pc}
    7b30:	2001      	movs	r0, #1
    7b32:	bd10      	pop	{r4, pc}
    7b34:	20000144 	.word	0x20000144
    7b38:	4a09      	ldr	r2, [pc, #36]	; (7b60 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x23c>)
    7b3a:	0003      	movs	r3, r0
    7b3c:	6810      	ldr	r0, [r2, #0]
    7b3e:	d001      	beq.n	7b44 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x220>
    7b40:	f000 ba66 	b.w	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
    7b44:	2900      	cmp	r1, #0
    7b46:	d009      	beq.n	7b5c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x238>
    7b48:	6891      	ldr	r1, [r2, #8]
    7b4a:	4a06      	ldr	r2, [pc, #24]	; (7b64 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x240>)
    7b4c:	6909      	ldr	r1, [r1, #16]
    7b4e:	7812      	ldrb	r2, [r2, #0]
    7b50:	f06f 030f 	mvn.w	r3, #15
    7b54:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    7b58:	5889      	ldr	r1, [r1, r2]
    7b5a:	4708      	bx	r1
    7b5c:	4770      	bx	lr
    7b5e:	0000      	.short	0x0000
    7b60:	20000138 	.word	0x20000138
    7b64:	20001678 	.word	0x20001678
    7b68:	b570      	push	{r4, r5, r6, lr}
    7b6a:	4604      	mov	r4, r0
    7b6c:	8840      	ldrh	r0, [r0, #2]
    7b6e:	2810      	cmp	r0, #16
    7b70:	d019      	beq.n	7ba6 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x282>
    7b72:	4d10      	ldr	r5, [pc, #64]	; (7bb4 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x290>)
    7b74:	7ba8      	ldrb	r0, [r5, #14]
    7b76:	b120      	cbz	r0, 7b82 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x25e>
    7b78:	f003 fdc6 	bl	b708 <sym_XCEN5K7VEI2CAO42XW7S3FKM3HKMOCDCUFDX25Y>
    7b7c:	2040      	movs	r0, #64	; 0x40
    7b7e:	f003 ff8b 	bl	ba98 <sym_RXYEX777ZXB2E2DXJWDBCV7AAHWTCHNTLOSENBY>
    7b82:	480d      	ldr	r0, [pc, #52]	; (7bb8 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x294>)
    7b84:	6840      	ldr	r0, [r0, #4]
    7b86:	f004 fa0d 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    7b8a:	78a0      	ldrb	r0, [r4, #2]
    7b8c:	0740      	lsls	r0, r0, #29
    7b8e:	d404      	bmi.n	7b9a <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x276>
    7b90:	2100      	movs	r1, #0
    7b92:	7922      	ldrb	r2, [r4, #4]
    7b94:	4608      	mov	r0, r1
    7b96:	f004 fa7d 	bl	c094 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q>
    7b9a:	2000      	movs	r0, #0
    7b9c:	f004 f8b8 	bl	bd10 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY>
    7ba0:	2002      	movs	r0, #2
    7ba2:	7028      	strb	r0, [r5, #0]
    7ba4:	bd70      	pop	{r4, r5, r6, pc}
    7ba6:	4620      	mov	r0, r4
    7ba8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    7bac:	2101      	movs	r1, #1
    7bae:	f7ff bec1 	b.w	7934 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x10>
    7bb2:	0000      	.short	0x0000
    7bb4:	20001678 	.word	0x20001678
    7bb8:	20000138 	.word	0x20000138
    7bbc:	b510      	push	{r4, lr}
    7bbe:	4c12      	ldr	r4, [pc, #72]	; (7c08 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2e4>)
    7bc0:	6820      	ldr	r0, [r4, #0]
    7bc2:	f000 f825 	bl	7c10 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2ec>
    7bc6:	6820      	ldr	r0, [r4, #0]
    7bc8:	f007 fd06 	bl	f5d8 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ>
    7bcc:	2800      	cmp	r0, #0
    7bce:	6820      	ldr	r0, [r4, #0]
    7bd0:	d00b      	beq.n	7bea <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2c6>
    7bd2:	490e      	ldr	r1, [pc, #56]	; (7c0c <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2e8>)
    7bd4:	780a      	ldrb	r2, [r1, #0]
    7bd6:	2a02      	cmp	r2, #2
    7bd8:	d00b      	beq.n	7bf2 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2ce>
    7bda:	780a      	ldrb	r2, [r1, #0]
    7bdc:	2a03      	cmp	r2, #3
    7bde:	d008      	beq.n	7bf2 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2ce>
    7be0:	f640 31c6 	movw	r1, #3014	; 0xbc6
    7be4:	202d      	movs	r0, #45	; 0x2d
    7be6:	f7fd fab5 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    7bea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    7bee:	f000 ba0f 	b.w	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
    7bf2:	68a2      	ldr	r2, [r4, #8]
    7bf4:	7809      	ldrb	r1, [r1, #0]
    7bf6:	68d2      	ldr	r2, [r2, #12]
    7bf8:	f06f 0307 	mvn.w	r3, #7
    7bfc:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    7c00:	5851      	ldr	r1, [r2, r1]
    7c02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    7c06:	4708      	bx	r1
    7c08:	20000138 	.word	0x20000138
    7c0c:	20001678 	.word	0x20001678
    7c10:	b510      	push	{r4, lr}
    7c12:	7b01      	ldrb	r1, [r0, #12]
    7c14:	b109      	cbz	r1, 7c1a <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2f6>
    7c16:	f007 fc1a 	bl	f44e <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xca>
    7c1a:	4805      	ldr	r0, [pc, #20]	; (7c30 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x30c>)
    7c1c:	7b80      	ldrb	r0, [r0, #14]
    7c1e:	2800      	cmp	r0, #0
    7c20:	d005      	beq.n	7c2e <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x30a>
    7c22:	f003 ff2b 	bl	ba7c <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y>
    7c26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    7c2a:	f003 bd4d 	b.w	b6c8 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI>
    7c2e:	bd10      	pop	{r4, pc}
    7c30:	20001678 	.word	0x20001678

00007c34 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ>:
    7c34:	b5f0      	push	{r4, r5, r6, r7, lr}
    7c36:	4d59      	ldr	r5, [pc, #356]	; (7d9c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x168>)
    7c38:	4604      	mov	r4, r0
    7c3a:	b08b      	sub	sp, #44	; 0x2c
    7c3c:	7828      	ldrb	r0, [r5, #0]
    7c3e:	bbe8      	cbnz	r0, 7cbc <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x88>
    7c40:	7820      	ldrb	r0, [r4, #0]
    7c42:	28ff      	cmp	r0, #255	; 0xff
    7c44:	d03d      	beq.n	7cc2 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x8e>
    7c46:	2000      	movs	r0, #0
    7c48:	81a8      	strh	r0, [r5, #12]
    7c4a:	6068      	str	r0, [r5, #4]
    7c4c:	7068      	strb	r0, [r5, #1]
    7c4e:	70a8      	strb	r0, [r5, #2]
    7c50:	f884 0061 	strb.w	r0, [r4, #97]	; 0x61
    7c54:	4b52      	ldr	r3, [pc, #328]	; (7da0 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x16c>)
    7c56:	af06      	add	r7, sp, #24
    7c58:	4e52      	ldr	r6, [pc, #328]	; (7da4 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x170>)
    7c5a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    7c5c:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    7c60:	68b0      	ldr	r0, [r6, #8]
    7c62:	6840      	ldr	r0, [r0, #4]
    7c64:	9009      	str	r0, [sp, #36]	; 0x24
    7c66:	a806      	add	r0, sp, #24
    7c68:	f004 f826 	bl	bcb8 <sym_YG4UROEKVB7ZBE5TWHLNJHYKSFBTXGBYAX3RXRI>
    7c6c:	f004 f8f4 	bl	be58 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI>
    7c70:	f004 fb68 	bl	c344 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY>
    7c74:	f003 ff02 	bl	ba7c <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y>
    7c78:	f003 fd26 	bl	b6c8 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI>
    7c7c:	484a      	ldr	r0, [pc, #296]	; (7da8 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x174>)
    7c7e:	f004 fa3b 	bl	c0f8 <sym_YLRTPBVG5ROXKOW4KXUYITRUY3FD2MVZW5LF7ZA>
    7c82:	4847      	ldr	r0, [pc, #284]	; (7da0 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x16c>)
    7c84:	1f00      	subs	r0, r0, #4
    7c86:	f004 fa41 	bl	c10c <sym_XD56LJG2JTRU4Q2V7WCY72EI3VTZICA3O4ERV2A>
    7c8a:	f104 0020 	add.w	r0, r4, #32
    7c8e:	4607      	mov	r7, r0
    7c90:	f007 fc55 	bl	f53e <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ>
    7c94:	4638      	mov	r0, r7
    7c96:	f007 fc17 	bl	f4c8 <sym_GDGGQ5EKEJNZBTEWASFQ2LUSL4TZGNXHPD7BDQA>
    7c9a:	4601      	mov	r1, r0
    7c9c:	4620      	mov	r0, r4
    7c9e:	f007 fbcb 	bl	f438 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xb4>
    7ca2:	f994 000e 	ldrsb.w	r0, [r4, #14]
    7ca6:	f004 f95b 	bl	bf60 <sym_HE5JGYEZFIITGQL7PMATDHSORSCK7HJIY5UXOZA>
    7caa:	7921      	ldrb	r1, [r4, #4]
    7cac:	2000      	movs	r0, #0
    7cae:	f003 ff97 	bl	bbe0 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I>
    7cb2:	2101      	movs	r1, #1
    7cb4:	60a8      	str	r0, [r5, #8]
    7cb6:	b138      	cbz	r0, 7cc8 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x94>
    7cb8:	7ea0      	ldrb	r0, [r4, #26]
    7cba:	e000      	b.n	7cbe <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x8a>
    7cbc:	e001      	b.n	7cc2 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x8e>
    7cbe:	b950      	cbnz	r0, 7cd6 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0xa2>
    7cc0:	e004      	b.n	7ccc <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x98>
    7cc2:	200c      	movs	r0, #12
    7cc4:	b00b      	add	sp, #44	; 0x2c
    7cc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7cc8:	7029      	strb	r1, [r5, #0]
    7cca:	e064      	b.n	7d96 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x162>
    7ccc:	7e20      	ldrb	r0, [r4, #24]
    7cce:	b910      	cbnz	r0, 7cd6 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0xa2>
    7cd0:	78a0      	ldrb	r0, [r4, #2]
    7cd2:	0740      	lsls	r0, r0, #29
    7cd4:	d522      	bpl.n	7d1c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0xe8>
    7cd6:	e9d4 1010 	ldrd	r1, r0, [r4, #64]	; 0x40
    7cda:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
    7cde:	4050      	eors	r0, r2
    7ce0:	ea70 0101 	orns	r1, r0, r1
    7ce4:	d01a      	beq.n	7d1c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0xe8>
    7ce6:	f7fb fe5d 	bl	39a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>
    7cea:	e9d4 2310 	ldrd	r2, r3, [r4, #64]	; 0x40
    7cee:	1a80      	subs	r0, r0, r2
    7cf0:	4199      	sbcs	r1, r3
    7cf2:	d313      	bcc.n	7d1c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0xe8>
    7cf4:	f7fe ff1a 	bl	6b2c <sym_RHRHCWPUPZHCOID576WBS7QZ2KAUT2GASS2T3QY>
    7cf8:	492c      	ldr	r1, [pc, #176]	; (7dac <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x178>)
    7cfa:	fba0 2301 	umull	r2, r3, r0, r1
    7cfe:	f104 0040 	add.w	r0, r4, #64	; 0x40
    7d02:	f007 fbaf 	bl	f464 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xe0>
    7d06:	2101      	movs	r1, #1
    7d08:	4620      	mov	r0, r4
    7d0a:	f007 fb59 	bl	f3c0 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x3c>
    7d0e:	78a0      	ldrb	r0, [r4, #2]
    7d10:	0740      	lsls	r0, r0, #29
    7d12:	d503      	bpl.n	7d1c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0xe8>
    7d14:	2101      	movs	r1, #1
    7d16:	4620      	mov	r0, r4
    7d18:	f000 fabc 	bl	8294 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x294>
    7d1c:	f104 0130 	add.w	r1, r4, #48	; 0x30
    7d20:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    7d22:	f006 fa96 	bl	e252 <sym_VPXIA5P4C72CY3ME4ZVXBADOKEG5S4C7Z7QZZFA>
    7d26:	f104 0138 	add.w	r1, r4, #56	; 0x38
    7d2a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    7d2c:	f006 fa94 	bl	e258 <sym_MF4WRTQNYFRYRFGW7FZUI3ZAYNQZ5EQ54QSK6JQ>
    7d30:	f7fe ff54 	bl	6bdc <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY>
    7d34:	6870      	ldr	r0, [r6, #4]
    7d36:	1cc0      	adds	r0, r0, #3
    7d38:	f006 fba4 	bl	e484 <sym_2X6ZBBHQKFJV27I6OQZLD4IRAL5JANEGA5N34WA>
    7d3c:	73a8      	strb	r0, [r5, #14]
    7d3e:	78a0      	ldrb	r0, [r4, #2]
    7d40:	07c0      	lsls	r0, r0, #31
    7d42:	d028      	beq.n	7d96 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x162>
    7d44:	a903      	add	r1, sp, #12
    7d46:	2000      	movs	r0, #0
    7d48:	f006 f959 	bl	dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>
    7d4c:	b120      	cbz	r0, 7d58 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x124>
    7d4e:	f640 118c 	movw	r1, #2444	; 0x98c
    7d52:	202d      	movs	r0, #45	; 0x2d
    7d54:	f7fd f9fe 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    7d58:	20ff      	movs	r0, #255	; 0xff
    7d5a:	73e8      	strb	r0, [r5, #15]
    7d5c:	69e6      	ldr	r6, [r4, #28]
    7d5e:	f106 070a 	add.w	r7, r6, #10
    7d62:	e013      	b.n	7d8c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x158>
    7d64:	9c05      	ldr	r4, [sp, #20]
    7d66:	42b4      	cmp	r4, r6
    7d68:	d010      	beq.n	7d8c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x158>
    7d6a:	7a72      	ldrb	r2, [r6, #9]
    7d6c:	7a60      	ldrb	r0, [r4, #9]
    7d6e:	463b      	mov	r3, r7
    7d70:	f104 010a 	add.w	r1, r4, #10
    7d74:	f006 fafb 	bl	e36e <sym_4ZZLWI6QQY4KJYYVP4RVDTJJJ6MW72AL2TJDVOI>
    7d78:	b140      	cbz	r0, 7d8c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x158>
    7d7a:	78a0      	ldrb	r0, [r4, #2]
    7d7c:	73e8      	strb	r0, [r5, #15]
    7d7e:	f8d4 0003 	ldr.w	r0, [r4, #3]
    7d82:	6128      	str	r0, [r5, #16]
    7d84:	f8b4 0007 	ldrh.w	r0, [r4, #7]
    7d88:	82a8      	strh	r0, [r5, #20]
    7d8a:	e004      	b.n	7d96 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x162>
    7d8c:	a803      	add	r0, sp, #12
    7d8e:	f7fd fc25 	bl	55dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>
    7d92:	2800      	cmp	r0, #0
    7d94:	d0e6      	beq.n	7d64 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x130>
    7d96:	2000      	movs	r0, #0
    7d98:	e794      	b.n	7cc4 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x90>
    7d9a:	0000      	.short	0x0000
    7d9c:	20001678 	.word	0x20001678
    7da0:	000083a8 	.word	0x000083a8
    7da4:	20000138 	.word	0x20000138
    7da8:	8e89bed6 	.word	0x8e89bed6
    7dac:	000f4240 	.word	0x000f4240
    7db0:	b510      	push	{r4, lr}
    7db2:	4604      	mov	r4, r0
    7db4:	f7ff ff3e 	bl	7c34 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ>
    7db8:	2800      	cmp	r0, #0
    7dba:	d108      	bne.n	7dce <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x19a>
    7dbc:	4804      	ldr	r0, [pc, #16]	; (7dd0 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x19c>)
    7dbe:	7800      	ldrb	r0, [r0, #0]
    7dc0:	2801      	cmp	r0, #1
    7dc2:	d003      	beq.n	7dcc <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x198>
    7dc4:	2100      	movs	r1, #0
    7dc6:	4620      	mov	r0, r4
    7dc8:	f7ff fdb4 	bl	7934 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x10>
    7dcc:	2000      	movs	r0, #0
    7dce:	bd10      	pop	{r4, pc}
    7dd0:	20001678 	.word	0x20001678
    7dd4:	480a      	ldr	r0, [pc, #40]	; (7e00 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x1cc>)
    7dd6:	b510      	push	{r4, lr}
    7dd8:	490a      	ldr	r1, [pc, #40]	; (7e04 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x1d0>)
    7dda:	6804      	ldr	r4, [r0, #0]
    7ddc:	7808      	ldrb	r0, [r1, #0]
    7dde:	2800      	cmp	r0, #0
    7de0:	d00d      	beq.n	7dfe <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x1ca>
    7de2:	7808      	ldrb	r0, [r1, #0]
    7de4:	2802      	cmp	r0, #2
    7de6:	d002      	beq.n	7dee <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x1ba>
    7de8:	7808      	ldrb	r0, [r1, #0]
    7dea:	2803      	cmp	r0, #3
    7dec:	d102      	bne.n	7df4 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x1c0>
    7dee:	4620      	mov	r0, r4
    7df0:	f7ff ff0e 	bl	7c10 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x2ec>
    7df4:	4620      	mov	r0, r4
    7df6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    7dfa:	f000 b909 	b.w	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>
    7dfe:	bd10      	pop	{r4, pc}
    7e00:	20000138 	.word	0x20000138
    7e04:	20001678 	.word	0x20001678
    7e08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7e0c:	4604      	mov	r4, r0
    7e0e:	4827      	ldr	r0, [pc, #156]	; (7eac <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x278>)
    7e10:	460d      	mov	r5, r1
    7e12:	6840      	ldr	r0, [r0, #4]
    7e14:	f004 f8c6 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    7e18:	4e25      	ldr	r6, [pc, #148]	; (7eb0 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x27c>)
    7e1a:	2004      	movs	r0, #4
    7e1c:	7030      	strb	r0, [r6, #0]
    7e1e:	b325      	cbz	r5, 7e6a <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x236>
    7e20:	8860      	ldrh	r0, [r4, #2]
    7e22:	2810      	cmp	r0, #16
    7e24:	d02a      	beq.n	7e7c <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x248>
    7e26:	f104 0020 	add.w	r0, r4, #32
    7e2a:	4680      	mov	r8, r0
    7e2c:	68b5      	ldr	r5, [r6, #8]
    7e2e:	f007 fb3f 	bl	f4b0 <sym_STP6UONGXHZIIGYZLLHSWZFO5DU7227CCUKBTDQ>
    7e32:	4607      	mov	r7, r0
    7e34:	4640      	mov	r0, r8
    7e36:	f007 fb64 	bl	f502 <sym_4U2RA2RXIRU5BEMWZTHT3PETZK6K62P2SAJVWHA>
    7e3a:	1a38      	subs	r0, r7, r0
    7e3c:	1e40      	subs	r0, r0, #1
    7e3e:	b2c0      	uxtb	r0, r0
    7e40:	8861      	ldrh	r1, [r4, #2]
    7e42:	2228      	movs	r2, #40	; 0x28
    7e44:	f000 faec 	bl	8420 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I>
    7e48:	4405      	add	r5, r0
    7e4a:	78a0      	ldrb	r0, [r4, #2]
    7e4c:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    7e50:	b130      	cbz	r0, 7e60 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x22c>
    7e52:	6870      	ldr	r0, [r6, #4]
    7e54:	4405      	add	r5, r0
    7e56:	f007 fbad 	bl	f5b4 <sym_USXJ3USYRHE5AVFUSG2J2G7QDHRASPG75ESP25A>
    7e5a:	4428      	add	r0, r5
    7e5c:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
    7e60:	7922      	ldrb	r2, [r4, #4]
    7e62:	4629      	mov	r1, r5
    7e64:	2000      	movs	r0, #0
    7e66:	f004 f8b3 	bl	bfd0 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA>
    7e6a:	8860      	ldrh	r0, [r4, #2]
    7e6c:	2813      	cmp	r0, #19
    7e6e:	d013      	beq.n	7e98 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x264>
    7e70:	dc09      	bgt.n	7e86 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x252>
    7e72:	2810      	cmp	r0, #16
    7e74:	d017      	beq.n	7ea6 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x272>
    7e76:	2812      	cmp	r0, #18
    7e78:	d109      	bne.n	7e8e <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x25a>
    7e7a:	e00d      	b.n	7e98 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x264>
    7e7c:	7921      	ldrb	r1, [r4, #4]
    7e7e:	2000      	movs	r0, #0
    7e80:	f003 fe74 	bl	bb6c <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI>
    7e84:	e7f1      	b.n	7e6a <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x236>
    7e86:	2815      	cmp	r0, #21
    7e88:	d006      	beq.n	7e98 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x264>
    7e8a:	281d      	cmp	r0, #29
    7e8c:	d004      	beq.n	7e98 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x264>
    7e8e:	f640 5148 	movw	r1, #3400	; 0xd48
    7e92:	202d      	movs	r0, #45	; 0x2d
    7e94:	f7fd f95e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    7e98:	7922      	ldrb	r2, [r4, #4]
    7e9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7e9e:	2101      	movs	r1, #1
    7ea0:	2000      	movs	r0, #0
    7ea2:	f004 b8f7 	b.w	c094 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q>
    7ea6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7eaa:	0000      	.short	0x0000
    7eac:	20000138 	.word	0x20000138
    7eb0:	20001678 	.word	0x20001678
    7eb4:	b510      	push	{r4, lr}
    7eb6:	4604      	mov	r4, r0
    7eb8:	7800      	ldrb	r0, [r0, #0]
    7eba:	460b      	mov	r3, r1
    7ebc:	f884 00b5 	strb.w	r0, [r4, #181]	; 0xb5
    7ec0:	29ff      	cmp	r1, #255	; 0xff
    7ec2:	d010      	beq.n	7ee6 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x2b2>
    7ec4:	f104 02b7 	add.w	r2, r4, #183	; 0xb7
    7ec8:	1e51      	subs	r1, r2, #1
    7eca:	4618      	mov	r0, r3
    7ecc:	f7fe fe02 	bl	6ad4 <sym_YAOI5BW7G2C6EUUY2B4S7A3CWX63A6MP2T3O5KA>
    7ed0:	b130      	cbz	r0, 7ee0 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x2ac>
    7ed2:	f894 00b6 	ldrb.w	r0, [r4, #182]	; 0xb6
    7ed6:	f040 0002 	orr.w	r0, r0, #2
    7eda:	f884 00b6 	strb.w	r0, [r4, #182]	; 0xb6
    7ede:	e011      	b.n	7f04 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x2d0>
    7ee0:	f640 7193 	movw	r1, #3987	; 0xf93
    7ee4:	e023      	b.n	7f2e <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x2fa>
    7ee6:	4813      	ldr	r0, [pc, #76]	; (7f34 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x300>)
    7ee8:	6840      	ldr	r0, [r0, #4]
    7eea:	7801      	ldrb	r1, [r0, #0]
    7eec:	f3c1 1180 	ubfx	r1, r1, #6, #1
    7ef0:	f884 10b6 	strb.w	r1, [r4, #182]	; 0xb6
    7ef4:	f8d0 1003 	ldr.w	r1, [r0, #3]
    7ef8:	f8c4 10b7 	str.w	r1, [r4, #183]	; 0xb7
    7efc:	f8b0 0007 	ldrh.w	r0, [r0, #7]
    7f00:	f8a4 00bb 	strh.w	r0, [r4, #187]	; 0xbb
    7f04:	f994 0026 	ldrsb.w	r0, [r4, #38]	; 0x26
    7f08:	287f      	cmp	r0, #127	; 0x7f
    7f0a:	d00e      	beq.n	7f2a <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x2f6>
    7f0c:	f884 00bd 	strb.w	r0, [r4, #189]	; 0xbd
    7f10:	207f      	movs	r0, #127	; 0x7f
    7f12:	f884 0026 	strb.w	r0, [r4, #38]	; 0x26
    7f16:	2219      	movs	r2, #25
    7f18:	4621      	mov	r1, r4
    7f1a:	f104 00ac 	add.w	r0, r4, #172	; 0xac
    7f1e:	f7ff f941 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    7f22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    7f26:	f7ff ba0f 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    7f2a:	f640 51fb 	movw	r1, #3579	; 0xdfb
    7f2e:	202d      	movs	r0, #45	; 0x2d
    7f30:	f7fd f910 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    7f34:	20000138 	.word	0x20000138
    7f38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7f3c:	4690      	mov	r8, r2
    7f3e:	460e      	mov	r6, r1
    7f40:	4604      	mov	r4, r0
    7f42:	2903      	cmp	r1, #3
    7f44:	d004      	beq.n	7f50 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x31c>
    7f46:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
    7f4a:	b108      	cbz	r0, 7f50 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x31c>
    7f4c:	2001      	movs	r0, #1
    7f4e:	e000      	b.n	7f52 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x31e>
    7f50:	2000      	movs	r0, #0
    7f52:	4681      	mov	r9, r0
    7f54:	f003 fdac 	bl	bab0 <sym_BNUQ5CI25DXEDLVOULTXPCKLL6P4CJJYO4G535I>
    7f58:	4605      	mov	r5, r0
    7f5a:	2e03      	cmp	r6, #3
    7f5c:	d003      	beq.n	7f66 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x332>
    7f5e:	2701      	movs	r7, #1
    7f60:	2e05      	cmp	r6, #5
    7f62:	d005      	beq.n	7f70 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x33c>
    7f64:	e008      	b.n	7f78 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x344>
    7f66:	78a0      	ldrb	r0, [r4, #2]
    7f68:	2702      	movs	r7, #2
    7f6a:	f3c0 0040 	ubfx	r0, r0, #1, #1
    7f6e:	e001      	b.n	7f74 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x340>
    7f70:	78a0      	ldrb	r0, [r4, #2]
    7f72:	07c0      	lsls	r0, r0, #31
    7f74:	2800      	cmp	r0, #0
    7f76:	d042      	beq.n	7ffe <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3ca>
    7f78:	f1b9 0f00 	cmp.w	r9, #0
    7f7c:	d13e      	bne.n	7ffc <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3c8>
    7f7e:	4822      	ldr	r0, [pc, #136]	; (8008 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x8>)
    7f80:	7b80      	ldrb	r0, [r0, #14]
    7f82:	b140      	cbz	r0, 7f96 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x362>
    7f84:	f006 fa81 	bl	e48a <sym_GKUVQYGVTZ7DKWBNC3M5TXN4XZ4Q6TUJFSFOWBA>
    7f88:	f888 0000 	strb.w	r0, [r8]
    7f8c:	28ff      	cmp	r0, #255	; 0xff
    7f8e:	d002      	beq.n	7f96 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x362>
    7f90:	f7fe fdba 	bl	6b08 <sym_IJTA37LCLZMYZVQ3I74HRUK4JDZEZR23VU3JFJI>
    7f94:	4305      	orrs	r5, r0
    7f96:	4e1d      	ldr	r6, [pc, #116]	; (800c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xc>)
    7f98:	f894 204f 	ldrb.w	r2, [r4, #79]	; 0x4f
    7f9c:	f104 0350 	add.w	r3, r4, #80	; 0x50
    7fa0:	6871      	ldr	r1, [r6, #4]
    7fa2:	f811 0b03 	ldrb.w	r0, [r1], #3
    7fa6:	f3c0 1080 	ubfx	r0, r0, #6, #1
    7faa:	f006 f9e0 	bl	e36e <sym_4ZZLWI6QQY4KJYYVP4RVDTJJJ6MW72AL2TJDVOI>
    7fae:	f898 1000 	ldrb.w	r1, [r8]
    7fb2:	29ff      	cmp	r1, #255	; 0xff
    7fb4:	d004      	beq.n	7fc0 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x38c>
    7fb6:	b990      	cbnz	r0, 7fde <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3aa>
    7fb8:	7e60      	ldrb	r0, [r4, #25]
    7fba:	4288      	cmp	r0, r1
    7fbc:	d00f      	beq.n	7fde <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3aa>
    7fbe:	e008      	b.n	7fd2 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x39e>
    7fc0:	b138      	cbz	r0, 7fd2 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x39e>
    7fc2:	6871      	ldr	r1, [r6, #4]
    7fc4:	f811 0b03 	ldrb.w	r0, [r1], #3
    7fc8:	f3c0 1080 	ubfx	r0, r0, #6, #1
    7fcc:	f007 f9df 	bl	f38e <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xa>
    7fd0:	b128      	cbz	r0, 7fde <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3aa>
    7fd2:	2000      	movs	r0, #0
    7fd4:	78a1      	ldrb	r1, [r4, #2]
    7fd6:	0749      	lsls	r1, r1, #29
    7fd8:	d503      	bpl.n	7fe2 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3ae>
    7fda:	b990      	cbnz	r0, 8002 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2>
    7fdc:	e00e      	b.n	7ffc <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3c8>
    7fde:	2001      	movs	r0, #1
    7fe0:	e7f8      	b.n	7fd4 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3a0>
    7fe2:	b975      	cbnz	r5, 8002 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2>
    7fe4:	7be0      	ldrb	r0, [r4, #15]
    7fe6:	b108      	cbz	r0, 7fec <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3b8>
    7fe8:	42b8      	cmp	r0, r7
    7fea:	d107      	bne.n	7ffc <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3c8>
    7fec:	6871      	ldr	r1, [r6, #4]
    7fee:	f811 0b03 	ldrb.w	r0, [r1], #3
    7ff2:	f3c0 1080 	ubfx	r0, r0, #6, #1
    7ff6:	f007 f9ca 	bl	f38e <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xa>
    7ffa:	b110      	cbz	r0, 8002 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2>
    7ffc:	2000      	movs	r0, #0
    7ffe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8002:	2001      	movs	r0, #1
    8004:	e7fb      	b.n	7ffe <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x3ca>
    8006:	0000      	.short	0x0000
    8008:	20001678 	.word	0x20001678
    800c:	20000138 	.word	0x20000138
    8010:	b570      	push	{r4, r5, r6, lr}
    8012:	4604      	mov	r4, r0
    8014:	8d00      	ldrh	r0, [r0, #40]	; 0x28
    8016:	4d13      	ldr	r5, [pc, #76]	; (8064 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x64>)
    8018:	1c40      	adds	r0, r0, #1
    801a:	8520      	strh	r0, [r4, #40]	; 0x28
    801c:	7ba8      	ldrb	r0, [r5, #14]
    801e:	2600      	movs	r6, #0
    8020:	b120      	cbz	r0, 802c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2c>
    8022:	f003 fd2b 	bl	ba7c <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y>
    8026:	f003 fb4f 	bl	b6c8 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI>
    802a:	73ae      	strb	r6, [r5, #14]
    802c:	702e      	strb	r6, [r5, #0]
    802e:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
    8032:	b108      	cbz	r0, 8038 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x38>
    8034:	2101      	movs	r1, #1
    8036:	e00f      	b.n	8058 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x58>
    8038:	7b60      	ldrb	r0, [r4, #13]
    803a:	b160      	cbz	r0, 8056 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x56>
    803c:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    803e:	4288      	cmp	r0, r1
    8040:	d809      	bhi.n	8056 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x56>
    8042:	2101      	movs	r1, #1
    8044:	4620      	mov	r0, r4
    8046:	f007 fad9 	bl	f5fc <sym_FY3JF6XBXLAG22E42UPFUU55A3QFAFZDUGSPAPY>
    804a:	78a0      	ldrb	r0, [r4, #2]
    804c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    8050:	07c0      	lsls	r0, r0, #31
    8052:	f7ff b979 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    8056:	2100      	movs	r1, #0
    8058:	4620      	mov	r0, r4
    805a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    805e:	f007 bacd 	b.w	f5fc <sym_FY3JF6XBXLAG22E42UPFUU55A3QFAFZDUGSPAPY>
    8062:	0000      	.short	0x0000
    8064:	20001678 	.word	0x20001678
    8068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    806a:	4604      	mov	r4, r0
    806c:	f890 006c 	ldrb.w	r0, [r0, #108]	; 0x6c
    8070:	4616      	mov	r6, r2
    8072:	460d      	mov	r5, r1
    8074:	f88d 0000 	strb.w	r0, [sp]
    8078:	9800      	ldr	r0, [sp, #0]
    807a:	9000      	str	r0, [sp, #0]
    807c:	f89d 0000 	ldrb.w	r0, [sp]
    8080:	b110      	cbz	r0, 8088 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x88>
    8082:	f640 31fa 	movw	r1, #3066	; 0xbfa
    8086:	e055      	b.n	8134 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x134>
    8088:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
    808c:	2700      	movs	r7, #0
    808e:	8828      	ldrh	r0, [r5, #0]
    8090:	f8a4 0070 	strh.w	r0, [r4, #112]	; 0x70
    8094:	2b00      	cmp	r3, #0
    8096:	d14a      	bne.n	812e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x12e>
    8098:	6928      	ldr	r0, [r5, #16]
    809a:	f006 fa45 	bl	e528 <sym_DSAIJDVMFSSNYDQYP4G3W4ZBYTG4PAWPSVOBJ2Y>
    809e:	f8a4 0086 	strh.w	r0, [r4, #134]	; 0x86
    80a2:	8b28      	ldrh	r0, [r5, #24]
    80a4:	f8a4 0088 	strh.w	r0, [r4, #136]	; 0x88
    80a8:	8b68      	ldrh	r0, [r5, #26]
    80aa:	f8a4 008a 	strh.w	r0, [r4, #138]	; 0x8a
    80ae:	f895 01c7 	ldrb.w	r0, [r5, #455]	; 0x1c7
    80b2:	f884 008c 	strb.w	r0, [r4, #140]	; 0x8c
    80b6:	7e20      	ldrb	r0, [r4, #24]
    80b8:	f104 0149 	add.w	r1, r4, #73	; 0x49
    80bc:	460d      	mov	r5, r1
    80be:	b120      	cbz	r0, 80ca <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xca>
    80c0:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
    80c4:	f007 f82a 	bl	f11c <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xe0>
    80c8:	b940      	cbnz	r0, 80dc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xdc>
    80ca:	f894 0062 	ldrb.w	r0, [r4, #98]	; 0x62
    80ce:	b170      	cbz	r0, 80ee <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xee>
    80d0:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
    80d4:	4629      	mov	r1, r5
    80d6:	f007 f818 	bl	f10a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xce>
    80da:	b140      	cbz	r0, 80ee <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xee>
    80dc:	f8d4 0049 	ldr.w	r0, [r4, #73]	; 0x49
    80e0:	f8c4 007a 	str.w	r0, [r4, #122]	; 0x7a
    80e4:	f8b4 004d 	ldrh.w	r0, [r4, #77]	; 0x4d
    80e8:	f8a4 007e 	strh.w	r0, [r4, #126]	; 0x7e
    80ec:	e003      	b.n	80f6 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf6>
    80ee:	f8c4 707a 	str.w	r7, [r4, #122]	; 0x7a
    80f2:	f8a4 707e 	strh.w	r7, [r4, #126]	; 0x7e
    80f6:	4814      	ldr	r0, [pc, #80]	; (8148 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x148>)
    80f8:	2eff      	cmp	r6, #255	; 0xff
    80fa:	6840      	ldr	r0, [r0, #4]
    80fc:	7801      	ldrb	r1, [r0, #0]
    80fe:	f3c1 1180 	ubfx	r1, r1, #6, #1
    8102:	f884 1073 	strb.w	r1, [r4, #115]	; 0x73
    8106:	f850 1f03 	ldr.w	r1, [r0, #3]!
    810a:	d016      	beq.n	813a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x13a>
    810c:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
    8110:	8880      	ldrh	r0, [r0, #4]
    8112:	f8a4 0084 	strh.w	r0, [r4, #132]	; 0x84
    8116:	f104 0274 	add.w	r2, r4, #116	; 0x74
    811a:	1e51      	subs	r1, r2, #1
    811c:	4630      	mov	r0, r6
    811e:	f7fe fcd9 	bl	6ad4 <sym_YAOI5BW7G2C6EUUY2B4S7A3CWX63A6MP2T3O5KA>
    8122:	b128      	cbz	r0, 8130 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x130>
    8124:	f814 0f73 	ldrb.w	r0, [r4, #115]!
    8128:	f040 0002 	orr.w	r0, r0, #2
    812c:	7020      	strb	r0, [r4, #0]
    812e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8130:	f640 411b 	movw	r1, #3099	; 0xc1b
    8134:	202d      	movs	r0, #45	; 0x2d
    8136:	f7fd f80d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    813a:	f844 1f74 	str.w	r1, [r4, #116]!
    813e:	8880      	ldrh	r0, [r0, #4]
    8140:	80a0      	strh	r0, [r4, #4]
    8142:	60e7      	str	r7, [r4, #12]
    8144:	8227      	strh	r7, [r4, #16]
    8146:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8148:	20000138 	.word	0x20000138
    814c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    814e:	4604      	mov	r4, r0
    8150:	20ff      	movs	r0, #255	; 0xff
    8152:	f88d 0000 	strb.w	r0, [sp]
    8156:	2601      	movs	r6, #1
    8158:	466a      	mov	r2, sp
    815a:	2105      	movs	r1, #5
    815c:	4620      	mov	r0, r4
    815e:	f7ff feeb 	bl	7f38 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x304>
    8162:	b160      	cbz	r0, 817e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x17e>
    8164:	4d2c      	ldr	r5, [pc, #176]	; (8218 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x218>)
    8166:	4f2b      	ldr	r7, [pc, #172]	; (8214 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x214>)
    8168:	6869      	ldr	r1, [r5, #4]
    816a:	7bfa      	ldrb	r2, [r7, #15]
    816c:	f107 0310 	add.w	r3, r7, #16
    8170:	f811 0b03 	ldrb.w	r0, [r1], #3
    8174:	f3c0 1080 	ubfx	r0, r0, #6, #1
    8178:	f006 f8f9 	bl	e36e <sym_4ZZLWI6QQY4KJYYVP4RVDTJJJ6MW72AL2TJDVOI>
    817c:	b110      	cbz	r0, 8184 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x184>
    817e:	2600      	movs	r6, #0
    8180:	4630      	mov	r0, r6
    8182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8184:	686a      	ldr	r2, [r5, #4]
    8186:	69e0      	ldr	r0, [r4, #28]
    8188:	7812      	ldrb	r2, [r2, #0]
    818a:	f810 1f8e 	ldrb.w	r1, [r0, #142]!
    818e:	f3c2 1240 	ubfx	r2, r2, #5, #1
    8192:	4011      	ands	r1, r2
    8194:	7001      	strb	r1, [r0, #0]
    8196:	2201      	movs	r2, #1
    8198:	4620      	mov	r0, r4
    819a:	69e1      	ldr	r1, [r4, #28]
    819c:	f000 f8a8 	bl	82f0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2f0>
    81a0:	2300      	movs	r3, #0
    81a2:	f89d 2000 	ldrb.w	r2, [sp]
    81a6:	4620      	mov	r0, r4
    81a8:	69e1      	ldr	r1, [r4, #28]
    81aa:	f7ff ff5d 	bl	8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>
    81ae:	220e      	movs	r2, #14
    81b0:	4621      	mov	r1, r4
    81b2:	f104 0064 	add.w	r0, r4, #100	; 0x64
    81b6:	f7fe fff5 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    81ba:	69e0      	ldr	r0, [r4, #28]
    81bc:	2203      	movs	r2, #3
    81be:	8801      	ldrh	r1, [r0, #0]
    81c0:	f8a4 10a8 	strh.w	r1, [r4, #168]	; 0xa8
    81c4:	f890 008e 	ldrb.w	r0, [r0, #142]	; 0x8e
    81c8:	f884 00aa 	strb.w	r0, [r4, #170]	; 0xaa
    81cc:	4621      	mov	r1, r4
    81ce:	f104 009e 	add.w	r0, r4, #158	; 0x9e
    81d2:	f7fe ffe7 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    81d6:	f7ff f8b7 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    81da:	2000      	movs	r0, #0
    81dc:	7038      	strb	r0, [r7, #0]
    81de:	2200      	movs	r2, #0
    81e0:	4621      	mov	r1, r4
    81e2:	69e0      	ldr	r0, [r4, #28]
    81e4:	f000 fa74 	bl	86d0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ>
    81e8:	69e0      	ldr	r0, [r4, #28]
    81ea:	8800      	ldrh	r0, [r0, #0]
    81ec:	f7fd fbda 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    81f0:	f005 fdd7 	bl	dda2 <sym_56BVXVVSYPZZTDFBHBV4MJAFTYIS7HMITNWUEZQ>
    81f4:	6868      	ldr	r0, [r5, #4]
    81f6:	69e1      	ldr	r1, [r4, #28]
    81f8:	f8d0 2003 	ldr.w	r2, [r0, #3]
    81fc:	f841 2f03 	str.w	r2, [r1, #3]!
    8200:	f8b0 2007 	ldrh.w	r2, [r0, #7]
    8204:	808a      	strh	r2, [r1, #4]
    8206:	7800      	ldrb	r0, [r0, #0]
    8208:	69e1      	ldr	r1, [r4, #28]
    820a:	f3c0 1080 	ubfx	r0, r0, #6, #1
    820e:	7088      	strb	r0, [r1, #2]
    8210:	e7b6      	b.n	8180 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x180>
    8212:	0000      	.short	0x0000
    8214:	20001678 	.word	0x20001678
    8218:	20000138 	.word	0x20000138
    821c:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    8220:	4604      	mov	r4, r0
    8222:	20ff      	movs	r0, #255	; 0xff
    8224:	f88d 0000 	strb.w	r0, [sp]
    8228:	2501      	movs	r5, #1
    822a:	466a      	mov	r2, sp
    822c:	2103      	movs	r1, #3
    822e:	4620      	mov	r0, r4
    8230:	f7ff fe82 	bl	7f38 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x304>
    8234:	b330      	cbz	r0, 8284 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x284>
    8236:	7b20      	ldrb	r0, [r4, #12]
    8238:	2700      	movs	r7, #0
    823a:	b168      	cbz	r0, 8258 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x258>
    823c:	f894 00b4 	ldrb.w	r0, [r4, #180]	; 0xb4
    8240:	f88d 0004 	strb.w	r0, [sp, #4]
    8244:	9801      	ldr	r0, [sp, #4]
    8246:	9001      	str	r0, [sp, #4]
    8248:	f89d 0004 	ldrb.w	r0, [sp, #4]
    824c:	b920      	cbnz	r0, 8258 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x258>
    824e:	f89d 1000 	ldrb.w	r1, [sp]
    8252:	4620      	mov	r0, r4
    8254:	f7ff fe2e 	bl	7eb4 <sym_KBJ4SX4MJK4IAM4DI3ILSISVXIP6O72O62TW3OQ+0x280>
    8258:	4e0c      	ldr	r6, [pc, #48]	; (828c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28c>)
    825a:	2104      	movs	r1, #4
    825c:	6870      	ldr	r0, [r6, #4]
    825e:	8007      	strh	r7, [r0, #0]
    8260:	f006 fca8 	bl	ebb4 <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY>
    8264:	4620      	mov	r0, r4
    8266:	f000 f88b 	bl	8380 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x380>
    826a:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
    826e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    8270:	6870      	ldr	r0, [r6, #4]
    8272:	f006 fcd6 	bl	ec22 <sym_MAMY3D3622JJLMFKLRQXSRTVOPUNWAAGSSCAVMY>
    8276:	4906      	ldr	r1, [pc, #24]	; (8290 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x290>)
    8278:	2005      	movs	r0, #5
    827a:	7008      	strb	r0, [r1, #0]
    827c:	6870      	ldr	r0, [r6, #4]
    827e:	f003 fe91 	bl	bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>
    8282:	e000      	b.n	8286 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x286>
    8284:	2500      	movs	r5, #0
    8286:	4628      	mov	r0, r5
    8288:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
    828c:	20000138 	.word	0x20000138
    8290:	20001678 	.word	0x20001678
    8294:	b570      	push	{r4, r5, r6, lr}
    8296:	4604      	mov	r4, r0
    8298:	460e      	mov	r6, r1
    829a:	7e40      	ldrb	r0, [r0, #25]
    829c:	f7fe fbf4 	bl	6a88 <sym_PLOW4TMGVQT52FP2ERNRL6S5EELE2YO563WRPJA>
    82a0:	0005      	movs	r5, r0
    82a2:	d019      	beq.n	82d8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2d8>
    82a4:	2110      	movs	r1, #16
    82a6:	f006 fadd 	bl	e864 <sym_35JWAFJL2IEYRDNORVIQ7BBAS7FQNUVOFCLQNSQ>
    82aa:	2800      	cmp	r0, #0
    82ac:	d114      	bne.n	82d8 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2d8>
    82ae:	2001      	movs	r0, #1
    82b0:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    82b4:	f104 0157 	add.w	r1, r4, #87	; 0x57
    82b8:	4632      	mov	r2, r6
    82ba:	460c      	mov	r4, r1
    82bc:	4628      	mov	r0, r5
    82be:	f006 f886 	bl	e3ce <sym_BLMJ5IIKWMCUMGRAJC47JTAD5DUGOY4TIBII5HY>
    82c2:	4621      	mov	r1, r4
    82c4:	4c05      	ldr	r4, [pc, #20]	; (82dc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2dc>)
    82c6:	6860      	ldr	r0, [r4, #4]
    82c8:	f006 fc8f 	bl	ebea <sym_6GC7CC2BUFLCMQVOZDACHKZEET4WUCXSLEMHSCY>
    82cc:	6860      	ldr	r0, [r4, #4]
    82ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    82d2:	2101      	movs	r1, #1
    82d4:	f006 bc8f 	b.w	ebf6 <sym_6FJEZEEBKMCAKI6FMPGNQ7TUXYDPYPEPSNJFOMQ>
    82d8:	bd70      	pop	{r4, r5, r6, pc}
    82da:	0000      	.short	0x0000
    82dc:	20000138 	.word	0x20000138
    82e0:	4802      	ldr	r0, [pc, #8]	; (82ec <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2ec>)
    82e2:	2101      	movs	r1, #1
    82e4:	6800      	ldr	r0, [r0, #0]
    82e6:	f7ff bb25 	b.w	7934 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x10>
    82ea:	0000      	.short	0x0000
    82ec:	20000138 	.word	0x20000138
    82f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    82f4:	4e21      	ldr	r6, [pc, #132]	; (837c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x37c>)
    82f6:	4680      	mov	r8, r0
    82f8:	460c      	mov	r4, r1
    82fa:	6870      	ldr	r0, [r6, #4]
    82fc:	4615      	mov	r5, r2
    82fe:	f850 1f0f 	ldr.w	r1, [r0, #15]!
    8302:	6161      	str	r1, [r4, #20]
    8304:	8881      	ldrh	r1, [r0, #4]
    8306:	83a1      	strh	r1, [r4, #28]
    8308:	7981      	ldrb	r1, [r0, #6]
    830a:	77a1      	strb	r1, [r4, #30]
    830c:	8940      	ldrh	r0, [r0, #10]
    830e:	f006 f907 	bl	e520 <sym_3GY4TYJRRJL4WNFV6XN3ATYT4MIF4FYTN3S33RI>
    8312:	4607      	mov	r7, r0
    8314:	6120      	str	r0, [r4, #16]
    8316:	6870      	ldr	r0, [r6, #4]
    8318:	4639      	mov	r1, r7
    831a:	7d80      	ldrb	r0, [r0, #22]
    831c:	f006 fa99 	bl	e852 <sym_NREHYZNNGMA6T4VUMP47EJMM5IU7BRHAZURXRLQ>
    8320:	8420      	strh	r0, [r4, #32]
    8322:	6870      	ldr	r0, [r6, #4]
    8324:	4639      	mov	r1, r7
    8326:	f8b0 0017 	ldrh.w	r0, [r0, #23]
    832a:	f006 fa8e 	bl	e84a <sym_5SQGEOI2QIBONU3LMZVAMW3SSGU24TVE57VDLBA>
    832e:	6260      	str	r0, [r4, #36]	; 0x24
    8330:	6870      	ldr	r0, [r6, #4]
    8332:	f830 1f1b 	ldrh.w	r1, [r0, #27]!
    8336:	8321      	strh	r1, [r4, #24]
    8338:	8841      	ldrh	r1, [r0, #2]
    833a:	8361      	strh	r1, [r4, #26]
    833c:	6841      	ldr	r1, [r0, #4]
    833e:	f8c4 108f 	str.w	r1, [r4, #143]	; 0x8f
    8342:	7a01      	ldrb	r1, [r0, #8]
    8344:	f884 1093 	strb.w	r1, [r4, #147]	; 0x93
    8348:	7a41      	ldrb	r1, [r0, #9]
    834a:	f001 011f 	and.w	r1, r1, #31
    834e:	f884 109a 	strb.w	r1, [r4, #154]	; 0x9a
    8352:	7a40      	ldrb	r0, [r0, #9]
    8354:	0940      	lsrs	r0, r0, #5
    8356:	f884 01c7 	strb.w	r0, [r4, #455]	; 0x1c7
    835a:	f104 0066 	add.w	r0, r4, #102	; 0x66
    835e:	7205      	strb	r5, [r0, #8]
    8360:	7245      	strb	r5, [r0, #9]
    8362:	21ff      	movs	r1, #255	; 0xff
    8364:	7281      	strb	r1, [r0, #10]
    8366:	2100      	movs	r1, #0
    8368:	3836      	subs	r0, #54	; 0x36
    836a:	f006 fe3c 	bl	efe6 <sym_43VAZS4NQXUMOPHD7W7SYFZ3WJ6KGQYQH6UOYPQ>
    836e:	f898 000e 	ldrb.w	r0, [r8, #14]
    8372:	f884 0072 	strb.w	r0, [r4, #114]	; 0x72
    8376:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    837a:	0000      	.short	0x0000
    837c:	20000138 	.word	0x20000138
    8380:	b570      	push	{r4, r5, r6, lr}
    8382:	4d07      	ldr	r5, [pc, #28]	; (83a0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3a0>)
    8384:	4604      	mov	r4, r0
    8386:	f100 0149 	add.w	r1, r0, #73	; 0x49
    838a:	6868      	ldr	r0, [r5, #4]
    838c:	f006 fc3a 	bl	ec04 <sym_5JID42ESVW3PB7AVBNALO6R7DLTBIV3DUQMUPQY>
    8390:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
    8394:	6868      	ldr	r0, [r5, #4]
    8396:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    839a:	f006 bc39 	b.w	ec10 <sym_K5Q3WMSYKQOD5SDB35E6WH2TTH6JWICUFV7AXJA>
    839e:	0000      	.short	0x0000
    83a0:	20000138 	.word	0x20000138
    83a4:	00555555 	.word	0x00555555
    83a8:	00007bbd 	.word	0x00007bbd
    83ac:	00007a49 	.word	0x00007a49
    83b0:	00007b39 	.word	0x00007b39
    83b4:	00000000 	.word	0x00000000
    83b8:	00007b11 	.word	0x00007b11
    83bc:	00007b69 	.word	0x00007b69
    83c0:	0000f3b5 	.word	0x0000f3b5
    83c4:	0000f3bb 	.word	0x0000f3bb
    83c8:	00007db1 	.word	0x00007db1
    83cc:	00007dd5 	.word	0x00007dd5
    83d0:	000082e1 	.word	0x000082e1
    83d4:	000083c4 	.word	0x000083c4
    83d8:	000083bc 	.word	0x000083bc
    83dc:	000083b8 	.word	0x000083b8

000083e0 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY>:
    83e0:	b510      	push	{r4, lr}
    83e2:	1e42      	subs	r2, r0, #1
    83e4:	2a02      	cmp	r2, #2
    83e6:	d901      	bls.n	83ec <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0xc>
    83e8:	21ca      	movs	r1, #202	; 0xca
    83ea:	e009      	b.n	8400 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x20>
    83ec:	1e40      	subs	r0, r0, #1
    83ee:	2910      	cmp	r1, #16
    83f0:	d009      	beq.n	8406 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x26>
    83f2:	2912      	cmp	r1, #18
    83f4:	d00c      	beq.n	8410 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x30>
    83f6:	2913      	cmp	r1, #19
    83f8:	d00a      	beq.n	8410 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x30>
    83fa:	2915      	cmp	r1, #21
    83fc:	d005      	beq.n	840a <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x2a>
    83fe:	21d8      	movs	r1, #216	; 0xd8
    8400:	202f      	movs	r0, #47	; 0x2f
    8402:	f7fc fea7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    8406:	4905      	ldr	r1, [pc, #20]	; (841c <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x3c>)
    8408:	e004      	b.n	8414 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x34>
    840a:	4904      	ldr	r1, [pc, #16]	; (841c <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x3c>)
    840c:	1d89      	adds	r1, r1, #6
    840e:	e001      	b.n	8414 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x34>
    8410:	4902      	ldr	r1, [pc, #8]	; (841c <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY+0x3c>)
    8412:	1f89      	subs	r1, r1, #6
    8414:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
    8418:	bd10      	pop	{r4, pc}
    841a:	0000      	.short	0x0000
    841c:	0000f5cc 	.word	0x0000f5cc

00008420 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I>:
    8420:	1e42      	subs	r2, r0, #1
    8422:	b510      	push	{r4, lr}
    8424:	b2d2      	uxtb	r2, r2
    8426:	2a01      	cmp	r2, #1
    8428:	d903      	bls.n	8432 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x12>
    842a:	291d      	cmp	r1, #29
    842c:	d001      	beq.n	8432 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x12>
    842e:	21ee      	movs	r1, #238	; 0xee
    8430:	e00d      	b.n	844e <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x2e>
    8432:	2913      	cmp	r1, #19
    8434:	d013      	beq.n	845e <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x3e>
    8436:	dc04      	bgt.n	8442 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x22>
    8438:	2910      	cmp	r1, #16
    843a:	d00b      	beq.n	8454 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x34>
    843c:	2912      	cmp	r1, #18
    843e:	d104      	bne.n	844a <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x2a>
    8440:	e00d      	b.n	845e <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x3e>
    8442:	2915      	cmp	r1, #21
    8444:	d008      	beq.n	8458 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x38>
    8446:	291d      	cmp	r1, #29
    8448:	d00e      	beq.n	8468 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x48>
    844a:	f44f 7181 	mov.w	r1, #258	; 0x102
    844e:	202f      	movs	r0, #47	; 0x2f
    8450:	f7fc fe80 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    8454:	4807      	ldr	r0, [pc, #28]	; (8474 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x54>)
    8456:	e004      	b.n	8462 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x42>
    8458:	4806      	ldr	r0, [pc, #24]	; (8474 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x54>)
    845a:	3008      	adds	r0, #8
    845c:	e001      	b.n	8462 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x42>
    845e:	4805      	ldr	r0, [pc, #20]	; (8474 <sym_CWVFJQ3UTS5MGUYKHB563UDBBB3FBCXUIVZDU2I+0x54>)
    8460:	1d00      	adds	r0, r0, #4
    8462:	f830 0012 	ldrh.w	r0, [r0, r2, lsl #1]
    8466:	bd10      	pop	{r4, pc}
    8468:	f240 315a 	movw	r1, #858	; 0x35a
    846c:	fb10 f001 	smulbb	r0, r0, r1
    8470:	bd10      	pop	{r4, pc}
    8472:	0000      	.short	0x0000
    8474:	0000f5ba 	.word	0x0000f5ba

00008478 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY>:
    8478:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    847c:	4604      	mov	r4, r0
    847e:	f890 00d8 	ldrb.w	r0, [r0, #216]	; 0xd8
    8482:	4616      	mov	r6, r2
    8484:	460f      	mov	r7, r1
    8486:	2800      	cmp	r0, #0
    8488:	d15e      	bne.n	8548 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0xd0>
    848a:	4621      	mov	r1, r4
    848c:	484d      	ldr	r0, [pc, #308]	; (85c4 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x14c>)
    848e:	f7fb f8d7 	bl	3640 <sym_RPHL2J7CVNKM6GKLDIFI4NVAPZE2FHTYW4VJSJI>
    8492:	4605      	mov	r5, r0
    8494:	2820      	cmp	r0, #32
    8496:	d057      	beq.n	8548 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0xd0>
    8498:	2250      	movs	r2, #80	; 0x50
    849a:	2100      	movs	r1, #0
    849c:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
    84a0:	f004 fe16 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    84a4:	f884 50c0 	strb.w	r5, [r4, #192]	; 0xc0
    84a8:	2501      	movs	r5, #1
    84aa:	f8c4 70c4 	str.w	r7, [r4, #196]	; 0xc4
    84ae:	f884 50d8 	strb.w	r5, [r4, #216]	; 0xd8
    84b2:	b137      	cbz	r7, 84c2 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x4a>
    84b4:	f7ff f8c4 	bl	7640 <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY>
    84b8:	f000 0007 	and.w	r0, r0, #7
    84bc:	1c40      	adds	r0, r0, #1
    84be:	f887 01f4 	strb.w	r0, [r7, #500]	; 0x1f4
    84c2:	4620      	mov	r0, r4
    84c4:	f007 fa6c 	bl	f9a0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f6>
    84c8:	f8a4 00e8 	strh.w	r0, [r4, #232]	; 0xe8
    84cc:	2002      	movs	r0, #2
    84ce:	f884 00ea 	strb.w	r0, [r4, #234]	; 0xea
    84d2:	46a8      	mov	r8, r5
    84d4:	f884 50eb 	strb.w	r5, [r4, #235]	; 0xeb
    84d8:	2500      	movs	r5, #0
    84da:	f804 5fe0 	strb.w	r5, [r4, #224]!
    84de:	f7fc f9bf 	bl	4860 <sym_MGDULS4U2D5VQ5NBLZDC7UTSC6O3GJASJZPQJ2Q>
    84e2:	4607      	mov	r7, r0
    84e4:	f004 fc17 	bl	cd16 <sym_MGCUANL7Q2CUPWKYBFLWSWSNXIEEYBPZTHT2VZI>
    84e8:	8921      	ldrh	r1, [r4, #8]
    84ea:	3ce0      	subs	r4, #224	; 0xe0
    84ec:	4288      	cmp	r0, r1
    84ee:	d800      	bhi.n	84f2 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x7a>
    84f0:	4608      	mov	r0, r1
    84f2:	4438      	add	r0, r7
    84f4:	30cc      	adds	r0, #204	; 0xcc
    84f6:	b287      	uxth	r7, r0
    84f8:	4620      	mov	r0, r4
    84fa:	f006 fefa 	bl	f2f2 <sym_XRU76NANM3C4EMKWQU3DF6CELSRNDV6766IKPJI>
    84fe:	b330      	cbz	r0, 854e <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0xd6>
    8500:	f008 fbd0 	bl	10ca4 <sym_R2552DB5ZKNDWW24PBGEV77VCDBC44WVAYRCUXQ>
    8504:	f500 60cd 	add.w	r0, r0, #1640	; 0x668
    8508:	b281      	uxth	r1, r0
    850a:	4630      	mov	r0, r6
    850c:	f004 fc37 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    8510:	4430      	add	r0, r6
    8512:	f8c4 00e4 	str.w	r0, [r4, #228]	; 0xe4
    8516:	34c4      	adds	r4, #196	; 0xc4
    8518:	f7fb fa44 	bl	39a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>
    851c:	19c0      	adds	r0, r0, r7
    851e:	4169      	adcs	r1, r5
    8520:	e9c4 010b 	strd	r0, r1, [r4, #44]	; 0x2c
    8524:	f804 5c03 	strb.w	r5, [r4, #-3]
    8528:	f884 8004 	strb.w	r8, [r4, #4]
    852c:	2001      	movs	r0, #1
    852e:	f007 f83d 	bl	f5ac <sym_FHGEXLJ7V34P3MECCDTYSDEZTZHFJ2TXYSFZQHQ>
    8532:	f500 7088 	add.w	r0, r0, #272	; 0x110
    8536:	1a30      	subs	r0, r6, r0
    8538:	60a0      	str	r0, [r4, #8]
    853a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    853e:	0841      	lsrs	r1, r0, #1
    8540:	e9c4 010f 	strd	r0, r1, [r4, #60]	; 0x3c
    8544:	3cc4      	subs	r4, #196	; 0xc4
    8546:	e022      	b.n	858e <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x116>
    8548:	200c      	movs	r0, #12
    854a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    854e:	4620      	mov	r0, r4
    8550:	f007 f979 	bl	f846 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x19c>
    8554:	f844 0fe4 	str.w	r0, [r4, #228]!
    8558:	f804 8c23 	strb.w	r8, [r4, #-35]
    855c:	f7fb fa22 	bl	39a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>
    8560:	4680      	mov	r8, r0
    8562:	4689      	mov	r9, r1
    8564:	f7ff f86c 	bl	7640 <sym_7LZ5OF5UTH4WGXV6IKS6GUUHKYRIWQTTIJXNBEY>
    8568:	f242 7110 	movw	r1, #10000	; 0x2710
    856c:	fbb0 f2f1 	udiv	r2, r0, r1
    8570:	fb01 0012 	mls	r0, r1, r2, r0
    8574:	1839      	adds	r1, r7, r0
    8576:	eb11 0108 	adds.w	r1, r1, r8
    857a:	eb45 0009 	adc.w	r0, r5, r9
    857e:	e9c4 1003 	strd	r1, r0, [r4, #12]
    8582:	3ce4      	subs	r4, #228	; 0xe4
    8584:	b196      	cbz	r6, 85ac <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x134>
    8586:	1989      	adds	r1, r1, r6
    8588:	4168      	adcs	r0, r5
    858a:	e9c4 1040 	strd	r1, r0, [r4, #256]	; 0x100
    858e:	f894 00c0 	ldrb.w	r0, [r4, #192]	; 0xc0
    8592:	f104 01e0 	add.w	r1, r4, #224	; 0xe0
    8596:	f007 fa01 	bl	f99c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f2>
    859a:	b168      	cbz	r0, 85b8 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x140>
    859c:	f8a4 50f8 	strh.w	r5, [r4, #248]	; 0xf8
    85a0:	2100      	movs	r1, #0
    85a2:	4620      	mov	r0, r4
    85a4:	f006 fed1 	bl	f34a <sym_WAXMY55QAGCTLTIDQV34FPT2PPSDRT5VDN7EYYY>
    85a8:	2000      	movs	r0, #0
    85aa:	e7ce      	b.n	854a <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0xd2>
    85ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    85b0:	0841      	lsrs	r1, r0, #1
    85b2:	e9c4 0140 	strd	r0, r1, [r4, #256]	; 0x100
    85b6:	e7ea      	b.n	858e <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY+0x116>
    85b8:	f44f 71f6 	mov.w	r1, #492	; 0x1ec
    85bc:	2030      	movs	r0, #48	; 0x30
    85be:	f7fc fdc9 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    85c2:	0000      	.short	0x0000
    85c4:	0000fb1d 	.word	0x0000fb1d

000085c8 <sym_4O3EP57XWWWRY57PVJMDKXNE25ZWFBDV6LLBFQQ>:
    85c8:	4803      	ldr	r0, [pc, #12]	; (85d8 <sym_4O3EP57XWWWRY57PVJMDKXNE25ZWFBDV6LLBFQQ+0x10>)
    85ca:	2100      	movs	r1, #0
    85cc:	7001      	strb	r1, [r0, #0]
    85ce:	2201      	movs	r2, #1
    85d0:	7082      	strb	r2, [r0, #2]
    85d2:	7041      	strb	r1, [r0, #1]
    85d4:	f007 b852 	b.w	f67c <sym_3LXCSEW4O4NZFGMXLMWXSJJVGEQV4VDRFCVRV4Q>
    85d8:	20000148 	.word	0x20000148

000085dc <sym_O6J3MUC4KJEDMNJLCC5Z3G5LTC5IHVL4PW7F6QI>:
    85dc:	4901      	ldr	r1, [pc, #4]	; (85e4 <sym_O6J3MUC4KJEDMNJLCC5Z3G5LTC5IHVL4PW7F6QI+0x8>)
    85de:	7008      	strb	r0, [r1, #0]
    85e0:	4770      	bx	lr
    85e2:	0000      	.short	0x0000
    85e4:	20000148 	.word	0x20000148

000085e8 <sym_VZU4MLS2BZIZVCMAEOYQRASTSKMJXHSO6FAK2JA>:
    85e8:	4908      	ldr	r1, [pc, #32]	; (860c <sym_VZU4MLS2BZIZVCMAEOYQRASTSKMJXHSO6FAK2JA+0x24>)
    85ea:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    85ee:	fbb1 f1f2 	udiv	r1, r1, r2
    85f2:	b510      	push	{r4, lr}
    85f4:	f501 7125 	add.w	r1, r1, #660	; 0x294
    85f8:	f006 fd0e 	bl	f018 <sym_NEHMDBQBGZXV6OFKIS4NBQDVMDAPMSPSGUQZB7A>
    85fc:	f640 0148 	movw	r1, #2120	; 0x848
    8600:	4288      	cmp	r0, r1
    8602:	d300      	bcc.n	8606 <sym_VZU4MLS2BZIZVCMAEOYQRASTSKMJXHSO6FAK2JA+0x1e>
    8604:	4608      	mov	r0, r1
    8606:	b280      	uxth	r0, r0
    8608:	bd10      	pop	{r4, pc}
    860a:	0000      	.short	0x0000
    860c:	0001527d 	.word	0x0001527d

00008610 <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY>:
    8610:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8614:	4c10      	ldr	r4, [pc, #64]	; (8658 <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY+0x48>)
    8616:	e9d4 5701 	ldrd	r5, r7, [r4, #4]
    861a:	f003 fbdd 	bl	bdd8 <sym_GI7KSEEMTJQ7HR2XTQJ6A3EAB54YYLMWKNL2RBA>
    861e:	4606      	mov	r6, r0
    8620:	7820      	ldrb	r0, [r4, #0]
    8622:	b128      	cbz	r0, 8630 <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY+0x20>
    8624:	4632      	mov	r2, r6
    8626:	4639      	mov	r1, r7
    8628:	4628      	mov	r0, r5
    862a:	f005 ff83 	bl	e534 <sym_75VOI5ZNFW3OXMHUCY2QF6IZX2BBZSQKA7XVCPQ>
    862e:	4605      	mov	r5, r0
    8630:	6860      	ldr	r0, [r4, #4]
    8632:	4285      	cmp	r5, r0
    8634:	d005      	beq.n	8642 <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY+0x32>
    8636:	68e1      	ldr	r1, [r4, #12]
    8638:	1a28      	subs	r0, r5, r0
    863a:	4408      	add	r0, r1
    863c:	60e0      	str	r0, [r4, #12]
    863e:	f7fb f8f7 	bl	3830 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY>
    8642:	6065      	str	r5, [r4, #4]
    8644:	42ae      	cmp	r6, r5
    8646:	d801      	bhi.n	864c <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY+0x3c>
    8648:	7860      	ldrb	r0, [r4, #1]
    864a:	b110      	cbz	r0, 8652 <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY+0x42>
    864c:	2000      	movs	r0, #0
    864e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8652:	2001      	movs	r0, #1
    8654:	e7fb      	b.n	864e <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY+0x3e>
    8656:	0000      	.short	0x0000
    8658:	20000148 	.word	0x20000148

0000865c <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI>:
    865c:	b510      	push	{r4, lr}
    865e:	4604      	mov	r4, r0
    8660:	2906      	cmp	r1, #6
    8662:	d22e      	bcs.n	86c2 <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI+0x66>
    8664:	e8df f001 	tbb	[pc, r1]
    8668:	14031105 	.word	0x14031105
    866c:	2815      	.short	0x2815
    866e:	2100      	movs	r1, #0
    8670:	e006      	b.n	8680 <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI+0x24>
    8672:	f8d4 0254 	ldr.w	r0, [r4, #596]	; 0x254
    8676:	b110      	cbz	r0, 867e <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI+0x22>
    8678:	4620      	mov	r0, r4
    867a:	f007 f922 	bl	f8c2 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x218>
    867e:	2101      	movs	r1, #1
    8680:	4620      	mov	r0, r4
    8682:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    8686:	f000 b8fb 	b.w	8880 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1b0>
    868a:	2003      	movs	r0, #3
    868c:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
    8690:	bd10      	pop	{r4, pc}
    8692:	f003 fba7 	bl	bde4 <sym_YKV5VFBUMD7K2LRWZ6WWYBEL5ESMQ4SDYYBDIPI>
    8696:	f8c4 0254 	str.w	r0, [r4, #596]	; 0x254
    869a:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    869e:	f003 fc65 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    86a2:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
    86a6:	1a09      	subs	r1, r1, r0
    86a8:	4808      	ldr	r0, [pc, #32]	; (86cc <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI+0x70>)
    86aa:	6842      	ldr	r2, [r0, #4]
    86ac:	440a      	add	r2, r1
    86ae:	6042      	str	r2, [r0, #4]
    86b0:	6882      	ldr	r2, [r0, #8]
    86b2:	4411      	add	r1, r2
    86b4:	6081      	str	r1, [r0, #8]
    86b6:	bd10      	pop	{r4, pc}
    86b8:	4620      	mov	r0, r4
    86ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    86be:	f007 b8eb 	b.w	f898 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1ee>
    86c2:	f240 715b 	movw	r1, #1883	; 0x75b
    86c6:	2030      	movs	r0, #48	; 0x30
    86c8:	f7fc fd44 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    86cc:	20000148 	.word	0x20000148

000086d0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ>:
    86d0:	b570      	push	{r4, r5, r6, lr}
    86d2:	460c      	mov	r4, r1
    86d4:	4605      	mov	r5, r0
    86d6:	b112      	cbz	r2, 86de <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xe>
    86d8:	f240 7185 	movw	r1, #1925	; 0x785
    86dc:	e010      	b.n	8700 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x30>
    86de:	f003 fb7b 	bl	bdd8 <sym_GI7KSEEMTJQ7HR2XTQJ6A3EAB54YYLMWKNL2RBA>
    86e2:	4601      	mov	r1, r0
    86e4:	2200      	movs	r2, #0
    86e6:	4620      	mov	r0, r4
    86e8:	f007 f9cc 	bl	fa84 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3da>
    86ec:	f894 00c0 	ldrb.w	r0, [r4, #192]	; 0xc0
    86f0:	462a      	mov	r2, r5
    86f2:	4905      	ldr	r1, [pc, #20]	; (8708 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x38>)
    86f4:	f7fa fe5a 	bl	33ac <sym_MLZNDMDYRI6WNTNQ4RIQGPD423CK7RT4YVI5CAI>
    86f8:	2800      	cmp	r0, #0
    86fa:	d104      	bne.n	8706 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x36>
    86fc:	f240 716e 	movw	r1, #1902	; 0x76e
    8700:	2030      	movs	r0, #48	; 0x30
    8702:	f7fc fd27 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    8706:	bd70      	pop	{r4, r5, r6, pc}
    8708:	0000fbbd 	.word	0x0000fbbd
    870c:	b510      	push	{r4, lr}
    870e:	280c      	cmp	r0, #12
    8710:	d304      	bcc.n	871c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4c>
    8712:	f44f 7157 	mov.w	r1, #860	; 0x35c
    8716:	2006      	movs	r0, #6
    8718:	f7fc fd1c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    871c:	4901      	ldr	r1, [pc, #4]	; (8724 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x54>)
    871e:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
    8722:	bd10      	pop	{r4, pc}
    8724:	0000fde0 	.word	0x0000fde0
    8728:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
    872a:	4c18      	ldr	r4, [pc, #96]	; (878c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xbc>)
    872c:	2001      	movs	r0, #1
    872e:	7060      	strb	r0, [r4, #1]
    8730:	f64f 75ff 	movw	r5, #65535	; 0xffff
    8734:	e00b      	b.n	874e <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x7e>
    8736:	2100      	movs	r1, #0
    8738:	f005 fc57 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
    873c:	0006      	movs	r6, r0
    873e:	d010      	beq.n	8762 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x92>
    8740:	f896 024c 	ldrb.w	r0, [r6, #588]	; 0x24c
    8744:	f7fa fe64 	bl	3410 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI>
    8748:	4630      	mov	r0, r6
    874a:	f007 f98e 	bl	fa6a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3c0>
    874e:	4669      	mov	r1, sp
    8750:	2000      	movs	r0, #0
    8752:	f005 fc54 	bl	dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>
    8756:	b180      	cbz	r0, 877a <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xaa>
    8758:	f240 1103 	movw	r1, #259	; 0x103
    875c:	2030      	movs	r0, #48	; 0x30
    875e:	f7fc fcf9 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    8762:	f240 1123 	movw	r1, #291	; 0x123
    8766:	e7f9      	b.n	875c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x8c>
    8768:	9802      	ldr	r0, [sp, #8]
    876a:	b130      	cbz	r0, 877a <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xaa>
    876c:	f890 1204 	ldrb.w	r1, [r0, #516]	; 0x204
    8770:	b119      	cbz	r1, 877a <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xaa>
    8772:	8800      	ldrh	r0, [r0, #0]
    8774:	42a8      	cmp	r0, r5
    8776:	d1de      	bne.n	8736 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x66>
    8778:	e004      	b.n	8784 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xb4>
    877a:	4668      	mov	r0, sp
    877c:	f7fc ff2e 	bl	55dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>
    8780:	2800      	cmp	r0, #0
    8782:	d0f1      	beq.n	8768 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x98>
    8784:	2000      	movs	r0, #0
    8786:	7060      	strb	r0, [r4, #1]
    8788:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    878a:	0000      	.short	0x0000
    878c:	20000148 	.word	0x20000148
    8790:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8794:	4604      	mov	r4, r0
    8796:	4839      	ldr	r0, [pc, #228]	; (887c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1ac>)
    8798:	461e      	mov	r6, r3
    879a:	4690      	mov	r8, r2
    879c:	7880      	ldrb	r0, [r0, #2]
    879e:	4689      	mov	r9, r1
    87a0:	2500      	movs	r5, #0
    87a2:	2800      	cmp	r0, #0
    87a4:	d063      	beq.n	886e <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x19e>
    87a6:	f7fc f931 	bl	4a0c <sym_4CZSFTTT34WDYFZKE2NSCSVSYLPHLZYN7QUTGHY>
    87aa:	b3e0      	cbz	r0, 8826 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x156>
    87ac:	f8b4 01f0 	ldrh.w	r0, [r4, #496]	; 0x1f0
    87b0:	2802      	cmp	r0, #2
    87b2:	d35c      	bcc.n	886e <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x19e>
    87b4:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    87b8:	2802      	cmp	r0, #2
    87ba:	d058      	beq.n	886e <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x19e>
    87bc:	f894 021a 	ldrb.w	r0, [r4, #538]	; 0x21a
    87c0:	bb88      	cbnz	r0, 8826 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x156>
    87c2:	f894 01c7 	ldrb.w	r0, [r4, #455]	; 0x1c7
    87c6:	f7ff ffa1 	bl	870c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3c>
    87ca:	f500 60c8 	add.w	r0, r0, #1600	; 0x640
    87ce:	b281      	uxth	r1, r0
    87d0:	8031      	strh	r1, [r6, #0]
    87d2:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    87d6:	2700      	movs	r7, #0
    87d8:	2801      	cmp	r0, #1
    87da:	d00d      	beq.n	87f8 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x128>
    87dc:	6920      	ldr	r0, [r4, #16]
    87de:	f004 face 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    87e2:	f8b4 21de 	ldrh.w	r2, [r4, #478]	; 0x1de
    87e6:	4442      	add	r2, r8
    87e8:	eba2 0109 	sub.w	r1, r2, r9
    87ec:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
    87f0:	1a82      	subs	r2, r0, r2
    87f2:	fb01 7502 	mla	r5, r1, r2, r7
    87f6:	e035      	b.n	8864 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x194>
    87f8:	f894 008a 	ldrb.w	r0, [r4, #138]	; 0x8a
    87fc:	2803      	cmp	r0, #3
    87fe:	d039      	beq.n	8874 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1a4>
    8800:	2101      	movs	r1, #1
    8802:	2000      	movs	r0, #0
    8804:	f005 ff51 	bl	e6aa <sym_QOK2KYWK62QNZBQRPK2GPAU2IEJXSELK32IAUUA>
    8808:	6a61      	ldr	r1, [r4, #36]	; 0x24
    880a:	1847      	adds	r7, r0, r1
    880c:	8831      	ldrh	r1, [r6, #0]
    880e:	f8d4 01fc 	ldr.w	r0, [r4, #508]	; 0x1fc
    8812:	f004 fab4 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    8816:	f8d4 21f8 	ldr.w	r2, [r4, #504]	; 0x1f8
    881a:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
    881e:	1a82      	subs	r2, r0, r2
    8820:	fb01 5502 	mla	r5, r1, r2, r5
    8824:	e000      	b.n	8828 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x158>
    8826:	e022      	b.n	886e <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x19e>
    8828:	f8c4 01f8 	str.w	r0, [r4, #504]	; 0x1f8
    882c:	8831      	ldrh	r1, [r6, #0]
    882e:	4638      	mov	r0, r7
    8830:	f004 faa5 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    8834:	f8d4 1208 	ldr.w	r1, [r4, #520]	; 0x208
    8838:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208
    883c:	1a41      	subs	r1, r0, r1
    883e:	440d      	add	r5, r1
    8840:	8831      	ldrh	r1, [r6, #0]
    8842:	6920      	ldr	r0, [r4, #16]
    8844:	f004 fa9b 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    8848:	f8b4 21de 	ldrh.w	r2, [r4, #478]	; 0x1de
    884c:	4442      	add	r2, r8
    884e:	eba2 0109 	sub.w	r1, r2, r9
    8852:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    8856:	1a89      	subs	r1, r1, r2
    8858:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
    885c:	1a82      	subs	r2, r0, r2
    885e:	1e49      	subs	r1, r1, #1
    8860:	fb01 5502 	mla	r5, r1, r2, r5
    8864:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
    8868:	2001      	movs	r0, #1
    886a:	f884 021a 	strb.w	r0, [r4, #538]	; 0x21a
    886e:	4628      	mov	r0, r5
    8870:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8874:	f8d4 01fc 	ldr.w	r0, [r4, #508]	; 0x1fc
    8878:	e7c6      	b.n	8808 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x138>
    887a:	0000      	.short	0x0000
    887c:	20000148 	.word	0x20000148
    8880:	b538      	push	{r3, r4, r5, lr}
    8882:	2500      	movs	r5, #0
    8884:	4604      	mov	r4, r0
    8886:	2901      	cmp	r1, #1
    8888:	d102      	bne.n	8890 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1c0>
    888a:	4810      	ldr	r0, [pc, #64]	; (88cc <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1fc>)
    888c:	7840      	ldrb	r0, [r0, #1]
    888e:	b170      	cbz	r0, 88ae <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1de>
    8890:	2004      	movs	r0, #4
    8892:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
    8896:	bf00      	nop
    8898:	f007 f80c 	bl	f8b4 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x20a>
    889c:	f8a4 524a 	strh.w	r5, [r4, #586]	; 0x24a
    88a0:	f8b4 007c 	ldrh.w	r0, [r4, #124]	; 0x7c
    88a4:	f8a4 0216 	strh.w	r0, [r4, #534]	; 0x216
    88a8:	f884 5219 	strb.w	r5, [r4, #537]	; 0x219
    88ac:	bd38      	pop	{r3, r4, r5, pc}
    88ae:	9500      	str	r5, [sp, #0]
    88b0:	f8b4 11cc 	ldrh.w	r1, [r4, #460]	; 0x1cc
    88b4:	2301      	movs	r3, #1
    88b6:	2200      	movs	r2, #0
    88b8:	4620      	mov	r0, r4
    88ba:	f000 f809 	bl	88d0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x200>
    88be:	2800      	cmp	r0, #0
    88c0:	d0ea      	beq.n	8898 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x1c8>
    88c2:	f240 61cf 	movw	r1, #1743	; 0x6cf
    88c6:	2030      	movs	r0, #48	; 0x30
    88c8:	f7fc fc44 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    88cc:	20000148 	.word	0x20000148
    88d0:	e92d 4fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    88d4:	b08b      	sub	sp, #44	; 0x2c
    88d6:	4604      	mov	r4, r0
    88d8:	f890 006f 	ldrb.w	r0, [r0, #111]	; 0x6f
    88dc:	4699      	mov	r9, r3
    88de:	460f      	mov	r7, r1
    88e0:	9307      	str	r3, [sp, #28]
    88e2:	9005      	str	r0, [sp, #20]
    88e4:	f008 f9de 	bl	10ca4 <sym_R2552DB5ZKNDWW24PBGEV77VCDBC44WVAYRCUXQ>
    88e8:	4605      	mov	r5, r0
    88ea:	f894 01c7 	ldrb.w	r0, [r4, #455]	; 0x1c7
    88ee:	f7ff ff0d 	bl	870c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3c>
    88f2:	4428      	add	r0, r5
    88f4:	f8ad 0004 	strh.w	r0, [sp, #4]
    88f8:	f894 0086 	ldrb.w	r0, [r4, #134]	; 0x86
    88fc:	280d      	cmp	r0, #13
    88fe:	d004      	beq.n	890a <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x23a>
    8900:	2000      	movs	r0, #0
    8902:	9008      	str	r0, [sp, #32]
    8904:	980d      	ldr	r0, [sp, #52]	; 0x34
    8906:	b110      	cbz	r0, 890e <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x23e>
    8908:	e02e      	b.n	8968 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x298>
    890a:	2001      	movs	r0, #1
    890c:	e7f9      	b.n	8902 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x232>
    890e:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    8912:	2803      	cmp	r0, #3
    8914:	d128      	bne.n	8968 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x298>
    8916:	9808      	ldr	r0, [sp, #32]
    8918:	b330      	cbz	r0, 8968 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x298>
    891a:	f8b4 0274 	ldrh.w	r0, [r4, #628]	; 0x274
    891e:	42b8      	cmp	r0, r7
    8920:	d122      	bne.n	8968 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x298>
    8922:	f8d4 020c 	ldr.w	r0, [r4, #524]	; 0x20c
    8926:	f8c4 01f8 	str.w	r0, [r4, #504]	; 0x1f8
    892a:	6920      	ldr	r0, [r4, #16]
    892c:	f8c4 01fc 	str.w	r0, [r4, #508]	; 0x1fc
    8930:	f8b4 024a 	ldrh.w	r0, [r4, #586]	; 0x24a
    8934:	f8b4 11de 	ldrh.w	r1, [r4, #478]	; 0x1de
    8938:	4408      	add	r0, r1
    893a:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
    893e:	4620      	mov	r0, r4
    8940:	f007 fa6e 	bl	fe20 <sym_HT64RIVISXSWFJE3LL26YHKQRTRRXKVEDBUUUOQ>
    8944:	f8d4 0278 	ldr.w	r0, [r4, #632]	; 0x278
    8948:	6260      	str	r0, [r4, #36]	; 0x24
    894a:	f8b4 0276 	ldrh.w	r0, [r4, #630]	; 0x276
    894e:	8420      	strh	r0, [r4, #32]
    8950:	f8d4 027c 	ldr.w	r0, [r4, #636]	; 0x27c
    8954:	6120      	str	r0, [r4, #16]
    8956:	f8b4 0280 	ldrh.w	r0, [r4, #640]	; 0x280
    895a:	8320      	strh	r0, [r4, #24]
    895c:	f8b4 0282 	ldrh.w	r0, [r4, #642]	; 0x282
    8960:	8360      	strh	r0, [r4, #26]
    8962:	2002      	movs	r0, #2
    8964:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
    8968:	f8b4 007c 	ldrh.w	r0, [r4, #124]	; 0x7c
    896c:	f504 7508 	add.w	r5, r4, #544	; 0x220
    8970:	1a38      	subs	r0, r7, r0
    8972:	fa0f fa80 	sxth.w	sl, r0
    8976:	f8b4 0248 	ldrh.w	r0, [r4, #584]	; 0x248
    897a:	1a38      	subs	r0, r7, r0
    897c:	fa0f f880 	sxth.w	r8, r0
    8980:	f1b8 0f00 	cmp.w	r8, #0
    8984:	da08      	bge.n	8998 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x2c8>
    8986:	f8d4 0238 	ldr.w	r0, [r4, #568]	; 0x238
    898a:	f8d4 123c 	ldr.w	r1, [r4, #572]	; 0x23c
    898e:	46d0      	mov	r8, sl
    8990:	e9c4 0190 	strd	r0, r1, [r4, #576]	; 0x240
    8994:	2001      	movs	r0, #1
    8996:	9007      	str	r0, [sp, #28]
    8998:	ab01      	add	r3, sp, #4
    899a:	4652      	mov	r2, sl
    899c:	4641      	mov	r1, r8
    899e:	4620      	mov	r0, r4
    89a0:	f7ff fef6 	bl	8790 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0xc0>
    89a4:	9004      	str	r0, [sp, #16]
    89a6:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    89aa:	f8df b334 	ldr.w	fp, [pc, #820]	; 8ce0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x610>
    89ae:	b140      	cbz	r0, 89c2 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x2f2>
    89b0:	2801      	cmp	r0, #1
    89b2:	d07d      	beq.n	8ab0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3e0>
    89b4:	2802      	cmp	r0, #2
    89b6:	d051      	beq.n	8a5c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x38c>
    89b8:	2803      	cmp	r0, #3
    89ba:	d07a      	beq.n	8ab2 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3e2>
    89bc:	f240 514b 	movw	r1, #1355	; 0x54b
    89c0:	e18a      	b.n	8cd8 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x608>
    89c2:	2101      	movs	r1, #1
    89c4:	2000      	movs	r0, #0
    89c6:	f005 fe70 	bl	e6aa <sym_QOK2KYWK62QNZBQRPK2GPAU2IEJXSELK32IAUUA>
    89ca:	4606      	mov	r6, r0
    89cc:	6a60      	ldr	r0, [r4, #36]	; 0x24
    89ce:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    89d2:	4430      	add	r0, r6
    89d4:	f004 f9d3 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    89d8:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208
    89dc:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    89e0:	6920      	ldr	r0, [r4, #16]
    89e2:	f004 f9cc 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    89e6:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
    89ea:	a907      	add	r1, sp, #28
    89ec:	a806      	add	r0, sp, #24
    89ee:	f003 f95b 	bl	bca8 <sym_LSYZDZOMTD6BKKRX25HIBNLFKSFDXBS3PS4UKOY>
    89f2:	e9d4 0190 	ldrd	r0, r1, [r4, #576]	; 0x240
    89f6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    89fa:	f7fa ffe5 	bl	39c8 <sym_ORUJDMUJV7RZIFXM3X5KLRROPKJ7VPLJ65JMLRQ>
    89fe:	4682      	mov	sl, r0
    8a00:	4620      	mov	r0, r4
    8a02:	f006 ff49 	bl	f898 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1ee>
    8a06:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8a0a:	f8d4 8250 	ldr.w	r8, [r4, #592]	; 0x250
    8a0e:	f003 fad9 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    8a12:	f24a 31a1 	movw	r1, #41889	; 0xa3a1
    8a16:	4401      	add	r1, r0
    8a18:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    8a1c:	fbb1 f0f0 	udiv	r0, r1, r0
    8a20:	6a61      	ldr	r1, [r4, #36]	; 0x24
    8a22:	f8d4 2208 	ldr.w	r2, [r4, #520]	; 0x208
    8a26:	4431      	add	r1, r6
    8a28:	1a08      	subs	r0, r1, r0
    8a2a:	1a81      	subs	r1, r0, r2
    8a2c:	4441      	add	r1, r8
    8a2e:	3920      	subs	r1, #32
    8a30:	eba1 060a 	sub.w	r6, r1, sl
    8a34:	0050      	lsls	r0, r2, #1
    8a36:	8c21      	ldrh	r1, [r4, #32]
    8a38:	3060      	adds	r0, #96	; 0x60
    8a3a:	4401      	add	r1, r0
    8a3c:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8a40:	f006 ff9a 	bl	f978 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2ce>
    8a44:	3022      	adds	r0, #34	; 0x22
    8a46:	f8cb 0010 	str.w	r0, [fp, #16]
    8a4a:	f8d4 0250 	ldr.w	r0, [r4, #592]	; 0x250
    8a4e:	1a30      	subs	r0, r6, r0
    8a50:	f5b0 7fde 	cmp.w	r0, #444	; 0x1bc
    8a54:	d258      	bcs.n	8b08 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x438>
    8a56:	f240 41e4 	movw	r1, #1252	; 0x4e4
    8a5a:	e13d      	b.n	8cd8 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x608>
    8a5c:	6a61      	ldr	r1, [r4, #36]	; 0x24
    8a5e:	f8d4 01fc 	ldr.w	r0, [r4, #508]	; 0x1fc
    8a62:	4408      	add	r0, r1
    8a64:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    8a68:	f004 f989 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    8a6c:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208
    8a70:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    8a74:	6920      	ldr	r0, [r4, #16]
    8a76:	f004 f982 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    8a7a:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
    8a7e:	4620      	mov	r0, r4
    8a80:	f006 ff0a 	bl	f898 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1ee>
    8a84:	f8b4 01de 	ldrh.w	r0, [r4, #478]	; 0x1de
    8a88:	bb10      	cbnz	r0, 8ad0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x400>
    8a8a:	f1b9 0f00 	cmp.w	r9, #0
    8a8e:	d01f      	beq.n	8ad0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x400>
    8a90:	f894 806f 	ldrb.w	r8, [r4, #111]	; 0x6f
    8a94:	4640      	mov	r0, r8
    8a96:	f003 fa95 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    8a9a:	f24a 31a1 	movw	r1, #41889	; 0xa3a1
    8a9e:	4401      	add	r1, r0
    8aa0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    8aa4:	fbb1 f0f0 	udiv	r0, r1, r0
    8aa8:	f8d4 1208 	ldr.w	r1, [r4, #520]	; 0x208
    8aac:	4408      	add	r0, r1
    8aae:	e001      	b.n	8ab4 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3e4>
    8ab0:	e02b      	b.n	8b0a <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x43a>
    8ab2:	e047      	b.n	8b44 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x474>
    8ab4:	6a62      	ldr	r2, [r4, #36]	; 0x24
    8ab6:	f8d4 11fc 	ldr.w	r1, [r4, #508]	; 0x1fc
    8aba:	4411      	add	r1, r2
    8abc:	1a0e      	subs	r6, r1, r0
    8abe:	4640      	mov	r0, r8
    8ac0:	f003 fa54 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    8ac4:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
    8ac8:	1a08      	subs	r0, r1, r0
    8aca:	4406      	add	r6, r0
    8acc:	3e20      	subs	r6, #32
    8ace:	e006      	b.n	8ade <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x40e>
    8ad0:	6a61      	ldr	r1, [r4, #36]	; 0x24
    8ad2:	f8d4 01fc 	ldr.w	r0, [r4, #508]	; 0x1fc
    8ad6:	4408      	add	r0, r1
    8ad8:	f8d4 1208 	ldr.w	r1, [r4, #520]	; 0x208
    8adc:	1a46      	subs	r6, r0, r1
    8ade:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    8ae2:	f8d4 11f8 	ldr.w	r1, [r4, #504]	; 0x1f8
    8ae6:	f8d4 0208 	ldr.w	r0, [r4, #520]	; 0x208
    8aea:	fb01 0002 	mla	r0, r1, r2, r0
    8aee:	0040      	lsls	r0, r0, #1
    8af0:	8c21      	ldrh	r1, [r4, #32]
    8af2:	3060      	adds	r0, #96	; 0x60
    8af4:	4401      	add	r1, r0
    8af6:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8afa:	f006 ff3d 	bl	f978 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2ce>
    8afe:	f8cb 0010 	str.w	r0, [fp, #16]
    8b02:	2001      	movs	r0, #1
    8b04:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
    8b08:	e061      	b.n	8bce <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4fe>
    8b0a:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
    8b0e:	6920      	ldr	r0, [r4, #16]
    8b10:	f8b4 11de 	ldrh.w	r1, [r4, #478]	; 0x1de
    8b14:	1a86      	subs	r6, r0, r2
    8b16:	eb01 000a 	add.w	r0, r1, sl
    8b1a:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
    8b1e:	f8d4 c1f8 	ldr.w	ip, [r4, #504]	; 0x1f8
    8b22:	1a40      	subs	r0, r0, r1
    8b24:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
    8b28:	1e40      	subs	r0, r0, #1
    8b2a:	fb0c 3101 	mla	r1, ip, r1, r3
    8b2e:	fb00 1002 	mla	r0, r0, r2, r1
    8b32:	0040      	lsls	r0, r0, #1
    8b34:	8c21      	ldrh	r1, [r4, #32]
    8b36:	3060      	adds	r0, #96	; 0x60
    8b38:	4401      	add	r1, r0
    8b3a:	fb06 f608 	mul.w	r6, r6, r8
    8b3e:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8b42:	e040      	b.n	8bc6 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4f6>
    8b44:	6920      	ldr	r0, [r4, #16]
    8b46:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
    8b4a:	fb00 f008 	mul.w	r0, r0, r8
    8b4e:	fb08 0611 	mls	r6, r8, r1, r0
    8b52:	f894 0085 	ldrb.w	r0, [r4, #133]	; 0x85
    8b56:	2824      	cmp	r0, #36	; 0x24
    8b58:	d003      	beq.n	8b62 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x492>
    8b5a:	f894 0086 	ldrb.w	r0, [r4, #134]	; 0x86
    8b5e:	2824      	cmp	r0, #36	; 0x24
    8b60:	d109      	bne.n	8b76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4a6>
    8b62:	f8b4 0274 	ldrh.w	r0, [r4, #628]	; 0x274
    8b66:	1a38      	subs	r0, r7, r0
    8b68:	b200      	sxth	r0, r0
    8b6a:	2800      	cmp	r0, #0
    8b6c:	db03      	blt.n	8b76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4a6>
    8b6e:	f894 0277 	ldrb.w	r0, [r4, #631]	; 0x277
    8b72:	b100      	cbz	r0, 8b76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4a6>
    8b74:	9005      	str	r0, [sp, #20]
    8b76:	9807      	ldr	r0, [sp, #28]
    8b78:	b1d8      	cbz	r0, 8bb2 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4e2>
    8b7a:	f8b4 01de 	ldrh.w	r0, [r4, #478]	; 0x1de
    8b7e:	b9c0      	cbnz	r0, 8bb2 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x4e2>
    8b80:	f8d4 0254 	ldr.w	r0, [r4, #596]	; 0x254
    8b84:	2800      	cmp	r0, #0
    8b86:	d07d      	beq.n	8c84 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5b4>
    8b88:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8b8c:	f003 fa1a 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    8b90:	f24a 31a1 	movw	r1, #41889	; 0xa3a1
    8b94:	4401      	add	r1, r0
    8b96:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    8b9a:	fbb1 f0f0 	udiv	r0, r1, r0
    8b9e:	1a36      	subs	r6, r6, r0
    8ba0:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8ba4:	f003 f9e2 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    8ba8:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
    8bac:	1a08      	subs	r0, r1, r0
    8bae:	4406      	add	r6, r0
    8bb0:	3e20      	subs	r6, #32
    8bb2:	f8b4 11de 	ldrh.w	r1, [r4, #478]	; 0x1de
    8bb6:	eb01 000a 	add.w	r0, r1, sl
    8bba:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
    8bbe:	4348      	muls	r0, r1
    8bc0:	0041      	lsls	r1, r0, #1
    8bc2:	3160      	adds	r1, #96	; 0x60
    8bc4:	9805      	ldr	r0, [sp, #20]
    8bc6:	f006 fed7 	bl	f978 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2ce>
    8bca:	f8cb 0010 	str.w	r0, [fp, #16]
    8bce:	9804      	ldr	r0, [sp, #16]
    8bd0:	f8db 2010 	ldr.w	r2, [fp, #16]
    8bd4:	1a31      	subs	r1, r6, r0
    8bd6:	f8d4 620c 	ldr.w	r6, [r4, #524]	; 0x20c
    8bda:	6920      	ldr	r0, [r4, #16]
    8bdc:	1b80      	subs	r0, r0, r6
    8bde:	f2a0 2046 	subw	r0, r0, #582	; 0x246
    8be2:	f8cb 0014 	str.w	r0, [fp, #20]
    8be6:	4282      	cmp	r2, r0
    8be8:	d800      	bhi.n	8bec <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x51c>
    8bea:	4610      	mov	r0, r2
    8bec:	f8c4 01d8 	str.w	r0, [r4, #472]	; 0x1d8
    8bf0:	2600      	movs	r6, #0
    8bf2:	702e      	strb	r6, [r5, #0]
    8bf4:	2064      	movs	r0, #100	; 0x64
    8bf6:	8128      	strh	r0, [r5, #8]
    8bf8:	e9d4 2090 	ldrd	r2, r0, [r4, #576]	; 0x240
    8bfc:	1851      	adds	r1, r2, r1
    8bfe:	4170      	adcs	r0, r6
    8c00:	e9c5 1004 	strd	r1, r0, [r5, #16]
    8c04:	f104 0030 	add.w	r0, r4, #48	; 0x30
    8c08:	f006 f9d7 	bl	efba <sym_2T6ENJKRE7MWBMC42J5L6S3EMUNPYUXCPAHD23A>
    8c0c:	f8d4 11d8 	ldr.w	r1, [r4, #472]	; 0x1d8
    8c10:	4408      	add	r0, r1
    8c12:	6068      	str	r0, [r5, #4]
    8c14:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
    8c18:	e9c4 0190 	strd	r0, r1, [r4, #576]	; 0x240
    8c1c:	f8a4 7248 	strh.w	r7, [r4, #584]	; 0x248
    8c20:	72ae      	strb	r6, [r5, #10]
    8c22:	f8b4 01c8 	ldrh.w	r0, [r4, #456]	; 0x1c8
    8c26:	1bc0      	subs	r0, r0, r7
    8c28:	b200      	sxth	r0, r0
    8c2a:	2800      	cmp	r0, #0
    8c2c:	dd01      	ble.n	8c32 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x562>
    8c2e:	2002      	movs	r0, #2
    8c30:	72a8      	strb	r0, [r5, #10]
    8c32:	9808      	ldr	r0, [sp, #32]
    8c34:	b338      	cbz	r0, 8c86 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5b6>
    8c36:	f1b9 0f00 	cmp.w	r9, #0
    8c3a:	d01c      	beq.n	8c76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5a6>
    8c3c:	f8b4 11f0 	ldrh.w	r1, [r4, #496]	; 0x1f0
    8c40:	b3f1      	cbz	r1, 8cc0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5f0>
    8c42:	f8b4 01f2 	ldrh.w	r0, [r4, #498]	; 0x1f2
    8c46:	bf00      	nop
    8c48:	f8a4 01f2 	strh.w	r0, [r4, #498]	; 0x1f2
    8c4c:	f894 21f4 	ldrb.w	r2, [r4, #500]	; 0x1f4
    8c50:	1c40      	adds	r0, r0, #1
    8c52:	4342      	muls	r2, r0
    8c54:	428a      	cmp	r2, r1
    8c56:	d20e      	bcs.n	8c76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5a6>
    8c58:	7aa8      	ldrb	r0, [r5, #10]
    8c5a:	b160      	cbz	r0, 8c76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5a6>
    8c5c:	72ae      	strb	r6, [r5, #10]
    8c5e:	f8b4 01f2 	ldrh.w	r0, [r4, #498]	; 0x1f2
    8c62:	1c40      	adds	r0, r0, #1
    8c64:	f8a4 01f2 	strh.w	r0, [r4, #498]	; 0x1f2
    8c68:	f7fe fce4 	bl	7634 <sym_K5GMJMBHBYPRCUIWKNEXGPSNQEZKEMBAP4JWHBQ>
    8c6c:	f000 0007 	and.w	r0, r0, #7
    8c70:	1c40      	adds	r0, r0, #1
    8c72:	f884 01f4 	strb.w	r0, [r4, #500]	; 0x1f4
    8c76:	f894 024c 	ldrb.w	r0, [r4, #588]	; 0x24c
    8c7a:	4629      	mov	r1, r5
    8c7c:	f006 fe8e 	bl	f99c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f2>
    8c80:	b340      	cbz	r0, 8cd4 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x604>
    8c82:	e001      	b.n	8c88 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5b8>
    8c84:	e009      	b.n	8c9a <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5ca>
    8c86:	e00b      	b.n	8ca0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5d0>
    8c88:	980d      	ldr	r0, [sp, #52]	; 0x34
    8c8a:	f080 0001 	eor.w	r0, r0, #1
    8c8e:	f884 0218 	strb.w	r0, [r4, #536]	; 0x218
    8c92:	2000      	movs	r0, #0
    8c94:	b00f      	add	sp, #60	; 0x3c
    8c96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8c9a:	f240 5136 	movw	r1, #1334	; 0x536
    8c9e:	e01b      	b.n	8cd8 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x608>
    8ca0:	f1b9 0f00 	cmp.w	r9, #0
    8ca4:	d1ca      	bne.n	8c3c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x56c>
    8ca6:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    8caa:	2800      	cmp	r0, #0
    8cac:	d0e3      	beq.n	8c76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5a6>
    8cae:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
    8cb2:	6920      	ldr	r0, [r4, #16]
    8cb4:	1a41      	subs	r1, r0, r1
    8cb6:	4628      	mov	r0, r5
    8cb8:	f005 fd09 	bl	e6ce <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY>
    8cbc:	0400      	lsls	r0, r0, #16
    8cbe:	e000      	b.n	8cc2 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5f2>
    8cc0:	e006      	b.n	8cd0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x600>
    8cc2:	0c00      	lsrs	r0, r0, #16
    8cc4:	d0d7      	beq.n	8c76 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5a6>
    8cc6:	9918      	ldr	r1, [sp, #96]	; 0x60
    8cc8:	b101      	cbz	r1, 8ccc <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5fc>
    8cca:	8008      	strh	r0, [r1, #0]
    8ccc:	2001      	movs	r0, #1
    8cce:	e7e1      	b.n	8c94 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x5c4>
    8cd0:	2000      	movs	r0, #0
    8cd2:	e7b9      	b.n	8c48 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x578>
    8cd4:	f240 5194 	movw	r1, #1428	; 0x594
    8cd8:	2030      	movs	r0, #48	; 0x30
    8cda:	f7fc fa3b 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    8cde:	0000      	.short	0x0000
    8ce0:	20000148 	.word	0x20000148
    8ce4:	b570      	push	{r4, r5, r6, lr}
    8ce6:	4604      	mov	r4, r0
    8ce8:	f004 f815 	bl	cd16 <sym_MGCUANL7Q2CUPWKYBFLWSWSNXIEEYBPZTHT2VZI>
    8cec:	2864      	cmp	r0, #100	; 0x64
    8cee:	d901      	bls.n	8cf4 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x624>
    8cf0:	4605      	mov	r5, r0
    8cf2:	e000      	b.n	8cf6 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x626>
    8cf4:	2564      	movs	r5, #100	; 0x64
    8cf6:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8cfa:	2128      	movs	r1, #40	; 0x28
    8cfc:	f006 fd3c 	bl	f778 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xce>
    8d00:	4428      	add	r0, r5
    8d02:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
    8d06:	f500 7010 	add.w	r0, r0, #576	; 0x240
    8d0a:	180e      	adds	r6, r1, r0
    8d0c:	f894 006f 	ldrb.w	r0, [r4, #111]	; 0x6f
    8d10:	2128      	movs	r1, #40	; 0x28
    8d12:	f006 fd31 	bl	f778 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xce>
    8d16:	f500 7229 	add.w	r2, r0, #676	; 0x2a4
    8d1a:	4620      	mov	r0, r4
    8d1c:	6b21      	ldr	r1, [r4, #48]	; 0x30
    8d1e:	f006 f8e9 	bl	eef4 <sym_XRSFUVJVALTQXGE7INRI3M6HEEON3PEMDM73SDI>
    8d22:	4605      	mov	r5, r0
    8d24:	4632      	mov	r2, r6
    8d26:	4620      	mov	r0, r4
    8d28:	6921      	ldr	r1, [r4, #16]
    8d2a:	f006 f8e3 	bl	eef4 <sym_XRSFUVJVALTQXGE7INRI3M6HEEON3PEMDM73SDI>
    8d2e:	4907      	ldr	r1, [pc, #28]	; (8d4c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x67c>)
    8d30:	4285      	cmp	r5, r0
    8d32:	6088      	str	r0, [r1, #8]
    8d34:	d200      	bcs.n	8d38 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x668>
    8d36:	4628      	mov	r0, r5
    8d38:	6048      	str	r0, [r1, #4]
    8d3a:	f8d4 0224 	ldr.w	r0, [r4, #548]	; 0x224
    8d3e:	f2a0 1069 	subw	r0, r0, #361	; 0x169
    8d42:	60c8      	str	r0, [r1, #12]
    8d44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    8d48:	f7fa bd72 	b.w	3830 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY>
    8d4c:	20000148 	.word	0x20000148

00008d50 <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI>:
    8d50:	4806      	ldr	r0, [pc, #24]	; (8d6c <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI+0x1c>)
    8d52:	4905      	ldr	r1, [pc, #20]	; (8d68 <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI+0x18>)
    8d54:	6501      	str	r1, [r0, #80]	; 0x50
    8d56:	4906      	ldr	r1, [pc, #24]	; (8d70 <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI+0x20>)
    8d58:	6541      	str	r1, [r0, #84]	; 0x54
    8d5a:	4807      	ldr	r0, [pc, #28]	; (8d78 <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI+0x28>)
    8d5c:	4905      	ldr	r1, [pc, #20]	; (8d74 <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI+0x24>)
    8d5e:	6501      	str	r1, [r0, #80]	; 0x50
    8d60:	4906      	ldr	r1, [pc, #24]	; (8d7c <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI+0x2c>)
    8d62:	6541      	str	r1, [r0, #84]	; 0x54
    8d64:	4770      	bx	lr
    8d66:	0000      	.short	0x0000
    8d68:	0000a171 	.word	0x0000a171
    8d6c:	20000178 	.word	0x20000178
    8d70:	0000a255 	.word	0x0000a255
    8d74:	0000a911 	.word	0x0000a911
    8d78:	20000210 	.word	0x20000210
    8d7c:	0000a941 	.word	0x0000a941

00008d80 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA>:
    8d80:	481e      	ldr	r0, [pc, #120]	; (8dfc <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x7c>)
    8d82:	491d      	ldr	r1, [pc, #116]	; (8df8 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x78>)
    8d84:	6081      	str	r1, [r0, #8]
    8d86:	491e      	ldr	r1, [pc, #120]	; (8e00 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x80>)
    8d88:	6041      	str	r1, [r0, #4]
    8d8a:	491e      	ldr	r1, [pc, #120]	; (8e04 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x84>)
    8d8c:	6001      	str	r1, [r0, #0]
    8d8e:	491e      	ldr	r1, [pc, #120]	; (8e08 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x88>)
    8d90:	6281      	str	r1, [r0, #40]	; 0x28
    8d92:	491e      	ldr	r1, [pc, #120]	; (8e0c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x8c>)
    8d94:	62c1      	str	r1, [r0, #44]	; 0x2c
    8d96:	491e      	ldr	r1, [pc, #120]	; (8e10 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x90>)
    8d98:	60c1      	str	r1, [r0, #12]
    8d9a:	491e      	ldr	r1, [pc, #120]	; (8e14 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x94>)
    8d9c:	6181      	str	r1, [r0, #24]
    8d9e:	491e      	ldr	r1, [pc, #120]	; (8e18 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x98>)
    8da0:	6301      	str	r1, [r0, #48]	; 0x30
    8da2:	491e      	ldr	r1, [pc, #120]	; (8e1c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0x9c>)
    8da4:	6201      	str	r1, [r0, #32]
    8da6:	491e      	ldr	r1, [pc, #120]	; (8e20 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xa0>)
    8da8:	64c1      	str	r1, [r0, #76]	; 0x4c
    8daa:	491e      	ldr	r1, [pc, #120]	; (8e24 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xa4>)
    8dac:	6481      	str	r1, [r0, #72]	; 0x48
    8dae:	491e      	ldr	r1, [pc, #120]	; (8e28 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xa8>)
    8db0:	6441      	str	r1, [r0, #68]	; 0x44
    8db2:	491e      	ldr	r1, [pc, #120]	; (8e2c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xac>)
    8db4:	6341      	str	r1, [r0, #52]	; 0x34
    8db6:	491e      	ldr	r1, [pc, #120]	; (8e30 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xb0>)
    8db8:	61c1      	str	r1, [r0, #28]
    8dba:	491e      	ldr	r1, [pc, #120]	; (8e34 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xb4>)
    8dbc:	6241      	str	r1, [r0, #36]	; 0x24
    8dbe:	481f      	ldr	r0, [pc, #124]	; (8e3c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xbc>)
    8dc0:	491d      	ldr	r1, [pc, #116]	; (8e38 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xb8>)
    8dc2:	6081      	str	r1, [r0, #8]
    8dc4:	491e      	ldr	r1, [pc, #120]	; (8e40 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xc0>)
    8dc6:	61c1      	str	r1, [r0, #28]
    8dc8:	491e      	ldr	r1, [pc, #120]	; (8e44 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xc4>)
    8dca:	6241      	str	r1, [r0, #36]	; 0x24
    8dcc:	491e      	ldr	r1, [pc, #120]	; (8e48 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xc8>)
    8dce:	62c1      	str	r1, [r0, #44]	; 0x2c
    8dd0:	491e      	ldr	r1, [pc, #120]	; (8e4c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xcc>)
    8dd2:	6101      	str	r1, [r0, #16]
    8dd4:	491e      	ldr	r1, [pc, #120]	; (8e50 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xd0>)
    8dd6:	6141      	str	r1, [r0, #20]
    8dd8:	491e      	ldr	r1, [pc, #120]	; (8e54 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xd4>)
    8dda:	6441      	str	r1, [r0, #68]	; 0x44
    8ddc:	491e      	ldr	r1, [pc, #120]	; (8e58 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xd8>)
    8dde:	6341      	str	r1, [r0, #52]	; 0x34
    8de0:	491e      	ldr	r1, [pc, #120]	; (8e5c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xdc>)
    8de2:	6181      	str	r1, [r0, #24]
    8de4:	491e      	ldr	r1, [pc, #120]	; (8e60 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xe0>)
    8de6:	6301      	str	r1, [r0, #48]	; 0x30
    8de8:	491e      	ldr	r1, [pc, #120]	; (8e64 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xe4>)
    8dea:	6481      	str	r1, [r0, #72]	; 0x48
    8dec:	491e      	ldr	r1, [pc, #120]	; (8e68 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xe8>)
    8dee:	64c1      	str	r1, [r0, #76]	; 0x4c
    8df0:	491e      	ldr	r1, [pc, #120]	; (8e6c <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA+0xec>)
    8df2:	6381      	str	r1, [r0, #56]	; 0x38
    8df4:	4770      	bx	lr
    8df6:	0000      	.short	0x0000
    8df8:	0000a63d 	.word	0x0000a63d
    8dfc:	20000178 	.word	0x20000178
    8e00:	00009e95 	.word	0x00009e95
    8e04:	00009ef9 	.word	0x00009ef9
    8e08:	0000a329 	.word	0x0000a329
    8e0c:	0000a36d 	.word	0x0000a36d
    8e10:	00009fad 	.word	0x00009fad
    8e14:	0000a615 	.word	0x0000a615
    8e18:	0000a74d 	.word	0x0000a74d
    8e1c:	0000a065 	.word	0x0000a065
    8e20:	0000a2f9 	.word	0x0000a2f9
    8e24:	0000a2cd 	.word	0x0000a2cd
    8e28:	0000a5bd 	.word	0x0000a5bd
    8e2c:	0000a5ed 	.word	0x0000a5ed
    8e30:	0000a675 	.word	0x0000a675
    8e34:	0000a0b9 	.word	0x0000a0b9
    8e38:	0000ab69 	.word	0x0000ab69
    8e3c:	20000210 	.word	0x20000210
    8e40:	0000ab91 	.word	0x0000ab91
    8e44:	0000a8e1 	.word	0x0000a8e1
    8e48:	0000a9b9 	.word	0x0000a9b9
    8e4c:	0000a8b5 	.word	0x0000a8b5
    8e50:	0000aabd 	.word	0x0000aabd
    8e54:	0000aa3d 	.word	0x0000aa3d
    8e58:	0000aa69 	.word	0x0000aa69
    8e5c:	0000aae1 	.word	0x0000aae1
    8e60:	0000abed 	.word	0x0000abed
    8e64:	0000a971 	.word	0x0000a971
    8e68:	0000a9a1 	.word	0x0000a9a1
    8e6c:	0000aa8d 	.word	0x0000aa8d

00008e70 <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI>:
    8e70:	4806      	ldr	r0, [pc, #24]	; (8e8c <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI+0x1c>)
    8e72:	4905      	ldr	r1, [pc, #20]	; (8e88 <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI+0x18>)
    8e74:	6581      	str	r1, [r0, #88]	; 0x58
    8e76:	4906      	ldr	r1, [pc, #24]	; (8e90 <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI+0x20>)
    8e78:	6601      	str	r1, [r0, #96]	; 0x60
    8e7a:	4807      	ldr	r0, [pc, #28]	; (8e98 <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI+0x28>)
    8e7c:	4905      	ldr	r1, [pc, #20]	; (8e94 <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI+0x24>)
    8e7e:	6581      	str	r1, [r0, #88]	; 0x58
    8e80:	4906      	ldr	r1, [pc, #24]	; (8e9c <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI+0x2c>)
    8e82:	65c1      	str	r1, [r0, #92]	; 0x5c
    8e84:	4770      	bx	lr
    8e86:	0000      	.short	0x0000
    8e88:	0000a38d 	.word	0x0000a38d
    8e8c:	20000178 	.word	0x20000178
    8e90:	0000a46d 	.word	0x0000a46d
    8e94:	0000a9e5 	.word	0x0000a9e5
    8e98:	20000210 	.word	0x20000210
    8e9c:	0000aa15 	.word	0x0000aa15

00008ea0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA>:
    8ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8ea2:	4c7c      	ldr	r4, [pc, #496]	; (9094 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f4>)
    8ea4:	2101      	movs	r1, #1
    8ea6:	f1a4 0610 	sub.w	r6, r4, #16
    8eaa:	7021      	strb	r1, [r4, #0]
    8eac:	2500      	movs	r5, #0
    8eae:	6060      	str	r0, [r4, #4]
    8eb0:	8075      	strh	r5, [r6, #2]
    8eb2:	7075      	strb	r5, [r6, #1]
    8eb4:	7035      	strb	r5, [r6, #0]
    8eb6:	f880 11d3 	strb.w	r1, [r0, #467]	; 0x1d3
    8eba:	8800      	ldrh	r0, [r0, #0]
    8ebc:	f7fc fd88 	bl	59d0 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA>
    8ec0:	b180      	cbz	r0, 8ee4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x44>
    8ec2:	6860      	ldr	r0, [r4, #4]
    8ec4:	8800      	ldrh	r0, [r0, #0]
    8ec6:	f7fc ffd7 	bl	5e78 <sym_NKFCLZ5HTE6KVHDV5DGZ6TJP4KSZI43SYBECPRY>
    8eca:	6860      	ldr	r0, [r4, #4]
    8ecc:	8800      	ldrh	r0, [r0, #0]
    8ece:	f7fc ff7b 	bl	5dc8 <sym_IXGTNRGKILIZPWG2NJIZ2ALUPW2IM3XFVCGJW2I>
    8ed2:	6860      	ldr	r0, [r4, #4]
    8ed4:	f8b0 11ca 	ldrh.w	r1, [r0, #458]	; 0x1ca
    8ed8:	b1c9      	cbz	r1, 8f0e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6e>
    8eda:	3078      	adds	r0, #120	; 0x78
    8edc:	f006 ffe7 	bl	feae <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1e>
    8ee0:	b118      	cbz	r0, 8eea <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4a>
    8ee2:	e014      	b.n	8f0e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6e>
    8ee4:	f640 3166 	movw	r1, #2918	; 0xb66
    8ee8:	e06c      	b.n	8fc4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x124>
    8eea:	6860      	ldr	r0, [r4, #4]
    8eec:	f890 1118 	ldrb.w	r1, [r0, #280]	; 0x118
    8ef0:	f88d 1000 	strb.w	r1, [sp]
    8ef4:	9900      	ldr	r1, [sp, #0]
    8ef6:	9100      	str	r1, [sp, #0]
    8ef8:	f89d 1000 	ldrb.w	r1, [sp]
    8efc:	b139      	cbz	r1, 8f0e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6e>
    8efe:	f890 2088 	ldrb.w	r2, [r0, #136]	; 0x88
    8f02:	2301      	movs	r3, #1
    8f04:	4619      	mov	r1, r3
    8f06:	3078      	adds	r0, #120	; 0x78
    8f08:	f005 fb27 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    8f0c:	b180      	cbz	r0, 8f30 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x90>
    8f0e:	6860      	ldr	r0, [r4, #4]
    8f10:	3078      	adds	r0, #120	; 0x78
    8f12:	f006 ffcc 	bl	feae <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1e>
    8f16:	b128      	cbz	r0, 8f24 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x84>
    8f18:	6860      	ldr	r0, [r4, #4]
    8f1a:	f890 010c 	ldrb.w	r0, [r0, #268]	; 0x10c
    8f1e:	bf00      	nop
    8f20:	f000 fbb2 	bl	9688 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7e8>
    8f24:	6860      	ldr	r0, [r4, #4]
    8f26:	f890 11d5 	ldrb.w	r1, [r0, #469]	; 0x1d5
    8f2a:	b189      	cbz	r1, 8f50 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb0>
    8f2c:	80b5      	strh	r5, [r6, #4]
    8f2e:	e01e      	b.n	8f6e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xce>
    8f30:	6860      	ldr	r0, [r4, #4]
    8f32:	f8a0 50b8 	strh.w	r5, [r0, #184]	; 0xb8
    8f36:	f890 1119 	ldrb.w	r1, [r0, #281]	; 0x119
    8f3a:	f880 110e 	strb.w	r1, [r0, #270]	; 0x10e
    8f3e:	2100      	movs	r1, #0
    8f40:	2002      	movs	r0, #2
    8f42:	f000 fe53 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    8f46:	6860      	ldr	r0, [r4, #4]
    8f48:	f880 51d2 	strb.w	r5, [r0, #466]	; 0x1d2
    8f4c:	2002      	movs	r0, #2
    8f4e:	e7e7      	b.n	8f20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x80>
    8f50:	f890 11aa 	ldrb.w	r1, [r0, #426]	; 0x1aa
    8f54:	f88d 1000 	strb.w	r1, [sp]
    8f58:	9900      	ldr	r1, [sp, #0]
    8f5a:	9100      	str	r1, [sp, #0]
    8f5c:	f89d 1000 	ldrb.w	r1, [sp]
    8f60:	b919      	cbnz	r1, 8f6a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xca>
    8f62:	8d01      	ldrh	r1, [r0, #40]	; 0x28
    8f64:	8b02      	ldrh	r2, [r0, #24]
    8f66:	4291      	cmp	r1, r2
    8f68:	d800      	bhi.n	8f6c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xcc>
    8f6a:	8b01      	ldrh	r1, [r0, #24]
    8f6c:	80b1      	strh	r1, [r6, #4]
    8f6e:	f8b0 11ce 	ldrh.w	r1, [r0, #462]	; 0x1ce
    8f72:	1e49      	subs	r1, r1, #1
    8f74:	b28f      	uxth	r7, r1
    8f76:	f8b0 11d0 	ldrh.w	r1, [r0, #464]	; 0x1d0
    8f7a:	4439      	add	r1, r7
    8f7c:	f8a0 11d0 	strh.w	r1, [r0, #464]	; 0x1d0
    8f80:	f830 1fb4 	ldrh.w	r1, [r0, #180]!
    8f84:	4439      	add	r1, r7
    8f86:	8001      	strh	r1, [r0, #0]
    8f88:	f001 fe5e 	bl	ac48 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1da8>
    8f8c:	b120      	cbz	r0, 8f98 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf8>
    8f8e:	6860      	ldr	r0, [r4, #4]
    8f90:	f850 1fa8 	ldr.w	r1, [r0, #168]!
    8f94:	4439      	add	r1, r7
    8f96:	6001      	str	r1, [r0, #0]
    8f98:	6861      	ldr	r1, [r4, #4]
    8f9a:	f8b1 01ca 	ldrh.w	r0, [r1, #458]	; 0x1ca
    8f9e:	2801      	cmp	r0, #1
    8fa0:	d802      	bhi.n	8fa8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x108>
    8fa2:	1c40      	adds	r0, r0, #1
    8fa4:	f8a1 01ca 	strh.w	r0, [r1, #458]	; 0x1ca
    8fa8:	b10f      	cbz	r7, 8fae <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x10e>
    8faa:	f881 51dc 	strb.w	r5, [r1, #476]	; 0x1dc
    8fae:	f881 51d2 	strb.w	r5, [r1, #466]	; 0x1d2
    8fb2:	f8b1 21ce 	ldrh.w	r2, [r1, #462]	; 0x1ce
    8fb6:	f101 0078 	add.w	r0, r1, #120	; 0x78
    8fba:	f005 fc62 	bl	e882 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA>
    8fbe:	b120      	cbz	r0, 8fca <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x12a>
    8fc0:	f640 31ad 	movw	r1, #2989	; 0xbad
    8fc4:	2031      	movs	r0, #49	; 0x31
    8fc6:	f7fc f8c5 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    8fca:	6860      	ldr	r0, [r4, #4]
    8fcc:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    8fd0:	290b      	cmp	r1, #11
    8fd2:	d001      	beq.n	8fd8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x138>
    8fd4:	290c      	cmp	r1, #12
    8fd6:	d119      	bne.n	900c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16c>
    8fd8:	f8b0 207c 	ldrh.w	r2, [r0, #124]	; 0x7c
    8fdc:	f8b0 3274 	ldrh.w	r3, [r0, #628]	; 0x274
    8fe0:	1ad2      	subs	r2, r2, r3
    8fe2:	b212      	sxth	r2, r2
    8fe4:	2a00      	cmp	r2, #0
    8fe6:	db11      	blt.n	900c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16c>
    8fe8:	f8d0 1276 	ldr.w	r1, [r0, #630]	; 0x276
    8fec:	f8c0 108f 	str.w	r1, [r0, #143]	; 0x8f
    8ff0:	f890 127a 	ldrb.w	r1, [r0, #634]	; 0x27a
    8ff4:	f880 1093 	strb.w	r1, [r0, #147]	; 0x93
    8ff8:	2103      	movs	r1, #3
    8ffa:	f7fd fedd 	bl	6db8 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI>
    8ffe:	6860      	ldr	r0, [r4, #4]
    9000:	f880 5086 	strb.w	r5, [r0, #134]	; 0x86
    9004:	21ff      	movs	r1, #255	; 0xff
    9006:	f880 10dc 	strb.w	r1, [r0, #220]	; 0xdc
    900a:	e026      	b.n	905a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ba>
    900c:	2924      	cmp	r1, #36	; 0x24
    900e:	d111      	bne.n	9034 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x194>
    9010:	f8b0 107c 	ldrh.w	r1, [r0, #124]	; 0x7c
    9014:	f8b0 2274 	ldrh.w	r2, [r0, #628]	; 0x274
    9018:	1a89      	subs	r1, r1, r2
    901a:	b209      	sxth	r1, r1
    901c:	2900      	cmp	r1, #0
    901e:	db09      	blt.n	9034 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x194>
    9020:	f880 5086 	strb.w	r5, [r0, #134]	; 0x86
    9024:	f000 fe9c 	bl	9d60 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xec0>
    9028:	2800      	cmp	r0, #0
    902a:	6860      	ldr	r0, [r4, #4]
    902c:	f880 5124 	strb.w	r5, [r0, #292]	; 0x124
    9030:	d029      	beq.n	9086 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e6>
    9032:	e012      	b.n	905a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ba>
    9034:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
    9038:	2924      	cmp	r1, #36	; 0x24
    903a:	d001      	beq.n	9040 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a0>
    903c:	2925      	cmp	r1, #37	; 0x25
    903e:	d10c      	bne.n	905a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ba>
    9040:	f8b0 107c 	ldrh.w	r1, [r0, #124]	; 0x7c
    9044:	f8b0 2274 	ldrh.w	r2, [r0, #628]	; 0x274
    9048:	1a89      	subs	r1, r1, r2
    904a:	b209      	sxth	r1, r1
    904c:	2900      	cmp	r1, #0
    904e:	db04      	blt.n	905a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ba>
    9050:	f880 5085 	strb.w	r5, [r0, #133]	; 0x85
    9054:	f000 fe84 	bl	9d60 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xec0>
    9058:	b1a8      	cbz	r0, 9086 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e6>
    905a:	480f      	ldr	r0, [pc, #60]	; (9098 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f8>)
    905c:	9000      	str	r0, [sp, #0]
    905e:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
    9062:	4b0e      	ldr	r3, [pc, #56]	; (909c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fc>)
    9064:	4a0e      	ldr	r2, [pc, #56]	; (90a0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x200>)
    9066:	f7fc ff9f 	bl	5fa8 <sym_SQINY6V2VHFAHM5HL3H753H3QE3VQ7FWHCIJ57Q>
    906a:	6860      	ldr	r0, [r4, #4]
    906c:	2301      	movs	r3, #1
    906e:	2105      	movs	r1, #5
    9070:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9074:	3078      	adds	r0, #120	; 0x78
    9076:	f005 fa70 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    907a:	2800      	cmp	r0, #0
    907c:	d009      	beq.n	9092 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f2>
    907e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    9082:	f7fc bf8b 	b.w	5f9c <sym_4OWM6DBJ6JLAWH2MVU52MKC56VOOJLN34T33LQA>
    9086:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    908a:	2100      	movs	r1, #0
    908c:	4608      	mov	r0, r1
    908e:	f000 bbd9 	b.w	9844 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x9a4>
    9092:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9094:	20000170 	.word	0x20000170
    9098:	00009845 	.word	0x00009845
    909c:	00009365 	.word	0x00009365
    90a0:	00009cad 	.word	0x00009cad
    90a4:	4804      	ldr	r0, [pc, #16]	; (90b8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x218>)
    90a6:	2100      	movs	r1, #0
    90a8:	6840      	ldr	r0, [r0, #4]
    90aa:	f820 1fc0 	strh.w	r1, [r0, #192]!
    90ae:	7881      	ldrb	r1, [r0, #2]
    90b0:	1c49      	adds	r1, r1, #1
    90b2:	7081      	strb	r1, [r0, #2]
    90b4:	4770      	bx	lr
    90b6:	0000      	.short	0x0000
    90b8:	20000170 	.word	0x20000170
    90bc:	4807      	ldr	r0, [pc, #28]	; (90dc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x23c>)
    90be:	b510      	push	{r4, lr}
    90c0:	6841      	ldr	r1, [r0, #4]
    90c2:	f811 0fc2 	ldrb.w	r0, [r1, #194]!
    90c6:	1e40      	subs	r0, r0, #1
    90c8:	b240      	sxtb	r0, r0
    90ca:	7008      	strb	r0, [r1, #0]
    90cc:	2800      	cmp	r0, #0
    90ce:	da04      	bge.n	90da <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x23a>
    90d0:	f240 118d 	movw	r1, #397	; 0x18d
    90d4:	2031      	movs	r0, #49	; 0x31
    90d6:	f7fc f83d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    90da:	bd10      	pop	{r4, pc}
    90dc:	20000170 	.word	0x20000170
    90e0:	491d      	ldr	r1, [pc, #116]	; (9158 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2b8>)
    90e2:	b508      	push	{r3, lr}
    90e4:	6849      	ldr	r1, [r1, #4]
    90e6:	f891 2086 	ldrb.w	r2, [r1, #134]	; 0x86
    90ea:	b1b8      	cbz	r0, 911c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x27c>
    90ec:	2a10      	cmp	r2, #16
    90ee:	d006      	beq.n	90fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x25e>
    90f0:	2a14      	cmp	r2, #20
    90f2:	d007      	beq.n	9104 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x264>
    90f4:	2a15      	cmp	r2, #21
    90f6:	d008      	beq.n	910a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x26a>
    90f8:	2a1b      	cmp	r2, #27
    90fa:	d127      	bne.n	914c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2ac>
    90fc:	e008      	b.n	9110 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x270>
    90fe:	2101      	movs	r1, #1
    9100:	200b      	movs	r0, #11
    9102:	e007      	b.n	9114 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x274>
    9104:	f001 fb88 	bl	a818 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1978>
    9108:	e006      	b.n	9118 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x278>
    910a:	f000 fd8d 	bl	9c28 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd88>
    910e:	e003      	b.n	9118 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x278>
    9110:	2101      	movs	r1, #1
    9112:	2006      	movs	r0, #6
    9114:	f000 fd6a 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9118:	2001      	movs	r0, #1
    911a:	bd08      	pop	{r3, pc}
    911c:	2a21      	cmp	r2, #33	; 0x21
    911e:	d004      	beq.n	912a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x28a>
    9120:	2a28      	cmp	r2, #40	; 0x28
    9122:	d113      	bne.n	914c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2ac>
    9124:	2101      	movs	r1, #1
    9126:	2011      	movs	r0, #17
    9128:	e7f4      	b.n	9114 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x274>
    912a:	f891 0124 	ldrb.w	r0, [r1, #292]	; 0x124
    912e:	2802      	cmp	r0, #2
    9130:	d00e      	beq.n	9150 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2b0>
    9132:	f891 0124 	ldrb.w	r0, [r1, #292]	; 0x124
    9136:	2801      	cmp	r0, #1
    9138:	d108      	bne.n	914c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2ac>
    913a:	f891 0125 	ldrb.w	r0, [r1, #293]	; 0x125
    913e:	f88d 0000 	strb.w	r0, [sp]
    9142:	9800      	ldr	r0, [sp, #0]
    9144:	9000      	str	r0, [sp, #0]
    9146:	f89d 0000 	ldrb.w	r0, [sp]
    914a:	b108      	cbz	r0, 9150 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2b0>
    914c:	2000      	movs	r0, #0
    914e:	bd08      	pop	{r3, pc}
    9150:	2101      	movs	r1, #1
    9152:	2017      	movs	r0, #23
    9154:	e7de      	b.n	9114 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x274>
    9156:	0000      	.short	0x0000
    9158:	20000170 	.word	0x20000170
    915c:	b538      	push	{r3, r4, r5, lr}
    915e:	2800      	cmp	r0, #0
    9160:	d16d      	bne.n	923e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x39e>
    9162:	4c38      	ldr	r4, [pc, #224]	; (9244 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3a4>)
    9164:	6860      	ldr	r0, [r4, #4]
    9166:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
    916a:	07ca      	lsls	r2, r1, #31
    916c:	d002      	beq.n	9174 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2d4>
    916e:	2101      	movs	r1, #1
    9170:	2009      	movs	r0, #9
    9172:	e05d      	b.n	9230 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x390>
    9174:	078a      	lsls	r2, r1, #30
    9176:	d50a      	bpl.n	918e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2ee>
    9178:	2101      	movs	r1, #1
    917a:	200c      	movs	r0, #12
    917c:	f000 fd36 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9180:	6860      	ldr	r0, [r4, #4]
    9182:	f810 1fc5 	ldrb.w	r1, [r0, #197]!
    9186:	f041 0101 	orr.w	r1, r1, #1
    918a:	7001      	strb	r1, [r0, #0]
    918c:	e052      	b.n	9234 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x394>
    918e:	074a      	lsls	r2, r1, #29
    9190:	d502      	bpl.n	9198 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2f8>
    9192:	2101      	movs	r1, #1
    9194:	2013      	movs	r0, #19
    9196:	e04b      	b.n	9230 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x390>
    9198:	070a      	lsls	r2, r1, #28
    919a:	d506      	bpl.n	91aa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x30a>
    919c:	f890 1108 	ldrb.w	r1, [r0, #264]	; 0x108
    91a0:	f880 110e 	strb.w	r1, [r0, #270]	; 0x10e
    91a4:	2101      	movs	r1, #1
    91a6:	2007      	movs	r0, #7
    91a8:	e042      	b.n	9230 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x390>
    91aa:	f011 0f30 	tst.w	r1, #48	; 0x30
    91ae:	d046      	beq.n	923e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x39e>
    91b0:	f890 111b 	ldrb.w	r1, [r0, #283]	; 0x11b
    91b4:	f88d 1000 	strb.w	r1, [sp]
    91b8:	9900      	ldr	r1, [sp, #0]
    91ba:	9100      	str	r1, [sp, #0]
    91bc:	f89d 1000 	ldrb.w	r1, [sp]
    91c0:	bbd1      	cbnz	r1, 9238 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x398>
    91c2:	f890 111a 	ldrb.w	r1, [r0, #282]	; 0x11a
    91c6:	2500      	movs	r5, #0
    91c8:	f88d 1000 	strb.w	r1, [sp]
    91cc:	9900      	ldr	r1, [sp, #0]
    91ce:	9100      	str	r1, [sp, #0]
    91d0:	f89d 1000 	ldrb.w	r1, [sp]
    91d4:	b1c1      	cbz	r1, 9208 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x368>
    91d6:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    91da:	2924      	cmp	r1, #36	; 0x24
    91dc:	d02d      	beq.n	923a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x39a>
    91de:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
    91e2:	2924      	cmp	r1, #36	; 0x24
    91e4:	d029      	beq.n	923a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x39a>
    91e6:	2300      	movs	r3, #0
    91e8:	f200 2276 	addw	r2, r0, #630	; 0x276
    91ec:	f500 718d 	add.w	r1, r0, #282	; 0x11a
    91f0:	f005 fe72 	bl	eed8 <sym_436OKKOGR27QX7FMSZKYSEYLCMU4ZXR5RN4XUBY>
    91f4:	6860      	ldr	r0, [r4, #4]
    91f6:	f810 1f87 	ldrb.w	r1, [r0, #135]!
    91fa:	f001 01df 	and.w	r1, r1, #223	; 0xdf
    91fe:	f041 0110 	orr.w	r1, r1, #16
    9202:	7001      	strb	r1, [r0, #0]
    9204:	f880 5093 	strb.w	r5, [r0, #147]	; 0x93
    9208:	6860      	ldr	r0, [r4, #4]
    920a:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
    920e:	06c9      	lsls	r1, r1, #27
    9210:	d515      	bpl.n	923e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x39e>
    9212:	f005 fe7c 	bl	ef0e <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q>
    9216:	f000 f92b 	bl	9470 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5d0>
    921a:	6861      	ldr	r1, [r4, #4]
    921c:	f101 0030 	add.w	r0, r1, #48	; 0x30
    9220:	8bc2      	ldrh	r2, [r0, #30]
    9222:	f8a1 210e 	strh.w	r2, [r1, #270]	; 0x10e
    9226:	8c40      	ldrh	r0, [r0, #34]	; 0x22
    9228:	f8a1 0110 	strh.w	r0, [r1, #272]	; 0x110
    922c:	2101      	movs	r1, #1
    922e:	2015      	movs	r0, #21
    9230:	f000 fcdc 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9234:	2001      	movs	r0, #1
    9236:	bd38      	pop	{r3, r4, r5, pc}
    9238:	e001      	b.n	923e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x39e>
    923a:	2301      	movs	r3, #1
    923c:	e7d4      	b.n	91e8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x348>
    923e:	2000      	movs	r0, #0
    9240:	e7f9      	b.n	9236 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x396>
    9242:	0000      	.short	0x0000
    9244:	20000170 	.word	0x20000170
    9248:	b570      	push	{r4, r5, r6, lr}
    924a:	460d      	mov	r5, r1
    924c:	4606      	mov	r6, r0
    924e:	f005 fc09 	bl	ea64 <sym_GRRIKVTWBW2KWQ7YPR62UQBT5XVQYKO2LIWXODY>
    9252:	4604      	mov	r4, r0
    9254:	4630      	mov	r0, r6
    9256:	f005 fc11 	bl	ea7c <sym_6HFAHFLWDMEYCQ4GR3OXMWUSK4H5E4C2QPT3NZA>
    925a:	4629      	mov	r1, r5
    925c:	f000 f81e 	bl	929c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3fc>
    9260:	b1b8      	cbz	r0, 9292 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3f2>
    9262:	4620      	mov	r0, r4
    9264:	f005 fa13 	bl	e68e <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI>
    9268:	0001      	movs	r1, r0
    926a:	d00d      	beq.n	9288 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3e8>
    926c:	480a      	ldr	r0, [pc, #40]	; (9298 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3f8>)
    926e:	6840      	ldr	r0, [r0, #4]
    9270:	f890 206f 	ldrb.w	r2, [r0, #111]	; 0x6f
    9274:	428a      	cmp	r2, r1
    9276:	d007      	beq.n	9288 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3e8>
    9278:	f890 1124 	ldrb.w	r1, [r0, #292]	; 0x124
    927c:	2901      	cmp	r1, #1
    927e:	d005      	beq.n	928c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3ec>
    9280:	f890 006b 	ldrb.w	r0, [r0, #107]	; 0x6b
    9284:	4220      	tst	r0, r4
    9286:	d004      	beq.n	9292 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3f2>
    9288:	2001      	movs	r0, #1
    928a:	bd70      	pop	{r4, r5, r6, pc}
    928c:	f890 0127 	ldrb.w	r0, [r0, #295]	; 0x127
    9290:	e7f8      	b.n	9284 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3e4>
    9292:	2000      	movs	r0, #0
    9294:	bd70      	pop	{r4, r5, r6, pc}
    9296:	0000      	.short	0x0000
    9298:	20000170 	.word	0x20000170
    929c:	b570      	push	{r4, r5, r6, lr}
    929e:	460d      	mov	r5, r1
    92a0:	4604      	mov	r4, r0
    92a2:	f005 f9f4 	bl	e68e <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI>
    92a6:	b350      	cbz	r0, 92fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45e>
    92a8:	4916      	ldr	r1, [pc, #88]	; (9304 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x464>)
    92aa:	6849      	ldr	r1, [r1, #4]
    92ac:	f891 206e 	ldrb.w	r2, [r1, #110]	; 0x6e
    92b0:	4282      	cmp	r2, r0
    92b2:	d024      	beq.n	92fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45e>
    92b4:	f891 3124 	ldrb.w	r3, [r1, #292]	; 0x124
    92b8:	2b01      	cmp	r3, #1
    92ba:	d005      	beq.n	92c8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x428>
    92bc:	f891 306a 	ldrb.w	r3, [r1, #106]	; 0x6a
    92c0:	4223      	tst	r3, r4
    92c2:	d013      	beq.n	92ec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x44c>
    92c4:	b11d      	cbz	r5, 92ce <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x42e>
    92c6:	e01a      	b.n	92fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45e>
    92c8:	f891 3126 	ldrb.w	r3, [r1, #294]	; 0x126
    92cc:	e7f8      	b.n	92c0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x420>
    92ce:	f891 1067 	ldrb.w	r1, [r1, #103]	; 0x67
    92d2:	4221      	tst	r1, r4
    92d4:	d113      	bne.n	92fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45e>
    92d6:	b15a      	cbz	r2, 92f0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x450>
    92d8:	2a04      	cmp	r2, #4
    92da:	d00e      	beq.n	92fa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45a>
    92dc:	2804      	cmp	r0, #4
    92de:	d00c      	beq.n	92fa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45a>
    92e0:	2a08      	cmp	r2, #8
    92e2:	d00a      	beq.n	92fa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45a>
    92e4:	2808      	cmp	r0, #8
    92e6:	d008      	beq.n	92fa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45a>
    92e8:	4282      	cmp	r2, r0
    92ea:	d908      	bls.n	92fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x45e>
    92ec:	2000      	movs	r0, #0
    92ee:	bd70      	pop	{r4, r5, r6, pc}
    92f0:	f44f 71c5 	mov.w	r1, #394	; 0x18a
    92f4:	2006      	movs	r0, #6
    92f6:	f7fb ff2d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    92fa:	4282      	cmp	r2, r0
    92fc:	d3f6      	bcc.n	92ec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x44c>
    92fe:	2001      	movs	r0, #1
    9300:	bd70      	pop	{r4, r5, r6, pc}
    9302:	0000      	.short	0x0000
    9304:	20000170 	.word	0x20000170
    9308:	b510      	push	{r4, lr}
    930a:	4c10      	ldr	r4, [pc, #64]	; (934c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4ac>)
    930c:	2301      	movs	r3, #1
    930e:	2100      	movs	r1, #0
    9310:	6860      	ldr	r0, [r4, #4]
    9312:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    9316:	3078      	adds	r0, #120	; 0x78
    9318:	f005 f91f 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    931c:	b140      	cbz	r0, 9330 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x490>
    931e:	6860      	ldr	r0, [r4, #4]
    9320:	2301      	movs	r3, #1
    9322:	2104      	movs	r1, #4
    9324:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9328:	3078      	adds	r0, #120	; 0x78
    932a:	f005 f916 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    932e:	b108      	cbz	r0, 9334 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x494>
    9330:	2000      	movs	r0, #0
    9332:	bd10      	pop	{r4, pc}
    9334:	6860      	ldr	r0, [r4, #4]
    9336:	f890 00b2 	ldrb.w	r0, [r0, #178]	; 0xb2
    933a:	2800      	cmp	r0, #0
    933c:	d0f9      	beq.n	9332 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x492>
    933e:	2100      	movs	r1, #0
    9340:	2012      	movs	r0, #18
    9342:	f000 fc53 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9346:	2001      	movs	r0, #1
    9348:	bd10      	pop	{r4, pc}
    934a:	0000      	.short	0x0000
    934c:	20000170 	.word	0x20000170
    9350:	4903      	ldr	r1, [pc, #12]	; (9360 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4c0>)
    9352:	2000      	movs	r0, #0
    9354:	6849      	ldr	r1, [r1, #4]
    9356:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    935a:	f881 00be 	strb.w	r0, [r1, #190]	; 0xbe
    935e:	4770      	bx	lr
    9360:	20000170 	.word	0x20000170
    9364:	490d      	ldr	r1, [pc, #52]	; (939c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4fc>)
    9366:	4602      	mov	r2, r0
    9368:	7848      	ldrb	r0, [r1, #1]
    936a:	b9a0      	cbnz	r0, 9396 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4f6>
    936c:	f101 0010 	add.w	r0, r1, #16
    9370:	6840      	ldr	r0, [r0, #4]
    9372:	b142      	cbz	r2, 9386 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4e6>
    9374:	7889      	ldrb	r1, [r1, #2]
    9376:	0709      	lsls	r1, r1, #28
    9378:	d503      	bpl.n	9382 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4e2>
    937a:	f890 0088 	ldrb.w	r0, [r0, #136]	; 0x88
    937e:	2808      	cmp	r0, #8
    9380:	d009      	beq.n	9396 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4f6>
    9382:	2001      	movs	r0, #1
    9384:	4770      	bx	lr
    9386:	f100 0130 	add.w	r1, r0, #48	; 0x30
    938a:	8c8a      	ldrh	r2, [r1, #36]	; 0x24
    938c:	8f01      	ldrh	r1, [r0, #56]	; 0x38
    938e:	428a      	cmp	r2, r1
    9390:	d801      	bhi.n	9396 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4f6>
    9392:	f7ff b93d 	b.w	8610 <sym_FQCHK2QLF7THGK7G4A4OWWNXI3K2TVYTTB4U4GY>
    9396:	2000      	movs	r0, #0
    9398:	4770      	bx	lr
    939a:	0000      	.short	0x0000
    939c:	20000160 	.word	0x20000160
    93a0:	b538      	push	{r3, r4, r5, lr}
    93a2:	4c32      	ldr	r4, [pc, #200]	; (946c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5cc>)
    93a4:	4605      	mov	r5, r0
    93a6:	6860      	ldr	r0, [r4, #4]
    93a8:	3078      	adds	r0, #120	; 0x78
    93aa:	f006 fd80 	bl	feae <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1e>
    93ae:	2800      	cmp	r0, #0
    93b0:	d15b      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    93b2:	2d00      	cmp	r5, #0
    93b4:	d159      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    93b6:	6860      	ldr	r0, [r4, #4]
    93b8:	2301      	movs	r3, #1
    93ba:	4619      	mov	r1, r3
    93bc:	f890 2088 	ldrb.w	r2, [r0, #136]	; 0x88
    93c0:	3078      	adds	r0, #120	; 0x78
    93c2:	f005 f8ca 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    93c6:	2800      	cmp	r0, #0
    93c8:	d14f      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    93ca:	6860      	ldr	r0, [r4, #4]
    93cc:	f890 1118 	ldrb.w	r1, [r0, #280]	; 0x118
    93d0:	f88d 1000 	strb.w	r1, [sp]
    93d4:	9900      	ldr	r1, [sp, #0]
    93d6:	9100      	str	r1, [sp, #0]
    93d8:	f89d 2000 	ldrb.w	r2, [sp]
    93dc:	2100      	movs	r1, #0
    93de:	b142      	cbz	r2, 93f2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x552>
    93e0:	f8a0 10b8 	strh.w	r1, [r0, #184]	; 0xb8
    93e4:	f890 1119 	ldrb.w	r1, [r0, #281]	; 0x119
    93e8:	f880 110e 	strb.w	r1, [r0, #270]	; 0x10e
    93ec:	2100      	movs	r1, #0
    93ee:	2002      	movs	r0, #2
    93f0:	e030      	b.n	9454 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5b4>
    93f2:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    93f6:	2301      	movs	r3, #1
    93f8:	2104      	movs	r1, #4
    93fa:	3078      	adds	r0, #120	; 0x78
    93fc:	f005 f8ad 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9400:	4605      	mov	r5, r0
    9402:	f7ff feab 	bl	915c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2bc>
    9406:	2800      	cmp	r0, #0
    9408:	d12f      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    940a:	4628      	mov	r0, r5
    940c:	f7ff fe68 	bl	90e0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x240>
    9410:	2800      	cmp	r0, #0
    9412:	d12a      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    9414:	f7ff ff78 	bl	9308 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x468>
    9418:	2800      	cmp	r0, #0
    941a:	d126      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    941c:	6860      	ldr	r0, [r4, #4]
    941e:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
    9422:	290a      	cmp	r1, #10
    9424:	d01a      	beq.n	945c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5bc>
    9426:	2d00      	cmp	r5, #0
    9428:	d11f      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    942a:	f000 fb2b 	bl	9a84 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbe4>
    942e:	2800      	cmp	r0, #0
    9430:	d11b      	bne.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    9432:	6860      	ldr	r0, [r4, #4]
    9434:	2301      	movs	r3, #1
    9436:	2100      	movs	r1, #0
    9438:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    943c:	3078      	adds	r0, #120	; 0x78
    943e:	f005 f88c 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9442:	2800      	cmp	r0, #0
    9444:	d011      	beq.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    9446:	6860      	ldr	r0, [r4, #4]
    9448:	f890 026c 	ldrb.w	r0, [r0, #620]	; 0x26c
    944c:	2800      	cmp	r0, #0
    944e:	d00c      	beq.n	946a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5ca>
    9450:	2100      	movs	r1, #0
    9452:	20ff      	movs	r0, #255	; 0xff
    9454:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    9458:	f000 bbc8 	b.w	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    945c:	f890 1109 	ldrb.w	r1, [r0, #265]	; 0x109
    9460:	f880 110e 	strb.w	r1, [r0, #270]	; 0x10e
    9464:	2100      	movs	r1, #0
    9466:	2007      	movs	r0, #7
    9468:	e7f4      	b.n	9454 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5b4>
    946a:	bd38      	pop	{r3, r4, r5, pc}
    946c:	20000170 	.word	0x20000170
    9470:	480a      	ldr	r0, [pc, #40]	; (949c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5fc>)
    9472:	b510      	push	{r4, lr}
    9474:	6843      	ldr	r3, [r0, #4]
    9476:	f893 0064 	ldrb.w	r0, [r3, #100]	; 0x64
    947a:	2801      	cmp	r0, #1
    947c:	d00a      	beq.n	9494 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5f4>
    947e:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    9482:	f103 0130 	add.w	r1, r3, #48	; 0x30
    9486:	8818      	ldrh	r0, [r3, #0]
    9488:	f005 fcfe 	bl	ee88 <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY>
    948c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9490:	f7fd bf5a 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    9494:	2002      	movs	r0, #2
    9496:	f883 0064 	strb.w	r0, [r3, #100]	; 0x64
    949a:	bd10      	pop	{r4, pc}
    949c:	20000170 	.word	0x20000170
    94a0:	b570      	push	{r4, r5, r6, lr}
    94a2:	4c24      	ldr	r4, [pc, #144]	; (9534 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x694>)
    94a4:	0006      	movs	r6, r0
    94a6:	f104 0510 	add.w	r5, r4, #16
    94aa:	d12f      	bne.n	950c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x66c>
    94ac:	f000 f8a2 	bl	95f4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x754>
    94b0:	f000 f844 	bl	953c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x69c>
    94b4:	0006      	movs	r6, r0
    94b6:	d129      	bne.n	950c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x66c>
    94b8:	8860      	ldrh	r0, [r4, #2]
    94ba:	0741      	lsls	r1, r0, #29
    94bc:	d506      	bpl.n	94cc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x62c>
    94be:	6869      	ldr	r1, [r5, #4]
    94c0:	f891 1088 	ldrb.w	r1, [r1, #136]	; 0x88
    94c4:	2907      	cmp	r1, #7
    94c6:	d101      	bne.n	94cc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x62c>
    94c8:	2101      	movs	r1, #1
    94ca:	7021      	strb	r1, [r4, #0]
    94cc:	0780      	lsls	r0, r0, #30
    94ce:	d512      	bpl.n	94f6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x656>
    94d0:	68a0      	ldr	r0, [r4, #8]
    94d2:	78c0      	ldrb	r0, [r0, #3]
    94d4:	2826      	cmp	r0, #38	; 0x26
    94d6:	d205      	bcs.n	94e4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x644>
    94d8:	4917      	ldr	r1, [pc, #92]	; (9538 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x698>)
    94da:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    94de:	b109      	cbz	r1, 94e4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x644>
    94e0:	4788      	blx	r1
    94e2:	e008      	b.n	94f6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x656>
    94e4:	28ff      	cmp	r0, #255	; 0xff
    94e6:	d004      	beq.n	94f2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x652>
    94e8:	f240 71c9 	movw	r1, #1993	; 0x7c9
    94ec:	2031      	movs	r0, #49	; 0x31
    94ee:	f7fb fe31 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    94f2:	f001 f9d3 	bl	a89c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19fc>
    94f6:	78a0      	ldrb	r0, [r4, #2]
    94f8:	06c0      	lsls	r0, r0, #27
    94fa:	d507      	bpl.n	950c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x66c>
    94fc:	6868      	ldr	r0, [r5, #4]
    94fe:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    9502:	290b      	cmp	r1, #11
    9504:	d102      	bne.n	950c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x66c>
    9506:	210c      	movs	r1, #12
    9508:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    950c:	7860      	ldrb	r0, [r4, #1]
    950e:	0700      	lsls	r0, r0, #28
    9510:	d50d      	bpl.n	952e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x68e>
    9512:	6868      	ldr	r0, [r5, #4]
    9514:	2301      	movs	r3, #1
    9516:	2105      	movs	r1, #5
    9518:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    951c:	3078      	adds	r0, #120	; 0x78
    951e:	f005 f81c 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9522:	b108      	cbz	r0, 9528 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x688>
    9524:	2608      	movs	r6, #8
    9526:	e002      	b.n	952e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x68e>
    9528:	2000      	movs	r0, #0
    952a:	f7fc fe05 	bl	6138 <sym_P6ESEOOF3E3ZRYNBCJWJZXMT4EPJJMHF472YBMQ>
    952e:	4630      	mov	r0, r6
    9530:	bd70      	pop	{r4, r5, r6, pc}
    9532:	0000      	.short	0x0000
    9534:	20000160 	.word	0x20000160
    9538:	20000210 	.word	0x20000210
    953c:	b570      	push	{r4, r5, r6, lr}
    953e:	4d2b      	ldr	r5, [pc, #172]	; (95ec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x74c>)
    9540:	2000      	movs	r0, #0
    9542:	78a9      	ldrb	r1, [r5, #2]
    9544:	07c9      	lsls	r1, r1, #31
    9546:	d017      	beq.n	9578 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6d8>
    9548:	68e8      	ldr	r0, [r5, #12]
    954a:	f105 0410 	add.w	r4, r5, #16
    954e:	2301      	movs	r3, #1
    9550:	78c6      	ldrb	r6, [r0, #3]
    9552:	6860      	ldr	r0, [r4, #4]
    9554:	2105      	movs	r1, #5
    9556:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    955a:	3078      	adds	r0, #120	; 0x78
    955c:	f004 fffd 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9560:	b158      	cbz	r0, 957a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6da>
    9562:	1eb6      	subs	r6, r6, #2
    9564:	2e0a      	cmp	r6, #10
    9566:	d206      	bcs.n	9576 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6d6>
    9568:	e8df f006 	tbb	[pc, r6]
    956c:	05050707 	.word	0x05050707
    9570:	05050707 	.word	0x05050707
    9574:	0707      	.short	0x0707
    9576:	2008      	movs	r0, #8
    9578:	bd70      	pop	{r4, r5, r6, pc}
    957a:	68e8      	ldr	r0, [r5, #12]
    957c:	f7fd fd48 	bl	7010 <sym_AQNKAYNIT4GTGTVAKOZJZSWZBN4I6FFKO6L5AXA>
    9580:	b138      	cbz	r0, 9592 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6f2>
    9582:	68e8      	ldr	r0, [r5, #12]
    9584:	78c5      	ldrb	r5, [r0, #3]
    9586:	b145      	cbz	r5, 959a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6fa>
    9588:	2d01      	cmp	r5, #1
    958a:	d006      	beq.n	959a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6fa>
    958c:	2d16      	cmp	r5, #22
    958e:	d118      	bne.n	95c2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x722>
    9590:	e003      	b.n	959a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x6fa>
    9592:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    9596:	f000 bdd1 	b.w	a13c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x129c>
    959a:	6860      	ldr	r0, [r4, #4]
    959c:	f890 0085 	ldrb.w	r0, [r0, #133]	; 0x85
    95a0:	f005 f829 	bl	e5f6 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI>
    95a4:	b168      	cbz	r0, 95c2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x722>
    95a6:	6861      	ldr	r1, [r4, #4]
    95a8:	f891 0085 	ldrb.w	r0, [r1, #133]	; 0x85
    95ac:	281f      	cmp	r0, #31
    95ae:	d008      	beq.n	95c2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x722>
    95b0:	2820      	cmp	r0, #32
    95b2:	d003      	beq.n	95bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x71c>
    95b4:	2d16      	cmp	r5, #22
    95b6:	d00c      	beq.n	95d2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x732>
    95b8:	2002      	movs	r0, #2
    95ba:	bd70      	pop	{r4, r5, r6, pc}
    95bc:	2027      	movs	r0, #39	; 0x27
    95be:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    95c2:	2d26      	cmp	r5, #38	; 0x26
    95c4:	d207      	bcs.n	95d6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x736>
    95c6:	480a      	ldr	r0, [pc, #40]	; (95f0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x750>)
    95c8:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
    95cc:	b118      	cbz	r0, 95d6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x736>
    95ce:	4780      	blx	r0
    95d0:	e003      	b.n	95da <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x73a>
    95d2:	2020      	movs	r0, #32
    95d4:	bd70      	pop	{r4, r5, r6, pc}
    95d6:	f000 fdb1 	bl	a13c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x129c>
    95da:	6861      	ldr	r1, [r4, #4]
    95dc:	e9f1 233a 	ldrd	r2, r3, [r1, #232]!	; 0xe8
    95e0:	1c52      	adds	r2, r2, #1
    95e2:	f143 0300 	adc.w	r3, r3, #0
    95e6:	e9c1 2300 	strd	r2, r3, [r1]
    95ea:	bd70      	pop	{r4, r5, r6, pc}
    95ec:	20000160 	.word	0x20000160
    95f0:	20000178 	.word	0x20000178
    95f4:	b570      	push	{r4, r5, r6, lr}
    95f6:	4e23      	ldr	r6, [pc, #140]	; (9684 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7e4>)
    95f8:	78b0      	ldrb	r0, [r6, #2]
    95fa:	0700      	lsls	r0, r0, #28
    95fc:	d540      	bpl.n	9680 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7e0>
    95fe:	f106 0410 	add.w	r4, r6, #16
    9602:	6860      	ldr	r0, [r4, #4]
    9604:	3078      	adds	r0, #120	; 0x78
    9606:	f006 fc52 	bl	feae <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1e>
    960a:	b148      	cbz	r0, 9620 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x780>
    960c:	6860      	ldr	r0, [r4, #4]
    960e:	21fe      	movs	r1, #254	; 0xfe
    9610:	2500      	movs	r5, #0
    9612:	f880 110c 	strb.w	r1, [r0, #268]	; 0x10c
    9616:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    961a:	2919      	cmp	r1, #25
    961c:	d10c      	bne.n	9638 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x798>
    961e:	e004      	b.n	962a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x78a>
    9620:	f240 71d3 	movw	r1, #2003	; 0x7d3
    9624:	2031      	movs	r0, #49	; 0x31
    9626:	f7fb fd95 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    962a:	f880 50c3 	strb.w	r5, [r0, #195]	; 0xc3
    962e:	f7ff fd45 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    9632:	6860      	ldr	r0, [r4, #4]
    9634:	f880 5086 	strb.w	r5, [r0, #134]	; 0x86
    9638:	6860      	ldr	r0, [r4, #4]
    963a:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
    963e:	291f      	cmp	r1, #31
    9640:	d002      	beq.n	9648 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7a8>
    9642:	2929      	cmp	r1, #41	; 0x29
    9644:	d113      	bne.n	966e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7ce>
    9646:	e00b      	b.n	9660 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7c0>
    9648:	f890 0086 	ldrb.w	r0, [r0, #134]	; 0x86
    964c:	f004 ffd3 	bl	e5f6 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI>
    9650:	b108      	cbz	r0, 9656 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7b6>
    9652:	2027      	movs	r0, #39	; 0x27
    9654:	e000      	b.n	9658 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7b8>
    9656:	2020      	movs	r0, #32
    9658:	6861      	ldr	r1, [r4, #4]
    965a:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    965e:	e006      	b.n	966e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7ce>
    9660:	2101      	movs	r1, #1
    9662:	f880 126d 	strb.w	r1, [r0, #621]	; 0x26d
    9666:	f880 5085 	strb.w	r5, [r0, #133]	; 0x85
    966a:	f880 50be 	strb.w	r5, [r0, #190]	; 0xbe
    966e:	6860      	ldr	r0, [r4, #4]
    9670:	f890 1088 	ldrb.w	r1, [r0, #136]	; 0x88
    9674:	2908      	cmp	r1, #8
    9676:	d103      	bne.n	9680 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x7e0>
    9678:	2102      	movs	r1, #2
    967a:	7031      	strb	r1, [r6, #0]
    967c:	f880 110c 	strb.w	r1, [r0, #268]	; 0x10c
    9680:	bd70      	pop	{r4, r5, r6, pc}
    9682:	0000      	.short	0x0000
    9684:	20000160 	.word	0x20000160
    9688:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
    968a:	4606      	mov	r6, r0
    968c:	4668      	mov	r0, sp
    968e:	f7fc fbdd 	bl	5e4c <sym_65LA7GM3MU7DDFQKTB75BYTZMPMROSWKS3VXCNI>
    9692:	b310      	cbz	r0, 96da <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x83a>
    9694:	2222      	movs	r2, #34	; 0x22
    9696:	2100      	movs	r1, #0
    9698:	9800      	ldr	r0, [sp, #0]
    969a:	f003 fd19 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    969e:	2103      	movs	r1, #3
    96a0:	9800      	ldr	r0, [sp, #0]
    96a2:	f005 fa4f 	bl	eb44 <sym_KWWW3Q4Z6LMHA6EXR6CMFCOS3QXXZ636XUAHVBY>
    96a6:	9800      	ldr	r0, [sp, #0]
    96a8:	7801      	ldrb	r1, [r0, #0]
    96aa:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    96ae:	7001      	strb	r1, [r0, #0]
    96b0:	4631      	mov	r1, r6
    96b2:	f7fd fcbd 	bl	7030 <sym_ASSU5HSD7LU7BXC2C2QNNVLB6AOHO4SQ3KK3OJY>
    96b6:	4c62      	ldr	r4, [pc, #392]	; (9840 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x9a0>)
    96b8:	f644 152f 	movw	r5, #18735	; 0x492f
    96bc:	2e0e      	cmp	r6, #14
    96be:	d079      	beq.n	97b4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x914>
    96c0:	dc0e      	bgt.n	96e0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x840>
    96c2:	f1a6 0602 	sub.w	r6, r6, #2
    96c6:	2e0c      	cmp	r6, #12
    96c8:	d21c      	bcs.n	9704 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x864>
    96ca:	e8df f006 	tbb	[pc, r6]
    96ce:	1b1e      	.short	0x1b1e
    96d0:	23aeae52 	.word	0x23aeae52
    96d4:	ae1b5f1b 	.word	0xae1b5f1b
    96d8:	363c      	.short	0x363c
    96da:	f640 210a 	movw	r1, #2570	; 0xa0a
    96de:	e0aa      	b.n	9836 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x996>
    96e0:	2e15      	cmp	r6, #21
    96e2:	d068      	beq.n	97b6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x916>
    96e4:	dc08      	bgt.n	96f8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x858>
    96e6:	2e11      	cmp	r6, #17
    96e8:	d01a      	beq.n	9720 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x880>
    96ea:	2e12      	cmp	r6, #18
    96ec:	d017      	beq.n	971e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x87e>
    96ee:	2e13      	cmp	r6, #19
    96f0:	d015      	beq.n	971e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x87e>
    96f2:	2e14      	cmp	r6, #20
    96f4:	d106      	bne.n	9704 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x864>
    96f6:	e05e      	b.n	97b6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x916>
    96f8:	2e16      	cmp	r6, #22
    96fa:	d030      	beq.n	975e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x8be>
    96fc:	2e17      	cmp	r6, #23
    96fe:	d075      	beq.n	97ec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x94c>
    9700:	2eff      	cmp	r6, #255	; 0xff
    9702:	d072      	beq.n	97ea <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x94a>
    9704:	f640 217b 	movw	r1, #2683	; 0xa7b
    9708:	e095      	b.n	9836 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x996>
    970a:	6861      	ldr	r1, [r4, #4]
    970c:	9800      	ldr	r0, [sp, #0]
    970e:	f891 110e 	ldrb.w	r1, [r1, #270]	; 0x10e
    9712:	e016      	b.n	9742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x8a2>
    9714:	6860      	ldr	r0, [r4, #4]
    9716:	9900      	ldr	r1, [sp, #0]
    9718:	f890 010e 	ldrb.w	r0, [r0, #270]	; 0x10e
    971c:	7108      	strb	r0, [r1, #4]
    971e:	e084      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    9720:	6860      	ldr	r0, [r4, #4]
    9722:	f890 110b 	ldrb.w	r1, [r0, #267]	; 0x10b
    9726:	9800      	ldr	r0, [sp, #0]
    9728:	f005 f9e8 	bl	eafc <sym_2AEWUZQ66QOZRZKHF7IFSSSWOGAXMPPQQH7267Y>
    972c:	6860      	ldr	r0, [r4, #4]
    972e:	f890 110a 	ldrb.w	r1, [r0, #266]	; 0x10a
    9732:	9800      	ldr	r0, [sp, #0]
    9734:	f005 f9e4 	bl	eb00 <sym_AG7JDKFTDFANNIOBH4HEQO2XNU7V2OR3R525SOY>
    9738:	e077      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    973a:	6861      	ldr	r1, [r4, #4]
    973c:	9800      	ldr	r0, [sp, #0]
    973e:	f891 110a 	ldrb.w	r1, [r1, #266]	; 0x10a
    9742:	7101      	strb	r1, [r0, #4]
    9744:	e071      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    9746:	9800      	ldr	r0, [sp, #0]
    9748:	210c      	movs	r1, #12
    974a:	7101      	strb	r1, [r0, #4]
    974c:	2159      	movs	r1, #89	; 0x59
    974e:	7141      	strb	r1, [r0, #5]
    9750:	2100      	movs	r1, #0
    9752:	7181      	strb	r1, [r0, #6]
    9754:	21a7      	movs	r1, #167	; 0xa7
    9756:	71c1      	strb	r1, [r0, #7]
    9758:	2111      	movs	r1, #17
    975a:	7201      	strb	r1, [r0, #8]
    975c:	e065      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    975e:	9800      	ldr	r0, [sp, #0]
    9760:	f8d4 1004 	ldr.w	r1, [r4, #4]
    9764:	f891 2126 	ldrb.w	r2, [r1, #294]	; 0x126
    9768:	7102      	strb	r2, [r0, #4]
    976a:	f891 1127 	ldrb.w	r1, [r1, #295]	; 0x127
    976e:	7141      	strb	r1, [r0, #5]
    9770:	e05b      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    9772:	6861      	ldr	r1, [r4, #4]
    9774:	9800      	ldr	r0, [sp, #0]
    9776:	f501 71f4 	add.w	r1, r1, #488	; 0x1e8
    977a:	f005 f9d4 	bl	eb26 <sym_GACCOL6OK5AZZZEY5D5QPNSIBJI3JJRDH53DCCY>
    977e:	6861      	ldr	r1, [r4, #4]
    9780:	9800      	ldr	r0, [sp, #0]
    9782:	f501 7182 	add.w	r1, r1, #260	; 0x104
    9786:	f005 f9cb 	bl	eb20 <sym_VUV5X4H4Y5BCHQYQ2OODYEDUWFHSSL4GLPT4S5Q>
    978a:	e04e      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    978c:	f001 ff54 	bl	b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>
    9790:	4028      	ands	r0, r5
    9792:	f001 0106 	and.w	r1, r1, #6
    9796:	e9cd 0101 	strd	r0, r1, [sp, #4]
    979a:	6861      	ldr	r1, [r4, #4]
    979c:	f89d 0004 	ldrb.w	r0, [sp, #4]
    97a0:	f891 10d4 	ldrb.w	r1, [r1, #212]	; 0xd4
    97a4:	4008      	ands	r0, r1
    97a6:	f88d 0004 	strb.w	r0, [sp, #4]
    97aa:	a901      	add	r1, sp, #4
    97ac:	9800      	ldr	r0, [sp, #0]
    97ae:	f005 f9c4 	bl	eb3a <sym_ATMVKJRU6FJAJXHYSHEXCCKRTDJACEACYJQFGVQ>
    97b2:	e03a      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    97b4:	e025      	b.n	9802 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x962>
    97b6:	6860      	ldr	r0, [r4, #4]
    97b8:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
    97bc:	9800      	ldr	r0, [sp, #0]
    97be:	f005 f9c9 	bl	eb54 <sym_5WASOMRPEYEGPJYIYCZL3MI6RFVOLW4PF3WQWXQ>
    97c2:	6860      	ldr	r0, [r4, #4]
    97c4:	f8b0 1110 	ldrh.w	r1, [r0, #272]	; 0x110
    97c8:	9800      	ldr	r0, [sp, #0]
    97ca:	f005 f9c7 	bl	eb5c <sym_65OGIL725U6FQPGLZMGDICIUHB5S2P2UG7UZGMY>
    97ce:	6860      	ldr	r0, [r4, #4]
    97d0:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
    97d4:	9800      	ldr	r0, [sp, #0]
    97d6:	f005 f9c5 	bl	eb64 <sym_DPBBMGOHRJRJWIFBTEHPLVVPOEIMHXK2HYFFW2A>
    97da:	6860      	ldr	r0, [r4, #4]
    97dc:	f8b0 110e 	ldrh.w	r1, [r0, #270]	; 0x10e
    97e0:	9800      	ldr	r0, [sp, #0]
    97e2:	f005 f9c3 	bl	eb6c <sym_F72ACBYKMJPI25JMH6PCTUEZPH6HMPJHM2HMJDY>
    97e6:	e020      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    97e8:	e000      	b.n	97ec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x94c>
    97ea:	e016      	b.n	981a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x97a>
    97ec:	6861      	ldr	r1, [r4, #4]
    97ee:	f891 0124 	ldrb.w	r0, [r1, #292]	; 0x124
    97f2:	2801      	cmp	r0, #1
    97f4:	9800      	ldr	r0, [sp, #0]
    97f6:	d0b5      	beq.n	9764 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x8c4>
    97f8:	f811 2f6a 	ldrb.w	r2, [r1, #106]!
    97fc:	7102      	strb	r2, [r0, #4]
    97fe:	7849      	ldrb	r1, [r1, #1]
    9800:	e7b5      	b.n	976e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x8ce>
    9802:	f001 ff19 	bl	b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>
    9806:	4028      	ands	r0, r5
    9808:	f001 0106 	and.w	r1, r1, #6
    980c:	e9cd 0101 	strd	r0, r1, [sp, #4]
    9810:	a901      	add	r1, sp, #4
    9812:	9800      	ldr	r0, [sp, #0]
    9814:	f005 f98c 	bl	eb30 <sym_ALFHFCPCHQINI4F6NU6LJJP26B4M2FERQPHDBAI>
    9818:	e007      	b.n	982a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x98a>
    981a:	6860      	ldr	r0, [r4, #4]
    981c:	f890 226f 	ldrb.w	r2, [r0, #623]	; 0x26f
    9820:	f8d0 1270 	ldr.w	r1, [r0, #624]	; 0x270
    9824:	9800      	ldr	r0, [sp, #0]
    9826:	f005 f96d 	bl	eb04 <sym_KDG27CITYLRG66Y5P6H5BVIHPU5DAFDVHM7DSQA>
    982a:	f7fc fae9 	bl	5e00 <sym_AGWGY6I3YKHHV6TMAWL24HN4IKGOB7PZYXPWBRA>
    982e:	2800      	cmp	r0, #0
    9830:	d104      	bne.n	983c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x99c>
    9832:	f640 217f 	movw	r1, #2687	; 0xa7f
    9836:	2031      	movs	r0, #49	; 0x31
    9838:	f7fb fc8c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    983c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    983e:	0000      	.short	0x0000
    9840:	20000170 	.word	0x20000170
    9844:	e92d 5ff3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    9848:	4e8d      	ldr	r6, [pc, #564]	; (9a80 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbe0>)
    984a:	468a      	mov	sl, r1
    984c:	6870      	ldr	r0, [r6, #4]
    984e:	8800      	ldrh	r0, [r0, #0]
    9850:	f7fc f8be 	bl	59d0 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA>
    9854:	0007      	movs	r7, r0
    9856:	d00c      	beq.n	9872 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x9d2>
    9858:	f1a6 0510 	sub.w	r5, r6, #16
    985c:	f04f 0400 	mov.w	r4, #0
    9860:	8868      	ldrh	r0, [r5, #2]
    9862:	05c0      	lsls	r0, r0, #23
    9864:	d50a      	bpl.n	987c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x9dc>
    9866:	6870      	ldr	r0, [r6, #4]
    9868:	f8a0 40b4 	strh.w	r4, [r0, #180]	; 0xb4
    986c:	f880 41dc 	strb.w	r4, [r0, #476]	; 0x1dc
    9870:	e009      	b.n	9886 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x9e6>
    9872:	f640 515c 	movw	r1, #3420	; 0xd5c
    9876:	2031      	movs	r0, #49	; 0x31
    9878:	f7fb fc6c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    987c:	6871      	ldr	r1, [r6, #4]
    987e:	f831 0fb4 	ldrh.w	r0, [r1, #180]!
    9882:	1c40      	adds	r0, r0, #1
    9884:	8008      	strh	r0, [r1, #0]
    9886:	f001 f9df 	bl	ac48 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1da8>
    988a:	f04f 0901 	mov.w	r9, #1
    988e:	b348      	cbz	r0, 98e4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa44>
    9890:	8868      	ldrh	r0, [r5, #2]
    9892:	0500      	lsls	r0, r0, #20
    9894:	d506      	bpl.n	98a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa04>
    9896:	6870      	ldr	r0, [r6, #4]
    9898:	f890 108c 	ldrb.w	r1, [r0, #140]	; 0x8c
    989c:	b111      	cbz	r1, 98a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa04>
    989e:	f8c0 40a8 	str.w	r4, [r0, #168]	; 0xa8
    98a2:	e01f      	b.n	98e4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa44>
    98a4:	6871      	ldr	r1, [r6, #4]
    98a6:	f8d1 00a8 	ldr.w	r0, [r1, #168]	; 0xa8
    98aa:	1c40      	adds	r0, r0, #1
    98ac:	f8c1 00a8 	str.w	r0, [r1, #168]	; 0xa8
    98b0:	f8d1 20ac 	ldr.w	r2, [r1, #172]	; 0xac
    98b4:	4282      	cmp	r2, r0
    98b6:	d301      	bcc.n	98bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa1c>
    98b8:	1a13      	subs	r3, r2, r0
    98ba:	e000      	b.n	98be <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa1e>
    98bc:	2300      	movs	r3, #0
    98be:	f8b5 c004 	ldrh.w	ip, [r5, #4]
    98c2:	f10c 0c05 	add.w	ip, ip, #5
    98c6:	4563      	cmp	r3, ip
    98c8:	d801      	bhi.n	98ce <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa2e>
    98ca:	f881 90b2 	strb.w	r9, [r1, #178]	; 0xb2
    98ce:	4290      	cmp	r0, r2
    98d0:	d308      	bcc.n	98e4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa44>
    98d2:	f501 709d 	add.w	r0, r1, #314	; 0x13a
    98d6:	220c      	movs	r2, #12
    98d8:	f8c1 40a8 	str.w	r4, [r1, #168]	; 0xa8
    98dc:	f7fd fc62 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    98e0:	f7fd fd32 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    98e4:	8868      	ldrh	r0, [r5, #2]
    98e6:	f04f 0b02 	mov.w	fp, #2
    98ea:	f410 7f40 	tst.w	r0, #768	; 0x300
    98ee:	d00e      	beq.n	990e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa6e>
    98f0:	6870      	ldr	r0, [r6, #4]
    98f2:	f890 108a 	ldrb.w	r1, [r0, #138]	; 0x8a
    98f6:	b111      	cbz	r1, 98fe <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa5e>
    98f8:	2903      	cmp	r1, #3
    98fa:	d108      	bne.n	990e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa6e>
    98fc:	e002      	b.n	9904 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa64>
    98fe:	f880 908a 	strb.w	r9, [r0, #138]	; 0x8a
    9902:	e001      	b.n	9908 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa68>
    9904:	f880 b08a 	strb.w	fp, [r0, #138]	; 0x8a
    9908:	2101      	movs	r1, #1
    990a:	f7fe fea7 	bl	865c <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI>
    990e:	6870      	ldr	r0, [r6, #4]
    9910:	46b0      	mov	r8, r6
    9912:	f890 108a 	ldrb.w	r1, [r0, #138]	; 0x8a
    9916:	2901      	cmp	r1, #1
    9918:	d104      	bne.n	9924 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa84>
    991a:	8869      	ldrh	r1, [r5, #2]
    991c:	0549      	lsls	r1, r1, #21
    991e:	d501      	bpl.n	9924 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa84>
    9920:	f880 b08a 	strb.w	fp, [r0, #138]	; 0x8a
    9924:	9900      	ldr	r1, [sp, #0]
    9926:	2900      	cmp	r1, #0
    9928:	d179      	bne.n	9a1e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb7e>
    992a:	78a9      	ldrb	r1, [r5, #2]
    992c:	0649      	lsls	r1, r1, #25
    992e:	d502      	bpl.n	9936 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xa96>
    9930:	f8a0 41f0 	strh.w	r4, [r0, #496]	; 0x1f0
    9934:	e004      	b.n	9940 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xaa0>
    9936:	f8b0 11f0 	ldrh.w	r1, [r0, #496]	; 0x1f0
    993a:	1c49      	adds	r1, r1, #1
    993c:	f8a0 11f0 	strh.w	r1, [r0, #496]	; 0x1f0
    9940:	4650      	mov	r0, sl
    9942:	f7ff fdad 	bl	94a0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x600>
    9946:	ea40 000a 	orr.w	r0, r0, sl
    994a:	4682      	mov	sl, r0
    994c:	f7ff fd28 	bl	93a0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x500>
    9950:	f8d8 6004 	ldr.w	r6, [r8, #4]
    9954:	f8b6 01d0 	ldrh.w	r0, [r6, #464]	; 0x1d0
    9958:	1c40      	adds	r0, r0, #1
    995a:	f8a6 01d0 	strh.w	r0, [r6, #464]	; 0x1d0
    995e:	f896 01d4 	ldrb.w	r0, [r6, #468]	; 0x1d4
    9962:	b128      	cbz	r0, 9970 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xad0>
    9964:	f7fc fc54 	bl	6210 <sym_ZWLSMB33C6NPFOBZGVPV4PN4UKQGSPLLR4WLDFI>
    9968:	b1b0      	cbz	r0, 9998 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xaf8>
    996a:	f8a6 41d0 	strh.w	r4, [r6, #464]	; 0x1d0
    996e:	e013      	b.n	9998 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xaf8>
    9970:	f7fc faee 	bl	5f50 <sym_Q3RLGT2MQM6S4H2ODVJHPDU44HGSYVXJV7676ZY>
    9974:	b108      	cbz	r0, 997a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xada>
    9976:	f8a6 41d0 	strh.w	r4, [r6, #464]	; 0x1d0
    997a:	f7fc fae3 	bl	5f44 <sym_IHWHOAENEU2EYZP2UWQTUC6SSXGS5NNQSIFSEAQ>
    997e:	b158      	cbz	r0, 9998 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xaf8>
    9980:	f896 01dc 	ldrb.w	r0, [r6, #476]	; 0x1dc
    9984:	1c40      	adds	r0, r0, #1
    9986:	b2c0      	uxtb	r0, r0
    9988:	f886 01dc 	strb.w	r0, [r6, #476]	; 0x1dc
    998c:	2802      	cmp	r0, #2
    998e:	d903      	bls.n	9998 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xaf8>
    9990:	f8a6 41d0 	strh.w	r4, [r6, #464]	; 0x1d0
    9994:	f886 41dc 	strb.w	r4, [r6, #476]	; 0x1dc
    9998:	f8d8 0004 	ldr.w	r0, [r8, #4]
    999c:	4646      	mov	r6, r8
    999e:	2301      	movs	r3, #1
    99a0:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    99a4:	2100      	movs	r1, #0
    99a6:	3078      	adds	r0, #120	; 0x78
    99a8:	f004 fdd7 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    99ac:	b920      	cbnz	r0, 99b8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb18>
    99ae:	6870      	ldr	r0, [r6, #4]
    99b0:	f890 0086 	ldrb.w	r0, [r0, #134]	; 0x86
    99b4:	280c      	cmp	r0, #12
    99b6:	d160      	bne.n	9a7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbda>
    99b8:	6870      	ldr	r0, [r6, #4]
    99ba:	2301      	movs	r3, #1
    99bc:	2100      	movs	r1, #0
    99be:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    99c2:	3078      	adds	r0, #120	; 0x78
    99c4:	f004 fdc9 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    99c8:	b350      	cbz	r0, 9a20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb80>
    99ca:	6870      	ldr	r0, [r6, #4]
    99cc:	2301      	movs	r3, #1
    99ce:	2100      	movs	r1, #0
    99d0:	f890 2088 	ldrb.w	r2, [r0, #136]	; 0x88
    99d4:	3078      	adds	r0, #120	; 0x78
    99d6:	f004 fdc0 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    99da:	b308      	cbz	r0, 9a20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb80>
    99dc:	6870      	ldr	r0, [r6, #4]
    99de:	f890 108a 	ldrb.w	r1, [r0, #138]	; 0x8a
    99e2:	2902      	cmp	r1, #2
    99e4:	d149      	bne.n	9a7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbda>
    99e6:	f890 01dc 	ldrb.w	r0, [r0, #476]	; 0x1dc
    99ea:	b9c8      	cbnz	r0, 9a20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb80>
    99ec:	4638      	mov	r0, r7
    99ee:	f004 f84d 	bl	da8c <sym_B62EJKCCJ4JFC5I4BFTUJG7GNOKGWQ4KKFBS6RI>
    99f2:	b1a8      	cbz	r0, 9a20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb80>
    99f4:	6870      	ldr	r0, [r6, #4]
    99f6:	3078      	adds	r0, #120	; 0x78
    99f8:	f006 fa59 	bl	feae <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1e>
    99fc:	b980      	cbnz	r0, 9a20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb80>
    99fe:	6871      	ldr	r1, [r6, #4]
    9a00:	f8b1 01ca 	ldrh.w	r0, [r1, #458]	; 0x1ca
    9a04:	2801      	cmp	r0, #1
    9a06:	d938      	bls.n	9a7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbda>
    9a08:	f881 91d2 	strb.w	r9, [r1, #466]	; 0x1d2
    9a0c:	f8b1 00b6 	ldrh.w	r0, [r1, #182]	; 0xb6
    9a10:	f8b1 20b4 	ldrh.w	r2, [r1, #180]	; 0xb4
    9a14:	1e83      	subs	r3, r0, #2
    9a16:	429a      	cmp	r2, r3
    9a18:	db03      	blt.n	9a22 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb82>
    9a1a:	2001      	movs	r0, #1
    9a1c:	e004      	b.n	9a28 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb88>
    9a1e:	e01d      	b.n	9a5c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbbc>
    9a20:	e02b      	b.n	9a7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbda>
    9a22:	1a80      	subs	r0, r0, r2
    9a24:	1e40      	subs	r0, r0, #1
    9a26:	b280      	uxth	r0, r0
    9a28:	f8b1 21d0 	ldrh.w	r2, [r1, #464]	; 0x1d0
    9a2c:	88ab      	ldrh	r3, [r5, #4]
    9a2e:	429a      	cmp	r2, r3
    9a30:	d301      	bcc.n	9a36 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb96>
    9a32:	2201      	movs	r2, #1
    9a34:	e002      	b.n	9a3c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xb9c>
    9a36:	1a9a      	subs	r2, r3, r2
    9a38:	1c52      	adds	r2, r2, #1
    9a3a:	b292      	uxth	r2, r2
    9a3c:	4290      	cmp	r0, r2
    9a3e:	d900      	bls.n	9a42 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xba2>
    9a40:	4610      	mov	r0, r2
    9a42:	2801      	cmp	r0, #1
    9a44:	d102      	bne.n	9a4c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xbac>
    9a46:	bf00      	nop
    9a48:	f881 41d2 	strb.w	r4, [r1, #466]	; 0x1d2
    9a4c:	6871      	ldr	r1, [r6, #4]
    9a4e:	f8b1 207c 	ldrh.w	r2, [r1, #124]	; 0x7c
    9a52:	4410      	add	r0, r2
    9a54:	f8a1 01cc 	strh.w	r0, [r1, #460]	; 0x1cc
    9a58:	f001 f9ca 	bl	adf0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f50>
    9a5c:	78a8      	ldrb	r0, [r5, #2]
    9a5e:	4652      	mov	r2, sl
    9a60:	f3c0 1180 	ubfx	r1, r0, #6, #1
    9a64:	9800      	ldr	r0, [sp, #0]
    9a66:	f001 f903 	bl	ac70 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1dd0>
    9a6a:	f8d8 0004 	ldr.w	r0, [r8, #4]
    9a6e:	f880 41d3 	strb.w	r4, [r0, #467]	; 0x1d3
    9a72:	e8bd 5ffc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    9a76:	f7fc b9ad 	b.w	5dd4 <sym_54CHYGRI3UHSVLN5ZOGJESXNRISJW5CS4IYBN7Y>
    9a7a:	2001      	movs	r0, #1
    9a7c:	6871      	ldr	r1, [r6, #4]
    9a7e:	e7e3      	b.n	9a48 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xba8>
    9a80:	20000170 	.word	0x20000170
    9a84:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    9a86:	4c58      	ldr	r4, [pc, #352]	; (9be8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd48>)
    9a88:	2301      	movs	r3, #1
    9a8a:	2100      	movs	r1, #0
    9a8c:	6860      	ldr	r0, [r4, #4]
    9a8e:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    9a92:	3078      	adds	r0, #120	; 0x78
    9a94:	f004 fd61 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9a98:	2800      	cmp	r0, #0
    9a9a:	d07c      	beq.n	9b96 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xcf6>
    9a9c:	6860      	ldr	r0, [r4, #4]
    9a9e:	f890 112b 	ldrb.w	r1, [r0, #299]	; 0x12b
    9aa2:	2500      	movs	r5, #0
    9aa4:	b139      	cbz	r1, 9ab6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xc16>
    9aa6:	2100      	movs	r1, #0
    9aa8:	200e      	movs	r0, #14
    9aaa:	f000 f89f 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9aae:	6860      	ldr	r0, [r4, #4]
    9ab0:	f880 512b 	strb.w	r5, [r0, #299]	; 0x12b
    9ab4:	e096      	b.n	9be4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd44>
    9ab6:	f890 112a 	ldrb.w	r1, [r0, #298]	; 0x12a
    9aba:	b119      	cbz	r1, 9ac4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xc24>
    9abc:	f890 10c5 	ldrb.w	r1, [r0, #197]	; 0xc5
    9ac0:	0789      	lsls	r1, r1, #30
    9ac2:	d016      	beq.n	9af2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xc52>
    9ac4:	f890 111a 	ldrb.w	r1, [r0, #282]	; 0x11a
    9ac8:	f88d 1004 	strb.w	r1, [sp, #4]
    9acc:	9901      	ldr	r1, [sp, #4]
    9ace:	9101      	str	r1, [sp, #4]
    9ad0:	f89d 1004 	ldrb.w	r1, [sp, #4]
    9ad4:	b141      	cbz	r1, 9ae8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xc48>
    9ad6:	f890 111b 	ldrb.w	r1, [r0, #283]	; 0x11b
    9ada:	f88d 1000 	strb.w	r1, [sp]
    9ade:	9900      	ldr	r1, [sp, #0]
    9ae0:	9100      	str	r1, [sp, #0]
    9ae2:	f89d 1000 	ldrb.w	r1, [sp]
    9ae6:	b189      	cbz	r1, 9b0c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xc6c>
    9ae8:	f890 1124 	ldrb.w	r1, [r0, #292]	; 0x124
    9aec:	2901      	cmp	r1, #1
    9aee:	d030      	beq.n	9b52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xcb2>
    9af0:	e072      	b.n	9bd8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd38>
    9af2:	2100      	movs	r1, #0
    9af4:	200c      	movs	r0, #12
    9af6:	f000 f879 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9afa:	6860      	ldr	r0, [r4, #4]
    9afc:	f810 1fc5 	ldrb.w	r1, [r0, #197]!
    9b00:	f041 0101 	orr.w	r1, r1, #1
    9b04:	7001      	strb	r1, [r0, #0]
    9b06:	f880 5065 	strb.w	r5, [r0, #101]	; 0x65
    9b0a:	e06b      	b.n	9be4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd44>
    9b0c:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    9b10:	2924      	cmp	r1, #36	; 0x24
    9b12:	d01c      	beq.n	9b4e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xcae>
    9b14:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
    9b18:	2924      	cmp	r1, #36	; 0x24
    9b1a:	d018      	beq.n	9b4e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xcae>
    9b1c:	f05f 0300 	movs.w	r3, #0
    9b20:	f200 2276 	addw	r2, r0, #630	; 0x276
    9b24:	f500 718d 	add.w	r1, r0, #282	; 0x11a
    9b28:	f005 f9d6 	bl	eed8 <sym_436OKKOGR27QX7FMSZKYSEYLCMU4ZXR5RN4XUBY>
    9b2c:	6860      	ldr	r0, [r4, #4]
    9b2e:	f880 511a 	strb.w	r5, [r0, #282]	; 0x11a
    9b32:	2100      	movs	r1, #0
    9b34:	2014      	movs	r0, #20
    9b36:	f000 f859 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9b3a:	6861      	ldr	r1, [r4, #4]
    9b3c:	f101 0030 	add.w	r0, r1, #48	; 0x30
    9b40:	8bc2      	ldrh	r2, [r0, #30]
    9b42:	f8a1 210e 	strh.w	r2, [r1, #270]	; 0x10e
    9b46:	8c40      	ldrh	r0, [r0, #34]	; 0x22
    9b48:	f8a1 0110 	strh.w	r0, [r1, #272]	; 0x110
    9b4c:	e04a      	b.n	9be4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd44>
    9b4e:	2301      	movs	r3, #1
    9b50:	e7e6      	b.n	9b20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xc80>
    9b52:	f890 1125 	ldrb.w	r1, [r0, #293]	; 0x125
    9b56:	f88d 1000 	strb.w	r1, [sp]
    9b5a:	9900      	ldr	r1, [sp, #0]
    9b5c:	9100      	str	r1, [sp, #0]
    9b5e:	f89d 1000 	ldrb.w	r1, [sp]
    9b62:	bb31      	cbnz	r1, 9bb2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd12>
    9b64:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9b68:	2301      	movs	r3, #1
    9b6a:	210b      	movs	r1, #11
    9b6c:	3078      	adds	r0, #120	; 0x78
    9b6e:	f004 fcf4 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9b72:	b9f0      	cbnz	r0, 9bb2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd12>
    9b74:	6860      	ldr	r0, [r4, #4]
    9b76:	f890 006e 	ldrb.w	r0, [r0, #110]	; 0x6e
    9b7a:	f006 f9a0 	bl	febe <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x2e>
    9b7e:	4605      	mov	r5, r0
    9b80:	6860      	ldr	r0, [r4, #4]
    9b82:	f890 006f 	ldrb.w	r0, [r0, #111]	; 0x6f
    9b86:	f006 f99a 	bl	febe <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x2e>
    9b8a:	4606      	mov	r6, r0
    9b8c:	6860      	ldr	r0, [r4, #4]
    9b8e:	f890 1126 	ldrb.w	r1, [r0, #294]	; 0x126
    9b92:	4628      	mov	r0, r5
    9b94:	e000      	b.n	9b98 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xcf8>
    9b96:	e020      	b.n	9bda <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd3a>
    9b98:	f006 f99c 	bl	fed4 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x44>
    9b9c:	b150      	cbz	r0, 9bb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd14>
    9b9e:	6860      	ldr	r0, [r4, #4]
    9ba0:	f890 1127 	ldrb.w	r1, [r0, #295]	; 0x127
    9ba4:	4630      	mov	r0, r6
    9ba6:	f006 f995 	bl	fed4 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x44>
    9baa:	b118      	cbz	r0, 9bb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd14>
    9bac:	2000      	movs	r0, #0
    9bae:	f000 f929 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    9bb2:	e011      	b.n	9bd8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd38>
    9bb4:	6860      	ldr	r0, [r4, #4]
    9bb6:	2301      	movs	r3, #1
    9bb8:	2103      	movs	r1, #3
    9bba:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9bbe:	3078      	adds	r0, #120	; 0x78
    9bc0:	f004 fccb 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9bc4:	b940      	cbnz	r0, 9bd8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd38>
    9bc6:	6860      	ldr	r0, [r4, #4]
    9bc8:	2301      	movs	r3, #1
    9bca:	2102      	movs	r1, #2
    9bcc:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9bd0:	3078      	adds	r0, #120	; 0x78
    9bd2:	f004 fcc2 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9bd6:	b108      	cbz	r0, 9bdc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd3c>
    9bd8:	2000      	movs	r0, #0
    9bda:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    9bdc:	2100      	movs	r1, #0
    9bde:	2016      	movs	r0, #22
    9be0:	f000 f804 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9be4:	2001      	movs	r0, #1
    9be6:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    9be8:	20000170 	.word	0x20000170
    9bec:	b570      	push	{r4, r5, r6, lr}
    9bee:	4c0d      	ldr	r4, [pc, #52]	; (9c24 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd84>)
    9bf0:	4606      	mov	r6, r0
    9bf2:	460d      	mov	r5, r1
    9bf4:	6860      	ldr	r0, [r4, #4]
    9bf6:	3078      	adds	r0, #120	; 0x78
    9bf8:	f006 f959 	bl	feae <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1e>
    9bfc:	b120      	cbz	r0, 9c08 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd68>
    9bfe:	f640 2184 	movw	r1, #2692	; 0xa84
    9c02:	2031      	movs	r0, #49	; 0x31
    9c04:	f7fb faa6 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    9c08:	6862      	ldr	r2, [r4, #4]
    9c0a:	2000      	movs	r0, #0
    9c0c:	f882 610c 	strb.w	r6, [r2, #268]	; 0x10c
    9c10:	b115      	cbz	r5, 9c18 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd78>
    9c12:	f8a2 00c0 	strh.w	r0, [r2, #192]	; 0xc0
    9c16:	bd70      	pop	{r4, r5, r6, pc}
    9c18:	f822 0fba 	strh.w	r0, [r2, #186]!
    9c1c:	2001      	movs	r0, #1
    9c1e:	7110      	strb	r0, [r2, #4]
    9c20:	bd70      	pop	{r4, r5, r6, pc}
    9c22:	0000      	.short	0x0000
    9c24:	20000170 	.word	0x20000170
    9c28:	b538      	push	{r3, r4, r5, lr}
    9c2a:	4c1f      	ldr	r4, [pc, #124]	; (9ca8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe08>)
    9c2c:	2500      	movs	r5, #0
    9c2e:	6860      	ldr	r0, [r4, #4]
    9c30:	f890 1258 	ldrb.w	r1, [r0, #600]	; 0x258
    9c34:	2901      	cmp	r1, #1
    9c36:	d00a      	beq.n	9c4e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xdae>
    9c38:	2902      	cmp	r1, #2
    9c3a:	d133      	bne.n	9ca4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe04>
    9c3c:	f890 10c4 	ldrb.w	r1, [r0, #196]	; 0xc4
    9c40:	b1d9      	cbz	r1, 9c7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xdda>
    9c42:	2106      	movs	r1, #6
    9c44:	f880 110e 	strb.w	r1, [r0, #270]	; 0x10e
    9c48:	2101      	movs	r1, #1
    9c4a:	2002      	movs	r0, #2
    9c4c:	e025      	b.n	9c9a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xdfa>
    9c4e:	f890 11be 	ldrb.w	r1, [r0, #446]	; 0x1be
    9c52:	f88d 1000 	strb.w	r1, [sp]
    9c56:	9900      	ldr	r1, [sp, #0]
    9c58:	9100      	str	r1, [sp, #0]
    9c5a:	f89d 1000 	ldrb.w	r1, [sp]
    9c5e:	2900      	cmp	r1, #0
    9c60:	d120      	bne.n	9ca4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe04>
    9c62:	f100 03f0 	add.w	r3, r0, #240	; 0xf0
    9c66:	f500 71f0 	add.w	r1, r0, #480	; 0x1e0
    9c6a:	2200      	movs	r2, #0
    9c6c:	f200 2059 	addw	r0, r0, #601	; 0x259
    9c70:	f004 fc2b 	bl	e4ca <sym_L64WJ6W52HQBFQCTPO5LHELOWQEJNMIWLQKG6JY>
    9c74:	2101      	movs	r1, #1
    9c76:	2005      	movs	r0, #5
    9c78:	e00f      	b.n	9c9a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xdfa>
    9c7a:	2203      	movs	r2, #3
    9c7c:	2106      	movs	r1, #6
    9c7e:	f880 210b 	strb.w	r2, [r0, #267]	; 0x10b
    9c82:	f880 110a 	strb.w	r1, [r0, #266]	; 0x10a
    9c86:	f890 00d4 	ldrb.w	r0, [r0, #212]	; 0xd4
    9c8a:	0880      	lsrs	r0, r0, #2
    9c8c:	f010 0f01 	tst.w	r0, #1
    9c90:	d001      	beq.n	9c96 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xdf6>
    9c92:	2011      	movs	r0, #17
    9c94:	e000      	b.n	9c98 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xdf8>
    9c96:	200d      	movs	r0, #13
    9c98:	2101      	movs	r1, #1
    9c9a:	f7ff ffa7 	bl	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    9c9e:	6860      	ldr	r0, [r4, #4]
    9ca0:	f880 5258 	strb.w	r5, [r0, #600]	; 0x258
    9ca4:	bd38      	pop	{r3, r4, r5, pc}
    9ca6:	0000      	.short	0x0000
    9ca8:	20000170 	.word	0x20000170
    9cac:	b570      	push	{r4, r5, r6, lr}
    9cae:	4b2b      	ldr	r3, [pc, #172]	; (9d5c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xebc>)
    9cb0:	4602      	mov	r2, r0
    9cb2:	8858      	ldrh	r0, [r3, #2]
    9cb4:	4310      	orrs	r0, r2
    9cb6:	8058      	strh	r0, [r3, #2]
    9cb8:	f103 0010 	add.w	r0, r3, #16
    9cbc:	2a40      	cmp	r2, #64	; 0x40
    9cbe:	6840      	ldr	r0, [r0, #4]
    9cc0:	d00d      	beq.n	9cde <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe3e>
    9cc2:	0796      	lsls	r6, r2, #30
    9cc4:	f04f 0500 	mov.w	r5, #0
    9cc8:	f04f 0401 	mov.w	r4, #1
    9ccc:	ea4f 76c2 	mov.w	r6, r2, lsl #31
    9cd0:	d50c      	bpl.n	9cec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe4c>
    9cd2:	b14e      	cbz	r6, 9ce8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe48>
    9cd4:	f640 41c9 	movw	r1, #3273	; 0xcc9
    9cd8:	2031      	movs	r0, #49	; 0x31
    9cda:	f7fb fa3b 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    9cde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    9ce2:	2104      	movs	r1, #4
    9ce4:	f7fe bcba 	b.w	865c <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI>
    9ce8:	6099      	str	r1, [r3, #8]
    9cea:	e01c      	b.n	9d26 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe86>
    9cec:	b1c6      	cbz	r6, 9d20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe80>
    9cee:	60d9      	str	r1, [r3, #12]
    9cf0:	78c9      	ldrb	r1, [r1, #3]
    9cf2:	2906      	cmp	r1, #6
    9cf4:	d002      	beq.n	9cfc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe5c>
    9cf6:	290b      	cmp	r1, #11
    9cf8:	d112      	bne.n	9d20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe80>
    9cfa:	e009      	b.n	9d10 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe70>
    9cfc:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    9d00:	2917      	cmp	r1, #23
    9d02:	d10d      	bne.n	9d20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe80>
    9d04:	2100      	movs	r1, #0
    9d06:	e9c0 1138 	strd	r1, r1, [r0, #224]	; 0xe0
    9d0a:	f880 408b 	strb.w	r4, [r0, #139]	; 0x8b
    9d0e:	e007      	b.n	9d20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe80>
    9d10:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    9d14:	2911      	cmp	r1, #17
    9d16:	d103      	bne.n	9d20 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe80>
    9d18:	f880 508b 	strb.w	r5, [r0, #139]	; 0x8b
    9d1c:	f880 40c4 	strb.w	r4, [r0, #196]	; 0xc4
    9d20:	0791      	lsls	r1, r2, #30
    9d22:	d516      	bpl.n	9d52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeb2>
    9d24:	6899      	ldr	r1, [r3, #8]
    9d26:	78c9      	ldrb	r1, [r1, #3]
    9d28:	2905      	cmp	r1, #5
    9d2a:	d002      	beq.n	9d32 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xe92>
    9d2c:	290b      	cmp	r1, #11
    9d2e:	d110      	bne.n	9d52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeb2>
    9d30:	e009      	b.n	9d46 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xea6>
    9d32:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    9d36:	2915      	cmp	r1, #21
    9d38:	d10b      	bne.n	9d52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeb2>
    9d3a:	2100      	movs	r1, #0
    9d3c:	e9c0 113a 	strd	r1, r1, [r0, #232]	; 0xe8
    9d40:	f880 408c 	strb.w	r4, [r0, #140]	; 0x8c
    9d44:	e005      	b.n	9d52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeb2>
    9d46:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    9d4a:	2910      	cmp	r1, #16
    9d4c:	d101      	bne.n	9d52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeb2>
    9d4e:	f880 508c 	strb.w	r5, [r0, #140]	; 0x8c
    9d52:	0690      	lsls	r0, r2, #26
    9d54:	d501      	bpl.n	9d5a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeba>
    9d56:	2008      	movs	r0, #8
    9d58:	7058      	strb	r0, [r3, #1]
    9d5a:	bd70      	pop	{r4, r5, r6, pc}
    9d5c:	20000160 	.word	0x20000160
    9d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9d64:	4c26      	ldr	r4, [pc, #152]	; (9e00 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf60>)
    9d66:	2501      	movs	r5, #1
    9d68:	6862      	ldr	r2, [r4, #4]
    9d6a:	f892 0276 	ldrb.w	r0, [r2, #630]	; 0x276
    9d6e:	b108      	cbz	r0, 9d74 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xed4>
    9d70:	2701      	movs	r7, #1
    9d72:	e000      	b.n	9d76 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xed6>
    9d74:	2700      	movs	r7, #0
    9d76:	f892 1277 	ldrb.w	r1, [r2, #631]	; 0x277
    9d7a:	b109      	cbz	r1, 9d80 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xee0>
    9d7c:	2601      	movs	r6, #1
    9d7e:	e000      	b.n	9d82 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xee2>
    9d80:	2600      	movs	r6, #0
    9d82:	b90f      	cbnz	r7, 9d88 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xee8>
    9d84:	f892 006e 	ldrb.w	r0, [r2, #110]	; 0x6e
    9d88:	b90e      	cbnz	r6, 9d8e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xeee>
    9d8a:	f892 106f 	ldrb.w	r1, [r2, #111]	; 0x6f
    9d8e:	f102 0366 	add.w	r3, r2, #102	; 0x66
    9d92:	7218      	strb	r0, [r3, #8]
    9d94:	7259      	strb	r1, [r3, #9]
    9d96:	20ff      	movs	r0, #255	; 0xff
    9d98:	7298      	strb	r0, [r3, #10]
    9d9a:	f892 0124 	ldrb.w	r0, [r2, #292]	; 0x124
    9d9e:	2801      	cmp	r0, #1
    9da0:	d001      	beq.n	9da6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf06>
    9da2:	b907      	cbnz	r7, 9da6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf06>
    9da4:	b116      	cbz	r6, 9dac <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf0c>
    9da6:	2000      	movs	r0, #0
    9da8:	f000 f82c 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    9dac:	6860      	ldr	r0, [r4, #4]
    9dae:	3030      	adds	r0, #48	; 0x30
    9db0:	f005 f903 	bl	efba <sym_2T6ENJKRE7MWBMC42J5L6S3EMUNPYUXCPAHD23A>
    9db4:	4607      	mov	r7, r0
    9db6:	2105      	movs	r1, #5
    9db8:	6860      	ldr	r0, [r4, #4]
    9dba:	f7fe fc4f 	bl	865c <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI>
    9dbe:	6860      	ldr	r0, [r4, #4]
    9dc0:	3030      	adds	r0, #48	; 0x30
    9dc2:	f005 f8fa 	bl	efba <sym_2T6ENJKRE7MWBMC42J5L6S3EMUNPYUXCPAHD23A>
    9dc6:	4606      	mov	r6, r0
    9dc8:	42b7      	cmp	r7, r6
    9dca:	d20a      	bcs.n	9de2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf42>
    9dcc:	f7f8 fd34 	bl	2838 <sym_HVFGTYCGAECGUJHOFSPMGUV2G4PTWWUYTJVAPNA>
    9dd0:	4601      	mov	r1, r0
    9dd2:	1bf0      	subs	r0, r6, r7
    9dd4:	2865      	cmp	r0, #101	; 0x65
    9dd6:	d200      	bcs.n	9dda <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf3a>
    9dd8:	2065      	movs	r0, #101	; 0x65
    9dda:	f7f8 fc4f 	bl	267c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ>
    9dde:	b100      	cbz	r0, 9de2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf42>
    9de0:	2500      	movs	r5, #0
    9de2:	6860      	ldr	r0, [r4, #4]
    9de4:	f005 f893 	bl	ef0e <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q>
    9de8:	b138      	cbz	r0, 9dfa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf5a>
    9dea:	6863      	ldr	r3, [r4, #4]
    9dec:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    9df0:	8818      	ldrh	r0, [r3, #0]
    9df2:	f103 0130 	add.w	r1, r3, #48	; 0x30
    9df6:	f005 f847 	bl	ee88 <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY>
    9dfa:	4628      	mov	r0, r5
    9dfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9e00:	20000170 	.word	0x20000170
    9e04:	b510      	push	{r4, lr}
    9e06:	4c11      	ldr	r4, [pc, #68]	; (9e4c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfac>)
    9e08:	6861      	ldr	r1, [r4, #4]
    9e0a:	880a      	ldrh	r2, [r1, #0]
    9e0c:	f8a1 2188 	strh.w	r2, [r1, #392]	; 0x188
    9e10:	f881 0186 	strb.w	r0, [r1, #390]	; 0x186
    9e14:	f891 006e 	ldrb.w	r0, [r1, #110]	; 0x6e
    9e18:	f006 f851 	bl	febe <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x2e>
    9e1c:	6861      	ldr	r1, [r4, #4]
    9e1e:	f881 018a 	strb.w	r0, [r1, #394]	; 0x18a
    9e22:	f891 006f 	ldrb.w	r0, [r1, #111]	; 0x6f
    9e26:	f006 f84a 	bl	febe <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x2e>
    9e2a:	6861      	ldr	r1, [r4, #4]
    9e2c:	2211      	movs	r2, #17
    9e2e:	f881 018b 	strb.w	r0, [r1, #395]	; 0x18b
    9e32:	f501 70be 	add.w	r0, r1, #380	; 0x17c
    9e36:	f7fd f9b5 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    9e3a:	6861      	ldr	r1, [r4, #4]
    9e3c:	2000      	movs	r0, #0
    9e3e:	f881 0124 	strb.w	r0, [r1, #292]	; 0x124
    9e42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9e46:	f7fd ba7f 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    9e4a:	0000      	.short	0x0000
    9e4c:	20000170 	.word	0x20000170
    9e50:	b570      	push	{r4, r5, r6, lr}
    9e52:	4d0f      	ldr	r5, [pc, #60]	; (9e90 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xff0>)
    9e54:	686c      	ldr	r4, [r5, #4]
    9e56:	f894 1085 	ldrb.w	r1, [r4, #133]	; 0x85
    9e5a:	2920      	cmp	r1, #32
    9e5c:	d002      	beq.n	9e64 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfc4>
    9e5e:	2927      	cmp	r1, #39	; 0x27
    9e60:	d003      	beq.n	9e6a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfca>
    9e62:	e011      	b.n	9e88 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfe8>
    9e64:	f7ff ffce 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    9e68:	e008      	b.n	9e7c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfdc>
    9e6a:	f894 2086 	ldrb.w	r2, [r4, #134]	; 0x86
    9e6e:	f104 0078 	add.w	r0, r4, #120	; 0x78
    9e72:	2301      	movs	r3, #1
    9e74:	210b      	movs	r1, #11
    9e76:	f004 fb70 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9e7a:	b138      	cbz	r0, 9e8c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfec>
    9e7c:	6869      	ldr	r1, [r5, #4]
    9e7e:	2000      	movs	r0, #0
    9e80:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    9e84:	f881 00be 	strb.w	r0, [r1, #190]	; 0xbe
    9e88:	2000      	movs	r0, #0
    9e8a:	bd70      	pop	{r4, r5, r6, pc}
    9e8c:	202a      	movs	r0, #42	; 0x2a
    9e8e:	e7e9      	b.n	9e64 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfc4>
    9e90:	20000170 	.word	0x20000170
    9e94:	b570      	push	{r4, r5, r6, lr}
    9e96:	4c17      	ldr	r4, [pc, #92]	; (9ef4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1054>)
    9e98:	2301      	movs	r3, #1
    9e9a:	2100      	movs	r1, #0
    9e9c:	6860      	ldr	r0, [r4, #4]
    9e9e:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9ea2:	3078      	adds	r0, #120	; 0x78
    9ea4:	f004 fb59 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9ea8:	b1b0      	cbz	r0, 9ed8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1038>
    9eaa:	f1a4 0510 	sub.w	r5, r4, #16
    9eae:	68e8      	ldr	r0, [r5, #12]
    9eb0:	f004 fdac 	bl	ea0c <sym_WMWALCDSCSGIPZVRYNPCN3Z65BL7HB3ZVUDUXCQ>
    9eb4:	6861      	ldr	r1, [r4, #4]
    9eb6:	f8a1 0274 	strh.w	r0, [r1, #628]	; 0x274
    9eba:	f8b1 107c 	ldrh.w	r1, [r1, #124]	; 0x7c
    9ebe:	f006 f817 	bl	fef0 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x60>
    9ec2:	b158      	cbz	r0, 9edc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x103c>
    9ec4:	6861      	ldr	r1, [r4, #4]
    9ec6:	2028      	movs	r0, #40	; 0x28
    9ec8:	2208      	movs	r2, #8
    9eca:	f881 00a6 	strb.w	r0, [r1, #166]	; 0xa6
    9ece:	f101 009d 	add.w	r0, r1, #157	; 0x9d
    9ed2:	f7fd f967 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    9ed6:	e00b      	b.n	9ef0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1050>
    9ed8:	2001      	movs	r0, #1
    9eda:	bd70      	pop	{r4, r5, r6, pc}
    9edc:	6861      	ldr	r1, [r4, #4]
    9ede:	68e8      	ldr	r0, [r5, #12]
    9ee0:	f201 2176 	addw	r1, r1, #630	; 0x276
    9ee4:	f004 fd8d 	bl	ea02 <sym_Z4ZI42RGZMV4HNY7AR3E37XXZ7IMFK22Y6ETFMA>
    9ee8:	6861      	ldr	r1, [r4, #4]
    9eea:	200b      	movs	r0, #11
    9eec:	f881 0086 	strb.w	r0, [r1, #134]	; 0x86
    9ef0:	2000      	movs	r0, #0
    9ef2:	bd70      	pop	{r4, r5, r6, pc}
    9ef4:	20000170 	.word	0x20000170
    9ef8:	b570      	push	{r4, r5, r6, lr}
    9efa:	4d2b      	ldr	r5, [pc, #172]	; (9fa8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1108>)
    9efc:	2301      	movs	r3, #1
    9efe:	2100      	movs	r1, #0
    9f00:	6868      	ldr	r0, [r5, #4]
    9f02:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9f06:	3078      	adds	r0, #120	; 0x78
    9f08:	f004 fb27 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9f0c:	b1d8      	cbz	r0, 9f46 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x10a6>
    9f0e:	f1a5 0410 	sub.w	r4, r5, #16
    9f12:	2100      	movs	r1, #0
    9f14:	68e0      	ldr	r0, [r4, #12]
    9f16:	f004 fd4c 	bl	e9b2 <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ>
    9f1a:	b1b0      	cbz	r0, 9f4a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x10aa>
    9f1c:	68e0      	ldr	r0, [r4, #12]
    9f1e:	6869      	ldr	r1, [r5, #4]
    9f20:	f8b0 000d 	ldrh.w	r0, [r0, #13]
    9f24:	f8a1 0274 	strh.w	r0, [r1, #628]	; 0x274
    9f28:	f8b1 107c 	ldrh.w	r1, [r1, #124]	; 0x7c
    9f2c:	f005 ffe0 	bl	fef0 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x60>
    9f30:	b178      	cbz	r0, 9f52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x10b2>
    9f32:	6869      	ldr	r1, [r5, #4]
    9f34:	2028      	movs	r0, #40	; 0x28
    9f36:	2208      	movs	r2, #8
    9f38:	f881 00a6 	strb.w	r0, [r1, #166]	; 0xa6
    9f3c:	f101 009d 	add.w	r0, r1, #157	; 0x9d
    9f40:	f7fd f930 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    9f44:	e02e      	b.n	9fa4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1104>
    9f46:	2001      	movs	r0, #1
    9f48:	bd70      	pop	{r4, r5, r6, pc}
    9f4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    9f4e:	f000 b8f5 	b.w	a13c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x129c>
    9f52:	68e0      	ldr	r0, [r4, #12]
    9f54:	f004 fd5d 	bl	ea12 <sym_O2B23O5JYMOMMFH6X6KNGJ752KMNUHBQLRFJPCA>
    9f58:	f004 fae2 	bl	e520 <sym_3GY4TYJRRJL4WNFV6XN3ATYT4MIF4FYTN3S33RI>
    9f5c:	4606      	mov	r6, r0
    9f5e:	6868      	ldr	r0, [r5, #4]
    9f60:	4631      	mov	r1, r6
    9f62:	f8c0 627c 	str.w	r6, [r0, #636]	; 0x27c
    9f66:	68e0      	ldr	r0, [r4, #12]
    9f68:	7900      	ldrb	r0, [r0, #4]
    9f6a:	f004 fc72 	bl	e852 <sym_NREHYZNNGMA6T4VUMP47EJMM5IU7BRHAZURXRLQ>
    9f6e:	6869      	ldr	r1, [r5, #4]
    9f70:	f8a1 0276 	strh.w	r0, [r1, #630]	; 0x276
    9f74:	68e0      	ldr	r0, [r4, #12]
    9f76:	4631      	mov	r1, r6
    9f78:	f8b0 0005 	ldrh.w	r0, [r0, #5]
    9f7c:	f004 fc65 	bl	e84a <sym_5SQGEOI2QIBONU3LMZVAMW3SSGU24TVE57VDLBA>
    9f80:	6869      	ldr	r1, [r5, #4]
    9f82:	f8c1 0278 	str.w	r0, [r1, #632]	; 0x278
    9f86:	68e0      	ldr	r0, [r4, #12]
    9f88:	f004 fd46 	bl	ea18 <sym_GKNOWO7GMUO66Z63YGKTWG2BRIW6TPGP7PUQ2RQ>
    9f8c:	6869      	ldr	r1, [r5, #4]
    9f8e:	f8a1 0280 	strh.w	r0, [r1, #640]	; 0x280
    9f92:	68e0      	ldr	r0, [r4, #12]
    9f94:	f004 fd43 	bl	ea1e <sym_CLMBK65KRQWY2JSWG7BYXAJVRACUXOCNFT2IPRY>
    9f98:	6869      	ldr	r1, [r5, #4]
    9f9a:	f8a1 0282 	strh.w	r0, [r1, #642]	; 0x282
    9f9e:	200d      	movs	r0, #13
    9fa0:	f881 0086 	strb.w	r0, [r1, #134]	; 0x86
    9fa4:	2000      	movs	r0, #0
    9fa6:	bd70      	pop	{r4, r5, r6, pc}
    9fa8:	20000170 	.word	0x20000170
    9fac:	b538      	push	{r3, r4, r5, lr}
    9fae:	4c2c      	ldr	r4, [pc, #176]	; (a060 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x11c0>)
    9fb0:	2301      	movs	r3, #1
    9fb2:	2100      	movs	r1, #0
    9fb4:	6860      	ldr	r0, [r4, #4]
    9fb6:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9fba:	3078      	adds	r0, #120	; 0x78
    9fbc:	f004 facd 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9fc0:	b970      	cbnz	r0, 9fe0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1140>
    9fc2:	6860      	ldr	r0, [r4, #4]
    9fc4:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    9fc8:	2a12      	cmp	r2, #18
    9fca:	d009      	beq.n	9fe0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1140>
    9fcc:	2301      	movs	r3, #1
    9fce:	2105      	movs	r1, #5
    9fd0:	3078      	adds	r0, #120	; 0x78
    9fd2:	f004 fac2 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    9fd6:	b108      	cbz	r0, 9fdc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x113c>
    9fd8:	2008      	movs	r0, #8
    9fda:	bd38      	pop	{r3, r4, r5, pc}
    9fdc:	2001      	movs	r0, #1
    9fde:	bd38      	pop	{r3, r4, r5, pc}
    9fe0:	6860      	ldr	r0, [r4, #4]
    9fe2:	f890 00c4 	ldrb.w	r0, [r0, #196]	; 0xc4
    9fe6:	b908      	cbnz	r0, 9fec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x114c>
    9fe8:	f7ff f85c 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    9fec:	4d1c      	ldr	r5, [pc, #112]	; (a060 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x11c0>)
    9fee:	6861      	ldr	r1, [r4, #4]
    9ff0:	3d10      	subs	r5, #16
    9ff2:	f501 71f0 	add.w	r1, r1, #480	; 0x1e0
    9ff6:	68e8      	ldr	r0, [r5, #12]
    9ff8:	f004 fd20 	bl	ea3c <sym_LSOEOXZGNVP5DB6ZYJ7WAAXWSU5HO7R25UQZZBQ>
    9ffc:	6861      	ldr	r1, [r4, #4]
    9ffe:	68e8      	ldr	r0, [r5, #12]
    a000:	f501 7180 	add.w	r1, r1, #256	; 0x100
    a004:	f004 fd11 	bl	ea2a <sym_3TJYOSQOHQD2677U7JVMG6ZM2AEKI337QVGY7TA>
    a008:	6861      	ldr	r1, [r4, #4]
    a00a:	f891 028c 	ldrb.w	r0, [r1, #652]	; 0x28c
    a00e:	f88d 0000 	strb.w	r0, [sp]
    a012:	9800      	ldr	r0, [sp, #0]
    a014:	9000      	str	r0, [sp, #0]
    a016:	f89d 0000 	ldrb.w	r0, [sp]
    a01a:	b120      	cbz	r0, a026 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1186>
    a01c:	f240 21a2 	movw	r1, #674	; 0x2a2
    a020:	2031      	movs	r0, #49	; 0x31
    a022:	f7fb f897 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a026:	8808      	ldrh	r0, [r1, #0]
    a028:	f8a1 028e 	strh.w	r0, [r1, #654]	; 0x28e
    a02c:	f501 7124 	add.w	r1, r1, #656	; 0x290
    a030:	68e8      	ldr	r0, [r5, #12]
    a032:	f004 fcfe 	bl	ea32 <sym_GVKSQ3HVAAAYIHJ3KPHNCAN4HXAZB6BCZZN5T2Q>
    a036:	6861      	ldr	r1, [r4, #4]
    a038:	68e8      	ldr	r0, [r5, #12]
    a03a:	f501 7126 	add.w	r1, r1, #664	; 0x298
    a03e:	f004 fcf1 	bl	ea24 <sym_RM2CYFWBBAMZ6QU7KT5244O7T6GTURMYRG2CBQQ>
    a042:	6861      	ldr	r1, [r4, #4]
    a044:	2207      	movs	r2, #7
    a046:	f501 7021 	add.w	r0, r1, #644	; 0x284
    a04a:	f7fd f8ab 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    a04e:	6861      	ldr	r1, [r4, #4]
    a050:	2014      	movs	r0, #20
    a052:	f881 0086 	strb.w	r0, [r1, #134]	; 0x86
    a056:	f7fd f977 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    a05a:	2000      	movs	r0, #0
    a05c:	bd38      	pop	{r3, r4, r5, pc}
    a05e:	0000      	.short	0x0000
    a060:	20000170 	.word	0x20000170
    a064:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    a066:	4c13      	ldr	r4, [pc, #76]	; (a0b4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1214>)
    a068:	6860      	ldr	r0, [r4, #4]
    a06a:	f890 0087 	ldrb.w	r0, [r0, #135]	; 0x87
    a06e:	07c0      	lsls	r0, r0, #31
    a070:	d001      	beq.n	a076 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x11d6>
    a072:	2001      	movs	r0, #1
    a074:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    a076:	480f      	ldr	r0, [pc, #60]	; (a0b4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1214>)
    a078:	4669      	mov	r1, sp
    a07a:	3810      	subs	r0, #16
    a07c:	68c0      	ldr	r0, [r0, #12]
    a07e:	f004 fce3 	bl	ea48 <sym_MMYJZLVXCKMFPUNAECUW6DM3QIRIH47IIFXKCBY>
    a082:	f001 fad9 	bl	b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>
    a086:	f644 122f 	movw	r2, #18735	; 0x492f
    a08a:	4010      	ands	r0, r2
    a08c:	e9dd 5200 	ldrd	r5, r2, [sp]
    a090:	6863      	ldr	r3, [r4, #4]
    a092:	4005      	ands	r5, r0
    a094:	f001 0106 	and.w	r1, r1, #6
    a098:	f843 5fd4 	str.w	r5, [r3, #212]!
    a09c:	400a      	ands	r2, r1
    a09e:	605a      	str	r2, [r3, #4]
    a0a0:	f7ff f800 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a0a4:	6860      	ldr	r0, [r4, #4]
    a0a6:	f810 1f87 	ldrb.w	r1, [r0, #135]!
    a0aa:	f041 0101 	orr.w	r1, r1, #1
    a0ae:	7001      	strb	r1, [r0, #0]
    a0b0:	2000      	movs	r0, #0
    a0b2:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    a0b4:	20000170 	.word	0x20000170
    a0b8:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    a0bc:	4d1e      	ldr	r5, [pc, #120]	; (a138 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1298>)
    a0be:	2301      	movs	r3, #1
    a0c0:	2107      	movs	r1, #7
    a0c2:	6868      	ldr	r0, [r5, #4]
    a0c4:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a0c8:	3078      	adds	r0, #120	; 0x78
    a0ca:	f004 fa46 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a0ce:	b380      	cbz	r0, a132 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1292>
    a0d0:	f1a5 0010 	sub.w	r0, r5, #16
    a0d4:	4669      	mov	r1, sp
    a0d6:	68c0      	ldr	r0, [r0, #12]
    a0d8:	f004 fcbb 	bl	ea52 <sym_KIWKQDEBPWXHISYFTEC7I32RP3MHD6CJEPVDW6I>
    a0dc:	686e      	ldr	r6, [r5, #4]
    a0de:	f89d 7004 	ldrb.w	r7, [sp, #4]
    a0e2:	36d4      	adds	r6, #212	; 0xd4
    a0e4:	9c00      	ldr	r4, [sp, #0]
    a0e6:	f001 faa7 	bl	b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>
    a0ea:	4004      	ands	r4, r0
    a0ec:	f644 102f 	movw	r0, #18735	; 0x492f
    a0f0:	4004      	ands	r4, r0
    a0f2:	400f      	ands	r7, r1
    a0f4:	f007 0006 	and.w	r0, r7, #6
    a0f8:	6034      	str	r4, [r6, #0]
    a0fa:	6070      	str	r0, [r6, #4]
    a0fc:	6869      	ldr	r1, [r5, #4]
    a0fe:	2000      	movs	r0, #0
    a100:	f881 00be 	strb.w	r0, [r1, #190]	; 0xbe
    a104:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    a108:	880a      	ldrh	r2, [r1, #0]
    a10a:	f8a1 2198 	strh.w	r2, [r1, #408]	; 0x198
    a10e:	f881 0196 	strb.w	r0, [r1, #406]	; 0x196
    a112:	9a00      	ldr	r2, [sp, #0]
    a114:	f8c1 219a 	str.w	r2, [r1, #410]	; 0x19a
    a118:	9a01      	ldr	r2, [sp, #4]
    a11a:	f8c1 219e 	str.w	r2, [r1, #414]	; 0x19e
    a11e:	f501 70c6 	add.w	r0, r1, #396	; 0x18c
    a122:	2205      	movs	r2, #5
    a124:	f7fd f83e 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    a128:	f7fd f90e 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    a12c:	2000      	movs	r0, #0
    a12e:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
    a132:	e7ff      	b.n	a134 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1294>
    a134:	2001      	movs	r0, #1
    a136:	e7fa      	b.n	a12e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x128e>
    a138:	20000170 	.word	0x20000170
    a13c:	480b      	ldr	r0, [pc, #44]	; (a16c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x12cc>)
    a13e:	b510      	push	{r4, lr}
    a140:	6840      	ldr	r0, [r0, #4]
    a142:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
    a146:	070a      	lsls	r2, r1, #28
    a148:	d501      	bpl.n	a14e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x12ae>
    a14a:	2001      	movs	r0, #1
    a14c:	bd10      	pop	{r4, pc}
    a14e:	f041 0108 	orr.w	r1, r1, #8
    a152:	f880 1087 	strb.w	r1, [r0, #135]	; 0x87
    a156:	4905      	ldr	r1, [pc, #20]	; (a16c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x12cc>)
    a158:	3910      	subs	r1, #16
    a15a:	68c9      	ldr	r1, [r1, #12]
    a15c:	78c9      	ldrb	r1, [r1, #3]
    a15e:	f880 1108 	strb.w	r1, [r0, #264]	; 0x108
    a162:	f7fe ff9f 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a166:	2000      	movs	r0, #0
    a168:	bd10      	pop	{r4, pc}
    a16a:	0000      	.short	0x0000
    a16c:	20000170 	.word	0x20000170
    a170:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    a174:	4d36      	ldr	r5, [pc, #216]	; (a250 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x13b0>)
    a176:	6868      	ldr	r0, [r5, #4]
    a178:	f890 0087 	ldrb.w	r0, [r0, #135]	; 0x87
    a17c:	f010 0f30 	tst.w	r0, #48	; 0x30
    a180:	d002      	beq.n	a188 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x12e8>
    a182:	2001      	movs	r0, #1
    a184:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
    a188:	4c31      	ldr	r4, [pc, #196]	; (a250 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x13b0>)
    a18a:	3c10      	subs	r4, #16
    a18c:	68e0      	ldr	r0, [r4, #12]
    a18e:	f004 fc7b 	bl	ea88 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI>
    a192:	b328      	cbz	r0, a1e0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1340>
    a194:	68e0      	ldr	r0, [r4, #12]
    a196:	f004 fc69 	bl	ea6c <sym_GPYTTEK2KDNR73G6ZAXHATMSQZASIEW24RTZFJA>
    a19a:	4607      	mov	r7, r0
    a19c:	68e0      	ldr	r0, [r4, #12]
    a19e:	f004 fc69 	bl	ea74 <sym_WC6UZSDJDS7GHVUUG36QUD3XWMICRFA5JJX42VA>
    a1a2:	4680      	mov	r8, r0
    a1a4:	68e0      	ldr	r0, [r4, #12]
    a1a6:	f004 fc5f 	bl	ea68 <sym_AWXBPGMPTTTWF7DPZL5Q2JQ4QSDFRJFHKF3BIIQ>
    a1aa:	4606      	mov	r6, r0
    a1ac:	68e0      	ldr	r0, [r4, #12]
    a1ae:	f004 fc5f 	bl	ea70 <sym_IR77N76GC2RMGAYGDAEPSAGD4DPXFGWMASI3OGY>
    a1b2:	4601      	mov	r1, r0
    a1b4:	9700      	str	r7, [sp, #0]
    a1b6:	6868      	ldr	r0, [r5, #4]
    a1b8:	4643      	mov	r3, r8
    a1ba:	4632      	mov	r2, r6
    a1bc:	3030      	adds	r0, #48	; 0x30
    a1be:	f004 ff36 	bl	f02e <sym_ONVPV2DV6OK6HG537JAHRS5B7G22RD24D2QGM5A>
    a1c2:	78a0      	ldrb	r0, [r4, #2]
    a1c4:	0781      	lsls	r1, r0, #30
    a1c6:	f04f 0001 	mov.w	r0, #1
    a1ca:	d503      	bpl.n	a1d4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1334>
    a1cc:	68a1      	ldr	r1, [r4, #8]
    a1ce:	78c9      	ldrb	r1, [r1, #3]
    a1d0:	2914      	cmp	r1, #20
    a1d2:	d009      	beq.n	a1e8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1348>
    a1d4:	6869      	ldr	r1, [r5, #4]
    a1d6:	f891 1085 	ldrb.w	r1, [r1, #133]	; 0x85
    a1da:	291c      	cmp	r1, #28
    a1dc:	d004      	beq.n	a1e8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1348>
    a1de:	e006      	b.n	a1ee <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x134e>
    a1e0:	e8bd 41fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    a1e4:	f7ff bfaa 	b.w	a13c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x129c>
    a1e8:	6869      	ldr	r1, [r5, #4]
    a1ea:	f881 0064 	strb.w	r0, [r1, #100]	; 0x64
    a1ee:	686b      	ldr	r3, [r5, #4]
    a1f0:	f893 0064 	ldrb.w	r0, [r3, #100]	; 0x64
    a1f4:	2801      	cmp	r0, #1
    a1f6:	d011      	beq.n	a21c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x137c>
    a1f8:	f893 011b 	ldrb.w	r0, [r3, #283]	; 0x11b
    a1fc:	f88d 0004 	strb.w	r0, [sp, #4]
    a200:	9801      	ldr	r0, [sp, #4]
    a202:	9001      	str	r0, [sp, #4]
    a204:	f89d 0004 	ldrb.w	r0, [sp, #4]
    a208:	b940      	cbnz	r0, a21c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x137c>
    a20a:	f893 011a 	ldrb.w	r0, [r3, #282]	; 0x11a
    a20e:	f88d 0000 	strb.w	r0, [sp]
    a212:	9800      	ldr	r0, [sp, #0]
    a214:	9000      	str	r0, [sp, #0]
    a216:	f89d 0000 	ldrb.w	r0, [sp]
    a21a:	b148      	cbz	r0, a230 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1390>
    a21c:	f813 0f87 	ldrb.w	r0, [r3, #135]!
    a220:	f040 0010 	orr.w	r0, r0, #16
    a224:	f883 0000 	strb.w	r0, [r3]
    a228:	f7fe ff3c 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a22c:	2000      	movs	r0, #0
    a22e:	e7a9      	b.n	a184 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x12e4>
    a230:	f893 0087 	ldrb.w	r0, [r3, #135]	; 0x87
    a234:	f503 72ad 	add.w	r2, r3, #346	; 0x15a
    a238:	f040 0020 	orr.w	r0, r0, #32
    a23c:	f883 0087 	strb.w	r0, [r3, #135]	; 0x87
    a240:	f103 0130 	add.w	r1, r3, #48	; 0x30
    a244:	8818      	ldrh	r0, [r3, #0]
    a246:	f004 fef9 	bl	f03c <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I>
    a24a:	f7fd f87d 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    a24e:	e7eb      	b.n	a228 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1388>
    a250:	20000170 	.word	0x20000170
    a254:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a258:	4c1b      	ldr	r4, [pc, #108]	; (a2c8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1428>)
    a25a:	2301      	movs	r3, #1
    a25c:	210a      	movs	r1, #10
    a25e:	6860      	ldr	r0, [r4, #4]
    a260:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a264:	3078      	adds	r0, #120	; 0x78
    a266:	f004 f978 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a26a:	b358      	cbz	r0, a2c4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1424>
    a26c:	f1a4 0510 	sub.w	r5, r4, #16
    a270:	68e8      	ldr	r0, [r5, #12]
    a272:	f004 fc09 	bl	ea88 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI>
    a276:	b1d0      	cbz	r0, a2ae <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x140e>
    a278:	68e8      	ldr	r0, [r5, #12]
    a27a:	f004 fbf7 	bl	ea6c <sym_GPYTTEK2KDNR73G6ZAXHATMSQZASIEW24RTZFJA>
    a27e:	4680      	mov	r8, r0
    a280:	68e8      	ldr	r0, [r5, #12]
    a282:	f004 fbf7 	bl	ea74 <sym_WC6UZSDJDS7GHVUUG36QUD3XWMICRFA5JJX42VA>
    a286:	4607      	mov	r7, r0
    a288:	68e8      	ldr	r0, [r5, #12]
    a28a:	f004 fbed 	bl	ea68 <sym_AWXBPGMPTTTWF7DPZL5Q2JQ4QSDFRJFHKF3BIIQ>
    a28e:	4606      	mov	r6, r0
    a290:	68e8      	ldr	r0, [r5, #12]
    a292:	f004 fbed 	bl	ea70 <sym_IR77N76GC2RMGAYGDAEPSAGD4DPXFGWMASI3OGY>
    a296:	4601      	mov	r1, r0
    a298:	f8cd 8000 	str.w	r8, [sp]
    a29c:	6860      	ldr	r0, [r4, #4]
    a29e:	463b      	mov	r3, r7
    a2a0:	4632      	mov	r2, r6
    a2a2:	3030      	adds	r0, #48	; 0x30
    a2a4:	f004 fec3 	bl	f02e <sym_ONVPV2DV6OK6HG537JAHRS5B7G22RD24D2QGM5A>
    a2a8:	6860      	ldr	r0, [r4, #4]
    a2aa:	f004 fe30 	bl	ef0e <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q>
    a2ae:	6861      	ldr	r1, [r4, #4]
    a2b0:	2000      	movs	r0, #0
    a2b2:	f881 00be 	strb.w	r0, [r1, #190]	; 0xbe
    a2b6:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    a2ba:	f7ff f8d9 	bl	9470 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5d0>
    a2be:	2000      	movs	r0, #0
    a2c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a2c4:	2001      	movs	r0, #1
    a2c6:	e7fb      	b.n	a2c0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1420>
    a2c8:	20000170 	.word	0x20000170
    a2cc:	b510      	push	{r4, lr}
    a2ce:	4c09      	ldr	r4, [pc, #36]	; (a2f4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1454>)
    a2d0:	6860      	ldr	r0, [r4, #4]
    a2d2:	f890 0087 	ldrb.w	r0, [r0, #135]	; 0x87
    a2d6:	0740      	lsls	r0, r0, #29
    a2d8:	d501      	bpl.n	a2de <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x143e>
    a2da:	2001      	movs	r0, #1
    a2dc:	bd10      	pop	{r4, pc}
    a2de:	f7fe fee1 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a2e2:	6860      	ldr	r0, [r4, #4]
    a2e4:	f810 1f87 	ldrb.w	r1, [r0, #135]!
    a2e8:	f041 0104 	orr.w	r1, r1, #4
    a2ec:	7001      	strb	r1, [r0, #0]
    a2ee:	2000      	movs	r0, #0
    a2f0:	bd10      	pop	{r4, pc}
    a2f2:	0000      	.short	0x0000
    a2f4:	20000170 	.word	0x20000170
    a2f8:	b510      	push	{r4, lr}
    a2fa:	4c0a      	ldr	r4, [pc, #40]	; (a324 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1484>)
    a2fc:	2301      	movs	r3, #1
    a2fe:	2109      	movs	r1, #9
    a300:	6860      	ldr	r0, [r4, #4]
    a302:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a306:	3078      	adds	r0, #120	; 0x78
    a308:	f004 f927 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a30c:	2800      	cmp	r0, #0
    a30e:	d007      	beq.n	a320 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1480>
    a310:	6860      	ldr	r0, [r4, #4]
    a312:	2100      	movs	r1, #0
    a314:	f800 1fb2 	strb.w	r1, [r0, #178]!
    a318:	7301      	strb	r1, [r0, #12]
    a31a:	f800 1c2d 	strb.w	r1, [r0, #-45]
    a31e:	4608      	mov	r0, r1
    a320:	bd10      	pop	{r4, pc}
    a322:	0000      	.short	0x0000
    a324:	20000170 	.word	0x20000170
    a328:	b510      	push	{r4, lr}
    a32a:	4c0f      	ldr	r4, [pc, #60]	; (a368 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x14c8>)
    a32c:	2301      	movs	r3, #1
    a32e:	2100      	movs	r1, #0
    a330:	6860      	ldr	r0, [r4, #4]
    a332:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    a336:	3078      	adds	r0, #120	; 0x78
    a338:	f004 f90f 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a33c:	b138      	cbz	r0, a34e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x14ae>
    a33e:	f7fe feb1 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a342:	6861      	ldr	r1, [r4, #4]
    a344:	2010      	movs	r0, #16
    a346:	f881 0086 	strb.w	r0, [r1, #134]	; 0x86
    a34a:	2000      	movs	r0, #0
    a34c:	bd10      	pop	{r4, pc}
    a34e:	6860      	ldr	r0, [r4, #4]
    a350:	2301      	movs	r3, #1
    a352:	2105      	movs	r1, #5
    a354:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    a358:	3078      	adds	r0, #120	; 0x78
    a35a:	f004 f8fe 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a35e:	b108      	cbz	r0, a364 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x14c4>
    a360:	2008      	movs	r0, #8
    a362:	bd10      	pop	{r4, pc}
    a364:	2001      	movs	r0, #1
    a366:	bd10      	pop	{r4, pc}
    a368:	20000170 	.word	0x20000170
    a36c:	4806      	ldr	r0, [pc, #24]	; (a388 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x14e8>)
    a36e:	6840      	ldr	r0, [r0, #4]
    a370:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    a374:	2911      	cmp	r1, #17
    a376:	d001      	beq.n	a37c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x14dc>
    a378:	2002      	movs	r0, #2
    a37a:	4770      	bx	lr
    a37c:	2112      	movs	r1, #18
    a37e:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    a382:	2000      	movs	r0, #0
    a384:	4770      	bx	lr
    a386:	0000      	.short	0x0000
    a388:	20000170 	.word	0x20000170
    a38c:	b538      	push	{r3, r4, r5, lr}
    a38e:	4c36      	ldr	r4, [pc, #216]	; (a468 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15c8>)
    a390:	2301      	movs	r3, #1
    a392:	210b      	movs	r1, #11
    a394:	6860      	ldr	r0, [r4, #4]
    a396:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    a39a:	3078      	adds	r0, #120	; 0x78
    a39c:	f004 f8dd 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a3a0:	bb80      	cbnz	r0, a404 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1564>
    a3a2:	6860      	ldr	r0, [r4, #4]
    a3a4:	2301      	movs	r3, #1
    a3a6:	2100      	movs	r1, #0
    a3a8:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    a3ac:	3078      	adds	r0, #120	; 0x78
    a3ae:	f004 f8d4 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a3b2:	b328      	cbz	r0, a400 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1560>
    a3b4:	6860      	ldr	r0, [r4, #4]
    a3b6:	f890 0085 	ldrb.w	r0, [r0, #133]	; 0x85
    a3ba:	2824      	cmp	r0, #36	; 0x24
    a3bc:	d023      	beq.n	a406 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1566>
    a3be:	f1a4 0510 	sub.w	r5, r4, #16
    a3c2:	68e8      	ldr	r0, [r5, #12]
    a3c4:	f004 fb7c 	bl	eac0 <sym_RPQNXSNTPADDKXP5RSAMGT6PEA6HJ6WJSJ5DQUA>
    a3c8:	b1f8      	cbz	r0, a40a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x156a>
    a3ca:	6860      	ldr	r0, [r4, #4]
    a3cc:	2102      	movs	r1, #2
    a3ce:	30d4      	adds	r0, #212	; 0xd4
    a3d0:	f005 fd1c 	bl	fe0c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x762>
    a3d4:	68e8      	ldr	r0, [r5, #12]
    a3d6:	7941      	ldrb	r1, [r0, #5]
    a3d8:	f001 0207 	and.w	r2, r1, #7
    a3dc:	6861      	ldr	r1, [r4, #4]
    a3de:	f881 2067 	strb.w	r2, [r1, #103]	; 0x67
    a3e2:	7900      	ldrb	r0, [r0, #4]
    a3e4:	f000 0007 	and.w	r0, r0, #7
    a3e8:	f881 0066 	strb.w	r0, [r1, #102]	; 0x66
    a3ec:	f891 3125 	ldrb.w	r3, [r1, #293]	; 0x125
    a3f0:	f88d 3000 	strb.w	r3, [sp]
    a3f4:	9b00      	ldr	r3, [sp, #0]
    a3f6:	9300      	str	r3, [sp, #0]
    a3f8:	f89d 3000 	ldrb.w	r3, [sp]
    a3fc:	bb5b      	cbnz	r3, a456 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15b6>
    a3fe:	e008      	b.n	a412 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1572>
    a400:	2001      	movs	r0, #1
    a402:	bd38      	pop	{r3, r4, r5, pc}
    a404:	e7ff      	b.n	a406 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1566>
    a406:	2020      	movs	r0, #32
    a408:	e7fb      	b.n	a402 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1562>
    a40a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a40e:	f7ff be95 	b.w	a13c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x129c>
    a412:	f891 3124 	ldrb.w	r3, [r1, #292]	; 0x124
    a416:	2b01      	cmp	r3, #1
    a418:	d01d      	beq.n	a456 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15b6>
    a41a:	f101 036e 	add.w	r3, r1, #110	; 0x6e
    a41e:	785d      	ldrb	r5, [r3, #1]
    a420:	4285      	cmp	r5, r0
    a422:	d106      	bne.n	a432 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1592>
    a424:	7818      	ldrb	r0, [r3, #0]
    a426:	4290      	cmp	r0, r2
    a428:	d103      	bne.n	a432 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1592>
    a42a:	2002      	movs	r0, #2
    a42c:	f881 0124 	strb.w	r0, [r1, #292]	; 0x124
    a430:	e011      	b.n	a456 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15b6>
    a432:	f501 70bc 	add.w	r0, r1, #376	; 0x178
    a436:	880a      	ldrh	r2, [r1, #0]
    a438:	f820 2b02 	strh.w	r2, [r0], #2
    a43c:	f891 2066 	ldrb.w	r2, [r1, #102]	; 0x66
    a440:	f800 2b01 	strb.w	r2, [r0], #1
    a444:	f891 2067 	ldrb.w	r2, [r1, #103]	; 0x67
    a448:	f800 290d 	strb.w	r2, [r0], #-13
    a44c:	221b      	movs	r2, #27
    a44e:	f7fc fea9 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    a452:	f7fc ff79 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    a456:	6861      	ldr	r1, [r4, #4]
    a458:	2021      	movs	r0, #33	; 0x21
    a45a:	f881 0086 	strb.w	r0, [r1, #134]	; 0x86
    a45e:	f7fe fe21 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a462:	2000      	movs	r0, #0
    a464:	e7cd      	b.n	a402 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1562>
    a466:	0000      	.short	0x0000
    a468:	20000170 	.word	0x20000170
    a46c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a470:	4951      	ldr	r1, [pc, #324]	; (a5b8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1718>)
    a472:	6848      	ldr	r0, [r1, #4]
    a474:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a478:	2a20      	cmp	r2, #32
    a47a:	d009      	beq.n	a490 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15f0>
    a47c:	f05f 0600 	movs.w	r6, #0
    a480:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    a484:	2a22      	cmp	r2, #34	; 0x22
    a486:	d005      	beq.n	a494 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15f4>
    a488:	b3a6      	cbz	r6, a4f4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1654>
    a48a:	f100 0485 	add.w	r4, r0, #133	; 0x85
    a48e:	e003      	b.n	a498 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15f8>
    a490:	2601      	movs	r6, #1
    a492:	e7f5      	b.n	a480 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x15e0>
    a494:	f100 0486 	add.w	r4, r0, #134	; 0x86
    a498:	4688      	mov	r8, r1
    a49a:	2102      	movs	r1, #2
    a49c:	30d4      	adds	r0, #212	; 0xd4
    a49e:	f005 fcb5 	bl	fe0c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x762>
    a4a2:	4d45      	ldr	r5, [pc, #276]	; (a5b8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1718>)
    a4a4:	3d10      	subs	r5, #16
    a4a6:	68e8      	ldr	r0, [r5, #12]
    a4a8:	f004 fb14 	bl	ead4 <sym_OIELJZXQUH4XDAK7XBXBJX4CE2IIXWLOTEZEOSI>
    a4ac:	2700      	movs	r7, #0
    a4ae:	b328      	cbz	r0, a4fc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x165c>
    a4b0:	4631      	mov	r1, r6
    a4b2:	68e8      	ldr	r0, [r5, #12]
    a4b4:	f7fe fec8 	bl	9248 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x3a8>
    a4b8:	b300      	cbz	r0, a4fc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x165c>
    a4ba:	4646      	mov	r6, r8
    a4bc:	466a      	mov	r2, sp
    a4be:	f8d8 0004 	ldr.w	r0, [r8, #4]
    a4c2:	68e9      	ldr	r1, [r5, #12]
    a4c4:	f004 f97b 	bl	e7be <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q>
    a4c8:	b3a8      	cbz	r0, a536 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1696>
    a4ca:	68e8      	ldr	r0, [r5, #12]
    a4cc:	f004 fad4 	bl	ea78 <sym_VMI6LAIHFJODZECDSALRIOKPVGLRUJ6WTCP43FY>
    a4d0:	6871      	ldr	r1, [r6, #4]
    a4d2:	f8a1 0274 	strh.w	r0, [r1, #628]	; 0x274
    a4d6:	f8b1 107c 	ldrh.w	r1, [r1, #124]	; 0x7c
    a4da:	f005 fd09 	bl	fef0 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x60>
    a4de:	b358      	cbz	r0, a538 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1698>
    a4e0:	6871      	ldr	r1, [r6, #4]
    a4e2:	2028      	movs	r0, #40	; 0x28
    a4e4:	2208      	movs	r2, #8
    a4e6:	f881 00a6 	strb.w	r0, [r1, #166]	; 0xa6
    a4ea:	f101 009d 	add.w	r0, r1, #157	; 0x9d
    a4ee:	f7fc fe59 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    a4f2:	e055      	b.n	a5a0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1700>
    a4f4:	e7ff      	b.n	a4f6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1656>
    a4f6:	2002      	movs	r0, #2
    a4f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a4fc:	f8d8 0004 	ldr.w	r0, [r8, #4]
    a500:	f04f 0900 	mov.w	r9, #0
    a504:	f890 1124 	ldrb.w	r1, [r0, #292]	; 0x124
    a508:	2901      	cmp	r1, #1
    a50a:	d016      	beq.n	a53a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x169a>
    a50c:	f880 7124 	strb.w	r7, [r0, #292]	; 0x124
    a510:	b1fe      	cbz	r6, a552 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16b2>
    a512:	68e8      	ldr	r0, [r5, #12]
    a514:	f8d8 1004 	ldr.w	r1, [r8, #4]
    a518:	2201      	movs	r2, #1
    a51a:	78c0      	ldrb	r0, [r0, #3]
    a51c:	f881 0109 	strb.w	r0, [r1, #265]	; 0x109
    a520:	4082      	lsls	r2, r0
    a522:	f3c2 6000 	ubfx	r0, r2, #24, #1
    a526:	b160      	cbz	r0, a542 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16a2>
    a528:	200a      	movs	r0, #10
    a52a:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    a52e:	f891 00be 	ldrb.w	r0, [r1, #190]	; 0xbe
    a532:	b9a0      	cbnz	r0, a55e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16be>
    a534:	e008      	b.n	a548 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16a8>
    a536:	e014      	b.n	a562 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16c2>
    a538:	e027      	b.n	a58a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16ea>
    a53a:	201e      	movs	r0, #30
    a53c:	f7ff fc62 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    a540:	e7e6      	b.n	a510 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1670>
    a542:	f240 31fd 	movw	r1, #1021	; 0x3fd
    a546:	e001      	b.n	a54c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16ac>
    a548:	f240 4105 	movw	r1, #1029	; 0x405
    a54c:	2031      	movs	r0, #49	; 0x31
    a54e:	f7fa fe01 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a552:	7027      	strb	r7, [r4, #0]
    a554:	f7fe fdb2 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a558:	f7ff fdf0 	bl	a13c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x129c>
    a55c:	4681      	mov	r9, r0
    a55e:	4648      	mov	r0, r9
    a560:	e7ca      	b.n	a4f8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1658>
    a562:	6870      	ldr	r0, [r6, #4]
    a564:	f890 1124 	ldrb.w	r1, [r0, #292]	; 0x124
    a568:	2901      	cmp	r1, #1
    a56a:	d009      	beq.n	a580 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16e0>
    a56c:	f880 7124 	strb.w	r7, [r0, #292]	; 0x124
    a570:	6870      	ldr	r0, [r6, #4]
    a572:	f100 0186 	add.w	r1, r0, #134	; 0x86
    a576:	42a1      	cmp	r1, r4
    a578:	d112      	bne.n	a5a0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1700>
    a57a:	f880 7086 	strb.w	r7, [r0, #134]	; 0x86
    a57e:	e00f      	b.n	a5a0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1700>
    a580:	2000      	movs	r0, #0
    a582:	f7ff fc3f 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    a586:	7027      	strb	r7, [r4, #0]
    a588:	e7f2      	b.n	a570 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x16d0>
    a58a:	6870      	ldr	r0, [r6, #4]
    a58c:	f89d 1000 	ldrb.w	r1, [sp]
    a590:	f880 1276 	strb.w	r1, [r0, #630]	; 0x276
    a594:	f89d 1001 	ldrb.w	r1, [sp, #1]
    a598:	f880 1277 	strb.w	r1, [r0, #631]	; 0x277
    a59c:	2024      	movs	r0, #36	; 0x24
    a59e:	7020      	strb	r0, [r4, #0]
    a5a0:	6870      	ldr	r0, [r6, #4]
    a5a2:	f100 0186 	add.w	r1, r0, #134	; 0x86
    a5a6:	42a1      	cmp	r1, r4
    a5a8:	d102      	bne.n	a5b0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1710>
    a5aa:	f7fe fd87 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a5ae:	e001      	b.n	a5b4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1714>
    a5b0:	f880 70be 	strb.w	r7, [r0, #190]	; 0xbe
    a5b4:	2000      	movs	r0, #0
    a5b6:	e79f      	b.n	a4f8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1658>
    a5b8:	20000170 	.word	0x20000170
    a5bc:	b570      	push	{r4, r5, r6, lr}
    a5be:	480a      	ldr	r0, [pc, #40]	; (a5e8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1748>)
    a5c0:	2102      	movs	r1, #2
    a5c2:	6840      	ldr	r0, [r0, #4]
    a5c4:	30d4      	adds	r0, #212	; 0xd4
    a5c6:	f005 fc21 	bl	fe0c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x762>
    a5ca:	4c07      	ldr	r4, [pc, #28]	; (a5e8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1748>)
    a5cc:	3c10      	subs	r4, #16
    a5ce:	68e0      	ldr	r0, [r4, #12]
    a5d0:	f004 fa90 	bl	eaf4 <sym_V37KOABA26BNKOPPXCRMHM2FBYFAD7NU4IA7EIQ>
    a5d4:	4605      	mov	r5, r0
    a5d6:	68e0      	ldr	r0, [r4, #12]
    a5d8:	f004 fa8e 	bl	eaf8 <sym_I6A5ME4L4BDSYALCIKK2V6NRQKRM5QI7WNBE2CA>
    a5dc:	4601      	mov	r1, r0
    a5de:	4628      	mov	r0, r5
    a5e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    a5e4:	f005 bc90 	b.w	ff08 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x78>
    a5e8:	20000170 	.word	0x20000170
    a5ec:	4808      	ldr	r0, [pc, #32]	; (a610 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1770>)
    a5ee:	68c0      	ldr	r0, [r0, #12]
    a5f0:	7901      	ldrb	r1, [r0, #4]
    a5f2:	4807      	ldr	r0, [pc, #28]	; (a610 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1770>)
    a5f4:	3010      	adds	r0, #16
    a5f6:	6840      	ldr	r0, [r0, #4]
    a5f8:	f890 0085 	ldrb.w	r0, [r0, #133]	; 0x85
    a5fc:	2820      	cmp	r0, #32
    a5fe:	d005      	beq.n	a60c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x176c>
    a600:	2827      	cmp	r0, #39	; 0x27
    a602:	d003      	beq.n	a60c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x176c>
    a604:	f05f 00fe 	movs.w	r0, #254	; 0xfe
    a608:	f005 bc7e 	b.w	ff08 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x78>
    a60c:	2016      	movs	r0, #22
    a60e:	e7fb      	b.n	a608 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1768>
    a610:	20000160 	.word	0x20000160
    a614:	b510      	push	{r4, lr}
    a616:	4c08      	ldr	r4, [pc, #32]	; (a638 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1798>)
    a618:	6860      	ldr	r0, [r4, #4]
    a61a:	f890 0086 	ldrb.w	r0, [r0, #134]	; 0x86
    a61e:	2817      	cmp	r0, #23
    a620:	d001      	beq.n	a626 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1786>
    a622:	2002      	movs	r0, #2
    a624:	bd10      	pop	{r4, pc}
    a626:	f7fe fd49 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a62a:	6861      	ldr	r1, [r4, #4]
    a62c:	201b      	movs	r0, #27
    a62e:	f881 0086 	strb.w	r0, [r1, #134]	; 0x86
    a632:	2000      	movs	r0, #0
    a634:	bd10      	pop	{r4, pc}
    a636:	0000      	.short	0x0000
    a638:	20000170 	.word	0x20000170
    a63c:	b510      	push	{r4, lr}
    a63e:	4c0c      	ldr	r4, [pc, #48]	; (a670 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x17d0>)
    a640:	2301      	movs	r3, #1
    a642:	4619      	mov	r1, r3
    a644:	6860      	ldr	r0, [r4, #4]
    a646:	f890 2088 	ldrb.w	r2, [r0, #136]	; 0x88
    a64a:	3078      	adds	r0, #120	; 0x78
    a64c:	f003 ff85 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a650:	b108      	cbz	r0, a656 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x17b6>
    a652:	2000      	movs	r0, #0
    a654:	bd10      	pop	{r4, pc}
    a656:	4806      	ldr	r0, [pc, #24]	; (a670 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x17d0>)
    a658:	3810      	subs	r0, #16
    a65a:	68c0      	ldr	r0, [r0, #12]
    a65c:	f004 fa10 	bl	ea80 <sym_WRY64WR3RHFREREX3ZB66OLRGKHGDAUZMHJMBCI>
    a660:	6861      	ldr	r1, [r4, #4]
    a662:	f881 0089 	strb.w	r0, [r1, #137]	; 0x89
    a666:	2007      	movs	r0, #7
    a668:	f881 0088 	strb.w	r0, [r1, #136]	; 0x88
    a66c:	e7f1      	b.n	a652 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x17b2>
    a66e:	0000      	.short	0x0000
    a670:	20000170 	.word	0x20000170
    a674:	b570      	push	{r4, r5, r6, lr}
    a676:	4834      	ldr	r0, [pc, #208]	; (a748 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a8>)
    a678:	4c33      	ldr	r4, [pc, #204]	; (a748 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a8>)
    a67a:	2500      	movs	r5, #0
    a67c:	68c0      	ldr	r0, [r0, #12]
    a67e:	3410      	adds	r4, #16
    a680:	6862      	ldr	r2, [r4, #4]
    a682:	7901      	ldrb	r1, [r0, #4]
    a684:	f892 0085 	ldrb.w	r0, [r2, #133]	; 0x85
    a688:	390e      	subs	r1, #14
    a68a:	290a      	cmp	r1, #10
    a68c:	d259      	bcs.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a68e:	e8df f001 	tbb	[pc, r1]
    a692:	5805      	.short	0x5805
    a694:	581a5858 	.word	0x581a5858
    a698:	442c5820 	.word	0x442c5820
    a69c:	2804      	cmp	r0, #4
    a69e:	d150      	bne.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6a0:	f7fe fe56 	bl	9350 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4b0>
    a6a4:	6860      	ldr	r0, [r4, #4]
    a6a6:	2205      	movs	r2, #5
    a6a8:	f500 73c6 	add.w	r3, r0, #396	; 0x18c
    a6ac:	8801      	ldrh	r1, [r0, #0]
    a6ae:	f8a0 1198 	strh.w	r1, [r0, #408]	; 0x198
    a6b2:	211a      	movs	r1, #26
    a6b4:	f880 1196 	strb.w	r1, [r0, #406]	; 0x196
    a6b8:	4601      	mov	r1, r0
    a6ba:	4618      	mov	r0, r3
    a6bc:	f7fc fd72 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    a6c0:	f7fc fe42 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    a6c4:	e03d      	b.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6c6:	280e      	cmp	r0, #14
    a6c8:	d13b      	bne.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6ca:	f7ff fe15 	bl	a2f8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1458>
    a6ce:	4605      	mov	r5, r0
    a6d0:	e037      	b.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6d2:	281c      	cmp	r0, #28
    a6d4:	d135      	bne.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6d6:	f7fe fe3b 	bl	9350 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4b0>
    a6da:	6860      	ldr	r0, [r4, #4]
    a6dc:	2105      	movs	r1, #5
    a6de:	30d4      	adds	r0, #212	; 0xd4
    a6e0:	f005 fb8a 	bl	fdf8 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x74e>
    a6e4:	f7fe fec4 	bl	9470 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x5d0>
    a6e8:	e02b      	b.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6ea:	2820      	cmp	r0, #32
    a6ec:	d001      	beq.n	a6f2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1852>
    a6ee:	2827      	cmp	r0, #39	; 0x27
    a6f0:	d127      	bne.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a6f2:	f7fe fe2d 	bl	9350 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x4b0>
    a6f6:	6860      	ldr	r0, [r4, #4]
    a6f8:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    a6fc:	2921      	cmp	r1, #33	; 0x21
    a6fe:	d020      	beq.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a700:	2108      	movs	r1, #8
    a702:	30d4      	adds	r0, #212	; 0xd4
    a704:	f005 fb78 	bl	fdf8 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x74e>
    a708:	6860      	ldr	r0, [r4, #4]
    a70a:	210b      	movs	r1, #11
    a70c:	30d4      	adds	r0, #212	; 0xd4
    a70e:	f005 fb73 	bl	fdf8 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x74e>
    a712:	201a      	movs	r0, #26
    a714:	f7ff fb76 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    a718:	e013      	b.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a71a:	f892 0086 	ldrb.w	r0, [r2, #134]	; 0x86
    a71e:	2822      	cmp	r0, #34	; 0x22
    a720:	d10f      	bne.n	a742 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18a2>
    a722:	2600      	movs	r6, #0
    a724:	f882 6086 	strb.w	r6, [r2, #134]	; 0x86
    a728:	f7fe fcc8 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a72c:	6860      	ldr	r0, [r4, #4]
    a72e:	f890 0124 	ldrb.w	r0, [r0, #292]	; 0x124
    a732:	2801      	cmp	r0, #1
    a734:	d102      	bne.n	a73c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x189c>
    a736:	2000      	movs	r0, #0
    a738:	f7ff fb64 	bl	9e04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xf64>
    a73c:	6860      	ldr	r0, [r4, #4]
    a73e:	f880 6124 	strb.w	r6, [r0, #292]	; 0x124
    a742:	4628      	mov	r0, r5
    a744:	bd70      	pop	{r4, r5, r6, pc}
    a746:	0000      	.short	0x0000
    a748:	20000160 	.word	0x20000160
    a74c:	b570      	push	{r4, r5, r6, lr}
    a74e:	4c31      	ldr	r4, [pc, #196]	; (a814 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1974>)
    a750:	6860      	ldr	r0, [r4, #4]
    a752:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
    a756:	0789      	lsls	r1, r1, #30
    a758:	d507      	bpl.n	a76a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18ca>
    a75a:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a75e:	2301      	movs	r3, #1
    a760:	2108      	movs	r1, #8
    a762:	3078      	adds	r0, #120	; 0x78
    a764:	f003 fef9 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a768:	b1f8      	cbz	r0, a7aa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x190a>
    a76a:	6860      	ldr	r0, [r4, #4]
    a76c:	f890 00c5 	ldrb.w	r0, [r0, #197]	; 0xc5
    a770:	0780      	lsls	r0, r0, #30
    a772:	d414      	bmi.n	a79e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x18fe>
    a774:	4d27      	ldr	r5, [pc, #156]	; (a814 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1974>)
    a776:	3d10      	subs	r5, #16
    a778:	68e8      	ldr	r0, [r5, #12]
    a77a:	f004 f983 	bl	ea84 <sym_FES4SNLGDB2HCH3XYZK52SHDPFDGL5NN3ARGNTY>
    a77e:	6861      	ldr	r1, [r4, #4]
    a780:	f881 00cf 	strb.w	r0, [r1, #207]	; 0xcf
    a784:	68e8      	ldr	r0, [r5, #12]
    a786:	f830 2f05 	ldrh.w	r2, [r0, #5]!
    a78a:	f8a1 20d0 	strh.w	r2, [r1, #208]	; 0xd0
    a78e:	8840      	ldrh	r0, [r0, #2]
    a790:	f8a1 00d2 	strh.w	r0, [r1, #210]	; 0xd2
    a794:	f811 0fc5 	ldrb.w	r0, [r1, #197]!
    a798:	f040 0002 	orr.w	r0, r0, #2
    a79c:	7008      	strb	r0, [r1, #0]
    a79e:	6860      	ldr	r0, [r4, #4]
    a7a0:	f890 10c5 	ldrb.w	r1, [r0, #197]	; 0xc5
    a7a4:	07c9      	lsls	r1, r1, #31
    a7a6:	d002      	beq.n	a7ae <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x190e>
    a7a8:	e015      	b.n	a7d6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1936>
    a7aa:	2001      	movs	r0, #1
    a7ac:	bd70      	pop	{r4, r5, r6, pc}
    a7ae:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
    a7b2:	078a      	lsls	r2, r1, #30
    a7b4:	d504      	bpl.n	a7c0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1920>
    a7b6:	f240 21e2 	movw	r1, #738	; 0x2e2
    a7ba:	2031      	movs	r0, #49	; 0x31
    a7bc:	f7fa fcca 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a7c0:	f041 0102 	orr.w	r1, r1, #2
    a7c4:	f880 1087 	strb.w	r1, [r0, #135]	; 0x87
    a7c8:	f7fe fc6c 	bl	90a4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x204>
    a7cc:	6860      	ldr	r0, [r4, #4]
    a7ce:	f890 00c5 	ldrb.w	r0, [r0, #197]	; 0xc5
    a7d2:	07c0      	lsls	r0, r0, #31
    a7d4:	d007      	beq.n	a7e6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1946>
    a7d6:	6861      	ldr	r1, [r4, #4]
    a7d8:	2201      	movs	r2, #1
    a7da:	f101 00c6 	add.w	r0, r1, #198	; 0xc6
    a7de:	f7fc fce1 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    a7e2:	f7fc fdb1 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    a7e6:	6860      	ldr	r0, [r4, #4]
    a7e8:	2100      	movs	r1, #0
    a7ea:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a7ee:	2a06      	cmp	r2, #6
    a7f0:	d103      	bne.n	a7fa <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x195a>
    a7f2:	f880 1085 	strb.w	r1, [r0, #133]	; 0x85
    a7f6:	f880 10be 	strb.w	r1, [r0, #190]	; 0xbe
    a7fa:	f890 212a 	ldrb.w	r2, [r0, #298]	; 0x12a
    a7fe:	b132      	cbz	r2, a80e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x196e>
    a800:	f880 112a 	strb.w	r1, [r0, #298]	; 0x12a
    a804:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a808:	b90a      	cbnz	r2, a80e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x196e>
    a80a:	f880 10be 	strb.w	r1, [r0, #190]	; 0xbe
    a80e:	2000      	movs	r0, #0
    a810:	bd70      	pop	{r4, r5, r6, pc}
    a812:	0000      	.short	0x0000
    a814:	20000170 	.word	0x20000170
    a818:	b510      	push	{r4, lr}
    a81a:	4c1f      	ldr	r4, [pc, #124]	; (a898 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19f8>)
    a81c:	6863      	ldr	r3, [r4, #4]
    a81e:	f893 0112 	ldrb.w	r0, [r3, #274]	; 0x112
    a822:	2808      	cmp	r0, #8
    a824:	d20d      	bcs.n	a842 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19a2>
    a826:	f500 72f4 	add.w	r2, r0, #488	; 0x1e8
    a82a:	f1c0 0008 	rsb	r0, r0, #8
    a82e:	b2c1      	uxtb	r1, r0
    a830:	1898      	adds	r0, r3, r2
    a832:	f7fa fd2d 	bl	5290 <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA>
    a836:	6861      	ldr	r1, [r4, #4]
    a838:	f891 2112 	ldrb.w	r2, [r1, #274]	; 0x112
    a83c:	4410      	add	r0, r2
    a83e:	f881 0112 	strb.w	r0, [r1, #274]	; 0x112
    a842:	6863      	ldr	r3, [r4, #4]
    a844:	f893 0112 	ldrb.w	r0, [r3, #274]	; 0x112
    a848:	3808      	subs	r0, #8
    a84a:	2804      	cmp	r0, #4
    a84c:	d20d      	bcs.n	a86a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19ca>
    a84e:	f500 7282 	add.w	r2, r0, #260	; 0x104
    a852:	f1c0 0004 	rsb	r0, r0, #4
    a856:	b2c1      	uxtb	r1, r0
    a858:	1898      	adds	r0, r3, r2
    a85a:	f7fa fd19 	bl	5290 <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA>
    a85e:	6861      	ldr	r1, [r4, #4]
    a860:	f891 2112 	ldrb.w	r2, [r1, #274]	; 0x112
    a864:	4410      	add	r0, r2
    a866:	f881 0112 	strb.w	r0, [r1, #274]	; 0x112
    a86a:	6860      	ldr	r0, [r4, #4]
    a86c:	f890 1112 	ldrb.w	r1, [r0, #274]	; 0x112
    a870:	290c      	cmp	r1, #12
    a872:	d30f      	bcc.n	a894 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19f4>
    a874:	d005      	beq.n	a882 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19e2>
    a876:	f640 013b 	movw	r1, #2107	; 0x83b
    a87a:	f04f 0031 	mov.w	r0, #49	; 0x31
    a87e:	f7fa fc69 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a882:	2100      	movs	r1, #0
    a884:	f880 1112 	strb.w	r1, [r0, #274]	; 0x112
    a888:	2101      	movs	r1, #1
    a88a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a88e:	2004      	movs	r0, #4
    a890:	f7ff b9ac 	b.w	9bec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xd4c>
    a894:	bd10      	pop	{r4, pc}
    a896:	0000      	.short	0x0000
    a898:	20000170 	.word	0x20000170
    a89c:	4804      	ldr	r0, [pc, #16]	; (a8b0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a10>)
    a89e:	2129      	movs	r1, #41	; 0x29
    a8a0:	6840      	ldr	r0, [r0, #4]
    a8a2:	f880 1085 	strb.w	r1, [r0, #133]	; 0x85
    a8a6:	2100      	movs	r1, #0
    a8a8:	f880 126c 	strb.w	r1, [r0, #620]	; 0x26c
    a8ac:	4770      	bx	lr
    a8ae:	0000      	.short	0x0000
    a8b0:	20000170 	.word	0x20000170
    a8b4:	4809      	ldr	r0, [pc, #36]	; (a8dc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a3c>)
    a8b6:	b510      	push	{r4, lr}
    a8b8:	6840      	ldr	r0, [r0, #4]
    a8ba:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    a8be:	2914      	cmp	r1, #20
    a8c0:	d004      	beq.n	a8cc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a2c>
    a8c2:	f240 61fd 	movw	r1, #1789	; 0x6fd
    a8c6:	2031      	movs	r0, #49	; 0x31
    a8c8:	f7fa fc44 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a8cc:	2101      	movs	r1, #1
    a8ce:	f880 10c3 	strb.w	r1, [r0, #195]	; 0xc3
    a8d2:	2115      	movs	r1, #21
    a8d4:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    a8d8:	bd10      	pop	{r4, pc}
    a8da:	0000      	.short	0x0000
    a8dc:	20000170 	.word	0x20000170
    a8e0:	b510      	push	{r4, lr}
    a8e2:	4c0a      	ldr	r4, [pc, #40]	; (a90c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a6c>)
    a8e4:	6860      	ldr	r0, [r4, #4]
    a8e6:	f890 0087 	ldrb.w	r0, [r0, #135]	; 0x87
    a8ea:	07c0      	lsls	r0, r0, #31
    a8ec:	d008      	beq.n	a900 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a60>
    a8ee:	f7fe fbe5 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a8f2:	6860      	ldr	r0, [r4, #4]
    a8f4:	f810 1f87 	ldrb.w	r1, [r0, #135]!
    a8f8:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
    a8fc:	7001      	strb	r1, [r0, #0]
    a8fe:	bd10      	pop	{r4, pc}
    a900:	f44f 61dd 	mov.w	r1, #1768	; 0x6e8
    a904:	2031      	movs	r0, #49	; 0x31
    a906:	f7fa fc25 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a90a:	0000      	.short	0x0000
    a90c:	20000170 	.word	0x20000170
    a910:	b510      	push	{r4, lr}
    a912:	4c0a      	ldr	r4, [pc, #40]	; (a93c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a9c>)
    a914:	2301      	movs	r3, #1
    a916:	2100      	movs	r1, #0
    a918:	6860      	ldr	r0, [r4, #4]
    a91a:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a91e:	3078      	adds	r0, #120	; 0x78
    a920:	f003 fe1b 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a924:	b120      	cbz	r0, a930 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1a90>
    a926:	6861      	ldr	r1, [r4, #4]
    a928:	201c      	movs	r0, #28
    a92a:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    a92e:	bd10      	pop	{r4, pc}
    a930:	f240 7184 	movw	r1, #1924	; 0x784
    a934:	2031      	movs	r0, #49	; 0x31
    a936:	f7fa fc0d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a93a:	0000      	.short	0x0000
    a93c:	20000170 	.word	0x20000170
    a940:	480a      	ldr	r0, [pc, #40]	; (a96c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1acc>)
    a942:	b510      	push	{r4, lr}
    a944:	6840      	ldr	r0, [r0, #4]
    a946:	f890 1087 	ldrb.w	r1, [r0, #135]	; 0x87
    a94a:	f3c1 1201 	ubfx	r2, r1, #4, #2
    a94e:	2a01      	cmp	r2, #1
    a950:	d004      	beq.n	a95c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1abc>
    a952:	f240 718b 	movw	r1, #1931	; 0x78b
    a956:	2031      	movs	r0, #49	; 0x31
    a958:	f7fa fbfc 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a95c:	f001 01ef 	and.w	r1, r1, #239	; 0xef
    a960:	f880 1087 	strb.w	r1, [r0, #135]	; 0x87
    a964:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a968:	f7fe bba8 	b.w	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a96c:	20000170 	.word	0x20000170
    a970:	b510      	push	{r4, lr}
    a972:	4c0a      	ldr	r4, [pc, #40]	; (a99c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1afc>)
    a974:	2301      	movs	r3, #1
    a976:	2100      	movs	r1, #0
    a978:	6860      	ldr	r0, [r4, #4]
    a97a:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a97e:	3078      	adds	r0, #120	; 0x78
    a980:	f003 fdeb 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a984:	b120      	cbz	r0, a990 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1af0>
    a986:	6861      	ldr	r1, [r4, #4]
    a988:	200e      	movs	r0, #14
    a98a:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    a98e:	bd10      	pop	{r4, pc}
    a990:	f240 7177 	movw	r1, #1911	; 0x777
    a994:	2031      	movs	r0, #49	; 0x31
    a996:	f7fa fbdd 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a99a:	0000      	.short	0x0000
    a99c:	20000170 	.word	0x20000170
    a9a0:	4804      	ldr	r0, [pc, #16]	; (a9b4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b14>)
    a9a2:	6840      	ldr	r0, [r0, #4]
    a9a4:	f810 1f87 	ldrb.w	r1, [r0, #135]!
    a9a8:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
    a9ac:	7001      	strb	r1, [r0, #0]
    a9ae:	f7fe bb85 	b.w	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    a9b2:	0000      	.short	0x0000
    a9b4:	20000170 	.word	0x20000170
    a9b8:	4809      	ldr	r0, [pc, #36]	; (a9e0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b40>)
    a9ba:	b510      	push	{r4, lr}
    a9bc:	6840      	ldr	r0, [r0, #4]
    a9be:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    a9c2:	2910      	cmp	r1, #16
    a9c4:	d004      	beq.n	a9d0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b30>
    a9c6:	f240 61f5 	movw	r1, #1781	; 0x6f5
    a9ca:	2031      	movs	r0, #49	; 0x31
    a9cc:	f7fa fbc2 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    a9d0:	2101      	movs	r1, #1
    a9d2:	f880 10c3 	strb.w	r1, [r0, #195]	; 0xc3
    a9d6:	2111      	movs	r1, #17
    a9d8:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    a9dc:	bd10      	pop	{r4, pc}
    a9de:	0000      	.short	0x0000
    a9e0:	20000170 	.word	0x20000170
    a9e4:	b510      	push	{r4, lr}
    a9e6:	4c0a      	ldr	r4, [pc, #40]	; (aa10 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b70>)
    a9e8:	2301      	movs	r3, #1
    a9ea:	2100      	movs	r1, #0
    a9ec:	6860      	ldr	r0, [r4, #4]
    a9ee:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    a9f2:	3078      	adds	r0, #120	; 0x78
    a9f4:	f003 fdb1 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    a9f8:	b120      	cbz	r0, aa04 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b64>
    a9fa:	6861      	ldr	r1, [r4, #4]
    a9fc:	201f      	movs	r0, #31
    a9fe:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    aa02:	bd10      	pop	{r4, pc}
    aa04:	f240 7197 	movw	r1, #1943	; 0x797
    aa08:	2031      	movs	r0, #49	; 0x31
    aa0a:	f7fa fba3 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    aa0e:	0000      	.short	0x0000
    aa10:	20000170 	.word	0x20000170
    aa14:	4808      	ldr	r0, [pc, #32]	; (aa38 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b98>)
    aa16:	b510      	push	{r4, lr}
    aa18:	6840      	ldr	r0, [r0, #4]
    aa1a:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    aa1e:	2921      	cmp	r1, #33	; 0x21
    aa20:	d005      	beq.n	aa2e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b8e>
    aa22:	b121      	cbz	r1, aa2e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1b8e>
    aa24:	f240 719e 	movw	r1, #1950	; 0x79e
    aa28:	2031      	movs	r0, #49	; 0x31
    aa2a:	f7fa fb93 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    aa2e:	2122      	movs	r1, #34	; 0x22
    aa30:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    aa34:	bd10      	pop	{r4, pc}
    aa36:	0000      	.short	0x0000
    aa38:	20000170 	.word	0x20000170
    aa3c:	4809      	ldr	r0, [pc, #36]	; (aa64 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1bc4>)
    aa3e:	b510      	push	{r4, lr}
    aa40:	6840      	ldr	r0, [r0, #4]
    aa42:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    aa46:	2928      	cmp	r1, #40	; 0x28
    aa48:	d006      	beq.n	aa58 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1bb8>
    aa4a:	2915      	cmp	r1, #21
    aa4c:	d006      	beq.n	aa5c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1bbc>
    aa4e:	f240 711e 	movw	r1, #1822	; 0x71e
    aa52:	2031      	movs	r0, #49	; 0x31
    aa54:	f7fa fb7e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    aa58:	2100      	movs	r1, #0
    aa5a:	e000      	b.n	aa5e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1bbe>
    aa5c:	2119      	movs	r1, #25
    aa5e:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    aa62:	bd10      	pop	{r4, pc}
    aa64:	20000170 	.word	0x20000170
    aa68:	4807      	ldr	r0, [pc, #28]	; (aa88 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1be8>)
    aa6a:	b510      	push	{r4, lr}
    aa6c:	6840      	ldr	r0, [r0, #4]
    aa6e:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    aa72:	2915      	cmp	r1, #21
    aa74:	d004      	beq.n	aa80 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1be0>
    aa76:	f240 710a 	movw	r1, #1802	; 0x70a
    aa7a:	2031      	movs	r0, #49	; 0x31
    aa7c:	f7fa fb6a 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    aa80:	2119      	movs	r1, #25
    aa82:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    aa86:	bd10      	pop	{r4, pc}
    aa88:	20000170 	.word	0x20000170
    aa8c:	b510      	push	{r4, lr}
    aa8e:	4c0a      	ldr	r4, [pc, #40]	; (aab8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c18>)
    aa90:	2301      	movs	r3, #1
    aa92:	2100      	movs	r1, #0
    aa94:	6860      	ldr	r0, [r4, #4]
    aa96:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    aa9a:	3078      	adds	r0, #120	; 0x78
    aa9c:	f003 fd5d 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    aaa0:	b120      	cbz	r0, aaac <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c0c>
    aaa2:	6861      	ldr	r1, [r4, #4]
    aaa4:	2004      	movs	r0, #4
    aaa6:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    aaaa:	bd10      	pop	{r4, pc}
    aaac:	f240 61ef 	movw	r1, #1775	; 0x6ef
    aab0:	2031      	movs	r0, #49	; 0x31
    aab2:	f7fa fb4f 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    aab6:	0000      	.short	0x0000
    aab8:	20000170 	.word	0x20000170
    aabc:	4807      	ldr	r0, [pc, #28]	; (aadc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c3c>)
    aabe:	b510      	push	{r4, lr}
    aac0:	6840      	ldr	r0, [r0, #4]
    aac2:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
    aac6:	2915      	cmp	r1, #21
    aac8:	d004      	beq.n	aad4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c34>
    aaca:	f240 7104 	movw	r1, #1796	; 0x704
    aace:	2031      	movs	r0, #49	; 0x31
    aad0:	f7fa fb40 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    aad4:	2117      	movs	r1, #23
    aad6:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    aada:	bd10      	pop	{r4, pc}
    aadc:	20000170 	.word	0x20000170
    aae0:	b538      	push	{r3, r4, r5, lr}
    aae2:	4d20      	ldr	r5, [pc, #128]	; (ab64 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1cc4>)
    aae4:	6869      	ldr	r1, [r5, #4]
    aae6:	f891 0086 	ldrb.w	r0, [r1, #134]	; 0x86
    aaea:	281b      	cmp	r0, #27
    aaec:	d002      	beq.n	aaf4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c54>
    aaee:	f240 7137 	movw	r1, #1847	; 0x737
    aaf2:	e00e      	b.n	ab12 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c72>
    aaf4:	2400      	movs	r4, #0
    aaf6:	f881 40c3 	strb.w	r4, [r1, #195]	; 0xc3
    aafa:	f891 01be 	ldrb.w	r0, [r1, #446]	; 0x1be
    aafe:	f88d 0000 	strb.w	r0, [sp]
    ab02:	9800      	ldr	r0, [sp, #0]
    ab04:	9000      	str	r0, [sp, #0]
    ab06:	f89d 0000 	ldrb.w	r0, [sp]
    ab0a:	2201      	movs	r2, #1
    ab0c:	b120      	cbz	r0, ab18 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c78>
    ab0e:	f240 713b 	movw	r1, #1851	; 0x73b
    ab12:	2031      	movs	r0, #49	; 0x31
    ab14:	f7fa fb1e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ab18:	4812      	ldr	r0, [pc, #72]	; (ab64 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1cc4>)
    ab1a:	f891 30c4 	ldrb.w	r3, [r1, #196]	; 0xc4
    ab1e:	6840      	ldr	r0, [r0, #4]
    ab20:	f500 70db 	add.w	r0, r0, #438	; 0x1b6
    ab24:	b143      	cbz	r3, ab38 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1c98>
    ab26:	f881 40c4 	strb.w	r4, [r1, #196]	; 0xc4
    ab2a:	880a      	ldrh	r2, [r1, #0]
    ab2c:	f8a1 21c2 	strh.w	r2, [r1, #450]	; 0x1c2
    ab30:	f881 41c0 	strb.w	r4, [r1, #448]	; 0x1c0
    ab34:	220a      	movs	r2, #10
    ab36:	e007      	b.n	ab48 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ca8>
    ab38:	880b      	ldrh	r3, [r1, #0]
    ab3a:	f8a1 31c2 	strh.w	r3, [r1, #450]	; 0x1c2
    ab3e:	f881 41c0 	strb.w	r4, [r1, #448]	; 0x1c0
    ab42:	f881 21c4 	strb.w	r2, [r1, #452]	; 0x1c4
    ab46:	2209      	movs	r2, #9
    ab48:	f7fc fb2c 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    ab4c:	6868      	ldr	r0, [r5, #4]
    ab4e:	8800      	ldrh	r0, [r0, #0]
    ab50:	f7fa ff28 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    ab54:	f003 f925 	bl	dda2 <sym_56BVXVVSYPZZTDFBHBV4MJAFTYIS7HMITNWUEZQ>
    ab58:	f7fc fbf6 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    ab5c:	6868      	ldr	r0, [r5, #4]
    ab5e:	f880 4086 	strb.w	r4, [r0, #134]	; 0x86
    ab62:	bd38      	pop	{r3, r4, r5, pc}
    ab64:	20000170 	.word	0x20000170
    ab68:	b510      	push	{r4, lr}
    ab6a:	4c08      	ldr	r4, [pc, #32]	; (ab8c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1cec>)
    ab6c:	2301      	movs	r3, #1
    ab6e:	4619      	mov	r1, r3
    ab70:	6860      	ldr	r0, [r4, #4]
    ab72:	f890 2088 	ldrb.w	r2, [r0, #136]	; 0x88
    ab76:	3078      	adds	r0, #120	; 0x78
    ab78:	f003 fcef 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    ab7c:	2800      	cmp	r0, #0
    ab7e:	d103      	bne.n	ab88 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ce8>
    ab80:	6861      	ldr	r1, [r4, #4]
    ab82:	2008      	movs	r0, #8
    ab84:	f881 0088 	strb.w	r0, [r1, #136]	; 0x88
    ab88:	bd10      	pop	{r4, pc}
    ab8a:	0000      	.short	0x0000
    ab8c:	20000170 	.word	0x20000170
    ab90:	4815      	ldr	r0, [pc, #84]	; (abe8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d48>)
    ab92:	b510      	push	{r4, lr}
    ab94:	6880      	ldr	r0, [r0, #8]
    ab96:	7901      	ldrb	r1, [r0, #4]
    ab98:	4813      	ldr	r0, [pc, #76]	; (abe8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d48>)
    ab9a:	3010      	adds	r0, #16
    ab9c:	6840      	ldr	r0, [r0, #4]
    ab9e:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    aba2:	2a0a      	cmp	r2, #10
    aba4:	d109      	bne.n	abba <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d1a>
    aba6:	f890 2109 	ldrb.w	r2, [r0, #265]	; 0x109
    abaa:	428a      	cmp	r2, r1
    abac:	d105      	bne.n	abba <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d1a>
    abae:	2100      	movs	r1, #0
    abb0:	f880 1085 	strb.w	r1, [r0, #133]	; 0x85
    abb4:	f880 10be 	strb.w	r1, [r0, #190]	; 0xbe
    abb8:	bd10      	pop	{r4, pc}
    abba:	f890 2087 	ldrb.w	r2, [r0, #135]	; 0x87
    abbe:	0713      	lsls	r3, r2, #28
    abc0:	d507      	bpl.n	abd2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d32>
    abc2:	f002 01f7 	and.w	r1, r2, #247	; 0xf7
    abc6:	f880 1087 	strb.w	r1, [r0, #135]	; 0x87
    abca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    abce:	f7fe ba75 	b.w	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    abd2:	29ff      	cmp	r1, #255	; 0xff
    abd4:	d004      	beq.n	abe0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d40>
    abd6:	f240 61e2 	movw	r1, #1762	; 0x6e2
    abda:	2031      	movs	r0, #49	; 0x31
    abdc:	f7fa faba 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    abe0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    abe4:	f7ff be5a 	b.w	a89c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x19fc>
    abe8:	20000160 	.word	0x20000160
    abec:	b510      	push	{r4, lr}
    abee:	4c15      	ldr	r4, [pc, #84]	; (ac44 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1da4>)
    abf0:	6860      	ldr	r0, [r4, #4]
    abf2:	f890 10c5 	ldrb.w	r1, [r0, #197]	; 0xc5
    abf6:	0789      	lsls	r1, r1, #30
    abf8:	d411      	bmi.n	ac1e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d7e>
    abfa:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    abfe:	2301      	movs	r3, #1
    ac00:	2100      	movs	r1, #0
    ac02:	3078      	adds	r0, #120	; 0x78
    ac04:	f003 fca9 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    ac08:	b120      	cbz	r0, ac14 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d74>
    ac0a:	6861      	ldr	r1, [r4, #4]
    ac0c:	2006      	movs	r0, #6
    ac0e:	f881 0085 	strb.w	r0, [r1, #133]	; 0x85
    ac12:	e009      	b.n	ac28 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1d88>
    ac14:	f240 7163 	movw	r1, #1891	; 0x763
    ac18:	2031      	movs	r0, #49	; 0x31
    ac1a:	f7fa fa9b 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ac1e:	2100      	movs	r1, #0
    ac20:	f880 10be 	strb.w	r1, [r0, #190]	; 0xbe
    ac24:	f880 112a 	strb.w	r1, [r0, #298]	; 0x12a
    ac28:	6860      	ldr	r0, [r4, #4]
    ac2a:	f890 0087 	ldrb.w	r0, [r0, #135]	; 0x87
    ac2e:	0780      	lsls	r0, r0, #30
    ac30:	d507      	bpl.n	ac42 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1da2>
    ac32:	f7fe fa43 	bl	90bc <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x21c>
    ac36:	6860      	ldr	r0, [r4, #4]
    ac38:	f810 1f87 	ldrb.w	r1, [r0, #135]!
    ac3c:	f001 01fd 	and.w	r1, r1, #253	; 0xfd
    ac40:	7001      	strb	r1, [r0, #0]
    ac42:	bd10      	pop	{r4, pc}
    ac44:	20000170 	.word	0x20000170
    ac48:	4808      	ldr	r0, [pc, #32]	; (ac6c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1dcc>)
    ac4a:	b510      	push	{r4, lr}
    ac4c:	6840      	ldr	r0, [r0, #4]
    ac4e:	f890 108c 	ldrb.w	r1, [r0, #140]	; 0x8c
    ac52:	b941      	cbnz	r1, ac66 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1dc6>
    ac54:	f890 2086 	ldrb.w	r2, [r0, #134]	; 0x86
    ac58:	2301      	movs	r3, #1
    ac5a:	2106      	movs	r1, #6
    ac5c:	3078      	adds	r0, #120	; 0x78
    ac5e:	f003 fc7c 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    ac62:	2800      	cmp	r0, #0
    ac64:	d000      	beq.n	ac68 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1dc8>
    ac66:	2001      	movs	r0, #1
    ac68:	bd10      	pop	{r4, pc}
    ac6a:	0000      	.short	0x0000
    ac6c:	20000170 	.word	0x20000170
    ac70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ac72:	4c5e      	ldr	r4, [pc, #376]	; (adec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f4c>)
    ac74:	4607      	mov	r7, r0
    ac76:	4615      	mov	r5, r2
    ac78:	6860      	ldr	r0, [r4, #4]
    ac7a:	2200      	movs	r2, #0
    ac7c:	b111      	cbz	r1, ac84 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1de4>
    ac7e:	f8a0 21de 	strh.w	r2, [r0, #478]	; 0x1de
    ac82:	e006      	b.n	ac92 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1df2>
    ac84:	f8b0 11de 	ldrh.w	r1, [r0, #478]	; 0x1de
    ac88:	f8b0 21ce 	ldrh.w	r2, [r0, #462]	; 0x1ce
    ac8c:	4411      	add	r1, r2
    ac8e:	f8a0 11de 	strh.w	r1, [r0, #478]	; 0x1de
    ac92:	f890 1118 	ldrb.w	r1, [r0, #280]	; 0x118
    ac96:	f88d 1000 	strb.w	r1, [sp]
    ac9a:	9900      	ldr	r1, [sp, #0]
    ac9c:	9100      	str	r1, [sp, #0]
    ac9e:	f89d 1000 	ldrb.w	r1, [sp]
    aca2:	b939      	cbnz	r1, acb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e14>
    aca4:	f890 2088 	ldrb.w	r2, [r0, #136]	; 0x88
    aca8:	2301      	movs	r3, #1
    acaa:	4619      	mov	r1, r3
    acac:	3078      	adds	r0, #120	; 0x78
    acae:	f003 fc54 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    acb2:	b130      	cbz	r0, acc2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e22>
    acb4:	6860      	ldr	r0, [r4, #4]
    acb6:	f830 1fb8 	ldrh.w	r1, [r0, #184]!
    acba:	f8b0 2116 	ldrh.w	r2, [r0, #278]	; 0x116
    acbe:	4411      	add	r1, r2
    acc0:	8001      	strh	r1, [r0, #0]
    acc2:	6861      	ldr	r1, [r4, #4]
    acc4:	f891 00be 	ldrb.w	r0, [r1, #190]	; 0xbe
    acc8:	b130      	cbz	r0, acd8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e38>
    acca:	f8b1 20ba 	ldrh.w	r2, [r1, #186]	; 0xba
    acce:	f8b1 31ce 	ldrh.w	r3, [r1, #462]	; 0x1ce
    acd2:	441a      	add	r2, r3
    acd4:	f8a1 20ba 	strh.w	r2, [r1, #186]	; 0xba
    acd8:	f991 20c2 	ldrsb.w	r2, [r1, #194]	; 0xc2
    acdc:	2a00      	cmp	r2, #0
    acde:	dd06      	ble.n	acee <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e4e>
    ace0:	f8b1 30c0 	ldrh.w	r3, [r1, #192]	; 0xc0
    ace4:	f8b1 61ce 	ldrh.w	r6, [r1, #462]	; 0x1ce
    ace8:	4433      	add	r3, r6
    acea:	f8a1 30c0 	strh.w	r3, [r1, #192]	; 0xc0
    acee:	263d      	movs	r6, #61	; 0x3d
    acf0:	b117      	cbz	r7, acf8 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e58>
    acf2:	f881 60a6 	strb.w	r6, [r1, #166]	; 0xa6
    acf6:	e016      	b.n	ad26 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e86>
    acf8:	4b3c      	ldr	r3, [pc, #240]	; (adec <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f4c>)
    acfa:	3b10      	subs	r3, #16
    acfc:	781b      	ldrb	r3, [r3, #0]
    acfe:	2b02      	cmp	r3, #2
    ad00:	d00b      	beq.n	ad1a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e7a>
    ad02:	2b01      	cmp	r3, #1
    ad04:	d015      	beq.n	ad32 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e92>
    ad06:	b36d      	cbz	r5, ad64 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ec4>
    ad08:	f101 009d 	add.w	r0, r1, #157	; 0x9d
    ad0c:	2208      	movs	r2, #8
    ad0e:	f7fc fa49 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    ad12:	06e8      	lsls	r0, r5, #27
    ad14:	d510      	bpl.n	ad38 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e98>
    ad16:	201e      	movs	r0, #30
    ad18:	e01b      	b.n	ad52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1eb2>
    ad1a:	f891 010e 	ldrb.w	r0, [r1, #270]	; 0x10e
    ad1e:	2806      	cmp	r0, #6
    ad20:	d048      	beq.n	adb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f14>
    ad22:	2016      	movs	r0, #22
    ad24:	e046      	b.n	adb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f14>
    ad26:	f101 009d 	add.w	r0, r1, #157	; 0x9d
    ad2a:	2208      	movs	r2, #8
    ad2c:	f7fc fa3a 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    ad30:	e049      	b.n	adc6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f26>
    ad32:	f891 0089 	ldrb.w	r0, [r1, #137]	; 0x89
    ad36:	e03d      	b.n	adb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f14>
    ad38:	0728      	lsls	r0, r5, #28
    ad3a:	d503      	bpl.n	ad44 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ea4>
    ad3c:	6860      	ldr	r0, [r4, #4]
    ad3e:	f880 60a6 	strb.w	r6, [r0, #166]	; 0xa6
    ad42:	e040      	b.n	adc6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f26>
    ad44:	06a8      	lsls	r0, r5, #26
    ad46:	d501      	bpl.n	ad4c <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1eac>
    ad48:	2023      	movs	r0, #35	; 0x23
    ad4a:	e002      	b.n	ad52 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1eb2>
    ad4c:	07a8      	lsls	r0, r5, #30
    ad4e:	d004      	beq.n	ad5a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1eba>
    ad50:	202a      	movs	r0, #42	; 0x2a
    ad52:	6861      	ldr	r1, [r4, #4]
    ad54:	f881 00a6 	strb.w	r0, [r1, #166]	; 0xa6
    ad58:	e035      	b.n	adc6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f26>
    ad5a:	f640 4173 	movw	r1, #3187	; 0xc73
    ad5e:	2031      	movs	r0, #49	; 0x31
    ad60:	f7fa f9f8 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ad64:	b128      	cbz	r0, ad72 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ed2>
    ad66:	f8b1 00ba 	ldrh.w	r0, [r1, #186]	; 0xba
    ad6a:	f8b1 30bc 	ldrh.w	r3, [r1, #188]	; 0xbc
    ad6e:	4298      	cmp	r0, r3
    ad70:	d216      	bcs.n	ada0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f00>
    ad72:	2a00      	cmp	r2, #0
    ad74:	dd05      	ble.n	ad82 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1ee2>
    ad76:	f8b1 00c0 	ldrh.w	r0, [r1, #192]	; 0xc0
    ad7a:	f8b1 20bc 	ldrh.w	r2, [r1, #188]	; 0xbc
    ad7e:	4290      	cmp	r0, r2
    ad80:	d20e      	bcs.n	ada0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f00>
    ad82:	f8b1 20b8 	ldrh.w	r2, [r1, #184]	; 0xb8
    ad86:	f8b1 00b6 	ldrh.w	r0, [r1, #182]	; 0xb6
    ad8a:	4282      	cmp	r2, r0
    ad8c:	d30a      	bcc.n	ada4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f04>
    ad8e:	f891 2118 	ldrb.w	r2, [r1, #280]	; 0x118
    ad92:	f88d 2000 	strb.w	r2, [sp]
    ad96:	9a00      	ldr	r2, [sp, #0]
    ad98:	9200      	str	r2, [sp, #0]
    ad9a:	f89d 2000 	ldrb.w	r2, [sp]
    ad9e:	b10a      	cbz	r2, ada4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f04>
    ada0:	2022      	movs	r0, #34	; 0x22
    ada2:	e007      	b.n	adb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f14>
    ada4:	f891 208a 	ldrb.w	r2, [r1, #138]	; 0x8a
    ada8:	b13a      	cbz	r2, adba <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f1a>
    adaa:	f8b1 20b4 	ldrh.w	r2, [r1, #180]	; 0xb4
    adae:	4282      	cmp	r2, r0
    adb0:	d309      	bcc.n	adc6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f26>
    adb2:	2008      	movs	r0, #8
    adb4:	f881 00a6 	strb.w	r0, [r1, #166]	; 0xa6
    adb8:	e7b5      	b.n	ad26 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1e86>
    adba:	f8b1 00b4 	ldrh.w	r0, [r1, #180]	; 0xb4
    adbe:	2806      	cmp	r0, #6
    adc0:	d301      	bcc.n	adc6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f26>
    adc2:	203e      	movs	r0, #62	; 0x3e
    adc4:	e7f6      	b.n	adb4 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f14>
    adc6:	6860      	ldr	r0, [r4, #4]
    adc8:	f890 10a5 	ldrb.w	r1, [r0, #165]	; 0xa5
    adcc:	f88d 1000 	strb.w	r1, [sp]
    add0:	9900      	ldr	r1, [sp, #0]
    add2:	9100      	str	r1, [sp, #0]
    add4:	f89d 1000 	ldrb.w	r1, [sp]
    add8:	b119      	cbz	r1, ade2 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f42>
    adda:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    adde:	f005 b857 	b.w	fe90 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ>
    ade2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ade6:	2100      	movs	r1, #0
    ade8:	f7fd bc38 	b.w	865c <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI>
    adec:	20000170 	.word	0x20000170
    adf0:	b570      	push	{r4, r5, r6, lr}
    adf2:	4d2e      	ldr	r5, [pc, #184]	; (aeac <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x200c>)
    adf4:	6868      	ldr	r0, [r5, #4]
    adf6:	f890 108a 	ldrb.w	r1, [r0, #138]	; 0x8a
    adfa:	b151      	cbz	r1, ae12 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f72>
    adfc:	2901      	cmp	r1, #1
    adfe:	d008      	beq.n	ae12 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f72>
    ae00:	2902      	cmp	r1, #2
    ae02:	d009      	beq.n	ae18 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f78>
    ae04:	2903      	cmp	r1, #3
    ae06:	d007      	beq.n	ae18 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f78>
    ae08:	f640 21f1 	movw	r1, #2801	; 0xaf1
    ae0c:	2031      	movs	r0, #49	; 0x31
    ae0e:	f7fa f9a1 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ae12:	f8b0 11cc 	ldrh.w	r1, [r0, #460]	; 0x1cc
    ae16:	e037      	b.n	ae88 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fe8>
    ae18:	f890 1088 	ldrb.w	r1, [r0, #136]	; 0x88
    ae1c:	2908      	cmp	r1, #8
    ae1e:	d036      	beq.n	ae8e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fee>
    ae20:	f8b0 20b4 	ldrh.w	r2, [r0, #180]	; 0xb4
    ae24:	f8b0 10b6 	ldrh.w	r1, [r0, #182]	; 0xb6
    ae28:	2400      	movs	r4, #0
    ae2a:	1c93      	adds	r3, r2, #2
    ae2c:	4299      	cmp	r1, r3
    ae2e:	d306      	bcc.n	ae3e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f9e>
    ae30:	1a89      	subs	r1, r1, r2
    ae32:	1e89      	subs	r1, r1, #2
    ae34:	040c      	lsls	r4, r1, #16
    ae36:	0c24      	lsrs	r4, r4, #16
    ae38:	d001      	beq.n	ae3e <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f9e>
    ae3a:	1e64      	subs	r4, r4, #1
    ae3c:	b2a4      	uxth	r4, r4
    ae3e:	f890 10b2 	ldrb.w	r1, [r0, #178]	; 0xb2
    ae42:	b139      	cbz	r1, ae54 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fb4>
    ae44:	f890 2085 	ldrb.w	r2, [r0, #133]	; 0x85
    ae48:	2301      	movs	r3, #1
    ae4a:	2109      	movs	r1, #9
    ae4c:	3078      	adds	r0, #120	; 0x78
    ae4e:	f003 fb84 	bl	e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>
    ae52:	b340      	cbz	r0, aea6 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x2006>
    ae54:	f7ff fef8 	bl	ac48 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1da8>
    ae58:	b178      	cbz	r0, ae7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fda>
    ae5a:	686a      	ldr	r2, [r5, #4]
    ae5c:	2000      	movs	r0, #0
    ae5e:	f8d2 10ac 	ldr.w	r1, [r2, #172]	; 0xac
    ae62:	f8d2 20a8 	ldr.w	r2, [r2, #168]	; 0xa8
    ae66:	1c93      	adds	r3, r2, #2
    ae68:	4299      	cmp	r1, r3
    ae6a:	d303      	bcc.n	ae74 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fd4>
    ae6c:	1a88      	subs	r0, r1, r2
    ae6e:	1e80      	subs	r0, r0, #2
    ae70:	d000      	beq.n	ae74 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fd4>
    ae72:	1e40      	subs	r0, r0, #1
    ae74:	42a0      	cmp	r0, r4
    ae76:	d200      	bcs.n	ae7a <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fda>
    ae78:	b284      	uxth	r4, r0
    ae7a:	b10c      	cbz	r4, ae80 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fe0>
    ae7c:	1e64      	subs	r4, r4, #1
    ae7e:	b2a4      	uxth	r4, r4
    ae80:	6868      	ldr	r0, [r5, #4]
    ae82:	f8b0 11cc 	ldrh.w	r1, [r0, #460]	; 0x1cc
    ae86:	4421      	add	r1, r4
    ae88:	f8a0 11c8 	strh.w	r1, [r0, #456]	; 0x1c8
    ae8c:	bd70      	pop	{r4, r5, r6, pc}
    ae8e:	f8b0 10b4 	ldrh.w	r1, [r0, #180]	; 0xb4
    ae92:	2903      	cmp	r1, #3
    ae94:	d3bd      	bcc.n	ae12 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1f72>
    ae96:	f830 1f7c 	ldrh.w	r1, [r0, #124]!
    ae9a:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
    ae9c:	4411      	add	r1, r2
    ae9e:	1c49      	adds	r1, r1, #1
    aea0:	f8a0 114c 	strh.w	r1, [r0, #332]	; 0x14c
    aea4:	bd70      	pop	{r4, r5, r6, pc}
    aea6:	2400      	movs	r4, #0
    aea8:	e7ea      	b.n	ae80 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0x1fe0>
    aeaa:	0000      	.short	0x0000
    aeac:	20000170 	.word	0x20000170

0000aeb0 <sym_Y5RIWFUVP4FHJFYC7FBZKM2MV7INK43TLWQ5URA>:
    aeb0:	4903      	ldr	r1, [pc, #12]	; (aec0 <sym_Y5RIWFUVP4FHJFYC7FBZKM2MV7INK43TLWQ5URA+0x10>)
    aeb2:	884a      	ldrh	r2, [r1, #2]
    aeb4:	8002      	strh	r2, [r0, #0]
    aeb6:	7809      	ldrb	r1, [r1, #0]
    aeb8:	7081      	strb	r1, [r0, #2]
    aeba:	2000      	movs	r0, #0
    aebc:	4770      	bx	lr
    aebe:	0000      	.short	0x0000
    aec0:	2000165c 	.word	0x2000165c

0000aec4 <sym_PAQFQMAKUCMOA6SUTJ7CAX3DYCWNAJLJQFJCDNY>:
    aec4:	b53e      	push	{r1, r2, r3, r4, r5, lr}
    aec6:	460c      	mov	r4, r1
    aec8:	4605      	mov	r5, r0
    aeca:	8800      	ldrh	r0, [r0, #0]
    aecc:	4669      	mov	r1, sp
    aece:	f003 fb1a 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    aed2:	2200      	movs	r2, #0
    aed4:	b128      	cbz	r0, aee2 <sym_PAQFQMAKUCMOA6SUTJ7CAX3DYCWNAJLJQFJCDNY+0x1e>
    aed6:	f8c4 2002 	str.w	r2, [r4, #2]
    aeda:	71a2      	strb	r2, [r4, #6]
    aedc:	8022      	strh	r2, [r4, #0]
    aede:	2002      	movs	r0, #2
    aee0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    aee2:	9901      	ldr	r1, [sp, #4]
    aee4:	f111 0178 	adds.w	r1, r1, #120	; 0x78
    aee8:	f881 2064 	strb.w	r2, [r1, #100]	; 0x64
    aeec:	f8d1 0017 	ldr.w	r0, [r1, #23]
    aef0:	f8c4 0002 	str.w	r0, [r4, #2]
    aef4:	7ec8      	ldrb	r0, [r1, #27]
    aef6:	71a0      	strb	r0, [r4, #6]
    aef8:	8828      	ldrh	r0, [r5, #0]
    aefa:	8020      	strh	r0, [r4, #0]
    aefc:	f891 0064 	ldrb.w	r0, [r1, #100]	; 0x64
    af00:	f88d 0008 	strb.w	r0, [sp, #8]
    af04:	9802      	ldr	r0, [sp, #8]
    af06:	9002      	str	r0, [sp, #8]
    af08:	f89d 0008 	ldrb.w	r0, [sp, #8]
    af0c:	2800      	cmp	r0, #0
    af0e:	d1eb      	bne.n	aee8 <sym_PAQFQMAKUCMOA6SUTJ7CAX3DYCWNAJLJQFJCDNY+0x24>
    af10:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	...

0000af14 <sym_VT6ZFFM2E7JNVAG5YLSPAZYR4HOPL3X5GX3IH7A>:
    af14:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
    af16:	460d      	mov	r5, r1
    af18:	4606      	mov	r6, r0
    af1a:	8800      	ldrh	r0, [r0, #0]
    af1c:	4669      	mov	r1, sp
    af1e:	f003 faf2 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    af22:	2800      	cmp	r0, #0
    af24:	d11a      	bne.n	af5c <sym_VT6ZFFM2E7JNVAG5YLSPAZYR4HOPL3X5GX3IH7A+0x48>
    af26:	f8dd 4004 	ldr.w	r4, [sp, #4]
    af2a:	2700      	movs	r7, #0
    af2c:	f884 7070 	strb.w	r7, [r4, #112]	; 0x70
    af30:	f814 0f6e 	ldrb.w	r0, [r4, #110]!
    af34:	f005 fc8c 	bl	10850 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2e>
    af38:	70a8      	strb	r0, [r5, #2]
    af3a:	7860      	ldrb	r0, [r4, #1]
    af3c:	f005 fc88 	bl	10850 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2e>
    af40:	70e8      	strb	r0, [r5, #3]
    af42:	78a0      	ldrb	r0, [r4, #2]
    af44:	f88d 0008 	strb.w	r0, [sp, #8]
    af48:	9802      	ldr	r0, [sp, #8]
    af4a:	9002      	str	r0, [sp, #8]
    af4c:	f89d 0008 	ldrb.w	r0, [sp, #8]
    af50:	3c6e      	subs	r4, #110	; 0x6e
    af52:	2800      	cmp	r0, #0
    af54:	d1ea      	bne.n	af2c <sym_VT6ZFFM2E7JNVAG5YLSPAZYR4HOPL3X5GX3IH7A+0x18>
    af56:	8830      	ldrh	r0, [r6, #0]
    af58:	8028      	strh	r0, [r5, #0]
    af5a:	2000      	movs	r0, #0
    af5c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0000af60 <sym_THL6EKGE7AKTO5JDGU45MV33YSIXORBRMDECS2Q>:
    af60:	4903      	ldr	r1, [pc, #12]	; (af70 <sym_THL6EKGE7AKTO5JDGU45MV33YSIXORBRMDECS2Q+0x10>)
    af62:	888a      	ldrh	r2, [r1, #4]
    af64:	8002      	strh	r2, [r0, #0]
    af66:	88c9      	ldrh	r1, [r1, #6]
    af68:	8041      	strh	r1, [r0, #2]
    af6a:	2000      	movs	r0, #0
    af6c:	4770      	bx	lr
    af6e:	0000      	.short	0x0000
    af70:	200002b0 	.word	0x200002b0

0000af74 <sym_4POEZKL66A5T3356722OWKNB5CNFKPMV6JI3HEA>:
    af74:	b53e      	push	{r1, r2, r3, r4, r5, lr}
    af76:	2400      	movs	r4, #0
    af78:	a902      	add	r1, sp, #8
    af7a:	f88d 4004 	strb.w	r4, [sp, #4]
    af7e:	f88d 4008 	strb.w	r4, [sp, #8]
    af82:	9100      	str	r1, [sp, #0]
    af84:	7882      	ldrb	r2, [r0, #2]
    af86:	7841      	ldrb	r1, [r0, #1]
    af88:	7800      	ldrb	r0, [r0, #0]
    af8a:	ab01      	add	r3, sp, #4
    af8c:	f005 fdeb 	bl	10b66 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x344>
    af90:	2800      	cmp	r0, #0
    af92:	d112      	bne.n	afba <sym_4POEZKL66A5T3356722OWKNB5CNFKPMV6JI3HEA+0x46>
    af94:	f89d 0004 	ldrb.w	r0, [sp, #4]
    af98:	f005 fd26 	bl	109e8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1c6>
    af9c:	b170      	cbz	r0, afbc <sym_4POEZKL66A5T3356722OWKNB5CNFKPMV6JI3HEA+0x48>
    af9e:	f89d 0008 	ldrb.w	r0, [sp, #8]
    afa2:	f005 fd21 	bl	109e8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1c6>
    afa6:	b148      	cbz	r0, afbc <sym_4POEZKL66A5T3356722OWKNB5CNFKPMV6JI3HEA+0x48>
    afa8:	4805      	ldr	r0, [pc, #20]	; (afc0 <sym_4POEZKL66A5T3356722OWKNB5CNFKPMV6JI3HEA+0x4c>)
    afaa:	f89d 1004 	ldrb.w	r1, [sp, #4]
    afae:	7381      	strb	r1, [r0, #14]
    afb0:	f89d 1008 	ldrb.w	r1, [sp, #8]
    afb4:	73c1      	strb	r1, [r0, #15]
    afb6:	8204      	strh	r4, [r0, #16]
    afb8:	2000      	movs	r0, #0
    afba:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    afbc:	2011      	movs	r0, #17
    afbe:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    afc0:	2000165c 	.word	0x2000165c

0000afc4 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI>:
    afc4:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    afc8:	460f      	mov	r7, r1
    afca:	4605      	mov	r5, r0
    afcc:	7806      	ldrb	r6, [r0, #0]
    afce:	f005 fcbe 	bl	1094e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x12c>
    afd2:	2800      	cmp	r0, #0
    afd4:	d10a      	bne.n	afec <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x28>
    afd6:	4628      	mov	r0, r5
    afd8:	f005 fc93 	bl	10902 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xe0>
    afdc:	2800      	cmp	r0, #0
    afde:	d105      	bne.n	afec <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x28>
    afe0:	2001      	movs	r0, #1
    afe2:	f7fa faad 	bl	5540 <sym_XHE47EZYHONCPR22HUAZULMCALDJINMYREOFDEI>
    afe6:	4286      	cmp	r6, r0
    afe8:	d302      	bcc.n	aff0 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x2c>
    afea:	2007      	movs	r0, #7
    afec:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
    aff0:	2101      	movs	r1, #1
    aff2:	4630      	mov	r0, r6
    aff4:	f002 fff9 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
    aff8:	0004      	movs	r4, r0
    affa:	d004      	beq.n	b006 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x42>
    affc:	f004 fb3b 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
    b000:	b170      	cbz	r0, b020 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x5c>
    b002:	200c      	movs	r0, #12
    b004:	e7f2      	b.n	afec <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x28>
    b006:	2200      	movs	r2, #0
    b008:	2101      	movs	r1, #1
    b00a:	4630      	mov	r0, r6
    b00c:	f002 ffe3 	bl	dfd6 <sym_7JFC7IFAJQVPYCQHAIUKZ626ISM3VUWBEEXY7WI>
    b010:	0004      	movs	r4, r0
    b012:	d013      	beq.n	b03c <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x78>
    b014:	4817      	ldr	r0, [pc, #92]	; (b074 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0xb0>)
    b016:	f990 1000 	ldrsb.w	r1, [r0]
    b01a:	4620      	mov	r0, r4
    b01c:	f004 f8c7 	bl	f1ae <sym_YA57TPZ3CLQ6C73TD2RIGTELUAMYOOAKHU5T7RQ>
    b020:	4620      	mov	r0, r4
    b022:	f004 f970 	bl	f306 <sym_L5UCRJFFWEVVII5IYG6PAKIQHXM34B62KO6ERPY>
    b026:	7038      	strb	r0, [r7, #0]
    b028:	74e8      	strb	r0, [r5, #19]
    b02a:	4629      	mov	r1, r5
    b02c:	4620      	mov	r0, r4
    b02e:	f7fc fb89 	bl	7744 <sym_L2IWXNCKXJIQJRTEIIW7HGFEPJAQM34TKD2GOIA>
    b032:	4606      	mov	r6, r0
    b034:	7e68      	ldrb	r0, [r5, #25]
    b036:	b1d0      	cbz	r0, b06e <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0xaa>
    b038:	b12e      	cbz	r6, b046 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x82>
    b03a:	e018      	b.n	b06e <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0xaa>
    b03c:	f241 215a 	movw	r1, #4698	; 0x125a
    b040:	2039      	movs	r0, #57	; 0x39
    b042:	f7fa f887 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b046:	2200      	movs	r2, #0
    b048:	4668      	mov	r0, sp
    b04a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    b04c:	f003 f891 	bl	e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>
    b050:	2200      	movs	r2, #0
    b052:	2101      	movs	r1, #1
    b054:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    b056:	f003 f902 	bl	e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>
    b05a:	2204      	movs	r2, #4
    b05c:	4668      	mov	r0, sp
    b05e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    b060:	f003 f887 	bl	e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>
    b064:	2200      	movs	r2, #0
    b066:	4611      	mov	r1, r2
    b068:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    b06a:	f003 f8f8 	bl	e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>
    b06e:	4630      	mov	r0, r6
    b070:	e7bc      	b.n	afec <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI+0x28>
    b072:	0000      	.short	0x0000
    b074:	200002a8 	.word	0x200002a8

0000b078 <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI>:
    b078:	7801      	ldrb	r1, [r0, #0]
    b07a:	b171      	cbz	r1, b09a <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI+0x22>
    b07c:	7841      	ldrb	r1, [r0, #1]
    b07e:	b161      	cbz	r1, b09a <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI+0x22>
    b080:	8841      	ldrh	r1, [r0, #2]
    b082:	291b      	cmp	r1, #27
    b084:	d309      	bcc.n	b09a <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI+0x22>
    b086:	8881      	ldrh	r1, [r0, #4]
    b088:	291b      	cmp	r1, #27
    b08a:	d306      	bcc.n	b09a <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI+0x22>
    b08c:	4904      	ldr	r1, [pc, #16]	; (b0a0 <sym_XQWU4MX22DPQIRRYTXBNWTH2DBYK7MH33FME7FI+0x28>)
    b08e:	6802      	ldr	r2, [r0, #0]
    b090:	600a      	str	r2, [r1, #0]
    b092:	8880      	ldrh	r0, [r0, #4]
    b094:	8088      	strh	r0, [r1, #4]
    b096:	2000      	movs	r0, #0
    b098:	4770      	bx	lr
    b09a:	2012      	movs	r0, #18
    b09c:	4770      	bx	lr
    b09e:	0000      	.short	0x0000
    b0a0:	2000165c 	.word	0x2000165c

0000b0a4 <sym_DVVOECRRYK6EAGDREB2UKKQZT5MAOOUK66XNPTA>:
    b0a4:	6800      	ldr	r0, [r0, #0]
    b0a6:	f240 41e2 	movw	r1, #1250	; 0x4e2
    b0aa:	4288      	cmp	r0, r1
    b0ac:	d303      	bcc.n	b0b6 <sym_DVVOECRRYK6EAGDREB2UKKQZT5MAOOUK66XNPTA+0x12>
    b0ae:	4903      	ldr	r1, [pc, #12]	; (b0bc <sym_DVVOECRRYK6EAGDREB2UKKQZT5MAOOUK66XNPTA+0x18>)
    b0b0:	6088      	str	r0, [r1, #8]
    b0b2:	2000      	movs	r0, #0
    b0b4:	4770      	bx	lr
    b0b6:	2012      	movs	r0, #18
    b0b8:	4770      	bx	lr
    b0ba:	0000      	.short	0x0000
    b0bc:	2000165c 	.word	0x2000165c

0000b0c0 <sym_VBKW2EEGTD4JJSNUU73GLQHLYR7TWOGYRMQYZEY>:
    b0c0:	4a03      	ldr	r2, [pc, #12]	; (b0d0 <sym_VBKW2EEGTD4JJSNUU73GLQHLYR7TWOGYRMQYZEY+0x10>)
    b0c2:	e9d2 1200 	ldrd	r1, r2, [r2]
    b0c6:	6001      	str	r1, [r0, #0]
    b0c8:	6042      	str	r2, [r0, #4]
    b0ca:	2000      	movs	r0, #0
    b0cc:	4770      	bx	lr
    b0ce:	0000      	.short	0x0000
    b0d0:	0000b52c 	.word	0x0000b52c

0000b0d4 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI>:
    b0d4:	b510      	push	{r4, lr}
    b0d6:	2005      	movs	r0, #5
    b0d8:	f000 faa2 	bl	b620 <sym_N6TOG3AODPPFNS6LXFKKIADNGIMUMBS5BXPEFOY>
    b0dc:	f7fd fe38 	bl	8d50 <sym_OGXWMXSCK2QG6TOSCWHHS4PII24VSXWVJJIPCDI>
    b0e0:	4902      	ldr	r1, [pc, #8]	; (b0ec <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x18>)
    b0e2:	4801      	ldr	r0, [pc, #4]	; (b0e8 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x14>)
    b0e4:	6048      	str	r0, [r1, #4]
    b0e6:	bd10      	pop	{r4, pc}
    b0e8:	0000b0f1 	.word	0x0000b0f1
    b0ec:	200002a8 	.word	0x200002a8
    b0f0:	e92d 43fe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, lr}
    b0f4:	4613      	mov	r3, r2
    b0f6:	4a33      	ldr	r2, [pc, #204]	; (b1c4 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xf0>)
    b0f8:	460f      	mov	r7, r1
    b0fa:	f8b0 1058 	ldrh.w	r1, [r0, #88]	; 0x58
    b0fe:	8814      	ldrh	r4, [r2, #0]
    b100:	f8b0 6056 	ldrh.w	r6, [r0, #86]	; 0x56
    b104:	428c      	cmp	r4, r1
    b106:	d200      	bcs.n	b10a <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x36>
    b108:	4621      	mov	r1, r4
    b10a:	4688      	mov	r8, r1
    b10c:	8891      	ldrh	r1, [r2, #4]
    b10e:	42b1      	cmp	r1, r6
    b110:	d200      	bcs.n	b114 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x40>
    b112:	460e      	mov	r6, r1
    b114:	8851      	ldrh	r1, [r2, #2]
    b116:	f640 0448 	movw	r4, #2120	; 0x848
    b11a:	42a1      	cmp	r1, r4
    b11c:	d300      	bcc.n	b120 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x4c>
    b11e:	4621      	mov	r1, r4
    b120:	88d5      	ldrh	r5, [r2, #6]
    b122:	42a5      	cmp	r5, r4
    b124:	d300      	bcc.n	b128 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x54>
    b126:	4625      	mov	r5, r4
    b128:	42a1      	cmp	r1, r4
    b12a:	d200      	bcs.n	b12e <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x5a>
    b12c:	460c      	mov	r4, r1
    b12e:	f44f 72a4 	mov.w	r2, #328	; 0x148
    b132:	2e1b      	cmp	r6, #27
    b134:	d001      	beq.n	b13a <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x66>
    b136:	4295      	cmp	r5, r2
    b138:	d104      	bne.n	b144 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x70>
    b13a:	f1b8 0f1b 	cmp.w	r8, #27
    b13e:	d03e      	beq.n	b1be <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xea>
    b140:	4294      	cmp	r4, r2
    b142:	d03c      	beq.n	b1be <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xea>
    b144:	466a      	mov	r2, sp
    b146:	4619      	mov	r1, r3
    b148:	f005 fc71 	bl	10a2e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x20c>
    b14c:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    b150:	4641      	mov	r1, r8
    b152:	4540      	cmp	r0, r8
    b154:	d900      	bls.n	b158 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x84>
    b156:	4608      	mov	r0, r1
    b158:	80f8      	strh	r0, [r7, #6]
    b15a:	f8bd 1008 	ldrh.w	r1, [sp, #8]
    b15e:	42a1      	cmp	r1, r4
    b160:	d800      	bhi.n	b164 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x90>
    b162:	460c      	mov	r4, r1
    b164:	813c      	strh	r4, [r7, #8]
    b166:	f8bd 1002 	ldrh.w	r1, [sp, #2]
    b16a:	42b1      	cmp	r1, r6
    b16c:	d800      	bhi.n	b170 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x9c>
    b16e:	460e      	mov	r6, r1
    b170:	807e      	strh	r6, [r7, #2]
    b172:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    b176:	42a9      	cmp	r1, r5
    b178:	d800      	bhi.n	b17c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xa8>
    b17a:	460d      	mov	r5, r1
    b17c:	80bd      	strh	r5, [r7, #4]
    b17e:	21ff      	movs	r1, #255	; 0xff
    b180:	7039      	strb	r1, [r7, #0]
    b182:	381b      	subs	r0, #27
    b184:	28e0      	cmp	r0, #224	; 0xe0
    b186:	d902      	bls.n	b18e <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xba>
    b188:	f640 41b8 	movw	r1, #3256	; 0xcb8
    b18c:	e014      	b.n	b1b8 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xe4>
    b18e:	3e1b      	subs	r6, #27
    b190:	2ee0      	cmp	r6, #224	; 0xe0
    b192:	d902      	bls.n	b19a <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xc6>
    b194:	f640 41ba 	movw	r1, #3258	; 0xcba
    b198:	e00e      	b.n	b1b8 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xe4>
    b19a:	f44f 60e0 	mov.w	r0, #1792	; 0x700
    b19e:	f5a4 74a4 	sub.w	r4, r4, #328	; 0x148
    b1a2:	4284      	cmp	r4, r0
    b1a4:	d902      	bls.n	b1ac <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xd8>
    b1a6:	f640 41bc 	movw	r1, #3260	; 0xcbc
    b1aa:	e005      	b.n	b1b8 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xe4>
    b1ac:	f5a5 75a4 	sub.w	r5, r5, #328	; 0x148
    b1b0:	4285      	cmp	r5, r0
    b1b2:	d904      	bls.n	b1be <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xea>
    b1b4:	f640 41be 	movw	r1, #3262	; 0xcbe
    b1b8:	2039      	movs	r0, #57	; 0x39
    b1ba:	f7f9 ffcb 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b1be:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
    b1c2:	0000      	.short	0x0000
    b1c4:	200002b0 	.word	0x200002b0
    b1c8:	b510      	push	{r4, lr}
    b1ca:	480e      	ldr	r0, [pc, #56]	; (b204 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x130>)
    b1cc:	f64f 71ff 	movw	r1, #65535	; 0xffff
    b1d0:	4b0d      	ldr	r3, [pc, #52]	; (b208 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x134>)
    b1d2:	8281      	strh	r1, [r0, #20]
    b1d4:	2100      	movs	r1, #0
    b1d6:	7581      	strb	r1, [r0, #22]
    b1d8:	8301      	strh	r1, [r0, #24]
    b1da:	221b      	movs	r2, #27
    b1dc:	801a      	strh	r2, [r3, #0]
    b1de:	f44f 74a4 	mov.w	r4, #328	; 0x148
    b1e2:	805c      	strh	r4, [r3, #2]
    b1e4:	809a      	strh	r2, [r3, #4]
    b1e6:	80dc      	strh	r4, [r3, #6]
    b1e8:	7381      	strb	r1, [r0, #14]
    b1ea:	73c1      	strb	r1, [r0, #15]
    b1ec:	2303      	movs	r3, #3
    b1ee:	7003      	strb	r3, [r0, #0]
    b1f0:	2302      	movs	r3, #2
    b1f2:	7043      	strb	r3, [r0, #1]
    b1f4:	8042      	strh	r2, [r0, #2]
    b1f6:	8082      	strh	r2, [r0, #4]
    b1f8:	f640 62a6 	movw	r2, #3750	; 0xea6
    b1fc:	6082      	str	r2, [r0, #8]
    b1fe:	7481      	strb	r1, [r0, #18]
    b200:	7301      	strb	r1, [r0, #12]
    b202:	bd10      	pop	{r4, pc}
    b204:	2000165c 	.word	0x2000165c
    b208:	200002b0 	.word	0x200002b0
    b20c:	b510      	push	{r4, lr}
    b20e:	2101      	movs	r1, #1
    b210:	2000      	movs	r0, #0
    b212:	f002 feea 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
    b216:	0004      	movs	r4, r0
    b218:	d10c      	bne.n	b234 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x160>
    b21a:	2200      	movs	r2, #0
    b21c:	2101      	movs	r1, #1
    b21e:	4610      	mov	r0, r2
    b220:	f002 fed9 	bl	dfd6 <sym_7JFC7IFAJQVPYCQHAIUKZ626ISM3VUWBEEXY7WI>
    b224:	0004      	movs	r4, r0
    b226:	d007      	beq.n	b238 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x164>
    b228:	4806      	ldr	r0, [pc, #24]	; (b244 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x170>)
    b22a:	f990 1000 	ldrsb.w	r1, [r0]
    b22e:	4620      	mov	r0, r4
    b230:	f003 ffbd 	bl	f1ae <sym_YA57TPZ3CLQ6C73TD2RIGTELUAMYOOAKHU5T7RQ>
    b234:	4620      	mov	r0, r4
    b236:	bd10      	pop	{r4, pc}
    b238:	f240 2135 	movw	r1, #565	; 0x235
    b23c:	2039      	movs	r0, #57	; 0x39
    b23e:	f7f9 ff89 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b242:	0000      	.short	0x0000
    b244:	200002a8 	.word	0x200002a8

0000b248 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ>:
    b248:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b24c:	b088      	sub	sp, #32
    b24e:	460c      	mov	r4, r1
    b250:	4606      	mov	r6, r0
    b252:	f004 f85b 	bl	f30c <sym_WGJLFS2PDN6RZG7JWUITZ3W5MGJYYXFXIKI3GGQ>
    b256:	b198      	cbz	r0, b280 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x38>
    b258:	4630      	mov	r0, r6
    b25a:	f004 f84a 	bl	f2f2 <sym_XRU76NANM3C4EMKWQU3DF6CELSRNDV6766IKPJI>
    b25e:	b130      	cbz	r0, b26e <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x26>
    b260:	f8b4 1001 	ldrh.w	r1, [r4, #1]
    b264:	2012      	movs	r0, #18
    b266:	2900      	cmp	r1, #0
    b268:	d00b      	beq.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b26a:	2980      	cmp	r1, #128	; 0x80
    b26c:	d809      	bhi.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b26e:	4630      	mov	r0, r6
    b270:	f004 f82e 	bl	f2d0 <sym_JWG2K5Z2IDS7IGZ34EUMCNHIOV34425FH263YQQ>
    b274:	b140      	cbz	r0, b288 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x40>
    b276:	4630      	mov	r0, r6
    b278:	f003 ff63 	bl	f142 <sym_NFQK2HO6DBYRYVUCFLRI766EKAAKCM57FJRRS5Y>
    b27c:	b130      	cbz	r0, b28c <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x44>
    b27e:	e009      	b.n	b294 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x4c>
    b280:	2042      	movs	r0, #66	; 0x42
    b282:	b008      	add	sp, #32
    b284:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b288:	200c      	movs	r0, #12
    b28a:	e7fa      	b.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b28c:	4630      	mov	r0, r6
    b28e:	f004 f82a 	bl	f2e6 <sym_TPWVJBQKX2TXZDZ4IZ6XDJYVEDFBPIX3TMZMRCQ>
    b292:	b3c0      	cbz	r0, b306 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0xbe>
    b294:	4630      	mov	r0, r6
    b296:	f004 f9ee 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
    b29a:	2800      	cmp	r0, #0
    b29c:	d1f4      	bne.n	b288 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x40>
    b29e:	4630      	mov	r0, r6
    b2a0:	f003 ff6a 	bl	f178 <sym_OAGVEJLAHKQB2YTTUDIS6TDHXZIVWZXKUMPIBHQ>
    b2a4:	2800      	cmp	r0, #0
    b2a6:	d1ef      	bne.n	b288 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x40>
    b2a8:	4630      	mov	r0, r6
    b2aa:	f7fc f9e9 	bl	7680 <sym_JIJASGQH4XEEPZL7D35VQHVPKKLANGDBS2M46NQ>
    b2ae:	f8b4 0001 	ldrh.w	r0, [r4, #1]
    b2b2:	f242 7110 	movw	r1, #10000	; 0x2710
    b2b6:	fb00 f801 	mul.w	r8, r0, r1
    b2ba:	78e1      	ldrb	r1, [r4, #3]
    b2bc:	4630      	mov	r0, r6
    b2be:	f003 fffe 	bl	f2be <sym_DG6VHZEFRVR44ESTRZM42ZEBJG4KXT7IVJESA4Y>
    b2c2:	4630      	mov	r0, r6
    b2c4:	f004 f811 	bl	f2ea <sym_UEZ3FVWFJ5XVLQBVVAHW7UTXVCC77F7ZYGOMLTQ>
    b2c8:	b300      	cbz	r0, b30c <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0xc4>
    b2ca:	2200      	movs	r2, #0
    b2cc:	4611      	mov	r1, r2
    b2ce:	a801      	add	r0, sp, #4
    b2d0:	f7fa f9aa 	bl	5628 <sym_DMJHGENWVWA7ILXIIOOHU6SYMMXUDCUFUUBACLQ>
    b2d4:	0004      	movs	r4, r0
    b2d6:	d06d      	beq.n	b3b4 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x16c>
    b2d8:	2100      	movs	r1, #0
    b2da:	f7fb fd6d 	bl	6db8 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI>
    b2de:	f8bd 0004 	ldrh.w	r0, [sp, #4]
    b2e2:	8020      	strh	r0, [r4, #0]
    b2e4:	4621      	mov	r1, r4
    b2e6:	4630      	mov	r0, r6
    b2e8:	f004 f823 	bl	f332 <sym_4FKJZF4AXR7RHM7IPPZMVUWU7W6MFHLX726TPNY>
    b2ec:	f000 f9a4 	bl	b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>
    b2f0:	0940      	lsrs	r0, r0, #5
    b2f2:	ea40 60c1 	orr.w	r0, r0, r1, lsl #27
    b2f6:	07c0      	lsls	r0, r0, #31
    b2f8:	4d3a      	ldr	r5, [pc, #232]	; (b3e4 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x19c>)
    b2fa:	f104 0030 	add.w	r0, r4, #48	; 0x30
    b2fe:	d00f      	beq.n	b320 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0xd8>
    b300:	8869      	ldrh	r1, [r5, #2]
    b302:	88aa      	ldrh	r2, [r5, #4]
    b304:	e00e      	b.n	b324 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0xdc>
    b306:	e7ff      	b.n	b308 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0xc0>
    b308:	2012      	movs	r0, #18
    b30a:	e7ba      	b.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b30c:	4642      	mov	r2, r8
    b30e:	2100      	movs	r1, #0
    b310:	4630      	mov	r0, r6
    b312:	f7fd f8b1 	bl	8478 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY>
    b316:	2800      	cmp	r0, #0
    b318:	d0b3      	beq.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b31a:	f241 417b 	movw	r1, #5243	; 0x147b
    b31e:	e053      	b.n	b3c8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x180>
    b320:	211b      	movs	r1, #27
    b322:	460a      	mov	r2, r1
    b324:	84c1      	strh	r1, [r0, #38]	; 0x26
    b326:	8502      	strh	r2, [r0, #40]	; 0x28
    b328:	68a8      	ldr	r0, [r5, #8]
    b32a:	6320      	str	r0, [r4, #48]	; 0x30
    b32c:	f641 574c 	movw	r7, #7500	; 0x1d4c
    b330:	4630      	mov	r0, r6
    b332:	f003 ffe2 	bl	f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>
    b336:	b910      	cbnz	r0, b33e <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0xf6>
    b338:	4630      	mov	r0, r6
    b33a:	f003 fff8 	bl	f32e <sym_4HDCBJCT2JOHNORERPDEH2A3V47FOX6NCTAKLUA>
    b33e:	6127      	str	r7, [r4, #16]
    b340:	8821      	ldrh	r1, [r4, #0]
    b342:	f8ad 1008 	strh.w	r1, [sp, #8]
    b346:	7ba9      	ldrb	r1, [r5, #14]
    b348:	f88d 100a 	strb.w	r1, [sp, #10]
    b34c:	7be9      	ldrb	r1, [r5, #15]
    b34e:	f88d 100b 	strb.w	r1, [sp, #11]
    b352:	8a29      	ldrh	r1, [r5, #16]
    b354:	f8ad 100c 	strh.w	r1, [sp, #12]
    b358:	a905      	add	r1, sp, #20
    b35a:	9100      	str	r1, [sp, #0]
    b35c:	2001      	movs	r0, #1
    b35e:	ab04      	add	r3, sp, #16
    b360:	aa02      	add	r2, sp, #8
    b362:	4621      	mov	r1, r4
    b364:	f005 fb99 	bl	10a9a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x278>
    b368:	b140      	cbz	r0, b37c <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x134>
    b36a:	2100      	movs	r1, #0
    b36c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
    b370:	f7fa f984 	bl	567c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY>
    b374:	b1f0      	cbz	r0, b3b4 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x16c>
    b376:	f241 41cb 	movw	r1, #5323	; 0x14cb
    b37a:	e025      	b.n	b3c8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x180>
    b37c:	f89d 0010 	ldrb.w	r0, [sp, #16]
    b380:	f88d 0018 	strb.w	r0, [sp, #24]
    b384:	f89d 0014 	ldrb.w	r0, [sp, #20]
    b388:	f88d 0019 	strb.w	r0, [sp, #25]
    b38c:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    b390:	f8ad 001a 	strh.w	r0, [sp, #26]
    b394:	a906      	add	r1, sp, #24
    b396:	4620      	mov	r0, r4
    b398:	f003 f975 	bl	e686 <sym_6NROXJNXJONASXBRH4ZGPEEQ42PSH3YLRTC74GQ>
    b39c:	7868      	ldrb	r0, [r5, #1]
    b39e:	9000      	str	r0, [sp, #0]
    b3a0:	782b      	ldrb	r3, [r5, #0]
    b3a2:	88aa      	ldrh	r2, [r5, #4]
    b3a4:	8869      	ldrh	r1, [r5, #2]
    b3a6:	8820      	ldrh	r0, [r4, #0]
    b3a8:	f7fa fa34 	bl	5814 <sym_24NU2MJKHN4R2Z7HXHMPDWTTDYSB32VL6HEQPZA>
    b3ac:	b120      	cbz	r0, b3b8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x170>
    b3ae:	f241 41d6 	movw	r1, #5334	; 0x14d6
    b3b2:	e009      	b.n	b3c8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x180>
    b3b4:	2009      	movs	r0, #9
    b3b6:	e764      	b.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b3b8:	4642      	mov	r2, r8
    b3ba:	4621      	mov	r1, r4
    b3bc:	4630      	mov	r0, r6
    b3be:	f7fd f85b 	bl	8478 <sym_U3OFHSWAAHECAZEDHWSQTU63SOSYAQR6QI45AFY>
    b3c2:	b120      	cbz	r0, b3ce <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x186>
    b3c4:	f241 41d8 	movw	r1, #5336	; 0x14d8
    b3c8:	2039      	movs	r0, #57	; 0x39
    b3ca:	f7f9 fec3 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b3ce:	4806      	ldr	r0, [pc, #24]	; (b3e8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1a0>)
    b3d0:	6843      	ldr	r3, [r0, #4]
    b3d2:	b123      	cbz	r3, b3de <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x196>
    b3d4:	2200      	movs	r2, #0
    b3d6:	f504 718d 	add.w	r1, r4, #282	; 0x11a
    b3da:	4620      	mov	r0, r4
    b3dc:	4798      	blx	r3
    b3de:	2000      	movs	r0, #0
    b3e0:	e74f      	b.n	b282 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x3a>
    b3e2:	0000      	.short	0x0000
    b3e4:	2000165c 	.word	0x2000165c
    b3e8:	200002a8 	.word	0x200002a8
    b3ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b3f0:	b088      	sub	sp, #32
    b3f2:	4604      	mov	r4, r0
    b3f4:	8800      	ldrh	r0, [r0, #0]
    b3f6:	a906      	add	r1, sp, #24
    b3f8:	f003 f885 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    b3fc:	2800      	cmp	r0, #0
    b3fe:	d147      	bne.n	b490 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x248>
    b400:	9807      	ldr	r0, [sp, #28]
    b402:	f890 1162 	ldrb.w	r1, [r0, #354]	; 0x162
    b406:	f88d 1008 	strb.w	r1, [sp, #8]
    b40a:	9902      	ldr	r1, [sp, #8]
    b40c:	9102      	str	r1, [sp, #8]
    b40e:	f89d 1008 	ldrb.w	r1, [sp, #8]
    b412:	3078      	adds	r0, #120	; 0x78
    b414:	b101      	cbz	r1, b418 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1d0>
    b416:	2101      	movs	r1, #1
    b418:	f88d 100c 	strb.w	r1, [sp, #12]
    b41c:	7bc1      	ldrb	r1, [r0, #15]
    b41e:	f04f 0800 	mov.w	r8, #0
    b422:	0689      	lsls	r1, r1, #26
    b424:	d502      	bpl.n	b42c <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1e4>
    b426:	f89d 100c 	ldrb.w	r1, [sp, #12]
    b42a:	b149      	cbz	r1, b440 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1f8>
    b42c:	f05f 0100 	movs.w	r1, #0
    b430:	f88d 1004 	strb.w	r1, [sp, #4]
    b434:	2105      	movs	r1, #5
    b436:	305c      	adds	r0, #92	; 0x5c
    b438:	f004 fd6e 	bl	ff18 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x88>
    b43c:	b110      	cbz	r0, b444 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1fc>
    b43e:	e004      	b.n	b44a <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x202>
    b440:	2101      	movs	r1, #1
    b442:	e7f5      	b.n	b430 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1e8>
    b444:	f89d 0004 	ldrb.w	r0, [sp, #4]
    b448:	b308      	cbz	r0, b48e <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x246>
    b44a:	8921      	ldrh	r1, [r4, #8]
    b44c:	88e0      	ldrh	r0, [r4, #6]
    b44e:	f005 fae0 	bl	10a12 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1f0>
    b452:	2800      	cmp	r0, #0
    b454:	d11c      	bne.n	b490 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x248>
    b456:	88a1      	ldrh	r1, [r4, #4]
    b458:	8860      	ldrh	r0, [r4, #2]
    b45a:	f005 fada 	bl	10a12 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1f0>
    b45e:	2800      	cmp	r0, #0
    b460:	d116      	bne.n	b490 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x248>
    b462:	8921      	ldrh	r1, [r4, #8]
    b464:	88e0      	ldrh	r0, [r4, #6]
    b466:	f005 faca 	bl	109fe <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1dc>
    b46a:	2800      	cmp	r0, #0
    b46c:	d110      	bne.n	b490 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x248>
    b46e:	88a1      	ldrh	r1, [r4, #4]
    b470:	8860      	ldrh	r0, [r4, #2]
    b472:	f005 fac4 	bl	109fe <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1dc>
    b476:	0006      	movs	r6, r0
    b478:	d10a      	bne.n	b490 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x248>
    b47a:	9807      	ldr	r0, [sp, #28]
    b47c:	f500 758d 	add.w	r5, r0, #282	; 0x11a
    b480:	27ff      	movs	r7, #255	; 0xff
    b482:	706f      	strb	r7, [r5, #1]
    b484:	f89d 100c 	ldrb.w	r1, [sp, #12]
    b488:	b129      	cbz	r1, b496 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x24e>
    b48a:	263a      	movs	r6, #58	; 0x3a
    b48c:	e02e      	b.n	b4ec <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x2a4>
    b48e:	201a      	movs	r0, #26
    b490:	b008      	add	sp, #32
    b492:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b496:	4641      	mov	r1, r8
    b498:	aa03      	add	r2, sp, #12
    b49a:	f005 fac8 	bl	10a2e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x20c>
    b49e:	8861      	ldrh	r1, [r4, #2]
    b4a0:	f8bd 0012 	ldrh.w	r0, [sp, #18]
    b4a4:	4281      	cmp	r1, r0
    b4a6:	d200      	bcs.n	b4aa <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x262>
    b4a8:	4608      	mov	r0, r1
    b4aa:	80e8      	strh	r0, [r5, #6]
    b4ac:	88a1      	ldrh	r1, [r4, #4]
    b4ae:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    b4b2:	4281      	cmp	r1, r0
    b4b4:	d200      	bcs.n	b4b8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x270>
    b4b6:	4608      	mov	r0, r1
    b4b8:	8128      	strh	r0, [r5, #8]
    b4ba:	88e2      	ldrh	r2, [r4, #6]
    b4bc:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    b4c0:	428a      	cmp	r2, r1
    b4c2:	d200      	bcs.n	b4c6 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x27e>
    b4c4:	4611      	mov	r1, r2
    b4c6:	8069      	strh	r1, [r5, #2]
    b4c8:	8922      	ldrh	r2, [r4, #8]
    b4ca:	f8bd 1010 	ldrh.w	r1, [sp, #16]
    b4ce:	428a      	cmp	r2, r1
    b4d0:	d200      	bcs.n	b4d4 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x28c>
    b4d2:	4611      	mov	r1, r2
    b4d4:	f640 0248 	movw	r2, #2120	; 0x848
    b4d8:	80a9      	strh	r1, [r5, #4]
    b4da:	4291      	cmp	r1, r2
    b4dc:	d300      	bcc.n	b4e0 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x298>
    b4de:	4611      	mov	r1, r2
    b4e0:	80a9      	strh	r1, [r5, #4]
    b4e2:	4290      	cmp	r0, r2
    b4e4:	d200      	bcs.n	b4e8 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x2a0>
    b4e6:	4602      	mov	r2, r0
    b4e8:	812a      	strh	r2, [r5, #8]
    b4ea:	702f      	strb	r7, [r5, #0]
    b4ec:	f885 8001 	strb.w	r8, [r5, #1]
    b4f0:	4630      	mov	r0, r6
    b4f2:	e7cd      	b.n	b490 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x248>
    b4f4:	b510      	push	{r4, lr}
    b4f6:	4604      	mov	r4, r0
    b4f8:	88c1      	ldrh	r1, [r0, #6]
    b4fa:	8880      	ldrh	r0, [r0, #4]
    b4fc:	f005 fa89 	bl	10a12 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1f0>
    b500:	2800      	cmp	r0, #0
    b502:	d10f      	bne.n	b524 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x2dc>
    b504:	8861      	ldrh	r1, [r4, #2]
    b506:	8820      	ldrh	r0, [r4, #0]
    b508:	f005 fa83 	bl	10a12 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1f0>
    b50c:	2800      	cmp	r0, #0
    b50e:	d109      	bne.n	b524 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x2dc>
    b510:	4805      	ldr	r0, [pc, #20]	; (b528 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x2e0>)
    b512:	88a1      	ldrh	r1, [r4, #4]
    b514:	8081      	strh	r1, [r0, #4]
    b516:	8821      	ldrh	r1, [r4, #0]
    b518:	8001      	strh	r1, [r0, #0]
    b51a:	88e1      	ldrh	r1, [r4, #6]
    b51c:	80c1      	strh	r1, [r0, #6]
    b51e:	8861      	ldrh	r1, [r4, #2]
    b520:	8041      	strh	r1, [r0, #2]
    b522:	2000      	movs	r0, #0
    b524:	bd10      	pop	{r4, pc}
    b526:	0000      	.short	0x0000
    b528:	200002b0 	.word	0x200002b0
    b52c:	0c11a70c 	.word	0x0c11a70c
    b530:	11a70059 	.word	0x11a70059

0000b534 <sym_G4TIIR7KO3GHFF45HCHTIL3RIPRK2LVDQADUYJQ>:
    b534:	b510      	push	{r4, lr}
    b536:	f7fb ff01 	bl	733c <sym_VKBDHCW5KWYFAEZJJBKQNHH4JDURIHHEJCK4SOA>
    b53a:	4805      	ldr	r0, [pc, #20]	; (b550 <sym_G4TIIR7KO3GHFF45HCHTIL3RIPRK2LVDQADUYJQ+0x1c>)
    b53c:	6840      	ldr	r0, [r0, #4]
    b53e:	f005 fb8a 	bl	10c56 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x434>
    b542:	f005 f8fc 	bl	1073e <sym_5EMU3BEOS6JCQEXTZ5M5LP72YGJNCV3W3R43AOI>
    b546:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b54a:	f7fc b867 	b.w	761c <sym_77ICNIHY2R2L3JRP4ZLMOWZSS3UZRKJXJOBWTWI>
    b54e:	0000      	.short	0x0000
    b550:	200002b8 	.word	0x200002b8

0000b554 <sym_4W26TPGCKOCVVRKXQDBKGXGC2Y5LMZXNKS2QITA>:
    b554:	b510      	push	{r4, lr}
    b556:	4c05      	ldr	r4, [pc, #20]	; (b56c <sym_4W26TPGCKOCVVRKXQDBKGXGC2Y5LMZXNKS2QITA+0x18>)
    b558:	68a0      	ldr	r0, [r4, #8]
    b55a:	f005 fb7c 	bl	10c56 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x434>
    b55e:	68e0      	ldr	r0, [r4, #12]
    b560:	f005 fb79 	bl	10c56 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x434>
    b564:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b568:	f005 b94e 	b.w	10808 <sym_RGKYP5TXYS27EGT6ZHZS5EDDAZK5QGTWLBOBJEA>
    b56c:	200002b8 	.word	0x200002b8

0000b570 <sym_EANB2LFFCPDZUHTPF7SNNYVWVGG3AE7JVOONSTY>:
    b570:	b510      	push	{r4, lr}
    b572:	4905      	ldr	r1, [pc, #20]	; (b588 <sym_EANB2LFFCPDZUHTPF7SNNYVWVGG3AE7JVOONSTY+0x18>)
    b574:	4805      	ldr	r0, [pc, #20]	; (b58c <sym_EANB2LFFCPDZUHTPF7SNNYVWVGG3AE7JVOONSTY+0x1c>)
    b576:	f005 fb61 	bl	10c3c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x41a>
    b57a:	4804      	ldr	r0, [pc, #16]	; (b58c <sym_EANB2LFFCPDZUHTPF7SNNYVWVGG3AE7JVOONSTY+0x1c>)
    b57c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b580:	4903      	ldr	r1, [pc, #12]	; (b590 <sym_EANB2LFFCPDZUHTPF7SNNYVWVGG3AE7JVOONSTY+0x20>)
    b582:	1d00      	adds	r0, r0, #4
    b584:	f005 bb5a 	b.w	10c3c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x41a>
    b588:	200002c8 	.word	0x200002c8
    b58c:	200002bc 	.word	0x200002bc
    b590:	200002d0 	.word	0x200002d0

0000b594 <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA>:
    b594:	b510      	push	{r4, lr}
    b596:	4908      	ldr	r1, [pc, #32]	; (b5b8 <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA+0x24>)
    b598:	4808      	ldr	r0, [pc, #32]	; (b5bc <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA+0x28>)
    b59a:	f005 fb4f 	bl	10c3c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x41a>
    b59e:	4807      	ldr	r0, [pc, #28]	; (b5bc <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA+0x28>)
    b5a0:	4907      	ldr	r1, [pc, #28]	; (b5c0 <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA+0x2c>)
    b5a2:	1d00      	adds	r0, r0, #4
    b5a4:	f005 fb4a 	bl	10c3c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x41a>
    b5a8:	4804      	ldr	r0, [pc, #16]	; (b5bc <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA+0x28>)
    b5aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b5ae:	4905      	ldr	r1, [pc, #20]	; (b5c4 <sym_BFBDHRTPYGNRMJSAT7WCAPOXBGIVSWF4E5GFHOA+0x30>)
    b5b0:	3008      	adds	r0, #8
    b5b2:	f005 bb43 	b.w	10c3c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x41a>
    b5b6:	0000      	.short	0x0000
    b5b8:	200002e0 	.word	0x200002e0
    b5bc:	200002bc 	.word	0x200002bc
    b5c0:	200002e8 	.word	0x200002e8
    b5c4:	200002d8 	.word	0x200002d8

0000b5c8 <sym_PRWTRTI5GPQHIT26MFBSSOCWTUYYRLQLJWD2ZOI>:
    b5c8:	4801      	ldr	r0, [pc, #4]	; (b5d0 <sym_PRWTRTI5GPQHIT26MFBSSOCWTUYYRLQLJWD2ZOI+0x8>)
    b5ca:	7800      	ldrb	r0, [r0, #0]
    b5cc:	4770      	bx	lr
    b5ce:	0000      	.short	0x0000
    b5d0:	200002b8 	.word	0x200002b8
    b5d4:	b510      	push	{r4, lr}
    b5d6:	f7fc f975 	bl	78c4 <sym_BPVIPCP3IMFHHNRASYWRUQPTOXIXQGWP3DTKXWI>
    b5da:	f7fc fff5 	bl	85c8 <sym_4O3EP57XWWWRY57PVJMDKXNE25ZWFBDV6LLBFQQ>
    b5de:	4803      	ldr	r0, [pc, #12]	; (b5ec <sym_PRWTRTI5GPQHIT26MFBSSOCWTUYYRLQLJWD2ZOI+0x24>)
    b5e0:	f7fc f956 	bl	7890 <sym_KC3JIKE7HTERE3Q3BXMRUIDPAENUZKVBIDO6ODY>
    b5e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b5e8:	f7fb beb4 	b.w	7354 <sym_2ZDP75C7NTGGQLOC7B3VQWZBDYTVYDPXMMVG73Q>
    b5ec:	20001aef 	.word	0x20001aef
    b5f0:	4909      	ldr	r1, [pc, #36]	; (b618 <sym_PRWTRTI5GPQHIT26MFBSSOCWTUYYRLQLJWD2ZOI+0x50>)
    b5f2:	b510      	push	{r4, lr}
    b5f4:	2001      	movs	r0, #1
    b5f6:	7008      	strb	r0, [r1, #0]
    b5f8:	f7fc f994 	bl	7924 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY>
    b5fc:	f7fd fbc0 	bl	8d80 <sym_FIYSAC63N2FF462LEI76F5US34JKFTAQDSI2LXA>
    b600:	f002 feb3 	bl	e36a <sym_QXKT3PVMDTZRAAU2QNTWO5VOUEZ4NW6TWISREXY>
    b604:	4805      	ldr	r0, [pc, #20]	; (b61c <sym_PRWTRTI5GPQHIT26MFBSSOCWTUYYRLQLJWD2ZOI+0x54>)
    b606:	f7fa fcb5 	bl	5f74 <sym_ULQ236TSMK6UJATLJCXSX5JBKSVB4ZM2NNU74PA>
    b60a:	2000      	movs	r0, #0
    b60c:	f7f9 ff7c 	bl	5508 <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A>
    b610:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b614:	f7fb bea6 	b.w	7364 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q>
    b618:	200002b8 	.word	0x200002b8
    b61c:	20001aef 	.word	0x20001aef

0000b620 <sym_N6TOG3AODPPFNS6LXFKKIADNGIMUMBS5BXPEFOY>:
    b620:	4a04      	ldr	r2, [pc, #16]	; (b634 <sym_N6TOG3AODPPFNS6LXFKKIADNGIMUMBS5BXPEFOY+0x14>)
    b622:	08c1      	lsrs	r1, r0, #3
    b624:	f000 0307 	and.w	r3, r0, #7
    b628:	2001      	movs	r0, #1
    b62a:	4098      	lsls	r0, r3
    b62c:	5c53      	ldrb	r3, [r2, r1]
    b62e:	4303      	orrs	r3, r0
    b630:	5453      	strb	r3, [r2, r1]
    b632:	4770      	bx	lr
    b634:	20000020 	.word	0x20000020

0000b638 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ>:
    b638:	4901      	ldr	r1, [pc, #4]	; (b640 <sym_PBZPB3PSJJYSQQW7TH2XDGNLD2UYSZR6YJ4ZZNQ+0x8>)
    b63a:	e9d1 0100 	ldrd	r0, r1, [r1]
    b63e:	4770      	bx	lr
    b640:	20000020 	.word	0x20000020

0000b644 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ>:
    b644:	4806      	ldr	r0, [pc, #24]	; (b660 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ+0x1c>)
    b646:	8801      	ldrh	r1, [r0, #0]
    b648:	7900      	ldrb	r0, [r0, #4]
    b64a:	0602      	lsls	r2, r0, #24
    b64c:	ea42 2011 	orr.w	r0, r2, r1, lsr #8
    b650:	f000 0001 	and.w	r0, r0, #1
    b654:	1800      	adds	r0, r0, r0
    b656:	b2c0      	uxtb	r0, r0
    b658:	f040 0001 	orr.w	r0, r0, #1
    b65c:	4770      	bx	lr
    b65e:	0000      	.short	0x0000
    b660:	20000020 	.word	0x20000020

0000b664 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA>:
    b664:	b510      	push	{r4, lr}
    b666:	f7f9 f9ad 	bl	49c4 <sym_ETIE3PCEXQYLK2GIVZENQ6V7PLBRV57MB7BDMNY>
    b66a:	2200      	movs	r2, #0
    b66c:	4b08      	ldr	r3, [pc, #32]	; (b690 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA+0x2c>)
    b66e:	4611      	mov	r1, r2
    b670:	f833 4021 	ldrh.w	r4, [r3, r1, lsl #2]
    b674:	4284      	cmp	r4, r0
    b676:	d303      	bcc.n	b680 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA+0x1c>
    b678:	eb03 0081 	add.w	r0, r3, r1, lsl #2
    b67c:	7882      	ldrb	r2, [r0, #2]
    b67e:	e003      	b.n	b688 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA+0x24>
    b680:	1c49      	adds	r1, r1, #1
    b682:	b2c9      	uxtb	r1, r1
    b684:	290c      	cmp	r1, #12
    b686:	d3f3      	bcc.n	b670 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA+0xc>
    b688:	4802      	ldr	r0, [pc, #8]	; (b694 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA+0x30>)
    b68a:	7002      	strb	r2, [r0, #0]
    b68c:	bd10      	pop	{r4, pc}
    b68e:	0000      	.short	0x0000
    b690:	00010ca8 	.word	0x00010ca8
    b694:	20000338 	.word	0x20000338

0000b698 <sym_MDF364N4PQDEA5ZGP5CB3ZDZVZM5Q32KSEZZ5HI>:
    b698:	b570      	push	{r4, r5, r6, lr}
    b69a:	4605      	mov	r5, r0
    b69c:	4616      	mov	r6, r2
    b69e:	460c      	mov	r4, r1
    b6a0:	2002      	movs	r0, #2
    b6a2:	f000 f9b7 	bl	ba14 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI>
    b6a6:	4906      	ldr	r1, [pc, #24]	; (b6c0 <sym_MDF364N4PQDEA5ZGP5CB3ZDZVZM5Q32KSEZZ5HI+0x28>)
    b6a8:	2001      	movs	r0, #1
    b6aa:	1ef6      	subs	r6, r6, #3
    b6ac:	7008      	strb	r0, [r1, #0]
    b6ae:	4805      	ldr	r0, [pc, #20]	; (b6c4 <sym_MDF364N4PQDEA5ZGP5CB3ZDZVZM5Q32KSEZZ5HI+0x2c>)
    b6b0:	6006      	str	r6, [r0, #0]
    b6b2:	4804      	ldr	r0, [pc, #16]	; (b6c4 <sym_MDF364N4PQDEA5ZGP5CB3ZDZVZM5Q32KSEZZ5HI+0x2c>)
    b6b4:	3808      	subs	r0, #8
    b6b6:	6005      	str	r5, [r0, #0]
    b6b8:	1f00      	subs	r0, r0, #4
    b6ba:	6004      	str	r4, [r0, #0]
    b6bc:	bd70      	pop	{r4, r5, r6, pc}
    b6be:	0000      	.short	0x0000
    b6c0:	20000339 	.word	0x20000339
    b6c4:	4000f510 	.word	0x4000f510

0000b6c8 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI>:
    b6c8:	b510      	push	{r4, lr}
    b6ca:	4c0c      	ldr	r4, [pc, #48]	; (b6fc <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI+0x34>)
    b6cc:	7820      	ldrb	r0, [r4, #0]
    b6ce:	b180      	cbz	r0, b6f2 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI+0x2a>
    b6d0:	490b      	ldr	r1, [pc, #44]	; (b700 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI+0x38>)
    b6d2:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    b6d6:	6008      	str	r0, [r1, #0]
    b6d8:	f000 f86a 	bl	b7b0 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x48>
    b6dc:	2100      	movs	r1, #0
    b6de:	b120      	cbz	r0, b6ea <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI+0x22>
    b6e0:	2001      	movs	r0, #1
    b6e2:	7060      	strb	r0, [r4, #1]
    b6e4:	4807      	ldr	r0, [pc, #28]	; (b704 <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI+0x3c>)
    b6e6:	6800      	ldr	r0, [r0, #0]
    b6e8:	e001      	b.n	b6ee <sym_5DEPI2OGSPXE5OVFBPVFPSPYPRYUQ54QVVXIKNI+0x26>
    b6ea:	7061      	strb	r1, [r4, #1]
    b6ec:	2010      	movs	r0, #16
    b6ee:	70a0      	strb	r0, [r4, #2]
    b6f0:	7021      	strb	r1, [r4, #0]
    b6f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b6f6:	2000      	movs	r0, #0
    b6f8:	f000 b98c 	b.w	ba14 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI>
    b6fc:	20000339 	.word	0x20000339
    b700:	4001f508 	.word	0x4001f508
    b704:	4000f400 	.word	0x4000f400

0000b708 <sym_XCEN5K7VEI2CAO42XW7S3FKM3HKMOCDCUFDX25Y>:
    b708:	b510      	push	{r4, lr}
    b70a:	2002      	movs	r0, #2
    b70c:	f000 f982 	bl	ba14 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI>
    b710:	4904      	ldr	r1, [pc, #16]	; (b724 <sym_XCEN5K7VEI2CAO42XW7S3FKM3HKMOCDCUFDX25Y+0x1c>)
    b712:	2001      	movs	r0, #1
    b714:	7008      	strb	r0, [r1, #0]
    b716:	f000 f859 	bl	b7cc <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x64>
    b71a:	4903      	ldr	r1, [pc, #12]	; (b728 <sym_XCEN5K7VEI2CAO42XW7S3FKM3HKMOCDCUFDX25Y+0x20>)
    b71c:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    b720:	6008      	str	r0, [r1, #0]
    b722:	bd10      	pop	{r4, pc}
    b724:	20000339 	.word	0x20000339
    b728:	4001f504 	.word	0x4001f504

0000b72c <sym_LOTFHGQTFUFWGX7HOTL4Q2XATGIJRVIMCMOYRMA>:
    b72c:	4803      	ldr	r0, [pc, #12]	; (b73c <sym_LOTFHGQTFUFWGX7HOTL4Q2XATGIJRVIMCMOYRMA+0x10>)
    b72e:	2100      	movs	r1, #0
    b730:	7001      	strb	r1, [r0, #0]
    b732:	7041      	strb	r1, [r0, #1]
    b734:	2110      	movs	r1, #16
    b736:	7081      	strb	r1, [r0, #2]
    b738:	4770      	bx	lr
    b73a:	0000      	.short	0x0000
    b73c:	20000339 	.word	0x20000339

0000b740 <sym_ZQHB3ANU2DANFLJZLZL5U4SPQ2ZDVUAHI35744Y>:
    b740:	4807      	ldr	r0, [pc, #28]	; (b760 <sym_ZQHB3ANU2DANFLJZLZL5U4SPQ2ZDVUAHI35744Y+0x20>)
    b742:	b510      	push	{r4, lr}
    b744:	7801      	ldrb	r1, [r0, #0]
    b746:	b141      	cbz	r1, b75a <sym_ZQHB3ANU2DANFLJZLZL5U4SPQ2ZDVUAHI35744Y+0x1a>
    b748:	f000 f832 	bl	b7b0 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x48>
    b74c:	b118      	cbz	r0, b756 <sym_ZQHB3ANU2DANFLJZLZL5U4SPQ2ZDVUAHI35744Y+0x16>
    b74e:	4805      	ldr	r0, [pc, #20]	; (b764 <sym_ZQHB3ANU2DANFLJZLZL5U4SPQ2ZDVUAHI35744Y+0x24>)
    b750:	6800      	ldr	r0, [r0, #0]
    b752:	b2c0      	uxtb	r0, r0
    b754:	bd10      	pop	{r4, pc}
    b756:	2010      	movs	r0, #16
    b758:	bd10      	pop	{r4, pc}
    b75a:	7880      	ldrb	r0, [r0, #2]
    b75c:	bd10      	pop	{r4, pc}
    b75e:	0000      	.short	0x0000
    b760:	20000339 	.word	0x20000339
    b764:	4000f400 	.word	0x4000f400

0000b768 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ>:
    b768:	4808      	ldr	r0, [pc, #32]	; (b78c <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x24>)
    b76a:	b510      	push	{r4, lr}
    b76c:	7801      	ldrb	r1, [r0, #0]
    b76e:	b159      	cbz	r1, b788 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x20>
    b770:	4807      	ldr	r0, [pc, #28]	; (b790 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x28>)
    b772:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
    b776:	b128      	cbz	r0, b784 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x1c>
    b778:	f000 f80c 	bl	b794 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x2c>
    b77c:	2800      	cmp	r0, #0
    b77e:	d000      	beq.n	b782 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x1a>
    b780:	2001      	movs	r0, #1
    b782:	bd10      	pop	{r4, pc}
    b784:	2002      	movs	r0, #2
    b786:	bd10      	pop	{r4, pc}
    b788:	7840      	ldrb	r0, [r0, #1]
    b78a:	bd10      	pop	{r4, pc}
    b78c:	20000339 	.word	0x20000339
    b790:	4000f000 	.word	0x4000f000
    b794:	4805      	ldr	r0, [pc, #20]	; (b7ac <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x44>)
    b796:	f8d0 1104 	ldr.w	r1, [r0, #260]	; 0x104
    b79a:	b111      	cbz	r1, b7a2 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x3a>
    b79c:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
    b7a0:	b108      	cbz	r0, b7a6 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x3e>
    b7a2:	2000      	movs	r0, #0
    b7a4:	4770      	bx	lr
    b7a6:	2001      	movs	r0, #1
    b7a8:	4770      	bx	lr
    b7aa:	0000      	.short	0x0000
    b7ac:	4000f000 	.word	0x4000f000
    b7b0:	4805      	ldr	r0, [pc, #20]	; (b7c8 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x60>)
    b7b2:	b510      	push	{r4, lr}
    b7b4:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
    b7b8:	b120      	cbz	r0, b7c4 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x5c>
    b7ba:	f7ff ffeb 	bl	b794 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x2c>
    b7be:	b108      	cbz	r0, b7c4 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x5c>
    b7c0:	2001      	movs	r0, #1
    b7c2:	bd10      	pop	{r4, pc}
    b7c4:	2000      	movs	r0, #0
    b7c6:	bd10      	pop	{r4, pc}
    b7c8:	4000f000 	.word	0x4000f000
    b7cc:	4804      	ldr	r0, [pc, #16]	; (b7e0 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ+0x78>)
    b7ce:	2100      	movs	r1, #0
    b7d0:	f8c0 1100 	str.w	r1, [r0, #256]	; 0x100
    b7d4:	f8c0 1104 	str.w	r1, [r0, #260]	; 0x104
    b7d8:	f8c0 1108 	str.w	r1, [r0, #264]	; 0x108
    b7dc:	4770      	bx	lr
    b7de:	0000      	.short	0x0000
    b7e0:	4000f000 	.word	0x4000f000

0000b7e4 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA>:
    b7e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b7e8:	4604      	mov	r4, r0
    b7ea:	461e      	mov	r6, r3
    b7ec:	4690      	mov	r8, r2
    b7ee:	460f      	mov	r7, r1
    b7f0:	2001      	movs	r0, #1
    b7f2:	f000 f90f 	bl	ba14 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI>
    b7f6:	4d1e      	ldr	r5, [pc, #120]	; (b870 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x8c>)
    b7f8:	481e      	ldr	r0, [pc, #120]	; (b874 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x90>)
    b7fa:	f004 0103 	and.w	r1, r4, #3
    b7fe:	712e      	strb	r6, [r5, #4]
    b800:	6800      	ldr	r0, [r0, #0]
    b802:	0432      	lsls	r2, r6, #16
    b804:	f361 0007 	bfi	r0, r1, #0, #8
    b808:	f366 200f 	bfi	r0, r6, #8, #8
    b80c:	0c00      	lsrs	r0, r0, #16
    b80e:	4e1a      	ldr	r6, [pc, #104]	; (b878 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x94>)
    b810:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
    b814:	4308      	orrs	r0, r1
    b816:	f8c6 0504 	str.w	r0, [r6, #1284]	; 0x504
    b81a:	4818      	ldr	r0, [pc, #96]	; (b87c <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x98>)
    b81c:	6007      	str	r7, [r0, #0]
    b81e:	f001 fb9d 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    b822:	b938      	cbnz	r0, b834 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x50>
    b824:	4815      	ldr	r0, [pc, #84]	; (b87c <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x98>)
    b826:	3010      	adds	r0, #16
    b828:	6801      	ldr	r1, [r0, #0]
    b82a:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    b82e:	ea41 0108 	orr.w	r1, r1, r8
    b832:	6001      	str	r1, [r0, #0]
    b834:	f000 f8e4 	bl	ba00 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x80>
    b838:	b10c      	cbz	r4, b83e <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x5a>
    b83a:	2c04      	cmp	r4, #4
    b83c:	d107      	bne.n	b84e <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x6a>
    b83e:	4811      	ldr	r0, [pc, #68]	; (b884 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0xa0>)
    b840:	490d      	ldr	r1, [pc, #52]	; (b878 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x94>)
    b842:	4a0f      	ldr	r2, [pc, #60]	; (b880 <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x9c>)
    b844:	1d09      	adds	r1, r1, #4
    b846:	f8c0 2510 	str.w	r2, [r0, #1296]	; 0x510
    b84a:	f8c0 1514 	str.w	r1, [r0, #1300]	; 0x514
    b84e:	2001      	movs	r0, #1
    b850:	7068      	strb	r0, [r5, #1]
    b852:	70ec      	strb	r4, [r5, #3]
    b854:	b11c      	cbz	r4, b85e <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x7a>
    b856:	2c01      	cmp	r4, #1
    b858:	d001      	beq.n	b85e <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x7a>
    b85a:	2c02      	cmp	r4, #2
    b85c:	d106      	bne.n	b86c <sym_5I5MTMPTF2F4WI7MIXG5OG4TUPLUR53CB2QHVUA+0x88>
    b85e:	7028      	strb	r0, [r5, #0]
    b860:	2100      	movs	r1, #0
    b862:	f8c6 1100 	str.w	r1, [r6, #256]	; 0x100
    b866:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
    b86a:	6030      	str	r0, [r6, #0]
    b86c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b870:	2000033c 	.word	0x2000033c
    b874:	0000ba10 	.word	0x0000ba10
    b878:	4000f000 	.word	0x4000f000
    b87c:	4000f508 	.word	0x4000f508
    b880:	4000f100 	.word	0x4000f100
    b884:	4001f088 	.word	0x4001f088

0000b888 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA>:
    b888:	b570      	push	{r4, r5, r6, lr}
    b88a:	4a1c      	ldr	r2, [pc, #112]	; (b8fc <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x74>)
    b88c:	7853      	ldrb	r3, [r2, #1]
    b88e:	b1a3      	cbz	r3, b8ba <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x32>
    b890:	4b1b      	ldr	r3, [pc, #108]	; (b900 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x78>)
    b892:	6019      	str	r1, [r3, #0]
    b894:	1d19      	adds	r1, r3, #4
    b896:	6008      	str	r0, [r1, #0]
    b898:	2501      	movs	r5, #1
    b89a:	7095      	strb	r5, [r2, #2]
    b89c:	4610      	mov	r0, r2
    b89e:	78d6      	ldrb	r6, [r2, #3]
    b8a0:	4b18      	ldr	r3, [pc, #96]	; (b904 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x7c>)
    b8a2:	7800      	ldrb	r0, [r0, #0]
    b8a4:	4c18      	ldr	r4, [pc, #96]	; (b908 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x80>)
    b8a6:	2100      	movs	r1, #0
    b8a8:	b156      	cbz	r6, b8c0 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x38>
    b8aa:	2e04      	cmp	r6, #4
    b8ac:	d01b      	beq.n	b8e6 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x5e>
    b8ae:	b308      	cbz	r0, b8f4 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x6c>
    b8b0:	f8c4 1104 	str.w	r1, [r4, #260]	; 0x104
    b8b4:	0668      	lsls	r0, r5, #25
    b8b6:	6018      	str	r0, [r3, #0]
    b8b8:	bd70      	pop	{r4, r5, r6, pc}
    b8ba:	f44f 71c2 	mov.w	r1, #388	; 0x184
    b8be:	e01a      	b.n	b8f6 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x6e>
    b8c0:	b178      	cbz	r0, b8e2 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x5a>
    b8c2:	4620      	mov	r0, r4
    b8c4:	f8c4 1104 	str.w	r1, [r4, #260]	; 0x104
    b8c8:	f44f 3600 	mov.w	r6, #131072	; 0x20000
    b8cc:	601e      	str	r6, [r3, #0]
    b8ce:	1271      	asrs	r1, r6, #9
    b8d0:	f005 fa1f 	bl	10d12 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x24>
    b8d4:	2800      	cmp	r0, #0
    b8d6:	d0ef      	beq.n	b8b8 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x30>
    b8d8:	6065      	str	r5, [r4, #4]
    b8da:	480a      	ldr	r0, [pc, #40]	; (b904 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x7c>)
    b8dc:	1d00      	adds	r0, r0, #4
    b8de:	6006      	str	r6, [r0, #0]
    b8e0:	bd70      	pop	{r4, r5, r6, pc}
    b8e2:	21b3      	movs	r1, #179	; 0xb3
    b8e4:	e007      	b.n	b8f6 <sym_WLH66EC4H754I3MAYKGHFOCADIOY4E4WNRBI4TA+0x6e>
    b8e6:	7015      	strb	r5, [r2, #0]
    b8e8:	f8c4 1104 	str.w	r1, [r4, #260]	; 0x104
    b8ec:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
    b8f0:	6025      	str	r5, [r4, #0]
    b8f2:	bd70      	pop	{r4, r5, r6, pc}
    b8f4:	21c6      	movs	r1, #198	; 0xc6
    b8f6:	203c      	movs	r0, #60	; 0x3c
    b8f8:	f7f9 fc2c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b8fc:	2000033c 	.word	0x2000033c
    b900:	4000f50c 	.word	0x4000f50c
    b904:	4001f504 	.word	0x4001f504
    b908:	4000f000 	.word	0x4000f000

0000b90c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ>:
    b90c:	b570      	push	{r4, r5, r6, lr}
    b90e:	4d05      	ldr	r5, [pc, #20]	; (b924 <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ+0x18>)
    b910:	2400      	movs	r4, #0
    b912:	7828      	ldrb	r0, [r5, #0]
    b914:	b110      	cbz	r0, b91c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ+0x10>
    b916:	f000 f873 	bl	ba00 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x80>
    b91a:	702c      	strb	r4, [r5, #0]
    b91c:	706c      	strb	r4, [r5, #1]
    b91e:	70ac      	strb	r4, [r5, #2]
    b920:	bd70      	pop	{r4, r5, r6, pc}
    b922:	0000      	.short	0x0000
    b924:	2000033c 	.word	0x2000033c

0000b928 <sym_TRMXENGHOH4VBQQZPIN222FLCEFU3Z3CD5C47DY>:
    b928:	4802      	ldr	r0, [pc, #8]	; (b934 <sym_TRMXENGHOH4VBQQZPIN222FLCEFU3Z3CD5C47DY+0xc>)
    b92a:	2100      	movs	r1, #0
    b92c:	7001      	strb	r1, [r0, #0]
    b92e:	7041      	strb	r1, [r0, #1]
    b930:	7081      	strb	r1, [r0, #2]
    b932:	4770      	bx	lr
    b934:	2000033c 	.word	0x2000033c

0000b938 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA>:
    b938:	480b      	ldr	r0, [pc, #44]	; (b968 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x30>)
    b93a:	b510      	push	{r4, lr}
    b93c:	7800      	ldrb	r0, [r0, #0]
    b93e:	b158      	cbz	r0, b958 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x20>
    b940:	f44f 7182 	mov.w	r1, #260	; 0x104
    b944:	4809      	ldr	r0, [pc, #36]	; (b96c <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x34>)
    b946:	f005 f9e4 	bl	10d12 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x24>
    b94a:	b140      	cbz	r0, b95e <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x26>
    b94c:	4808      	ldr	r0, [pc, #32]	; (b970 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x38>)
    b94e:	6800      	ldr	r0, [r0, #0]
    b950:	2800      	cmp	r0, #0
    b952:	d000      	beq.n	b956 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x1e>
    b954:	2001      	movs	r0, #1
    b956:	bd10      	pop	{r4, pc}
    b958:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
    b95c:	e001      	b.n	b962 <sym_3CD5EC6VYR6RXXLO3FXSZQ37BOYSM63APF5D5BA+0x2a>
    b95e:	f240 11eb 	movw	r1, #491	; 0x1eb
    b962:	203c      	movs	r0, #60	; 0x3c
    b964:	f7f9 fbf6 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b968:	2000033c 	.word	0x2000033c
    b96c:	4000f000 	.word	0x4000f000
    b970:	4000f400 	.word	0x4000f400

0000b974 <sym_QQVHHHKNBN5TJBK4NCDSUYAMXMOEHFSL7HE7RRA>:
    b974:	4801      	ldr	r0, [pc, #4]	; (b97c <sym_QQVHHHKNBN5TJBK4NCDSUYAMXMOEHFSL7HE7RRA+0x8>)
    b976:	2101      	movs	r1, #1
    b978:	6081      	str	r1, [r0, #8]
    b97a:	4770      	bx	lr
    b97c:	4000f000 	.word	0x4000f000

0000b980 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI>:
    b980:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b984:	481b      	ldr	r0, [pc, #108]	; (b9f4 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x74>)
    b986:	7800      	ldrb	r0, [r0, #0]
    b988:	b1d8      	cbz	r0, b9c2 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x42>
    b98a:	f8df 806c 	ldr.w	r8, [pc, #108]	; b9f8 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x78>
    b98e:	f44f 7682 	mov.w	r6, #260	; 0x104
    b992:	4631      	mov	r1, r6
    b994:	4640      	mov	r0, r8
    b996:	f005 f9bc 	bl	10d12 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x24>
    b99a:	2800      	cmp	r0, #0
    b99c:	d128      	bne.n	b9f0 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x70>
    b99e:	2002      	movs	r0, #2
    b9a0:	f8c8 0304 	str.w	r0, [r8, #772]	; 0x304
    b9a4:	4c15      	ldr	r4, [pc, #84]	; (b9fc <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x7c>)
    b9a6:	6820      	ldr	r0, [r4, #0]
    b9a8:	43c0      	mvns	r0, r0
    b9aa:	f340 1500 	sbfx	r5, r0, #4, #1
    b9ae:	6820      	ldr	r0, [r4, #0]
    b9b0:	f040 0010 	orr.w	r0, r0, #16
    b9b4:	6020      	str	r0, [r4, #0]
    b9b6:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    b9ba:	f04f 29e0 	mov.w	r9, #3758153728	; 0xe000e000
    b9be:	1c6d      	adds	r5, r5, #1
    b9c0:	e008      	b.n	b9d4 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x54>
    b9c2:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
    b9c6:	203c      	movs	r0, #60	; 0x3c
    b9c8:	f7f9 fbc4 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    b9cc:	f8c9 7280 	str.w	r7, [r9, #640]	; 0x280
    b9d0:	f7f9 fa1a 	bl	4e08 <sym_PAD7XREQQORPXRJMXMW2EYVS4S43S42A5D43SBA>
    b9d4:	4631      	mov	r1, r6
    b9d6:	4640      	mov	r0, r8
    b9d8:	f005 f99b 	bl	10d12 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x24>
    b9dc:	2800      	cmp	r0, #0
    b9de:	d0f5      	beq.n	b9cc <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x4c>
    b9e0:	b91d      	cbnz	r5, b9ea <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x6a>
    b9e2:	6820      	ldr	r0, [r4, #0]
    b9e4:	f020 0010 	bic.w	r0, r0, #16
    b9e8:	6020      	str	r0, [r4, #0]
    b9ea:	2002      	movs	r0, #2
    b9ec:	f8c8 0308 	str.w	r0, [r8, #776]	; 0x308
    b9f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b9f4:	2000033c 	.word	0x2000033c
    b9f8:	4000f000 	.word	0x4000f000
    b9fc:	e000ed10 	.word	0xe000ed10
    ba00:	4902      	ldr	r1, [pc, #8]	; (ba0c <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x8c>)
    ba02:	4801      	ldr	r0, [pc, #4]	; (ba08 <sym_FYMYD324TMLKJZE62CZN4WTXFSPL6FPU2SZH6CI+0x88>)
    ba04:	6008      	str	r0, [r1, #0]
    ba06:	4770      	bx	lr
    ba08:	02020000 	.word	0x02020000
    ba0c:	4001f508 	.word	0x4001f508
    ba10:	00010000 	.word	0x00010000

0000ba14 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI>:
    ba14:	b510      	push	{r4, lr}
    ba16:	4604      	mov	r4, r0
    ba18:	f000 f820 	bl	ba5c <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x48>
    ba1c:	2c00      	cmp	r4, #0
    ba1e:	d00e      	beq.n	ba3e <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x2a>
    ba20:	4a0b      	ldr	r2, [pc, #44]	; (ba50 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x3c>)
    ba22:	480b      	ldr	r0, [pc, #44]	; (ba50 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x3c>)
    ba24:	490b      	ldr	r1, [pc, #44]	; (ba54 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x40>)
    ba26:	3214      	adds	r2, #20
    ba28:	2c01      	cmp	r4, #1
    ba2a:	d005      	beq.n	ba38 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x24>
    ba2c:	2c02      	cmp	r4, #2
    ba2e:	d007      	beq.n	ba40 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x2c>
    ba30:	2181      	movs	r1, #129	; 0x81
    ba32:	203d      	movs	r0, #61	; 0x3d
    ba34:	f7f9 fb8e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ba38:	2302      	movs	r3, #2
    ba3a:	6003      	str	r3, [r0, #0]
    ba3c:	6011      	str	r1, [r2, #0]
    ba3e:	bd10      	pop	{r4, pc}
    ba40:	2303      	movs	r3, #3
    ba42:	6003      	str	r3, [r0, #0]
    ba44:	6011      	str	r1, [r2, #0]
    ba46:	4904      	ldr	r1, [pc, #16]	; (ba58 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x44>)
    ba48:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    ba4c:	6008      	str	r0, [r1, #0]
    ba4e:	bd10      	pop	{r4, pc}
    ba50:	4000f500 	.word	0x4000f500
    ba54:	20001bf1 	.word	0x20001bf1
    ba58:	4001f504 	.word	0x4001f504
    ba5c:	4805      	ldr	r0, [pc, #20]	; (ba74 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x60>)
    ba5e:	b510      	push	{r4, lr}
    ba60:	2100      	movs	r1, #0
    ba62:	6001      	str	r1, [r0, #0]
    ba64:	6001      	str	r1, [r0, #0]
    ba66:	f7ff ff51 	bl	b90c <sym_VIDE7XVSTT4HHX2MQJX6VUVABAKVNGIPRTLRLEQ>
    ba6a:	4903      	ldr	r1, [pc, #12]	; (ba78 <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x64>)
    ba6c:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    ba70:	6008      	str	r0, [r1, #0]
    ba72:	bd10      	pop	{r4, pc}
    ba74:	4000f500 	.word	0x4000f500
    ba78:	4001f508 	.word	0x4001f508

0000ba7c <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y>:
    ba7c:	4805      	ldr	r0, [pc, #20]	; (ba94 <sym_PCLF3MATC3G3MYGRPG4ATMGCS6N4B7M5CSF2C2Y+0x18>)
    ba7e:	f8d0 1200 	ldr.w	r1, [r0, #512]	; 0x200
    ba82:	f021 0140 	bic.w	r1, r1, #64	; 0x40
    ba86:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
    ba8a:	2100      	movs	r1, #0
    ba8c:	f8c0 1560 	str.w	r1, [r0, #1376]	; 0x560
    ba90:	4770      	bx	lr
    ba92:	0000      	.short	0x0000
    ba94:	40001000 	.word	0x40001000

0000ba98 <sym_RXYEX777ZXB2E2DXJWDBCV7AAHWTCHNTLOSENBY>:
    ba98:	4904      	ldr	r1, [pc, #16]	; (baac <sym_RXYEX777ZXB2E2DXJWDBCV7AAHWTCHNTLOSENBY+0x14>)
    ba9a:	f8c1 0560 	str.w	r0, [r1, #1376]	; 0x560
    ba9e:	f8d1 0200 	ldr.w	r0, [r1, #512]	; 0x200
    baa2:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    baa6:	f8c1 0200 	str.w	r0, [r1, #512]	; 0x200
    baaa:	4770      	bx	lr
    baac:	40001000 	.word	0x40001000

0000bab0 <sym_BNUQ5CI25DXEDLVOULTXPCKLL6P4CJJYO4G535I>:
    bab0:	4801      	ldr	r0, [pc, #4]	; (bab8 <sym_BNUQ5CI25DXEDLVOULTXPCKLL6P4CJJYO4G535I+0x8>)
    bab2:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
    bab6:	4770      	bx	lr
    bab8:	200016a0 	.word	0x200016a0

0000babc <sym_DRIMECVE2FH7O6C2LQ25QRVJOICPHLA5GC6TM2I>:
    babc:	4902      	ldr	r1, [pc, #8]	; (bac8 <sym_DRIMECVE2FH7O6C2LQ25QRVJOICPHLA5GC6TM2I+0xc>)
    babe:	5c08      	ldrb	r0, [r1, r0]
    bac0:	f500 6016 	add.w	r0, r0, #2400	; 0x960
    bac4:	4770      	bx	lr
    bac6:	0000      	.short	0x0000
    bac8:	0000c7ea 	.word	0x0000c7ea

0000bacc <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y>:
    bacc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bace:	4c24      	ldr	r4, [pc, #144]	; (bb60 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x94>)
    bad0:	f8d4 0304 	ldr.w	r0, [r4, #772]	; 0x304
    bad4:	f010 0f10 	tst.w	r0, #16
    bad8:	d001      	beq.n	bade <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x12>
    bada:	2701      	movs	r7, #1
    badc:	e000      	b.n	bae0 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x14>
    bade:	2700      	movs	r7, #0
    bae0:	2010      	movs	r0, #16
    bae2:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    bae6:	2002      	movs	r0, #2
    bae8:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
    baec:	481d      	ldr	r0, [pc, #116]	; (bb64 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x98>)
    baee:	2500      	movs	r5, #0
    baf0:	491d      	ldr	r1, [pc, #116]	; (bb68 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x9c>)
    baf2:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
    baf6:	f44f 2060 	mov.w	r0, #917504	; 0xe0000
    bafa:	6008      	str	r0, [r1, #0]
    bafc:	f8d4 0550 	ldr.w	r0, [r4, #1360]	; 0x550
    bb00:	f44f 7688 	mov.w	r6, #272	; 0x110
    bb04:	f010 0fff 	tst.w	r0, #255	; 0xff
    bb08:	d019      	beq.n	bb3e <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x72>
    bb0a:	20ff      	movs	r0, #255	; 0xff
    bb0c:	f88d 0000 	strb.w	r0, [sp]
    bb10:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
    bb14:	2001      	movs	r0, #1
    bb16:	6120      	str	r0, [r4, #16]
    bb18:	e005      	b.n	bb26 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x5a>
    bb1a:	bf00      	nop
    bb1c:	f89d 0000 	ldrb.w	r0, [sp]
    bb20:	1e40      	subs	r0, r0, #1
    bb22:	f88d 0000 	strb.w	r0, [sp]
    bb26:	f89d 0000 	ldrb.w	r0, [sp]
    bb2a:	b128      	cbz	r0, bb38 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x6c>
    bb2c:	4631      	mov	r1, r6
    bb2e:	4620      	mov	r0, r4
    bb30:	f005 f91e 	bl	10d70 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x54>
    bb34:	2800      	cmp	r0, #0
    bb36:	d0f1      	beq.n	bb1c <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x50>
    bb38:	f89d 0000 	ldrb.w	r0, [sp]
    bb3c:	b158      	cbz	r0, bb56 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x8a>
    bb3e:	f000 fc49 	bl	c3d4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x90>
    bb42:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
    bb46:	f000 fdd1 	bl	c6ec <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a8>
    bb4a:	2f00      	cmp	r7, #0
    bb4c:	d002      	beq.n	bb54 <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y+0x88>
    bb4e:	2010      	movs	r0, #16
    bb50:	f8c4 0304 	str.w	r0, [r4, #772]	; 0x304
    bb54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    bb56:	f640 0163 	movw	r1, #2147	; 0x863
    bb5a:	203e      	movs	r0, #62	; 0x3e
    bb5c:	f7f9 fafa 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    bb60:	40001000 	.word	0x40001000
    bb64:	200016a0 	.word	0x200016a0
    bb68:	4001f508 	.word	0x4001f508

0000bb6c <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI>:
    bb6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bb70:	4d18      	ldr	r5, [pc, #96]	; (bbd4 <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x68>)
    bb72:	4607      	mov	r7, r0
    bb74:	f895 002c 	ldrb.w	r0, [r5, #44]	; 0x2c
    bb78:	07c2      	lsls	r2, r0, #31
    bb7a:	d00f      	beq.n	bb9c <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x30>
    bb7c:	4c16      	ldr	r4, [pc, #88]	; (bbd8 <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x6c>)
    bb7e:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    bb82:	f042 0201 	orr.w	r2, r2, #1
    bb86:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
    bb8a:	f040 0002 	orr.w	r0, r0, #2
    bb8e:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
    bb92:	2601      	movs	r6, #1
    bb94:	b13f      	cbz	r7, bba6 <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x3a>
    bb96:	2f01      	cmp	r7, #1
    bb98:	d00b      	beq.n	bbb2 <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x46>
    bb9a:	e010      	b.n	bbbe <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x52>
    bb9c:	f44f 61e9 	mov.w	r1, #1864	; 0x748
    bba0:	203e      	movs	r0, #62	; 0x3e
    bba2:	f7f9 fad7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    bba6:	4608      	mov	r0, r1
    bba8:	f000 fdfa 	bl	c7a0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x45c>
    bbac:	726e      	strb	r6, [r5, #9]
    bbae:	6026      	str	r6, [r4, #0]
    bbb0:	e005      	b.n	bbbe <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x52>
    bbb2:	4608      	mov	r0, r1
    bbb4:	f000 fdda 	bl	c76c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x428>
    bbb8:	2002      	movs	r0, #2
    bbba:	7268      	strb	r0, [r5, #9]
    bbbc:	6066      	str	r6, [r4, #4]
    bbbe:	4807      	ldr	r0, [pc, #28]	; (bbdc <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x70>)
    bbc0:	64c6      	str	r6, [r0, #76]	; 0x4c
    bbc2:	4806      	ldr	r0, [pc, #24]	; (bbdc <sym_6PPYXQQOLTVZ6DHASA45P4Y6MOJ5US37OHECCGI+0x70>)
    bbc4:	300c      	adds	r0, #12
    bbc6:	f8d0 1540 	ldr.w	r1, [r0, #1344]	; 0x540
    bbca:	4638      	mov	r0, r7
    bbcc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    bbd0:	f000 bd5e 	b.w	c690 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x34c>
    bbd4:	200016a0 	.word	0x200016a0
    bbd8:	40001000 	.word	0x40001000
    bbdc:	40008000 	.word	0x40008000

0000bbe0 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I>:
    bbe0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    bbe4:	4c2c      	ldr	r4, [pc, #176]	; (bc98 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0xb8>)
    bbe6:	0006      	movs	r6, r0
    bbe8:	4d2c      	ldr	r5, [pc, #176]	; (bc9c <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0xbc>)
    bbea:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
    bbee:	f8df 80b0 	ldr.w	r8, [pc, #176]	; bca0 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0xc0>
    bbf2:	f040 0002 	orr.w	r0, r0, #2
    bbf6:	4689      	mov	r9, r1
    bbf8:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    bbfc:	f04f 0700 	mov.w	r7, #0
    bc00:	d002      	beq.n	bc08 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0x28>
    bc02:	2e01      	cmp	r6, #1
    bc04:	d020      	beq.n	bc48 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0x68>
    bc06:	e036      	b.n	bc76 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0x96>
    bc08:	4608      	mov	r0, r1
    bc0a:	f000 fdc9 	bl	c7a0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x45c>
    bc0e:	2001      	movs	r0, #1
    bc10:	7260      	strb	r0, [r4, #9]
    bc12:	79e0      	ldrb	r0, [r4, #7]
    bc14:	2801      	cmp	r0, #1
    bc16:	d105      	bne.n	bc24 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0x44>
    bc18:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
    bc1c:	f040 0008 	orr.w	r0, r0, #8
    bc20:	f8c5 0200 	str.w	r0, [r5, #512]	; 0x200
    bc24:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    bc26:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
    bc2a:	62a0      	str	r0, [r4, #40]	; 0x28
    bc2c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    bc30:	f8c8 0000 	str.w	r0, [r8]
    bc34:	491b      	ldr	r1, [pc, #108]	; (bca4 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0xc4>)
    bc36:	f831 0019 	ldrh.w	r0, [r1, r9, lsl #1]
    bc3a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    bc3e:	f500 70fa 	add.w	r0, r0, #500	; 0x1f4
    bc42:	fbb0 f7f1 	udiv	r7, r0, r1
    bc46:	e016      	b.n	bc76 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0x96>
    bc48:	4608      	mov	r0, r1
    bc4a:	f000 fd8f 	bl	c76c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x428>
    bc4e:	2002      	movs	r0, #2
    bc50:	7260      	strb	r0, [r4, #9]
    bc52:	79e0      	ldrb	r0, [r4, #7]
    bc54:	2801      	cmp	r0, #1
    bc56:	d105      	bne.n	bc64 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0x84>
    bc58:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
    bc5c:	f040 0004 	orr.w	r0, r0, #4
    bc60:	f8c5 0200 	str.w	r0, [r5, #512]	; 0x200
    bc64:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    bc66:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
    bc6a:	62a0      	str	r0, [r4, #40]	; 0x28
    bc6c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
    bc70:	f8c8 0000 	str.w	r0, [r8]
    bc74:	2729      	movs	r7, #41	; 0x29
    bc76:	f000 fc19 	bl	c4ac <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x168>
    bc7a:	f001 f843 	bl	cd04 <sym_F77FUTRRLLWPYDS7BBANG2WE3C4EDMYMAPNI54A>
    bc7e:	b120      	cbz	r0, bc8a <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0xaa>
    bc80:	f7ff ff24 	bl	bacc <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y>
    bc84:	2000      	movs	r0, #0
    bc86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bc8a:	2100      	movs	r1, #0
    bc8c:	4630      	mov	r0, r6
    bc8e:	f000 fcff 	bl	c690 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x34c>
    bc92:	4638      	mov	r0, r7
    bc94:	e7f7      	b.n	bc86 <sym_WJZCKVDJU3WW5NVNH77DPRGYVZQLD372GLDYO6I+0xa6>
    bc96:	0000      	.short	0x0000
    bc98:	200016a0 	.word	0x200016a0
    bc9c:	40001000 	.word	0x40001000
    bca0:	4001f504 	.word	0x4001f504
    bca4:	0000c7e4 	.word	0x0000c7e4

0000bca8 <sym_LSYZDZOMTD6BKKRX25HIBNLFKSFDXBS3PS4UKOY>:
    bca8:	4a02      	ldr	r2, [pc, #8]	; (bcb4 <sym_LSYZDZOMTD6BKKRX25HIBNLFKSFDXBS3PS4UKOY+0xc>)
    bcaa:	6b13      	ldr	r3, [r2, #48]	; 0x30
    bcac:	6003      	str	r3, [r0, #0]
    bcae:	6b50      	ldr	r0, [r2, #52]	; 0x34
    bcb0:	6008      	str	r0, [r1, #0]
    bcb2:	4770      	bx	lr
    bcb4:	200016a0 	.word	0x200016a0

0000bcb8 <sym_YG4UROEKVB7ZBE5TWHLNJHYKSFBTXGBYAX3RXRI>:
    bcb8:	b510      	push	{r4, lr}
    bcba:	c81d      	ldmia	r0, {r0, r2, r3, r4}
    bcbc:	4901      	ldr	r1, [pc, #4]	; (bcc4 <sym_YG4UROEKVB7ZBE5TWHLNJHYKSFBTXGBYAX3RXRI+0xc>)
    bcbe:	e881 001d 	stmia.w	r1, {r0, r2, r3, r4}
    bcc2:	bd10      	pop	{r4, pc}
    bcc4:	20001690 	.word	0x20001690

0000bcc8 <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA>:
    bcc8:	490f      	ldr	r1, [pc, #60]	; (bd08 <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA+0x40>)
    bcca:	b510      	push	{r4, lr}
    bccc:	69ca      	ldr	r2, [r1, #28]
    bcce:	4282      	cmp	r2, r0
    bcd0:	d302      	bcc.n	bcd8 <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA+0x10>
    bcd2:	f640 01f7 	movw	r1, #2295	; 0x8f7
    bcd6:	e00b      	b.n	bcf0 <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA+0x28>
    bcd8:	2201      	movs	r2, #1
    bcda:	730a      	strb	r2, [r1, #12]
    bcdc:	6108      	str	r0, [r1, #16]
    bcde:	490b      	ldr	r1, [pc, #44]	; (bd0c <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA+0x44>)
    bce0:	644a      	str	r2, [r1, #68]	; 0x44
    bce2:	1d0a      	adds	r2, r1, #4
    bce4:	f8d2 3540 	ldr.w	r3, [r2, #1344]	; 0x540
    bce8:	4283      	cmp	r3, r0
    bcea:	d304      	bcc.n	bcf6 <sym_7CIQBS4FNO23MS6BAN7Q3LK45R62DBPT5FNCWOA+0x2e>
    bcec:	f44f 6110 	mov.w	r1, #2304	; 0x900
    bcf0:	203e      	movs	r0, #62	; 0x3e
    bcf2:	f7f9 fa2f 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    bcf6:	2300      	movs	r3, #0
    bcf8:	f8c1 3144 	str.w	r3, [r1, #324]	; 0x144
    bcfc:	f8c2 0540 	str.w	r0, [r2, #1344]	; 0x540
    bd00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    bd04:	f000 bc98 	b.w	c638 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2f4>
    bd08:	200016a0 	.word	0x200016a0
    bd0c:	40008000 	.word	0x40008000

0000bd10 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY>:
    bd10:	b570      	push	{r4, r5, r6, lr}
    bd12:	4c0f      	ldr	r4, [pc, #60]	; (bd50 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY+0x40>)
    bd14:	4603      	mov	r3, r0
    bd16:	2002      	movs	r0, #2
    bd18:	7320      	strb	r0, [r4, #12]
    bd1a:	f894 5021 	ldrb.w	r5, [r4, #33]	; 0x21
    bd1e:	2096      	movs	r0, #150	; 0x96
    bd20:	f894 1020 	ldrb.w	r1, [r4, #32]
    bd24:	7d22      	ldrb	r2, [r4, #20]
    bd26:	2d01      	cmp	r5, #1
    bd28:	d00e      	beq.n	bd48 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY+0x38>
    bd2a:	f000 fd97 	bl	c85c <sym_55XNA7W2CQFJPCH62ZAKHLPISYHJ7KMNREEN6EA>
    bd2e:	6120      	str	r0, [r4, #16]
    bd30:	4808      	ldr	r0, [pc, #32]	; (bd54 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY+0x44>)
    bd32:	2100      	movs	r1, #0
    bd34:	f8c0 1144 	str.w	r1, [r0, #324]	; 0x144
    bd38:	6921      	ldr	r1, [r4, #16]
    bd3a:	69e0      	ldr	r0, [r4, #28]
    bd3c:	4408      	add	r0, r1
    bd3e:	4905      	ldr	r1, [pc, #20]	; (bd54 <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY+0x44>)
    bd40:	1d09      	adds	r1, r1, #4
    bd42:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
    bd46:	bd70      	pop	{r4, r5, r6, pc}
    bd48:	f000 fda6 	bl	c898 <sym_7VLVVPDI26BVJ64XQBSGXOQYGQA4VH5APIPDGYA>
    bd4c:	e7ef      	b.n	bd2e <sym_Y6HXZQJARJ7FDWKGPREPQGRRGDOQMXHDALUK6KY+0x1e>
    bd4e:	0000      	.short	0x0000
    bd50:	200016a0 	.word	0x200016a0
    bd54:	40008000 	.word	0x40008000

0000bd58 <sym_YUNWMAOOL6VPZ57LS54EAM7TJ65IEHYU7XKGKUI>:
    bd58:	b510      	push	{r4, lr}
    bd5a:	f001 f91b 	bl	cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>
    bd5e:	2800      	cmp	r0, #0
    bd60:	d006      	beq.n	bd70 <sym_YUNWMAOOL6VPZ57LS54EAM7TJ65IEHYU7XKGKUI+0x18>
    bd62:	4804      	ldr	r0, [pc, #16]	; (bd74 <sym_YUNWMAOOL6VPZ57LS54EAM7TJ65IEHYU7XKGKUI+0x1c>)
    bd64:	6801      	ldr	r1, [r0, #0]
    bd66:	f021 0101 	bic.w	r1, r1, #1
    bd6a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
    bd6e:	6001      	str	r1, [r0, #0]
    bd70:	bd10      	pop	{r4, pc}
    bd72:	0000      	.short	0x0000
    bd74:	40001774 	.word	0x40001774

0000bd78 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A>:
    bd78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bd7c:	2238      	movs	r2, #56	; 0x38
    bd7e:	2100      	movs	r1, #0
    bd80:	4813      	ldr	r0, [pc, #76]	; (bdd0 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x58>)
    bd82:	f001 f9a5 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    bd86:	f000 fcb1 	bl	c6ec <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a8>
    bd8a:	f001 f8bc 	bl	cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>
    bd8e:	4d11      	ldr	r5, [pc, #68]	; (bdd4 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x5c>)
    bd90:	4e10      	ldr	r6, [pc, #64]	; (bdd4 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x5c>)
    bd92:	2400      	movs	r4, #0
    bd94:	4f0f      	ldr	r7, [pc, #60]	; (bdd4 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x5c>)
    bd96:	3508      	adds	r5, #8
    bd98:	3610      	adds	r6, #16
    bd9a:	b928      	cbnz	r0, bda8 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x30>
    bd9c:	f001 f8ca 	bl	cf34 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q>
    bda0:	b910      	cbnz	r0, bda8 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x30>
    bda2:	f001 f8d1 	bl	cf48 <sym_SWIBDSDMHUYNCG5ZWLB52J7NETJIUBPCO5IIQFA>
    bda6:	b108      	cbz	r0, bdac <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x34>
    bda8:	2224      	movs	r2, #36	; 0x24
    bdaa:	e006      	b.n	bdba <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x42>
    bdac:	f001 f90c 	bl	cfc8 <sym_USR4MDT6VMTQLOGKNN4MALBZ3GJPD2KOEY4HFAQ>
    bdb0:	b910      	cbnz	r0, bdb8 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x40>
    bdb2:	f001 f8ff 	bl	cfb4 <sym_6PVOPWDLWTXOTRZZ7LP36TLYTLPTQHNAUQNFHEA>
    bdb6:	b140      	cbz	r0, bdca <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x52>
    bdb8:	2240      	movs	r2, #64	; 0x40
    bdba:	21ff      	movs	r1, #255	; 0xff
    bdbc:	4638      	mov	r0, r7
    bdbe:	f001 f987 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    bdc2:	602c      	str	r4, [r5, #0]
    bdc4:	6034      	str	r4, [r6, #0]
    bdc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bdca:	2238      	movs	r2, #56	; 0x38
    bdcc:	e7f5      	b.n	bdba <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A+0x42>
    bdce:	0000      	.short	0x0000
    bdd0:	200016a0 	.word	0x200016a0
    bdd4:	40000e00 	.word	0x40000e00

0000bdd8 <sym_GI7KSEEMTJQ7HR2XTQJ6A3EAB54YYLMWKNL2RBA>:
    bdd8:	4801      	ldr	r0, [pc, #4]	; (bde0 <sym_GI7KSEEMTJQ7HR2XTQJ6A3EAB54YYLMWKNL2RBA+0x8>)
    bdda:	69c0      	ldr	r0, [r0, #28]
    bddc:	4770      	bx	lr
    bdde:	0000      	.short	0x0000
    bde0:	200016a0 	.word	0x200016a0

0000bde4 <sym_YKV5VFBUMD7K2LRWZ6WWYBEL5ESMQ4SDYYBDIPI>:
    bde4:	4801      	ldr	r0, [pc, #4]	; (bdec <sym_YKV5VFBUMD7K2LRWZ6WWYBEL5ESMQ4SDYYBDIPI+0x8>)
    bde6:	6980      	ldr	r0, [r0, #24]
    bde8:	4770      	bx	lr
    bdea:	0000      	.short	0x0000
    bdec:	200016a0 	.word	0x200016a0

0000bdf0 <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY>:
    bdf0:	b510      	push	{r4, lr}
    bdf2:	f000 fc2f 	bl	c654 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x310>
    bdf6:	f7ff fe69 	bl	bacc <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y>
    bdfa:	f7f9 f85b 	bl	4eb4 <mpsl_fem_disable>
    bdfe:	b130      	cbz	r0, be0e <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY+0x1e>
    be00:	1c40      	adds	r0, r0, #1
    be02:	d004      	beq.n	be0e <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY+0x1e>
    be04:	f240 5126 	movw	r1, #1318	; 0x526
    be08:	203e      	movs	r0, #62	; 0x3e
    be0a:	f7f9 f9a3 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    be0e:	480f      	ldr	r0, [pc, #60]	; (be4c <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY+0x5c>)
    be10:	4a0f      	ldr	r2, [pc, #60]	; (be50 <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY+0x60>)
    be12:	6a81      	ldr	r1, [r0, #40]	; 0x28
    be14:	f041 6144 	orr.w	r1, r1, #205520896	; 0xc400000
    be18:	6011      	str	r1, [r2, #0]
    be1a:	2400      	movs	r4, #0
    be1c:	6284      	str	r4, [r0, #40]	; 0x28
    be1e:	7304      	strb	r4, [r0, #12]
    be20:	61c4      	str	r4, [r0, #28]
    be22:	6184      	str	r4, [r0, #24]
    be24:	f000 fc16 	bl	c654 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x310>
    be28:	480a      	ldr	r0, [pc, #40]	; (be54 <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY+0x64>)
    be2a:	f8c0 4148 	str.w	r4, [r0, #328]	; 0x148
    be2e:	f8c0 4144 	str.w	r4, [r0, #324]	; 0x144
    be32:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
    be36:	f8c0 414c 	str.w	r4, [r0, #332]	; 0x14c
    be3a:	2001      	movs	r0, #1
    be3c:	f004 ff87 	bl	10d4e <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x32>
    be40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    be44:	2001      	movs	r0, #1
    be46:	f004 bf75 	b.w	10d34 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x18>
    be4a:	0000      	.short	0x0000
    be4c:	200016a0 	.word	0x200016a0
    be50:	4001f508 	.word	0x4001f508
    be54:	40008000 	.word	0x40008000

0000be58 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI>:
    be58:	b570      	push	{r4, r5, r6, lr}
    be5a:	2001      	movs	r0, #1
    be5c:	f004 ff77 	bl	10d4e <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x32>
    be60:	4c37      	ldr	r4, [pc, #220]	; (bf40 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xe8>)
    be62:	2000      	movs	r0, #0
    be64:	f8c4 0ffc 	str.w	r0, [r4, #4092]	; 0xffc
    be68:	2001      	movs	r0, #1
    be6a:	f8c4 0ffc 	str.w	r0, [r4, #4092]	; 0xffc
    be6e:	f001 f881 	bl	cf74 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ>
    be72:	4d34      	ldr	r5, [pc, #208]	; (bf44 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xec>)
    be74:	b118      	cbz	r0, be7e <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x26>
    be76:	6828      	ldr	r0, [r5, #0]
    be78:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
    be7c:	6028      	str	r0, [r5, #0]
    be7e:	f001 f86d 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    be82:	b128      	cbz	r0, be90 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x38>
    be84:	6828      	ldr	r0, [r5, #0]
    be86:	4930      	ldr	r1, [pc, #192]	; (bf48 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xf0>)
    be88:	f020 0069 	bic.w	r0, r0, #105	; 0x69
    be8c:	4308      	orrs	r0, r1
    be8e:	6028      	str	r0, [r5, #0]
    be90:	f001 f880 	bl	cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>
    be94:	b138      	cbz	r0, bea6 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x4e>
    be96:	482b      	ldr	r0, [pc, #172]	; (bf44 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xec>)
    be98:	1d00      	adds	r0, r0, #4
    be9a:	6801      	ldr	r1, [r0, #0]
    be9c:	f421 417f 	bic.w	r1, r1, #65280	; 0xff00
    bea0:	f441 51b0 	orr.w	r1, r1, #5632	; 0x1600
    bea4:	6001      	str	r1, [r0, #0]
    bea6:	4927      	ldr	r1, [pc, #156]	; (bf44 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xec>)
    bea8:	4828      	ldr	r0, [pc, #160]	; (bf4c <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xf4>)
    beaa:	313c      	adds	r1, #60	; 0x3c
    beac:	6008      	str	r0, [r1, #0]
    beae:	f7f9 f837 	bl	4f20 <mpsl_fem_device_config_254_apply_get>
    beb2:	b140      	cbz	r0, bec6 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x6e>
    beb4:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    beb8:	f8d0 0330 	ldr.w	r0, [r0, #816]	; 0x330
    bebc:	1c41      	adds	r1, r0, #1
    bebe:	d002      	beq.n	bec6 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x6e>
    bec0:	4920      	ldr	r1, [pc, #128]	; (bf44 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xec>)
    bec2:	3110      	adds	r1, #16
    bec4:	6008      	str	r0, [r1, #0]
    bec6:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    beca:	6e00      	ldr	r0, [r0, #96]	; 0x60
    becc:	1c41      	adds	r1, r0, #1
    bece:	d004      	beq.n	beda <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x82>
    bed0:	491f      	ldr	r1, [pc, #124]	; (bf50 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xf8>)
    bed2:	680a      	ldr	r2, [r1, #0]
    bed4:	f360 4217 	bfi	r2, r0, #16, #8
    bed8:	600a      	str	r2, [r1, #0]
    beda:	f240 1103 	movw	r1, #259	; 0x103
    bede:	f240 605b 	movw	r0, #1627	; 0x65b
    bee2:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    bee6:	f8c4 0538 	str.w	r0, [r4, #1336]	; 0x538
    beea:	2001      	movs	r0, #1
    beec:	f8c4 0530 	str.w	r0, [r4, #1328]	; 0x530
    bef0:	f000 f842 	bl	bf78 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ>
    bef4:	f240 2001 	movw	r0, #513	; 0x201
    bef8:	f8c4 0650 	str.w	r0, [r4, #1616]	; 0x650
    befc:	2002      	movs	r0, #2
    befe:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
    bf02:	4914      	ldr	r1, [pc, #80]	; (bf54 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xfc>)
    bf04:	f04f 6040 	mov.w	r0, #201326592	; 0xc000000
    bf08:	6008      	str	r0, [r1, #0]
    bf0a:	4913      	ldr	r1, [pc, #76]	; (bf58 <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x100>)
    bf0c:	2000      	movs	r0, #0
    bf0e:	4d13      	ldr	r5, [pc, #76]	; (bf5c <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0x104>)
    bf10:	8608      	strh	r0, [r1, #48]	; 0x30
    bf12:	3110      	adds	r1, #16
    bf14:	61c8      	str	r0, [r1, #28]
    bf16:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
    bf1a:	7028      	strb	r0, [r5, #0]
    bf1c:	2001      	movs	r0, #1
    bf1e:	f004 ff09 	bl	10d34 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x18>
    bf22:	2010      	movs	r0, #16
    bf24:	f8c4 0304 	str.w	r0, [r4, #772]	; 0x304
    bf28:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    bf2c:	2002      	movs	r0, #2
    bf2e:	f8c1 0100 	str.w	r0, [r1, #256]	; 0x100
    bf32:	6868      	ldr	r0, [r5, #4]
    bf34:	2800      	cmp	r0, #0
    bf36:	d002      	beq.n	bf3e <sym_JQ5GTNCJKXERB3SSKQRXLQOKWJQVRNEOVZZZVXI+0xe6>
    bf38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    bf3c:	4700      	bx	r0
    bf3e:	bd70      	pop	{r4, r5, r6, pc}
    bf40:	40001000 	.word	0x40001000
    bf44:	4000173c 	.word	0x4000173c
    bf48:	80000096 	.word	0x80000096
    bf4c:	8900002c 	.word	0x8900002c
    bf50:	4000158c 	.word	0x4000158c
    bf54:	4001f504 	.word	0x4001f504
    bf58:	20001690 	.word	0x20001690
    bf5c:	200002f0 	.word	0x200002f0

0000bf60 <sym_HE5JGYEZFIITGQL7PMATDHSORSCK7HJIY5UXOZA>:
    bf60:	4901      	ldr	r1, [pc, #4]	; (bf68 <sym_HE5JGYEZFIITGQL7PMATDHSORSCK7HJIY5UXOZA+0x8>)
    bf62:	7548      	strb	r0, [r1, #21]
    bf64:	4770      	bx	lr
    bf66:	0000      	.short	0x0000
    bf68:	200016a0 	.word	0x200016a0

0000bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>:
    bf6c:	4901      	ldr	r1, [pc, #4]	; (bf74 <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY+0x8>)
    bf6e:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    bf72:	4770      	bx	lr
    bf74:	0000c838 	.word	0x0000c838

0000bf78 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ>:
    bf78:	4908      	ldr	r1, [pc, #32]	; (bf9c <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ+0x24>)
    bf7a:	b510      	push	{r4, lr}
    bf7c:	7508      	strb	r0, [r1, #20]
    bf7e:	4908      	ldr	r1, [pc, #32]	; (bfa0 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ+0x28>)
    bf80:	2801      	cmp	r0, #1
    bf82:	d006      	beq.n	bf92 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ+0x1a>
    bf84:	2802      	cmp	r0, #2
    bf86:	d006      	beq.n	bf96 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ+0x1e>
    bf88:	f640 5135 	movw	r1, #3381	; 0xd35
    bf8c:	203e      	movs	r0, #62	; 0x3e
    bf8e:	f7f9 f8e1 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    bf92:	2003      	movs	r0, #3
    bf94:	e000      	b.n	bf98 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ+0x20>
    bf96:	2004      	movs	r0, #4
    bf98:	6008      	str	r0, [r1, #0]
    bf9a:	bd10      	pop	{r4, pc}
    bf9c:	200016a0 	.word	0x200016a0
    bfa0:	40001510 	.word	0x40001510

0000bfa4 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I>:
    bfa4:	4905      	ldr	r1, [pc, #20]	; (bfbc <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I+0x18>)
    bfa6:	f8c1 0504 	str.w	r0, [r1, #1284]	; 0x504
    bfaa:	4805      	ldr	r0, [pc, #20]	; (bfc0 <sym_LPFN6QJEOHBT4AP2K7MEYWDZW35U5VHIHXOA54I+0x1c>)
    bfac:	f810 1f2c 	ldrb.w	r1, [r0, #44]!
    bfb0:	f041 0101 	orr.w	r1, r1, #1
    bfb4:	7001      	strb	r1, [r0, #0]
    bfb6:	f000 ba3f 	b.w	c438 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xf4>
    bfba:	0000      	.short	0x0000
    bfbc:	40001000 	.word	0x40001000
    bfc0:	200016a0 	.word	0x200016a0

0000bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>:
    bfc4:	4901      	ldr	r1, [pc, #4]	; (bfcc <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY+0x8>)
    bfc6:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    bfca:	4770      	bx	lr
    bfcc:	0000c844 	.word	0x0000c844

0000bfd0 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA>:
    bfd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    bfd4:	f8df 90a0 	ldr.w	r9, [pc, #160]	; c078 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xa8>
    bfd8:	4d28      	ldr	r5, [pc, #160]	; (c07c <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xac>)
    bfda:	460f      	mov	r7, r1
    bfdc:	0006      	movs	r6, r0
    bfde:	4614      	mov	r4, r2
    bfe0:	f04f 0801 	mov.w	r8, #1
    bfe4:	d004      	beq.n	bff0 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0x20>
    bfe6:	2e01      	cmp	r6, #1
    bfe8:	d010      	beq.n	c00c <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0x3c>
    bfea:	f240 71f4 	movw	r1, #2036	; 0x7f4
    bfee:	e039      	b.n	c064 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0x94>
    bff0:	4610      	mov	r0, r2
    bff2:	f000 fbd5 	bl	c7a0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x45c>
    bff6:	4822      	ldr	r0, [pc, #136]	; (c080 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xb0>)
    bff8:	f885 8009 	strb.w	r8, [r5, #9]
    bffc:	f830 1014 	ldrh.w	r1, [r0, r4, lsl #1]
    c000:	4638      	mov	r0, r7
    c002:	f000 fb7b 	bl	c6fc <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3b8>
    c006:	4604      	mov	r4, r0
    c008:	4648      	mov	r0, r9
    c00a:	e00c      	b.n	c026 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0x56>
    c00c:	4610      	mov	r0, r2
    c00e:	f000 fbad 	bl	c76c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x428>
    c012:	2002      	movs	r0, #2
    c014:	7268      	strb	r0, [r5, #9]
    c016:	f649 71ba 	movw	r1, #40890	; 0x9fba
    c01a:	4638      	mov	r0, r7
    c01c:	f000 fb6e 	bl	c6fc <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3b8>
    c020:	4604      	mov	r4, r0
    c022:	4815      	ldr	r0, [pc, #84]	; (c078 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xa8>)
    c024:	1d00      	adds	r0, r0, #4
    c026:	f000 fb27 	bl	c678 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x334>
    c02a:	4f16      	ldr	r7, [pc, #88]	; (c084 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xb4>)
    c02c:	f8c7 4540 	str.w	r4, [r7, #1344]	; 0x540
    c030:	4916      	ldr	r1, [pc, #88]	; (c08c <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xbc>)
    c032:	4815      	ldr	r0, [pc, #84]	; (c088 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xb8>)
    c034:	f8c1 0510 	str.w	r0, [r1, #1296]	; 0x510
    c038:	2010      	movs	r0, #16
    c03a:	f8c9 0304 	str.w	r0, [r9, #772]	; 0x304
    c03e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    c040:	4913      	ldr	r1, [pc, #76]	; (c090 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xc0>)
    c042:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
    c046:	62a8      	str	r0, [r5, #40]	; 0x28
    c048:	0138      	lsls	r0, r7, #4
    c04a:	6008      	str	r0, [r1, #0]
    c04c:	f000 fa2e 	bl	c4ac <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x168>
    c050:	f8c7 804c 	str.w	r8, [r7, #76]	; 0x4c
    c054:	480b      	ldr	r0, [pc, #44]	; (c084 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0xb4>)
    c056:	300c      	adds	r0, #12
    c058:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
    c05c:	42a0      	cmp	r0, r4
    c05e:	d304      	bcc.n	c06a <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA+0x9a>
    c060:	f640 010a 	movw	r1, #2058	; 0x80a
    c064:	203e      	movs	r0, #62	; 0x3e
    c066:	f7f9 f875 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c06a:	4621      	mov	r1, r4
    c06c:	4630      	mov	r0, r6
    c06e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c072:	f000 bb0d 	b.w	c690 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x34c>
    c076:	0000      	.short	0x0000
    c078:	40001000 	.word	0x40001000
    c07c:	200016a0 	.word	0x200016a0
    c080:	0000c7e4 	.word	0x0000c7e4
    c084:	40008000 	.word	0x40008000
    c088:	40008140 	.word	0x40008140
    c08c:	4001f098 	.word	0x4001f098
    c090:	4001f504 	.word	0x4001f504

0000c094 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q>:
    c094:	4b0d      	ldr	r3, [pc, #52]	; (c0cc <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q+0x38>)
    c096:	b510      	push	{r4, lr}
    c098:	71d8      	strb	r0, [r3, #7]
    c09a:	729a      	strb	r2, [r3, #10]
    c09c:	b151      	cbz	r1, c0b4 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q+0x20>
    c09e:	2002      	movs	r0, #2
    c0a0:	7218      	strb	r0, [r3, #8]
    c0a2:	2801      	cmp	r0, #1
    c0a4:	d008      	beq.n	c0b8 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q+0x24>
    c0a6:	2802      	cmp	r0, #2
    c0a8:	d00f      	beq.n	c0ca <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q+0x36>
    c0aa:	f640 211d 	movw	r1, #2589	; 0xa1d
    c0ae:	203e      	movs	r0, #62	; 0x3e
    c0b0:	f7f9 f850 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c0b4:	2001      	movs	r0, #1
    c0b6:	e7f3      	b.n	c0a0 <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q+0xc>
    c0b8:	7a58      	ldrb	r0, [r3, #9]
    c0ba:	2802      	cmp	r0, #2
    c0bc:	d105      	bne.n	c0ca <sym_MBOR6QO7CTIMBTL5BVPURKFTQFZYFCUOAZ3M43Q+0x36>
    c0be:	f000 f97f 	bl	c3c0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x7c>
    c0c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    c0c6:	f000 baad 	b.w	c624 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2e0>
    c0ca:	bd10      	pop	{r4, pc}
    c0cc:	200016a0 	.word	0x200016a0

0000c0d0 <sym_VEC44ISWPJAJ32J57NYIBEMC7Q6QEP7J6SVR4BQ>:
    c0d0:	4902      	ldr	r1, [pc, #8]	; (c0dc <sym_VEC44ISWPJAJ32J57NYIBEMC7Q6QEP7J6SVR4BQ+0xc>)
    c0d2:	2000      	movs	r0, #0
    c0d4:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
    c0d8:	4770      	bx	lr
    c0da:	0000      	.short	0x0000
    c0dc:	40008000 	.word	0x40008000

0000c0e0 <sym_EZCFQXKGAFHY5HQVJOXWDLO45XWMEJQY5WUGZNI>:
    c0e0:	4904      	ldr	r1, [pc, #16]	; (c0f4 <sym_EZCFQXKGAFHY5HQVJOXWDLO45XWMEJQY5WUGZNI+0x14>)
    c0e2:	f8d1 1548 	ldr.w	r1, [r1, #1352]	; 0x548
    c0e6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    c0ea:	4249      	negs	r1, r1
    c0ec:	7001      	strb	r1, [r0, #0]
    c0ee:	2001      	movs	r0, #1
    c0f0:	4770      	bx	lr
    c0f2:	0000      	.short	0x0000
    c0f4:	40001000 	.word	0x40001000

0000c0f8 <sym_YLRTPBVG5ROXKOW4KXUYITRUY3FD2MVZW5LF7ZA>:
    c0f8:	4903      	ldr	r1, [pc, #12]	; (c108 <sym_YLRTPBVG5ROXKOW4KXUYITRUY3FD2MVZW5LF7ZA+0x10>)
    c0fa:	0e02      	lsrs	r2, r0, #24
    c0fc:	f8c1 2524 	str.w	r2, [r1, #1316]	; 0x524
    c100:	0200      	lsls	r0, r0, #8
    c102:	f8c1 051c 	str.w	r0, [r1, #1308]	; 0x51c
    c106:	4770      	bx	lr
    c108:	40001000 	.word	0x40001000

0000c10c <sym_XD56LJG2JTRU4Q2V7WCY72EI3VTZICA3O4ERV2A>:
    c10c:	6800      	ldr	r0, [r0, #0]
    c10e:	4903      	ldr	r1, [pc, #12]	; (c11c <sym_XD56LJG2JTRU4Q2V7WCY72EI3VTZICA3O4ERV2A+0x10>)
    c110:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    c114:	f8c1 053c 	str.w	r0, [r1, #1340]	; 0x53c
    c118:	4770      	bx	lr
    c11a:	0000      	.short	0x0000
    c11c:	40001000 	.word	0x40001000

0000c120 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ>:
    c120:	b510      	push	{r4, lr}
    c122:	2200      	movs	r2, #0
    c124:	2901      	cmp	r1, #1
    c126:	d006      	beq.n	c136 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x16>
    c128:	2902      	cmp	r1, #2
    c12a:	d002      	beq.n	c132 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x12>
    c12c:	f44f 712f 	mov.w	r1, #700	; 0x2bc
    c130:	e014      	b.n	c15c <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x3c>
    c132:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    c136:	490b      	ldr	r1, [pc, #44]	; (c164 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x44>)
    c138:	430a      	orrs	r2, r1
    c13a:	490b      	ldr	r1, [pc, #44]	; (c168 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x48>)
    c13c:	600a      	str	r2, [r1, #0]
    c13e:	490b      	ldr	r1, [pc, #44]	; (c16c <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x4c>)
    c140:	4308      	orrs	r0, r1
    c142:	4909      	ldr	r1, [pc, #36]	; (c168 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x48>)
    c144:	1d09      	adds	r1, r1, #4
    c146:	6008      	str	r0, [r1, #0]
    c148:	4809      	ldr	r0, [pc, #36]	; (c170 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x50>)
    c14a:	f8d0 0550 	ldr.w	r0, [r0, #1360]	; 0x550
    c14e:	b2c0      	uxtb	r0, r0
    c150:	2803      	cmp	r0, #3
    c152:	d001      	beq.n	c158 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x38>
    c154:	280b      	cmp	r0, #11
    c156:	d104      	bne.n	c162 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ+0x42>
    c158:	f44f 7135 	mov.w	r1, #724	; 0x2d4
    c15c:	203e      	movs	r0, #62	; 0x3e
    c15e:	f7f8 fff9 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c162:	bd10      	pop	{r4, pc}
    c164:	00100108 	.word	0x00100108
    c168:	40001514 	.word	0x40001514
    c16c:	02030000 	.word	0x02030000
    c170:	40001000 	.word	0x40001000

0000c174 <sym_ZQE76VUU7S5U7DETTZA65E75LHFWL5PGRN4JPHI>:
    c174:	4901      	ldr	r1, [pc, #4]	; (c17c <sym_ZQE76VUU7S5U7DETTZA65E75LHFWL5PGRN4JPHI+0x8>)
    c176:	7588      	strb	r0, [r1, #22]
    c178:	4770      	bx	lr
    c17a:	0000      	.short	0x0000
    c17c:	200016a0 	.word	0x200016a0

0000c180 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ>:
    c180:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c184:	4852      	ldr	r0, [pc, #328]	; (c2d0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x150>)
    c186:	f04f 0a01 	mov.w	sl, #1
    c18a:	f8c0 a04c 	str.w	sl, [r0, #76]	; 0x4c
    c18e:	4850      	ldr	r0, [pc, #320]	; (c2d0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x150>)
    c190:	300c      	adds	r0, #12
    c192:	f8d0 7540 	ldr.w	r7, [r0, #1344]	; 0x540
    c196:	f000 fdb3 	bl	cd00 <sym_6TZLBWMEWRMPI4KKAUVLC2XHUBDGXEA4B4JJJYQ>
    c19a:	4c4e      	ldr	r4, [pc, #312]	; (c2d4 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x154>)
    c19c:	e9c4 070c 	strd	r0, r7, [r4, #48]	; 0x30
    c1a0:	f000 f918 	bl	c3d4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x90>
    c1a4:	494c      	ldr	r1, [pc, #304]	; (c2d8 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x158>)
    c1a6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    c1a8:	6008      	str	r0, [r1, #0]
    c1aa:	f8df 9130 	ldr.w	r9, [pc, #304]	; c2dc <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x15c>
    c1ae:	2000      	movs	r0, #0
    c1b0:	62a0      	str	r0, [r4, #40]	; 0x28
    c1b2:	f8d9 2200 	ldr.w	r2, [r9, #512]	; 0x200
    c1b6:	f240 131d 	movw	r3, #285	; 0x11d
    c1ba:	439a      	bics	r2, r3
    c1bc:	f8c9 2200 	str.w	r2, [r9, #512]	; 0x200
    c1c0:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    c1c4:	f000 f986 	bl	c4d4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x190>
    c1c8:	4605      	mov	r5, r0
    c1ca:	4841      	ldr	r0, [pc, #260]	; (c2d0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x150>)
    c1cc:	3008      	adds	r0, #8
    c1ce:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
    c1d2:	4e3f      	ldr	r6, [pc, #252]	; (c2d0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x150>)
    c1d4:	61e0      	str	r0, [r4, #28]
    c1d6:	1d36      	adds	r6, r6, #4
    c1d8:	f8d6 0540 	ldr.w	r0, [r6, #1344]	; 0x540
    c1dc:	61a0      	str	r0, [r4, #24]
    c1de:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
    c1e2:	7d21      	ldrb	r1, [r4, #20]
    c1e4:	f884 1020 	strb.w	r1, [r4, #32]
    c1e8:	7a61      	ldrb	r1, [r4, #9]
    c1ea:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
    c1ee:	46a0      	mov	r8, r4
    c1f0:	2400      	movs	r4, #0
    c1f2:	4639      	mov	r1, r7
    c1f4:	4628      	mov	r0, r5
    c1f6:	f000 f9e1 	bl	c5bc <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x278>
    c1fa:	b910      	cbnz	r0, c202 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x82>
    c1fc:	f8c9 a010 	str.w	sl, [r9, #16]
    c200:	2401      	movs	r4, #1
    c202:	4f34      	ldr	r7, [pc, #208]	; (c2d4 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x154>)
    c204:	07e8      	lsls	r0, r5, #31
    c206:	f1a7 0710 	sub.w	r7, r7, #16
    c20a:	d002      	beq.n	c212 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x92>
    c20c:	6838      	ldr	r0, [r7, #0]
    c20e:	4780      	blx	r0
    c210:	e032      	b.n	c278 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xf8>
    c212:	07a8      	lsls	r0, r5, #30
    c214:	d527      	bpl.n	c266 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xe6>
    c216:	0768      	lsls	r0, r5, #29
    c218:	d41f      	bmi.n	c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c21a:	f000 febb 	bl	cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>
    c21e:	b9e0      	cbnz	r0, c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c220:	f000 fea8 	bl	cf74 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ>
    c224:	b9c8      	cbnz	r0, c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c226:	482e      	ldr	r0, [pc, #184]	; (c2e0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x160>)
    c228:	6800      	ldr	r0, [r0, #0]
    c22a:	f3c0 6c00 	ubfx	ip, r0, #24, #1
    c22e:	f3c0 5142 	ubfx	r1, r0, #21, #3
    c232:	f000 030f 	and.w	r3, r0, #15
    c236:	f3c0 1203 	ubfx	r2, r0, #4, #4
    c23a:	f3c0 2003 	ubfx	r0, r0, #8, #4
    c23e:	f1bc 0f00 	cmp.w	ip, #0
    c242:	d00a      	beq.n	c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c244:	b10b      	cbz	r3, c24a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xca>
    c246:	b102      	cbz	r2, c24a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xca>
    c248:	b938      	cbnz	r0, c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c24a:	4825      	ldr	r0, [pc, #148]	; (c2e0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x160>)
    c24c:	1d00      	adds	r0, r0, #4
    c24e:	6800      	ldr	r0, [r0, #0]
    c250:	b118      	cbz	r0, c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c252:	2903      	cmp	r1, #3
    c254:	d201      	bcs.n	c25a <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xda>
    c256:	f045 0504 	orr.w	r5, r5, #4
    c25a:	f345 0080 	sbfx	r0, r5, #2, #1
    c25e:	4621      	mov	r1, r4
    c260:	1c40      	adds	r0, r0, #1
    c262:	687a      	ldr	r2, [r7, #4]
    c264:	e007      	b.n	c276 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xf6>
    c266:	f015 0f28 	tst.w	r5, #40	; 0x28
    c26a:	d005      	beq.n	c278 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0xf8>
    c26c:	f345 1140 	sbfx	r1, r5, #5, #1
    c270:	68ba      	ldr	r2, [r7, #8]
    c272:	4620      	mov	r0, r4
    c274:	1c49      	adds	r1, r1, #1
    c276:	4790      	blx	r2
    c278:	06e8      	lsls	r0, r5, #27
    c27a:	d501      	bpl.n	c280 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x100>
    c27c:	68f8      	ldr	r0, [r7, #12]
    c27e:	4780      	blx	r0
    c280:	f898 1009 	ldrb.w	r1, [r8, #9]
    c284:	4640      	mov	r0, r8
    c286:	2902      	cmp	r1, #2
    c288:	d120      	bne.n	c2cc <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x14c>
    c28a:	7b01      	ldrb	r1, [r0, #12]
    c28c:	2900      	cmp	r1, #0
    c28e:	d01d      	beq.n	c2cc <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x14c>
    c290:	2902      	cmp	r1, #2
    c292:	d004      	beq.n	c29e <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x11e>
    c294:	2901      	cmp	r1, #1
    c296:	d009      	beq.n	c2ac <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x12c>
    c298:	f640 4114 	movw	r1, #3092	; 0xc14
    c29c:	e00d      	b.n	c2ba <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x13a>
    c29e:	69c1      	ldr	r1, [r0, #28]
    c2a0:	f8d8 0010 	ldr.w	r0, [r8, #16]
    c2a4:	4408      	add	r0, r1
    c2a6:	f8c6 0540 	str.w	r0, [r6, #1344]	; 0x540
    c2aa:	e00b      	b.n	c2c4 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x144>
    c2ac:	6901      	ldr	r1, [r0, #16]
    c2ae:	f8d8 001c 	ldr.w	r0, [r8, #28]
    c2b2:	4281      	cmp	r1, r0
    c2b4:	d804      	bhi.n	c2c0 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ+0x140>
    c2b6:	f640 4115 	movw	r1, #3093	; 0xc15
    c2ba:	203e      	movs	r0, #62	; 0x3e
    c2bc:	f7f8 ff4a 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c2c0:	f8c6 1540 	str.w	r1, [r6, #1344]	; 0x540
    c2c4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c2c8:	f000 b9b6 	b.w	c638 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2f4>
    c2cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c2d0:	40008000 	.word	0x40008000
    c2d4:	200016a0 	.word	0x200016a0
    c2d8:	4001f508 	.word	0x4001f508
    c2dc:	40001000 	.word	0x40001000
    c2e0:	40001450 	.word	0x40001450

0000c2e4 <sym_53FPWJRYQVPJEOZPLNZO6VOSTP72TYV5A36KFIY>:
    c2e4:	b570      	push	{r4, r5, r6, lr}
    c2e6:	4b16      	ldr	r3, [pc, #88]	; (c340 <sym_53FPWJRYQVPJEOZPLNZO6VOSTP72TYV5A36KFIY+0x5c>)
    c2e8:	888c      	ldrh	r4, [r1, #4]
    c2ea:	eb03 0580 	add.w	r5, r3, r0, lsl #2
    c2ee:	f8c5 4620 	str.w	r4, [r5, #1568]	; 0x620
    c2f2:	780c      	ldrb	r4, [r1, #0]
    c2f4:	f8d1 1001 	ldr.w	r1, [r1, #1]
    c2f8:	ea44 2101 	orr.w	r1, r4, r1, lsl #8
    c2fc:	f8c5 1600 	str.w	r1, [r5, #1536]	; 0x600
    c300:	f8d3 1640 	ldr.w	r1, [r3, #1600]	; 0x640
    c304:	2401      	movs	r4, #1
    c306:	4084      	lsls	r4, r0
    c308:	b2c9      	uxtb	r1, r1
    c30a:	b2e5      	uxtb	r5, r4
    c30c:	4329      	orrs	r1, r5
    c30e:	b132      	cbz	r2, c31e <sym_53FPWJRYQVPJEOZPLNZO6VOSTP72TYV5A36KFIY+0x3a>
    c310:	2a01      	cmp	r2, #1
    c312:	d00a      	beq.n	c32a <sym_53FPWJRYQVPJEOZPLNZO6VOSTP72TYV5A36KFIY+0x46>
    c314:	f240 518d 	movw	r1, #1421	; 0x58d
    c318:	203e      	movs	r0, #62	; 0x3e
    c31a:	f7f8 ff1b 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c31e:	f8d3 0640 	ldr.w	r0, [r3, #1600]	; 0x640
    c322:	f3c0 2007 	ubfx	r0, r0, #8, #8
    c326:	43a0      	bics	r0, r4
    c328:	e004      	b.n	c334 <sym_53FPWJRYQVPJEOZPLNZO6VOSTP72TYV5A36KFIY+0x50>
    c32a:	f8d3 0640 	ldr.w	r0, [r3, #1600]	; 0x640
    c32e:	f3c0 2007 	ubfx	r0, r0, #8, #8
    c332:	4328      	orrs	r0, r5
    c334:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
    c338:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
    c33c:	bd70      	pop	{r4, r5, r6, pc}
    c33e:	0000      	.short	0x0000
    c340:	40001000 	.word	0x40001000

0000c344 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY>:
    c344:	4901      	ldr	r1, [pc, #4]	; (c34c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x8>)
    c346:	2001      	movs	r0, #1
    c348:	7008      	strb	r0, [r1, #0]
    c34a:	4770      	bx	lr
    c34c:	200002f0 	.word	0x200002f0
    c350:	480b      	ldr	r0, [pc, #44]	; (c380 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3c>)
    c352:	7d81      	ldrb	r1, [r0, #22]
    c354:	480b      	ldr	r0, [pc, #44]	; (c384 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x40>)
    c356:	5c40      	ldrb	r0, [r0, r1]
    c358:	f500 6016 	add.w	r0, r0, #2400	; 0x960
    c35c:	f5b0 6f16 	cmp.w	r0, #2400	; 0x960
    c360:	d204      	bcs.n	c36c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x28>
    c362:	f6a0 1038 	subw	r0, r0, #2360	; 0x938
    c366:	f440 7080 	orr.w	r0, r0, #256	; 0x100
    c36a:	e001      	b.n	c370 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2c>
    c36c:	f5a0 6016 	sub.w	r0, r0, #2400	; 0x960
    c370:	4a05      	ldr	r2, [pc, #20]	; (c388 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x44>)
    c372:	f8c2 0508 	str.w	r0, [r2, #1288]	; 0x508
    c376:	f001 007f 	and.w	r0, r1, #127	; 0x7f
    c37a:	f8c2 0554 	str.w	r0, [r2, #1364]	; 0x554
    c37e:	4770      	bx	lr
    c380:	200016a0 	.word	0x200016a0
    c384:	0000c7ea 	.word	0x0000c7ea
    c388:	40001000 	.word	0x40001000
    c38c:	b508      	push	{r3, lr}
    c38e:	490b      	ldr	r1, [pc, #44]	; (c3bc <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x78>)
    c390:	466b      	mov	r3, sp
    c392:	f991 2015 	ldrsb.w	r2, [r1, #21]
    c396:	7d89      	ldrb	r1, [r1, #22]
    c398:	f000 faca 	bl	c930 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ>
    c39c:	f99d 0000 	ldrsb.w	r0, [sp]
    c3a0:	f000 fa9a 	bl	c8d8 <sym_L4JTLGMK2AWYAAPRB3O77773SG36X2NTZJ3FAHA>
    c3a4:	f10d 0001 	add.w	r0, sp, #1
    c3a8:	f7f8 fda8 	bl	4efc <mpsl_fem_pa_gain_set>
    c3ac:	2800      	cmp	r0, #0
    c3ae:	d004      	beq.n	c3ba <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x76>
    c3b0:	f240 51ce 	movw	r1, #1486	; 0x5ce
    c3b4:	203e      	movs	r0, #62	; 0x3e
    c3b6:	f7f8 fecd 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c3ba:	bd08      	pop	{r3, pc}
    c3bc:	200016a0 	.word	0x200016a0
    c3c0:	4803      	ldr	r0, [pc, #12]	; (c3d0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x8c>)
    c3c2:	7a01      	ldrb	r1, [r0, #8]
    c3c4:	2901      	cmp	r1, #1
    c3c6:	d102      	bne.n	c3ce <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x8a>
    c3c8:	7a80      	ldrb	r0, [r0, #10]
    c3ca:	f7ff bfdf 	b.w	c38c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x48>
    c3ce:	4770      	bx	lr
    c3d0:	200016a0 	.word	0x200016a0
    c3d4:	480d      	ldr	r0, [pc, #52]	; (c40c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc8>)
    c3d6:	b510      	push	{r4, lr}
    c3d8:	7a40      	ldrb	r0, [r0, #9]
    c3da:	2801      	cmp	r0, #1
    c3dc:	d00c      	beq.n	c3f8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xb4>
    c3de:	2802      	cmp	r0, #2
    c3e0:	d113      	bne.n	c40a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc6>
    c3e2:	f7f8 fd6d 	bl	4ec0 <mpsl_fem_lna_configuration_clear>
    c3e6:	2800      	cmp	r0, #0
    c3e8:	d00f      	beq.n	c40a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc6>
    c3ea:	1c40      	adds	r0, r0, #1
    c3ec:	d00d      	beq.n	c40a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc6>
    c3ee:	f640 017a 	movw	r1, #2170	; 0x87a
    c3f2:	203e      	movs	r0, #62	; 0x3e
    c3f4:	f7f8 feae 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c3f8:	f7f8 fd74 	bl	4ee4 <mpsl_fem_pa_configuration_clear>
    c3fc:	2800      	cmp	r0, #0
    c3fe:	d004      	beq.n	c40a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc6>
    c400:	1c40      	adds	r0, r0, #1
    c402:	d002      	beq.n	c40a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc6>
    c404:	f640 0174 	movw	r1, #2164	; 0x874
    c408:	e7f3      	b.n	c3f2 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xae>
    c40a:	bd10      	pop	{r4, pc}
    c40c:	200016a0 	.word	0x200016a0
    c410:	4808      	ldr	r0, [pc, #32]	; (c434 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xf0>)
    c412:	2100      	movs	r1, #0
    c414:	f8c0 1100 	str.w	r1, [r0, #256]	; 0x100
    c418:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
    c41c:	f8c0 1110 	str.w	r1, [r0, #272]	; 0x110
    c420:	f8c0 1104 	str.w	r1, [r0, #260]	; 0x104
    c424:	f8c0 1114 	str.w	r1, [r0, #276]	; 0x114
    c428:	f8c0 1118 	str.w	r1, [r0, #280]	; 0x118
    c42c:	f8c0 1108 	str.w	r1, [r0, #264]	; 0x108
    c430:	4770      	bx	lr
    c432:	0000      	.short	0x0000
    c434:	40001000 	.word	0x40001000
    c438:	4818      	ldr	r0, [pc, #96]	; (c49c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x158>)
    c43a:	b510      	push	{r4, lr}
    c43c:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
    c440:	07c1      	lsls	r1, r0, #31
    c442:	d029      	beq.n	c498 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x154>
    c444:	0781      	lsls	r1, r0, #30
    c446:	d514      	bpl.n	c472 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x12e>
    c448:	4815      	ldr	r0, [pc, #84]	; (c4a0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x15c>)
    c44a:	f8d0 1200 	ldr.w	r1, [r0, #512]	; 0x200
    c44e:	f041 0101 	orr.w	r1, r1, #1
    c452:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
    c456:	f8d0 0550 	ldr.w	r0, [r0, #1360]	; 0x550
    c45a:	b2c0      	uxtb	r0, r0
    c45c:	280b      	cmp	r0, #11
    c45e:	d005      	beq.n	c46c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x128>
    c460:	280a      	cmp	r0, #10
    c462:	d003      	beq.n	c46c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x128>
    c464:	2803      	cmp	r0, #3
    c466:	d001      	beq.n	c46c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x128>
    c468:	2802      	cmp	r0, #2
    c46a:	d115      	bne.n	c498 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x154>
    c46c:	f240 51f7 	movw	r1, #1527	; 0x5f7
    c470:	e00f      	b.n	c492 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x14e>
    c472:	0740      	lsls	r0, r0, #29
    c474:	d510      	bpl.n	c498 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x154>
    c476:	480a      	ldr	r0, [pc, #40]	; (c4a0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x15c>)
    c478:	490a      	ldr	r1, [pc, #40]	; (c4a4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x160>)
    c47a:	3008      	adds	r0, #8
    c47c:	f8c1 0514 	str.w	r0, [r1, #1300]	; 0x514
    c480:	f44f 71a0 	mov.w	r1, #320	; 0x140
    c484:	4808      	ldr	r0, [pc, #32]	; (c4a8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x164>)
    c486:	f004 fc78 	bl	10d7a <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x5e>
    c48a:	2800      	cmp	r0, #0
    c48c:	d004      	beq.n	c498 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x154>
    c48e:	f240 51ff 	movw	r1, #1535	; 0x5ff
    c492:	203e      	movs	r0, #62	; 0x3e
    c494:	f7f8 fe5e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c498:	bd10      	pop	{r4, pc}
    c49a:	0000      	.short	0x0000
    c49c:	200016a0 	.word	0x200016a0
    c4a0:	40001000 	.word	0x40001000
    c4a4:	4001f098 	.word	0x4001f098
    c4a8:	40008000 	.word	0x40008000
    c4ac:	4808      	ldr	r0, [pc, #32]	; (c4d0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x18c>)
    c4ae:	4601      	mov	r1, r0
    c4b0:	79c2      	ldrb	r2, [r0, #7]
    c4b2:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
    c4b6:	b112      	cbz	r2, c4be <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x17a>
    c4b8:	2a01      	cmp	r2, #1
    c4ba:	d003      	beq.n	c4c4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x180>
    c4bc:	e006      	b.n	c4cc <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x188>
    c4be:	f041 0102 	orr.w	r1, r1, #2
    c4c2:	e001      	b.n	c4c8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x184>
    c4c4:	f041 0104 	orr.w	r1, r1, #4
    c4c8:	f880 102c 	strb.w	r1, [r0, #44]	; 0x2c
    c4cc:	f7ff bfb4 	b.w	c438 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xf4>
    c4d0:	200016a0 	.word	0x200016a0
    c4d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c4d8:	4d34      	ldr	r5, [pc, #208]	; (c5ac <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x268>)
    c4da:	2400      	movs	r4, #0
    c4dc:	7b28      	ldrb	r0, [r5, #12]
    c4de:	b138      	cbz	r0, c4f0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ac>
    c4e0:	f44f 71a2 	mov.w	r1, #324	; 0x144
    c4e4:	4832      	ldr	r0, [pc, #200]	; (c5b0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x26c>)
    c4e6:	f004 fc48 	bl	10d7a <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x5e>
    c4ea:	b108      	cbz	r0, c4f0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ac>
    c4ec:	2601      	movs	r6, #1
    c4ee:	e000      	b.n	c4f2 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ae>
    c4f0:	2600      	movs	r6, #0
    c4f2:	7a68      	ldrb	r0, [r5, #9]
    c4f4:	4f2f      	ldr	r7, [pc, #188]	; (c5b4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x270>)
    c4f6:	f44f 7186 	mov.w	r1, #268	; 0x10c
    c4fa:	2801      	cmp	r0, #1
    c4fc:	d002      	beq.n	c504 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1c0>
    c4fe:	2802      	cmp	r0, #2
    c500:	d006      	beq.n	c510 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1cc>
    c502:	e016      	b.n	c532 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ee>
    c504:	4638      	mov	r0, r7
    c506:	f004 fc33 	bl	10d70 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x54>
    c50a:	b190      	cbz	r0, c532 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ee>
    c50c:	2408      	movs	r4, #8
    c50e:	e010      	b.n	c532 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ee>
    c510:	4638      	mov	r0, r7
    c512:	f004 fc2d 	bl	10d70 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x54>
    c516:	b100      	cbz	r0, c51a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1d6>
    c518:	2402      	movs	r4, #2
    c51a:	f8d7 0400 	ldr.w	r0, [r7, #1024]	; 0x400
    c51e:	43c0      	mvns	r0, r0
    c520:	f340 0000 	sbfx	r0, r0, #0, #1
    c524:	1c40      	adds	r0, r0, #1
    c526:	d101      	bne.n	c52c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1e8>
    c528:	f044 0404 	orr.w	r4, r4, #4
    c52c:	b10e      	cbz	r6, c532 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x1ee>
    c52e:	f044 0401 	orr.w	r4, r4, #1
    c532:	f014 0f0b 	tst.w	r4, #11
    c536:	d107      	bne.n	c548 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x204>
    c538:	f44f 7188 	mov.w	r1, #272	; 0x110
    c53c:	4638      	mov	r0, r7
    c53e:	f004 fc17 	bl	10d70 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x54>
    c542:	b108      	cbz	r0, c548 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x204>
    c544:	f044 0410 	orr.w	r4, r4, #16
    c548:	481b      	ldr	r0, [pc, #108]	; (c5b8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x274>)
    c54a:	7800      	ldrb	r0, [r0, #0]
    c54c:	b1f8      	cbz	r0, c58e <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x24a>
    c54e:	f8d7 0640 	ldr.w	r0, [r7, #1600]	; 0x640
    c552:	f010 06ff 	ands.w	r6, r0, #255	; 0xff
    c556:	d007      	beq.n	c568 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x224>
    c558:	f44f 718a 	mov.w	r1, #276	; 0x114
    c55c:	4638      	mov	r0, r7
    c55e:	f004 fc07 	bl	10d70 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x54>
    c562:	b108      	cbz	r0, c568 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x224>
    c564:	2001      	movs	r0, #1
    c566:	e000      	b.n	c56a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x226>
    c568:	2000      	movs	r0, #0
    c56a:	f885 0022 	strb.w	r0, [r5, #34]	; 0x22
    c56e:	b13e      	cbz	r6, c580 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x23c>
    c570:	f44f 718c 	mov.w	r1, #280	; 0x118
    c574:	4638      	mov	r0, r7
    c576:	f004 fbfb 	bl	10d70 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x54>
    c57a:	b108      	cbz	r0, c580 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x23c>
    c57c:	2001      	movs	r0, #1
    c57e:	e000      	b.n	c582 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x23e>
    c580:	2000      	movs	r0, #0
    c582:	f885 0023 	strb.w	r0, [r5, #35]	; 0x23
    c586:	f8d7 0410 	ldr.w	r0, [r7, #1040]	; 0x410
    c58a:	f885 0024 	strb.w	r0, [r5, #36]	; 0x24
    c58e:	f7ff ff3f 	bl	c410 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xcc>
    c592:	06e0      	lsls	r0, r4, #27
    c594:	d506      	bpl.n	c5a4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x260>
    c596:	0720      	lsls	r0, r4, #28
    c598:	d404      	bmi.n	c5a4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x260>
    c59a:	7a68      	ldrb	r0, [r5, #9]
    c59c:	2801      	cmp	r0, #1
    c59e:	d101      	bne.n	c5a4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x260>
    c5a0:	f044 0420 	orr.w	r4, r4, #32
    c5a4:	4620      	mov	r0, r4
    c5a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c5aa:	0000      	.short	0x0000
    c5ac:	200016a0 	.word	0x200016a0
    c5b0:	40008000 	.word	0x40008000
    c5b4:	40001000 	.word	0x40001000
    c5b8:	200002f0 	.word	0x200002f0
    c5bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c5c0:	4c17      	ldr	r4, [pc, #92]	; (c620 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2dc>)
    c5c2:	460d      	mov	r5, r1
    c5c4:	7a21      	ldrb	r1, [r4, #8]
    c5c6:	b129      	cbz	r1, c5d4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x290>
    c5c8:	f010 0f11 	tst.w	r0, #17
    c5cc:	d007      	beq.n	c5de <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x29a>
    c5ce:	f7ff fa7d 	bl	bacc <sym_A5S3P57NWYYY5XJWBYERU6H4QSVP5TCTU7HKA5Y>
    c5d2:	e023      	b.n	c61c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2d8>
    c5d4:	f000 f88a 	bl	c6ec <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a8>
    c5d8:	2000      	movs	r0, #0
    c5da:	7320      	strb	r0, [r4, #12]
    c5dc:	e01e      	b.n	c61c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2d8>
    c5de:	2901      	cmp	r1, #1
    c5e0:	d001      	beq.n	c5e6 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2a2>
    c5e2:	2601      	movs	r6, #1
    c5e4:	e000      	b.n	c5e8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2a4>
    c5e6:	2600      	movs	r6, #0
    c5e8:	79e0      	ldrb	r0, [r4, #7]
    c5ea:	2801      	cmp	r0, #1
    c5ec:	d00e      	beq.n	c60c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2c8>
    c5ee:	2700      	movs	r7, #0
    c5f0:	f000 f87c 	bl	c6ec <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a8>
    c5f4:	2196      	movs	r1, #150	; 0x96
    c5f6:	4630      	mov	r0, r6
    c5f8:	f000 f88e 	bl	c718 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3d4>
    c5fc:	4601      	mov	r1, r0
    c5fe:	b14f      	cbz	r7, c614 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2d0>
    c600:	353b      	adds	r5, #59	; 0x3b
    c602:	428d      	cmp	r5, r1
    c604:	d904      	bls.n	c610 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2cc>
    c606:	2000      	movs	r0, #0
    c608:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c60c:	2701      	movs	r7, #1
    c60e:	e7ef      	b.n	c5f0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2ac>
    c610:	2001      	movs	r0, #1
    c612:	71e0      	strb	r0, [r4, #7]
    c614:	7aa2      	ldrb	r2, [r4, #10]
    c616:	4630      	mov	r0, r6
    c618:	f7ff fcda 	bl	bfd0 <sym_E7IS652W2J5N5UTHP752WOA4YNSR7E5S5H4J2AA>
    c61c:	2001      	movs	r0, #1
    c61e:	e7f3      	b.n	c608 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2c4>
    c620:	200016a0 	.word	0x200016a0
    c624:	4803      	ldr	r0, [pc, #12]	; (c634 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2f0>)
    c626:	f8d0 1200 	ldr.w	r1, [r0, #512]	; 0x200
    c62a:	f441 7188 	orr.w	r1, r1, #272	; 0x110
    c62e:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
    c632:	4770      	bx	lr
    c634:	40001000 	.word	0x40001000
    c638:	4804      	ldr	r0, [pc, #16]	; (c64c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x308>)
    c63a:	6a81      	ldr	r1, [r0, #40]	; 0x28
    c63c:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
    c640:	6281      	str	r1, [r0, #40]	; 0x28
    c642:	4903      	ldr	r1, [pc, #12]	; (c650 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x30c>)
    c644:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
    c648:	6008      	str	r0, [r1, #0]
    c64a:	4770      	bx	lr
    c64c:	200016a0 	.word	0x200016a0
    c650:	4001f504 	.word	0x4001f504
    c654:	4a07      	ldr	r2, [pc, #28]	; (c674 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x330>)
    c656:	2000      	movs	r0, #0
    c658:	3208      	adds	r2, #8
    c65a:	4906      	ldr	r1, [pc, #24]	; (c674 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x330>)
    c65c:	f8c2 0540 	str.w	r0, [r2, #1344]	; 0x540
    c660:	1d0a      	adds	r2, r1, #4
    c662:	f8c2 0540 	str.w	r0, [r2, #1344]	; 0x540
    c666:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
    c66a:	4902      	ldr	r1, [pc, #8]	; (c674 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x330>)
    c66c:	310c      	adds	r1, #12
    c66e:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
    c672:	4770      	bx	lr
    c674:	40008000 	.word	0x40008000
    c678:	4903      	ldr	r1, [pc, #12]	; (c688 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x344>)
    c67a:	79c9      	ldrb	r1, [r1, #7]
    c67c:	2900      	cmp	r1, #0
    c67e:	d102      	bne.n	c686 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x342>
    c680:	4902      	ldr	r1, [pc, #8]	; (c68c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x348>)
    c682:	f8c1 0514 	str.w	r0, [r1, #1300]	; 0x514
    c686:	4770      	bx	lr
    c688:	200016a0 	.word	0x200016a0
    c68c:	4001f098 	.word	0x4001f098
    c690:	b510      	push	{r4, lr}
    c692:	4a14      	ldr	r2, [pc, #80]	; (c6e4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a0>)
    c694:	b120      	cbz	r0, c6a0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x35c>
    c696:	2801      	cmp	r0, #1
    c698:	d011      	beq.n	c6be <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x37a>
    c69a:	f240 712c 	movw	r1, #1836	; 0x72c
    c69e:	e01c      	b.n	c6da <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x396>
    c6a0:	f101 0028 	add.w	r0, r1, #40	; 0x28
    c6a4:	e9c2 1002 	strd	r1, r0, [r2, #8]
    c6a8:	490f      	ldr	r1, [pc, #60]	; (c6e8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a4>)
    c6aa:	480e      	ldr	r0, [pc, #56]	; (c6e4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a0>)
    c6ac:	f7f8 fc20 	bl	4ef0 <mpsl_fem_pa_configuration_set>
    c6b0:	2800      	cmp	r0, #0
    c6b2:	d015      	beq.n	c6e0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x39c>
    c6b4:	1c40      	adds	r0, r0, #1
    c6b6:	d013      	beq.n	c6e0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x39c>
    c6b8:	f240 711b 	movw	r1, #1819	; 0x71b
    c6bc:	e00d      	b.n	c6da <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x396>
    c6be:	f101 0029 	add.w	r0, r1, #41	; 0x29
    c6c2:	e9c2 1002 	strd	r1, r0, [r2, #8]
    c6c6:	4908      	ldr	r1, [pc, #32]	; (c6e8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a4>)
    c6c8:	4806      	ldr	r0, [pc, #24]	; (c6e4 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3a0>)
    c6ca:	f7f8 fbff 	bl	4ecc <mpsl_fem_lna_configuration_set>
    c6ce:	2800      	cmp	r0, #0
    c6d0:	d006      	beq.n	c6e0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x39c>
    c6d2:	1c40      	adds	r0, r0, #1
    c6d4:	d004      	beq.n	c6e0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x39c>
    c6d6:	f44f 61e5 	mov.w	r1, #1832	; 0x728
    c6da:	203e      	movs	r0, #62	; 0x3e
    c6dc:	f7f8 fd3a 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c6e0:	bd10      	pop	{r4, pc}
    c6e2:	0000      	.short	0x0000
    c6e4:	200002f8 	.word	0x200002f8
    c6e8:	0000c814 	.word	0x0000c814
    c6ec:	4802      	ldr	r0, [pc, #8]	; (c6f8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3b4>)
    c6ee:	2100      	movs	r1, #0
    c6f0:	71c1      	strb	r1, [r0, #7]
    c6f2:	7201      	strb	r1, [r0, #8]
    c6f4:	7241      	strb	r1, [r0, #9]
    c6f6:	4770      	bx	lr
    c6f8:	200016a0 	.word	0x200016a0
    c6fc:	4a05      	ldr	r2, [pc, #20]	; (c714 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3d0>)
    c6fe:	79d2      	ldrb	r2, [r2, #7]
    c700:	2a01      	cmp	r2, #1
    c702:	d006      	beq.n	c712 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3ce>
    c704:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c708:	f501 71fa 	add.w	r1, r1, #500	; 0x1f4
    c70c:	fbb1 f1f2 	udiv	r1, r1, r2
    c710:	1a40      	subs	r0, r0, r1
    c712:	4770      	bx	lr
    c714:	200016a0 	.word	0x200016a0
    c718:	b570      	push	{r4, r5, r6, lr}
    c71a:	4c13      	ldr	r4, [pc, #76]	; (c768 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x424>)
    c71c:	4603      	mov	r3, r0
    c71e:	460d      	mov	r5, r1
    c720:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    c724:	2000      	movs	r0, #0
    c726:	b15a      	cbz	r2, c740 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x3fc>
    c728:	4621      	mov	r1, r4
    c72a:	f891 1020 	ldrb.w	r1, [r1, #32]
    c72e:	b163      	cbz	r3, c74a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x406>
    c730:	2b01      	cmp	r3, #1
    c732:	d111      	bne.n	c758 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x414>
    c734:	2a01      	cmp	r2, #1
    c736:	4628      	mov	r0, r5
    c738:	d012      	beq.n	c760 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x41c>
    c73a:	f004 fb23 	bl	10d84 <sym_2EA2WBXQOKCTPMK7YNDR6QM6MTGHJCDTPZEXNNA>
    c73e:	e009      	b.n	c754 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x410>
    c740:	f640 0127 	movw	r1, #2087	; 0x827
    c744:	203e      	movs	r0, #62	; 0x3e
    c746:	f7f8 fd05 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c74a:	2a01      	cmp	r2, #1
    c74c:	4628      	mov	r0, r5
    c74e:	d004      	beq.n	c75a <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x416>
    c750:	f004 fb26 	bl	10da0 <sym_KM5SKFVNZKDXUQ7BDD3RZ5UCA5E3ZDVNWYJVR3Y>
    c754:	69e1      	ldr	r1, [r4, #28]
    c756:	4408      	add	r0, r1
    c758:	bd70      	pop	{r4, r5, r6, pc}
    c75a:	f000 f8d1 	bl	c900 <sym_WGW6HZ6PNLYQSUJALICWZO27AY5UJWYCU6B6ACI>
    c75e:	e7f9      	b.n	c754 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x410>
    c760:	f000 f8c0 	bl	c8e4 <sym_WD6EQ3FQVKOAARDWHQJJC5SVKHQS7A2MF5YDCPA>
    c764:	e7f6      	b.n	c754 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x410>
    c766:	0000      	.short	0x0000
    c768:	200016a0 	.word	0x200016a0
    c76c:	b510      	push	{r4, lr}
    c76e:	f7ff fc03 	bl	bf78 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ>
    c772:	f7ff fded 	bl	c350 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc>
    c776:	f7ff fe23 	bl	c3c0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x7c>
    c77a:	f7ff ff53 	bl	c624 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x2e0>
    c77e:	f000 fc09 	bl	cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>
    c782:	2800      	cmp	r0, #0
    c784:	d108      	bne.n	c798 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x454>
    c786:	f000 fbf5 	bl	cf74 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ>
    c78a:	2800      	cmp	r0, #0
    c78c:	d104      	bne.n	c798 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x454>
    c78e:	4803      	ldr	r0, [pc, #12]	; (c79c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x458>)
    c790:	6801      	ldr	r1, [r0, #0]
    c792:	f441 21c0 	orr.w	r1, r1, #393216	; 0x60000
    c796:	6001      	str	r1, [r0, #0]
    c798:	bd10      	pop	{r4, pc}
    c79a:	0000      	.short	0x0000
    c79c:	40001568 	.word	0x40001568
    c7a0:	b510      	push	{r4, lr}
    c7a2:	4604      	mov	r4, r0
    c7a4:	f7ff fbe8 	bl	bf78 <sym_PHVPWYOPAKZKJKURGZ7GXJVYEVEK2ONKU5LBGEQ>
    c7a8:	f7ff fdd2 	bl	c350 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0xc>
    c7ac:	4620      	mov	r0, r4
    c7ae:	f7ff fded 	bl	c38c <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x48>
    c7b2:	f000 fbef 	bl	cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>
    c7b6:	2800      	cmp	r0, #0
    c7b8:	d00d      	beq.n	c7d6 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x492>
    c7ba:	4a09      	ldr	r2, [pc, #36]	; (c7e0 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x49c>)
    c7bc:	6811      	ldr	r1, [r2, #0]
    c7be:	0650      	lsls	r0, r2, #25
    c7c0:	2c02      	cmp	r4, #2
    c7c2:	f8d0 0320 	ldr.w	r0, [r0, #800]	; 0x320
    c7c6:	d007      	beq.n	c7d8 <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x494>
    c7c8:	f3c0 2006 	ubfx	r0, r0, #8, #7
    c7cc:	f421 41fe 	bic.w	r1, r1, #32512	; 0x7f00
    c7d0:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
    c7d4:	6010      	str	r0, [r2, #0]
    c7d6:	bd10      	pop	{r4, pc}
    c7d8:	f3c0 6006 	ubfx	r0, r0, #24, #7
    c7dc:	e7f6      	b.n	c7cc <sym_G3LKQQIKLUPALYXV2H43IC7H4PYU6B6QFLQBXZY+0x488>
    c7de:	0000      	.short	0x0000
    c7e0:	40001588 	.word	0x40001588
    c7e4:	a62c0000 	.word	0xa62c0000
    c7e8:	0604a1e0 	.word	0x0604a1e0
    c7ec:	0e0c0a08 	.word	0x0e0c0a08
    c7f0:	16141210 	.word	0x16141210
    c7f4:	201e1c18 	.word	0x201e1c18
    c7f8:	28262422 	.word	0x28262422
    c7fc:	302e2c2a 	.word	0x302e2c2a
    c800:	38363432 	.word	0x38363432
    c804:	403e3c3a 	.word	0x403e3c3a
    c808:	48464442 	.word	0x48464442
    c80c:	024e4c4a 	.word	0x024e4c4a
    c810:	0000501a 	.word	0x0000501a
    c814:	00000001 	.word	0x00000001
    c818:	40001110 	.word	0x40001110
	...
    c830:	00001e14 	.word	0x00001e14
    c834:	00001130 	.word	0x00001130
    c838:	00000000 	.word	0x00000000
    c83c:	00000028 	.word	0x00000028
    c840:	00000018 	.word	0x00000018
    c844:	00000000 	.word	0x00000000
    c848:	00001e14 	.word	0x00001e14
    c84c:	00001130 	.word	0x00001130
    c850:	00000000 	.word	0x00000000
    c854:	00001770 	.word	0x00001770
    c858:	00000fa0 	.word	0x00000fa0

0000c85c <sym_55XNA7W2CQFJPCH62ZAKHLPISYHJ7KMNREEN6EA>:
    c85c:	b570      	push	{r4, r5, r6, lr}
    c85e:	4605      	mov	r5, r0
    c860:	4614      	mov	r4, r2
    c862:	4608      	mov	r0, r1
    c864:	f7ff fbae 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    c868:	eb05 0145 	add.w	r1, r5, r5, lsl #1
    c86c:	ebc1 11c5 	rsb	r1, r1, r5, lsl #7
    c870:	ebc0 01c1 	rsb	r1, r0, r1, lsl #3
    c874:	4807      	ldr	r0, [pc, #28]	; (c894 <sym_55XNA7W2CQFJPCH62ZAKHLPISYHJ7KMNREEN6EA+0x38>)
    c876:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
    c87a:	4408      	add	r0, r1
    c87c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    c880:	f600 30b7 	addw	r0, r0, #2999	; 0xbb7
    c884:	fbb0 f5f1 	udiv	r5, r0, r1
    c888:	4620      	mov	r0, r4
    c88a:	f7ff fb6f 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    c88e:	4428      	add	r0, r5
    c890:	1d40      	adds	r0, r0, #5
    c892:	bd70      	pop	{r4, r5, r6, pc}
    c894:	0000c924 	.word	0x0000c924

0000c898 <sym_7VLVVPDI26BVJ64XQBSGXOQYGQA4VH5APIPDGYA>:
    c898:	b570      	push	{r4, r5, r6, lr}
    c89a:	4d0e      	ldr	r5, [pc, #56]	; (c8d4 <sym_7VLVVPDI26BVJ64XQBSGXOQYGQA4VH5APIPDGYA+0x3c>)
    c89c:	461c      	mov	r4, r3
    c89e:	3d08      	subs	r5, #8
    c8a0:	4b0c      	ldr	r3, [pc, #48]	; (c8d4 <sym_7VLVVPDI26BVJ64XQBSGXOQYGQA4VH5APIPDGYA+0x3c>)
    c8a2:	f835 1011 	ldrh.w	r1, [r5, r1, lsl #1]
    c8a6:	eb00 0540 	add.w	r5, r0, r0, lsl #1
    c8aa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    c8ae:	ebc5 10c0 	rsb	r0, r5, r0, lsl #7
    c8b2:	eb01 00c0 	add.w	r0, r1, r0, lsl #3
    c8b6:	f603 33b7 	addw	r3, r3, #2999	; 0xbb7
    c8ba:	4418      	add	r0, r3
    c8bc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    c8c0:	fbb0 f5f1 	udiv	r5, r0, r1
    c8c4:	4610      	mov	r0, r2
    c8c6:	f7ff fb51 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    c8ca:	4428      	add	r0, r5
    c8cc:	4420      	add	r0, r4
    c8ce:	1d40      	adds	r0, r0, #5
    c8d0:	bd70      	pop	{r4, r5, r6, pc}
    c8d2:	0000      	.short	0x0000
    c8d4:	0000c924 	.word	0x0000c924

0000c8d8 <sym_L4JTLGMK2AWYAAPRB3O77773SG36X2NTZJ3FAHA>:
    c8d8:	4901      	ldr	r1, [pc, #4]	; (c8e0 <sym_L4JTLGMK2AWYAAPRB3O77773SG36X2NTZJ3FAHA+0x8>)
    c8da:	b2c0      	uxtb	r0, r0
    c8dc:	6008      	str	r0, [r1, #0]
    c8de:	4770      	bx	lr
    c8e0:	4000150c 	.word	0x4000150c

0000c8e4 <sym_WD6EQ3FQVKOAARDWHQJJC5SVKHQS7A2MF5YDCPA>:
    c8e4:	4a05      	ldr	r2, [pc, #20]	; (c8fc <sym_WD6EQ3FQVKOAARDWHQJJC5SVKHQS7A2MF5YDCPA+0x18>)
    c8e6:	f832 1011 	ldrh.w	r1, [r2, r1, lsl #1]
    c8ea:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c8ee:	f201 31e7 	addw	r1, r1, #999	; 0x3e7
    c8f2:	fbb1 f1f2 	udiv	r1, r1, r2
    c8f6:	4408      	add	r0, r1
    c8f8:	1e80      	subs	r0, r0, #2
    c8fa:	4770      	bx	lr
    c8fc:	0000c91c 	.word	0x0000c91c

0000c900 <sym_WGW6HZ6PNLYQSUJALICWZO27AY5UJWYCU6B6ACI>:
    c900:	4a05      	ldr	r2, [pc, #20]	; (c918 <sym_WGW6HZ6PNLYQSUJALICWZO27AY5UJWYCU6B6ACI+0x18>)
    c902:	f832 1011 	ldrh.w	r1, [r2, r1, lsl #1]
    c906:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c90a:	f501 717a 	add.w	r1, r1, #1000	; 0x3e8
    c90e:	fbb1 f1f2 	udiv	r1, r1, r2
    c912:	4408      	add	r0, r1
    c914:	4770      	bx	lr
    c916:	0000      	.short	0x0000
    c918:	0000c91c 	.word	0x0000c91c
    c91c:	05dc0000 	.word	0x05dc0000
    c920:	000003e8 	.word	0x000003e8
    c924:	00000000 	.word	0x00000000
    c928:	00001e14 	.word	0x00001e14
    c92c:	00001130 	.word	0x00001130

0000c930 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ>:
    c930:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c934:	461e      	mov	r6, r3
    c936:	4617      	mov	r7, r2
    c938:	460c      	mov	r4, r1
    c93a:	4605      	mov	r5, r0
    c93c:	f7f4 fdf4 	bl	1528 <sym_3NUECOSAIC227DBCPHAP4U7EQ3UBTGANU5ASIOA>
    c940:	f8df 90a4 	ldr.w	r9, [pc, #164]	; c9e8 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0xb8>
    c944:	4680      	mov	r8, r0
    c946:	f899 0000 	ldrb.w	r0, [r9]
    c94a:	42a8      	cmp	r0, r5
    c94c:	d110      	bne.n	c970 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x40>
    c94e:	f899 1001 	ldrb.w	r1, [r9, #1]
    c952:	4648      	mov	r0, r9
    c954:	42a1      	cmp	r1, r4
    c956:	d10b      	bne.n	c970 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x40>
    c958:	f990 1002 	ldrsb.w	r1, [r0, #2]
    c95c:	42b9      	cmp	r1, r7
    c95e:	d107      	bne.n	c970 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x40>
    c960:	78c2      	ldrb	r2, [r0, #3]
    c962:	4542      	cmp	r2, r8
    c964:	d104      	bne.n	c970 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x40>
    c966:	8881      	ldrh	r1, [r0, #4]
    c968:	8031      	strh	r1, [r6, #0]
    c96a:	7980      	ldrb	r0, [r0, #6]
    c96c:	70b0      	strb	r0, [r6, #2]
    c96e:	e036      	b.n	c9de <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0xae>
    c970:	463a      	mov	r2, r7
    c972:	4621      	mov	r1, r4
    c974:	2d01      	cmp	r5, #1
    c976:	d009      	beq.n	c98c <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x5c>
    c978:	2d02      	cmp	r5, #2
    c97a:	d009      	beq.n	c990 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x60>
    c97c:	2d04      	cmp	r5, #4
    c97e:	d009      	beq.n	c994 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x64>
    c980:	2d08      	cmp	r5, #8
    c982:	d009      	beq.n	c998 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x68>
    c984:	f240 4133 	movw	r1, #1075	; 0x433
    c988:	2006      	movs	r0, #6
    c98a:	e00c      	b.n	c9a6 <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x76>
    c98c:	2000      	movs	r0, #0
    c98e:	e004      	b.n	c99a <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x6a>
    c990:	2001      	movs	r0, #1
    c992:	e002      	b.n	c99a <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x6a>
    c994:	2003      	movs	r0, #3
    c996:	e000      	b.n	c99a <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x6a>
    c998:	2002      	movs	r0, #2
    c99a:	466b      	mov	r3, sp
    c99c:	f7f4 fe0a 	bl	15b4 <sym_QLJBNB55XHXGY3EZ4W3ZZ3U6AVPE2YGDOXRUZSQ>
    c9a0:	b118      	cbz	r0, c9aa <sym_472GCM45ITLH5GOXITRUEUJXOU6SPVHTMEVFHWQ+0x7a>
    c9a2:	213d      	movs	r1, #61	; 0x3d
    c9a4:	2075      	movs	r0, #117	; 0x75
    c9a6:	f7f8 fbd5 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    c9aa:	4620      	mov	r0, r4
    c9ac:	f7ff f886 	bl	babc <sym_DRIMECVE2FH7O6C2LQ25QRVJOICPHLA5GC6TM2I>
    c9b0:	4602      	mov	r2, r0
    c9b2:	4631      	mov	r1, r6
    c9b4:	f99d 0000 	ldrsb.w	r0, [sp]
    c9b8:	f7f8 faac 	bl	4f14 <mpsl_fem_tx_power_split>
    c9bc:	4601      	mov	r1, r0
    c9be:	f889 1007 	strb.w	r1, [r9, #7]
    c9c2:	8831      	ldrh	r1, [r6, #0]
    c9c4:	f8a9 1004 	strh.w	r1, [r9, #4]
    c9c8:	78b1      	ldrb	r1, [r6, #2]
    c9ca:	f889 1006 	strb.w	r1, [r9, #6]
    c9ce:	f889 5000 	strb.w	r5, [r9]
    c9d2:	f889 4001 	strb.w	r4, [r9, #1]
    c9d6:	f889 7002 	strb.w	r7, [r9, #2]
    c9da:	f889 8003 	strb.w	r8, [r9, #3]
    c9de:	f999 0007 	ldrsb.w	r0, [r9, #7]
    c9e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    c9e6:	0000      	.short	0x0000
    c9e8:	20000341 	.word	0x20000341

0000c9ec <__udivmoddi4>:
    c9ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c9f0:	9e09      	ldr	r6, [sp, #36]	; 0x24
    c9f2:	4688      	mov	r8, r1
    c9f4:	468e      	mov	lr, r1
    c9f6:	4615      	mov	r5, r2
    c9f8:	4604      	mov	r4, r0
    c9fa:	4619      	mov	r1, r3
    c9fc:	2b00      	cmp	r3, #0
    c9fe:	f040 80c7 	bne.w	cb90 <__udivmoddi4+0x1a4>
    ca02:	4542      	cmp	r2, r8
    ca04:	fab2 f782 	clz	r7, r2
    ca08:	d946      	bls.n	ca98 <__udivmoddi4+0xac>
    ca0a:	b14f      	cbz	r7, ca20 <__udivmoddi4+0x34>
    ca0c:	f1c7 0c20 	rsb	ip, r7, #32
    ca10:	fa08 f307 	lsl.w	r3, r8, r7
    ca14:	fa20 fc0c 	lsr.w	ip, r0, ip
    ca18:	40bd      	lsls	r5, r7
    ca1a:	ea4c 0e03 	orr.w	lr, ip, r3
    ca1e:	40bc      	lsls	r4, r7
    ca20:	ea4f 4815 	mov.w	r8, r5, lsr #16
    ca24:	fa1f fc85 	uxth.w	ip, r5
    ca28:	fbbe f9f8 	udiv	r9, lr, r8
    ca2c:	0c22      	lsrs	r2, r4, #16
    ca2e:	fb08 e319 	mls	r3, r8, r9, lr
    ca32:	fb09 fa0c 	mul.w	sl, r9, ip
    ca36:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
    ca3a:	459a      	cmp	sl, r3
    ca3c:	d928      	bls.n	ca90 <__udivmoddi4+0xa4>
    ca3e:	18eb      	adds	r3, r5, r3
    ca40:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    ca44:	d204      	bcs.n	ca50 <__udivmoddi4+0x64>
    ca46:	459a      	cmp	sl, r3
    ca48:	d902      	bls.n	ca50 <__udivmoddi4+0x64>
    ca4a:	f1a9 0002 	sub.w	r0, r9, #2
    ca4e:	442b      	add	r3, r5
    ca50:	eba3 030a 	sub.w	r3, r3, sl
    ca54:	b2a4      	uxth	r4, r4
    ca56:	fbb3 f2f8 	udiv	r2, r3, r8
    ca5a:	fb08 3312 	mls	r3, r8, r2, r3
    ca5e:	fb02 fc0c 	mul.w	ip, r2, ip
    ca62:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    ca66:	45a4      	cmp	ip, r4
    ca68:	d914      	bls.n	ca94 <__udivmoddi4+0xa8>
    ca6a:	192c      	adds	r4, r5, r4
    ca6c:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    ca70:	d203      	bcs.n	ca7a <__udivmoddi4+0x8e>
    ca72:	45a4      	cmp	ip, r4
    ca74:	d901      	bls.n	ca7a <__udivmoddi4+0x8e>
    ca76:	1e93      	subs	r3, r2, #2
    ca78:	442c      	add	r4, r5
    ca7a:	eba4 040c 	sub.w	r4, r4, ip
    ca7e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    ca82:	b11e      	cbz	r6, ca8c <__udivmoddi4+0xa0>
    ca84:	40fc      	lsrs	r4, r7
    ca86:	2300      	movs	r3, #0
    ca88:	6034      	str	r4, [r6, #0]
    ca8a:	6073      	str	r3, [r6, #4]
    ca8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ca90:	4648      	mov	r0, r9
    ca92:	e7dd      	b.n	ca50 <__udivmoddi4+0x64>
    ca94:	4613      	mov	r3, r2
    ca96:	e7f0      	b.n	ca7a <__udivmoddi4+0x8e>
    ca98:	b902      	cbnz	r2, ca9c <__udivmoddi4+0xb0>
    ca9a:	deff      	udf	#255	; 0xff
    ca9c:	bb8f      	cbnz	r7, cb02 <__udivmoddi4+0x116>
    ca9e:	eba8 0302 	sub.w	r3, r8, r2
    caa2:	2101      	movs	r1, #1
    caa4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    caa8:	b2aa      	uxth	r2, r5
    caaa:	fbb3 fcfe 	udiv	ip, r3, lr
    caae:	0c20      	lsrs	r0, r4, #16
    cab0:	fb0e 331c 	mls	r3, lr, ip, r3
    cab4:	fb0c f802 	mul.w	r8, ip, r2
    cab8:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
    cabc:	4598      	cmp	r8, r3
    cabe:	d963      	bls.n	cb88 <__udivmoddi4+0x19c>
    cac0:	18eb      	adds	r3, r5, r3
    cac2:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
    cac6:	d204      	bcs.n	cad2 <__udivmoddi4+0xe6>
    cac8:	4598      	cmp	r8, r3
    caca:	d902      	bls.n	cad2 <__udivmoddi4+0xe6>
    cacc:	f1ac 0002 	sub.w	r0, ip, #2
    cad0:	442b      	add	r3, r5
    cad2:	eba3 0308 	sub.w	r3, r3, r8
    cad6:	b2a4      	uxth	r4, r4
    cad8:	fbb3 fcfe 	udiv	ip, r3, lr
    cadc:	fb0e 331c 	mls	r3, lr, ip, r3
    cae0:	fb0c f202 	mul.w	r2, ip, r2
    cae4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    cae8:	42a2      	cmp	r2, r4
    caea:	d94f      	bls.n	cb8c <__udivmoddi4+0x1a0>
    caec:	192c      	adds	r4, r5, r4
    caee:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
    caf2:	d204      	bcs.n	cafe <__udivmoddi4+0x112>
    caf4:	42a2      	cmp	r2, r4
    caf6:	d902      	bls.n	cafe <__udivmoddi4+0x112>
    caf8:	f1ac 0302 	sub.w	r3, ip, #2
    cafc:	442c      	add	r4, r5
    cafe:	1aa4      	subs	r4, r4, r2
    cb00:	e7bd      	b.n	ca7e <__udivmoddi4+0x92>
    cb02:	f1c7 0c20 	rsb	ip, r7, #32
    cb06:	fa28 f90c 	lsr.w	r9, r8, ip
    cb0a:	fa08 f307 	lsl.w	r3, r8, r7
    cb0e:	fa20 fc0c 	lsr.w	ip, r0, ip
    cb12:	40bd      	lsls	r5, r7
    cb14:	ea4c 0203 	orr.w	r2, ip, r3
    cb18:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    cb1c:	b2ab      	uxth	r3, r5
    cb1e:	fbb9 fcfe 	udiv	ip, r9, lr
    cb22:	0c11      	lsrs	r1, r2, #16
    cb24:	fb0e 901c 	mls	r0, lr, ip, r9
    cb28:	fb0c f803 	mul.w	r8, ip, r3
    cb2c:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
    cb30:	4580      	cmp	r8, r0
    cb32:	fa04 f407 	lsl.w	r4, r4, r7
    cb36:	d923      	bls.n	cb80 <__udivmoddi4+0x194>
    cb38:	1828      	adds	r0, r5, r0
    cb3a:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
    cb3e:	d204      	bcs.n	cb4a <__udivmoddi4+0x15e>
    cb40:	4580      	cmp	r8, r0
    cb42:	d902      	bls.n	cb4a <__udivmoddi4+0x15e>
    cb44:	f1ac 0102 	sub.w	r1, ip, #2
    cb48:	4428      	add	r0, r5
    cb4a:	eba0 0008 	sub.w	r0, r0, r8
    cb4e:	b292      	uxth	r2, r2
    cb50:	fbb0 fcfe 	udiv	ip, r0, lr
    cb54:	fb0e 001c 	mls	r0, lr, ip, r0
    cb58:	fb0c f803 	mul.w	r8, ip, r3
    cb5c:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
    cb60:	4598      	cmp	r8, r3
    cb62:	d90f      	bls.n	cb84 <__udivmoddi4+0x198>
    cb64:	18eb      	adds	r3, r5, r3
    cb66:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
    cb6a:	d204      	bcs.n	cb76 <__udivmoddi4+0x18a>
    cb6c:	4598      	cmp	r8, r3
    cb6e:	d902      	bls.n	cb76 <__udivmoddi4+0x18a>
    cb70:	f1ac 0202 	sub.w	r2, ip, #2
    cb74:	442b      	add	r3, r5
    cb76:	eba3 0308 	sub.w	r3, r3, r8
    cb7a:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
    cb7e:	e791      	b.n	caa4 <__udivmoddi4+0xb8>
    cb80:	4661      	mov	r1, ip
    cb82:	e7e2      	b.n	cb4a <__udivmoddi4+0x15e>
    cb84:	4662      	mov	r2, ip
    cb86:	e7f6      	b.n	cb76 <__udivmoddi4+0x18a>
    cb88:	4660      	mov	r0, ip
    cb8a:	e7a2      	b.n	cad2 <__udivmoddi4+0xe6>
    cb8c:	4663      	mov	r3, ip
    cb8e:	e7b6      	b.n	cafe <__udivmoddi4+0x112>
    cb90:	4543      	cmp	r3, r8
    cb92:	d905      	bls.n	cba0 <__udivmoddi4+0x1b4>
    cb94:	b10e      	cbz	r6, cb9a <__udivmoddi4+0x1ae>
    cb96:	e9c6 0800 	strd	r0, r8, [r6]
    cb9a:	2100      	movs	r1, #0
    cb9c:	4608      	mov	r0, r1
    cb9e:	e775      	b.n	ca8c <__udivmoddi4+0xa0>
    cba0:	fab3 fc83 	clz	ip, r3
    cba4:	f1bc 0f00 	cmp.w	ip, #0
    cba8:	d110      	bne.n	cbcc <__udivmoddi4+0x1e0>
    cbaa:	4543      	cmp	r3, r8
    cbac:	d301      	bcc.n	cbb2 <__udivmoddi4+0x1c6>
    cbae:	4282      	cmp	r2, r0
    cbb0:	d80a      	bhi.n	cbc8 <__udivmoddi4+0x1dc>
    cbb2:	1a84      	subs	r4, r0, r2
    cbb4:	eb68 0303 	sbc.w	r3, r8, r3
    cbb8:	2001      	movs	r0, #1
    cbba:	469e      	mov	lr, r3
    cbbc:	2e00      	cmp	r6, #0
    cbbe:	d068      	beq.n	cc92 <__udivmoddi4+0x2a6>
    cbc0:	e9c6 4e00 	strd	r4, lr, [r6]
    cbc4:	2100      	movs	r1, #0
    cbc6:	e761      	b.n	ca8c <__udivmoddi4+0xa0>
    cbc8:	4660      	mov	r0, ip
    cbca:	e7f7      	b.n	cbbc <__udivmoddi4+0x1d0>
    cbcc:	f1cc 0e20 	rsb	lr, ip, #32
    cbd0:	fa03 f30c 	lsl.w	r3, r3, ip
    cbd4:	fa22 f40e 	lsr.w	r4, r2, lr
    cbd8:	431c      	orrs	r4, r3
    cbda:	fa20 f10e 	lsr.w	r1, r0, lr
    cbde:	fa08 f30c 	lsl.w	r3, r8, ip
    cbe2:	fa28 fb0e 	lsr.w	fp, r8, lr
    cbe6:	4319      	orrs	r1, r3
    cbe8:	ea4f 4914 	mov.w	r9, r4, lsr #16
    cbec:	fa02 f50c 	lsl.w	r5, r2, ip
    cbf0:	fbbb f8f9 	udiv	r8, fp, r9
    cbf4:	b2a3      	uxth	r3, r4
    cbf6:	fb09 bb18 	mls	fp, r9, r8, fp
    cbfa:	0c0a      	lsrs	r2, r1, #16
    cbfc:	fb08 fa03 	mul.w	sl, r8, r3
    cc00:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
    cc04:	4592      	cmp	sl, r2
    cc06:	fa00 f70c 	lsl.w	r7, r0, ip
    cc0a:	d93e      	bls.n	cc8a <__udivmoddi4+0x29e>
    cc0c:	18a2      	adds	r2, r4, r2
    cc0e:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    cc12:	d204      	bcs.n	cc1e <__udivmoddi4+0x232>
    cc14:	4592      	cmp	sl, r2
    cc16:	d902      	bls.n	cc1e <__udivmoddi4+0x232>
    cc18:	f1a8 0002 	sub.w	r0, r8, #2
    cc1c:	4422      	add	r2, r4
    cc1e:	eba2 020a 	sub.w	r2, r2, sl
    cc22:	b289      	uxth	r1, r1
    cc24:	fbb2 f8f9 	udiv	r8, r2, r9
    cc28:	fb09 2218 	mls	r2, r9, r8, r2
    cc2c:	fb08 f303 	mul.w	r3, r8, r3
    cc30:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
    cc34:	4293      	cmp	r3, r2
    cc36:	d92a      	bls.n	cc8e <__udivmoddi4+0x2a2>
    cc38:	18a2      	adds	r2, r4, r2
    cc3a:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
    cc3e:	d204      	bcs.n	cc4a <__udivmoddi4+0x25e>
    cc40:	4293      	cmp	r3, r2
    cc42:	d902      	bls.n	cc4a <__udivmoddi4+0x25e>
    cc44:	f1a8 0102 	sub.w	r1, r8, #2
    cc48:	4422      	add	r2, r4
    cc4a:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
    cc4e:	fba0 9805 	umull	r9, r8, r0, r5
    cc52:	1ad2      	subs	r2, r2, r3
    cc54:	4542      	cmp	r2, r8
    cc56:	464b      	mov	r3, r9
    cc58:	4641      	mov	r1, r8
    cc5a:	d302      	bcc.n	cc62 <__udivmoddi4+0x276>
    cc5c:	d106      	bne.n	cc6c <__udivmoddi4+0x280>
    cc5e:	454f      	cmp	r7, r9
    cc60:	d204      	bcs.n	cc6c <__udivmoddi4+0x280>
    cc62:	ebb9 0305 	subs.w	r3, r9, r5
    cc66:	eb68 0104 	sbc.w	r1, r8, r4
    cc6a:	3801      	subs	r0, #1
    cc6c:	b18e      	cbz	r6, cc92 <__udivmoddi4+0x2a6>
    cc6e:	1afc      	subs	r4, r7, r3
    cc70:	eb62 0701 	sbc.w	r7, r2, r1
    cc74:	fa07 fe0e 	lsl.w	lr, r7, lr
    cc78:	fa24 f30c 	lsr.w	r3, r4, ip
    cc7c:	ea4e 0303 	orr.w	r3, lr, r3
    cc80:	fa27 f70c 	lsr.w	r7, r7, ip
    cc84:	e9c6 3700 	strd	r3, r7, [r6]
    cc88:	e79c      	b.n	cbc4 <__udivmoddi4+0x1d8>
    cc8a:	4640      	mov	r0, r8
    cc8c:	e7c7      	b.n	cc1e <__udivmoddi4+0x232>
    cc8e:	4641      	mov	r1, r8
    cc90:	e7db      	b.n	cc4a <__udivmoddi4+0x25e>
    cc92:	4631      	mov	r1, r6
    cc94:	e6fa      	b.n	ca8c <__udivmoddi4+0xa0>

0000cc96 <strcmp>:
    cc96:	f810 2b01 	ldrb.w	r2, [r0], #1
    cc9a:	f811 3b01 	ldrb.w	r3, [r1], #1
    cc9e:	2a01      	cmp	r2, #1
    cca0:	bf28      	it	cs
    cca2:	429a      	cmpcs	r2, r3
    cca4:	d0f7      	beq.n	cc96 <strcmp>
    cca6:	1ad0      	subs	r0, r2, r3
    cca8:	4770      	bx	lr

0000ccaa <strlen>:
    ccaa:	4603      	mov	r3, r0
    ccac:	f813 2b01 	ldrb.w	r2, [r3], #1
    ccb0:	2a00      	cmp	r2, #0
    ccb2:	d1fb      	bne.n	ccac <strlen+0x2>
    ccb4:	1a18      	subs	r0, r3, r0
    ccb6:	3801      	subs	r0, #1
    ccb8:	4770      	bx	lr
    ccba:	2804      	cmp	r0, #4
    ccbc:	d202      	bcs.n	ccc4 <strlen+0x1a>
    ccbe:	f04f 0028 	mov.w	r0, #40	; 0x28
    ccc2:	4770      	bx	lr
    ccc4:	d102      	bne.n	cccc <strlen+0x22>
    ccc6:	f04f 0010 	mov.w	r0, #16
    ccca:	4770      	bx	lr
    cccc:	f04f 0000 	mov.w	r0, #0
    ccd0:	4770      	bx	lr
    ccd2:	2100      	movs	r1, #0
    ccd4:	f880 1026 	strb.w	r1, [r0, #38]	; 0x26
    ccd8:	f800 1f24 	strb.w	r1, [r0, #36]!
    ccdc:	7041      	strb	r1, [r0, #1]
    ccde:	4770      	bx	lr

0000cce0 <sym_47MBMNER75N2M6YIZRIF4DAHSAATJOMK3LAIDCY>:
    cce0:	b570      	push	{r4, r5, r6, lr}
    cce2:	f7f4 fc87 	bl	15f4 <sym_SKFSQME5SGNPYLL7B75KY7PHXFYWSRI2HSTT45A>
    cce6:	4605      	mov	r5, r0
    cce8:	2400      	movs	r4, #0
    ccea:	e006      	b.n	ccfa <sym_47MBMNER75N2M6YIZRIF4DAHSAATJOMK3LAIDCY+0x1a>
    ccec:	4620      	mov	r0, r4
    ccee:	f7f4 fc87 	bl	1600 <sym_4RNEPYYQOFM4LAOGLN2TB27X7L3XBISTGAWYOHQ>
    ccf2:	f7ff ffee 	bl	ccd2 <strlen+0x28>
    ccf6:	1c64      	adds	r4, r4, #1
    ccf8:	b2e4      	uxtb	r4, r4
    ccfa:	42ac      	cmp	r4, r5
    ccfc:	d3f6      	bcc.n	ccec <sym_47MBMNER75N2M6YIZRIF4DAHSAATJOMK3LAIDCY+0xc>
    ccfe:	bd70      	pop	{r4, r5, r6, pc}

0000cd00 <sym_6TZLBWMEWRMPI4KKAUVLC2XHUBDGXEA4B4JJJYQ>:
    cd00:	f7f7 b83a 	b.w	3d78 <sym_M4DIQOXJAE3BNHQBIUCZXAABSM24CWUEJOCU7DY>

0000cd04 <sym_F77FUTRRLLWPYDS7BBANG2WE3C4EDMYMAPNI54A>:
    cd04:	b510      	push	{r4, lr}
    cd06:	2000      	movs	r0, #0
    cd08:	f7f7 fb5c 	bl	43c4 <sym_DY4TH3UYBBOUULSDPZZ7Y6J5DTNRGWFEBHJXKVA>
    cd0c:	6800      	ldr	r0, [r0, #0]
    cd0e:	2800      	cmp	r0, #0
    cd10:	bf18      	it	ne
    cd12:	2001      	movne	r0, #1
    cd14:	bd10      	pop	{r4, pc}

0000cd16 <sym_MGCUANL7Q2CUPWKYBFLWSWSNXIEEYBPZTHT2VZI>:
    cd16:	b510      	push	{r4, lr}
    cd18:	f7f7 fbd4 	bl	44c4 <sym_HUWGHJMM42MANQTSVL3EY7E3VE4XM4JTQUIQAII>
    cd1c:	f7f6 fea6 	bl	3a6c <sym_PITJNQC6YSCEFAH23N5QRORZDKCSKOAUGBUS6GA>
    cd20:	f000 f802 	bl	cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>
    cd24:	b280      	uxth	r0, r0
    cd26:	bd10      	pop	{r4, pc}

0000cd28 <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI>:
    cd28:	0a41      	lsrs	r1, r0, #9
    cd2a:	f643 5209 	movw	r2, #15625	; 0x3d09
    cd2e:	4351      	muls	r1, r2
    cd30:	f3c0 0008 	ubfx	r0, r0, #0, #9
    cd34:	fb10 f002 	smulbb	r0, r0, r2
    cd38:	f500 7080 	add.w	r0, r0, #256	; 0x100
    cd3c:	eb01 2050 	add.w	r0, r1, r0, lsr #9
    cd40:	4770      	bx	lr
    cd42:	2800      	cmp	r0, #0
    cd44:	db09      	blt.n	cd5a <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI+0x32>
    cd46:	f000 021f 	and.w	r2, r0, #31
    cd4a:	2101      	movs	r1, #1
    cd4c:	4091      	lsls	r1, r2
    cd4e:	0940      	lsrs	r0, r0, #5
    cd50:	0080      	lsls	r0, r0, #2
    cd52:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    cd56:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
    cd5a:	4770      	bx	lr
    cd5c:	2800      	cmp	r0, #0
    cd5e:	db0d      	blt.n	cd7c <sym_XYQTP7YX2XFVREW5KFDH2NNPGRIPEHKIO2RURYI+0x54>
    cd60:	f000 021f 	and.w	r2, r0, #31
    cd64:	2101      	movs	r1, #1
    cd66:	4091      	lsls	r1, r2
    cd68:	0940      	lsrs	r0, r0, #5
    cd6a:	0080      	lsls	r0, r0, #2
    cd6c:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    cd70:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
    cd74:	f3bf 8f4f 	dsb	sy
    cd78:	f3bf 8f6f 	isb	sy
    cd7c:	4770      	bx	lr

0000cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>:
    cd7e:	b570      	push	{r4, r5, r6, lr}
    cd80:	4602      	mov	r2, r0
    cd82:	2000      	movs	r0, #0
    cd84:	2900      	cmp	r1, #0
    cd86:	d01d      	beq.n	cdc4 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x46>
    cd88:	fba2 0101 	umull	r0, r1, r2, r1
    cd8c:	0a40      	lsrs	r0, r0, #9
    cd8e:	ea40 50c1 	orr.w	r0, r0, r1, lsl #23
    cd92:	0a49      	lsrs	r1, r1, #9
    cd94:	1c40      	adds	r0, r0, #1
    cd96:	f141 0100 	adc.w	r1, r1, #0
    cd9a:	f240 72a1 	movw	r2, #1953	; 0x7a1
    cd9e:	1883      	adds	r3, r0, r2
    cda0:	f141 0100 	adc.w	r1, r1, #0
    cda4:	1c5b      	adds	r3, r3, #1
    cda6:	f141 0400 	adc.w	r4, r1, #0
    cdaa:	2100      	movs	r1, #0
    cdac:	f1d3 33ff 	rsbs	r3, r3, #4294967295	; 0xffffffff
    cdb0:	41a1      	sbcs	r1, r4
    cdb2:	d203      	bcs.n	cdbc <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x3e>
    cdb4:	2172      	movs	r1, #114	; 0x72
    cdb6:	206d      	movs	r0, #109	; 0x6d
    cdb8:	f7f7 fefc 	bl	4bb4 <sym_S2UAPMFVIQXDUOA6CV7GJMB33TYHEUH5D6LHO5Q>
    cdbc:	f500 60f4 	add.w	r0, r0, #1952	; 0x7a0
    cdc0:	fbb0 f0f2 	udiv	r0, r0, r2
    cdc4:	bd70      	pop	{r4, r5, r6, pc}
    cdc6:	5840      	ldr	r0, [r0, r1]
    cdc8:	2800      	cmp	r0, #0
    cdca:	d000      	beq.n	cdce <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x50>
    cdcc:	2001      	movs	r0, #1
    cdce:	4770      	bx	lr
    cdd0:	f8d0 240c 	ldr.w	r2, [r0, #1036]	; 0x40c
    cdd4:	f8d0 040c 	ldr.w	r0, [r0, #1036]	; 0x40c
    cdd8:	f002 0201 	and.w	r2, r2, #1
    cddc:	03c0      	lsls	r0, r0, #15
    cdde:	d503      	bpl.n	cde8 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x6a>
    cde0:	428a      	cmp	r2, r1
    cde2:	d101      	bne.n	cde8 <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI+0x6a>
    cde4:	2001      	movs	r0, #1
    cde6:	4770      	bx	lr
    cde8:	2000      	movs	r0, #0
    cdea:	4770      	bx	lr

0000cdec <sym_TIWHB6UQGI33JQCQDL7C2BRAEXCRAFYENVN6QEI>:
    cdec:	b510      	push	{r4, lr}
    cdee:	2101      	movs	r1, #1
    cdf0:	0788      	lsls	r0, r1, #30
    cdf2:	f7f7 fe89 	bl	4b08 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x10>
    cdf6:	2800      	cmp	r0, #0
    cdf8:	d000      	beq.n	cdfc <sym_TIWHB6UQGI33JQCQDL7C2BRAEXCRAFYENVN6QEI+0x10>
    cdfa:	2001      	movs	r0, #1
    cdfc:	bd10      	pop	{r4, pc}

0000cdfe <sym_IFJHPQV3B4EIN6OIUP3LZSPJBF5HLX2VYD323GA>:
    cdfe:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    ce02:	2101      	movs	r1, #1
    ce04:	6001      	str	r1, [r0, #0]
    ce06:	4770      	bx	lr

0000ce08 <sym_LZEJCP3HZIBKMJQC47UQXAHGCQ52QF47EXOH2WA>:
    ce08:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    ce0c:	f8d1 2418 	ldr.w	r2, [r1, #1048]	; 0x418
    ce10:	f8d1 1418 	ldr.w	r1, [r1, #1048]	; 0x418
    ce14:	f002 0203 	and.w	r2, r2, #3
    ce18:	03c9      	lsls	r1, r1, #15
    ce1a:	d503      	bpl.n	ce24 <sym_LZEJCP3HZIBKMJQC47UQXAHGCQ52QF47EXOH2WA+0x1c>
    ce1c:	4282      	cmp	r2, r0
    ce1e:	d101      	bne.n	ce24 <sym_LZEJCP3HZIBKMJQC47UQXAHGCQ52QF47EXOH2WA+0x1c>
    ce20:	2001      	movs	r0, #1
    ce22:	4770      	bx	lr
    ce24:	2000      	movs	r0, #0
    ce26:	4770      	bx	lr

0000ce28 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA>:
    ce28:	b510      	push	{r4, lr}
    ce2a:	2100      	movs	r1, #0
    ce2c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    ce30:	f7f7 fe6a 	bl	4b08 <sym_7BUNPUBNWNFVXXIMNFFNK765OVON5LBIUZ66QRI+0x10>
    ce34:	2800      	cmp	r0, #0
    ce36:	d000      	beq.n	ce3a <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x12>
    ce38:	2001      	movs	r0, #1
    ce3a:	bd10      	pop	{r4, pc}
    ce3c:	2800      	cmp	r0, #0
    ce3e:	db09      	blt.n	ce54 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x2c>
    ce40:	f000 021f 	and.w	r2, r0, #31
    ce44:	2101      	movs	r1, #1
    ce46:	4091      	lsls	r1, r2
    ce48:	0940      	lsrs	r0, r0, #5
    ce4a:	0080      	lsls	r0, r0, #2
    ce4c:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    ce50:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
    ce54:	4770      	bx	lr
    ce56:	2800      	cmp	r0, #0
    ce58:	db0d      	blt.n	ce76 <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x4e>
    ce5a:	f000 021f 	and.w	r2, r0, #31
    ce5e:	2101      	movs	r1, #1
    ce60:	4091      	lsls	r1, r2
    ce62:	0940      	lsrs	r0, r0, #5
    ce64:	0080      	lsls	r0, r0, #2
    ce66:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    ce6a:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
    ce6e:	f3bf 8f4f 	dsb	sy
    ce72:	f3bf 8f6f 	isb	sy
    ce76:	4770      	bx	lr
    ce78:	00021000 	.word	0x00021000
    ce7c:	000000fa 	.word	0x000000fa
    ce80:	63a70f14 	.word	0x63a70f14
    ce84:	c477f9cf 	.word	0xc477f9cf
    ce88:	e931f9ef 	.word	0xe931f9ef
    ce8c:	03bcf561 	.word	0x03bcf561
    ce90:	2b06749a 	.word	0x2b06749a
    ce94:	2800      	cmp	r0, #0
    ce96:	db09      	blt.n	ceac <sym_AL7FCNVVCF72BNYCTLA5UGAWCQFXFPGE2ULTWOA+0x84>
    ce98:	f000 021f 	and.w	r2, r0, #31
    ce9c:	2101      	movs	r1, #1
    ce9e:	4091      	lsls	r1, r2
    cea0:	0940      	lsrs	r0, r0, #5
    cea2:	0080      	lsls	r0, r0, #2
    cea4:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    cea8:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
    ceac:	4770      	bx	lr

0000ceae <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA>:
    ceae:	f3ef 8110 	mrs	r1, PRIMASK
    ceb2:	b672      	cpsid	i
    ceb4:	7802      	ldrb	r2, [r0, #0]
    ceb6:	2a01      	cmp	r2, #1
    ceb8:	d001      	beq.n	cebe <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA+0x10>
    ceba:	2201      	movs	r2, #1
    cebc:	e000      	b.n	cec0 <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA+0x12>
    cebe:	2200      	movs	r2, #0
    cec0:	2301      	movs	r3, #1
    cec2:	7003      	strb	r3, [r0, #0]
    cec4:	b901      	cbnz	r1, cec8 <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA+0x1a>
    cec6:	b662      	cpsie	i
    cec8:	b10a      	cbz	r2, cece <sym_AR22FPVUFSZMVYMQBBXG7EEZNA2HPS2RLAKRPBA+0x20>
    ceca:	2000      	movs	r0, #0
    cecc:	4770      	bx	lr
    cece:	f06f 0022 	mvn.w	r0, #34	; 0x22
    ced2:	4770      	bx	lr

0000ced4 <sym_YS3AHD7GWBHZEQHPIQANPGALEXB4QGY5O2DQKRY>:
    ced4:	2100      	movs	r1, #0
    ced6:	7001      	strb	r1, [r0, #0]
    ced8:	4608      	mov	r0, r1
    ceda:	4770      	bx	lr

0000cedc <sym_OWJYSTADR5I36MIHWNPICVB7CMCWNSFIZPFXQ2Q>:
    cedc:	f3ef 8110 	mrs	r1, PRIMASK
    cee0:	b672      	cpsid	i
    cee2:	2200      	movs	r2, #0
    cee4:	7002      	strb	r2, [r0, #0]
    cee6:	b901      	cbnz	r1, ceea <sym_OWJYSTADR5I36MIHWNPICVB7CMCWNSFIZPFXQ2Q+0xe>
    cee8:	b662      	cpsie	i
    ceea:	2000      	movs	r0, #0
    ceec:	4770      	bx	lr

0000ceee <mpsl_low_priority_process>:
    ceee:	f7f7 bf51 	b.w	4d94 <sym_VWGRUQT3LYZHLYS5KJ7UOCJEHLDJTWH4RVJBGKQ>

0000cef2 <sym_BN6ZO2NBHRGKZ2NRQYWFBXVGKNG6Y5K55UNAWGA>:
    cef2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cef6:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cefa:	280f      	cmp	r0, #15
    cefc:	d001      	beq.n	cf02 <sym_BN6ZO2NBHRGKZ2NRQYWFBXVGKNG6Y5K55UNAWGA+0x10>
    cefe:	2000      	movs	r0, #0
    cf00:	4770      	bx	lr
    cf02:	2001      	movs	r0, #1
    cf04:	4770      	bx	lr

0000cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>:
    cf06:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cf0a:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cf0e:	280a      	cmp	r0, #10
    cf10:	d001      	beq.n	cf16 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY+0x10>
    cf12:	2000      	movs	r0, #0
    cf14:	4770      	bx	lr
    cf16:	2001      	movs	r0, #1
    cf18:	4770      	bx	lr

0000cf1a <sym_NQG4U7UYIQILZLC5ENYCA4NQMQM6PBAZC345PPA>:
    cf1a:	b500      	push	{lr}
    cf1c:	f7ff fff3 	bl	cf06 <sym_5EMXP3L6SPQSCAJKKRH62ZOKJCCSKLI3WEX2WHY>
    cf20:	b120      	cbz	r0, cf2c <sym_NQG4U7UYIQILZLC5ENYCA4NQMQM6PBAZC345PPA+0x12>
    cf22:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cf26:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
    cf2a:	b108      	cbz	r0, cf30 <sym_NQG4U7UYIQILZLC5ENYCA4NQMQM6PBAZC345PPA+0x16>
    cf2c:	2000      	movs	r0, #0
    cf2e:	bd00      	pop	{pc}
    cf30:	2001      	movs	r0, #1
    cf32:	bd00      	pop	{pc}

0000cf34 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q>:
    cf34:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cf38:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cf3c:	280e      	cmp	r0, #14
    cf3e:	d001      	beq.n	cf44 <sym_H2QJCU2ORTYAFBAQQ2FHUYIAZO4HCXEKCQ4SS2Q+0x10>
    cf40:	2000      	movs	r0, #0
    cf42:	4770      	bx	lr
    cf44:	2001      	movs	r0, #1
    cf46:	4770      	bx	lr

0000cf48 <sym_SWIBDSDMHUYNCG5ZWLB52J7NETJIUBPCO5IIQFA>:
    cf48:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cf4c:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cf50:	2810      	cmp	r0, #16
    cf52:	d001      	beq.n	cf58 <sym_SWIBDSDMHUYNCG5ZWLB52J7NETJIUBPCO5IIQFA+0x10>
    cf54:	2000      	movs	r0, #0
    cf56:	4770      	bx	lr
    cf58:	2001      	movs	r0, #1
    cf5a:	4770      	bx	lr

0000cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>:
    cf5c:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cf60:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cf64:	2806      	cmp	r0, #6
    cf66:	d003      	beq.n	cf70 <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ+0x14>
    cf68:	1c40      	adds	r0, r0, #1
    cf6a:	d001      	beq.n	cf70 <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ+0x14>
    cf6c:	2000      	movs	r0, #0
    cf6e:	4770      	bx	lr
    cf70:	2001      	movs	r0, #1
    cf72:	4770      	bx	lr

0000cf74 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ>:
    cf74:	b500      	push	{lr}
    cf76:	f7ff fff1 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    cf7a:	b148      	cbz	r0, cf90 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ+0x1c>
    cf7c:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cf80:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
    cf84:	2806      	cmp	r0, #6
    cf86:	d303      	bcc.n	cf90 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ+0x1c>
    cf88:	1c40      	adds	r0, r0, #1
    cf8a:	d001      	beq.n	cf90 <sym_6AONFMPWPBAZBMQ4KY5PX7QPX2FM4UPZQRFPZSQ+0x1c>
    cf8c:	2001      	movs	r0, #1
    cf8e:	bd00      	pop	{pc}
    cf90:	2000      	movs	r0, #0
    cf92:	bd00      	pop	{pc}

0000cf94 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ>:
    cf94:	b500      	push	{lr}
    cf96:	f7ff ffe1 	bl	cf5c <sym_QPP3IZFSWHUV4JQ6ODMIVIARPB4PQYUFESV7BRQ>
    cf9a:	b138      	cbz	r0, cfac <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ+0x18>
    cf9c:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cfa0:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
    cfa4:	2806      	cmp	r0, #6
    cfa6:	d303      	bcc.n	cfb0 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ+0x1c>
    cfa8:	1c40      	adds	r0, r0, #1
    cfaa:	d001      	beq.n	cfb0 <sym_YNH6KDZL2GMJ2KPUX5DEER63BRE7IOGBY3KCQAQ+0x1c>
    cfac:	2000      	movs	r0, #0
    cfae:	bd00      	pop	{pc}
    cfb0:	2001      	movs	r0, #1
    cfb2:	bd00      	pop	{pc}

0000cfb4 <sym_6PVOPWDLWTXOTRZZ7LP36TLYTLPTQHNAUQNFHEA>:
    cfb4:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cfb8:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cfbc:	280d      	cmp	r0, #13
    cfbe:	d001      	beq.n	cfc4 <sym_6PVOPWDLWTXOTRZZ7LP36TLYTLPTQHNAUQNFHEA+0x10>
    cfc0:	2000      	movs	r0, #0
    cfc2:	4770      	bx	lr
    cfc4:	2001      	movs	r0, #1
    cfc6:	4770      	bx	lr

0000cfc8 <sym_USR4MDT6VMTQLOGKNN4MALBZ3GJPD2KOEY4HFAQ>:
    cfc8:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    cfcc:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
    cfd0:	2808      	cmp	r0, #8
    cfd2:	d001      	beq.n	cfd8 <sym_USR4MDT6VMTQLOGKNN4MALBZ3GJPD2KOEY4HFAQ+0x10>
    cfd4:	2000      	movs	r0, #0
    cfd6:	4770      	bx	lr
    cfd8:	2001      	movs	r0, #1
    cfda:	4770      	bx	lr

0000cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>:
    cfdc:	b4f0      	push	{r4, r5, r6, r7}
    cfde:	ea80 0c01 	eor.w	ip, r0, r1
    cfe2:	4603      	mov	r3, r0
    cfe4:	f01c 0f03 	tst.w	ip, #3
    cfe8:	d13c      	bne.n	d064 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x88>
    cfea:	f013 0f03 	tst.w	r3, #3
    cfee:	d00b      	beq.n	d008 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x2c>
    cff0:	2a00      	cmp	r2, #0
    cff2:	bf04      	itt	eq
    cff4:	bcf0      	popeq	{r4, r5, r6, r7}
    cff6:	4770      	bxeq	lr
    cff8:	f811 cb01 	ldrb.w	ip, [r1], #1
    cffc:	f803 cb01 	strb.w	ip, [r3], #1
    d000:	1e52      	subs	r2, r2, #1
    d002:	f013 0f03 	tst.w	r3, #3
    d006:	d1f3      	bne.n	cff0 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x14>
    d008:	2a03      	cmp	r2, #3
    d00a:	d94f      	bls.n	d0ac <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xd0>
    d00c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    d010:	d24c      	bcs.n	d0ac <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xd0>
    d012:	f1c2 0c00 	rsb	ip, r2, #0
    d016:	ea4f 74ec 	mov.w	r4, ip, asr #31
    d01a:	eb0c 7c94 	add.w	ip, ip, r4, lsr #30
    d01e:	ea4f 0cac 	mov.w	ip, ip, asr #2
    d022:	f1cc 0c00 	rsb	ip, ip, #0
    d026:	f1bc 0f00 	cmp.w	ip, #0
    d02a:	dd1b      	ble.n	d064 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x88>
    d02c:	1f0d      	subs	r5, r1, #4
    d02e:	1f1c      	subs	r4, r3, #4
    d030:	f01c 0f01 	tst.w	ip, #1
    d034:	d003      	beq.n	d03e <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x62>
    d036:	f855 6f04 	ldr.w	r6, [r5, #4]!
    d03a:	f844 6f04 	str.w	r6, [r4, #4]!
    d03e:	ea5f 066c 	movs.w	r6, ip, asr #1
    d042:	d007      	beq.n	d054 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x78>
    d044:	686f      	ldr	r7, [r5, #4]
    d046:	6067      	str	r7, [r4, #4]
    d048:	f855 7f08 	ldr.w	r7, [r5, #8]!
    d04c:	f844 7f08 	str.w	r7, [r4, #8]!
    d050:	1e76      	subs	r6, r6, #1
    d052:	d1f7      	bne.n	d044 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x68>
    d054:	eb01 018c 	add.w	r1, r1, ip, lsl #2
    d058:	eb03 038c 	add.w	r3, r3, ip, lsl #2
    d05c:	f1cc 0c00 	rsb	ip, ip, #0
    d060:	eb02 028c 	add.w	r2, r2, ip, lsl #2
    d064:	2a00      	cmp	r2, #0
    d066:	bf04      	itt	eq
    d068:	bcf0      	popeq	{r4, r5, r6, r7}
    d06a:	4770      	bxeq	lr
    d06c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    d070:	d226      	bcs.n	d0c0 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xe4>
    d072:	2a00      	cmp	r2, #0
    d074:	bfdc      	itt	le
    d076:	bcf0      	pople	{r4, r5, r6, r7}
    d078:	4770      	bxle	lr
    d07a:	1e49      	subs	r1, r1, #1
    d07c:	1e5b      	subs	r3, r3, #1
    d07e:	f012 0f01 	tst.w	r2, #1
    d082:	d003      	beq.n	d08c <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xb0>
    d084:	f811 cf01 	ldrb.w	ip, [r1, #1]!
    d088:	f803 cf01 	strb.w	ip, [r3, #1]!
    d08c:	1052      	asrs	r2, r2, #1
    d08e:	bf04      	itt	eq
    d090:	bcf0      	popeq	{r4, r5, r6, r7}
    d092:	4770      	bxeq	lr
    d094:	f891 c001 	ldrb.w	ip, [r1, #1]
    d098:	f883 c001 	strb.w	ip, [r3, #1]
    d09c:	f811 cf02 	ldrb.w	ip, [r1, #2]!
    d0a0:	f803 cf02 	strb.w	ip, [r3, #2]!
    d0a4:	1e52      	subs	r2, r2, #1
    d0a6:	d1f5      	bne.n	d094 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xb8>
    d0a8:	bcf0      	pop	{r4, r5, r6, r7}
    d0aa:	4770      	bx	lr
    d0ac:	2a04      	cmp	r2, #4
    d0ae:	d3d9      	bcc.n	d064 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x88>
    d0b0:	f851 cb04 	ldr.w	ip, [r1], #4
    d0b4:	1f12      	subs	r2, r2, #4
    d0b6:	f843 cb04 	str.w	ip, [r3], #4
    d0ba:	2a04      	cmp	r2, #4
    d0bc:	d2f8      	bcs.n	d0b0 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xd4>
    d0be:	e7d1      	b.n	d064 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0x88>
    d0c0:	f811 cb01 	ldrb.w	ip, [r1], #1
    d0c4:	f803 cb01 	strb.w	ip, [r3], #1
    d0c8:	1e52      	subs	r2, r2, #1
    d0ca:	d1f9      	bne.n	d0c0 <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A+0xe4>
    d0cc:	bcf0      	pop	{r4, r5, r6, r7}
    d0ce:	4770      	bx	lr

0000d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>:
    d0d0:	b470      	push	{r4, r5, r6}
    d0d2:	4603      	mov	r3, r0
    d0d4:	f001 0cff 	and.w	ip, r1, #255	; 0xff
    d0d8:	f010 0f03 	tst.w	r0, #3
    d0dc:	d009      	beq.n	d0f2 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x22>
    d0de:	2a00      	cmp	r2, #0
    d0e0:	bf04      	itt	eq
    d0e2:	bc70      	popeq	{r4, r5, r6}
    d0e4:	4770      	bxeq	lr
    d0e6:	f803 cb01 	strb.w	ip, [r3], #1
    d0ea:	1e52      	subs	r2, r2, #1
    d0ec:	f013 0f03 	tst.w	r3, #3
    d0f0:	d1f5      	bne.n	d0de <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0xe>
    d0f2:	b2c9      	uxtb	r1, r1
    d0f4:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    d0f8:	ea41 4501 	orr.w	r5, r1, r1, lsl #16
    d0fc:	2a03      	cmp	r2, #3
    d0fe:	d939      	bls.n	d174 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0xa4>
    d100:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    d104:	d236      	bcs.n	d174 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0xa4>
    d106:	4251      	negs	r1, r2
    d108:	17cc      	asrs	r4, r1, #31
    d10a:	eb01 7194 	add.w	r1, r1, r4, lsr #30
    d10e:	1089      	asrs	r1, r1, #2
    d110:	424e      	negs	r6, r1
    d112:	2e00      	cmp	r6, #0
    d114:	dd11      	ble.n	d13a <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x6a>
    d116:	1f19      	subs	r1, r3, #4
    d118:	f016 0f01 	tst.w	r6, #1
    d11c:	bf18      	it	ne
    d11e:	f841 5f04 	strne.w	r5, [r1, #4]!
    d122:	1074      	asrs	r4, r6, #1
    d124:	d004      	beq.n	d130 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x60>
    d126:	604d      	str	r5, [r1, #4]
    d128:	f841 5f08 	str.w	r5, [r1, #8]!
    d12c:	1e64      	subs	r4, r4, #1
    d12e:	d1fa      	bne.n	d126 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x56>
    d130:	4271      	negs	r1, r6
    d132:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    d136:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    d13a:	2a00      	cmp	r2, #0
    d13c:	bf04      	itt	eq
    d13e:	bc70      	popeq	{r4, r5, r6}
    d140:	4770      	bxeq	lr
    d142:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    d146:	d21d      	bcs.n	d184 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0xb4>
    d148:	2a00      	cmp	r2, #0
    d14a:	bfdc      	itt	le
    d14c:	bc70      	pople	{r4, r5, r6}
    d14e:	4770      	bxle	lr
    d150:	1e59      	subs	r1, r3, #1
    d152:	f012 0f01 	tst.w	r2, #1
    d156:	bf18      	it	ne
    d158:	f801 cf01 	strbne.w	ip, [r1, #1]!
    d15c:	1052      	asrs	r2, r2, #1
    d15e:	bf04      	itt	eq
    d160:	bc70      	popeq	{r4, r5, r6}
    d162:	4770      	bxeq	lr
    d164:	f881 c001 	strb.w	ip, [r1, #1]
    d168:	f801 cf02 	strb.w	ip, [r1, #2]!
    d16c:	1e52      	subs	r2, r2, #1
    d16e:	d1f9      	bne.n	d164 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x94>
    d170:	bc70      	pop	{r4, r5, r6}
    d172:	4770      	bx	lr
    d174:	2a04      	cmp	r2, #4
    d176:	d3e0      	bcc.n	d13a <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x6a>
    d178:	1f12      	subs	r2, r2, #4
    d17a:	f843 5b04 	str.w	r5, [r3], #4
    d17e:	2a04      	cmp	r2, #4
    d180:	d2fa      	bcs.n	d178 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0xa8>
    d182:	e7da      	b.n	d13a <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x6a>
    d184:	f803 cb01 	strb.w	ip, [r3], #1
    d188:	1e52      	subs	r2, r2, #1
    d18a:	d1fb      	bne.n	d184 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0xb4>
    d18c:	bc70      	pop	{r4, r5, r6}
    d18e:	4770      	bx	lr
    d190:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d194:	4770      	bx	lr
    d196:	2000      	movs	r0, #0
    d198:	4770      	bx	lr
    d19a:	2000      	movs	r0, #0
    d19c:	4770      	bx	lr
    d19e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d1a2:	4770      	bx	lr
    d1a4:	4770      	bx	lr
    d1a6:	4770      	bx	lr
    d1a8:	2000      	movs	r0, #0
    d1aa:	4770      	bx	lr
    d1ac:	2100      	movs	r1, #0
    d1ae:	7001      	strb	r1, [r0, #0]
    d1b0:	4770      	bx	lr
    d1b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d1b6:	4770      	bx	lr
    d1b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d1bc:	4770      	bx	lr
    d1be:	2100      	movs	r1, #0
    d1c0:	7001      	strb	r1, [r0, #0]
    d1c2:	4770      	bx	lr
    d1c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d1c8:	4770      	bx	lr
    d1ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d1ce:	4770      	bx	lr
    d1d0:	7800      	ldrb	r0, [r0, #0]
    d1d2:	2800      	cmp	r0, #0
    d1d4:	d001      	beq.n	d1da <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA+0x10a>
    d1d6:	f06f 0015 	mvn.w	r0, #21
    d1da:	4770      	bx	lr
    d1dc:	2000      	movs	r0, #0
    d1de:	4770      	bx	lr
    d1e0:	2200      	movs	r2, #0
    d1e2:	f000 b800 	b.w	d1e6 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA>

0000d1e6 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA>:
    d1e6:	b570      	push	{r4, r5, r6, lr}
    d1e8:	4614      	mov	r4, r2
    d1ea:	460d      	mov	r5, r1
    d1ec:	1b00      	subs	r0, r0, r4
    d1ee:	f06f 017f 	mvn.w	r1, #127	; 0x7f
    d1f2:	4288      	cmp	r0, r1
    d1f4:	da01      	bge.n	d1fa <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x14>
    d1f6:	4608      	mov	r0, r1
    d1f8:	e002      	b.n	d200 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x1a>
    d1fa:	287f      	cmp	r0, #127	; 0x7f
    d1fc:	dd00      	ble.n	d200 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x1a>
    d1fe:	207f      	movs	r0, #127	; 0x7f
    d200:	b240      	sxtb	r0, r0
    d202:	f7f4 f9c5 	bl	1590 <mpsl_tx_power_radio_supported_power_adjust>
    d206:	7028      	strb	r0, [r5, #0]
    d208:	706c      	strb	r4, [r5, #1]
    d20a:	2100      	movs	r1, #0
    d20c:	4420      	add	r0, r4
    d20e:	70a9      	strb	r1, [r5, #2]
    d210:	b240      	sxtb	r0, r0
    d212:	bd70      	pop	{r4, r5, r6, pc}
    d214:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d218:	460c      	mov	r4, r1
    d21a:	4681      	mov	r9, r0
    d21c:	7849      	ldrb	r1, [r1, #1]
    d21e:	f100 0003 	add.w	r0, r0, #3
    d222:	f88d 1000 	strb.w	r1, [sp]
    d226:	f020 0003 	bic.w	r0, r0, #3
    d22a:	78a1      	ldrb	r1, [r4, #2]
    d22c:	0016      	movs	r6, r2
    d22e:	4605      	mov	r5, r0
    d230:	f88d 1001 	strb.w	r1, [sp, #1]
    d234:	d000      	beq.n	d238 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x52>
    d236:	2000      	movs	r0, #0
    d238:	4669      	mov	r1, sp
    d23a:	f7f8 f98f 	bl	555c <sym_EQ53CEL7EDVHMFMHMFPRRQU46C5YKKFEBAACFOA>
    d23e:	4428      	add	r0, r5
    d240:	78a1      	ldrb	r1, [r4, #2]
    d242:	4605      	mov	r5, r0
    d244:	b131      	cbz	r1, d254 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x6e>
    d246:	8a63      	ldrh	r3, [r4, #18]
    d248:	78e2      	ldrb	r2, [r4, #3]
    d24a:	b106      	cbz	r6, d24e <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x68>
    d24c:	2000      	movs	r0, #0
    d24e:	f7f8 fc17 	bl	5a80 <sym_YL4RMM7WH2QQSRTLJX7L5Q2F5KYIEZ5IWMCN3UQ>
    d252:	4405      	add	r5, r0
    d254:	7820      	ldrb	r0, [r4, #0]
    d256:	7861      	ldrb	r1, [r4, #1]
    d258:	46b2      	mov	sl, r6
    d25a:	2600      	movs	r6, #0
    d25c:	4408      	add	r0, r1
    d25e:	f000 08ff 	and.w	r8, r0, #255	; 0xff
    d262:	4637      	mov	r7, r6
    d264:	e008      	b.n	d278 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x92>
    d266:	7a23      	ldrb	r3, [r4, #8]
    d268:	79e2      	ldrb	r2, [r4, #7]
    d26a:	79a1      	ldrb	r1, [r4, #6]
    d26c:	7960      	ldrb	r0, [r4, #5]
    d26e:	f000 fee2 	bl	e036 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY>
    d272:	1c7f      	adds	r7, r7, #1
    d274:	4406      	add	r6, r0
    d276:	b2ff      	uxtb	r7, r7
    d278:	4547      	cmp	r7, r8
    d27a:	d3f4      	bcc.n	d266 <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0x80>
    d27c:	1ced      	adds	r5, r5, #3
    d27e:	f025 0003 	bic.w	r0, r5, #3
    d282:	4604      	mov	r4, r0
    d284:	f1ba 0f00 	cmp.w	sl, #0
    d288:	d000      	beq.n	d28c <sym_PX4SKXGNX25XLMGGWQM65ZRFHI6666YGHL6AYMA+0xa6>
    d28a:	2000      	movs	r0, #0
    d28c:	4632      	mov	r2, r6
    d28e:	4641      	mov	r1, r8
    d290:	f7f8 fb40 	bl	5914 <sym_6DYG6C6ROXZA67GZINNB2XIQHL3KE2RCKK4QFXA>
    d294:	4420      	add	r0, r4
    d296:	1dc0      	adds	r0, r0, #7
    d298:	f020 0007 	bic.w	r0, r0, #7
    d29c:	eba0 0009 	sub.w	r0, r0, r9
    d2a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d2a4 <sym_J4YPB5V427LGVECR3WQM2YMQSYACGT77QKJSI3I>:
    d2a4:	b53e      	push	{r1, r2, r3, r4, r5, lr}
    d2a6:	4604      	mov	r4, r0
    d2a8:	1d01      	adds	r1, r0, #4
    d2aa:	4668      	mov	r0, sp
    d2ac:	f7f9 fef4 	bl	7098 <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA>
    d2b0:	2800      	cmp	r0, #0
    d2b2:	d004      	beq.n	d2be <sym_J4YPB5V427LGVECR3WQM2YMQSYACGT77QKJSI3I+0x1a>
    d2b4:	4669      	mov	r1, sp
    d2b6:	4620      	mov	r0, r4
    d2b8:	f000 f848 	bl	d34c <sym_CNH7SD2WCGFAHI2ANQOF3HHV2F3WYQDABEB6D2I>
    d2bc:	2001      	movs	r0, #1
    d2be:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0000d2c0 <sym_PVKZWZJ5CJJGE5FITE5FOMMY5J4BUV2COWMQKSY>:
    d2c0:	b50e      	push	{r1, r2, r3, lr}
    d2c2:	4601      	mov	r1, r0
    d2c4:	4668      	mov	r0, sp
    d2c6:	f000 f827 	bl	d318 <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI>
    d2ca:	4668      	mov	r0, sp
    d2cc:	f001 fce6 	bl	ec9c <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA>
    d2d0:	bd0e      	pop	{r1, r2, r3, pc}

0000d2d2 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ>:
    d2d2:	b510      	push	{r4, lr}
    d2d4:	4604      	mov	r4, r0
    d2d6:	4620      	mov	r0, r4
    d2d8:	f7f8 f834 	bl	5344 <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0x50>
    d2dc:	2800      	cmp	r0, #0
    d2de:	d006      	beq.n	d2ee <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x1c>
    d2e0:	78a1      	ldrb	r1, [r4, #2]
    d2e2:	7820      	ldrb	r0, [r4, #0]
    d2e4:	f000 f804 	bl	d2f0 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x1e>
    d2e8:	2800      	cmp	r0, #0
    d2ea:	d0f4      	beq.n	d2d6 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x4>
    d2ec:	2001      	movs	r0, #1
    d2ee:	bd10      	pop	{r4, pc}
    d2f0:	b570      	push	{r4, r5, r6, lr}
    d2f2:	460c      	mov	r4, r1
    d2f4:	4605      	mov	r5, r0
    d2f6:	f7f8 f897 	bl	5428 <sym_Z7NJGBYWCKFTEHRYWAIDKWPEUN45273QSWUA5CY>
    d2fa:	2800      	cmp	r0, #0
    d2fc:	d002      	beq.n	d304 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x32>
    d2fe:	2d3e      	cmp	r5, #62	; 0x3e
    d300:	d001      	beq.n	d306 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x34>
    d302:	2001      	movs	r0, #1
    d304:	bd70      	pop	{r4, r5, r6, pc}
    d306:	2c12      	cmp	r4, #18
    d308:	d004      	beq.n	d314 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ+0x42>
    d30a:	4620      	mov	r0, r4
    d30c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    d310:	f7f8 b89c 	b.w	544c <sym_CEENVC5DZRUT7MGF5LABXKT4NV7YUL5F6EX6TEQ>
    d314:	2000      	movs	r0, #0
    d316:	bd70      	pop	{r4, r5, r6, pc}

0000d318 <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI>:
    d318:	880a      	ldrh	r2, [r1, #0]
    d31a:	f3c2 020b 	ubfx	r2, r2, #0, #12
    d31e:	8002      	strh	r2, [r0, #0]
    d320:	884a      	ldrh	r2, [r1, #2]
    d322:	8042      	strh	r2, [r0, #2]
    d324:	784a      	ldrb	r2, [r1, #1]
    d326:	0993      	lsrs	r3, r2, #6
    d328:	2200      	movs	r2, #0
    d32a:	7142      	strb	r2, [r0, #5]
    d32c:	784b      	ldrb	r3, [r1, #1]
    d32e:	f3c3 1301 	ubfx	r3, r3, #4, #2
    d332:	b11b      	cbz	r3, d33c <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI+0x24>
    d334:	2b01      	cmp	r3, #1
    d336:	d005      	beq.n	d344 <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI+0x2c>
    d338:	2b02      	cmp	r3, #2
    d33a:	d005      	beq.n	d348 <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI+0x30>
    d33c:	7102      	strb	r2, [r0, #4]
    d33e:	1d09      	adds	r1, r1, #4
    d340:	6081      	str	r1, [r0, #8]
    d342:	4770      	bx	lr
    d344:	2201      	movs	r2, #1
    d346:	e7f9      	b.n	d33c <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI+0x24>
    d348:	2202      	movs	r2, #2
    d34a:	e7f7      	b.n	d33c <sym_BR3ZWQHTEOP3TTXZR25GQZOEPSGL2XNSEOFSTEI+0x24>

0000d34c <sym_CNH7SD2WCGFAHI2ANQOF3HHV2F3WYQDABEB6D2I>:
    d34c:	b510      	push	{r4, lr}
    d34e:	460c      	mov	r4, r1
    d350:	7809      	ldrb	r1, [r1, #0]
    d352:	7001      	strb	r1, [r0, #0]
    d354:	7841      	ldrb	r1, [r0, #1]
    d356:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
    d35a:	7041      	strb	r1, [r0, #1]
    d35c:	8822      	ldrh	r2, [r4, #0]
    d35e:	f3c2 2203 	ubfx	r2, r2, #8, #4
    d362:	4311      	orrs	r1, r2
    d364:	7041      	strb	r1, [r0, #1]
    d366:	78a2      	ldrb	r2, [r4, #2]
    d368:	7082      	strb	r2, [r0, #2]
    d36a:	8862      	ldrh	r2, [r4, #2]
    d36c:	f001 01cf 	and.w	r1, r1, #207	; 0xcf
    d370:	0a12      	lsrs	r2, r2, #8
    d372:	70c2      	strb	r2, [r0, #3]
    d374:	7041      	strb	r1, [r0, #1]
    d376:	7922      	ldrb	r2, [r4, #4]
    d378:	ea41 1102 	orr.w	r1, r1, r2, lsl #4
    d37c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    d380:	7041      	strb	r1, [r0, #1]
    d382:	7962      	ldrb	r2, [r4, #5]
    d384:	ea41 1182 	orr.w	r1, r1, r2, lsl #6
    d388:	7041      	strb	r1, [r0, #1]
    d38a:	68a1      	ldr	r1, [r4, #8]
    d38c:	1d02      	adds	r2, r0, #4
    d38e:	4291      	cmp	r1, r2
    d390:	d006      	beq.n	d3a0 <sym_CNH7SD2WCGFAHI2ANQOF3HHV2F3WYQDABEB6D2I+0x54>
    d392:	8862      	ldrh	r2, [r4, #2]
    d394:	2afb      	cmp	r2, #251	; 0xfb
    d396:	d300      	bcc.n	d39a <sym_CNH7SD2WCGFAHI2ANQOF3HHV2F3WYQDABEB6D2I+0x4e>
    d398:	22fb      	movs	r2, #251	; 0xfb
    d39a:	1d00      	adds	r0, r0, #4
    d39c:	f7ff fe1e 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    d3a0:	78a0      	ldrb	r0, [r4, #2]
    d3a2:	1d00      	adds	r0, r0, #4
    d3a4:	b2c0      	uxtb	r0, r0
    d3a6:	bd10      	pop	{r4, pc}

0000d3a8 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI>:
    d3a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d3ac:	4604      	mov	r4, r0
    d3ae:	f891 c000 	ldrb.w	ip, [r1]
    d3b2:	2000      	movs	r0, #0
    d3b4:	2513      	movs	r5, #19
    d3b6:	260c      	movs	r6, #12
    d3b8:	2705      	movs	r7, #5
    d3ba:	223e      	movs	r2, #62	; 0x3e
    d3bc:	23ff      	movs	r3, #255	; 0xff
    d3be:	f1bc 0f1b 	cmp.w	ip, #27
    d3c2:	d27d      	bcs.n	d4c0 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x118>
    d3c4:	e8df f00c 	tbb	[pc, ip]
    d3c8:	27250e7c 	.word	0x27250e7c
    d3cc:	a391872d 	.word	0xa391872d
    d3d0:	ddd2d0bd 	.word	0xddd2d0bd
    d3d4:	7cf1f2f4 	.word	0x7cf1f2f4
    d3d8:	efff537c 	.word	0xefff537c
    d3dc:	ebecedee 	.word	0xebecedee
    d3e0:	00e8e9ea 	.word	0x00e8e9ea
    d3e4:	7026      	strb	r6, [r4, #0]
    d3e6:	7908      	ldrb	r0, [r1, #4]
    d3e8:	70a0      	strb	r0, [r4, #2]
    d3ea:	7948      	ldrb	r0, [r1, #5]
    d3ec:	70e0      	strb	r0, [r4, #3]
    d3ee:	f8b1 0005 	ldrh.w	r0, [r1, #5]
    d3f2:	0a00      	lsrs	r0, r0, #8
    d3f4:	7120      	strb	r0, [r4, #4]
    d3f6:	79c8      	ldrb	r0, [r1, #7]
    d3f8:	7160      	strb	r0, [r4, #5]
    d3fa:	7a08      	ldrb	r0, [r1, #8]
    d3fc:	71a0      	strb	r0, [r4, #6]
    d3fe:	8908      	ldrh	r0, [r1, #8]
    d400:	0a00      	lsrs	r0, r0, #8
    d402:	71e0      	strb	r0, [r4, #7]
    d404:	7a88      	ldrb	r0, [r1, #10]
    d406:	7220      	strb	r0, [r4, #8]
    d408:	8948      	ldrh	r0, [r1, #10]
    d40a:	0a00      	lsrs	r0, r0, #8
    d40c:	7260      	strb	r0, [r4, #9]
    d40e:	2008      	movs	r0, #8
    d410:	e174      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d412:	2010      	movs	r0, #16
    d414:	e000      	b.n	d418 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x70>
    d416:	201a      	movs	r0, #26
    d418:	7020      	strb	r0, [r4, #0]
    d41a:	7908      	ldrb	r0, [r1, #4]
    d41c:	70a0      	strb	r0, [r4, #2]
    d41e:	2001      	movs	r0, #1
    d420:	e16c      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d422:	7022      	strb	r2, [r4, #0]
    d424:	2001      	movs	r0, #1
    d426:	70a0      	strb	r0, [r4, #2]
    d428:	7908      	ldrb	r0, [r1, #4]
    d42a:	70e0      	strb	r0, [r4, #3]
    d42c:	7988      	ldrb	r0, [r1, #6]
    d42e:	7120      	strb	r0, [r4, #4]
    d430:	88c8      	ldrh	r0, [r1, #6]
    d432:	0a00      	lsrs	r0, r0, #8
    d434:	7160      	strb	r0, [r4, #5]
    d436:	7a08      	ldrb	r0, [r1, #8]
    d438:	71a0      	strb	r0, [r4, #6]
    d43a:	7a48      	ldrb	r0, [r1, #9]
    d43c:	71e0      	strb	r0, [r4, #7]
    d43e:	f8d1 000a 	ldr.w	r0, [r1, #10]
    d442:	60a0      	str	r0, [r4, #8]
    d444:	89c8      	ldrh	r0, [r1, #14]
    d446:	81a0      	strh	r0, [r4, #12]
    d448:	7c08      	ldrb	r0, [r1, #16]
    d44a:	73a0      	strb	r0, [r4, #14]
    d44c:	8a08      	ldrh	r0, [r1, #16]
    d44e:	0a00      	lsrs	r0, r0, #8
    d450:	73e0      	strb	r0, [r4, #15]
    d452:	7c88      	ldrb	r0, [r1, #18]
    d454:	7420      	strb	r0, [r4, #16]
    d456:	8a48      	ldrh	r0, [r1, #18]
    d458:	0a00      	lsrs	r0, r0, #8
    d45a:	7460      	strb	r0, [r4, #17]
    d45c:	7d08      	ldrb	r0, [r1, #20]
    d45e:	74a0      	strb	r0, [r4, #18]
    d460:	8a88      	ldrh	r0, [r1, #20]
    d462:	0a00      	lsrs	r0, r0, #8
    d464:	74e0      	strb	r0, [r4, #19]
    d466:	7d88      	ldrb	r0, [r1, #22]
    d468:	7520      	strb	r0, [r4, #20]
    d46a:	4628      	mov	r0, r5
    d46c:	e146      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d46e:	7022      	strb	r2, [r4, #0]
    d470:	200a      	movs	r0, #10
    d472:	70a0      	strb	r0, [r4, #2]
    d474:	f811 0f04 	ldrb.w	r0, [r1, #4]!
    d478:	70e0      	strb	r0, [r4, #3]
    d47a:	7888      	ldrb	r0, [r1, #2]
    d47c:	7120      	strb	r0, [r4, #4]
    d47e:	8848      	ldrh	r0, [r1, #2]
    d480:	0a00      	lsrs	r0, r0, #8
    d482:	7160      	strb	r0, [r4, #5]
    d484:	7908      	ldrb	r0, [r1, #4]
    d486:	71a0      	strb	r0, [r4, #6]
    d488:	7948      	ldrb	r0, [r1, #5]
    d48a:	71e0      	strb	r0, [r4, #7]
    d48c:	f8d1 0006 	ldr.w	r0, [r1, #6]
    d490:	60a0      	str	r0, [r4, #8]
    d492:	8948      	ldrh	r0, [r1, #10]
    d494:	81a0      	strh	r0, [r4, #12]
    d496:	68c8      	ldr	r0, [r1, #12]
    d498:	f8c4 000e 	str.w	r0, [r4, #14]
    d49c:	8a08      	ldrh	r0, [r1, #16]
    d49e:	8260      	strh	r0, [r4, #18]
    d4a0:	f8d1 0012 	ldr.w	r0, [r1, #18]
    d4a4:	6160      	str	r0, [r4, #20]
    d4a6:	8ac8      	ldrh	r0, [r1, #22]
    d4a8:	8320      	strh	r0, [r4, #24]
    d4aa:	7e08      	ldrb	r0, [r1, #24]
    d4ac:	76a0      	strb	r0, [r4, #26]
    d4ae:	8b08      	ldrh	r0, [r1, #24]
    d4b0:	0a00      	lsrs	r0, r0, #8
    d4b2:	76e0      	strb	r0, [r4, #27]
    d4b4:	7e88      	ldrb	r0, [r1, #26]
    d4b6:	7720      	strb	r0, [r4, #28]
    d4b8:	8b48      	ldrh	r0, [r1, #26]
    d4ba:	0a00      	lsrs	r0, r0, #8
    d4bc:	7760      	strb	r0, [r4, #29]
    d4be:	e000      	b.n	d4c2 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x11a>
    d4c0:	e097      	b.n	d5f2 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x24a>
    d4c2:	7f08      	ldrb	r0, [r1, #28]
    d4c4:	77a0      	strb	r0, [r4, #30]
    d4c6:	8b88      	ldrh	r0, [r1, #28]
    d4c8:	0a00      	lsrs	r0, r0, #8
    d4ca:	77e0      	strb	r0, [r4, #31]
    d4cc:	7f88      	ldrb	r0, [r1, #30]
    d4ce:	f884 0020 	strb.w	r0, [r4, #32]
    d4d2:	201f      	movs	r0, #31
    d4d4:	e112      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d4d6:	7022      	strb	r2, [r4, #0]
    d4d8:	2014      	movs	r0, #20
    d4da:	70a0      	strb	r0, [r4, #2]
    d4dc:	7908      	ldrb	r0, [r1, #4]
    d4de:	70e0      	strb	r0, [r4, #3]
    d4e0:	8888      	ldrh	r0, [r1, #4]
    d4e2:	0a00      	lsrs	r0, r0, #8
    d4e4:	7120      	strb	r0, [r4, #4]
    d4e6:	7988      	ldrb	r0, [r1, #6]
    d4e8:	e0a6      	b.n	d638 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x290>
    d4ea:	7022      	strb	r2, [r4, #0]
    d4ec:	2004      	movs	r0, #4
    d4ee:	70a0      	strb	r0, [r4, #2]
    d4f0:	7908      	ldrb	r0, [r1, #4]
    d4f2:	70e0      	strb	r0, [r4, #3]
    d4f4:	7988      	ldrb	r0, [r1, #6]
    d4f6:	7120      	strb	r0, [r4, #4]
    d4f8:	88c8      	ldrh	r0, [r1, #6]
    d4fa:	0a00      	lsrs	r0, r0, #8
    d4fc:	7160      	strb	r0, [r4, #5]
    d4fe:	6888      	ldr	r0, [r1, #8]
    d500:	f8c4 0006 	str.w	r0, [r4, #6]
    d504:	68c8      	ldr	r0, [r1, #12]
    d506:	f8c4 000a 	str.w	r0, [r4, #10]
    d50a:	200c      	movs	r0, #12
    d50c:	e0f6      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d50e:	7022      	strb	r2, [r4, #0]
    d510:	2003      	movs	r0, #3
    d512:	70a0      	strb	r0, [r4, #2]
    d514:	7908      	ldrb	r0, [r1, #4]
    d516:	70e0      	strb	r0, [r4, #3]
    d518:	7988      	ldrb	r0, [r1, #6]
    d51a:	7120      	strb	r0, [r4, #4]
    d51c:	88c8      	ldrh	r0, [r1, #6]
    d51e:	0a00      	lsrs	r0, r0, #8
    d520:	7160      	strb	r0, [r4, #5]
    d522:	7a08      	ldrb	r0, [r1, #8]
    d524:	71a0      	strb	r0, [r4, #6]
    d526:	8908      	ldrh	r0, [r1, #8]
    d528:	0a00      	lsrs	r0, r0, #8
    d52a:	71e0      	strb	r0, [r4, #7]
    d52c:	7a88      	ldrb	r0, [r1, #10]
    d52e:	7220      	strb	r0, [r4, #8]
    d530:	8948      	ldrh	r0, [r1, #10]
    d532:	0a00      	lsrs	r0, r0, #8
    d534:	7260      	strb	r0, [r4, #9]
    d536:	7b08      	ldrb	r0, [r1, #12]
    d538:	72a0      	strb	r0, [r4, #10]
    d53a:	8988      	ldrh	r0, [r1, #12]
    d53c:	0a00      	lsrs	r0, r0, #8
    d53e:	72e0      	strb	r0, [r4, #11]
    d540:	e0b6      	b.n	d6b0 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x308>
    d542:	7022      	strb	r2, [r4, #0]
    d544:	70a7      	strb	r7, [r4, #2]
    d546:	7908      	ldrb	r0, [r1, #4]
    d548:	70e0      	strb	r0, [r4, #3]
    d54a:	8888      	ldrh	r0, [r1, #4]
    d54c:	0a00      	lsrs	r0, r0, #8
    d54e:	7120      	strb	r0, [r4, #4]
    d550:	f8d1 0006 	ldr.w	r0, [r1, #6]
    d554:	f8c4 0005 	str.w	r0, [r4, #5]
    d558:	f8d1 000a 	ldr.w	r0, [r1, #10]
    d55c:	f8c4 0009 	str.w	r0, [r4, #9]
    d560:	89c8      	ldrh	r0, [r1, #14]
    d562:	f8a4 000d 	strh.w	r0, [r4, #13]
    d566:	e0c8      	b.n	d6fa <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x352>
    d568:	2011      	movs	r0, #17
    d56a:	e045      	b.n	d5f8 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x250>
    d56c:	7027      	strb	r7, [r4, #0]
    d56e:	7908      	ldrb	r0, [r1, #4]
    d570:	70a0      	strb	r0, [r4, #2]
    d572:	7948      	ldrb	r0, [r1, #5]
    d574:	70e0      	strb	r0, [r4, #3]
    d576:	f8b1 0005 	ldrh.w	r0, [r1, #5]
    d57a:	0a00      	lsrs	r0, r0, #8
    d57c:	7120      	strb	r0, [r4, #4]
    d57e:	79c8      	ldrb	r0, [r1, #7]
    d580:	e05a      	b.n	d638 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x290>
    d582:	2008      	movs	r0, #8
    d584:	7020      	strb	r0, [r4, #0]
    d586:	7908      	ldrb	r0, [r1, #4]
    d588:	70a0      	strb	r0, [r4, #2]
    d58a:	7988      	ldrb	r0, [r1, #6]
    d58c:	70e0      	strb	r0, [r4, #3]
    d58e:	88c8      	ldrh	r0, [r1, #6]
    d590:	0a00      	lsrs	r0, r0, #8
    d592:	7120      	strb	r0, [r4, #4]
    d594:	7a08      	ldrb	r0, [r1, #8]
    d596:	e04f      	b.n	d638 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x290>
    d598:	e09a      	b.n	d6d0 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x328>
    d59a:	e06e      	b.n	d67a <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x2d2>
    d59c:	e04f      	b.n	d63e <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x296>
    d59e:	e07a      	b.n	d696 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x2ee>
    d5a0:	e088      	b.n	d6b4 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x30c>
    d5a2:	e041      	b.n	d628 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x280>
    d5a4:	e030      	b.n	d608 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x260>
    d5a6:	e011      	b.n	d5cc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x224>
    d5a8:	e00d      	b.n	d5c6 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x21e>
    d5aa:	e024      	b.n	d5f6 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x24e>
    d5ac:	e01b      	b.n	d5e6 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x23e>
    d5ae:	e7ff      	b.n	d5b0 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x208>
    d5b0:	2030      	movs	r0, #48	; 0x30
    d5b2:	7020      	strb	r0, [r4, #0]
    d5b4:	7908      	ldrb	r0, [r1, #4]
    d5b6:	70a0      	strb	r0, [r4, #2]
    d5b8:	7988      	ldrb	r0, [r1, #6]
    d5ba:	70e0      	strb	r0, [r4, #3]
    d5bc:	88c8      	ldrh	r0, [r1, #6]
    d5be:	0a00      	lsrs	r0, r0, #8
    d5c0:	7120      	strb	r0, [r4, #4]
    d5c2:	2003      	movs	r0, #3
    d5c4:	e09a      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d5c6:	7022      	strb	r2, [r4, #0]
    d5c8:	2007      	movs	r0, #7
    d5ca:	e03a      	b.n	d642 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x29a>
    d5cc:	7022      	strb	r2, [r4, #0]
    d5ce:	70a6      	strb	r6, [r4, #2]
    d5d0:	7908      	ldrb	r0, [r1, #4]
    d5d2:	70e0      	strb	r0, [r4, #3]
    d5d4:	7988      	ldrb	r0, [r1, #6]
    d5d6:	7120      	strb	r0, [r4, #4]
    d5d8:	88c8      	ldrh	r0, [r1, #6]
    d5da:	0a00      	lsrs	r0, r0, #8
    d5dc:	7160      	strb	r0, [r4, #5]
    d5de:	7a08      	ldrb	r0, [r1, #8]
    d5e0:	71a0      	strb	r0, [r4, #6]
    d5e2:	7a48      	ldrb	r0, [r1, #9]
    d5e4:	e01d      	b.n	d622 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x27a>
    d5e6:	4620      	mov	r0, r4
    d5e8:	1d09      	adds	r1, r1, #4
    d5ea:	f7f7 feef 	bl	53cc <sym_MEYOCD6AYGN6BYYH5M35H6GLLMHM6TYBBTCW2LI+0xd8>
    d5ee:	2800      	cmp	r0, #0
    d5f0:	d109      	bne.n	d606 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x25e>
    d5f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d5f6:	2057      	movs	r0, #87	; 0x57
    d5f8:	7020      	strb	r0, [r4, #0]
    d5fa:	7908      	ldrb	r0, [r1, #4]
    d5fc:	70a0      	strb	r0, [r4, #2]
    d5fe:	8888      	ldrh	r0, [r1, #4]
    d600:	0a00      	lsrs	r0, r0, #8
    d602:	70e0      	strb	r0, [r4, #3]
    d604:	2002      	movs	r0, #2
    d606:	e079      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d608:	7022      	strb	r2, [r4, #0]
    d60a:	2012      	movs	r0, #18
    d60c:	70a0      	strb	r0, [r4, #2]
    d60e:	7908      	ldrb	r0, [r1, #4]
    d610:	70e0      	strb	r0, [r4, #3]
    d612:	7948      	ldrb	r0, [r1, #5]
    d614:	7120      	strb	r0, [r4, #4]
    d616:	7988      	ldrb	r0, [r1, #6]
    d618:	7160      	strb	r0, [r4, #5]
    d61a:	88c8      	ldrh	r0, [r1, #6]
    d61c:	0a00      	lsrs	r0, r0, #8
    d61e:	71a0      	strb	r0, [r4, #6]
    d620:	7a08      	ldrb	r0, [r1, #8]
    d622:	71e0      	strb	r0, [r4, #7]
    d624:	2006      	movs	r0, #6
    d626:	e069      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d628:	7023      	strb	r3, [r4, #0]
    d62a:	20a1      	movs	r0, #161	; 0xa1
    d62c:	70a0      	strb	r0, [r4, #2]
    d62e:	7908      	ldrb	r0, [r1, #4]
    d630:	70e0      	strb	r0, [r4, #3]
    d632:	7948      	ldrb	r0, [r1, #5]
    d634:	7120      	strb	r0, [r4, #4]
    d636:	2000      	movs	r0, #0
    d638:	7160      	strb	r0, [r4, #5]
    d63a:	2004      	movs	r0, #4
    d63c:	e05e      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d63e:	7023      	strb	r3, [r4, #0]
    d640:	20a2      	movs	r0, #162	; 0xa2
    d642:	70a0      	strb	r0, [r4, #2]
    d644:	7908      	ldrb	r0, [r1, #4]
    d646:	70e0      	strb	r0, [r4, #3]
    d648:	8888      	ldrh	r0, [r1, #4]
    d64a:	0a00      	lsrs	r0, r0, #8
    d64c:	7120      	strb	r0, [r4, #4]
    d64e:	7988      	ldrb	r0, [r1, #6]
    d650:	7160      	strb	r0, [r4, #5]
    d652:	88c8      	ldrh	r0, [r1, #6]
    d654:	0a00      	lsrs	r0, r0, #8
    d656:	71a0      	strb	r0, [r4, #6]
    d658:	7a08      	ldrb	r0, [r1, #8]
    d65a:	71e0      	strb	r0, [r4, #7]
    d65c:	8908      	ldrh	r0, [r1, #8]
    d65e:	0a00      	lsrs	r0, r0, #8
    d660:	7220      	strb	r0, [r4, #8]
    d662:	7a88      	ldrb	r0, [r1, #10]
    d664:	7260      	strb	r0, [r4, #9]
    d666:	8948      	ldrh	r0, [r1, #10]
    d668:	0a00      	lsrs	r0, r0, #8
    d66a:	72a0      	strb	r0, [r4, #10]
    d66c:	7b08      	ldrb	r0, [r1, #12]
    d66e:	72e0      	strb	r0, [r4, #11]
    d670:	8988      	ldrh	r0, [r1, #12]
    d672:	0a00      	lsrs	r0, r0, #8
    d674:	7320      	strb	r0, [r4, #12]
    d676:	200b      	movs	r0, #11
    d678:	e040      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d67a:	7023      	strb	r3, [r4, #0]
    d67c:	20a3      	movs	r0, #163	; 0xa3
    d67e:	70a0      	strb	r0, [r4, #2]
    d680:	7908      	ldrb	r0, [r1, #4]
    d682:	70e0      	strb	r0, [r4, #3]
    d684:	8888      	ldrh	r0, [r1, #4]
    d686:	0a00      	lsrs	r0, r0, #8
    d688:	7120      	strb	r0, [r4, #4]
    d68a:	7988      	ldrb	r0, [r1, #6]
    d68c:	7160      	strb	r0, [r4, #5]
    d68e:	79c8      	ldrb	r0, [r1, #7]
    d690:	71a0      	strb	r0, [r4, #6]
    d692:	2005      	movs	r0, #5
    d694:	e032      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d696:	7022      	strb	r2, [r4, #0]
    d698:	70a5      	strb	r5, [r4, #2]
    d69a:	7908      	ldrb	r0, [r1, #4]
    d69c:	70e0      	strb	r0, [r4, #3]
    d69e:	7948      	ldrb	r0, [r1, #5]
    d6a0:	7120      	strb	r0, [r4, #4]
    d6a2:	f8d1 0006 	ldr.w	r0, [r1, #6]
    d6a6:	f8c4 0005 	str.w	r0, [r4, #5]
    d6aa:	8948      	ldrh	r0, [r1, #10]
    d6ac:	f8a4 0009 	strh.w	r0, [r4, #9]
    d6b0:	200a      	movs	r0, #10
    d6b2:	e023      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d6b4:	7023      	strb	r3, [r4, #0]
    d6b6:	20a4      	movs	r0, #164	; 0xa4
    d6b8:	70a0      	strb	r0, [r4, #2]
    d6ba:	7908      	ldrb	r0, [r1, #4]
    d6bc:	70e0      	strb	r0, [r4, #3]
    d6be:	8888      	ldrh	r0, [r1, #4]
    d6c0:	0a00      	lsrs	r0, r0, #8
    d6c2:	7120      	strb	r0, [r4, #4]
    d6c4:	7988      	ldrb	r0, [r1, #6]
    d6c6:	7160      	strb	r0, [r4, #5]
    d6c8:	79c8      	ldrb	r0, [r1, #7]
    d6ca:	71a0      	strb	r0, [r4, #6]
    d6cc:	2007      	movs	r0, #7
    d6ce:	e015      	b.n	d6fc <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x354>
    d6d0:	7023      	strb	r3, [r4, #0]
    d6d2:	2080      	movs	r0, #128	; 0x80
    d6d4:	70a0      	strb	r0, [r4, #2]
    d6d6:	888a      	ldrh	r2, [r1, #4]
    d6d8:	f8a4 2003 	strh.w	r2, [r4, #3]
    d6dc:	88ca      	ldrh	r2, [r1, #6]
    d6de:	f8a4 2005 	strh.w	r2, [r4, #5]
    d6e2:	7a0a      	ldrb	r2, [r1, #8]
    d6e4:	71e2      	strb	r2, [r4, #7]
    d6e6:	894a      	ldrh	r2, [r1, #10]
    d6e8:	8122      	strh	r2, [r4, #8]
    d6ea:	898a      	ldrh	r2, [r1, #12]
    d6ec:	8162      	strh	r2, [r4, #10]
    d6ee:	89ca      	ldrh	r2, [r1, #14]
    d6f0:	81a2      	strh	r2, [r4, #12]
    d6f2:	7c09      	ldrb	r1, [r1, #16]
    d6f4:	f001 0101 	and.w	r1, r1, #1
    d6f8:	73a1      	strb	r1, [r4, #14]
    d6fa:	200d      	movs	r0, #13
    d6fc:	7060      	strb	r0, [r4, #1]
    d6fe:	1c80      	adds	r0, r0, #2
    d700:	e777      	b.n	d5f2 <sym_XMQQMVD4MD6DRWNW2DWSCGOMJHFY3IX7NXUHTGI+0x24a>

0000d702 <sym_3TBFCFZXCYDY6GUKVOWTISOQWWIRT2CJTYIBX5Y>:
    d702:	223e      	movs	r2, #62	; 0x3e
    d704:	7002      	strb	r2, [r0, #0]
    d706:	2201      	movs	r2, #1
    d708:	7082      	strb	r2, [r0, #2]
    d70a:	f811 2f04 	ldrb.w	r2, [r1, #4]!
    d70e:	70c2      	strb	r2, [r0, #3]
    d710:	788a      	ldrb	r2, [r1, #2]
    d712:	7102      	strb	r2, [r0, #4]
    d714:	884a      	ldrh	r2, [r1, #2]
    d716:	0a12      	lsrs	r2, r2, #8
    d718:	7142      	strb	r2, [r0, #5]
    d71a:	790a      	ldrb	r2, [r1, #4]
    d71c:	7182      	strb	r2, [r0, #6]
    d71e:	794a      	ldrb	r2, [r1, #5]
    d720:	71c2      	strb	r2, [r0, #7]
    d722:	f8d1 2006 	ldr.w	r2, [r1, #6]
    d726:	6082      	str	r2, [r0, #8]
    d728:	894a      	ldrh	r2, [r1, #10]
    d72a:	8182      	strh	r2, [r0, #12]
    d72c:	7e0a      	ldrb	r2, [r1, #24]
    d72e:	7382      	strb	r2, [r0, #14]
    d730:	8b0a      	ldrh	r2, [r1, #24]
    d732:	0a12      	lsrs	r2, r2, #8
    d734:	73c2      	strb	r2, [r0, #15]
    d736:	7e8a      	ldrb	r2, [r1, #26]
    d738:	7402      	strb	r2, [r0, #16]
    d73a:	8b4a      	ldrh	r2, [r1, #26]
    d73c:	0a12      	lsrs	r2, r2, #8
    d73e:	7442      	strb	r2, [r0, #17]
    d740:	7f0a      	ldrb	r2, [r1, #28]
    d742:	7482      	strb	r2, [r0, #18]
    d744:	8b8a      	ldrh	r2, [r1, #28]
    d746:	0a12      	lsrs	r2, r2, #8
    d748:	74c2      	strb	r2, [r0, #19]
    d74a:	7f89      	ldrb	r1, [r1, #30]
    d74c:	7501      	strb	r1, [r0, #20]
    d74e:	2113      	movs	r1, #19
    d750:	7041      	strb	r1, [r0, #1]
    d752:	4608      	mov	r0, r1
    d754:	4770      	bx	lr
    d756:	094a      	lsrs	r2, r1, #5
    d758:	f001 011f 	and.w	r1, r1, #31
    d75c:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
    d760:	40c8      	lsrs	r0, r1
    d762:	f000 0001 	and.w	r0, r0, #1
    d766:	4770      	bx	lr

0000d768 <sdc_hci_data_get>:
    d768:	b510      	push	{r4, lr}
    d76a:	b120      	cbz	r0, d776 <sdc_hci_data_get+0xe>
    d76c:	f7ff fd9a 	bl	d2a4 <sym_J4YPB5V427LGVECR3WQM2YMQSYACGT77QKJSI3I>
    d770:	b120      	cbz	r0, d77c <sdc_hci_data_get+0x14>
    d772:	2000      	movs	r0, #0
    d774:	bd10      	pop	{r4, pc}
    d776:	f06f 0015 	mvn.w	r0, #21
    d77a:	bd10      	pop	{r4, pc}
    d77c:	f06f 0022 	mvn.w	r0, #34	; 0x22
    d780:	bd10      	pop	{r4, pc}

0000d782 <sdc_hci_data_put>:
    d782:	b510      	push	{r4, lr}
    d784:	f06f 0415 	mvn.w	r4, #21
    d788:	b120      	cbz	r0, d794 <sdc_hci_data_put+0x12>
    d78a:	f7ff fd99 	bl	d2c0 <sym_PVKZWZJ5CJJGE5FITE5FOMMY5J4BUV2COWMQKSY>
    d78e:	b108      	cbz	r0, d794 <sdc_hci_data_put+0x12>
    d790:	2000      	movs	r0, #0
    d792:	bd10      	pop	{r4, pc}
    d794:	4620      	mov	r0, r4
    d796:	bd10      	pop	{r4, pc}

0000d798 <sdc_hci_evt_get>:
    d798:	b510      	push	{r4, lr}
    d79a:	b120      	cbz	r0, d7a6 <sdc_hci_evt_get+0xe>
    d79c:	f7ff fd99 	bl	d2d2 <sym_DUIEI4YTK3TJQ2V3W7PLOGVTWVPNDBBG4WJWTAQ>
    d7a0:	b120      	cbz	r0, d7ac <sdc_hci_evt_get+0x14>
    d7a2:	2000      	movs	r0, #0
    d7a4:	bd10      	pop	{r4, pc}
    d7a6:	f06f 0015 	mvn.w	r0, #21
    d7aa:	bd10      	pop	{r4, pc}
    d7ac:	f06f 0022 	mvn.w	r0, #34	; 0x22
    d7b0:	bd10      	pop	{r4, pc}

0000d7b2 <sdc_hci_get>:
    d7b2:	b118      	cbz	r0, d7bc <sdc_hci_get+0xa>
    d7b4:	b111      	cbz	r1, d7bc <sdc_hci_get+0xa>
    d7b6:	f06f 0022 	mvn.w	r0, #34	; 0x22
    d7ba:	4770      	bx	lr
    d7bc:	f06f 0015 	mvn.w	r0, #21
    d7c0:	4770      	bx	lr

0000d7c2 <sdc_hci_cmd_cb_read_authenticated_payload_timeout>:
    d7c2:	f002 bf30 	b.w	10626 <sym_AB3LPEZLZTHWVJYT4X3CSIX3UJONE76BJDZFP2Y>

0000d7c6 <sdc_hci_cmd_cb_read_transmit_power_level>:
    d7c6:	f002 bf7e 	b.w	106c6 <sym_Q3C2XSZVED7JHVMCJN53G6AXVXF3ZOUR7A37OEQ>

0000d7ca <sdc_hci_cmd_cb_set_event_mask>:
    d7ca:	b510      	push	{r4, lr}
    d7cc:	f7f7 fe4e 	bl	546c <sym_TU2SMBIUC7JL6C3K2XB6727DQLBLV5LEGIMZAFQ>
    d7d0:	2000      	movs	r0, #0
    d7d2:	bd10      	pop	{r4, pc}

0000d7d4 <sdc_hci_cmd_cb_set_event_mask_page_2>:
    d7d4:	b510      	push	{r4, lr}
    d7d6:	f7f7 fe59 	bl	548c <sym_CIVMWIRGIOQ374UFFPIFNN4ZGKYK2FRKTT6YRYA>
    d7da:	2000      	movs	r0, #0
    d7dc:	bd10      	pop	{r4, pc}

0000d7de <sdc_hci_cmd_cb_write_authenticated_payload_timeout>:
    d7de:	f002 bf8e 	b.w	106fe <sym_ULWM63O6UPJLQWAHX3MM6KEQT4NBSDWNEO3LSBY>

0000d7e2 <sdc_hci_cmd_vs_conn_event_extend>:
    d7e2:	b508      	push	{r3, lr}
    d7e4:	7800      	ldrb	r0, [r0, #0]
    d7e6:	f88d 0000 	strb.w	r0, [sp]
    d7ea:	4668      	mov	r0, sp
    d7ec:	f002 fe3c 	bl	10468 <sym_J2SUO2NMPPNDQZAGB2FE5TAXJFMJ5FZXKAPNVFQ>
    d7f0:	bd08      	pop	{r3, pc}

0000d7f2 <sdc_hci_cmd_vs_conn_update>:
    d7f2:	2001      	movs	r0, #1
    d7f4:	4770      	bx	lr

0000d7f6 <sdc_hci_cmd_vs_event_length_set>:
    d7f6:	f7fd bc55 	b.w	b0a4 <sym_DVVOECRRYK6EAGDREB2UKKQZT5MAOOUK66XNPTA>

0000d7fa <sdc_hci_cmd_vs_llpm_mode_set>:
    d7fa:	2001      	movs	r0, #1
    d7fc:	4770      	bx	lr

0000d7fe <sdc_hci_cmd_vs_peripheral_latency_mode_set>:
    d7fe:	7881      	ldrb	r1, [r0, #2]
    d800:	8800      	ldrh	r0, [r0, #0]
    d802:	f002 bdf9 	b.w	103f8 <sym_HZRUCXEK6VH2SKHLITFSCAH5JZW3VUS5CZD2RBY>

0000d806 <sdc_hci_cmd_vs_qos_conn_event_report_enable>:
    d806:	7800      	ldrb	r0, [r0, #0]
    d808:	b100      	cbz	r0, d80c <sdc_hci_cmd_vs_qos_conn_event_report_enable+0x6>
    d80a:	2001      	movs	r0, #1
    d80c:	f002 bdef 	b.w	103ee <sym_2USEL6R2GGJMMFO4XRNC6NIEFTFUU2HPLL2Z6FQ>

0000d810 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots>:
    d810:	b570      	push	{r4, r5, r6, lr}
    d812:	4605      	mov	r5, r0
    d814:	2210      	movs	r2, #16
    d816:	2100      	movs	r1, #0
    d818:	f7ff fc5a 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    d81c:	2210      	movs	r2, #16
    d81e:	2100      	movs	r1, #0
    d820:	f105 0010 	add.w	r0, r5, #16
    d824:	f7ff fc54 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    d828:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
    d82c:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
    d830:	1c40      	adds	r0, r0, #1
    d832:	d10b      	bne.n	d84c <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x3c>
    d834:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    d838:	1c40      	adds	r0, r0, #1
    d83a:	d107      	bne.n	d84c <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x3c>
    d83c:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
    d840:	1c40      	adds	r0, r0, #1
    d842:	d103      	bne.n	d84c <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x3c>
    d844:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
    d848:	1c40      	adds	r0, r0, #1
    d84a:	d00b      	beq.n	d864 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x54>
    d84c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    d850:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    d854:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
    d858:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    d85c:	612a      	str	r2, [r5, #16]
    d85e:	6168      	str	r0, [r5, #20]
    d860:	61a9      	str	r1, [r5, #24]
    d862:	61eb      	str	r3, [r5, #28]
    d864:	2000      	movs	r0, #0
    d866:	f7f8 fb57 	bl	5f18 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A>
    d86a:	b918      	cbnz	r0, d874 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x64>
    d86c:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
    d870:	07c0      	lsls	r0, r0, #31
    d872:	d118      	bne.n	d8a6 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x96>
    d874:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
    d878:	1c40      	adds	r0, r0, #1
    d87a:	d10b      	bne.n	d894 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x84>
    d87c:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
    d880:	1c40      	adds	r0, r0, #1
    d882:	d107      	bne.n	d894 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x84>
    d884:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
    d888:	1c40      	adds	r0, r0, #1
    d88a:	d103      	bne.n	d894 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x84>
    d88c:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    d890:	1c40      	adds	r0, r0, #1
    d892:	d008      	beq.n	d8a6 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots+0x96>
    d894:	f854 0f90 	ldr.w	r0, [r4, #144]!
    d898:	6861      	ldr	r1, [r4, #4]
    d89a:	68a2      	ldr	r2, [r4, #8]
    d89c:	68e3      	ldr	r3, [r4, #12]
    d89e:	6028      	str	r0, [r5, #0]
    d8a0:	6069      	str	r1, [r5, #4]
    d8a2:	60aa      	str	r2, [r5, #8]
    d8a4:	60eb      	str	r3, [r5, #12]
    d8a6:	2000      	movs	r0, #0
    d8a8:	bd70      	pop	{r4, r5, r6, pc}

0000d8aa <sdc_hci_cmd_vs_zephyr_read_static_addresses>:
    d8aa:	b538      	push	{r3, r4, r5, lr}
    d8ac:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    d8b0:	4604      	mov	r4, r0
    d8b2:	f8d5 00a4 	ldr.w	r0, [r5, #164]	; 0xa4
    d8b6:	1c40      	adds	r0, r0, #1
    d8b8:	d105      	bne.n	d8c6 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x1c>
    d8ba:	f8d5 00a8 	ldr.w	r0, [r5, #168]	; 0xa8
    d8be:	43c0      	mvns	r0, r0
    d8c0:	0400      	lsls	r0, r0, #16
    d8c2:	0c00      	lsrs	r0, r0, #16
    d8c4:	d03e      	beq.n	d944 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x9a>
    d8c6:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
    d8ca:	07c0      	lsls	r0, r0, #31
    d8cc:	d03a      	beq.n	d944 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x9a>
    d8ce:	f8d5 00a4 	ldr.w	r0, [r5, #164]	; 0xa4
    d8d2:	f8d5 10a8 	ldr.w	r1, [r5, #168]	; 0xa8
    d8d6:	f8ad 1000 	strh.w	r1, [sp]
    d8da:	f8c4 0001 	str.w	r0, [r4, #1]
    d8de:	f8bd 0000 	ldrh.w	r0, [sp]
    d8e2:	f8a4 0005 	strh.w	r0, [r4, #5]
    d8e6:	79a0      	ldrb	r0, [r4, #6]
    d8e8:	f040 00c0 	orr.w	r0, r0, #192	; 0xc0
    d8ec:	71a0      	strb	r0, [r4, #6]
    d8ee:	f8d5 0090 	ldr.w	r0, [r5, #144]	; 0x90
    d8f2:	1c40      	adds	r0, r0, #1
    d8f4:	d00f      	beq.n	d916 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x6c>
    d8f6:	f8d5 0094 	ldr.w	r0, [r5, #148]	; 0x94
    d8fa:	1c40      	adds	r0, r0, #1
    d8fc:	d00b      	beq.n	d916 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x6c>
    d8fe:	f8d5 0098 	ldr.w	r0, [r5, #152]	; 0x98
    d902:	1c40      	adds	r0, r0, #1
    d904:	d007      	beq.n	d916 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x6c>
    d906:	f8d5 009c 	ldr.w	r0, [r5, #156]	; 0x9c
    d90a:	1c40      	adds	r0, r0, #1
    d90c:	d003      	beq.n	d916 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x6c>
    d90e:	2000      	movs	r0, #0
    d910:	f7f8 fb02 	bl	5f18 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A>
    d914:	b140      	cbz	r0, d928 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x7e>
    d916:	2210      	movs	r2, #16
    d918:	2100      	movs	r1, #0
    d91a:	1de0      	adds	r0, r4, #7
    d91c:	f7ff fbd8 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    d920:	2001      	movs	r0, #1
    d922:	7020      	strb	r0, [r4, #0]
    d924:	2000      	movs	r0, #0
    d926:	bd38      	pop	{r3, r4, r5, pc}
    d928:	f855 2f90 	ldr.w	r2, [r5, #144]!
    d92c:	6869      	ldr	r1, [r5, #4]
    d92e:	68a8      	ldr	r0, [r5, #8]
    d930:	68eb      	ldr	r3, [r5, #12]
    d932:	f8c4 2007 	str.w	r2, [r4, #7]
    d936:	f8c4 100b 	str.w	r1, [r4, #11]
    d93a:	f8c4 000f 	str.w	r0, [r4, #15]
    d93e:	f8c4 3013 	str.w	r3, [r4, #19]
    d942:	e7ed      	b.n	d920 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x76>
    d944:	2000      	movs	r0, #0
    d946:	e7ec      	b.n	d922 <sdc_hci_cmd_vs_zephyr_read_static_addresses+0x78>

0000d948 <sdc_hci_cmd_vs_zephyr_write_bd_addr>:
    d948:	f002 bd80 	b.w	1044c <sym_4JSL5B25NNB5WWK7I5BGUTCTKEZ4HYLOODANEEQ>

0000d94c <sdc_hci_cmd_ip_read_bd_addr>:
    d94c:	f002 be7c 	b.w	10648 <sym_5KZ3ESY4NUZKM5COQRZJAL6CXWIG2JSPGHV3RPQ>

0000d950 <sdc_hci_cmd_ip_read_local_version_information>:
    d950:	f7fd bbb6 	b.w	b0c0 <sym_VBKW2EEGTD4JJSNUU73GLQHLYR7TWOGYRMQYZEY>

0000d954 <sdc_hci_cmd_le_add_device_to_filter_accept_list>:
    d954:	f002 bb3e 	b.w	ffd4 <sym_JNP3XPG2S47QWEENF5PX2JQ36HNB7C2PPNDBQRI>

0000d958 <sdc_hci_cmd_le_clear_filter_accept_list>:
    d958:	f002 bb53 	b.w	10002 <sym_UL6TXQTTOV34QCAIQPVPFYEQSUUJPIEN42CTITI>

0000d95c <sdc_hci_cmd_le_encrypt>:
    d95c:	f002 bb5b 	b.w	10016 <sym_V4G4DUSXVGCZMSYXHZZWQMKMNZCZVEEIBVCQ7EQ>

0000d960 <sdc_hci_cmd_le_long_term_key_request_negative_reply>:
    d960:	8802      	ldrh	r2, [r0, #0]
    d962:	800a      	strh	r2, [r1, #0]
    d964:	f002 bb60 	b.w	10028 <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA>

0000d968 <sdc_hci_cmd_le_long_term_key_request_reply>:
    d968:	8802      	ldrh	r2, [r0, #0]
    d96a:	800a      	strh	r2, [r1, #0]
    d96c:	f002 bb75 	b.w	1005a <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI>

0000d970 <sdc_hci_cmd_le_rand>:
    d970:	f002 bb9d 	b.w	100ae <sym_PMB4FUQR4IQVAL4FOP3PPQDDXYDFQIUYDVZ6DGY>

0000d974 <sdc_hci_cmd_le_read_adv_physical_channel_tx_power>:
    d974:	f002 bba1 	b.w	100ba <sym_IZN3QWH7I4A7OX5E6DK53W35W3UX25DTZ6CQ57Q>

0000d978 <sdc_hci_cmd_le_read_buffer_size>:
    d978:	f7fd ba9a 	b.w	aeb0 <sym_Y5RIWFUVP4FHJFYC7FBZKM2MV7INK43TLWQ5URA>

0000d97c <sdc_hci_cmd_le_read_channel_map>:
    d97c:	f7fd baa2 	b.w	aec4 <sym_PAQFQMAKUCMOA6SUTJ7CAX3DYCWNAJLJQFJCDNY>

0000d980 <sdc_hci_cmd_le_read_filter_accept_list_size>:
    d980:	f002 bbd2 	b.w	10128 <sym_5OKDNHIYSDG2NFFB242VCRESG3W37YENBGQLRBA>

0000d984 <sdc_hci_cmd_le_read_max_data_length>:
    d984:	f002 bba2 	b.w	100cc <sym_IS5N626FV5MT54PZIWSKFZUUH6WWJWJ46G6YN3A>

0000d988 <sdc_hci_cmd_le_read_phy>:
    d988:	f7fd bac4 	b.w	af14 <sym_VT6ZFFM2E7JNVAG5YLSPAZYR4HOPL3X5GX3IH7A>

0000d98c <sdc_hci_cmd_le_read_remote_features>:
    d98c:	f002 bba7 	b.w	100de <sym_CT735EXQUXWPD7TNRP2WWTA3LGLYUEOZMPS7RMI>

0000d990 <sdc_hci_cmd_le_read_suggested_default_data_length>:
    d990:	f7fd bae6 	b.w	af60 <sym_THL6EKGE7AKTO5JDGU45MV33YSIXORBRMDECS2Q>

0000d994 <sdc_hci_cmd_le_read_transmit_power>:
    d994:	f002 bbbf 	b.w	10116 <sym_KQ364TAUBSTGBVLC6BUZ6LU5UQACEISDV2KKO5I>

0000d998 <sdc_hci_cmd_le_remove_device_from_filter_accept_list>:
    d998:	f002 bbca 	b.w	10130 <sym_FQNF6KMIBMQDKYS2BJP6ZB7BLEET53WUIWQK6FA>

0000d99c <sdc_hci_cmd_le_set_adv_data>:
    d99c:	f002 bbdd 	b.w	1015a <sym_KXE6R52JHXVKOK6AHXAXVCPJHWR4FK73UB2AK7I>

0000d9a0 <sdc_hci_cmd_le_set_adv_enable>:
    d9a0:	f002 bbf0 	b.w	10184 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ>

0000d9a4 <sdc_hci_cmd_le_set_adv_params>:
    d9a4:	f002 bc21 	b.w	101ea <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI>

0000d9a8 <sdc_hci_cmd_le_set_data_length>:
    d9a8:	f002 bcb4 	b.w	10314 <sym_Q5GJELDUJDXPR5M7PG33JSPACOMZ32BYQV2DESA>

0000d9ac <sdc_hci_cmd_le_set_default_phy>:
    d9ac:	f7fd bae2 	b.w	af74 <sym_4POEZKL66A5T3356722OWKNB5CNFKPMV6JI3HEA>

0000d9b0 <sdc_hci_cmd_le_set_event_mask>:
    d9b0:	b510      	push	{r4, lr}
    d9b2:	f7f7 fd53 	bl	545c <sym_PPT6FEOF2T6DRALMCRRTUI7CHLEPBAN25HYV3KQ>
    d9b6:	2000      	movs	r0, #0
    d9b8:	bd10      	pop	{r4, pc}

0000d9ba <sdc_hci_cmd_le_set_phy>:
    d9ba:	f002 bccb 	b.w	10354 <sym_MBHLAUPQK3H6ERLQXCLUB2AQHB6N7MDDZSUQGSI>

0000d9be <sdc_hci_cmd_le_set_random_address>:
    d9be:	f002 bce2 	b.w	10386 <sym_NITRJIWYGM7PLEIQEII3QZID3O3DS62GXB3UYIA>

0000d9c2 <sdc_hci_cmd_le_set_scan_response_data>:
    d9c2:	f002 bcee 	b.w	103a2 <sym_XYKOVFYGOSL56Y753SKDQGINYTUFZGQJGBB54WI>

0000d9c6 <sdc_hci_cmd_le_write_suggested_default_data_length>:
    d9c6:	f002 bd01 	b.w	103cc <sym_JYVNTINWWHBNIBW6ZPFJYFKZBQTI25EUE75U36Y>

0000d9ca <sdc_hci_cmd_lc_disconnect>:
    d9ca:	f002 bab5 	b.w	ff38 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ>

0000d9ce <sdc_hci_cmd_lc_read_remote_version_information>:
    d9ce:	f002 be47 	b.w	10660 <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY>
    d9d2:	b570      	push	{r4, r5, r6, lr}
    d9d4:	880b      	ldrh	r3, [r1, #0]
    d9d6:	7f04      	ldrb	r4, [r0, #28]
    d9d8:	f100 0524 	add.w	r5, r0, #36	; 0x24
    d9dc:	f3c3 060e 	ubfx	r6, r3, #0, #15
    d9e0:	8802      	ldrh	r2, [r0, #0]
    d9e2:	4435      	add	r5, r6
    d9e4:	1da4      	adds	r4, r4, #6
    d9e6:	882d      	ldrh	r5, [r5, #0]
    d9e8:	4422      	add	r2, r4
    d9ea:	b292      	uxth	r2, r2
    d9ec:	4425      	add	r5, r4
    d9ee:	1e54      	subs	r4, r2, #1
    d9f0:	442c      	add	r4, r5
    d9f2:	fb94 f4f2 	sdiv	r4, r4, r2
    d9f6:	fb02 6204 	mla	r2, r2, r4, r6
    d9fa:	8840      	ldrh	r0, [r0, #2]
    d9fc:	b292      	uxth	r2, r2
    d9fe:	4290      	cmp	r0, r2
    da00:	d903      	bls.n	da0a <sdc_hci_cmd_lc_read_remote_version_information+0x3c>
    da02:	f403 4000 	and.w	r0, r3, #32768	; 0x8000
    da06:	4310      	orrs	r0, r2
    da08:	e002      	b.n	da10 <sdc_hci_cmd_lc_read_remote_version_information+0x42>
    da0a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    da0e:	4398      	bics	r0, r3
    da10:	8008      	strh	r0, [r1, #0]
    da12:	bd70      	pop	{r4, r5, r6, pc}
    da14:	0442      	lsls	r2, r0, #17
    da16:	ebb2 4f41 	cmp.w	r2, r1, lsl #17
    da1a:	d107      	bne.n	da2c <sdc_hci_cmd_lc_read_remote_version_information+0x5e>
    da1c:	f400 4000 	and.w	r0, r0, #32768	; 0x8000
    da20:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
    da24:	4288      	cmp	r0, r1
    da26:	d001      	beq.n	da2c <sdc_hci_cmd_lc_read_remote_version_information+0x5e>
    da28:	2001      	movs	r0, #1
    da2a:	4770      	bx	lr
    da2c:	2000      	movs	r0, #0
    da2e:	4770      	bx	lr

0000da30 <sym_BZ7Z4RQ3DCP67RU5HKR6L76AI2EU62TP34WUI5Q>:
    da30:	b570      	push	{r4, r5, r6, lr}
    da32:	7f00      	ldrb	r0, [r0, #28]
    da34:	461c      	mov	r4, r3
    da36:	1d80      	adds	r0, r0, #6
    da38:	4408      	add	r0, r1
    da3a:	4613      	mov	r3, r2
    da3c:	8809      	ldrh	r1, [r1, #0]
    da3e:	9a04      	ldr	r2, [sp, #16]
    da40:	1cc9      	adds	r1, r1, #3
    da42:	b289      	uxth	r1, r1
    da44:	1915      	adds	r5, r2, r4
    da46:	1ec0      	subs	r0, r0, #3
    da48:	428d      	cmp	r5, r1
    da4a:	d805      	bhi.n	da58 <sym_BZ7Z4RQ3DCP67RU5HKR6L76AI2EU62TP34WUI5Q+0x28>
    da4c:	1881      	adds	r1, r0, r2
    da4e:	4622      	mov	r2, r4
    da50:	4618      	mov	r0, r3
    da52:	f7ff fac3 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    da56:	e000      	b.n	da5a <sym_BZ7Z4RQ3DCP67RU5HKR6L76AI2EU62TP34WUI5Q+0x2a>
    da58:	2400      	movs	r4, #0
    da5a:	4620      	mov	r0, r4
    da5c:	bd70      	pop	{r4, r5, r6, pc}

0000da5e <sym_KYAZRCYN475PHPCZD6L3YCVO72SQVA3SBOAY44Q>:
    da5e:	b570      	push	{r4, r5, r6, lr}
    da60:	7f00      	ldrb	r0, [r0, #28]
    da62:	461c      	mov	r4, r3
    da64:	1d80      	adds	r0, r0, #6
    da66:	4408      	add	r0, r1
    da68:	4613      	mov	r3, r2
    da6a:	8809      	ldrh	r1, [r1, #0]
    da6c:	9a04      	ldr	r2, [sp, #16]
    da6e:	1cc9      	adds	r1, r1, #3
    da70:	b289      	uxth	r1, r1
    da72:	1915      	adds	r5, r2, r4
    da74:	1ec0      	subs	r0, r0, #3
    da76:	428d      	cmp	r5, r1
    da78:	d805      	bhi.n	da86 <sym_KYAZRCYN475PHPCZD6L3YCVO72SQVA3SBOAY44Q+0x28>
    da7a:	4410      	add	r0, r2
    da7c:	4622      	mov	r2, r4
    da7e:	4619      	mov	r1, r3
    da80:	f7ff faac 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    da84:	e000      	b.n	da88 <sym_KYAZRCYN475PHPCZD6L3YCVO72SQVA3SBOAY44Q+0x2a>
    da86:	2400      	movs	r4, #0
    da88:	4620      	mov	r0, r4
    da8a:	bd70      	pop	{r4, r5, r6, pc}

0000da8c <sym_B62EJKCCJ4JFC5I4BFTUJG7GNOKGWQ4KKFBS6RI>:
    da8c:	8881      	ldrh	r1, [r0, #4]
    da8e:	88c0      	ldrh	r0, [r0, #6]
    da90:	4288      	cmp	r0, r1
    da92:	d101      	bne.n	da98 <sym_B62EJKCCJ4JFC5I4BFTUJG7GNOKGWQ4KKFBS6RI+0xc>
    da94:	2001      	movs	r0, #1
    da96:	4770      	bx	lr
    da98:	2000      	movs	r0, #0
    da9a:	4770      	bx	lr

0000da9c <sym_WHJLTAWCA7L5AI7ZKZA7BNI7MYWDHIXTL45XGEI>:
    da9c:	8881      	ldrh	r1, [r0, #4]
    da9e:	8900      	ldrh	r0, [r0, #8]
    daa0:	4288      	cmp	r0, r1
    daa2:	d101      	bne.n	daa8 <sym_WHJLTAWCA7L5AI7ZKZA7BNI7MYWDHIXTL45XGEI+0xc>
    daa4:	2001      	movs	r0, #1
    daa6:	4770      	bx	lr
    daa8:	2000      	movs	r0, #0
    daaa:	4770      	bx	lr

0000daac <sym_UOYZDE3MDLGPDL5S5WKUFLPYH4DJIMF3BJSBDYA>:
    daac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dab0:	460f      	mov	r7, r1
    dab2:	4604      	mov	r4, r0
    dab4:	f100 0124 	add.w	r1, r0, #36	; 0x24
    dab8:	8880      	ldrh	r0, [r0, #4]
    daba:	2600      	movs	r6, #0
    dabc:	f3c0 000e 	ubfx	r0, r0, #0, #15
    dac0:	1845      	adds	r5, r0, r1
    dac2:	603e      	str	r6, [r7, #0]
    dac4:	8a20      	ldrh	r0, [r4, #16]
    dac6:	2800      	cmp	r0, #0
    dac8:	d01a      	beq.n	db00 <sym_UOYZDE3MDLGPDL5S5WKUFLPYH4DJIMF3BJSBDYA+0x54>
    daca:	89a1      	ldrh	r1, [r4, #12]
    dacc:	4408      	add	r0, r1
    dace:	b280      	uxth	r0, r0
    dad0:	81a0      	strh	r0, [r4, #12]
    dad2:	8829      	ldrh	r1, [r5, #0]
    dad4:	4288      	cmp	r0, r1
    dad6:	d905      	bls.n	dae4 <sym_UOYZDE3MDLGPDL5S5WKUFLPYH4DJIMF3BJSBDYA+0x38>
    dad8:	f44f 71b3 	mov.w	r1, #358	; 0x166
    dadc:	f04f 0014 	mov.w	r0, #20
    dae0:	f7f7 fb38 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    dae4:	d10a      	bne.n	dafc <sym_UOYZDE3MDLGPDL5S5WKUFLPYH4DJIMF3BJSBDYA+0x50>
    dae6:	69a0      	ldr	r0, [r4, #24]
    dae8:	b108      	cbz	r0, daee <sym_UOYZDE3MDLGPDL5S5WKUFLPYH4DJIMF3BJSBDYA+0x42>
    daea:	7f40      	ldrb	r0, [r0, #29]
    daec:	70a8      	strb	r0, [r5, #2]
    daee:	f104 0104 	add.w	r1, r4, #4
    daf2:	4620      	mov	r0, r4
    daf4:	f7ff ff6d 	bl	d9d2 <sdc_hci_cmd_lc_read_remote_version_information+0x4>
    daf8:	81a6      	strh	r6, [r4, #12]
    dafa:	603d      	str	r5, [r7, #0]
    dafc:	8226      	strh	r6, [r4, #16]
    dafe:	2001      	movs	r0, #1
    db00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000db04 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y>:
    db04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    db06:	4604      	mov	r4, r0
    db08:	f100 0324 	add.w	r3, r0, #36	; 0x24
    db0c:	88c0      	ldrh	r0, [r0, #6]
    db0e:	460e      	mov	r6, r1
    db10:	f3c0 070e 	ubfx	r7, r0, #0, #15
    db14:	8a60      	ldrh	r0, [r4, #18]
    db16:	19d9      	adds	r1, r3, r7
    db18:	b108      	cbz	r0, db1e <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0x1a>
    db1a:	42b0      	cmp	r0, r6
    db1c:	d201      	bcs.n	db22 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0x1e>
    db1e:	2000      	movs	r0, #0
    db20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    db22:	89e0      	ldrh	r0, [r4, #14]
    db24:	2500      	movs	r5, #0
    db26:	b140      	cbz	r0, db3a <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0x36>
    db28:	f8b1 c000 	ldrh.w	ip, [r1]
    db2c:	4560      	cmp	r0, ip
    db2e:	d008      	beq.n	db42 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0x3e>
    db30:	f240 2151 	movw	r1, #593	; 0x251
    db34:	2014      	movs	r0, #20
    db36:	f7f7 fb0d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    db3a:	7f60      	ldrb	r0, [r4, #29]
    db3c:	7088      	strb	r0, [r1, #2]
    db3e:	800d      	strh	r5, [r1, #0]
    db40:	e00e      	b.n	db60 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0x5c>
    db42:	f894 c01c 	ldrb.w	ip, [r4, #28]
    db46:	4418      	add	r0, r3
    db48:	f10c 0c06 	add.w	ip, ip, #6
    db4c:	44bc      	add	ip, r7
    db4e:	4460      	add	r0, ip
    db50:	f8b4 c01e 	ldrh.w	ip, [r4, #30]
    db54:	f820 cc03 	strh.w	ip, [r0, #-3]
    db58:	f894 c020 	ldrb.w	ip, [r4, #32]
    db5c:	f800 cc01 	strb.w	ip, [r0, #-1]
    db60:	89e0      	ldrh	r0, [r4, #14]
    db62:	4430      	add	r0, r6
    db64:	81e0      	strh	r0, [r4, #14]
    db66:	8808      	ldrh	r0, [r1, #0]
    db68:	4430      	add	r0, r6
    db6a:	8008      	strh	r0, [r1, #0]
    db6c:	b19a      	cbz	r2, db96 <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0x92>
    db6e:	1da1      	adds	r1, r4, #6
    db70:	4620      	mov	r0, r4
    db72:	f7ff ff2e 	bl	d9d2 <sdc_hci_cmd_lc_read_remote_version_information+0x4>
    db76:	81e5      	strh	r5, [r4, #14]
    db78:	7f60      	ldrb	r0, [r4, #29]
    db7a:	1c40      	adds	r0, r0, #1
    db7c:	7760      	strb	r0, [r4, #29]
    db7e:	7da0      	ldrb	r0, [r4, #22]
    db80:	f88d 0000 	strb.w	r0, [sp]
    db84:	9800      	ldr	r0, [sp, #0]
    db86:	9000      	str	r0, [sp, #0]
    db88:	f89d 0000 	ldrb.w	r0, [sp]
    db8c:	b178      	cbz	r0, dbae <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0xaa>
    db8e:	88e0      	ldrh	r0, [r4, #6]
    db90:	82a0      	strh	r0, [r4, #20]
    db92:	75a5      	strb	r5, [r4, #22]
    db94:	e00b      	b.n	dbae <sym_3LZ364FVGUVSOSH6XGIFMW5SY36X7BQXDOES46Y+0xaa>
    db96:	7f20      	ldrb	r0, [r4, #28]
    db98:	89e1      	ldrh	r1, [r4, #14]
    db9a:	1d80      	adds	r0, r0, #6
    db9c:	4438      	add	r0, r7
    db9e:	4419      	add	r1, r3
    dba0:	4408      	add	r0, r1
    dba2:	f830 1d03 	ldrh.w	r1, [r0, #-3]!
    dba6:	83e1      	strh	r1, [r4, #30]
    dba8:	7880      	ldrb	r0, [r0, #2]
    dbaa:	f884 0020 	strb.w	r0, [r4, #32]
    dbae:	8265      	strh	r5, [r4, #18]
    dbb0:	2001      	movs	r0, #1
    dbb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000dbb4 <sym_UPAEGKLCM3QW7VHROMMVD5MIRBTM2NGCYENWSLI>:
    dbb4:	1cc0      	adds	r0, r0, #3
    dbb6:	4770      	bx	lr

0000dbb8 <sym_Q4EW623JZHY67RB7U4Z2L2SMI5ENWIDFL23JZHQ>:
    dbb8:	b510      	push	{r4, lr}
    dbba:	4604      	mov	r4, r0
    dbbc:	88c0      	ldrh	r0, [r0, #6]
    dbbe:	88a1      	ldrh	r1, [r4, #4]
    dbc0:	4281      	cmp	r1, r0
    dbc2:	d007      	beq.n	dbd4 <sym_Q4EW623JZHY67RB7U4Z2L2SMI5ENWIDFL23JZHQ+0x1c>
    dbc4:	89a0      	ldrh	r0, [r4, #12]
    dbc6:	b928      	cbnz	r0, dbd4 <sym_Q4EW623JZHY67RB7U4Z2L2SMI5ENWIDFL23JZHQ+0x1c>
    dbc8:	8a20      	ldrh	r0, [r4, #16]
    dbca:	b918      	cbnz	r0, dbd4 <sym_Q4EW623JZHY67RB7U4Z2L2SMI5ENWIDFL23JZHQ+0x1c>
    dbcc:	88a0      	ldrh	r0, [r4, #4]
    dbce:	8aa1      	ldrh	r1, [r4, #20]
    dbd0:	4288      	cmp	r0, r1
    dbd2:	d101      	bne.n	dbd8 <sym_Q4EW623JZHY67RB7U4Z2L2SMI5ENWIDFL23JZHQ+0x20>
    dbd4:	2000      	movs	r0, #0
    dbd6:	bd10      	pop	{r4, pc}
    dbd8:	1d21      	adds	r1, r4, #4
    dbda:	4620      	mov	r0, r4
    dbdc:	f7ff fef9 	bl	d9d2 <sdc_hci_cmd_lc_read_remote_version_information+0x4>
    dbe0:	2000      	movs	r0, #0
    dbe2:	8220      	strh	r0, [r4, #16]
    dbe4:	2001      	movs	r0, #1
    dbe6:	bd10      	pop	{r4, pc}

0000dbe8 <sym_TDLIKQLE652KPCFAMYL33G6BKGPHRLYLWNEOTHQ>:
    dbe8:	b510      	push	{r4, lr}
    dbea:	4604      	mov	r4, r0
    dbec:	f100 0224 	add.w	r2, r0, #36	; 0x24
    dbf0:	88c0      	ldrh	r0, [r0, #6]
    dbf2:	f3c0 000e 	ubfx	r0, r0, #0, #15
    dbf6:	4402      	add	r2, r0
    dbf8:	8820      	ldrh	r0, [r4, #0]
    dbfa:	2845      	cmp	r0, #69	; 0x45
    dbfc:	d200      	bcs.n	dc00 <sym_TDLIKQLE652KPCFAMYL33G6BKGPHRLYLWNEOTHQ+0x18>
    dbfe:	2045      	movs	r0, #69	; 0x45
    dc00:	4288      	cmp	r0, r1
    dc02:	d204      	bcs.n	dc0e <sym_TDLIKQLE652KPCFAMYL33G6BKGPHRLYLWNEOTHQ+0x26>
    dc04:	f240 1119 	movw	r1, #281	; 0x119
    dc08:	2014      	movs	r0, #20
    dc0a:	f7f7 faa3 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    dc0e:	7de0      	ldrb	r0, [r4, #23]
    dc10:	2800      	cmp	r0, #0
    dc12:	d003      	beq.n	dc1c <sym_TDLIKQLE652KPCFAMYL33G6BKGPHRLYLWNEOTHQ+0x34>
    dc14:	8810      	ldrh	r0, [r2, #0]
    dc16:	4288      	cmp	r0, r1
    dc18:	d201      	bcs.n	dc1e <sym_TDLIKQLE652KPCFAMYL33G6BKGPHRLYLWNEOTHQ+0x36>
    dc1a:	2000      	movs	r0, #0
    dc1c:	bd10      	pop	{r4, pc}
    dc1e:	8011      	strh	r1, [r2, #0]
    dc20:	1da1      	adds	r1, r4, #6
    dc22:	4620      	mov	r0, r4
    dc24:	f7ff fed5 	bl	d9d2 <sdc_hci_cmd_lc_read_remote_version_information+0x4>
    dc28:	2000      	movs	r0, #0
    dc2a:	75e0      	strb	r0, [r4, #23]
    dc2c:	2001      	movs	r0, #1
    dc2e:	bd10      	pop	{r4, pc}

0000dc30 <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I>:
    dc30:	b530      	push	{r4, r5, lr}
    dc32:	88c4      	ldrh	r4, [r0, #6]
    dc34:	8881      	ldrh	r1, [r0, #4]
    dc36:	f100 0224 	add.w	r2, r0, #36	; 0x24
    dc3a:	f3c1 030e 	ubfx	r3, r1, #0, #15
    dc3e:	4413      	add	r3, r2
    dc40:	8882      	ldrh	r2, [r0, #4]
    dc42:	8a85      	ldrh	r5, [r0, #20]
    dc44:	42aa      	cmp	r2, r5
    dc46:	d012      	beq.n	dc6e <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I+0x3e>
    dc48:	42a1      	cmp	r1, r4
    dc4a:	d010      	beq.n	dc6e <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I+0x3e>
    dc4c:	8981      	ldrh	r1, [r0, #12]
    dc4e:	b971      	cbnz	r1, dc6e <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I+0x3e>
    dc50:	6982      	ldr	r2, [r0, #24]
    dc52:	b172      	cbz	r2, dc72 <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I+0x42>
    dc54:	4610      	mov	r0, r2
    dc56:	f7ff ff21 	bl	da9c <sym_WHJLTAWCA7L5AI7ZKZA7BNI7MYWDHIXTL45XGEI>
    dc5a:	b950      	cbnz	r0, dc72 <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I+0x42>
    dc5c:	8910      	ldrh	r0, [r2, #8]
    dc5e:	3224      	adds	r2, #36	; 0x24
    dc60:	f3c0 000e 	ubfx	r0, r0, #0, #15
    dc64:	4410      	add	r0, r2
    dc66:	7899      	ldrb	r1, [r3, #2]
    dc68:	7880      	ldrb	r0, [r0, #2]
    dc6a:	4288      	cmp	r0, r1
    dc6c:	d101      	bne.n	dc72 <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I+0x42>
    dc6e:	2000      	movs	r0, #0
    dc70:	bd30      	pop	{r4, r5, pc}
    dc72:	4618      	mov	r0, r3
    dc74:	bd30      	pop	{r4, r5, pc}

0000dc76 <sym_DY52YMZFQPMDNFDSVZDQLPFIWKOSXIQIEKUVZNY>:
    dc76:	7f00      	ldrb	r0, [r0, #28]
    dc78:	1d80      	adds	r0, r0, #6
    dc7a:	4408      	add	r0, r1
    dc7c:	1ec0      	subs	r0, r0, #3
    dc7e:	6010      	str	r0, [r2, #0]
    dc80:	8808      	ldrh	r0, [r1, #0]
    dc82:	4770      	bx	lr

0000dc84 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY>:
    dc84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dc88:	460e      	mov	r6, r1
    dc8a:	88c1      	ldrh	r1, [r0, #6]
    dc8c:	8902      	ldrh	r2, [r0, #8]
    dc8e:	4604      	mov	r4, r0
    dc90:	f100 0824 	add.w	r8, r0, #36	; 0x24
    dc94:	8800      	ldrh	r0, [r0, #0]
    dc96:	f3c1 050e 	ubfx	r5, r1, #0, #15
    dc9a:	f3c2 070e 	ubfx	r7, r2, #0, #15
    dc9e:	2845      	cmp	r0, #69	; 0x45
    dca0:	d200      	bcs.n	dca4 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x20>
    dca2:	2045      	movs	r0, #69	; 0x45
    dca4:	42b0      	cmp	r0, r6
    dca6:	d203      	bcs.n	dcb0 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x2c>
    dca8:	21db      	movs	r1, #219	; 0xdb
    dcaa:	2014      	movs	r0, #20
    dcac:	f7f7 fa52 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    dcb0:	4610      	mov	r0, r2
    dcb2:	f7ff feaf 	bl	da14 <sdc_hci_cmd_lc_read_remote_version_information+0x46>
    dcb6:	b110      	cbz	r0, dcbe <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x3a>
    dcb8:	2000      	movs	r0, #0
    dcba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    dcbe:	42af      	cmp	r7, r5
    dcc0:	d908      	bls.n	dcd4 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x50>
    dcc2:	7f21      	ldrb	r1, [r4, #28]
    dcc4:	1b78      	subs	r0, r7, r5
    dcc6:	1a40      	subs	r0, r0, r1
    dcc8:	1f80      	subs	r0, r0, #6
    dcca:	4286      	cmp	r6, r0
    dccc:	dd02      	ble.n	dcd4 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x50>
    dcce:	2000      	movs	r0, #0
    dcd0:	75e0      	strb	r0, [r4, #23]
    dcd2:	e7f1      	b.n	dcb8 <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x34>
    dcd4:	eb08 0005 	add.w	r0, r8, r5
    dcd8:	2101      	movs	r1, #1
    dcda:	8006      	strh	r6, [r0, #0]
    dcdc:	75e1      	strb	r1, [r4, #23]
    dcde:	e7ec      	b.n	dcba <sym_XCF2HHS4DO2JW2ILCF4RJW66HXXYOROBK7NUPMY+0x36>

0000dce0 <sym_4WKKRRMMNLQOCTRGC2MVIREG5QOCFUEL67TBUQY>:
    dce0:	b538      	push	{r3, r4, r5, lr}
    dce2:	88c4      	ldrh	r4, [r0, #6]
    dce4:	8881      	ldrh	r1, [r0, #4]
    dce6:	f100 0224 	add.w	r2, r0, #36	; 0x24
    dcea:	f3c1 030e 	ubfx	r3, r1, #0, #15
    dcee:	441a      	add	r2, r3
    dcf0:	42a1      	cmp	r1, r4
    dcf2:	d010      	beq.n	dd16 <sym_4WKKRRMMNLQOCTRGC2MVIREG5QOCFUEL67TBUQY+0x36>
    dcf4:	8983      	ldrh	r3, [r0, #12]
    dcf6:	8a05      	ldrh	r5, [r0, #16]
    dcf8:	8812      	ldrh	r2, [r2, #0]
    dcfa:	442b      	add	r3, r5
    dcfc:	4293      	cmp	r3, r2
    dcfe:	d308      	bcc.n	dd12 <sym_4WKKRRMMNLQOCTRGC2MVIREG5QOCFUEL67TBUQY+0x32>
    dd00:	f8ad 1000 	strh.w	r1, [sp]
    dd04:	4669      	mov	r1, sp
    dd06:	f7ff fe64 	bl	d9d2 <sdc_hci_cmd_lc_read_remote_version_information+0x4>
    dd0a:	f8bd 0000 	ldrh.w	r0, [sp]
    dd0e:	42a0      	cmp	r0, r4
    dd10:	d001      	beq.n	dd16 <sym_4WKKRRMMNLQOCTRGC2MVIREG5QOCFUEL67TBUQY+0x36>
    dd12:	2001      	movs	r0, #1
    dd14:	bd38      	pop	{r3, r4, r5, pc}
    dd16:	2000      	movs	r0, #0
    dd18:	bd38      	pop	{r3, r4, r5, pc}

0000dd1a <sym_47GVMLF7NXDJBYC2TPU2ES3ZL6CP4GIPWKYYWBI>:
    dd1a:	b570      	push	{r4, r5, r6, lr}
    dd1c:	88c6      	ldrh	r6, [r0, #6]
    dd1e:	8885      	ldrh	r5, [r0, #4]
    dd20:	4603      	mov	r3, r0
    dd22:	f100 0424 	add.w	r4, r0, #36	; 0x24
    dd26:	f3c5 000e 	ubfx	r0, r5, #0, #15
    dd2a:	4420      	add	r0, r4
    dd2c:	42b5      	cmp	r5, r6
    dd2e:	d102      	bne.n	dd36 <sym_47GVMLF7NXDJBYC2TPU2ES3ZL6CP4GIPWKYYWBI+0x1c>
    dd30:	2000      	movs	r0, #0
    dd32:	8218      	strh	r0, [r3, #16]
    dd34:	bd70      	pop	{r4, r5, r6, pc}
    dd36:	8804      	ldrh	r4, [r0, #0]
    dd38:	899d      	ldrh	r5, [r3, #12]
    dd3a:	7f1e      	ldrb	r6, [r3, #28]
    dd3c:	1b64      	subs	r4, r4, r5
    dd3e:	4435      	add	r5, r6
    dd40:	4428      	add	r0, r5
    dd42:	880d      	ldrh	r5, [r1, #0]
    dd44:	b2a4      	uxth	r4, r4
    dd46:	1cc0      	adds	r0, r0, #3
    dd48:	42a5      	cmp	r5, r4
    dd4a:	d900      	bls.n	dd4e <sym_47GVMLF7NXDJBYC2TPU2ES3ZL6CP4GIPWKYYWBI+0x34>
    dd4c:	800c      	strh	r4, [r1, #0]
    dd4e:	899c      	ldrh	r4, [r3, #12]
    dd50:	b124      	cbz	r4, dd5c <sym_47GVMLF7NXDJBYC2TPU2ES3ZL6CP4GIPWKYYWBI+0x42>
    dd52:	2400      	movs	r4, #0
    dd54:	7014      	strb	r4, [r2, #0]
    dd56:	8809      	ldrh	r1, [r1, #0]
    dd58:	8219      	strh	r1, [r3, #16]
    dd5a:	bd70      	pop	{r4, r5, r6, pc}
    dd5c:	2401      	movs	r4, #1
    dd5e:	e7f9      	b.n	dd54 <sym_47GVMLF7NXDJBYC2TPU2ES3ZL6CP4GIPWKYYWBI+0x3a>

0000dd60 <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY>:
    dd60:	b508      	push	{r3, lr}
    dd62:	8a81      	ldrh	r1, [r0, #20]
    dd64:	f5a1 427f 	sub.w	r2, r1, #65280	; 0xff00
    dd68:	3aff      	subs	r2, #255	; 0xff
    dd6a:	d008      	beq.n	dd7e <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY+0x1e>
    dd6c:	7d82      	ldrb	r2, [r0, #22]
    dd6e:	f88d 2000 	strb.w	r2, [sp]
    dd72:	9a00      	ldr	r2, [sp, #0]
    dd74:	9200      	str	r2, [sp, #0]
    dd76:	f89d 2000 	ldrb.w	r2, [sp]
    dd7a:	b952      	cbnz	r2, dd92 <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY+0x32>
    dd7c:	e004      	b.n	dd88 <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY+0x28>
    dd7e:	f240 318e 	movw	r1, #910	; 0x38e
    dd82:	2014      	movs	r0, #20
    dd84:	f7f7 f9e6 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    dd88:	8880      	ldrh	r0, [r0, #4]
    dd8a:	4281      	cmp	r1, r0
    dd8c:	d101      	bne.n	dd92 <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY+0x32>
    dd8e:	2000      	movs	r0, #0
    dd90:	bd08      	pop	{r3, pc}
    dd92:	2001      	movs	r0, #1
    dd94:	bd08      	pop	{r3, pc}

0000dd96 <sym_4Z7443SGSMJBRM7TLEVRIFXZXBZ34MHB7IK5ETY>:
    dd96:	f64f 71ff 	movw	r1, #65535	; 0xffff
    dd9a:	8281      	strh	r1, [r0, #20]
    dd9c:	2100      	movs	r1, #0
    dd9e:	7581      	strb	r1, [r0, #22]
    dda0:	4770      	bx	lr

0000dda2 <sym_56BVXVVSYPZZTDFBHBV4MJAFTYIS7HMITNWUEZQ>:
    dda2:	b510      	push	{r4, lr}
    dda4:	8a81      	ldrh	r1, [r0, #20]
    dda6:	f5a1 427f 	sub.w	r2, r1, #65280	; 0xff00
    ddaa:	3aff      	subs	r2, #255	; 0xff
    ddac:	d004      	beq.n	ddb8 <sym_56BVXVVSYPZZTDFBHBV4MJAFTYIS7HMITNWUEZQ+0x16>
    ddae:	f240 316a 	movw	r1, #874	; 0x36a
    ddb2:	2014      	movs	r0, #20
    ddb4:	f7f7 f9ce 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ddb8:	88c1      	ldrh	r1, [r0, #6]
    ddba:	8281      	strh	r1, [r0, #20]
    ddbc:	89c1      	ldrh	r1, [r0, #14]
    ddbe:	b109      	cbz	r1, ddc4 <sym_56BVXVVSYPZZTDFBHBV4MJAFTYIS7HMITNWUEZQ+0x22>
    ddc0:	21ff      	movs	r1, #255	; 0xff
    ddc2:	e000      	b.n	ddc6 <sym_56BVXVVSYPZZTDFBHBV4MJAFTYIS7HMITNWUEZQ+0x24>
    ddc4:	2100      	movs	r1, #0
    ddc6:	7581      	strb	r1, [r0, #22]
    ddc8:	bd10      	pop	{r4, pc}

0000ddca <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ>:
    ddca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ddce:	461d      	mov	r5, r3
    ddd0:	4616      	mov	r6, r2
    ddd2:	9f06      	ldr	r7, [sp, #24]
    ddd4:	460b      	mov	r3, r1
    ddd6:	4604      	mov	r4, r0
    ddd8:	463a      	mov	r2, r7
    ddda:	4629      	mov	r1, r5
    dddc:	4630      	mov	r0, r6
    ddde:	f000 f84f 	bl	de80 <sym_E56LW5YVGUG6HP2OML5URHI7K2KCWX5ULQKQOKY>
    dde2:	4283      	cmp	r3, r0
    dde4:	d201      	bcs.n	ddea <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ+0x20>
    dde6:	21a8      	movs	r1, #168	; 0xa8
    dde8:	e018      	b.n	de1c <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ+0x52>
    ddea:	1ce0      	adds	r0, r4, #3
    ddec:	f020 0103 	bic.w	r1, r0, #3
    ddf0:	4620      	mov	r0, r4
    ddf2:	42a1      	cmp	r1, r4
    ddf4:	d001      	beq.n	ddfa <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ+0x30>
    ddf6:	21a9      	movs	r1, #169	; 0xa9
    ddf8:	e010      	b.n	de1c <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ+0x52>
    ddfa:	2224      	movs	r2, #36	; 0x24
    ddfc:	2100      	movs	r1, #0
    ddfe:	f7ff f967 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    de02:	f64f 70ff 	movw	r0, #65535	; 0xffff
    de06:	82a0      	strh	r0, [r4, #20]
    de08:	19a8      	adds	r0, r5, r6
    de0a:	1d80      	adds	r0, r0, #6
    de0c:	4378      	muls	r0, r7
    de0e:	b280      	uxth	r0, r0
    de10:	7725      	strb	r5, [r4, #28]
    de12:	8060      	strh	r0, [r4, #2]
    de14:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    de18:	d903      	bls.n	de22 <sym_A7PVZLRTORLFMETW3GOBE4DG32WTH46LP2SW5QQ+0x58>
    de1a:	21af      	movs	r1, #175	; 0xaf
    de1c:	2014      	movs	r0, #20
    de1e:	f7f7 f999 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    de22:	8026      	strh	r6, [r4, #0]
    de24:	2000      	movs	r0, #0
    de26:	7760      	strb	r0, [r4, #29]
    de28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000de2c <sym_SSKIYGWPVDNEN7KR2D37H7PSUNCWATTS2JUNCZI>:
    de2c:	6181      	str	r1, [r0, #24]
    de2e:	6188      	str	r0, [r1, #24]
    de30:	4770      	bx	lr

0000de32 <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II>:
    de32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    de36:	460b      	mov	r3, r1
    de38:	4604      	mov	r4, r0
    de3a:	f100 0124 	add.w	r1, r0, #36	; 0x24
    de3e:	8905      	ldrh	r5, [r0, #8]
    de40:	8946      	ldrh	r6, [r0, #10]
    de42:	8880      	ldrh	r0, [r0, #4]
    de44:	f3c5 070e 	ubfx	r7, r5, #0, #15
    de48:	4439      	add	r1, r7
    de4a:	460f      	mov	r7, r1
    de4c:	4285      	cmp	r5, r0
    de4e:	d102      	bne.n	de56 <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II+0x24>
    de50:	2000      	movs	r0, #0
    de52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    de56:	b10a      	cbz	r2, de5c <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II+0x2a>
    de58:	1cc8      	adds	r0, r1, #3
    de5a:	6010      	str	r0, [r2, #0]
    de5c:	b123      	cbz	r3, de68 <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II+0x36>
    de5e:	7f22      	ldrb	r2, [r4, #28]
    de60:	1cf9      	adds	r1, r7, #3
    de62:	4618      	mov	r0, r3
    de64:	f7ff f8ba 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    de68:	883f      	ldrh	r7, [r7, #0]
    de6a:	f104 0108 	add.w	r1, r4, #8
    de6e:	4620      	mov	r0, r4
    de70:	f7ff fdaf 	bl	d9d2 <sdc_hci_cmd_lc_read_remote_version_information+0x4>
    de74:	42b5      	cmp	r5, r6
    de76:	d101      	bne.n	de7c <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II+0x4a>
    de78:	8920      	ldrh	r0, [r4, #8]
    de7a:	8160      	strh	r0, [r4, #10]
    de7c:	4638      	mov	r0, r7
    de7e:	e7e8      	b.n	de52 <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II+0x20>

0000de80 <sym_E56LW5YVGUG6HP2OML5URHI7K2KCWX5ULQKQOKY>:
    de80:	4401      	add	r1, r0
    de82:	1d89      	adds	r1, r1, #6
    de84:	4351      	muls	r1, r2
    de86:	b28a      	uxth	r2, r1
    de88:	2100      	movs	r1, #0
    de8a:	2845      	cmp	r0, #69	; 0x45
    de8c:	d202      	bcs.n	de94 <sym_E56LW5YVGUG6HP2OML5URHI7K2KCWX5ULQKQOKY+0x14>
    de8e:	f1c0 0045 	rsb	r0, r0, #69	; 0x45
    de92:	b281      	uxth	r1, r0
    de94:	3224      	adds	r2, #36	; 0x24
    de96:	1850      	adds	r0, r2, r1
    de98:	b280      	uxth	r0, r0
    de9a:	4770      	bx	lr

0000de9c <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI>:
    de9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    dea0:	4688      	mov	r8, r1
    dea2:	88c1      	ldrh	r1, [r0, #6]
    dea4:	4604      	mov	r4, r0
    dea6:	8900      	ldrh	r0, [r0, #8]
    dea8:	f3c1 060e 	ubfx	r6, r1, #0, #15
    deac:	f104 0524 	add.w	r5, r4, #36	; 0x24
    deb0:	f3c0 070e 	ubfx	r7, r0, #0, #15
    deb4:	eb05 0906 	add.w	r9, r5, r6
    deb8:	f7ff fdac 	bl	da14 <sdc_hci_cmd_lc_read_remote_version_information+0x46>
    debc:	2200      	movs	r2, #0
    debe:	b998      	cbnz	r0, dee8 <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x4c>
    dec0:	8820      	ldrh	r0, [r4, #0]
    dec2:	2845      	cmp	r0, #69	; 0x45
    dec4:	d200      	bcs.n	dec8 <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x2c>
    dec6:	2045      	movs	r0, #69	; 0x45
    dec8:	42b7      	cmp	r7, r6
    deca:	d906      	bls.n	deda <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x3e>
    decc:	7f23      	ldrb	r3, [r4, #28]
    dece:	1bb9      	subs	r1, r7, r6
    ded0:	1ac9      	subs	r1, r1, r3
    ded2:	1f89      	subs	r1, r1, #6
    ded4:	4281      	cmp	r1, r0
    ded6:	da00      	bge.n	deda <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x3e>
    ded8:	4608      	mov	r0, r1
    deda:	89e1      	ldrh	r1, [r4, #14]
    dedc:	b111      	cbz	r1, dee4 <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x48>
    dede:	f8b9 3000 	ldrh.w	r3, [r9]
    dee2:	1ac0      	subs	r0, r0, r3
    dee4:	4540      	cmp	r0, r8
    dee6:	da03      	bge.n	def0 <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x54>
    dee8:	8262      	strh	r2, [r4, #18]
    deea:	2000      	movs	r0, #0
    deec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    def0:	7f20      	ldrb	r0, [r4, #28]
    def2:	4429      	add	r1, r5
    def4:	1d80      	adds	r0, r0, #6
    def6:	4430      	add	r0, r6
    def8:	4408      	add	r0, r1
    defa:	f8a4 8012 	strh.w	r8, [r4, #18]
    defe:	1ec0      	subs	r0, r0, #3
    df00:	e7f4      	b.n	deec <sym_4DUZAAZKVNAL6VUHN4XAFX35FQKJS4D7DISLHDI+0x50>

0000df02 <sym_W4P456NK4DQPUF5QVP3W7JSFZJTVGAOKAMSTNSQ>:
    df02:	2100      	movs	r1, #0
    df04:	81c1      	strh	r1, [r0, #14]
    df06:	8241      	strh	r1, [r0, #18]
    df08:	7581      	strb	r1, [r0, #22]
    df0a:	4770      	bx	lr

0000df0c <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ>:
    df0c:	b570      	push	{r4, r5, r6, lr}
    df0e:	2300      	movs	r3, #0
    df10:	f1a1 0208 	sub.w	r2, r1, #8
    df14:	f64f 74f7 	movw	r4, #65527	; 0xfff7
    df18:	42a2      	cmp	r2, r4
    df1a:	d304      	bcc.n	df26 <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x1a>
    df1c:	f240 11cd 	movw	r1, #461	; 0x1cd
    df20:	2015      	movs	r0, #21
    df22:	f7f7 f917 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    df26:	6802      	ldr	r2, [r0, #0]
    df28:	b90a      	cbnz	r2, df2e <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x22>
    df2a:	e01e      	b.n	df6a <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x5e>
    df2c:	4610      	mov	r0, r2
    df2e:	6802      	ldr	r2, [r0, #0]
    df30:	8893      	ldrh	r3, [r2, #4]
    df32:	428b      	cmp	r3, r1
    df34:	d002      	beq.n	df3c <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x30>
    df36:	6813      	ldr	r3, [r2, #0]
    df38:	2b00      	cmp	r3, #0
    df3a:	d1f7      	bne.n	df2c <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x20>
    df3c:	8894      	ldrh	r4, [r2, #4]
    df3e:	4613      	mov	r3, r2
    df40:	428c      	cmp	r4, r1
    df42:	d101      	bne.n	df48 <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x3c>
    df44:	6811      	ldr	r1, [r2, #0]
    df46:	e00d      	b.n	df64 <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x58>
    df48:	f101 0508 	add.w	r5, r1, #8
    df4c:	b2ae      	uxth	r6, r5
    df4e:	2500      	movs	r5, #0
    df50:	42b4      	cmp	r4, r6
    df52:	d309      	bcc.n	df68 <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x5c>
    df54:	1a64      	subs	r4, r4, r1
    df56:	4411      	add	r1, r2
    df58:	600d      	str	r5, [r1, #0]
    df5a:	808c      	strh	r4, [r1, #4]
    df5c:	6802      	ldr	r2, [r0, #0]
    df5e:	6812      	ldr	r2, [r2, #0]
    df60:	6002      	str	r2, [r0, #0]
    df62:	600a      	str	r2, [r1, #0]
    df64:	6001      	str	r1, [r0, #0]
    df66:	e000      	b.n	df6a <sym_JTNP7UFMKYWSFCHJEA5IASO3QVW3HK4YV6YOJYQ+0x5e>
    df68:	2300      	movs	r3, #0
    df6a:	4618      	mov	r0, r3
    df6c:	bd70      	pop	{r4, r5, r6, pc}

0000df6e <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY>:
    df6e:	b510      	push	{r4, lr}
    df70:	000c      	movs	r4, r1
    df72:	d004      	beq.n	df7e <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY+0x10>
    df74:	2c08      	cmp	r4, #8
    df76:	d207      	bcs.n	df88 <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY+0x1a>
    df78:	f240 1195 	movw	r1, #405	; 0x195
    df7c:	e00a      	b.n	df94 <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY+0x26>
    df7e:	b108      	cbz	r0, df84 <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY+0x16>
    df80:	2100      	movs	r1, #0
    df82:	6001      	str	r1, [r0, #0]
    df84:	2000      	movs	r0, #0
    df86:	bd10      	pop	{r4, pc}
    df88:	b158      	cbz	r0, dfa2 <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY+0x34>
    df8a:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
    df8e:	d304      	bcc.n	df9a <sym_T2KVJXUKBW7E6DZMIXB2ENUQYG6P2TBYLXO3PAY+0x2c>
    df90:	f240 11a7 	movw	r1, #423	; 0x1a7
    df94:	2015      	movs	r0, #21
    df96:	f7f7 f8dd 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    df9a:	b2a1      	uxth	r1, r4
    df9c:	6800      	ldr	r0, [r0, #0]
    df9e:	f000 f814 	bl	dfca <sym_B627VJPECYREV5OY4VJ652ISBA4XGPKVOUJ747A+0xe>
    dfa2:	1d20      	adds	r0, r4, #4
    dfa4:	bd10      	pop	{r4, pc}

0000dfa6 <sym_4FRIF7JGOVTE7JZ3KYQVPKX5PKSXGKCIHE6GQDY>:
    dfa6:	2100      	movs	r1, #0
    dfa8:	6802      	ldr	r2, [r0, #0]
    dfaa:	e003      	b.n	dfb4 <sym_4FRIF7JGOVTE7JZ3KYQVPKX5PKSXGKCIHE6GQDY+0xe>
    dfac:	8893      	ldrh	r3, [r2, #4]
    dfae:	6812      	ldr	r2, [r2, #0]
    dfb0:	4419      	add	r1, r3
    dfb2:	b289      	uxth	r1, r1
    dfb4:	2a00      	cmp	r2, #0
    dfb6:	d1f9      	bne.n	dfac <sym_4FRIF7JGOVTE7JZ3KYQVPKX5PKSXGKCIHE6GQDY+0x6>
    dfb8:	f000 b807 	b.w	dfca <sym_B627VJPECYREV5OY4VJ652ISBA4XGPKVOUJ747A+0xe>

0000dfbc <sym_B627VJPECYREV5OY4VJ652ISBA4XGPKVOUJ747A>:
    dfbc:	2300      	movs	r3, #0
    dfbe:	600b      	str	r3, [r1, #0]
    dfc0:	808a      	strh	r2, [r1, #4]
    dfc2:	6802      	ldr	r2, [r0, #0]
    dfc4:	600a      	str	r2, [r1, #0]
    dfc6:	6001      	str	r1, [r0, #0]
    dfc8:	4770      	bx	lr
    dfca:	2300      	movs	r3, #0
    dfcc:	6043      	str	r3, [r0, #4]
    dfce:	1d02      	adds	r2, r0, #4
    dfd0:	8101      	strh	r1, [r0, #8]
    dfd2:	6002      	str	r2, [r0, #0]
    dfd4:	4770      	bx	lr

0000dfd6 <sym_7JFC7IFAJQVPYCQHAIUKZ626ISM3VUWBEEXY7WI>:
    dfd6:	f5a0 437f 	sub.w	r3, r0, #65280	; 0xff00
    dfda:	3bff      	subs	r3, #255	; 0xff
    dfdc:	d001      	beq.n	dfe2 <sym_7JFC7IFAJQVPYCQHAIUKZ626ISM3VUWBEEXY7WI+0xc>
    dfde:	2902      	cmp	r1, #2
    dfe0:	d301      	bcc.n	dfe6 <sym_7JFC7IFAJQVPYCQHAIUKZ626ISM3VUWBEEXY7WI+0x10>
    dfe2:	2000      	movs	r0, #0
    dfe4:	4770      	bx	lr
    dfe6:	f7f7 bb7b 	b.w	56e0 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x64>

0000dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>:
    dfea:	f5a0 427f 	sub.w	r2, r0, #65280	; 0xff00
    dfee:	3aff      	subs	r2, #255	; 0xff
    dff0:	d001      	beq.n	dff6 <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI+0xc>
    dff2:	2902      	cmp	r1, #2
    dff4:	d301      	bcc.n	dffa <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI+0x10>
    dff6:	2000      	movs	r0, #0
    dff8:	4770      	bx	lr
    dffa:	f7f7 bbab 	b.w	5754 <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0xd8>

0000dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>:
    dffe:	b570      	push	{r4, r5, r6, lr}
    e000:	4605      	mov	r5, r0
    e002:	460c      	mov	r4, r1
    e004:	4608      	mov	r0, r1
    e006:	f000 f9a9 	bl	e35c <sym_RFDF52I45CER5LUFD5R474FWGPTOSAHNLW6EPTI>
    e00a:	b108      	cbz	r0, e010 <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY+0x12>
    e00c:	2010      	movs	r0, #16
    e00e:	bd70      	pop	{r4, r5, r6, pc}
    e010:	2d02      	cmp	r5, #2
    e012:	d301      	bcc.n	e018 <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY+0x1a>
    e014:	2007      	movs	r0, #7
    e016:	bd70      	pop	{r4, r5, r6, pc}
    e018:	7025      	strb	r5, [r4, #0]
    e01a:	2000      	movs	r0, #0
    e01c:	8060      	strh	r0, [r4, #2]
    e01e:	bd70      	pop	{r4, r5, r6, pc}
    e020:	b510      	push	{r4, lr}
    e022:	4604      	mov	r4, r0
    e024:	f7f7 fbe2 	bl	57ec <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY+0x170>
    e028:	42a0      	cmp	r0, r4
    e02a:	d901      	bls.n	e030 <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY+0x32>
    e02c:	2001      	movs	r0, #1
    e02e:	bd10      	pop	{r4, pc}
    e030:	2000      	movs	r0, #0
    e032:	bd10      	pop	{r4, pc}
    e034:	4770      	bx	lr

0000e036 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY>:
    e036:	b570      	push	{r4, r5, r6, lr}
    e038:	460e      	mov	r6, r1
    e03a:	461d      	mov	r5, r3
    e03c:	4611      	mov	r1, r2
    e03e:	f000 f813 	bl	e068 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x32>
    e042:	4604      	mov	r4, r0
    e044:	4629      	mov	r1, r5
    e046:	4630      	mov	r0, r6
    e048:	f000 f804 	bl	e054 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x1e>
    e04c:	4420      	add	r0, r4
    e04e:	1d00      	adds	r0, r0, #4
    e050:	b280      	uxth	r0, r0
    e052:	bd70      	pop	{r4, r5, r6, pc}
    e054:	b510      	push	{r4, lr}
    e056:	460a      	mov	r2, r1
    e058:	2101      	movs	r1, #1
    e05a:	f7ff ff11 	bl	de80 <sym_E56LW5YVGUG6HP2OML5URHI7K2KCWX5ULQKQOKY>
    e05e:	f64f 71fc 	movw	r1, #65532	; 0xfffc
    e062:	1cc0      	adds	r0, r0, #3
    e064:	4008      	ands	r0, r1
    e066:	bd10      	pop	{r4, pc}
    e068:	b510      	push	{r4, lr}
    e06a:	460a      	mov	r2, r1
    e06c:	210a      	movs	r1, #10
    e06e:	f7ff ff07 	bl	de80 <sym_E56LW5YVGUG6HP2OML5URHI7K2KCWX5ULQKQOKY>
    e072:	f64f 71fc 	movw	r1, #65532	; 0xfffc
    e076:	1cc0      	adds	r0, r0, #3
    e078:	4008      	ands	r0, r1
    e07a:	bd10      	pop	{r4, pc}
    e07c:	b109      	cbz	r1, e082 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x4c>
    e07e:	2100      	movs	r1, #0
    e080:	e000      	b.n	e084 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x4e>
    e082:	2102      	movs	r1, #2
    e084:	1843      	adds	r3, r0, r1
    e086:	7d1a      	ldrb	r2, [r3, #20]
    e088:	2a02      	cmp	r2, #2
    e08a:	d008      	beq.n	e09e <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x68>
    e08c:	7d5b      	ldrb	r3, [r3, #21]
    e08e:	2b02      	cmp	r3, #2
    e090:	d009      	beq.n	e0a6 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x70>
    e092:	2a03      	cmp	r2, #3
    e094:	d003      	beq.n	e09e <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x68>
    e096:	2b03      	cmp	r3, #3
    e098:	d005      	beq.n	e0a6 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x70>
    e09a:	2000      	movs	r0, #0
    e09c:	4770      	bx	lr
    e09e:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    e0a2:	8b00      	ldrh	r0, [r0, #24]
    e0a4:	4770      	bx	lr
    e0a6:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    e0aa:	8b40      	ldrh	r0, [r0, #26]
    e0ac:	4770      	bx	lr
    e0ae:	b109      	cbz	r1, e0b4 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x7e>
    e0b0:	2100      	movs	r1, #0
    e0b2:	e000      	b.n	e0b6 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x80>
    e0b4:	2102      	movs	r1, #2
    e0b6:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    e0ba:	8b01      	ldrh	r1, [r0, #24]
    e0bc:	b911      	cbnz	r1, e0c4 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x8e>
    e0be:	8b40      	ldrh	r0, [r0, #26]
    e0c0:	2800      	cmp	r0, #0
    e0c2:	d000      	beq.n	e0c6 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x90>
    e0c4:	2001      	movs	r0, #1
    e0c6:	4770      	bx	lr
    e0c8:	b538      	push	{r3, r4, r5, lr}
    e0ca:	7883      	ldrb	r3, [r0, #2]
    e0cc:	f88d 3000 	strb.w	r3, [sp]
    e0d0:	9b00      	ldr	r3, [sp, #0]
    e0d2:	9300      	str	r3, [sp, #0]
    e0d4:	f89d 3000 	ldrb.w	r3, [sp]
    e0d8:	b95b      	cbnz	r3, e0f2 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xbc>
    e0da:	2400      	movs	r4, #0
    e0dc:	b10a      	cbz	r2, e0e2 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xac>
    e0de:	2300      	movs	r3, #0
    e0e0:	e000      	b.n	e0e4 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xae>
    e0e2:	2302      	movs	r3, #2
    e0e4:	18c2      	adds	r2, r0, r3
    e0e6:	7d15      	ldrb	r5, [r2, #20]
    e0e8:	2d02      	cmp	r5, #2
    e0ea:	d004      	beq.n	e0f6 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xc0>
    e0ec:	7d52      	ldrb	r2, [r2, #21]
    e0ee:	2a02      	cmp	r2, #2
    e0f0:	d004      	beq.n	e0fc <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xc6>
    e0f2:	2000      	movs	r0, #0
    e0f4:	bd38      	pop	{r3, r4, r5, pc}
    e0f6:	461a      	mov	r2, r3
    e0f8:	1c5b      	adds	r3, r3, #1
    e0fa:	e000      	b.n	e0fe <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xc8>
    e0fc:	1c5a      	adds	r2, r3, #1
    e0fe:	b179      	cbz	r1, e120 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xea>
    e100:	18c5      	adds	r5, r0, r3
    e102:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    e106:	752c      	strb	r4, [r5, #20]
    e108:	831c      	strh	r4, [r3, #24]
    e10a:	2303      	movs	r3, #3
    e10c:	1884      	adds	r4, r0, r2
    e10e:	7523      	strb	r3, [r4, #20]
    e110:	eb00 0382 	add.w	r3, r0, r2, lsl #2
    e114:	eb00 0042 	add.w	r0, r0, r2, lsl #1
    e118:	685b      	ldr	r3, [r3, #4]
    e11a:	600b      	str	r3, [r1, #0]
    e11c:	8b00      	ldrh	r0, [r0, #24]
    e11e:	8088      	strh	r0, [r1, #4]
    e120:	2001      	movs	r0, #1
    e122:	bd38      	pop	{r3, r4, r5, pc}
    e124:	b510      	push	{r4, lr}
    e126:	b109      	cbz	r1, e12c <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xf6>
    e128:	2100      	movs	r1, #0
    e12a:	e000      	b.n	e12e <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xf8>
    e12c:	2102      	movs	r1, #2
    e12e:	1843      	adds	r3, r0, r1
    e130:	7d1c      	ldrb	r4, [r3, #20]
    e132:	4294      	cmp	r4, r2
    e134:	d103      	bne.n	e13e <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x108>
    e136:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    e13a:	8b00      	ldrh	r0, [r0, #24]
    e13c:	bd10      	pop	{r4, pc}
    e13e:	7d5b      	ldrb	r3, [r3, #21]
    e140:	4293      	cmp	r3, r2
    e142:	d103      	bne.n	e14c <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x116>
    e144:	eb00 0041 	add.w	r0, r0, r1, lsl #1
    e148:	8b40      	ldrh	r0, [r0, #26]
    e14a:	bd10      	pop	{r4, pc}
    e14c:	2000      	movs	r0, #0
    e14e:	bd10      	pop	{r4, pc}
    e150:	f5b0 7fff 	cmp.w	r0, #510	; 0x1fe
    e154:	d201      	bcs.n	e15a <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x124>
    e156:	0841      	lsrs	r1, r0, #1
    e158:	e000      	b.n	e15c <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x126>
    e15a:	21ff      	movs	r1, #255	; 0xff
    e15c:	1a40      	subs	r0, r0, r1
    e15e:	f240 6172 	movw	r1, #1650	; 0x672
    e162:	4288      	cmp	r0, r1
    e164:	db00      	blt.n	e168 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x132>
    e166:	4608      	mov	r0, r1
    e168:	b280      	uxth	r0, r0
    e16a:	4770      	bx	lr

0000e16c <sym_RIJIFYF46ZRKFDPA3GKV7WCH2VGEUEP6MVN4JFI>:
    e16c:	2101      	movs	r1, #1
    e16e:	f7ff bf85 	b.w	e07c <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x46>

0000e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>:
    e172:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e176:	4606      	mov	r6, r0
    e178:	f342 0780 	sbfx	r7, r2, #2, #1
    e17c:	7848      	ldrb	r0, [r1, #1]
    e17e:	460c      	mov	r4, r1
    e180:	f022 0504 	bic.w	r5, r2, #4
    e184:	1c7f      	adds	r7, r7, #1
    e186:	b100      	cbz	r0, e18a <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x18>
    e188:	b90d      	cbnz	r5, e18e <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x1c>
    e18a:	4328      	orrs	r0, r5
    e18c:	d104      	bne.n	e198 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x26>
    e18e:	b145      	cbz	r5, e1a2 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x30>
    e190:	2100      	movs	r1, #0
    e192:	4620      	mov	r0, r4
    e194:	f7f7 fc34 	bl	5a00 <sym_35ZAQW4ABRMBYES2ZHPK63BHZAFFFC4WMGEJ6NA+0x30>
    e198:	20ff      	movs	r0, #255	; 0xff
    e19a:	70a0      	strb	r0, [r4, #2]
    e19c:	b11f      	cbz	r7, e1a6 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x34>
    e19e:	2000      	movs	r0, #0
    e1a0:	e002      	b.n	e1a8 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x36>
    e1a2:	2101      	movs	r1, #1
    e1a4:	e7f5      	b.n	e192 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x20>
    e1a6:	2002      	movs	r0, #2
    e1a8:	1821      	adds	r1, r4, r0
    e1aa:	7d09      	ldrb	r1, [r1, #20]
    e1ac:	2903      	cmp	r1, #3
    e1ae:	d102      	bne.n	e1b6 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x44>
    e1b0:	2d02      	cmp	r5, #2
    e1b2:	d000      	beq.n	e1b6 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA+0x44>
    e1b4:	1c40      	adds	r0, r0, #1
    e1b6:	1822      	adds	r2, r4, r0
    e1b8:	2101      	movs	r1, #1
    e1ba:	7511      	strb	r1, [r2, #20]
    e1bc:	eb04 0140 	add.w	r1, r4, r0, lsl #1
    e1c0:	2200      	movs	r2, #0
    e1c2:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    e1c6:	830a      	strh	r2, [r1, #24]
    e1c8:	6840      	ldr	r0, [r0, #4]
    e1ca:	70a2      	strb	r2, [r4, #2]
    e1cc:	4631      	mov	r1, r6
    e1ce:	f362 010f 	bfi	r1, r2, #0, #16
    e1d2:	e9c6 0100 	strd	r0, r1, [r6]
    e1d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000e1da <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY>:
    e1da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e1de:	461e      	mov	r6, r3
    e1e0:	4613      	mov	r3, r2
    e1e2:	4604      	mov	r4, r0
    e1e4:	b109      	cbz	r1, e1ea <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY+0x10>
    e1e6:	2000      	movs	r0, #0
    e1e8:	e000      	b.n	e1ec <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY+0x12>
    e1ea:	2002      	movs	r0, #2
    e1ec:	21ff      	movs	r1, #255	; 0xff
    e1ee:	70a1      	strb	r1, [r4, #2]
    e1f0:	1821      	adds	r1, r4, r0
    e1f2:	7d0a      	ldrb	r2, [r1, #20]
    e1f4:	2a01      	cmp	r2, #1
    e1f6:	d003      	beq.n	e200 <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY+0x26>
    e1f8:	7d49      	ldrb	r1, [r1, #21]
    e1fa:	2901      	cmp	r1, #1
    e1fc:	d10c      	bne.n	e218 <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY+0x3e>
    e1fe:	1c40      	adds	r0, r0, #1
    e200:	eb04 0540 	add.w	r5, r4, r0, lsl #1
    e204:	2700      	movs	r7, #0
    e206:	8b29      	ldrh	r1, [r5, #24]
    e208:	f8b5 c020 	ldrh.w	ip, [r5, #32]
    e20c:	198a      	adds	r2, r1, r6
    e20e:	4562      	cmp	r2, ip
    e210:	d905      	bls.n	e21e <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY+0x44>
    e212:	4420      	add	r0, r4
    e214:	832f      	strh	r7, [r5, #24]
    e216:	7507      	strb	r7, [r0, #20]
    e218:	2000      	movs	r0, #0
    e21a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e21e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    e222:	4632      	mov	r2, r6
    e224:	6840      	ldr	r0, [r0, #4]
    e226:	4408      	add	r0, r1
    e228:	4619      	mov	r1, r3
    e22a:	f7fe fed7 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    e22e:	8b28      	ldrh	r0, [r5, #24]
    e230:	4430      	add	r0, r6
    e232:	8328      	strh	r0, [r5, #24]
    e234:	70a7      	strb	r7, [r4, #2]
    e236:	2001      	movs	r0, #1
    e238:	e7ef      	b.n	e21a <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY+0x40>

0000e23a <sym_SYX5A4D5YT7FQ4PORL5PYZ5T6BOBVEZRWNZWOOA>:
    e23a:	2202      	movs	r2, #2
    e23c:	2100      	movs	r1, #0
    e23e:	f7ff bf71 	b.w	e124 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xee>

0000e242 <sym_Z3P3D5U3YDA66QTFRMTODYQPS5XZL7N2E3M2DIY>:
    e242:	b510      	push	{r4, lr}
    e244:	2101      	movs	r1, #1
    e246:	f7ff ff32 	bl	e0ae <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x78>
    e24a:	2800      	cmp	r0, #0
    e24c:	d000      	beq.n	e250 <sym_Z3P3D5U3YDA66QTFRMTODYQPS5XZL7N2E3M2DIY+0xe>
    e24e:	2001      	movs	r0, #1
    e250:	bd10      	pop	{r4, pc}

0000e252 <sym_VPXIA5P4C72CY3ME4ZVXBADOKEG5S4C7Z7QZZFA>:
    e252:	2201      	movs	r2, #1
    e254:	f7ff bf38 	b.w	e0c8 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x92>

0000e258 <sym_MF4WRTQNYFRYRFGW7FZUI3ZAYNQZ5EQ54QSK6JQ>:
    e258:	2200      	movs	r2, #0
    e25a:	f7ff bf35 	b.w	e0c8 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x92>

0000e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>:
    e25e:	b570      	push	{r4, r5, r6, lr}
    e260:	b109      	cbz	r1, e266 <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I+0x8>
    e262:	2300      	movs	r3, #0
    e264:	e000      	b.n	e268 <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I+0xa>
    e266:	2302      	movs	r3, #2
    e268:	21ff      	movs	r1, #255	; 0xff
    e26a:	7081      	strb	r1, [r0, #2]
    e26c:	18c1      	adds	r1, r0, r3
    e26e:	2402      	movs	r4, #2
    e270:	7d0d      	ldrb	r5, [r1, #20]
    e272:	2d01      	cmp	r5, #1
    e274:	d007      	beq.n	e286 <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I+0x28>
    e276:	7d4d      	ldrb	r5, [r1, #21]
    e278:	2d01      	cmp	r5, #1
    e27a:	d009      	beq.n	e290 <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I+0x32>
    e27c:	f44f 718b 	mov.w	r1, #278	; 0x116
    e280:	2009      	movs	r0, #9
    e282:	f7f6 ff67 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    e286:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    e28a:	831a      	strh	r2, [r3, #24]
    e28c:	750c      	strb	r4, [r1, #20]
    e28e:	e003      	b.n	e298 <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I+0x3a>
    e290:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    e294:	835a      	strh	r2, [r3, #26]
    e296:	754c      	strb	r4, [r1, #21]
    e298:	2100      	movs	r1, #0
    e29a:	7081      	strb	r1, [r0, #2]
    e29c:	bd70      	pop	{r4, r5, r6, pc}

0000e29e <sym_SCCFLYV5KOPRJ5S7RGDC2KDSCCHMKXYC3EQIE6A>:
    e29e:	2101      	movs	r1, #1
    e2a0:	7001      	strb	r1, [r0, #0]
    e2a2:	4770      	bx	lr

0000e2a4 <sym_DPFAWTOI3GRLXCS5TV5FXLZJNKWMRLYTLT4DRFY>:
    e2a4:	2201      	movs	r2, #1
    e2a6:	4611      	mov	r1, r2
    e2a8:	f7ff bf3c 	b.w	e124 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xee>

0000e2ac <sym_27RZBWKBTESKUPVNN3E7RHYQU6UH4RT372SK2WA>:
    e2ac:	2201      	movs	r2, #1
    e2ae:	2100      	movs	r1, #0
    e2b0:	f7ff bf38 	b.w	e124 <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0xee>

0000e2b4 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ>:
    e2b4:	2100      	movs	r1, #0
    e2b6:	f7ff bee1 	b.w	e07c <sym_WDNTHBFS7DQM3AR7WDCR7ZEICFH5ZM5PJ35BRPY+0x46>
    e2ba:	2800      	cmp	r0, #0
    e2bc:	db09      	blt.n	e2d2 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x1e>
    e2be:	f000 021f 	and.w	r2, r0, #31
    e2c2:	2101      	movs	r1, #1
    e2c4:	4091      	lsls	r1, r2
    e2c6:	0940      	lsrs	r0, r0, #5
    e2c8:	0080      	lsls	r0, r0, #2
    e2ca:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    e2ce:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
    e2d2:	4770      	bx	lr
    e2d4:	2800      	cmp	r0, #0
    e2d6:	db0d      	blt.n	e2f4 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x40>
    e2d8:	f000 021f 	and.w	r2, r0, #31
    e2dc:	2101      	movs	r1, #1
    e2de:	4091      	lsls	r1, r2
    e2e0:	0940      	lsrs	r0, r0, #5
    e2e2:	0080      	lsls	r0, r0, #2
    e2e4:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    e2e8:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
    e2ec:	f3bf 8f4f 	dsb	sy
    e2f0:	f3bf 8f6f 	isb	sy
    e2f4:	4770      	bx	lr
    e2f6:	b510      	push	{r4, lr}
    e2f8:	200e      	movs	r0, #14
    e2fa:	f7ff ffeb 	bl	e2d4 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x20>
    e2fe:	200e      	movs	r0, #14
    e300:	f7ff ffdb 	bl	e2ba <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x6>
    e304:	200f      	movs	r0, #15
    e306:	f7ff ffe5 	bl	e2d4 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x20>
    e30a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e30e:	200f      	movs	r0, #15
    e310:	f7ff bfd3 	b.w	e2ba <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x6>
    e314:	2800      	cmp	r0, #0
    e316:	db09      	blt.n	e32c <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x78>
    e318:	f000 021f 	and.w	r2, r0, #31
    e31c:	2101      	movs	r1, #1
    e31e:	4091      	lsls	r1, r2
    e320:	0940      	lsrs	r0, r0, #5
    e322:	0080      	lsls	r0, r0, #2
    e324:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
    e328:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
    e32c:	4770      	bx	lr
    e32e:	5840      	ldr	r0, [r0, r1]
    e330:	2800      	cmp	r0, #0
    e332:	d000      	beq.n	e336 <sym_MJFFFAJVV3IQTOJK6UL2575XXGCEKTIIFXD5MAQ+0x82>
    e334:	2001      	movs	r0, #1
    e336:	4770      	bx	lr

0000e338 <sym_2ZCOT6ZEUU54S36NE627GOZVLBS26AFIUJKNLBI>:
    e338:	b510      	push	{r4, lr}
    e33a:	4604      	mov	r4, r0
    e33c:	4620      	mov	r0, r4
    e33e:	f7f7 fc5f 	bl	5c00 <sym_E5WZNPP2DINHF6K4PHXLYLX5AXTYBQYGQESRSGQ+0x2c>
    e342:	2811      	cmp	r0, #17
    e344:	d0fa      	beq.n	e33c <sym_2ZCOT6ZEUU54S36NE627GOZVLBS26AFIUJKNLBI+0x4>
    e346:	bd10      	pop	{r4, pc}

0000e348 <sym_GZE6QJRFTCG2MERGOKENHWFRYSCC5S3WEXUU47A>:
    e348:	b510      	push	{r4, lr}
    e34a:	f7ff fff5 	bl	e338 <sym_2ZCOT6ZEUU54S36NE627GOZVLBS26AFIUJKNLBI>
    e34e:	2800      	cmp	r0, #0
    e350:	d003      	beq.n	e35a <sym_GZE6QJRFTCG2MERGOKENHWFRYSCC5S3WEXUU47A+0x12>
    e352:	21a0      	movs	r1, #160	; 0xa0
    e354:	201d      	movs	r0, #29
    e356:	f7f6 fefd 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    e35a:	bd10      	pop	{r4, pc}

0000e35c <sym_RFDF52I45CER5LUFD5R474FWGPTOSAHNLW6EPTI>:
    e35c:	b108      	cbz	r0, e362 <sym_RFDF52I45CER5LUFD5R474FWGPTOSAHNLW6EPTI+0x6>
    e35e:	2000      	movs	r0, #0
    e360:	4770      	bx	lr
    e362:	2001      	movs	r0, #1
    e364:	4770      	bx	lr

0000e366 <sym_REO6MG4FRJTNQQ56RDJDYGEWFEO5TFVYGRW6OLI>:
    e366:	f7f7 bd9d 	b.w	5ea4 <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY+0x20>

0000e36a <sym_QXKT3PVMDTZRAAU2QNTWO5VOUEZ4NW6TWISREXY>:
    e36a:	f7f7 bd8b 	b.w	5e84 <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY>

0000e36e <sym_4ZZLWI6QQY4KJYYVP4RVDTJJJ6MW72AL2TJDVOI>:
    e36e:	b510      	push	{r4, lr}
    e370:	4050      	eors	r0, r2
    e372:	780a      	ldrb	r2, [r1, #0]
    e374:	781c      	ldrb	r4, [r3, #0]
    e376:	4062      	eors	r2, r4
    e378:	4410      	add	r0, r2
    e37a:	784a      	ldrb	r2, [r1, #1]
    e37c:	785c      	ldrb	r4, [r3, #1]
    e37e:	4062      	eors	r2, r4
    e380:	4410      	add	r0, r2
    e382:	788a      	ldrb	r2, [r1, #2]
    e384:	789c      	ldrb	r4, [r3, #2]
    e386:	4062      	eors	r2, r4
    e388:	4410      	add	r0, r2
    e38a:	78ca      	ldrb	r2, [r1, #3]
    e38c:	78dc      	ldrb	r4, [r3, #3]
    e38e:	4062      	eors	r2, r4
    e390:	4410      	add	r0, r2
    e392:	790a      	ldrb	r2, [r1, #4]
    e394:	791c      	ldrb	r4, [r3, #4]
    e396:	7949      	ldrb	r1, [r1, #5]
    e398:	4062      	eors	r2, r4
    e39a:	4410      	add	r0, r2
    e39c:	795a      	ldrb	r2, [r3, #5]
    e39e:	4051      	eors	r1, r2
    e3a0:	42c1      	cmn	r1, r0
    e3a2:	d101      	bne.n	e3a8 <sym_4ZZLWI6QQY4KJYYVP4RVDTJJJ6MW72AL2TJDVOI+0x3a>
    e3a4:	2001      	movs	r0, #1
    e3a6:	bd10      	pop	{r4, pc}
    e3a8:	2000      	movs	r0, #0
    e3aa:	bd10      	pop	{r4, pc}

0000e3ac <sym_FEGTISSRZOTQRK4SD4MRDIWBV3TTZYGCCKXTY4Y>:
    e3ac:	b510      	push	{r4, lr}
    e3ae:	2900      	cmp	r1, #0
    e3b0:	4604      	mov	r4, r0
    e3b2:	f04f 0106 	mov.w	r1, #6
    e3b6:	d002      	beq.n	e3be <sym_FEGTISSRZOTQRK4SD4MRDIWBV3TTZYGCCKXTY4Y+0x12>
    e3b8:	f7f6 ff6a 	bl	5290 <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA>
    e3bc:	e001      	b.n	e3c2 <sym_FEGTISSRZOTQRK4SD4MRDIWBV3TTZYGCCKXTY4Y+0x16>
    e3be:	f7f6 ff75 	bl	52ac <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA>
    e3c2:	7960      	ldrb	r0, [r4, #5]
    e3c4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    e3c8:	7160      	strb	r0, [r4, #5]
    e3ca:	bd10      	pop	{r4, pc}

0000e3cc <sym_BGPX36PUCNVPV3544HQ5RQFY5WG7CJAFVVBI7AY>:
    e3cc:	4770      	bx	lr

0000e3ce <sym_BLMJ5IIKWMCUMGRAJC47JTAD5DUGOY4TIBII5HY>:
    e3ce:	b530      	push	{r4, r5, lr}
    e3d0:	460c      	mov	r4, r1
    e3d2:	4605      	mov	r5, r0
    e3d4:	b08d      	sub	sp, #52	; 0x34
    e3d6:	f04f 0103 	mov.w	r1, #3
    e3da:	f104 0003 	add.w	r0, r4, #3
    e3de:	b112      	cbz	r2, e3e6 <sym_BLMJ5IIKWMCUMGRAJC47JTAD5DUGOY4TIBII5HY+0x18>
    e3e0:	f7f6 ff56 	bl	5290 <sym_4BGPQMJJRBR2ET4K6M3CH3OLXQGTP2TS7FVXINA>
    e3e4:	e001      	b.n	e3ea <sym_BLMJ5IIKWMCUMGRAJC47JTAD5DUGOY4TIBII5HY+0x1c>
    e3e6:	f7f6 ff61 	bl	52ac <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA>
    e3ea:	7960      	ldrb	r0, [r4, #5]
    e3ec:	220d      	movs	r2, #13
    e3ee:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    e3f2:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    e3f6:	7160      	strb	r0, [r4, #5]
    e3f8:	2100      	movs	r1, #0
    e3fa:	a804      	add	r0, sp, #16
    e3fc:	f7fe fe68 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    e400:	78e0      	ldrb	r0, [r4, #3]
    e402:	f88d 001f 	strb.w	r0, [sp, #31]
    e406:	7920      	ldrb	r0, [r4, #4]
    e408:	f88d 001e 	strb.w	r0, [sp, #30]
    e40c:	7960      	ldrb	r0, [r4, #5]
    e40e:	f88d 001d 	strb.w	r0, [sp, #29]
    e412:	2210      	movs	r2, #16
    e414:	4629      	mov	r1, r5
    e416:	4668      	mov	r0, sp
    e418:	f7fe fde0 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    e41c:	4668      	mov	r0, sp
    e41e:	f7ff ff93 	bl	e348 <sym_GZE6QJRFTCG2MERGOKENHWFRYSCC5S3WEXUU47A>
    e422:	f89d 002f 	ldrb.w	r0, [sp, #47]	; 0x2f
    e426:	7020      	strb	r0, [r4, #0]
    e428:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
    e42c:	7060      	strb	r0, [r4, #1]
    e42e:	f89d 002d 	ldrb.w	r0, [sp, #45]	; 0x2d
    e432:	70a0      	strb	r0, [r4, #2]
    e434:	b00d      	add	sp, #52	; 0x34
    e436:	bd30      	pop	{r4, r5, pc}

0000e438 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q>:
    e438:	f7f8 b910 	b.w	665c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ+0x420>
    e43c:	07c1      	lsls	r1, r0, #31
    e43e:	d001      	beq.n	e444 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0xc>
    e440:	2001      	movs	r0, #1
    e442:	4770      	bx	lr
    e444:	0780      	lsls	r0, r0, #30
    e446:	d501      	bpl.n	e44c <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x14>
    e448:	2002      	movs	r0, #2
    e44a:	4770      	bx	lr
    e44c:	2000      	movs	r0, #0
    e44e:	4770      	bx	lr
    e450:	b510      	push	{r4, lr}
    e452:	2801      	cmp	r0, #1
    e454:	d008      	beq.n	e468 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x30>
    e456:	2802      	cmp	r0, #2
    e458:	d004      	beq.n	e464 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x2c>
    e45a:	f240 31f3 	movw	r1, #1011	; 0x3f3
    e45e:	2006      	movs	r0, #6
    e460:	f7f6 fe78 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    e464:	2001      	movs	r0, #1
    e466:	bd10      	pop	{r4, pc}
    e468:	2000      	movs	r0, #0
    e46a:	bd10      	pop	{r4, pc}
    e46c:	2900      	cmp	r1, #0
    e46e:	d004      	beq.n	e47a <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x42>
    e470:	2801      	cmp	r0, #1
    e472:	d003      	beq.n	e47c <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x44>
    e474:	2901      	cmp	r1, #1
    e476:	d001      	beq.n	e47c <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q+0x44>
    e478:	2002      	movs	r0, #2
    e47a:	4770      	bx	lr
    e47c:	2001      	movs	r0, #1
    e47e:	4770      	bx	lr
    e480:	f7ff bc4b 	b.w	dd1a <sym_47GVMLF7NXDJBYC2TPU2ES3ZL6CP4GIPWKYYWBI>

0000e484 <sym_2X6ZBBHQKFJV27I6OQZLD4IRAL5JANEGA5N34WA>:
    e484:	2101      	movs	r1, #1
    e486:	f7f8 bbe3 	b.w	6c50 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x74>

0000e48a <sym_GKUVQYGVTZ7DKWBNC3M5TXN4XZ4Q6TUJFSFOWBA>:
    e48a:	b510      	push	{r4, lr}
    e48c:	f002 fc2f 	bl	10cee <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ>
    e490:	b118      	cbz	r0, e49a <sym_GKUVQYGVTZ7DKWBNC3M5TXN4XZ4Q6TUJFSFOWBA+0x10>
    e492:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e496:	f7fd b953 	b.w	b740 <sym_ZQHB3ANU2DANFLJZLZL5U4SPQ2ZDVUAHI35744Y>
    e49a:	20ff      	movs	r0, #255	; 0xff
    e49c:	bd10      	pop	{r4, pc}

0000e49e <sym_QW6JOH7RCJIC2YFNJEURX5QNB5EIQT646EHIWEA>:
    e49e:	b510      	push	{r4, lr}
    e4a0:	f7f8 fc1e 	bl	6ce0 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x104>
    e4a4:	2810      	cmp	r0, #16
    e4a6:	d003      	beq.n	e4b0 <sym_QW6JOH7RCJIC2YFNJEURX5QNB5EIQT646EHIWEA+0x12>
    e4a8:	f7f8 fbea 	bl	6c80 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0xa4>
    e4ac:	2810      	cmp	r0, #16
    e4ae:	d100      	bne.n	e4b2 <sym_QW6JOH7RCJIC2YFNJEURX5QNB5EIQT646EHIWEA+0x14>
    e4b0:	2008      	movs	r0, #8
    e4b2:	bd10      	pop	{r4, pc}

0000e4b4 <sym_JAE5CJ34QIQM34DAKQFWDERFAUN5NXFJM57HRLY>:
    e4b4:	b510      	push	{r4, lr}
    e4b6:	f7f8 fc13 	bl	6ce0 <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x104>
    e4ba:	2810      	cmp	r0, #16
    e4bc:	d003      	beq.n	e4c6 <sym_JAE5CJ34QIQM34DAKQFWDERFAUN5NXFJM57HRLY+0x12>
    e4be:	f7f8 fc6d 	bl	6d9c <sym_NCQ5WTBCV7DGPK3QI3SSY5XGKOI2SE3XFCTKQKY+0x1c0>
    e4c2:	2001      	movs	r0, #1
    e4c4:	bd10      	pop	{r4, pc}
    e4c6:	2000      	movs	r0, #0
    e4c8:	bd10      	pop	{r4, pc}

0000e4ca <sym_L64WJ6W52HQBFQCTPO5LHELOWQEJNMIWLQKG6JY>:
    e4ca:	b570      	push	{r4, r5, r6, lr}
    e4cc:	460e      	mov	r6, r1
    e4ce:	b08c      	sub	sp, #48	; 0x30
    e4d0:	4614      	mov	r4, r2
    e4d2:	4601      	mov	r1, r0
    e4d4:	461d      	mov	r5, r3
    e4d6:	2210      	movs	r2, #16
    e4d8:	4668      	mov	r0, sp
    e4da:	f000 f928 	bl	e72e <sym_C5MZWIO7BXLJIO65K7CGSHP3SLST2VORSHVBOVI>
    e4de:	2210      	movs	r2, #16
    e4e0:	4631      	mov	r1, r6
    e4e2:	a804      	add	r0, sp, #16
    e4e4:	f000 f923 	bl	e72e <sym_C5MZWIO7BXLJIO65K7CGSHP3SLST2VORSHVBOVI>
    e4e8:	4668      	mov	r0, sp
    e4ea:	f7ff ff2d 	bl	e348 <sym_GZE6QJRFTCG2MERGOKENHWFRYSCC5S3WEXUU47A>
    e4ee:	a908      	add	r1, sp, #32
    e4f0:	f04f 0210 	mov.w	r2, #16
    e4f4:	4628      	mov	r0, r5
    e4f6:	b11c      	cbz	r4, e500 <sym_L64WJ6W52HQBFQCTPO5LHELOWQEJNMIWLQKG6JY+0x36>
    e4f8:	f000 f919 	bl	e72e <sym_C5MZWIO7BXLJIO65K7CGSHP3SLST2VORSHVBOVI>
    e4fc:	b00c      	add	sp, #48	; 0x30
    e4fe:	bd70      	pop	{r4, r5, r6, pc}
    e500:	f7fe fd6c 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    e504:	e7fa      	b.n	e4fc <sym_L64WJ6W52HQBFQCTPO5LHELOWQEJNMIWLQKG6JY+0x32>

0000e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>:
    e506:	b510      	push	{r4, lr}
    e508:	460c      	mov	r4, r1
    e50a:	2100      	movs	r1, #0
    e50c:	f7ff fd6d 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
    e510:	6060      	str	r0, [r4, #4]
    e512:	b118      	cbz	r0, e51c <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA+0x16>
    e514:	2001      	movs	r0, #1
    e516:	7020      	strb	r0, [r4, #0]
    e518:	2000      	movs	r0, #0
    e51a:	bd10      	pop	{r4, pc}
    e51c:	2002      	movs	r0, #2
    e51e:	bd10      	pop	{r4, pc}

0000e520 <sym_3GY4TYJRRJL4WNFV6XN3ATYT4MIF4FYTN3S33RI>:
    e520:	f240 41e2 	movw	r1, #1250	; 0x4e2
    e524:	4348      	muls	r0, r1
    e526:	4770      	bx	lr

0000e528 <sym_DSAIJDVMFSSNYDQYP4G3W4ZBYTG4PAWPSVOBJ2Y>:
    e528:	f240 41e2 	movw	r1, #1250	; 0x4e2
    e52c:	fbb0 f0f1 	udiv	r0, r0, r1
    e530:	b280      	uxth	r0, r0
    e532:	4770      	bx	lr

0000e534 <sym_75VOI5ZNFW3OXMHUCY2QF6IZX2BBZSQKA7XVCPQ>:
    e534:	b570      	push	{r4, r5, r6, lr}
    e536:	4604      	mov	r4, r0
    e538:	4290      	cmp	r0, r2
    e53a:	d20b      	bcs.n	e554 <sym_75VOI5ZNFW3OXMHUCY2QF6IZX2BBZSQKA7XVCPQ+0x20>
    e53c:	1b10      	subs	r0, r2, r4
    e53e:	2865      	cmp	r0, #101	; 0x65
    e540:	d200      	bcs.n	e544 <sym_75VOI5ZNFW3OXMHUCY2QF6IZX2BBZSQKA7XVCPQ+0x10>
    e542:	2065      	movs	r0, #101	; 0x65
    e544:	1825      	adds	r5, r4, r0
    e546:	428d      	cmp	r5, r1
    e548:	d803      	bhi.n	e552 <sym_75VOI5ZNFW3OXMHUCY2QF6IZX2BBZSQKA7XVCPQ+0x1e>
    e54a:	2103      	movs	r1, #3
    e54c:	f7f4 f896 	bl	267c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ>
    e550:	b108      	cbz	r0, e556 <sym_75VOI5ZNFW3OXMHUCY2QF6IZX2BBZSQKA7XVCPQ+0x22>
    e552:	4620      	mov	r0, r4
    e554:	bd70      	pop	{r4, r5, r6, pc}
    e556:	4628      	mov	r0, r5
    e558:	bd70      	pop	{r4, r5, r6, pc}

0000e55a <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I>:
    e55a:	b510      	push	{r4, lr}
    e55c:	f1a2 030f 	sub.w	r3, r2, #15
    e560:	290c      	cmp	r1, #12
    e562:	d244      	bcs.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e564:	e8df f001 	tbb	[pc, r1]
    e568:	120d0806 	.word	0x120d0806
    e56c:	241c1815 	.word	0x241c1815
    e570:	312a4127 	.word	0x312a4127
    e574:	b3c2      	cbz	r2, e5e8 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x8e>
    e576:	e03a      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e578:	2a07      	cmp	r2, #7
    e57a:	d03a      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e57c:	2a08      	cmp	r2, #8
    e57e:	d038      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e580:	e035      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e582:	2a0c      	cmp	r2, #12
    e584:	d035      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e586:	2a0b      	cmp	r2, #11
    e588:	d033      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e58a:	e030      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e58c:	2a0d      	cmp	r2, #13
    e58e:	d030      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e590:	e02d      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e592:	2b0c      	cmp	r3, #12
    e594:	d92d      	bls.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e596:	e02a      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e598:	3a10      	subs	r2, #16
    e59a:	2a0b      	cmp	r2, #11
    e59c:	d929      	bls.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e59e:	e026      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5a0:	2b03      	cmp	r3, #3
    e5a2:	d926      	bls.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5a4:	f890 004c 	ldrb.w	r0, [r0, #76]	; 0x4c
    e5a8:	b308      	cbz	r0, e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5aa:	2a1b      	cmp	r2, #27
    e5ac:	d921      	bls.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5ae:	e01e      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5b0:	2a04      	cmp	r2, #4
    e5b2:	d01e      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5b4:	e01b      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5b6:	2a06      	cmp	r2, #6
    e5b8:	d01b      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5ba:	e018      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5bc:	2a1c      	cmp	r2, #28
    e5be:	d018      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5c0:	2a1d      	cmp	r2, #29
    e5c2:	d016      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5c4:	2a1e      	cmp	r2, #30
    e5c6:	d014      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5c8:	e011      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5ca:	2a1f      	cmp	r2, #31
    e5cc:	d011      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5ce:	2a20      	cmp	r2, #32
    e5d0:	d00f      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5d2:	2a21      	cmp	r2, #33	; 0x21
    e5d4:	d00d      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5d6:	2a22      	cmp	r2, #34	; 0x22
    e5d8:	d00b      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5da:	2a23      	cmp	r2, #35	; 0x23
    e5dc:	d009      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5de:	2a24      	cmp	r2, #36	; 0x24
    e5e0:	d007      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5e2:	2a27      	cmp	r2, #39	; 0x27
    e5e4:	d005      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5e6:	e002      	b.n	e5ee <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x94>
    e5e8:	e003      	b.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5ea:	2a0e      	cmp	r2, #14
    e5ec:	d001      	beq.n	e5f2 <sym_76SF2THVWBBVUHDFLIXMTXOYE2LFAIMVFAFT26I+0x98>
    e5ee:	2000      	movs	r0, #0
    e5f0:	bd10      	pop	{r4, pc}
    e5f2:	2001      	movs	r0, #1
    e5f4:	bd10      	pop	{r4, pc}

0000e5f6 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI>:
    e5f6:	280c      	cmp	r0, #12
    e5f8:	d013      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e5fa:	280b      	cmp	r0, #11
    e5fc:	d011      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e5fe:	280d      	cmp	r0, #13
    e600:	d00f      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e602:	281f      	cmp	r0, #31
    e604:	d00d      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e606:	2820      	cmp	r0, #32
    e608:	d00b      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e60a:	2821      	cmp	r0, #33	; 0x21
    e60c:	d009      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e60e:	2822      	cmp	r0, #34	; 0x22
    e610:	d007      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e612:	2823      	cmp	r0, #35	; 0x23
    e614:	d005      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e616:	2824      	cmp	r0, #36	; 0x24
    e618:	d003      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e61a:	2827      	cmp	r0, #39	; 0x27
    e61c:	d001      	beq.n	e622 <sym_J22YCCWNUNOSXHAJQUUQAO7YZP2SNXLIWISZVHI+0x2c>
    e61e:	2000      	movs	r0, #0
    e620:	4770      	bx	lr
    e622:	2001      	movs	r0, #1
    e624:	4770      	bx	lr

0000e626 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y>:
    e626:	f011 0f0c 	tst.w	r1, #12
    e62a:	d018      	beq.n	e65e <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x38>
    e62c:	074a      	lsls	r2, r1, #29
    e62e:	f44f 7116 	mov.w	r1, #600	; 0x258
    e632:	2a00      	cmp	r2, #0
    e634:	da02      	bge.n	e63c <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x16>
    e636:	f04f 0210 	mov.w	r2, #16
    e63a:	e001      	b.n	e640 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x1a>
    e63c:	f04f 0240 	mov.w	r2, #64	; 0x40
    e640:	da01      	bge.n	e646 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x20>
    e642:	f04f 0196 	mov.w	r1, #150	; 0x96
    e646:	f501 71bc 	add.w	r1, r1, #376	; 0x178
    e64a:	eba0 0301 	sub.w	r3, r0, r1
    e64e:	4288      	cmp	r0, r1
    e650:	d903      	bls.n	e65a <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x34>
    e652:	fb93 f0f2 	sdiv	r0, r3, r2
    e656:	b280      	uxth	r0, r0
    e658:	4770      	bx	lr
    e65a:	2000      	movs	r0, #0
    e65c:	4770      	bx	lr
    e65e:	2902      	cmp	r1, #2
    e660:	d008      	beq.n	e674 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x4e>
    e662:	2870      	cmp	r0, #112	; 0x70
    e664:	d9f9      	bls.n	e65a <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x34>
    e666:	3870      	subs	r0, #112	; 0x70
    e668:	17c1      	asrs	r1, r0, #31
    e66a:	eb00 7051 	add.w	r0, r0, r1, lsr #29
    e66e:	f3c0 00cf 	ubfx	r0, r0, #3, #16
    e672:	4770      	bx	lr
    e674:	283c      	cmp	r0, #60	; 0x3c
    e676:	d9f0      	bls.n	e65a <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y+0x34>
    e678:	383c      	subs	r0, #60	; 0x3c
    e67a:	17c1      	asrs	r1, r0, #31
    e67c:	eb00 7091 	add.w	r0, r0, r1, lsr #30
    e680:	f3c0 008f 	ubfx	r0, r0, #2, #16
    e684:	4770      	bx	lr

0000e686 <sym_6NROXJNXJONASXBRH4ZGPEEQ42PSH3YLRTC74GQ>:
    e686:	6809      	ldr	r1, [r1, #0]
    e688:	f8c0 106a 	str.w	r1, [r0, #106]	; 0x6a
    e68c:	4770      	bx	lr

0000e68e <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI>:
    e68e:	07c1      	lsls	r1, r0, #31
    e690:	d001      	beq.n	e696 <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI+0x8>
    e692:	2001      	movs	r0, #1
    e694:	4770      	bx	lr
    e696:	0781      	lsls	r1, r0, #30
    e698:	d501      	bpl.n	e69e <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI+0x10>
    e69a:	2002      	movs	r0, #2
    e69c:	4770      	bx	lr
    e69e:	0740      	lsls	r0, r0, #29
    e6a0:	d501      	bpl.n	e6a6 <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI+0x18>
    e6a2:	2008      	movs	r0, #8
    e6a4:	4770      	bx	lr
    e6a6:	2000      	movs	r0, #0
    e6a8:	4770      	bx	lr

0000e6aa <sym_QOK2KYWK62QNZBQRPK2GPAU2IEJXSELK32IAUUA>:
    e6aa:	b510      	push	{r4, lr}
    e6ac:	f640 12c4 	movw	r2, #2500	; 0x9c4
    e6b0:	2901      	cmp	r1, #1
    e6b2:	d006      	beq.n	e6c2 <sym_QOK2KYWK62QNZBQRPK2GPAU2IEJXSELK32IAUUA+0x18>
    e6b4:	2902      	cmp	r1, #2
    e6b6:	d005      	beq.n	e6c4 <sym_QOK2KYWK62QNZBQRPK2GPAU2IEJXSELK32IAUUA+0x1a>
    e6b8:	f240 31ba 	movw	r1, #954	; 0x3ba
    e6bc:	2029      	movs	r0, #41	; 0x29
    e6be:	f7f6 fd49 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    e6c2:	b108      	cbz	r0, e6c8 <sym_QOK2KYWK62QNZBQRPK2GPAU2IEJXSELK32IAUUA+0x1e>
    e6c4:	4610      	mov	r0, r2
    e6c6:	bd10      	pop	{r4, pc}
    e6c8:	f240 40e2 	movw	r0, #1250	; 0x4e2
    e6cc:	bd10      	pop	{r4, pc}

0000e6ce <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY>:
    e6ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e6d2:	4607      	mov	r7, r0
    e6d4:	460e      	mov	r6, r1
    e6d6:	e9d7 5404 	ldrd	r5, r4, [r7, #16]
    e6da:	f7f4 fb8b 	bl	2df4 <sym_CVH6S6LMSFPC2RM6I6LYWFRVOJUD3A6OCMG7AAI>
    e6de:	b198      	cbz	r0, e708 <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY+0x3a>
    e6e0:	b31e      	cbz	r6, e72a <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY+0x5c>
    e6e2:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
    e6e6:	1b40      	subs	r0, r0, r5
    e6e8:	2300      	movs	r3, #0
    e6ea:	eb61 0104 	sbc.w	r1, r1, r4
    e6ee:	461a      	mov	r2, r3
    e6f0:	1a1b      	subs	r3, r3, r0
    e6f2:	418a      	sbcs	r2, r1
    e6f4:	da19      	bge.n	e72a <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY+0x5c>
    e6f6:	1c42      	adds	r2, r0, #1
    e6f8:	f171 0100 	sbcs.w	r1, r1, #0
    e6fc:	db07      	blt.n	e70e <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY+0x40>
    e6fe:	f240 2136 	movw	r1, #566	; 0x236
    e702:	2029      	movs	r0, #41	; 0x29
    e704:	f7f6 fd26 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    e708:	f44f 710b 	mov.w	r1, #556	; 0x22c
    e70c:	e7f9      	b.n	e702 <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY+0x34>
    e70e:	4430      	add	r0, r6
    e710:	1e40      	subs	r0, r0, #1
    e712:	fbb0 f1f6 	udiv	r1, r0, r6
    e716:	fb01 f006 	mul.w	r0, r1, r6
    e71a:	1828      	adds	r0, r5, r0
    e71c:	f144 0400 	adc.w	r4, r4, #0
    e720:	e9c7 0404 	strd	r0, r4, [r7, #16]
    e724:	4608      	mov	r0, r1
    e726:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e72a:	2000      	movs	r0, #0
    e72c:	e7fb      	b.n	e726 <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY+0x58>

0000e72e <sym_C5MZWIO7BXLJIO65K7CGSHP3SLST2VORSHVBOVI>:
    e72e:	b530      	push	{r4, r5, lr}
    e730:	4613      	mov	r3, r2
    e732:	e006      	b.n	e742 <sym_C5MZWIO7BXLJIO65K7CGSHP3SLST2VORSHVBOVI+0x14>
    e734:	18cc      	adds	r4, r1, r3
    e736:	1ad5      	subs	r5, r2, r3
    e738:	f814 4c01 	ldrb.w	r4, [r4, #-1]
    e73c:	1e5b      	subs	r3, r3, #1
    e73e:	5544      	strb	r4, [r0, r5]
    e740:	b2db      	uxtb	r3, r3
    e742:	2b00      	cmp	r3, #0
    e744:	d1f6      	bne.n	e734 <sym_C5MZWIO7BXLJIO65K7CGSHP3SLST2VORSHVBOVI+0x6>
    e746:	bd30      	pop	{r4, r5, pc}

0000e748 <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II>:
    e748:	b538      	push	{r3, r4, r5, lr}
    e74a:	4605      	mov	r5, r0
    e74c:	460c      	mov	r4, r1
    e74e:	4668      	mov	r0, sp
    e750:	f7fd fcc6 	bl	c0e0 <sym_EZCFQXKGAFHY5HQVJOXWDLO45XWMEJQY5WUGZNI>
    e754:	b310      	cbz	r0, e79c <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II+0x54>
    e756:	f99d 0000 	ldrsb.w	r0, [sp]
    e75a:	7260      	strb	r0, [r4, #9]
    e75c:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
    e760:	72a1      	strb	r1, [r4, #10]
    e762:	f994 100b 	ldrsb.w	r1, [r4, #11]
    e766:	2200      	movs	r2, #0
    e768:	1a41      	subs	r1, r0, r1
    e76a:	d500      	bpl.n	e76e <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II+0x26>
    e76c:	4249      	negs	r1, r1
    e76e:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
    e772:	428b      	cmp	r3, r1
    e774:	dc10      	bgt.n	e798 <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II+0x50>
    e776:	2bff      	cmp	r3, #255	; 0xff
    e778:	d00e      	beq.n	e798 <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II+0x50>
    e77a:	7b21      	ldrb	r1, [r4, #12]
    e77c:	1c49      	adds	r1, r1, #1
    e77e:	b2c9      	uxtb	r1, r1
    e780:	7321      	strb	r1, [r4, #12]
    e782:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    e786:	4299      	cmp	r1, r3
    e788:	d802      	bhi.n	e790 <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II+0x48>
    e78a:	7ae1      	ldrb	r1, [r4, #11]
    e78c:	297f      	cmp	r1, #127	; 0x7f
    e78e:	d103      	bne.n	e798 <sym_ATHPLOWBGAIKG7V5SSPNEEN27AC3OGL2HEWE4II+0x50>
    e790:	72e0      	strb	r0, [r4, #11]
    e792:	2000      	movs	r0, #0
    e794:	7320      	strb	r0, [r4, #12]
    e796:	2201      	movs	r2, #1
    e798:	4610      	mov	r0, r2
    e79a:	bd38      	pop	{r3, r4, r5, pc}
    e79c:	207f      	movs	r0, #127	; 0x7f
    e79e:	7260      	strb	r0, [r4, #9]
    e7a0:	2000      	movs	r0, #0
    e7a2:	bd38      	pop	{r3, r4, r5, pc}

0000e7a4 <sym_3LQGLF52CJLOKQOJSNFVLTD3CW6GGPJMARVGQNQ>:
    e7a4:	2300      	movs	r3, #0
    e7a6:	6303      	str	r3, [r0, #48]	; 0x30
    e7a8:	8702      	strh	r2, [r0, #56]	; 0x38
    e7aa:	f240 2371 	movw	r3, #625	; 0x271
    e7ae:	435a      	muls	r2, r3
    e7b0:	eb01 1202 	add.w	r2, r1, r2, lsl #4
    e7b4:	1e52      	subs	r2, r2, #1
    e7b6:	fbb2 f1f1 	udiv	r1, r2, r1
    e7ba:	6341      	str	r1, [r0, #52]	; 0x34
    e7bc:	4770      	bx	lr

0000e7be <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q>:
    e7be:	e92d 5ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    e7c2:	4607      	mov	r7, r0
    e7c4:	4690      	mov	r8, r2
    e7c6:	468b      	mov	fp, r1
    e7c8:	2601      	movs	r6, #1
    e7ca:	4608      	mov	r0, r1
    e7cc:	f000 f94a 	bl	ea64 <sym_GRRIKVTWBW2KWQ7YPR62UQBT5XVQYKO2LIWXODY>
    e7d0:	4682      	mov	sl, r0
    e7d2:	4658      	mov	r0, fp
    e7d4:	f000 f952 	bl	ea7c <sym_6HFAHFLWDMEYCQ4GR3OXMWUSK4H5E4C2QPT3NZA>
    e7d8:	4681      	mov	r9, r0
    e7da:	f7ff ff58 	bl	e68e <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI>
    e7de:	4604      	mov	r4, r0
    e7e0:	4650      	mov	r0, sl
    e7e2:	f7ff ff54 	bl	e68e <sym_FRDCUWW6PTM2YTBQLG5XNT6WJGPFH2XWEMJXJRI>
    e7e6:	4605      	mov	r5, r0
    e7e8:	ea54 0005 	orrs.w	r0, r4, r5
    e7ec:	d100      	bne.n	e7f0 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x32>
    e7ee:	2600      	movs	r6, #0
    e7f0:	f7fc ff28 	bl	b644 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ>
    e7f4:	ea10 0f09 	tst.w	r0, r9
    e7f8:	d100      	bne.n	e7fc <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x3e>
    e7fa:	2400      	movs	r4, #0
    e7fc:	f7fc ff22 	bl	b644 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ>
    e800:	ea10 0f0a 	tst.w	r0, sl
    e804:	d100      	bne.n	e808 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x4a>
    e806:	2500      	movs	r5, #0
    e808:	f897 006e 	ldrb.w	r0, [r7, #110]	; 0x6e
    e80c:	42a0      	cmp	r0, r4
    e80e:	d100      	bne.n	e812 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x54>
    e810:	2400      	movs	r4, #0
    e812:	f888 4000 	strb.w	r4, [r8]
    e816:	f897 006f 	ldrb.w	r0, [r7, #111]	; 0x6f
    e81a:	42a8      	cmp	r0, r5
    e81c:	d100      	bne.n	e820 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x62>
    e81e:	2500      	movs	r5, #0
    e820:	f888 5001 	strb.w	r5, [r8, #1]
    e824:	b974      	cbnz	r4, e844 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x86>
    e826:	b96d      	cbnz	r5, e844 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x86>
    e828:	4658      	mov	r0, fp
    e82a:	f000 f925 	bl	ea78 <sym_VMI6LAIHFJODZECDSALRIOKPVGLRUJ6WTCP43FY>
    e82e:	f8b7 107c 	ldrh.w	r1, [r7, #124]	; 0x7c
    e832:	1a40      	subs	r0, r0, r1
    e834:	b200      	sxth	r0, r0
    e836:	f647 71fe 	movw	r1, #32766	; 0x7ffe
    e83a:	4288      	cmp	r0, r1
    e83c:	dc01      	bgt.n	e842 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x84>
    e83e:	2800      	cmp	r0, #0
    e840:	dc00      	bgt.n	e844 <sym_ZX776SCJSI3JTFST57XOZBXAMGDDC7FRRHZEJ7Q+0x86>
    e842:	2600      	movs	r6, #0
    e844:	4630      	mov	r0, r6
    e846:	e8bd 9ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}

0000e84a <sym_5SQGEOI2QIBONU3LMZVAMW3SSGU24TVE57VDLBA>:
    e84a:	f240 41e2 	movw	r1, #1250	; 0x4e2
    e84e:	4348      	muls	r0, r1
    e850:	4770      	bx	lr

0000e852 <sym_NREHYZNNGMA6T4VUMP47EJMM5IU7BRHAZURXRLQ>:
    e852:	f240 2171 	movw	r1, #625	; 0x271
    e856:	fb10 f001 	smulbb	r0, r0, r1
    e85a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e85e:	ea01 0040 	and.w	r0, r1, r0, lsl #1
    e862:	4770      	bx	lr

0000e864 <sym_35JWAFJL2IEYRDNORVIQ7BBAS7FQNUVOFCLQNSQ>:
    e864:	b510      	push	{r4, lr}
    e866:	2300      	movs	r3, #0
    e868:	461a      	mov	r2, r3
    e86a:	e003      	b.n	e874 <sym_35JWAFJL2IEYRDNORVIQ7BBAS7FQNUVOFCLQNSQ+0x10>
    e86c:	5c84      	ldrb	r4, [r0, r2]
    e86e:	4323      	orrs	r3, r4
    e870:	1c52      	adds	r2, r2, #1
    e872:	b2d2      	uxtb	r2, r2
    e874:	428a      	cmp	r2, r1
    e876:	d3f9      	bcc.n	e86c <sym_35JWAFJL2IEYRDNORVIQ7BBAS7FQNUVOFCLQNSQ+0x8>
    e878:	b10b      	cbz	r3, e87e <sym_35JWAFJL2IEYRDNORVIQ7BBAS7FQNUVOFCLQNSQ+0x1a>
    e87a:	2000      	movs	r0, #0
    e87c:	bd10      	pop	{r4, pc}
    e87e:	2001      	movs	r0, #1
    e880:	bd10      	pop	{r4, pc}

0000e882 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA>:
    e882:	b510      	push	{r4, lr}
    e884:	4604      	mov	r4, r0
    e886:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
    e88a:	b108      	cbz	r0, e890 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA+0xe>
    e88c:	2825      	cmp	r0, #37	; 0x25
    e88e:	d901      	bls.n	e894 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA+0x12>
    e890:	2012      	movs	r0, #18
    e892:	bd10      	pop	{r4, pc}
    e894:	b12a      	cbz	r2, e8a2 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA+0x20>
    e896:	7da0      	ldrb	r0, [r4, #22]
    e898:	b128      	cbz	r0, e8a6 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA+0x24>
    e89a:	2801      	cmp	r0, #1
    e89c:	d009      	beq.n	e8b2 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA+0x30>
    e89e:	201f      	movs	r0, #31
    e8a0:	bd10      	pop	{r4, pc}
    e8a2:	2000      	movs	r0, #0
    e8a4:	bd10      	pop	{r4, pc}
    e8a6:	4620      	mov	r0, r4
    e8a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e8ac:	4611      	mov	r1, r2
    e8ae:	f7f8 bb6b 	b.w	6f88 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ+0xa8>
    e8b2:	88a2      	ldrh	r2, [r4, #4]
    e8b4:	6949      	ldr	r1, [r1, #20]
    e8b6:	f104 0016 	add.w	r0, r4, #22
    e8ba:	f7f8 fb11 	bl	6ee0 <sym_KHCOV3Y476ESNIVYZPGAZMIYAIZNR3YMGCWNDEQ>
    e8be:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
    e8c2:	e7ee      	b.n	e8a2 <sym_EMRT7PRPOJDVU5Z5ET5VJFU2CWFE2OMTIKS35RA+0x20>

0000e8c4 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I>:
    e8c4:	b530      	push	{r4, r5, lr}
    e8c6:	1c42      	adds	r2, r0, #1
    e8c8:	428a      	cmp	r2, r1
    e8ca:	d004      	beq.n	e8d6 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x12>
    e8cc:	680a      	ldr	r2, [r1, #0]
    e8ce:	f8c0 2001 	str.w	r2, [r0, #1]
    e8d2:	7909      	ldrb	r1, [r1, #4]
    e8d4:	7141      	strb	r1, [r0, #5]
    e8d6:	7941      	ldrb	r1, [r0, #5]
    e8d8:	f001 011f 	and.w	r1, r1, #31
    e8dc:	7141      	strb	r1, [r0, #5]
    e8de:	2100      	movs	r1, #0
    e8e0:	72c1      	strb	r1, [r0, #11]
    e8e2:	1843      	adds	r3, r0, r1
    e8e4:	1c49      	adds	r1, r1, #1
    e8e6:	785c      	ldrb	r4, [r3, #1]
    e8e8:	b2c9      	uxtb	r1, r1
    e8ea:	f004 0201 	and.w	r2, r4, #1
    e8ee:	0864      	lsrs	r4, r4, #1
    e8f0:	f004 0501 	and.w	r5, r4, #1
    e8f4:	4415      	add	r5, r2
    e8f6:	0862      	lsrs	r2, r4, #1
    e8f8:	f002 0401 	and.w	r4, r2, #1
    e8fc:	442c      	add	r4, r5
    e8fe:	0852      	lsrs	r2, r2, #1
    e900:	f002 0501 	and.w	r5, r2, #1
    e904:	442c      	add	r4, r5
    e906:	0852      	lsrs	r2, r2, #1
    e908:	f002 0501 	and.w	r5, r2, #1
    e90c:	442c      	add	r4, r5
    e90e:	0852      	lsrs	r2, r2, #1
    e910:	f002 0501 	and.w	r5, r2, #1
    e914:	442c      	add	r4, r5
    e916:	0852      	lsrs	r2, r2, #1
    e918:	f002 0501 	and.w	r5, r2, #1
    e91c:	442c      	add	r4, r5
    e91e:	eb04 0252 	add.w	r2, r4, r2, lsr #1
    e922:	719a      	strb	r2, [r3, #6]
    e924:	7ac3      	ldrb	r3, [r0, #11]
    e926:	2905      	cmp	r1, #5
    e928:	441a      	add	r2, r3
    e92a:	72c2      	strb	r2, [r0, #11]
    e92c:	d3d9      	bcc.n	e8e2 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x1e>
    e92e:	bd30      	pop	{r4, r5, pc}
    e930:	b570      	push	{r4, r5, r6, lr}
    e932:	f8d0 201f 	ldr.w	r2, [r0, #31]
    e936:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    e93a:	f012 0fff 	tst.w	r2, #255	; 0xff
    e93e:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
    e942:	d108      	bne.n	e956 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x92>
    e944:	f3c2 2407 	ubfx	r4, r2, #8, #8
    e948:	b92c      	cbnz	r4, e956 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x92>
    e94a:	f3c2 4407 	ubfx	r4, r2, #16, #8
    e94e:	b914      	cbnz	r4, e956 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x92>
    e950:	0e12      	lsrs	r2, r2, #24
    e952:	d100      	bne.n	e956 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x92>
    e954:	b35b      	cbz	r3, e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e956:	f8b0 2019 	ldrh.w	r2, [r0, #25]
    e95a:	f8b0 501b 	ldrh.w	r5, [r0, #27]
    e95e:	f8b0 4017 	ldrh.w	r4, [r0, #23]
    e962:	7d83      	ldrb	r3, [r0, #22]
    e964:	b141      	cbz	r1, e978 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xb4>
    e966:	f5b2 6f50 	cmp.w	r2, #3328	; 0xd00
    e96a:	d905      	bls.n	e978 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xb4>
    e96c:	f640 5107 	movw	r1, #3335	; 0xd07
    e970:	428a      	cmp	r2, r1
    e972:	d801      	bhi.n	e978 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xb4>
    e974:	2101      	movs	r1, #1
    e976:	e000      	b.n	e97a <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xb6>
    e978:	2100      	movs	r1, #0
    e97a:	7846      	ldrb	r6, [r0, #1]
    e97c:	2e22      	cmp	r6, #34	; 0x22
    e97e:	d116      	bne.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e980:	b959      	cbnz	r1, e99a <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xd6>
    e982:	1f91      	subs	r1, r2, #6
    e984:	f640 467a 	movw	r6, #3194	; 0xc7a
    e988:	42b1      	cmp	r1, r6
    e98a:	d810      	bhi.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e98c:	b17b      	cbz	r3, e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e98e:	2b08      	cmp	r3, #8
    e990:	d80d      	bhi.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e992:	4293      	cmp	r3, r2
    e994:	d20b      	bcs.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e996:	4294      	cmp	r4, r2
    e998:	d809      	bhi.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e99a:	f5b5 7ffa 	cmp.w	r5, #500	; 0x1f4
    e99e:	d206      	bcs.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e9a0:	f8b0 001d 	ldrh.w	r0, [r0, #29]
    e9a4:	f5b0 6f48 	cmp.w	r0, #3200	; 0xc80
    e9a8:	d801      	bhi.n	e9ae <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0xea>
    e9aa:	2001      	movs	r0, #1
    e9ac:	bd70      	pop	{r4, r5, r6, pc}
    e9ae:	2000      	movs	r0, #0
    e9b0:	bd70      	pop	{r4, r5, r6, pc}

0000e9b2 <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ>:
    e9b2:	b570      	push	{r4, r5, r6, lr}
    e9b4:	f8b0 2007 	ldrh.w	r2, [r0, #7]
    e9b8:	f8b0 5009 	ldrh.w	r5, [r0, #9]
    e9bc:	f830 4f05 	ldrh.w	r4, [r0, #5]!
    e9c0:	f810 3c01 	ldrb.w	r3, [r0, #-1]
    e9c4:	88c0      	ldrh	r0, [r0, #6]
    e9c6:	b131      	cbz	r1, e9d6 <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x24>
    e9c8:	f5b2 6f50 	cmp.w	r2, #3328	; 0xd00
    e9cc:	d903      	bls.n	e9d6 <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x24>
    e9ce:	f640 5107 	movw	r1, #3335	; 0xd07
    e9d2:	428a      	cmp	r2, r1
    e9d4:	d90b      	bls.n	e9ee <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x3c>
    e9d6:	1f91      	subs	r1, r2, #6
    e9d8:	f640 467a 	movw	r6, #3194	; 0xc7a
    e9dc:	42b1      	cmp	r1, r6
    e9de:	d80e      	bhi.n	e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9e0:	b16b      	cbz	r3, e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9e2:	2b08      	cmp	r3, #8
    e9e4:	d80b      	bhi.n	e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9e6:	4293      	cmp	r3, r2
    e9e8:	d209      	bcs.n	e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9ea:	4294      	cmp	r4, r2
    e9ec:	d807      	bhi.n	e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9ee:	f5b5 7ffa 	cmp.w	r5, #500	; 0x1f4
    e9f2:	d204      	bcs.n	e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9f4:	f5b0 6f48 	cmp.w	r0, #3200	; 0xc80
    e9f8:	d801      	bhi.n	e9fe <sym_SYUCVPKBWJVHVFRFN5N4446ZSHSJVKBYOSWHGGQ+0x4c>
    e9fa:	2001      	movs	r0, #1
    e9fc:	bd70      	pop	{r4, r5, r6, pc}
    e9fe:	2000      	movs	r0, #0
    ea00:	bd70      	pop	{r4, r5, r6, pc}

0000ea02 <sym_Z4ZI42RGZMV4HNY7AR3E37XXZ7IMFK22Y6ETFMA>:
    ea02:	6842      	ldr	r2, [r0, #4]
    ea04:	600a      	str	r2, [r1, #0]
    ea06:	7a00      	ldrb	r0, [r0, #8]
    ea08:	7108      	strb	r0, [r1, #4]
    ea0a:	4770      	bx	lr

0000ea0c <sym_WMWALCDSCSGIPZVRYNPCN3Z65BL7HB3ZVUDUXCQ>:
    ea0c:	f8b0 0009 	ldrh.w	r0, [r0, #9]
    ea10:	4770      	bx	lr

0000ea12 <sym_O2B23O5JYMOMMFH6X6KNGJ752KMNUHBQLRFJPCA>:
    ea12:	f8b0 0007 	ldrh.w	r0, [r0, #7]
    ea16:	4770      	bx	lr

0000ea18 <sym_GKNOWO7GMUO66Z63YGKTWG2BRIW6TPGP7PUQ2RQ>:
    ea18:	f8b0 0009 	ldrh.w	r0, [r0, #9]
    ea1c:	4770      	bx	lr

0000ea1e <sym_CLMBK65KRQWY2JSWG7BYXAJVRACUXOCNFT2IPRY>:
    ea1e:	f8b0 000b 	ldrh.w	r0, [r0, #11]
    ea22:	4770      	bx	lr

0000ea24 <sym_RM2CYFWBBAMZ6QU7KT5244O7T6GTURMYRG2CBQQ>:
    ea24:	8980      	ldrh	r0, [r0, #12]
    ea26:	8008      	strh	r0, [r1, #0]
    ea28:	4770      	bx	lr

0000ea2a <sym_3TJYOSQOHQD2677U7JVMG6ZM2AEKI337QVGY7TA>:
    ea2a:	f8d0 0016 	ldr.w	r0, [r0, #22]
    ea2e:	6008      	str	r0, [r1, #0]
    ea30:	4770      	bx	lr

0000ea32 <sym_GVKSQ3HVAAAYIHJ3KPHNCAN4HXAZB6BCZZN5T2Q>:
    ea32:	6842      	ldr	r2, [r0, #4]
    ea34:	600a      	str	r2, [r1, #0]
    ea36:	6880      	ldr	r0, [r0, #8]
    ea38:	6048      	str	r0, [r1, #4]
    ea3a:	4770      	bx	lr

0000ea3c <sym_LSOEOXZGNVP5DB6ZYJ7WAAXWSU5HO7R25UQZZBQ>:
    ea3c:	f850 2f0e 	ldr.w	r2, [r0, #14]!
    ea40:	600a      	str	r2, [r1, #0]
    ea42:	6840      	ldr	r0, [r0, #4]
    ea44:	6048      	str	r0, [r1, #4]
    ea46:	4770      	bx	lr

0000ea48 <sym_MMYJZLVXCKMFPUNAECUW6DM3QIRIH47IIFXKCBY>:
    ea48:	6842      	ldr	r2, [r0, #4]
    ea4a:	600a      	str	r2, [r1, #0]
    ea4c:	6880      	ldr	r0, [r0, #8]
    ea4e:	6048      	str	r0, [r1, #4]
    ea50:	4770      	bx	lr

0000ea52 <sym_KIWKQDEBPWXHISYFTEC7I32RP3MHD6CJEPVDW6I>:
    ea52:	6842      	ldr	r2, [r0, #4]
    ea54:	600a      	str	r2, [r1, #0]
    ea56:	6880      	ldr	r0, [r0, #8]
    ea58:	6048      	str	r0, [r1, #4]
    ea5a:	4770      	bx	lr

0000ea5c <sym_66SPI42RVSYPTJAEZPQR5PX32WQ6ZUXVEH3D2OI>:
    ea5c:	7800      	ldrb	r0, [r0, #0]
    ea5e:	f000 0003 	and.w	r0, r0, #3
    ea62:	4770      	bx	lr

0000ea64 <sym_GRRIKVTWBW2KWQ7YPR62UQBT5XVQYKO2LIWXODY>:
    ea64:	7900      	ldrb	r0, [r0, #4]
    ea66:	4770      	bx	lr

0000ea68 <sym_AWXBPGMPTTTWF7DPZL5Q2JQ4QSDFRJFHKF3BIIQ>:
    ea68:	8880      	ldrh	r0, [r0, #4]
    ea6a:	4770      	bx	lr

0000ea6c <sym_GPYTTEK2KDNR73G6ZAXHATMSQZASIEW24RTZFJA>:
    ea6c:	88c0      	ldrh	r0, [r0, #6]
    ea6e:	4770      	bx	lr

0000ea70 <sym_IR77N76GC2RMGAYGDAEPSAGD4DPXFGWMASI3OGY>:
    ea70:	8900      	ldrh	r0, [r0, #8]
    ea72:	4770      	bx	lr

0000ea74 <sym_WC6UZSDJDS7GHVUUG36QUD3XWMICRFA5JJX42VA>:
    ea74:	8940      	ldrh	r0, [r0, #10]
    ea76:	4770      	bx	lr

0000ea78 <sym_VMI6LAIHFJODZECDSALRIOKPVGLRUJ6WTCP43FY>:
    ea78:	88c0      	ldrh	r0, [r0, #6]
    ea7a:	4770      	bx	lr

0000ea7c <sym_6HFAHFLWDMEYCQ4GR3OXMWUSK4H5E4C2QPT3NZA>:
    ea7c:	7940      	ldrb	r0, [r0, #5]
    ea7e:	4770      	bx	lr

0000ea80 <sym_WRY64WR3RHFREREX3ZB66OLRGKHGDAUZMHJMBCI>:
    ea80:	7900      	ldrb	r0, [r0, #4]
    ea82:	4770      	bx	lr

0000ea84 <sym_FES4SNLGDB2HCH3XYZK52SHDPFDGL5NN3ARGNTY>:
    ea84:	7900      	ldrb	r0, [r0, #4]
    ea86:	4770      	bx	lr

0000ea88 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI>:
    ea88:	8901      	ldrh	r1, [r0, #8]
    ea8a:	291b      	cmp	r1, #27
    ea8c:	d30c      	bcc.n	eaa8 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI+0x20>
    ea8e:	8941      	ldrh	r1, [r0, #10]
    ea90:	f44f 72a4 	mov.w	r2, #328	; 0x148
    ea94:	4291      	cmp	r1, r2
    ea96:	d307      	bcc.n	eaa8 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI+0x20>
    ea98:	8881      	ldrh	r1, [r0, #4]
    ea9a:	291b      	cmp	r1, #27
    ea9c:	d304      	bcc.n	eaa8 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI+0x20>
    ea9e:	88c0      	ldrh	r0, [r0, #6]
    eaa0:	4290      	cmp	r0, r2
    eaa2:	d301      	bcc.n	eaa8 <sym_XNOKOPU7R2ZL4VYDMQPD5QQ2YM2WYINLYLRQ4TI+0x20>
    eaa4:	2001      	movs	r0, #1
    eaa6:	4770      	bx	lr
    eaa8:	2000      	movs	r0, #0
    eaaa:	4770      	bx	lr

0000eaac <sym_Z7V4WMT2JDSQSNPCH2UEJH6H44L3L7UHMRIWAOA>:
    eaac:	b510      	push	{r4, lr}
    eaae:	29fb      	cmp	r1, #251	; 0xfb
    eab0:	d904      	bls.n	eabc <sym_Z7V4WMT2JDSQSNPCH2UEJH6H44L3L7UHMRIWAOA+0x10>
    eab2:	f240 51fe 	movw	r1, #1534	; 0x5fe
    eab6:	202a      	movs	r0, #42	; 0x2a
    eab8:	f7f6 fb4c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    eabc:	7041      	strb	r1, [r0, #1]
    eabe:	bd10      	pop	{r4, pc}

0000eac0 <sym_RPQNXSNTPADDKXP5RSAMGT6PEA6HJ6WJSJ5DQUA>:
    eac0:	7901      	ldrb	r1, [r0, #4]
    eac2:	0749      	lsls	r1, r1, #29
    eac4:	d004      	beq.n	ead0 <sym_RPQNXSNTPADDKXP5RSAMGT6PEA6HJ6WJSJ5DQUA+0x10>
    eac6:	7940      	ldrb	r0, [r0, #5]
    eac8:	0740      	lsls	r0, r0, #29
    eaca:	d001      	beq.n	ead0 <sym_RPQNXSNTPADDKXP5RSAMGT6PEA6HJ6WJSJ5DQUA+0x10>
    eacc:	2001      	movs	r0, #1
    eace:	4770      	bx	lr
    ead0:	2000      	movs	r0, #0
    ead2:	4770      	bx	lr

0000ead4 <sym_OIELJZXQUH4XDAK7XBXBJX4CE2IIXWLOTEZEOSI>:
    ead4:	7901      	ldrb	r1, [r0, #4]
    ead6:	7940      	ldrb	r0, [r0, #5]
    ead8:	f001 0107 	and.w	r1, r1, #7
    eadc:	1e4a      	subs	r2, r1, #1
    eade:	f000 0007 	and.w	r0, r0, #7
    eae2:	4011      	ands	r1, r2
    eae4:	1e42      	subs	r2, r0, #1
    eae6:	4010      	ands	r0, r2
    eae8:	4301      	orrs	r1, r0
    eaea:	d001      	beq.n	eaf0 <sym_OIELJZXQUH4XDAK7XBXBJX4CE2IIXWLOTEZEOSI+0x1c>
    eaec:	2000      	movs	r0, #0
    eaee:	4770      	bx	lr
    eaf0:	2001      	movs	r0, #1
    eaf2:	4770      	bx	lr

0000eaf4 <sym_V37KOABA26BNKOPPXCRMHM2FBYFAD7NU4IA7EIQ>:
    eaf4:	7900      	ldrb	r0, [r0, #4]
    eaf6:	4770      	bx	lr

0000eaf8 <sym_I6A5ME4L4BDSYALCIKK2V6NRQKRM5QI7WNBE2CA>:
    eaf8:	7940      	ldrb	r0, [r0, #5]
    eafa:	4770      	bx	lr

0000eafc <sym_2AEWUZQ66QOZRZKHF7IFSSSWOGAXMPPQQH7267Y>:
    eafc:	7101      	strb	r1, [r0, #4]
    eafe:	4770      	bx	lr

0000eb00 <sym_AG7JDKFTDFANNIOBH4HEQO2XNU7V2OR3R525SOY>:
    eb00:	7141      	strb	r1, [r0, #5]
    eb02:	4770      	bx	lr

0000eb04 <sym_KDG27CITYLRG66Y5P6H5BVIHPU5DAFDVHM7DSQA>:
    eb04:	b510      	push	{r4, lr}
    eb06:	2a1b      	cmp	r2, #27
    eb08:	d904      	bls.n	eb14 <sym_KDG27CITYLRG66Y5P6H5BVIHPU5DAFDVHM7DSQA+0x10>
    eb0a:	f240 4127 	movw	r1, #1063	; 0x427
    eb0e:	202a      	movs	r0, #42	; 0x2a
    eb10:	f7f6 fb20 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    eb14:	7042      	strb	r2, [r0, #1]
    eb16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    eb1a:	1cc0      	adds	r0, r0, #3
    eb1c:	f7fe ba5e 	b.w	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>

0000eb20 <sym_VUV5X4H4Y5BCHQYQ2OODYEDUWFHSSL4GLPT4S5Q>:
    eb20:	6809      	ldr	r1, [r1, #0]
    eb22:	60c1      	str	r1, [r0, #12]
    eb24:	4770      	bx	lr

0000eb26 <sym_GACCOL6OK5AZZZEY5D5QPNSIBJI3JJRDH53DCCY>:
    eb26:	680a      	ldr	r2, [r1, #0]
    eb28:	6042      	str	r2, [r0, #4]
    eb2a:	6849      	ldr	r1, [r1, #4]
    eb2c:	6081      	str	r1, [r0, #8]
    eb2e:	4770      	bx	lr

0000eb30 <sym_ALFHFCPCHQINI4F6NU6LJJP26B4M2FERQPHDBAI>:
    eb30:	680a      	ldr	r2, [r1, #0]
    eb32:	6042      	str	r2, [r0, #4]
    eb34:	6849      	ldr	r1, [r1, #4]
    eb36:	6081      	str	r1, [r0, #8]
    eb38:	4770      	bx	lr

0000eb3a <sym_ATMVKJRU6FJAJXHYSHEXCCKRTDJACEACYJQFGVQ>:
    eb3a:	680a      	ldr	r2, [r1, #0]
    eb3c:	6042      	str	r2, [r0, #4]
    eb3e:	6849      	ldr	r1, [r1, #4]
    eb40:	6081      	str	r1, [r0, #8]
    eb42:	4770      	bx	lr

0000eb44 <sym_KWWW3Q4Z6LMHA6EXR6CMFCOS3QXXZ636XUAHVBY>:
    eb44:	7802      	ldrb	r2, [r0, #0]
    eb46:	f001 0103 	and.w	r1, r1, #3
    eb4a:	f002 02fc 	and.w	r2, r2, #252	; 0xfc
    eb4e:	430a      	orrs	r2, r1
    eb50:	7002      	strb	r2, [r0, #0]
    eb52:	4770      	bx	lr

0000eb54 <sym_5WASOMRPEYEGPJYIYCZL3MI6RFVOLW4PF3WQWXQ>:
    eb54:	7101      	strb	r1, [r0, #4]
    eb56:	0a09      	lsrs	r1, r1, #8
    eb58:	7141      	strb	r1, [r0, #5]
    eb5a:	4770      	bx	lr

0000eb5c <sym_65OGIL725U6FQPGLZMGDICIUHB5S2P2UG7UZGMY>:
    eb5c:	7181      	strb	r1, [r0, #6]
    eb5e:	0a09      	lsrs	r1, r1, #8
    eb60:	71c1      	strb	r1, [r0, #7]
    eb62:	4770      	bx	lr

0000eb64 <sym_DPBBMGOHRJRJWIFBTEHPLVVPOEIMHXK2HYFFW2A>:
    eb64:	7201      	strb	r1, [r0, #8]
    eb66:	0a09      	lsrs	r1, r1, #8
    eb68:	7241      	strb	r1, [r0, #9]
    eb6a:	4770      	bx	lr

0000eb6c <sym_F72ACBYKMJPI25JMH6PCTUEZPH6HMPJHM2HMJDY>:
    eb6c:	7281      	strb	r1, [r0, #10]
    eb6e:	0a09      	lsrs	r1, r1, #8
    eb70:	72c1      	strb	r1, [r0, #11]
    eb72:	4770      	bx	lr

0000eb74 <sym_7FFMBSDVRVZYH5XO7CHX33376QMIMFS3BQD5N7I>:
    eb74:	7802      	ldrb	r2, [r0, #0]
    eb76:	f002 020f 	and.w	r2, r2, #15
    eb7a:	2a03      	cmp	r2, #3
    eb7c:	d003      	beq.n	eb86 <sym_7FFMBSDVRVZYH5XO7CHX33376QMIMFS3BQD5N7I+0x12>
    eb7e:	2a05      	cmp	r2, #5
    eb80:	d104      	bne.n	eb8c <sym_7FFMBSDVRVZYH5XO7CHX33376QMIMFS3BQD5N7I+0x18>
    eb82:	f7ff bed5 	b.w	e930 <sym_DGQRK6XVXAAPQDRCJOVOHOTQ47PE7QQ4MNBOW5I+0x6c>
    eb86:	7840      	ldrb	r0, [r0, #1]
    eb88:	280c      	cmp	r0, #12
    eb8a:	d001      	beq.n	eb90 <sym_7FFMBSDVRVZYH5XO7CHX33376QMIMFS3BQD5N7I+0x1c>
    eb8c:	2000      	movs	r0, #0
    eb8e:	4770      	bx	lr
    eb90:	2001      	movs	r0, #1
    eb92:	4770      	bx	lr

0000eb94 <sym_AIYUY22PH5CFYGFYYYX5TRDP6GAU3UXOBISKF2I>:
    eb94:	b570      	push	{r4, r5, r6, lr}
    eb96:	4614      	mov	r4, r2
    eb98:	4605      	mov	r5, r0
    eb9a:	2a1f      	cmp	r2, #31
    eb9c:	d903      	bls.n	eba6 <sym_AIYUY22PH5CFYGFYYYX5TRDP6GAU3UXOBISKF2I+0x12>
    eb9e:	21b5      	movs	r1, #181	; 0xb5
    eba0:	202a      	movs	r0, #42	; 0x2a
    eba2:	f7f6 fad7 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    eba6:	f105 0009 	add.w	r0, r5, #9
    ebaa:	f7fe fa17 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    ebae:	1da4      	adds	r4, r4, #6
    ebb0:	706c      	strb	r4, [r5, #1]
    ebb2:	bd70      	pop	{r4, r5, r6, pc}

0000ebb4 <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY>:
    ebb4:	b510      	push	{r4, lr}
    ebb6:	7802      	ldrb	r2, [r0, #0]
    ebb8:	f001 030f 	and.w	r3, r1, #15
    ebbc:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
    ebc0:	431a      	orrs	r2, r3
    ebc2:	7002      	strb	r2, [r0, #0]
    ebc4:	2907      	cmp	r1, #7
    ebc6:	d20c      	bcs.n	ebe2 <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY+0x2e>
    ebc8:	e8df f001 	tbb	[pc, r1]
    ebcc:	06040604 	.word	0x06040604
    ebd0:	00040804 	.word	0x00040804
    ebd4:	2106      	movs	r1, #6
    ebd6:	e002      	b.n	ebde <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY+0x2a>
    ebd8:	210c      	movs	r1, #12
    ebda:	e000      	b.n	ebde <sym_ZJ2REXSOGBKJNHWVNXMDASZYI7CQBWWO2RMVAVY+0x2a>
    ebdc:	2122      	movs	r1, #34	; 0x22
    ebde:	7041      	strb	r1, [r0, #1]
    ebe0:	bd10      	pop	{r4, pc}
    ebe2:	216f      	movs	r1, #111	; 0x6f
    ebe4:	202a      	movs	r0, #42	; 0x2a
    ebe6:	f7f6 fab5 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>

0000ebea <sym_6GC7CC2BUFLCMQVOZDACHKZEET4WUCXSLEMHSCY>:
    ebea:	680a      	ldr	r2, [r1, #0]
    ebec:	f840 2f09 	str.w	r2, [r0, #9]!
    ebf0:	8889      	ldrh	r1, [r1, #4]
    ebf2:	8081      	strh	r1, [r0, #4]
    ebf4:	4770      	bx	lr

0000ebf6 <sym_6FJEZEEBKMCAKI6FMPGNQ7TUXYDPYPEPSNJFOMQ>:
    ebf6:	7802      	ldrb	r2, [r0, #0]
    ebf8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    ebfc:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
    ec00:	7002      	strb	r2, [r0, #0]
    ec02:	4770      	bx	lr

0000ec04 <sym_5JID42ESVW3PB7AVBNALO6R7DLTBIV3DUQMUPQY>:
    ec04:	680a      	ldr	r2, [r1, #0]
    ec06:	f840 2f03 	str.w	r2, [r0, #3]!
    ec0a:	8889      	ldrh	r1, [r1, #4]
    ec0c:	8081      	strh	r1, [r0, #4]
    ec0e:	4770      	bx	lr

0000ec10 <sym_K5Q3WMSYKQOD5SDB35E6WH2TTH6JWICUFV7AXJA>:
    ec10:	7802      	ldrb	r2, [r0, #0]
    ec12:	2340      	movs	r3, #64	; 0x40
    ec14:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
    ec18:	ea03 1181 	and.w	r1, r3, r1, lsl #6
    ec1c:	430a      	orrs	r2, r1
    ec1e:	7002      	strb	r2, [r0, #0]
    ec20:	4770      	bx	lr

0000ec22 <sym_MAMY3D3622JJLMFKLRQXSRTVOPUNWAAGSSCAVMY>:
    ec22:	b570      	push	{r4, r5, r6, lr}
    ec24:	4614      	mov	r4, r2
    ec26:	4605      	mov	r5, r0
    ec28:	2a1f      	cmp	r2, #31
    ec2a:	d903      	bls.n	ec34 <sym_MAMY3D3622JJLMFKLRQXSRTVOPUNWAAGSSCAVMY+0x12>
    ec2c:	21d7      	movs	r1, #215	; 0xd7
    ec2e:	202a      	movs	r0, #42	; 0x2a
    ec30:	f7f6 fa90 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    ec34:	f105 0009 	add.w	r0, r5, #9
    ec38:	f7fe f9d0 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    ec3c:	1da4      	adds	r4, r4, #6
    ec3e:	706c      	strb	r4, [r5, #1]
    ec40:	bd70      	pop	{r4, r5, r6, pc}

0000ec42 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I>:
    ec42:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    ec46:	4604      	mov	r4, r0
    ec48:	2000      	movs	r0, #0
    ec4a:	f7f6 fc79 	bl	5540 <sym_XHE47EZYHONCPR22HUAZULMCALDJINMYREOFDEI>
    ec4e:	2600      	movs	r6, #0
    ec50:	4605      	mov	r5, r0
    ec52:	4637      	mov	r7, r6
    ec54:	e00e      	b.n	ec74 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I+0x32>
    ec56:	8820      	ldrh	r0, [r4, #0]
    ec58:	1c40      	adds	r0, r0, #1
    ec5a:	b280      	uxth	r0, r0
    ec5c:	8020      	strh	r0, [r4, #0]
    ec5e:	42a8      	cmp	r0, r5
    ec60:	d300      	bcc.n	ec64 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I+0x22>
    ec62:	8027      	strh	r7, [r4, #0]
    ec64:	8820      	ldrh	r0, [r4, #0]
    ec66:	4669      	mov	r1, sp
    ec68:	f7ff fc4d 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    ec6c:	2800      	cmp	r0, #0
    ec6e:	d007      	beq.n	ec80 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I+0x3e>
    ec70:	1c76      	adds	r6, r6, #1
    ec72:	b2f6      	uxtb	r6, r6
    ec74:	42ae      	cmp	r6, r5
    ec76:	d3ee      	bcc.n	ec56 <sym_G7K5H2CRWCUUAX5LJNXCL36PP3OLK3XX7TBLE3I+0x14>
    ec78:	f64f 70ff 	movw	r0, #65535	; 0xffff
    ec7c:	8020      	strh	r0, [r4, #0]
    ec7e:	2012      	movs	r0, #18
    ec80:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}

0000ec84 <sym_24AALTDC2IQ6VNWU2ALOY4V3RG5R2RARTUG4AZY>:
    ec84:	6841      	ldr	r1, [r0, #4]
    ec86:	2200      	movs	r2, #0
    ec88:	f891 31d2 	ldrb.w	r3, [r1, #466]	; 0x1d2
    ec8c:	2b00      	cmp	r3, #0
    ec8e:	d004      	beq.n	ec9a <sym_24AALTDC2IQ6VNWU2ALOY4V3RG5R2RARTUG4AZY+0x16>
    ec90:	f881 21d2 	strb.w	r2, [r1, #466]	; 0x1d2
    ec94:	6840      	ldr	r0, [r0, #4]
    ec96:	f000 bd08 	b.w	f6aa <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y>
    ec9a:	4770      	bx	lr

0000ec9c <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA>:
    ec9c:	b510      	push	{r4, lr}
    ec9e:	7901      	ldrb	r1, [r0, #4]
    eca0:	b119      	cbz	r1, ecaa <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xe>
    eca2:	2901      	cmp	r1, #1
    eca4:	d006      	beq.n	ecb4 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x18>
    eca6:	2000      	movs	r0, #0
    eca8:	bd10      	pop	{r4, pc}
    ecaa:	8842      	ldrh	r2, [r0, #2]
    ecac:	6883      	ldr	r3, [r0, #8]
    ecae:	8800      	ldrh	r0, [r0, #0]
    ecb0:	2102      	movs	r1, #2
    ecb2:	e003      	b.n	ecbc <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x20>
    ecb4:	8842      	ldrh	r2, [r0, #2]
    ecb6:	6883      	ldr	r3, [r0, #8]
    ecb8:	8800      	ldrh	r0, [r0, #0]
    ecba:	2101      	movs	r1, #1
    ecbc:	f7f8 fa16 	bl	70ec <sym_BBCGHL23UJV466BYW2SHQ2OBUQH4NLFTPMY4GQA+0x54>
    ecc0:	b908      	cbnz	r0, ecc6 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x2a>
    ecc2:	f7f8 fa69 	bl	7198 <sym_HHT5YV37VWRBGUMO4AOJUKOJARZKAH2OUWPZF7Q>
    ecc6:	2001      	movs	r0, #1
    ecc8:	bd10      	pop	{r4, pc}
    ecca:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
    ecce:	460e      	mov	r6, r1
    ecd0:	f5a0 417f 	sub.w	r1, r0, #65280	; 0xff00
    ecd4:	4617      	mov	r7, r2
    ecd6:	39ff      	subs	r1, #255	; 0xff
    ecd8:	d014      	beq.n	ed04 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x68>
    ecda:	8030      	strh	r0, [r6, #0]
    ecdc:	2100      	movs	r1, #0
    ecde:	7171      	strb	r1, [r6, #5]
    ece0:	f7f6 fe60 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    ece4:	4604      	mov	r4, r0
    ece6:	f7fe ffa3 	bl	dc30 <sym_RZ3AO5KZJYCPFG5YW4CBZQF5SRGN3BPTEGBY47I>
    ecea:	0005      	movs	r5, r0
    ecec:	d00a      	beq.n	ed04 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x68>
    ecee:	4620      	mov	r0, r4
    ecf0:	4629      	mov	r1, r5
    ecf2:	aa01      	add	r2, sp, #4
    ecf4:	f7fe ffbf 	bl	dc76 <sym_DY52YMZFQPMDNFDSVZDQLPFIWKOSXIQIEKUVZNY>
    ecf8:	8070      	strh	r0, [r6, #2]
    ecfa:	b130      	cbz	r0, ed0a <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x6e>
    ecfc:	28fb      	cmp	r0, #251	; 0xfb
    ecfe:	d906      	bls.n	ed0e <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x72>
    ed00:	21ae      	movs	r1, #174	; 0xae
    ed02:	e026      	b.n	ed52 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xb6>
    ed04:	2000      	movs	r0, #0
    ed06:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
    ed0a:	21ad      	movs	r1, #173	; 0xad
    ed0c:	e021      	b.n	ed52 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xb6>
    ed0e:	9801      	ldr	r0, [sp, #4]
    ed10:	f7ff fea4 	bl	ea5c <sym_66SPI42RVSYPTJAEZPQR5PX32WQ6ZUXVEH3D2OI>
    ed14:	2801      	cmp	r0, #1
    ed16:	d003      	beq.n	ed20 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x84>
    ed18:	2802      	cmp	r0, #2
    ed1a:	d001      	beq.n	ed20 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x84>
    ed1c:	21bd      	movs	r1, #189	; 0xbd
    ed1e:	e018      	b.n	ed52 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xb6>
    ed20:	7130      	strb	r0, [r6, #4]
    ed22:	4629      	mov	r1, r5
    ed24:	8873      	ldrh	r3, [r6, #2]
    ed26:	2503      	movs	r5, #3
    ed28:	4620      	mov	r0, r4
    ed2a:	463a      	mov	r2, r7
    ed2c:	9500      	str	r5, [sp, #0]
    ed2e:	f7fe fe7f 	bl	da30 <sym_BZ7Z4RQ3DCP67RU5HKR6L76AI2EU62TP34WUI5Q>
    ed32:	4620      	mov	r0, r4
    ed34:	60b7      	str	r7, [r6, #8]
    ed36:	f7fe ff3f 	bl	dbb8 <sym_Q4EW623JZHY67RB7U4Z2L2SMI5ENWIDFL23JZHQ>
    ed3a:	b138      	cbz	r0, ed4c <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xb0>
    ed3c:	2100      	movs	r1, #0
    ed3e:	4620      	mov	r0, r4
    ed40:	460a      	mov	r2, r1
    ed42:	f7ff f876 	bl	de32 <sym_PTZ4EWNTFK5S5TZGCBNFETDF37P4DBX7VGM33II>
    ed46:	b118      	cbz	r0, ed50 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xb4>
    ed48:	2001      	movs	r0, #1
    ed4a:	e7dc      	b.n	ed06 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0x6a>
    ed4c:	21cd      	movs	r1, #205	; 0xcd
    ed4e:	e000      	b.n	ed52 <sym_ZUFGUNQKQRINYDDQ2AFT3BJLR3IFVV6WJFPT3PA+0xb6>
    ed50:	21d2      	movs	r1, #210	; 0xd2
    ed52:	202b      	movs	r0, #43	; 0x2b
    ed54:	f7f6 f9fe 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>

0000ed58 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ>:
    ed58:	f7f8 bc1c 	b.w	7594 <sym_FHMOSTDS4FAIPN4GDRMMMBPMBOTEQ5DLCM2A23Q+0x230>
    ed5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ed60:	460c      	mov	r4, r1
    ed62:	b180      	cbz	r0, ed86 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x2e>
    ed64:	2700      	movs	r7, #0
    ed66:	4606      	mov	r6, r0
    ed68:	f500 7596 	add.w	r5, r0, #300	; 0x12c
    ed6c:	2a10      	cmp	r2, #16
    ed6e:	d060      	beq.n	ee32 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0xda>
    ed70:	dc0c      	bgt.n	ed8c <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x34>
    ed72:	f1a2 0205 	sub.w	r2, r2, #5
    ed76:	2a08      	cmp	r2, #8
    ed78:	d210      	bcs.n	ed9c <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x44>
    ed7a:	e8df f002 	tbb	[pc, r2]
    ed7e:	124e      	.short	0x124e
    ed80:	20330f0f 	.word	0x20330f0f
    ed84:	540f      	.short	0x540f
    ed86:	f44f 7112 	mov.w	r1, #584	; 0x248
    ed8a:	e034      	b.n	edf6 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x9e>
    ed8c:	2a11      	cmp	r2, #17
    ed8e:	d072      	beq.n	ee76 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x11e>
    ed90:	2a18      	cmp	r2, #24
    ed92:	d068      	beq.n	ee66 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x10e>
    ed94:	2a1a      	cmp	r2, #26
    ed96:	d057      	beq.n	ee48 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0xf0>
    ed98:	2a1b      	cmp	r2, #27
    ed9a:	d060      	beq.n	ee5e <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x106>
    ed9c:	f240 2175 	movw	r1, #629	; 0x275
    eda0:	e029      	b.n	edf6 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x9e>
    eda2:	7067      	strb	r7, [r4, #1]
    eda4:	2007      	movs	r0, #7
    eda6:	7020      	strb	r0, [r4, #0]
    eda8:	8537      	strh	r7, [r6, #40]	; 0x28
    edaa:	f855 0f80 	ldr.w	r0, [r5, #128]!
    edae:	6060      	str	r0, [r4, #4]
    edb0:	6868      	ldr	r0, [r5, #4]
    edb2:	60a0      	str	r0, [r4, #8]
    edb4:	8928      	ldrh	r0, [r5, #8]
    edb6:	81a0      	strh	r0, [r4, #12]
    edb8:	7127      	strb	r7, [r4, #4]
    edba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    edbe:	8830      	ldrh	r0, [r6, #0]
    edc0:	f7f6 fdf0 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    edc4:	4680      	mov	r8, r0
    edc6:	f7fe ffcb 	bl	dd60 <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY>
    edca:	b110      	cbz	r0, edd2 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x7a>
    edcc:	f240 11b9 	movw	r1, #441	; 0x1b9
    edd0:	e011      	b.n	edf6 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x9e>
    edd2:	7067      	strb	r7, [r4, #1]
    edd4:	200c      	movs	r0, #12
    edd6:	7020      	strb	r0, [r4, #0]
    edd8:	f895 0094 	ldrb.w	r0, [r5, #148]	; 0x94
    eddc:	7120      	strb	r0, [r4, #4]
    edde:	8830      	ldrh	r0, [r6, #0]
    ede0:	80e0      	strh	r0, [r4, #6]
    ede2:	e015      	b.n	ee10 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0xb8>
    ede4:	8830      	ldrh	r0, [r6, #0]
    ede6:	f7f6 fddd 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    edea:	4680      	mov	r8, r0
    edec:	f7fe ffb8 	bl	dd60 <sym_ZOHQLKBCZOR3A7YQVK6MVD6IEOARIBONHUTW4FY>
    edf0:	b120      	cbz	r0, edfc <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0xa4>
    edf2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
    edf6:	2010      	movs	r0, #16
    edf8:	f7f6 f9ac 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    edfc:	7067      	strb	r7, [r4, #1]
    edfe:	200b      	movs	r0, #11
    ee00:	7020      	strb	r0, [r4, #0]
    ee02:	f815 0f94 	ldrb.w	r0, [r5, #148]!
    ee06:	7120      	strb	r0, [r4, #4]
    ee08:	8830      	ldrh	r0, [r6, #0]
    ee0a:	80e0      	strh	r0, [r4, #6]
    ee0c:	7928      	ldrb	r0, [r5, #4]
    ee0e:	7220      	strb	r0, [r4, #8]
    ee10:	4640      	mov	r0, r8
    ee12:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ee16:	f7fe bfbe 	b.w	dd96 <sym_4Z7443SGSMJBRM7TLEVRIFXZXBZ34MHB7IK5ETY>
    ee1a:	7067      	strb	r7, [r4, #1]
    ee1c:	2006      	movs	r0, #6
    ee1e:	7020      	strb	r0, [r4, #0]
    ee20:	f855 0f6a 	ldr.w	r0, [r5, #106]!
    ee24:	e00a      	b.n	ee3c <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0xe4>
    ee26:	7067      	strb	r7, [r4, #1]
    ee28:	200e      	movs	r0, #14
    ee2a:	7020      	strb	r0, [r4, #0]
    ee2c:	8830      	ldrh	r0, [r6, #0]
    ee2e:	8088      	strh	r0, [r1, #4]
    ee30:	e7c3      	b.n	edba <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x62>
    ee32:	7067      	strb	r7, [r4, #1]
    ee34:	2012      	movs	r0, #18
    ee36:	7020      	strb	r0, [r4, #0]
    ee38:	f855 0f22 	ldr.w	r0, [r5, #34]!
    ee3c:	6060      	str	r0, [r4, #4]
    ee3e:	6868      	ldr	r0, [r5, #4]
    ee40:	60a0      	str	r0, [r4, #8]
    ee42:	68a8      	ldr	r0, [r5, #8]
    ee44:	60e0      	str	r0, [r4, #12]
    ee46:	e7b8      	b.n	edba <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x62>
    ee48:	7067      	strb	r7, [r4, #1]
    ee4a:	2018      	movs	r0, #24
    ee4c:	7020      	strb	r0, [r4, #0]
    ee4e:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    ee50:	6060      	str	r0, [r4, #4]
    ee52:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    ee54:	60a0      	str	r0, [r4, #8]
    ee56:	f8b5 0040 	ldrh.w	r0, [r5, #64]	; 0x40
    ee5a:	81a0      	strh	r0, [r4, #12]
    ee5c:	e7ad      	b.n	edba <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x62>
    ee5e:	2019      	movs	r0, #25
    ee60:	7020      	strb	r0, [r4, #0]
    ee62:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
    ee64:	e004      	b.n	ee70 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x118>
    ee66:	7067      	strb	r7, [r4, #1]
    ee68:	2016      	movs	r0, #22
    ee6a:	7020      	strb	r0, [r4, #0]
    ee6c:	f8d5 000a 	ldr.w	r0, [r5, #10]
    ee70:	6048      	str	r0, [r1, #4]
    ee72:	e7a2      	b.n	edba <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x62>
    ee74:	e7ff      	b.n	ee76 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x11e>
    ee76:	7067      	strb	r7, [r4, #1]
    ee78:	2013      	movs	r0, #19
    ee7a:	7020      	strb	r0, [r4, #0]
    ee7c:	f855 0f5a 	ldr.w	r0, [r5, #90]!
    ee80:	6060      	str	r0, [r4, #4]
    ee82:	88a8      	ldrh	r0, [r5, #4]
    ee84:	8120      	strh	r0, [r4, #8]
    ee86:	e798      	b.n	edba <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ+0x62>

0000ee88 <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY>:
    ee88:	b4f0      	push	{r4, r5, r6, r7}
    ee8a:	8150      	strh	r0, [r2, #10]
    ee8c:	890d      	ldrh	r5, [r1, #8]
    ee8e:	4614      	mov	r4, r2
    ee90:	8195      	strh	r5, [r2, #12]
    ee92:	898a      	ldrh	r2, [r1, #12]
    ee94:	81e2      	strh	r2, [r4, #14]
    ee96:	8948      	ldrh	r0, [r1, #10]
    ee98:	8220      	strh	r0, [r4, #16]
    ee9a:	89ce      	ldrh	r6, [r1, #14]
    ee9c:	8266      	strh	r6, [r4, #18]
    ee9e:	8dcf      	ldrh	r7, [r1, #46]	; 0x2e
    eea0:	42b7      	cmp	r7, r6
    eea2:	d108      	bne.n	eeb6 <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY+0x2e>
    eea4:	8d4e      	ldrh	r6, [r1, #42]	; 0x2a
    eea6:	4286      	cmp	r6, r0
    eea8:	d105      	bne.n	eeb6 <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY+0x2e>
    eeaa:	8e0e      	ldrh	r6, [r1, #48]	; 0x30
    eeac:	4296      	cmp	r6, r2
    eeae:	d102      	bne.n	eeb6 <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY+0x2e>
    eeb0:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
    eeb2:	42aa      	cmp	r2, r5
    eeb4:	d001      	beq.n	eeba <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY+0x32>
    eeb6:	2201      	movs	r2, #1
    eeb8:	e000      	b.n	eebc <sym_KQELUVJKUXDWI537IIFYFUVTNDSZOYYQ6RIVVLY+0x34>
    eeba:	2200      	movs	r2, #0
    eebc:	7522      	strb	r2, [r4, #20]
    eebe:	8548      	strh	r0, [r1, #42]	; 0x2a
    eec0:	8a60      	ldrh	r0, [r4, #18]
    eec2:	85c8      	strh	r0, [r1, #46]	; 0x2e
    eec4:	89a0      	ldrh	r0, [r4, #12]
    eec6:	8588      	strh	r0, [r1, #44]	; 0x2c
    eec8:	89e0      	ldrh	r0, [r4, #14]
    eeca:	8608      	strh	r0, [r1, #48]	; 0x30
    eecc:	4620      	mov	r0, r4
    eece:	bcf0      	pop	{r4, r5, r6, r7}
    eed0:	2210      	movs	r2, #16
    eed2:	4619      	mov	r1, r3
    eed4:	f7f8 b966 	b.w	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>

0000eed8 <sym_436OKKOGR27QX7FMSZKYSEYLCMU4ZXR5RN4XUBY>:
    eed8:	b510      	push	{r4, lr}
    eeda:	888c      	ldrh	r4, [r1, #4]
    eedc:	890a      	ldrh	r2, [r1, #8]
    eede:	884b      	ldrh	r3, [r1, #2]
    eee0:	88c9      	ldrh	r1, [r1, #6]
    eee2:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
    eee6:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
    eeea:	f8a0 404e 	strh.w	r4, [r0, #78]	; 0x4e
    eeee:	f8a0 2052 	strh.w	r2, [r0, #82]	; 0x52
    eef2:	bd10      	pop	{r4, pc}

0000eef4 <sym_XRSFUVJVALTQXGE7INRI3M6HEEON3PEMDM73SDI>:
    eef4:	b570      	push	{r4, r5, r6, lr}
    eef6:	4615      	mov	r5, r2
    eef8:	460c      	mov	r4, r1
    eefa:	f000 f8ce 	bl	f09a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x5e>
    eefe:	3096      	adds	r0, #150	; 0x96
    ef00:	4428      	add	r0, r5
    ef02:	42a0      	cmp	r0, r4
    ef04:	d801      	bhi.n	ef0a <sym_XRSFUVJVALTQXGE7INRI3M6HEEON3PEMDM73SDI+0x16>
    ef06:	1a20      	subs	r0, r4, r0
    ef08:	bd70      	pop	{r4, r5, r6, pc}
    ef0a:	2000      	movs	r0, #0
    ef0c:	bd70      	pop	{r4, r5, r6, pc}

0000ef0e <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q>:
    ef0e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ef12:	4604      	mov	r4, r0
    ef14:	8f47      	ldrh	r7, [r0, #58]	; 0x3a
    ef16:	8fc6      	ldrh	r6, [r0, #62]	; 0x3e
    ef18:	f8b0 5050 	ldrh.w	r5, [r0, #80]	; 0x50
    ef1c:	f8b0 0044 	ldrh.w	r0, [r0, #68]	; 0x44
    ef20:	4285      	cmp	r5, r0
    ef22:	d300      	bcc.n	ef26 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x18>
    ef24:	4605      	mov	r5, r0
    ef26:	4620      	mov	r0, r4
    ef28:	f894 106f 	ldrb.w	r1, [r4, #111]	; 0x6f
    ef2c:	f000 f8a5 	bl	f07a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x3e>
    ef30:	4601      	mov	r1, r0
    ef32:	8765      	strh	r5, [r4, #58]	; 0x3a
    ef34:	87e1      	strh	r1, [r4, #62]	; 0x3e
    ef36:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
    ef3a:	f104 0030 	add.w	r0, r4, #48	; 0x30
    ef3e:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
    ef42:	4680      	mov	r8, r0
    ef44:	42aa      	cmp	r2, r5
    ef46:	d200      	bcs.n	ef4a <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x3c>
    ef48:	462a      	mov	r2, r5
    ef4a:	428b      	cmp	r3, r1
    ef4c:	d200      	bcs.n	ef50 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x42>
    ef4e:	460b      	mov	r3, r1
    ef50:	8202      	strh	r2, [r0, #16]
    ef52:	f8a8 3012 	strh.w	r3, [r8, #18]
    ef56:	42bd      	cmp	r5, r7
    ef58:	d101      	bne.n	ef5e <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x50>
    ef5a:	42b1      	cmp	r1, r6
    ef5c:	d001      	beq.n	ef62 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x54>
    ef5e:	2001      	movs	r0, #1
    ef60:	e000      	b.n	ef64 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x56>
    ef62:	2000      	movs	r0, #0
    ef64:	4681      	mov	r9, r0
    ef66:	f8b4 504c 	ldrh.w	r5, [r4, #76]	; 0x4c
    ef6a:	f8b4 0046 	ldrh.w	r0, [r4, #70]	; 0x46
    ef6e:	8f27      	ldrh	r7, [r4, #56]	; 0x38
    ef70:	8fa6      	ldrh	r6, [r4, #60]	; 0x3c
    ef72:	4285      	cmp	r5, r0
    ef74:	d300      	bcc.n	ef78 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x6a>
    ef76:	4605      	mov	r5, r0
    ef78:	f894 106e 	ldrb.w	r1, [r4, #110]	; 0x6e
    ef7c:	4620      	mov	r0, r4
    ef7e:	f000 f884 	bl	f08a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x4e>
    ef82:	f894 1064 	ldrb.w	r1, [r4, #100]	; 0x64
    ef86:	2902      	cmp	r1, #2
    ef88:	d108      	bne.n	ef9c <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x8e>
    ef8a:	42af      	cmp	r7, r5
    ef8c:	d200      	bcs.n	ef90 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x82>
    ef8e:	463d      	mov	r5, r7
    ef90:	4286      	cmp	r6, r0
    ef92:	d200      	bcs.n	ef96 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x88>
    ef94:	4630      	mov	r0, r6
    ef96:	2100      	movs	r1, #0
    ef98:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
    ef9c:	f8a8 5008 	strh.w	r5, [r8, #8]
    efa0:	f8a8 000c 	strh.w	r0, [r8, #12]
    efa4:	42bd      	cmp	r5, r7
    efa6:	d101      	bne.n	efac <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0x9e>
    efa8:	42b0      	cmp	r0, r6
    efaa:	d001      	beq.n	efb0 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0xa2>
    efac:	2001      	movs	r0, #1
    efae:	e000      	b.n	efb2 <sym_IPYDOGNKVSD5CNASNRZPFKSG4XKU4ZG4SVERI7Q+0xa4>
    efb0:	2000      	movs	r0, #0
    efb2:	ea40 0009 	orr.w	r0, r0, r9
    efb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000efba <sym_2T6ENJKRE7MWBMC42J5L6S3EMUNPYUXCPAHD23A>:
    efba:	6840      	ldr	r0, [r0, #4]
    efbc:	4770      	bx	lr

0000efbe <sym_EO2RG5OKHPJZIBYGTP56VVOSGXFYZ4DGV24KLDY>:
    efbe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    efc2:	4616      	mov	r6, r2
    efc4:	460f      	mov	r7, r1
    efc6:	4604      	mov	r4, r0
    efc8:	f000 f867 	bl	f09a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x5e>
    efcc:	4605      	mov	r5, r0
    efce:	463a      	mov	r2, r7
    efd0:	6921      	ldr	r1, [r4, #16]
    efd2:	6b20      	ldr	r0, [r4, #48]	; 0x30
    efd4:	f000 f84c 	bl	f070 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x34>
    efd8:	19a9      	adds	r1, r5, r6
    efda:	4281      	cmp	r1, r0
    efdc:	d300      	bcc.n	efe0 <__kernel_ram_size+0x20>
    efde:	4608      	mov	r0, r1
    efe0:	6360      	str	r0, [r4, #52]	; 0x34
    efe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000efe6 <sym_43VAZS4NQXUMOPHD7W7SYFZ3WJ6KGQYQH6UOYPQ>:
    efe6:	221b      	movs	r2, #27
    efe8:	8402      	strh	r2, [r0, #32]
    efea:	8382      	strh	r2, [r0, #28]
    efec:	82c2      	strh	r2, [r0, #22]
    efee:	8282      	strh	r2, [r0, #20]
    eff0:	8142      	strh	r2, [r0, #10]
    eff2:	8202      	strh	r2, [r0, #16]
    eff4:	8102      	strh	r2, [r0, #8]
    eff6:	8542      	strh	r2, [r0, #42]	; 0x2a
    eff8:	8582      	strh	r2, [r0, #44]	; 0x2c
    effa:	8482      	strh	r2, [r0, #36]	; 0x24
    effc:	2900      	cmp	r1, #0
    effe:	d10a      	bne.n	f016 <sym_43VAZS4NQXUMOPHD7W7SYFZ3WJ6KGQYQH6UOYPQ+0x30>
    f000:	f44f 71a4 	mov.w	r1, #328	; 0x148
    f004:	8441      	strh	r1, [r0, #34]	; 0x22
    f006:	83c1      	strh	r1, [r0, #30]
    f008:	8341      	strh	r1, [r0, #26]
    f00a:	8301      	strh	r1, [r0, #24]
    f00c:	81c1      	strh	r1, [r0, #14]
    f00e:	8241      	strh	r1, [r0, #18]
    f010:	8181      	strh	r1, [r0, #12]
    f012:	85c1      	strh	r1, [r0, #46]	; 0x2e
    f014:	8601      	strh	r1, [r0, #48]	; 0x30
    f016:	4770      	bx	lr

0000f018 <sym_NEHMDBQBGZXV6OFKIS4NBQDVMDAPMSPSGUQZB7A>:
    f018:	6800      	ldr	r0, [r0, #0]
    f01a:	f101 029c 	add.w	r2, r1, #156	; 0x9c
    f01e:	4290      	cmp	r0, r2
    f020:	d903      	bls.n	f02a <sym_NEHMDBQBGZXV6OFKIS4NBQDVMDAPMSPSGUQZB7A+0x12>
    f022:	1a40      	subs	r0, r0, r1
    f024:	389c      	subs	r0, #156	; 0x9c
    f026:	0840      	lsrs	r0, r0, #1
    f028:	4770      	bx	lr
    f02a:	2000      	movs	r0, #0
    f02c:	4770      	bx	lr

0000f02e <sym_ONVPV2DV6OK6HG537JAHRS5B7G22RD24D2QGM5A>:
    f02e:	b510      	push	{r4, lr}
    f030:	9c02      	ldr	r4, [sp, #8]
    f032:	8281      	strh	r1, [r0, #20]
    f034:	82c2      	strh	r2, [r0, #22]
    f036:	8303      	strh	r3, [r0, #24]
    f038:	8344      	strh	r4, [r0, #26]
    f03a:	bd10      	pop	{r4, pc}

0000f03c <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I>:
    f03c:	b430      	push	{r4, r5}
    f03e:	8150      	strh	r0, [r2, #10]
    f040:	8a88      	ldrh	r0, [r1, #20]
    f042:	8190      	strh	r0, [r2, #12]
    f044:	8ac8      	ldrh	r0, [r1, #22]
    f046:	81d0      	strh	r0, [r2, #14]
    f048:	8b08      	ldrh	r0, [r1, #24]
    f04a:	8210      	strh	r0, [r2, #16]
    f04c:	8b48      	ldrh	r0, [r1, #26]
    f04e:	4614      	mov	r4, r2
    f050:	8250      	strh	r0, [r2, #18]
    f052:	4620      	mov	r0, r4
    f054:	bc30      	pop	{r4, r5}
    f056:	221a      	movs	r2, #26
    f058:	4619      	mov	r1, r3
    f05a:	f7f8 b8a3 	b.w	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    f05e:	2902      	cmp	r1, #2
    f060:	d003      	beq.n	f06a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x2e>
    f062:	00c0      	lsls	r0, r0, #3
    f064:	3070      	adds	r0, #112	; 0x70
    f066:	b280      	uxth	r0, r0
    f068:	4770      	bx	lr
    f06a:	0080      	lsls	r0, r0, #2
    f06c:	303c      	adds	r0, #60	; 0x3c
    f06e:	e7fa      	b.n	f066 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x2a>
    f070:	4288      	cmp	r0, r1
    f072:	d300      	bcc.n	f076 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x3a>
    f074:	4608      	mov	r0, r1
    f076:	1a80      	subs	r0, r0, r2
    f078:	4770      	bx	lr
    f07a:	f8b0 1052 	ldrh.w	r1, [r0, #82]	; 0x52
    f07e:	f8b0 0048 	ldrh.w	r0, [r0, #72]	; 0x48
    f082:	4281      	cmp	r1, r0
    f084:	d200      	bcs.n	f088 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x4c>
    f086:	4608      	mov	r0, r1
    f088:	4770      	bx	lr
    f08a:	f8b0 104e 	ldrh.w	r1, [r0, #78]	; 0x4e
    f08e:	f8b0 004a 	ldrh.w	r0, [r0, #74]	; 0x4a
    f092:	4281      	cmp	r1, r0
    f094:	d200      	bcs.n	f098 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x5c>
    f096:	4608      	mov	r0, r1
    f098:	4770      	bx	lr
    f09a:	2196      	movs	r1, #150	; 0x96
    f09c:	f890 306f 	ldrb.w	r3, [r0, #111]	; 0x6f
    f0a0:	f890 206e 	ldrb.w	r2, [r0, #110]	; 0x6e
    f0a4:	f000 b800 	b.w	f0a8 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x6c>
    f0a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f0ac:	460d      	mov	r5, r1
    f0ae:	4606      	mov	r6, r0
    f0b0:	4698      	mov	r8, r3
    f0b2:	4617      	mov	r7, r2
    f0b4:	8f00      	ldrh	r0, [r0, #56]	; 0x38
    f0b6:	4611      	mov	r1, r2
    f0b8:	f7ff ffd1 	bl	f05e <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x22>
    f0bc:	4604      	mov	r4, r0
    f0be:	4639      	mov	r1, r7
    f0c0:	4630      	mov	r0, r6
    f0c2:	f7ff ffe2 	bl	f08a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x4e>
    f0c6:	42a0      	cmp	r0, r4
    f0c8:	d200      	bcs.n	f0cc <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x90>
    f0ca:	4604      	mov	r4, r0
    f0cc:	f8b6 0040 	ldrh.w	r0, [r6, #64]	; 0x40
    f0d0:	4641      	mov	r1, r8
    f0d2:	f7ff ffc4 	bl	f05e <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x22>
    f0d6:	4607      	mov	r7, r0
    f0d8:	4641      	mov	r1, r8
    f0da:	4630      	mov	r0, r6
    f0dc:	f7ff ffcd 	bl	f07a <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x3e>
    f0e0:	42b8      	cmp	r0, r7
    f0e2:	d300      	bcc.n	f0e6 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xaa>
    f0e4:	4638      	mov	r0, r7
    f0e6:	4420      	add	r0, r4
    f0e8:	4428      	add	r0, r5
    f0ea:	1d80      	adds	r0, r0, #6
    f0ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f0f0:	b510      	push	{r4, lr}
    f0f2:	4604      	mov	r4, r0
    f0f4:	2108      	movs	r1, #8
    f0f6:	4620      	mov	r0, r4
    f0f8:	f7f6 f8d8 	bl	52ac <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA>
    f0fc:	6820      	ldr	r0, [r4, #0]
    f0fe:	2800      	cmp	r0, #0
    f100:	d102      	bne.n	f108 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xcc>
    f102:	6860      	ldr	r0, [r4, #4]
    f104:	2800      	cmp	r0, #0
    f106:	d0f5      	beq.n	f0f4 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xb8>
    f108:	bd10      	pop	{r4, pc}
    f10a:	2801      	cmp	r0, #1
    f10c:	d102      	bne.n	f114 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xd8>
    f10e:	7948      	ldrb	r0, [r1, #5]
    f110:	0980      	lsrs	r0, r0, #6
    f112:	d001      	beq.n	f118 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xdc>
    f114:	2000      	movs	r0, #0
    f116:	4770      	bx	lr
    f118:	2001      	movs	r0, #1
    f11a:	4770      	bx	lr
    f11c:	2801      	cmp	r0, #1
    f11e:	d106      	bne.n	f12e <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xf2>
    f120:	7948      	ldrb	r0, [r1, #5]
    f122:	2101      	movs	r1, #1
    f124:	ebb1 1f90 	cmp.w	r1, r0, lsr #6
    f128:	d101      	bne.n	f12e <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xf2>
    f12a:	2001      	movs	r0, #1
    f12c:	4770      	bx	lr
    f12e:	2000      	movs	r0, #0
    f130:	4770      	bx	lr
    f132:	2802      	cmp	r0, #2
    f134:	d003      	beq.n	f13e <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x102>
    f136:	2803      	cmp	r0, #3
    f138:	d001      	beq.n	f13e <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0x102>
    f13a:	2000      	movs	r0, #0
    f13c:	4770      	bx	lr
    f13e:	2001      	movs	r0, #1
    f140:	4770      	bx	lr

0000f142 <sym_NFQK2HO6DBYRYVUCFLRI766EKAAKCM57FJRRS5Y>:
    f142:	b510      	push	{r4, lr}
    f144:	4604      	mov	r4, r0
    f146:	7c00      	ldrb	r0, [r0, #16]
    f148:	f7ff fff3 	bl	f132 <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xf6>
    f14c:	b148      	cbz	r0, f162 <sym_NFQK2HO6DBYRYVUCFLRI766EKAAKCM57FJRRS5Y+0x20>
    f14e:	f894 004f 	ldrb.w	r0, [r4, #79]	; 0x4f
    f152:	f104 0150 	add.w	r1, r4, #80	; 0x50
    f156:	f7ff f9a2 	bl	e49e <sym_QW6JOH7RCJIC2YFNJEURX5QNB5EIQT646EHIWEA>
    f15a:	2808      	cmp	r0, #8
    f15c:	d001      	beq.n	f162 <sym_NFQK2HO6DBYRYVUCFLRI766EKAAKCM57FJRRS5Y+0x20>
    f15e:	2001      	movs	r0, #1
    f160:	bd10      	pop	{r4, pc}
    f162:	7c20      	ldrb	r0, [r4, #16]
    f164:	b118      	cbz	r0, f16e <sym_NFQK2HO6DBYRYVUCFLRI766EKAAKCM57FJRRS5Y+0x2c>
    f166:	2802      	cmp	r0, #2
    f168:	d001      	beq.n	f16e <sym_NFQK2HO6DBYRYVUCFLRI766EKAAKCM57FJRRS5Y+0x2c>
    f16a:	7de0      	ldrb	r0, [r4, #23]
    f16c:	bd10      	pop	{r4, pc}
    f16e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f172:	2000      	movs	r0, #0
    f174:	f7f6 bed0 	b.w	5f18 <sym_AO3U45UEGFLUPMT565ZR5UWUQUONF5AKILLCT3A>

0000f178 <sym_OAGVEJLAHKQB2YTTUDIS6TDHXZIVWZXKUMPIBHQ>:
    f178:	b508      	push	{r3, lr}
    f17a:	f890 106c 	ldrb.w	r1, [r0, #108]	; 0x6c
    f17e:	f88d 1000 	strb.w	r1, [sp]
    f182:	9900      	ldr	r1, [sp, #0]
    f184:	9100      	str	r1, [sp, #0]
    f186:	f89d 1000 	ldrb.w	r1, [sp]
    f18a:	b109      	cbz	r1, f190 <sym_OAGVEJLAHKQB2YTTUDIS6TDHXZIVWZXKUMPIBHQ+0x18>
    f18c:	2001      	movs	r0, #1
    f18e:	bd08      	pop	{r3, pc}
    f190:	f890 0096 	ldrb.w	r0, [r0, #150]	; 0x96
    f194:	f88d 0000 	strb.w	r0, [sp]
    f198:	9800      	ldr	r0, [sp, #0]
    f19a:	9000      	str	r0, [sp, #0]
    f19c:	f89d 0000 	ldrb.w	r0, [sp]
    f1a0:	2000      	movs	r0, #0
    f1a2:	bd08      	pop	{r3, pc}

0000f1a4 <sym_2ORNMU44KG57RJ5GYPW4FCTEFWDXBHWXYAE3J6I>:
    f1a4:	20ff      	movs	r0, #255	; 0xff
    f1a6:	7008      	strb	r0, [r1, #0]
    f1a8:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
    f1aa:	f7ff b878 	b.w	e29e <sym_SCCFLYV5KOPRJ5S7RGDC2KDSCCHMKXYC3EQIE6A>

0000f1ae <sym_YA57TPZ3CLQ6C73TD2RIGTELUAMYOOAKHU5T7RQ>:
    f1ae:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    f1b0:	460d      	mov	r5, r1
    f1b2:	4604      	mov	r4, r0
    f1b4:	f44f 7288 	mov.w	r2, #272	; 0x110
    f1b8:	2100      	movs	r1, #0
    f1ba:	f7fd ff89 	bl	d0d0 <sym_VSILKYHVQ5DVF6LG5MG267DQVA3A2XZQ6FSCLXA>
    f1be:	20ff      	movs	r0, #255	; 0xff
    f1c0:	7020      	strb	r0, [r4, #0]
    f1c2:	207f      	movs	r0, #127	; 0x7f
    f1c4:	f884 0026 	strb.w	r0, [r4, #38]	; 0x26
    f1c8:	2013      	movs	r0, #19
    f1ca:	8060      	strh	r0, [r4, #2]
    f1cc:	f7f6 fcac 	bl	5b28 <sym_47U6MZ7GC5PU2CVEGYFSZO6JE3OMJD4DVLRAUZQ>
    f1d0:	4601      	mov	r1, r0
    f1d2:	62e0      	str	r0, [r4, #44]	; 0x2c
    f1d4:	2200      	movs	r2, #0
    f1d6:	4668      	mov	r0, sp
    f1d8:	f7fe ffcb 	bl	e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>
    f1dc:	2200      	movs	r2, #0
    f1de:	2101      	movs	r1, #1
    f1e0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    f1e2:	f7ff f83c 	bl	e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>
    f1e6:	2204      	movs	r2, #4
    f1e8:	4668      	mov	r0, sp
    f1ea:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    f1ec:	f7fe ffc1 	bl	e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>
    f1f0:	2200      	movs	r2, #0
    f1f2:	4611      	mov	r1, r2
    f1f4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    f1f6:	f7ff f832 	bl	e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>
    f1fa:	73a5      	strb	r5, [r4, #14]
    f1fc:	f104 0020 	add.w	r0, r4, #32
    f200:	e8bd 407c 	ldmia.w	sp!, {r2, r3, r4, r5, r6, lr}
    f204:	f000 b994 	b.w	f530 <sym_32MURW7CSXICOYPMCVOPRARLMRLK4UASNCF4JWQ>

0000f208 <sym_U7WTPI24N35WTMGPC25KDS7Q3PHHHS7M5KI6IPY>:
    f208:	7880      	ldrb	r0, [r0, #2]
    f20a:	f3c0 0080 	ubfx	r0, r0, #2, #1
    f20e:	b108      	cbz	r0, f214 <sym_U7WTPI24N35WTMGPC25KDS7Q3PHHHS7M5KI6IPY+0xc>
    f210:	2000      	movs	r0, #0
    f212:	4770      	bx	lr
    f214:	201f      	movs	r0, #31
    f216:	4770      	bx	lr

0000f218 <sym_2K3JTQJLCTROZQI43ERT7GF5BTQ3SMAJXYMCVJI>:
    f218:	f7f8 befa 	b.w	8010 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x10>

0000f21c <sym_73OZ6PE62EKDTT5E6DG3KMBVHOCSVKUK4QPTCXI>:
    f21c:	b570      	push	{r4, r5, r6, lr}
    f21e:	2300      	movs	r3, #0
    f220:	2a03      	cmp	r2, #3
    f222:	d015      	beq.n	f250 <sym_73OZ6PE62EKDTT5E6DG3KMBVHOCSVKUK4QPTCXI+0x34>
    f224:	2a0e      	cmp	r2, #14
    f226:	d01a      	beq.n	f25e <sym_73OZ6PE62EKDTT5E6DG3KMBVHOCSVKUK4QPTCXI+0x42>
    f228:	2a12      	cmp	r2, #18
    f22a:	d030      	beq.n	f28e <sym_73OZ6PE62EKDTT5E6DG3KMBVHOCSVKUK4QPTCXI+0x72>
    f22c:	2a19      	cmp	r2, #25
    f22e:	d004      	beq.n	f23a <sym_73OZ6PE62EKDTT5E6DG3KMBVHOCSVKUK4QPTCXI+0x1e>
    f230:	f240 21d2 	movw	r1, #722	; 0x2d2
    f234:	202d      	movs	r0, #45	; 0x2d
    f236:	f7f5 ff8d 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f23a:	704b      	strb	r3, [r1, #1]
    f23c:	2217      	movs	r2, #23
    f23e:	700a      	strb	r2, [r1, #0]
    f240:	f850 2fb5 	ldr.w	r2, [r0, #181]!
    f244:	604a      	str	r2, [r1, #4]
    f246:	6842      	ldr	r2, [r0, #4]
    f248:	608a      	str	r2, [r1, #8]
    f24a:	7a00      	ldrb	r0, [r0, #8]
    f24c:	7308      	strb	r0, [r1, #12]
    f24e:	bd70      	pop	{r4, r5, r6, pc}
    f250:	704b      	strb	r3, [r1, #1]
    f252:	2205      	movs	r2, #5
    f254:	700a      	strb	r2, [r1, #0]
    f256:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
    f25a:	6048      	str	r0, [r1, #4]
    f25c:	bd70      	pop	{r4, r5, r6, pc}
    f25e:	4605      	mov	r5, r0
    f260:	704b      	strb	r3, [r1, #1]
    f262:	2011      	movs	r0, #17
    f264:	460c      	mov	r4, r1
    f266:	7008      	strb	r0, [r1, #0]
    f268:	2220      	movs	r2, #32
    f26a:	f105 016e 	add.w	r1, r5, #110	; 0x6e
    f26e:	1d20      	adds	r0, r4, #4
    f270:	f7fd feb4 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
    f274:	2001      	movs	r0, #1
    f276:	7220      	strb	r0, [r4, #8]
    f278:	7920      	ldrb	r0, [r4, #4]
    f27a:	2800      	cmp	r0, #0
    f27c:	d1ee      	bne.n	f25c <sym_73OZ6PE62EKDTT5E6DG3KMBVHOCSVKUK4QPTCXI+0x40>
    f27e:	69e8      	ldr	r0, [r5, #28]
    f280:	8800      	ldrh	r0, [r0, #0]
    f282:	f7f6 fb8f 	bl	59a4 <sym_YNBBHT54WKEGUNVC6TSBMRGLF67VFWBOYEMKGTQ>
    f286:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    f28a:	f7fe bd84 	b.w	dd96 <sym_4Z7443SGSMJBRM7TLEVRIFXZXBZ34MHB7IK5ETY>
    f28e:	704b      	strb	r3, [r1, #1]
    f290:	2214      	movs	r2, #20
    f292:	700a      	strb	r2, [r1, #0]
    f294:	f850 2f98 	ldr.w	r2, [r0, #152]!
    f298:	604a      	str	r2, [r1, #4]
    f29a:	8880      	ldrh	r0, [r0, #4]
    f29c:	8108      	strh	r0, [r1, #8]
    f29e:	bd70      	pop	{r4, r5, r6, pc}

0000f2a0 <sym_RYQA5YFFRJZLTYB2ISC2Y3WUY3XB3LBBL37F22Q>:
    f2a0:	6880      	ldr	r0, [r0, #8]
    f2a2:	4770      	bx	lr

0000f2a4 <sym_GNUIHYMK3THJZQYGL7BBI74HDMHN6SBQQRVNSAY>:
    f2a4:	2001      	movs	r0, #1
    f2a6:	4770      	bx	lr

0000f2a8 <sym_3NMQXTBVJ27TN5IIVET3BSKEAUONNKTPZTYP2HY>:
    f2a8:	b510      	push	{r4, lr}
    f2aa:	4604      	mov	r4, r0
    f2ac:	3020      	adds	r0, #32
    f2ae:	f000 f8ff 	bl	f4b0 <sym_STP6UONGXHZIIGYZLLHSWZFO5DU7227CCUKBTDQ>
    f2b2:	8861      	ldrh	r1, [r4, #2]
    f2b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f2b8:	2228      	movs	r2, #40	; 0x28
    f2ba:	f7f9 b891 	b.w	83e0 <sym_6FVWF5AWPR7EN7BPHS4APSIUXYFZQTTZCMRDKPY>

0000f2be <sym_DG6VHZEFRVR44ESTRZM42ZEBJG4KXT7IVJESA4Y>:
    f2be:	2200      	movs	r2, #0
    f2c0:	8502      	strh	r2, [r0, #40]	; 0x28
    f2c2:	8843      	ldrh	r3, [r0, #2]
    f2c4:	2b1d      	cmp	r3, #29
    f2c6:	d001      	beq.n	f2cc <sym_DG6VHZEFRVR44ESTRZM42ZEBJG4KXT7IVJESA4Y+0xe>
    f2c8:	7341      	strb	r1, [r0, #13]
    f2ca:	4770      	bx	lr
    f2cc:	7342      	strb	r2, [r0, #13]
    f2ce:	4770      	bx	lr

0000f2d0 <sym_JWG2K5Z2IDS7IGZ34EUMCNHIOV34425FH263YQQ>:
    f2d0:	b510      	push	{r4, lr}
    f2d2:	2400      	movs	r4, #0
    f2d4:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    f2d6:	f7fe ffb0 	bl	e23a <sym_SYX5A4D5YT7FQ4PORL5PYZ5T6BOBVEZRWNZWOOA>
    f2da:	b100      	cbz	r0, f2de <sym_JWG2K5Z2IDS7IGZ34EUMCNHIOV34425FH263YQQ+0xe>
    f2dc:	2001      	movs	r0, #1
    f2de:	4384      	bics	r4, r0
    f2e0:	f084 0001 	eor.w	r0, r4, #1
    f2e4:	bd10      	pop	{r4, pc}

0000f2e6 <sym_TPWVJBQKX2TXZDZ4IZ6XDJYVEDFBPIX3TMZMRCQ>:
    f2e6:	2000      	movs	r0, #0
    f2e8:	4770      	bx	lr

0000f2ea <sym_UEZ3FVWFJ5XVLQBVVAHW7UTXVCC77F7ZYGOMLTQ>:
    f2ea:	7880      	ldrb	r0, [r0, #2]
    f2ec:	f000 0001 	and.w	r0, r0, #1
    f2f0:	4770      	bx	lr

0000f2f2 <sym_XRU76NANM3C4EMKWQU3DF6CELSRNDV6766IKPJI>:
    f2f2:	7880      	ldrb	r0, [r0, #2]
    f2f4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    f2f8:	4770      	bx	lr

0000f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>:
    f2fa:	2001      	movs	r0, #1
    f2fc:	4770      	bx	lr

0000f2fe <sym_NGJGZTNK6YIH3QX2NKB6A6MT7N5AOKWA6ZOOANQ>:
    f2fe:	7880      	ldrb	r0, [r0, #2]
    f300:	f3c0 0040 	ubfx	r0, r0, #1, #1
    f304:	4770      	bx	lr

0000f306 <sym_L5UCRJFFWEVVII5IYG6PAKIQHXM34B62KO6ERPY>:
    f306:	f990 000e 	ldrsb.w	r0, [r0, #14]
    f30a:	4770      	bx	lr

0000f30c <sym_WGJLFS2PDN6RZG7JWUITZ3W5MGJYYXFXIKI3GGQ>:
    f30c:	7800      	ldrb	r0, [r0, #0]
    f30e:	28ff      	cmp	r0, #255	; 0xff
    f310:	d001      	beq.n	f316 <sym_WGJLFS2PDN6RZG7JWUITZ3W5MGJYYXFXIKI3GGQ+0xa>
    f312:	2001      	movs	r0, #1
    f314:	4770      	bx	lr
    f316:	2000      	movs	r0, #0
    f318:	4770      	bx	lr

0000f31a <sym_UDZCFPCYSG5E2MUJ3CH3H5GF4YJLF3Y6KNH3ZRQ>:
    f31a:	680a      	ldr	r2, [r1, #0]
    f31c:	f840 2f11 	str.w	r2, [r0, #17]!
    f320:	8889      	ldrh	r1, [r1, #4]
    f322:	8081      	strh	r1, [r0, #4]
    f324:	2101      	movs	r1, #1
    f326:	7181      	strb	r1, [r0, #6]
    f328:	4770      	bx	lr

0000f32a <sym_2T6B57C7Z3NDT5ASKUJUGCCL3DBEO2AO4XX23BI>:
    f32a:	7b00      	ldrb	r0, [r0, #12]
    f32c:	4770      	bx	lr

0000f32e <sym_4HDCBJCT2JOHNORERPDEH2A3V47FOX6NCTAKLUA>:
    f32e:	2001      	movs	r0, #1
    f330:	4770      	bx	lr

0000f332 <sym_4FKJZF4AXR7RHM7IPPZMVUWU7W6MFHLX726TPNY>:
    f332:	61c1      	str	r1, [r0, #28]
    f334:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
    f338:	724a      	strb	r2, [r1, #9]
    f33a:	f8d0 2049 	ldr.w	r2, [r0, #73]	; 0x49
    f33e:	f8c1 200a 	str.w	r2, [r1, #10]
    f342:	f8b0 004d 	ldrh.w	r0, [r0, #77]	; 0x4d
    f346:	81c8      	strh	r0, [r1, #14]
    f348:	4770      	bx	lr

0000f34a <sym_WAXMY55QAGCTLTIDQV34FPT2PPSDRT5VDN7EYYY>:
    f34a:	f880 1060 	strb.w	r1, [r0, #96]	; 0x60
    f34e:	4770      	bx	lr

0000f350 <sym_RPDYS5TXULS3Z2BQR7IFNSOINXPPN4LN764SRIY>:
    f350:	b510      	push	{r4, lr}
    f352:	4604      	mov	r4, r0
    f354:	7880      	ldrb	r0, [r0, #2]
    f356:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    f35a:	b158      	cbz	r0, f374 <sym_RPDYS5TXULS3Z2BQR7IFNSOINXPPN4LN764SRIY+0x24>
    f35c:	233c      	movs	r3, #60	; 0x3c
    f35e:	22ff      	movs	r2, #255	; 0xff
    f360:	4620      	mov	r0, r4
    f362:	69e1      	ldr	r1, [r4, #28]
    f364:	f7f8 fe80 	bl	8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>
    f368:	220e      	movs	r2, #14
    f36a:	4621      	mov	r1, r4
    f36c:	f104 0064 	add.w	r0, r4, #100	; 0x64
    f370:	f7f7 ff18 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    f374:	78a0      	ldrb	r0, [r4, #2]
    f376:	07c0      	lsls	r0, r0, #31
    f378:	f7f7 ffe6 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    f37c:	2001      	movs	r0, #1
    f37e:	f884 0061 	strb.w	r0, [r4, #97]	; 0x61
    f382:	bd10      	pop	{r4, pc}

0000f384 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y>:
    f384:	7bc0      	ldrb	r0, [r0, #15]
    f386:	2800      	cmp	r0, #0
    f388:	d000      	beq.n	f38c <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x8>
    f38a:	2001      	movs	r0, #1
    f38c:	4770      	bx	lr
    f38e:	b510      	push	{r4, lr}
    f390:	f7ff f885 	bl	e49e <sym_QW6JOH7RCJIC2YFNJEURX5QNB5EIQT646EHIWEA>
    f394:	4604      	mov	r4, r0
    f396:	f7f7 fbcf 	bl	6b38 <sym_QEQGMTIGG3AOZQY7JM4T2FY2O3KM2UFUMT6Q7PI>
    f39a:	b138      	cbz	r0, f3ac <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x28>
    f39c:	4620      	mov	r0, r4
    f39e:	f7f7 fb73 	bl	6a88 <sym_PLOW4TMGVQT52FP2ERNRL6S5EELE2YO563WRPJA>
    f3a2:	b118      	cbz	r0, f3ac <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x28>
    f3a4:	2110      	movs	r1, #16
    f3a6:	f7ff fa5d 	bl	e864 <sym_35JWAFJL2IEYRDNORVIQ7BBAS7FQNUVOFCLQNSQ>
    f3aa:	b108      	cbz	r0, f3b0 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x2c>
    f3ac:	2000      	movs	r0, #0
    f3ae:	bd10      	pop	{r4, pc}
    f3b0:	2001      	movs	r0, #1
    f3b2:	bd10      	pop	{r4, pc}
    f3b4:	2101      	movs	r1, #1
    f3b6:	f7f8 babd 	b.w	7934 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x10>
    f3ba:	2101      	movs	r1, #1
    f3bc:	f7f8 baba 	b.w	7934 <sym_I72BLVRK23UDT6KM4GEW6EVDLN4L7QB2CLD4CMY+0x10>
    f3c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f3c4:	4604      	mov	r4, r0
    f3c6:	460f      	mov	r7, r1
    f3c8:	7e40      	ldrb	r0, [r0, #25]
    f3ca:	f7f7 fb43 	bl	6a54 <sym_F2LWAH27IT4H2IA7TZWGNABUCWINGT6MWXH2WIA>
    f3ce:	4606      	mov	r6, r0
    f3d0:	7e20      	ldrb	r0, [r4, #24]
    f3d2:	f104 0549 	add.w	r5, r4, #73	; 0x49
    f3d6:	b120      	cbz	r0, f3e2 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x5e>
    f3d8:	b11e      	cbz	r6, f3e2 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x5e>
    f3da:	7e60      	ldrb	r0, [r4, #25]
    f3dc:	f7f7 fb2e 	bl	6a3c <sym_BAUTABQSJLBAZ6GNH7KOF4MJMAA6NF7CDAZNOEQ>
    f3e0:	b1a0      	cbz	r0, f40c <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0x88>
    f3e2:	f894 0062 	ldrb.w	r0, [r4, #98]	; 0x62
    f3e6:	2800      	cmp	r0, #0
    f3e8:	d024      	beq.n	f434 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xb0>
    f3ea:	7ea0      	ldrb	r0, [r4, #26]
    f3ec:	2800      	cmp	r0, #0
    f3ee:	d021      	beq.n	f434 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xb0>
    f3f0:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
    f3f4:	4629      	mov	r1, r5
    f3f6:	f7ff fe91 	bl	f11c <sym_FKGRLSJGPWDG44KYHTBA74A2ZDKPDUWGXHS3E2I+0xe0>
    f3fa:	b1a8      	cbz	r0, f428 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xa4>
    f3fc:	f7f7 fb1a 	bl	6a34 <sym_3Q2UQ65DVTXA3EZPN34QXGGEFSEA6HOSHLFXCMI>
    f400:	463a      	mov	r2, r7
    f402:	4629      	mov	r1, r5
    f404:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f408:	f7fe bfe1 	b.w	e3ce <sym_BLMJ5IIKWMCUMGRAJC47JTAD5DUGOY4TIBII5HY>
    f40c:	2001      	movs	r0, #1
    f40e:	f884 0048 	strb.w	r0, [r4, #72]	; 0x48
    f412:	463a      	mov	r2, r7
    f414:	4629      	mov	r1, r5
    f416:	4630      	mov	r0, r6
    f418:	f7fe ffd9 	bl	e3ce <sym_BLMJ5IIKWMCUMGRAJC47JTAD5DUGOY4TIBII5HY>
    f41c:	7e61      	ldrb	r1, [r4, #25]
    f41e:	4628      	mov	r0, r5
    f420:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f424:	f7f7 bb22 	b.w	6a6c <sym_GV7ZEDU63KACGR6K3NXW7W7XARTADNTCQ3P2HLA>
    f428:	4639      	mov	r1, r7
    f42a:	4628      	mov	r0, r5
    f42c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f430:	f7fe bfbc 	b.w	e3ac <sym_FEGTISSRZOTQRK4SD4MRDIWBV3TTZYGCCKXTY4Y>
    f434:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f438:	b510      	push	{r4, lr}
    f43a:	4604      	mov	r4, r0
    f43c:	4608      	mov	r0, r1
    f43e:	f7fc fe99 	bl	c174 <sym_ZQE76VUU7S5U7DETTZA65E75LHFWL5PGRN4JPHI>
    f442:	7921      	ldrb	r1, [r4, #4]
    f444:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f448:	2025      	movs	r0, #37	; 0x25
    f44a:	f7fc be69 	b.w	c120 <sym_5CHOZAQ75MOW32NPEGX5AYLDFVQR6HZCDXZY5PQ>
    f44e:	b510      	push	{r4, lr}
    f450:	4604      	mov	r4, r0
    f452:	3026      	adds	r0, #38	; 0x26
    f454:	f7fc fe44 	bl	c0e0 <sym_EZCFQXKGAFHY5HQVJOXWDLO45XWMEJQY5WUGZNI>
    f458:	2800      	cmp	r0, #0
    f45a:	d102      	bne.n	f462 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y+0xde>
    f45c:	207f      	movs	r0, #127	; 0x7f
    f45e:	f884 0026 	strb.w	r0, [r4, #38]	; 0x26
    f462:	bd10      	pop	{r4, pc}
    f464:	b570      	push	{r4, r5, r6, lr}
    f466:	4614      	mov	r4, r2
    f468:	461d      	mov	r5, r3
    f46a:	4606      	mov	r6, r0
    f46c:	f7f4 fa9a 	bl	39a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>
    f470:	1900      	adds	r0, r0, r4
    f472:	4169      	adcs	r1, r5
    f474:	e9c6 0100 	strd	r0, r1, [r6]
    f478:	bd70      	pop	{r4, r5, r6, pc}
    f47a:	7802      	ldrb	r2, [r0, #0]
    f47c:	2320      	movs	r3, #32
    f47e:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    f482:	ea03 1141 	and.w	r1, r3, r1, lsl #5
    f486:	430a      	orrs	r2, r1
    f488:	7002      	strb	r2, [r0, #0]
    f48a:	4770      	bx	lr

0000f48c <sym_XD3FX5TVO57NBJG4QV33FUOBCL7SNGB4OOT7C3Y>:
    f48c:	b570      	push	{r4, r5, r6, lr}
    f48e:	7001      	strb	r1, [r0, #0]
    f490:	7042      	strb	r2, [r0, #1]
    f492:	4614      	mov	r4, r2
    f494:	460d      	mov	r5, r1
    f496:	7880      	ldrb	r0, [r0, #2]
    f498:	f000 f87f 	bl	f59a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x5c>
    f49c:	fb10 f005 	smulbb	r0, r0, r5
    f4a0:	4360      	muls	r0, r4
    f4a2:	28ff      	cmp	r0, #255	; 0xff
    f4a4:	d303      	bcc.n	f4ae <sym_XD3FX5TVO57NBJG4QV33FUOBCL7SNGB4OOT7C3Y+0x22>
    f4a6:	215c      	movs	r1, #92	; 0x5c
    f4a8:	202e      	movs	r0, #46	; 0x2e
    f4aa:	f7f5 fe53 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f4ae:	bd70      	pop	{r4, r5, r6, pc}

0000f4b0 <sym_STP6UONGXHZIIGYZLLHSWZFO5DU7227CCUKBTDQ>:
    f4b0:	b510      	push	{r4, lr}
    f4b2:	4604      	mov	r4, r0
    f4b4:	7880      	ldrb	r0, [r0, #2]
    f4b6:	f000 f870 	bl	f59a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x5c>
    f4ba:	7861      	ldrb	r1, [r4, #1]
    f4bc:	7822      	ldrb	r2, [r4, #0]
    f4be:	fb11 f102 	smulbb	r1, r1, r2
    f4c2:	4348      	muls	r0, r1
    f4c4:	b2c0      	uxtb	r0, r0
    f4c6:	bd10      	pop	{r4, pc}

0000f4c8 <sym_GDGGQ5EKEJNZBTEWASFQ2LUSL4TZGNXHPD7BDQA>:
    f4c8:	b510      	push	{r4, lr}
    f4ca:	4604      	mov	r4, r0
    f4cc:	f000 f84d 	bl	f56a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x2c>
    f4d0:	7961      	ldrb	r1, [r4, #5]
    f4d2:	1c49      	adds	r1, r1, #1
    f4d4:	b2c9      	uxtb	r1, r1
    f4d6:	7161      	strb	r1, [r4, #5]
    f4d8:	7862      	ldrb	r2, [r4, #1]
    f4da:	4291      	cmp	r1, r2
    f4dc:	d10b      	bne.n	f4f6 <sym_GDGGQ5EKEJNZBTEWASFQ2LUSL4TZGNXHPD7BDQA+0x2e>
    f4de:	2200      	movs	r2, #0
    f4e0:	7162      	strb	r2, [r4, #5]
    f4e2:	78e1      	ldrb	r1, [r4, #3]
    f4e4:	4301      	orrs	r1, r0
    f4e6:	70e1      	strb	r1, [r4, #3]
    f4e8:	78a3      	ldrb	r3, [r4, #2]
    f4ea:	4299      	cmp	r1, r3
    f4ec:	d103      	bne.n	f4f6 <sym_GDGGQ5EKEJNZBTEWASFQ2LUSL4TZGNXHPD7BDQA+0x2e>
    f4ee:	70e2      	strb	r2, [r4, #3]
    f4f0:	7921      	ldrb	r1, [r4, #4]
    f4f2:	1c49      	adds	r1, r1, #1
    f4f4:	7121      	strb	r1, [r4, #4]
    f4f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f4fa:	f000 b825 	b.w	f548 <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0xa>

0000f4fe <sym_YZ554N3225FHWC7CK3UNRUMI3O4SGFLKXVRCFXA>:
    f4fe:	7081      	strb	r1, [r0, #2]
    f500:	4770      	bx	lr

0000f502 <sym_4U2RA2RXIRU5BEMWZTHT3PETZK6K62P2SAJVWHA>:
    f502:	b570      	push	{r4, r5, r6, lr}
    f504:	4604      	mov	r4, r0
    f506:	7880      	ldrb	r0, [r0, #2]
    f508:	f000 f847 	bl	f59a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x5c>
    f50c:	7861      	ldrb	r1, [r4, #1]
    f50e:	fb11 f500 	smulbb	r5, r1, r0
    f512:	78e0      	ldrb	r0, [r4, #3]
    f514:	f000 f841 	bl	f59a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x5c>
    f518:	7861      	ldrb	r1, [r4, #1]
    f51a:	7962      	ldrb	r2, [r4, #5]
    f51c:	fb10 2001 	smlabb	r0, r0, r1, r2
    f520:	7821      	ldrb	r1, [r4, #0]
    f522:	7922      	ldrb	r2, [r4, #4]
    f524:	1a89      	subs	r1, r1, r2
    f526:	fb11 f105 	smulbb	r1, r1, r5
    f52a:	1a08      	subs	r0, r1, r0
    f52c:	b2c0      	uxtb	r0, r0
    f52e:	bd70      	pop	{r4, r5, r6, pc}

0000f530 <sym_32MURW7CSXICOYPMCVOPRARLMRLK4UASNCF4JWQ>:
    f530:	2100      	movs	r1, #0
    f532:	6001      	str	r1, [r0, #0]
    f534:	8081      	strh	r1, [r0, #4]
    f536:	2101      	movs	r1, #1
    f538:	7041      	strb	r1, [r0, #1]
    f53a:	7001      	strb	r1, [r0, #0]
    f53c:	4770      	bx	lr

0000f53e <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ>:
    f53e:	2100      	movs	r1, #0
    f540:	70c1      	strb	r1, [r0, #3]
    f542:	7141      	strb	r1, [r0, #5]
    f544:	7101      	strb	r1, [r0, #4]
    f546:	4770      	bx	lr
    f548:	b510      	push	{r4, lr}
    f54a:	2801      	cmp	r0, #1
    f54c:	d007      	beq.n	f55e <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x20>
    f54e:	2802      	cmp	r0, #2
    f550:	d007      	beq.n	f562 <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x24>
    f552:	2804      	cmp	r0, #4
    f554:	d007      	beq.n	f566 <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x28>
    f556:	2139      	movs	r1, #57	; 0x39
    f558:	202e      	movs	r0, #46	; 0x2e
    f55a:	f7f5 fdfb 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f55e:	2025      	movs	r0, #37	; 0x25
    f560:	bd10      	pop	{r4, pc}
    f562:	2026      	movs	r0, #38	; 0x26
    f564:	bd10      	pop	{r4, pc}
    f566:	2027      	movs	r0, #39	; 0x27
    f568:	bd10      	pop	{r4, pc}
    f56a:	4601      	mov	r1, r0
    f56c:	2000      	movs	r0, #0
    f56e:	788a      	ldrb	r2, [r1, #2]
    f570:	07d3      	lsls	r3, r2, #31
    f572:	d002      	beq.n	f57a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x3c>
    f574:	78cb      	ldrb	r3, [r1, #3]
    f576:	07db      	lsls	r3, r3, #31
    f578:	d006      	beq.n	f588 <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x4a>
    f57a:	0793      	lsls	r3, r2, #30
    f57c:	d506      	bpl.n	f58c <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x4e>
    f57e:	78cb      	ldrb	r3, [r1, #3]
    f580:	079b      	lsls	r3, r3, #30
    f582:	d403      	bmi.n	f58c <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x4e>
    f584:	2002      	movs	r0, #2
    f586:	4770      	bx	lr
    f588:	2001      	movs	r0, #1
    f58a:	4770      	bx	lr
    f58c:	0752      	lsls	r2, r2, #29
    f58e:	d5fc      	bpl.n	f58a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x4c>
    f590:	78c9      	ldrb	r1, [r1, #3]
    f592:	0749      	lsls	r1, r1, #29
    f594:	d4f9      	bmi.n	f58a <sym_UEYPZKGY2IF5BYZ3QDKK4LEW4OE7NWR6DH5XEZQ+0x4c>
    f596:	2004      	movs	r0, #4
    f598:	4770      	bx	lr
    f59a:	f3c0 0180 	ubfx	r1, r0, #2, #1
    f59e:	f3c0 0240 	ubfx	r2, r0, #1, #1
    f5a2:	4411      	add	r1, r2
    f5a4:	f000 0001 	and.w	r0, r0, #1
    f5a8:	4408      	add	r0, r1
    f5aa:	4770      	bx	lr

0000f5ac <sym_FHGEXLJ7V34P3MECCDTYSDEZTZHFJ2TXYSFZQHQ>:
    f5ac:	f240 315a 	movw	r1, #858	; 0x35a
    f5b0:	4348      	muls	r0, r1
    f5b2:	4770      	bx	lr

0000f5b4 <sym_USXJ3USYRHE5AVFUSG2J2G7QDHRASPG75ESP25A>:
    f5b4:	f240 20ef 	movw	r0, #751	; 0x2ef
    f5b8:	4770      	bx	lr
    f5ba:	020e      	.short	0x020e
    f5bc:	0630041c 	.word	0x0630041c
    f5c0:	035a0c60 	.word	0x035a0c60
    f5c4:	05c506b4 	.word	0x05c506b4
    f5c8:	12250bf5 	.word	0x12250bf5
    f5cc:	03b101a3 	.word	0x03b101a3
    f5d0:	02ef05bf 	.word	0x02ef05bf
    f5d4:	09a30649 	.word	0x09a30649

0000f5d8 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ>:
    f5d8:	b510      	push	{r4, lr}
    f5da:	f890 1108 	ldrb.w	r1, [r0, #264]	; 0x108
    f5de:	b109      	cbz	r1, f5e4 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ+0xc>
    f5e0:	2000      	movs	r0, #0
    f5e2:	bd10      	pop	{r4, pc}
    f5e4:	f890 10c8 	ldrb.w	r1, [r0, #200]	; 0xc8
    f5e8:	b131      	cbz	r1, f5f8 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ+0x20>
    f5ea:	e9d0 1233 	ldrd	r1, r2, [r0, #204]	; 0xcc
    f5ee:	428a      	cmp	r2, r1
    f5f0:	d902      	bls.n	f5f8 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ+0x20>
    f5f2:	f7ff fead 	bl	f350 <sym_RPDYS5TXULS3Z2BQR7IFNSOINXPPN4LN764SRIY>
    f5f6:	e7f3      	b.n	f5e0 <sym_3ZNIOFG7XMX7YS4WHN4QVNG3AVWN2QVSTHUWDXQ+0x8>
    f5f8:	2001      	movs	r0, #1
    f5fa:	bd10      	pop	{r4, pc}

0000f5fc <sym_FY3JF6XBXLAG22E42UPFUU55A3QFAFZDUGSPAPY>:
    f5fc:	b510      	push	{r4, lr}
    f5fe:	b131      	cbz	r1, f60e <sym_FY3JF6XBXLAG22E42UPFUU55A3QFAFZDUGSPAPY+0x12>
    f600:	2901      	cmp	r1, #1
    f602:	d008      	beq.n	f616 <sym_FY3JF6XBXLAG22E42UPFUU55A3QFAFZDUGSPAPY+0x1a>
    f604:	f240 7195 	movw	r1, #1941	; 0x795
    f608:	2030      	movs	r0, #48	; 0x30
    f60a:	f7f5 fda3 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f60e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f612:	f000 b9ec 	b.w	f9ee <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x344>
    f616:	2100      	movs	r1, #0
    f618:	f880 10c8 	strb.w	r1, [r0, #200]	; 0xc8
    f61c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f620:	f000 b948 	b.w	f8b4 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x20a>

0000f624 <sym_7Q3OGK46EJ4CJTNREFMB4I3YQOYV4MCCW6KC7XI>:
    f624:	b510      	push	{r4, lr}
    f626:	4604      	mov	r4, r0
    f628:	f890 00d8 	ldrb.w	r0, [r0, #216]	; 0xd8
    f62c:	2800      	cmp	r0, #0
    f62e:	d019      	beq.n	f664 <sym_7Q3OGK46EJ4CJTNREFMB4I3YQOYV4MCCW6KC7XI+0x40>
    f630:	2001      	movs	r0, #1
    f632:	f884 0108 	strb.w	r0, [r4, #264]	; 0x108
    f636:	4601      	mov	r1, r0
    f638:	4620      	mov	r0, r4
    f63a:	f7ff fe86 	bl	f34a <sym_WAXMY55QAGCTLTIDQV34FPT2PPSDRT5VDN7EYYY>
    f63e:	f894 00d8 	ldrb.w	r0, [r4, #216]	; 0xd8
    f642:	b170      	cbz	r0, f662 <sym_7Q3OGK46EJ4CJTNREFMB4I3YQOYV4MCCW6KC7XI+0x3e>
    f644:	f814 0fc0 	ldrb.w	r0, [r4, #192]!
    f648:	f7f3 fd7a 	bl	3140 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY>
    f64c:	7820      	ldrb	r0, [r4, #0]
    f64e:	f7f3 fedf 	bl	3410 <sym_DQFOGVCNU4NTOMWSL3IYDNCMIXT2LT7SZHL5IHI>
    f652:	f814 09c0 	ldrb.w	r0, [r4], #-192
    f656:	f7f3 feb9 	bl	33cc <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y>
    f65a:	b120      	cbz	r0, f666 <sym_7Q3OGK46EJ4CJTNREFMB4I3YQOYV4MCCW6KC7XI+0x42>
    f65c:	2000      	movs	r0, #0
    f65e:	f884 00d8 	strb.w	r0, [r4, #216]	; 0xd8
    f662:	2000      	movs	r0, #0
    f664:	bd10      	pop	{r4, pc}
    f666:	f240 2109 	movw	r1, #521	; 0x209
    f66a:	2030      	movs	r0, #48	; 0x30
    f66c:	f7f5 fd72 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>

0000f670 <sym_MHDCHYAEWBCIUYGOTWRWGZEJ6XEBEBUHOO5T6WY>:
    f670:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
    f674:	4770      	bx	lr

0000f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>:
    f676:	f890 00d8 	ldrb.w	r0, [r0, #216]	; 0xd8
    f67a:	4770      	bx	lr

0000f67c <sym_3LXCSEW4O4NZFGMXLMWXSJJVGEQV4VDRFCVRV4Q>:
    f67c:	b50e      	push	{r1, r2, r3, lr}
    f67e:	4669      	mov	r1, sp
    f680:	2001      	movs	r0, #1
    f682:	f7fe fcbc 	bl	dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>
    f686:	b138      	cbz	r0, f698 <sym_3LXCSEW4O4NZFGMXLMWXSJJVGEQV4VDRFCVRV4Q+0x1c>
    f688:	f240 1137 	movw	r1, #311	; 0x137
    f68c:	2030      	movs	r0, #48	; 0x30
    f68e:	f7f5 fd61 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f692:	9802      	ldr	r0, [sp, #8]
    f694:	f7ff ffc6 	bl	f624 <sym_7Q3OGK46EJ4CJTNREFMB4I3YQOYV4MCCW6KC7XI>
    f698:	4668      	mov	r0, sp
    f69a:	f7f5 ff9f 	bl	55dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>
    f69e:	2800      	cmp	r0, #0
    f6a0:	d0f7      	beq.n	f692 <sym_3LXCSEW4O4NZFGMXLMWXSJJVGEQV4VDRFCVRV4Q+0x16>
    f6a2:	f7f9 f841 	bl	8728 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x58>
    f6a6:	2000      	movs	r0, #0
    f6a8:	bd0e      	pop	{r1, r2, r3, pc}

0000f6aa <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y>:
    f6aa:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    f6ac:	4604      	mov	r4, r0
    f6ae:	f890 01d3 	ldrb.w	r0, [r0, #467]	; 0x1d3
    f6b2:	2800      	cmp	r0, #0
    f6b4:	d15f      	bne.n	f776 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xcc>
    f6b6:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    f6ba:	2803      	cmp	r0, #3
    f6bc:	d15b      	bne.n	f776 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xcc>
    f6be:	f7f4 f971 	bl	39a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>
    f6c2:	f8d4 3238 	ldr.w	r3, [r4, #568]	; 0x238
    f6c6:	f8d4 223c 	ldr.w	r2, [r4, #572]	; 0x23c
    f6ca:	1ac0      	subs	r0, r0, r3
    f6cc:	eb61 0102 	sbc.w	r1, r1, r2
    f6d0:	2300      	movs	r3, #0
    f6d2:	461a      	mov	r2, r3
    f6d4:	1a1b      	subs	r3, r3, r0
    f6d6:	418a      	sbcs	r2, r1
    f6d8:	da4d      	bge.n	f776 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xcc>
    f6da:	1c42      	adds	r2, r0, #1
    f6dc:	f171 0100 	sbcs.w	r1, r1, #0
    f6e0:	db02      	blt.n	f6e8 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3e>
    f6e2:	f44f 61b9 	mov.w	r1, #1480	; 0x5c8
    f6e6:	e036      	b.n	f756 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xac>
    f6e8:	6921      	ldr	r1, [r4, #16]
    f6ea:	b111      	cbz	r1, f6f2 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x48>
    f6ec:	fbb0 f0f1 	udiv	r0, r0, r1
    f6f0:	e000      	b.n	f6f4 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x4a>
    f6f2:	2000      	movs	r0, #0
    f6f4:	f8b4 107c 	ldrh.w	r1, [r4, #124]	; 0x7c
    f6f8:	1c40      	adds	r0, r0, #1
    f6fa:	4408      	add	r0, r1
    f6fc:	f8a4 0214 	strh.w	r0, [r4, #532]	; 0x214
    f700:	f8b4 0214 	ldrh.w	r0, [r4, #532]	; 0x214
    f704:	f8b4 11cc 	ldrh.w	r1, [r4, #460]	; 0x1cc
    f708:	1a08      	subs	r0, r1, r0
    f70a:	b200      	sxth	r0, r0
    f70c:	2800      	cmp	r0, #0
    f70e:	dd32      	ble.n	f776 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xcc>
    f710:	f894 024c 	ldrb.w	r0, [r4, #588]	; 0x24c
    f714:	f7f3 fd14 	bl	3140 <sym_R4Y3KWNYX4PGGLE5X2L7DXMWMJUY3DOXD7LSUKY>
    f718:	2800      	cmp	r0, #0
    f71a:	d02c      	beq.n	f776 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xcc>
    f71c:	20ff      	movs	r0, #255	; 0xff
    f71e:	f884 0219 	strb.w	r0, [r4, #537]	; 0x219
    f722:	f8b4 00b6 	ldrh.w	r0, [r4, #182]	; 0xb6
    f726:	f8b4 10b4 	ldrh.w	r1, [r4, #180]	; 0xb4
    f72a:	ae01      	add	r6, sp, #4
    f72c:	1a40      	subs	r0, r0, r1
    f72e:	f8b4 107c 	ldrh.w	r1, [r4, #124]	; 0x7c
    f732:	1e40      	subs	r0, r0, #1
    f734:	4408      	add	r0, r1
    f736:	b285      	uxth	r5, r0
    f738:	e017      	b.n	f76a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xc0>
    f73a:	9600      	str	r6, [sp, #0]
    f73c:	f8b4 1214 	ldrh.w	r1, [r4, #532]	; 0x214
    f740:	2300      	movs	r3, #0
    f742:	2201      	movs	r2, #1
    f744:	4620      	mov	r0, r4
    f746:	f7f9 f8c3 	bl	88d0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x200>
    f74a:	2800      	cmp	r0, #0
    f74c:	d013      	beq.n	f776 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xcc>
    f74e:	2801      	cmp	r0, #1
    f750:	d004      	beq.n	f75c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xb2>
    f752:	f240 6101 	movw	r1, #1537	; 0x601
    f756:	2030      	movs	r0, #48	; 0x30
    f758:	f7f5 fcfc 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f75c:	f8b4 0214 	ldrh.w	r0, [r4, #532]	; 0x214
    f760:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    f764:	4408      	add	r0, r1
    f766:	f8a4 0214 	strh.w	r0, [r4, #532]	; 0x214
    f76a:	f8b4 0214 	ldrh.w	r0, [r4, #532]	; 0x214
    f76e:	1a28      	subs	r0, r5, r0
    f770:	b200      	sxth	r0, r0
    f772:	2800      	cmp	r0, #0
    f774:	dae1      	bge.n	f73a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x90>
    f776:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    f778:	2000      	movs	r0, #0
    f77a:	4770      	bx	lr
    f77c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f780:	4604      	mov	r4, r0
    f782:	2501      	movs	r5, #1
    f784:	f000 f90c 	bl	f9a0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f6>
    f788:	2600      	movs	r6, #0
    f78a:	f8a4 00e8 	strh.w	r0, [r4, #232]	; 0xe8
    f78e:	f884 60e0 	strb.w	r6, [r4, #224]	; 0xe0
    f792:	2701      	movs	r7, #1
    f794:	f884 70eb 	strb.w	r7, [r4, #235]	; 0xeb
    f798:	f894 10c8 	ldrb.w	r1, [r4, #200]	; 0xc8
    f79c:	f104 08e0 	add.w	r8, r4, #224	; 0xe0
    f7a0:	b169      	cbz	r1, f7be <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x114>
    f7a2:	e9f4 013c 	ldrd	r0, r1, [r4, #240]!	; 0xf0
    f7a6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    f7aa:	1880      	adds	r0, r0, r2
    f7ac:	f141 0100 	adc.w	r1, r1, #0
    f7b0:	e864 013c 	strd	r0, r1, [r4], #-240	; 0xf0
    f7b4:	2100      	movs	r1, #0
    f7b6:	4640      	mov	r0, r8
    f7b8:	f7fe ff89 	bl	e6ce <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY>
    f7bc:	e00d      	b.n	f7da <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x130>
    f7be:	4620      	mov	r0, r4
    f7c0:	f7ff fd6e 	bl	f2a0 <sym_RYQA5YFFRJZLTYB2ISC2Y3WUY3XB3LBBL37F22Q>
    f7c4:	4601      	mov	r1, r0
    f7c6:	e9f4 203c 	ldrd	r2, r0, [r4, #240]!	; 0xf0
    f7ca:	1852      	adds	r2, r2, r1
    f7cc:	4170      	adcs	r0, r6
    f7ce:	e864 203c 	strd	r2, r0, [r4], #-240	; 0xf0
    f7d2:	4640      	mov	r0, r8
    f7d4:	f7fe ff7b 	bl	e6ce <sym_K4XFYUFHWSS4WLYRDTKOJ7STOPYHBKAJBCXHBBY>
    f7d8:	1c45      	adds	r5, r0, #1
    f7da:	f8b4 00f8 	ldrh.w	r0, [r4, #248]	; 0xf8
    f7de:	1c41      	adds	r1, r0, #1
    f7e0:	290a      	cmp	r1, #10
    f7e2:	d202      	bcs.n	f7ea <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x140>
    f7e4:	4428      	add	r0, r5
    f7e6:	f8a4 00f8 	strh.w	r0, [r4, #248]	; 0xf8
    f7ea:	f8d4 00c4 	ldr.w	r0, [r4, #196]	; 0xc4
    f7ee:	b138      	cbz	r0, f800 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x156>
    f7f0:	f8b4 00f8 	ldrh.w	r0, [r4, #248]	; 0xf8
    f7f4:	1c40      	adds	r0, r0, #1
    f7f6:	280a      	cmp	r0, #10
    f7f8:	d302      	bcc.n	f800 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x156>
    f7fa:	f884 70ea 	strb.w	r7, [r4, #234]	; 0xea
    f7fe:	e002      	b.n	f806 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x15c>
    f800:	2002      	movs	r0, #2
    f802:	f884 00ea 	strb.w	r0, [r4, #234]	; 0xea
    f806:	4620      	mov	r0, r4
    f808:	f000 f823 	bl	f852 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1a8>
    f80c:	b120      	cbz	r0, f818 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x16e>
    f80e:	4620      	mov	r0, r4
    f810:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f814:	f000 b80e 	b.w	f834 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x18a>
    f818:	f894 00c0 	ldrb.w	r0, [r4, #192]	; 0xc0
    f81c:	4641      	mov	r1, r8
    f81e:	f000 f8bd 	bl	f99c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f2>
    f822:	2800      	cmp	r0, #0
    f824:	d104      	bne.n	f830 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x186>
    f826:	f44f 61d5 	mov.w	r1, #1704	; 0x6a8
    f82a:	2030      	movs	r0, #48	; 0x30
    f82c:	f7f5 fc92 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    f830:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f834:	b510      	push	{r4, lr}
    f836:	4604      	mov	r4, r0
    f838:	f814 0fc0 	ldrb.w	r0, [r4, #192]!
    f83c:	f7f3 fdc6 	bl	33cc <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y>
    f840:	2000      	movs	r0, #0
    f842:	7620      	strb	r0, [r4, #24]
    f844:	bd10      	pop	{r4, pc}
    f846:	b510      	push	{r4, lr}
    f848:	f7ff fd2e 	bl	f2a8 <sym_3NMQXTBVJ27TN5IIVET3BSKEAUONNKTPZTYP2HY>
    f84c:	f500 7088 	add.w	r0, r0, #272	; 0x110
    f850:	bd10      	pop	{r4, pc}
    f852:	b570      	push	{r4, r5, r6, lr}
    f854:	4605      	mov	r5, r0
    f856:	f890 0108 	ldrb.w	r0, [r0, #264]	; 0x108
    f85a:	b108      	cbz	r0, f860 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1b6>
    f85c:	2001      	movs	r0, #1
    f85e:	bd70      	pop	{r4, r5, r6, pc}
    f860:	e9d5 1040 	ldrd	r1, r0, [r5, #256]	; 0x100
    f864:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
    f868:	4050      	eors	r0, r2
    f86a:	ea70 0101 	orns	r1, r0, r1
    f86e:	d011      	beq.n	f894 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1ea>
    f870:	2400      	movs	r4, #0
    f872:	4628      	mov	r0, r5
    f874:	f7ff ffe7 	bl	f846 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x19c>
    f878:	e9f5 123c 	ldrd	r1, r2, [r5, #240]!	; 0xf0
    f87c:	1840      	adds	r0, r0, r1
    f87e:	4154      	adcs	r4, r2
    f880:	e9d5 2104 	ldrd	r2, r1, [r5, #16]
    f884:	3df0      	subs	r5, #240	; 0xf0
    f886:	1a10      	subs	r0, r2, r0
    f888:	41a1      	sbcs	r1, r4
    f88a:	d503      	bpl.n	f894 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1ea>
    f88c:	4628      	mov	r0, r5
    f88e:	f7ff fd5f 	bl	f350 <sym_RPDYS5TXULS3Z2BQR7IFNSOINXPPN4LN764SRIY>
    f892:	e7e3      	b.n	f85c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1b2>
    f894:	2000      	movs	r0, #0
    f896:	bd70      	pop	{r4, r5, r6, pc}
    f898:	b510      	push	{r4, lr}
    f89a:	4604      	mov	r4, r0
    f89c:	f890 006f 	ldrb.w	r0, [r0, #111]	; 0x6f
    f8a0:	f000 f9f2 	bl	fc88 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5de>
    f8a4:	4602      	mov	r2, r0
    f8a6:	4620      	mov	r0, r4
    f8a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f8ac:	f240 111b 	movw	r1, #283	; 0x11b
    f8b0:	f7ff bb85 	b.w	efbe <sym_EO2RG5OKHPJZIBYGTP56VVOSGXFYZ4DGV24KLDY>
    f8b4:	b510      	push	{r4, lr}
    f8b6:	f7fc fa9b 	bl	bdf0 <sym_2YSDS7VWGMSD5CN64D2VGQIYXBV3A6NJCHWFZEY>
    f8ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f8be:	f7f3 bee7 	b.w	3690 <sym_SFR5TVV24PZRIRC5QGOHL2X436PUHKRY2QWKP5Y>
    f8c2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f8c6:	4604      	mov	r4, r0
    f8c8:	f890 021a 	ldrb.w	r0, [r0, #538]	; 0x21a
    f8cc:	2800      	cmp	r0, #0
    f8ce:	d051      	beq.n	f974 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2ca>
    f8d0:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    f8d4:	2803      	cmp	r0, #3
    f8d6:	d14d      	bne.n	f974 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2ca>
    f8d8:	f894 906f 	ldrb.w	r9, [r4, #111]	; 0x6f
    f8dc:	f001 f9e2 	bl	10ca4 <sym_R2552DB5ZKNDWW24PBGEV77VCDBC44WVAYRCUXQ>
    f8e0:	4605      	mov	r5, r0
    f8e2:	f894 01c7 	ldrb.w	r0, [r4, #455]	; 0x1c7
    f8e6:	f7f8 ff11 	bl	870c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3c>
    f8ea:	4428      	add	r0, r5
    f8ec:	b286      	uxth	r6, r0
    f8ee:	f894 01c7 	ldrb.w	r0, [r4, #455]	; 0x1c7
    f8f2:	f7f8 ff0b 	bl	870c <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x3c>
    f8f6:	f500 60c8 	add.w	r0, r0, #1600	; 0x640
    f8fa:	fa1f f880 	uxth.w	r8, r0
    f8fe:	4648      	mov	r0, r9
    f900:	f7fc fb34 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    f904:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
    f908:	1a0d      	subs	r5, r1, r0
    f90a:	4648      	mov	r0, r9
    f90c:	f7fc fb5a 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    f910:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
    f914:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
    f918:	fbb0 f0fa 	udiv	r0, r0, sl
    f91c:	1a2d      	subs	r5, r5, r0
    f91e:	4648      	mov	r0, r9
    f920:	f7fc fb24 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    f924:	f8d4 11d8 	ldr.w	r1, [r4, #472]	; 0x1d8
    f928:	1a0f      	subs	r7, r1, r0
    f92a:	4648      	mov	r0, r9
    f92c:	f7fc fb4a 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    f930:	f24a 31a1 	movw	r1, #41889	; 0xa3a1
    f934:	4401      	add	r1, r0
    f936:	fbb1 f0fa 	udiv	r0, r1, sl
    f93a:	1a39      	subs	r1, r7, r0
    f93c:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
    f940:	4370      	muls	r0, r6
    f942:	fbb0 f2f8 	udiv	r2, r0, r8
    f946:	2029      	movs	r0, #41	; 0x29
    f948:	eb00 0051 	add.w	r0, r0, r1, lsr #1
    f94c:	3260      	adds	r2, #96	; 0x60
    f94e:	eba0 0152 	sub.w	r1, r0, r2, lsr #1
    f952:	eb00 0052 	add.w	r0, r0, r2, lsr #1
    f956:	42a9      	cmp	r1, r5
    f958:	d801      	bhi.n	f95e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2b4>
    f95a:	4285      	cmp	r5, r0
    f95c:	d901      	bls.n	f962 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2b8>
    f95e:	f7f5 f837 	bl	49d0 <sym_UG7CMBAYEZEKSKQK753P4TBTSPUXVRWUS6QJJOA>
    f962:	4631      	mov	r1, r6
    f964:	6920      	ldr	r0, [r4, #16]
    f966:	f7fd fa0a 	bl	cd7e <sym_XEJLNUQGS5P4R5IXDJFF6NE6C2FZWRZYDQOGMPI>
    f96a:	2100      	movs	r1, #0
    f96c:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
    f970:	f884 121a 	strb.w	r1, [r4, #538]	; 0x21a
    f974:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f978:	b570      	push	{r4, r5, r6, lr}
    f97a:	460c      	mov	r4, r1
    f97c:	4605      	mov	r5, r0
    f97e:	f7fc fb21 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    f982:	f24a 31a1 	movw	r1, #41889	; 0xa3a1
    f986:	4408      	add	r0, r1
    f988:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    f98c:	fbb0 f6f1 	udiv	r6, r0, r1
    f990:	4628      	mov	r0, r5
    f992:	f7fc faeb 	bl	bf6c <sym_V67AIMSO57NYVNGXZF2PDQSJQJLITHU4KD4CKAY>
    f996:	4430      	add	r0, r6
    f998:	4420      	add	r0, r4
    f99a:	bd70      	pop	{r4, r5, r6, pc}
    f99c:	f7f3 b83a 	b.w	2a14 <sym_NFDFVOR5BUFND4TNTGYIYR4ARXJRXWSQ4PVFUKY>
    f9a0:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    f9a2:	4604      	mov	r4, r0
    f9a4:	f7ff fca9 	bl	f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>
    f9a8:	b1f8      	cbz	r0, f9ea <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x340>
    f9aa:	4620      	mov	r0, r4
    f9ac:	f7ff fc9d 	bl	f2ea <sym_UEZ3FVWFJ5XVLQBVVAHW7UTXVCC77F7ZYGOMLTQ>
    f9b0:	b918      	cbnz	r0, f9ba <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x310>
    f9b2:	4620      	mov	r0, r4
    f9b4:	f7ff fca3 	bl	f2fe <sym_NGJGZTNK6YIH3QX2NKB6A6MT7N5AOKWA6ZOOANQ>
    f9b8:	b140      	cbz	r0, f9cc <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x322>
    f9ba:	2449      	movs	r4, #73	; 0x49
    f9bc:	4668      	mov	r0, sp
    f9be:	f7f5 faa3 	bl	4f08 <mpsl_fem_pa_is_configured>
    f9c2:	f89d 0000 	ldrb.w	r0, [sp]
    f9c6:	b118      	cbz	r0, f9d0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x326>
    f9c8:	2501      	movs	r5, #1
    f9ca:	e002      	b.n	f9d2 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x328>
    f9cc:	2442      	movs	r4, #66	; 0x42
    f9ce:	e7f5      	b.n	f9bc <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x312>
    f9d0:	2500      	movs	r5, #0
    f9d2:	a801      	add	r0, sp, #4
    f9d4:	f7f5 fa80 	bl	4ed8 <mpsl_fem_lna_is_configured>
    f9d8:	f89d 0004 	ldrb.w	r0, [sp, #4]
    f9dc:	b100      	cbz	r0, f9e0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x336>
    f9de:	2001      	movs	r0, #1
    f9e0:	4305      	orrs	r5, r0
    f9e2:	d000      	beq.n	f9e6 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x33c>
    f9e4:	3409      	adds	r4, #9
    f9e6:	4620      	mov	r0, r4
    f9e8:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    f9ea:	206b      	movs	r0, #107	; 0x6b
    f9ec:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    f9ee:	b570      	push	{r4, r5, r6, lr}
    f9f0:	4604      	mov	r4, r0
    f9f2:	f890 00c1 	ldrb.w	r0, [r0, #193]	; 0xc1
    f9f6:	2500      	movs	r5, #0
    f9f8:	b138      	cbz	r0, fa0a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x360>
    f9fa:	f7f7 fe1b 	bl	7634 <sym_K5GMJMBHBYPRCUIWKNEXGPSNQEZKEMBAP4JWHBQ>
    f9fe:	f242 7110 	movw	r1, #10000	; 0x2710
    fa02:	fbb0 f2f1 	udiv	r2, r0, r1
    fa06:	fb01 0512 	mls	r5, r1, r2, r0
    fa0a:	4620      	mov	r0, r4
    fa0c:	f7ff fc48 	bl	f2a0 <sym_RYQA5YFFRJZLTYB2ISC2Y3WUY3XB3LBBL37F22Q>
    fa10:	e9d4 213c 	ldrd	r2, r1, [r4, #240]	; 0xf0
    fa14:	4428      	add	r0, r5
    fa16:	34e0      	adds	r4, #224	; 0xe0
    fa18:	2500      	movs	r5, #0
    fa1a:	1882      	adds	r2, r0, r2
    fa1c:	eb45 0001 	adc.w	r0, r5, r1
    fa20:	e9c4 2004 	strd	r2, r0, [r4, #16]
    fa24:	f804 5b0b 	strb.w	r5, [r4], #11
    fa28:	2001      	movs	r0, #1
    fa2a:	f804 0901 	strb.w	r0, [r4], #-1
    fa2e:	2002      	movs	r0, #2
    fa30:	f804 09ea 	strb.w	r0, [r4], #-234
    fa34:	4620      	mov	r0, r4
    fa36:	f7ff ffb3 	bl	f9a0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f6>
    fa3a:	f8a4 00e8 	strh.w	r0, [r4, #232]	; 0xe8
    fa3e:	4620      	mov	r0, r4
    fa40:	f7ff ff07 	bl	f852 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x1a8>
    fa44:	b930      	cbnz	r0, fa54 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3aa>
    fa46:	f894 00c0 	ldrb.w	r0, [r4, #192]	; 0xc0
    fa4a:	f104 01e0 	add.w	r1, r4, #224	; 0xe0
    fa4e:	f7ff ffa5 	bl	f99c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x2f2>
    fa52:	b128      	cbz	r0, fa60 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3b6>
    fa54:	f8a4 50f8 	strh.w	r5, [r4, #248]	; 0xf8
    fa58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fa5c:	f7ff bf2a 	b.w	f8b4 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x20a>
    fa60:	f240 61ef 	movw	r1, #1775	; 0x6ef
    fa64:	2030      	movs	r0, #48	; 0x30
    fa66:	f7f5 fb75 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    fa6a:	b510      	push	{r4, lr}
    fa6c:	4604      	mov	r4, r0
    fa6e:	2000      	movs	r0, #0
    fa70:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
    fa74:	f894 024c 	ldrb.w	r0, [r4, #588]	; 0x24c
    fa78:	f7f3 fca8 	bl	33cc <sym_CFZK3G6ZC4ONUAYO2UALWQ4CBO7A6ADNAS2FS7Y>
    fa7c:	2020      	movs	r0, #32
    fa7e:	f884 024c 	strb.w	r0, [r4, #588]	; 0x24c
    fa82:	bd10      	pop	{r4, pc}
    fa84:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    fa88:	4604      	mov	r4, r0
    fa8a:	2500      	movs	r5, #0
    fa8c:	f880 50c8 	strb.w	r5, [r0, #200]	; 0xc8
    fa90:	e9d4 673c 	ldrd	r6, r7, [r4, #240]	; 0xf0
    fa94:	4689      	mov	r9, r1
    fa96:	f880 50d8 	strb.w	r5, [r0, #216]	; 0xd8
    fa9a:	f04f 0801 	mov.w	r8, #1
    fa9e:	f880 80d9 	strb.w	r8, [r0, #217]	; 0xd9
    faa2:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
    faa6:	4641      	mov	r1, r8
    faa8:	34c0      	adds	r4, #192	; 0xc0
    faaa:	f7f7 f985 	bl	6db8 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI>
    faae:	6860      	ldr	r0, [r4, #4]
    fab0:	f8c0 6238 	str.w	r6, [r0, #568]	; 0x238
    fab4:	f8c0 723c 	str.w	r7, [r0, #572]	; 0x23c
    fab8:	6861      	ldr	r1, [r4, #4]
    faba:	7820      	ldrb	r0, [r4, #0]
    fabc:	f881 024c 	strb.w	r0, [r1, #588]	; 0x24c
    fac0:	6861      	ldr	r1, [r4, #4]
    fac2:	f8c1 9250 	str.w	r9, [r1, #592]	; 0x250
    fac6:	6860      	ldr	r0, [r4, #4]
    fac8:	e9c0 6790 	strd	r6, r7, [r0, #576]	; 0x240
    facc:	6864      	ldr	r4, [r4, #4]
    face:	f884 5204 	strb.w	r5, [r4, #516]	; 0x204
    fad2:	2300      	movs	r3, #0
    fad4:	f8a4 5248 	strh.w	r5, [r4, #584]	; 0x248
    fad8:	461a      	mov	r2, r3
    fada:	4619      	mov	r1, r3
    fadc:	4620      	mov	r0, r4
    fade:	9500      	str	r5, [sp, #0]
    fae0:	f7f8 fef6 	bl	88d0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x200>
    fae4:	b120      	cbz	r0, faf0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x446>
    fae6:	f240 211d 	movw	r1, #541	; 0x21d
    faea:	2030      	movs	r0, #48	; 0x30
    faec:	f7f5 fb32 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    faf0:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
    faf4:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
    faf8:	f884 8204 	strb.w	r8, [r4, #516]	; 0x204
    fafc:	f8a4 5216 	strh.w	r5, [r4, #534]	; 0x216
    fb00:	f8a4 5214 	strh.w	r5, [r4, #532]	; 0x214
    fb04:	347c      	adds	r4, #124	; 0x7c
    fb06:	f884 519d 	strb.w	r5, [r4, #413]	; 0x19d
    fb0a:	8820      	ldrh	r0, [r4, #0]
    fb0c:	1e40      	subs	r0, r0, #1
    fb0e:	8020      	strh	r0, [r4, #0]
    fb10:	f8a4 51ce 	strh.w	r5, [r4, #462]	; 0x1ce
    fb14:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    fb18:	f7ff becc 	b.w	f8b4 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x20a>
    fb1c:	b570      	push	{r4, r5, r6, lr}
    fb1e:	b140      	cbz	r0, fb32 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x488>
    fb20:	2909      	cmp	r1, #9
    fb22:	d248      	bcs.n	fbb6 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x50c>
    fb24:	e8df f001 	tbb	[pc, r1]
    fb28:	3b3b1507 	.word	0x3b3b1507
    fb2c:	3f294737 	.word	0x3f294737
    fb30:	0043      	.short	0x0043
    fb32:	21ca      	movs	r1, #202	; 0xca
    fb34:	e03c      	b.n	fbb0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x506>
    fb36:	4604      	mov	r4, r0
    fb38:	f7f7 fecc 	bl	78d4 <sym_PY5KUATPBYOYJBMP6H7AVRPSEO7BZX2JK524O6A>
    fb3c:	b110      	cbz	r0, fb44 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x49a>
    fb3e:	f240 2179 	movw	r1, #633	; 0x279
    fb42:	e035      	b.n	fbb0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x506>
    fb44:	f8d4 00e4 	ldr.w	r0, [r4, #228]	; 0xe4
    fb48:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fb4c:	38ff      	subs	r0, #255	; 0xff
    fb4e:	f7f3 be6f 	b.w	3830 <sym_URFU24FFGR2HYB6CCPIPKPNZNMTWHKDYOATUJNY>
    fb52:	4605      	mov	r5, r0
    fb54:	f7ff fbcd 	bl	f2f2 <sym_XRU76NANM3C4EMKWQU3DF6CELSRNDV6766IKPJI>
    fb58:	b9a8      	cbnz	r0, fb86 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x4dc>
    fb5a:	4628      	mov	r0, r5
    fb5c:	f7ff fe73 	bl	f846 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x19c>
    fb60:	4604      	mov	r4, r0
    fb62:	f8d5 00e4 	ldr.w	r0, [r5, #228]	; 0xe4
    fb66:	42a0      	cmp	r0, r4
    fb68:	d20b      	bcs.n	fb82 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x4d8>
    fb6a:	1a20      	subs	r0, r4, r0
    fb6c:	2103      	movs	r1, #3
    fb6e:	f7f2 fd85 	bl	267c <sym_QWOE5H22ZADGJX5JSROW7BOI32Z6PPEEJCISNOQ>
    fb72:	b130      	cbz	r0, fb82 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x4d8>
    fb74:	4628      	mov	r0, r5
    fb76:	f8c5 40e4 	str.w	r4, [r5, #228]	; 0xe4
    fb7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fb7e:	f7ff bb4b 	b.w	f218 <sym_2K3JTQJLCTROZQI43ERT7GF5BTQ3SMAJXYMCVJI>
    fb82:	f8c5 40e4 	str.w	r4, [r5, #228]	; 0xe4
    fb86:	4628      	mov	r0, r5
    fb88:	f7f7 fec0 	bl	790c <sym_ID5SI2L6AD3KMSDR72YSJZGVIA6DEYQZU7WJI3I>
    fb8c:	2800      	cmp	r0, #0
    fb8e:	d014      	beq.n	fbba <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x510>
    fb90:	f44f 712b 	mov.w	r1, #684	; 0x2ac
    fb94:	e00c      	b.n	fbb0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x506>
    fb96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fb9a:	f7fc baf1 	b.w	c180 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ>
    fb9e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fba2:	f7ff bdeb 	b.w	f77c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0xd2>
    fba6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fbaa:	f7ff be43 	b.w	f834 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x18a>
    fbae:	21ea      	movs	r1, #234	; 0xea
    fbb0:	2030      	movs	r0, #48	; 0x30
    fbb2:	f7f5 facf 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    fbb6:	21ee      	movs	r1, #238	; 0xee
    fbb8:	e7fa      	b.n	fbb0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x506>
    fbba:	bd70      	pop	{r4, r5, r6, pc}
    fbbc:	b510      	push	{r4, lr}
    fbbe:	0004      	movs	r4, r0
    fbc0:	d008      	beq.n	fbd4 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x52a>
    fbc2:	2909      	cmp	r1, #9
    fbc4:	d25e      	bcs.n	fc84 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5da>
    fbc6:	e8df f001 	tbb	[pc, r1]
    fbca:	3807      	.short	0x3807
    fbcc:	5d3c4040 	.word	0x5d3c4040
    fbd0:	00594c45 	.word	0x00594c45
    fbd4:	2193      	movs	r1, #147	; 0x93
    fbd6:	e052      	b.n	fc7e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5d4>
    fbd8:	2100      	movs	r1, #0
    fbda:	f8c4 1254 	str.w	r1, [r4, #596]	; 0x254
    fbde:	f894 1218 	ldrb.w	r1, [r4, #536]	; 0x218
    fbe2:	4620      	mov	r0, r4
    fbe4:	b189      	cbz	r1, fc0a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x560>
    fbe6:	f8b0 2216 	ldrh.w	r2, [r0, #534]	; 0x216
    fbea:	f8b0 107c 	ldrh.w	r1, [r0, #124]	; 0x7c
    fbee:	428a      	cmp	r2, r1
    fbf0:	d106      	bne.n	fc00 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x556>
    fbf2:	f8b0 21cc 	ldrh.w	r2, [r0, #460]	; 0x1cc
    fbf6:	1a51      	subs	r1, r2, r1
    fbf8:	f8a0 11ce 	strh.w	r1, [r0, #462]	; 0x1ce
    fbfc:	4611      	mov	r1, r2
    fbfe:	e00d      	b.n	fc1c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x572>
    fc00:	1a51      	subs	r1, r2, r1
    fc02:	f8a0 11ce 	strh.w	r1, [r0, #462]	; 0x1ce
    fc06:	b291      	uxth	r1, r2
    fc08:	e008      	b.n	fc1c <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x572>
    fc0a:	f8b0 1214 	ldrh.w	r1, [r0, #532]	; 0x214
    fc0e:	f8b0 207c 	ldrh.w	r2, [r0, #124]	; 0x7c
    fc12:	1a89      	subs	r1, r1, r2
    fc14:	f8a0 11ce 	strh.w	r1, [r0, #462]	; 0x1ce
    fc18:	f8b0 1214 	ldrh.w	r1, [r0, #532]	; 0x214
    fc1c:	f8a0 107c 	strh.w	r1, [r0, #124]	; 0x7c
    fc20:	e9d0 128c 	ldrd	r1, r2, [r0, #560]	; 0x230
    fc24:	f8c0 1238 	str.w	r1, [r0, #568]	; 0x238
    fc28:	f8c0 223c 	str.w	r2, [r0, #572]	; 0x23c
    fc2c:	f7f9 f938 	bl	8ea0 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA>
    fc30:	4620      	mov	r0, r4
    fc32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fc36:	f7f9 b855 	b.w	8ce4 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x614>
    fc3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fc3e:	f000 b925 	b.w	fe8c <sym_RUQGL7Y7CEVCWXKLY62UGVRWLQYUPKUGTSH7NVY>
    fc42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fc46:	f7fc ba9b 	b.w	c180 <sym_EMR2H7KEGRFFKS6A4P3ZPPGOJSTVXLGRI25MEYQ>
    fc4a:	4620      	mov	r0, r4
    fc4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fc50:	f000 b827 	b.w	fca2 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5f8>
    fc54:	2001      	movs	r0, #1
    fc56:	f7f2 fd01 	bl	265c <sym_RWBLK2534FJMTER76IYUPZQ3YF74JEALZ2OBIDI>
    fc5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fc5e:	f7fe bbeb 	b.w	e438 <sym_DQHYQ3HZODNGY32MUV2QBXEWNH7ASP5VOSVL45Q>
    fc62:	f894 0204 	ldrb.w	r0, [r4, #516]	; 0x204
    fc66:	2804      	cmp	r0, #4
    fc68:	d001      	beq.n	fc6e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5c4>
    fc6a:	21b5      	movs	r1, #181	; 0xb5
    fc6c:	e007      	b.n	fc7e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5d4>
    fc6e:	4620      	mov	r0, r4
    fc70:	f7ff fefb 	bl	fa6a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3c0>
    fc74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fc78:	f7f7 bb66 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    fc7c:	21be      	movs	r1, #190	; 0xbe
    fc7e:	2030      	movs	r0, #48	; 0x30
    fc80:	f7f5 fa68 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    fc84:	21c2      	movs	r1, #194	; 0xc2
    fc86:	e7fa      	b.n	fc7e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x5d4>
    fc88:	b510      	push	{r4, lr}
    fc8a:	f7fc f99b 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
    fc8e:	f64d 7141 	movw	r1, #57153	; 0xdf41
    fc92:	4408      	add	r0, r1
    fc94:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    fc98:	fbb0 f0f1 	udiv	r0, r0, r1
    fc9c:	f200 1079 	addw	r0, r0, #377	; 0x179
    fca0:	bd10      	pop	{r4, pc}
    fca2:	b57c      	push	{r2, r3, r4, r5, r6, lr}
    fca4:	4604      	mov	r4, r0
    fca6:	f7f3 fe7d 	bl	39a4 <sym_PIDJEDDM47FHOOZQXISY5YBB3CBP5VAXWPCUL2Q>
    fcaa:	f8d4 3238 	ldr.w	r3, [r4, #568]	; 0x238
    fcae:	f8d4 223c 	ldr.w	r2, [r4, #572]	; 0x23c
    fcb2:	1ac0      	subs	r0, r0, r3
    fcb4:	eb61 0102 	sbc.w	r1, r1, r2
    fcb8:	2200      	movs	r2, #0
    fcba:	4613      	mov	r3, r2
    fcbc:	1a12      	subs	r2, r2, r0
    fcbe:	418b      	sbcs	r3, r1
    fcc0:	db02      	blt.n	fcc8 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x61e>
    fcc2:	f240 6111 	movw	r1, #1553	; 0x611
    fcc6:	e052      	b.n	fd6e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6c4>
    fcc8:	1c42      	adds	r2, r0, #1
    fcca:	f171 0100 	sbcs.w	r1, r1, #0
    fcce:	db02      	blt.n	fcd6 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x62c>
    fcd0:	f240 6112 	movw	r1, #1554	; 0x612
    fcd4:	e04b      	b.n	fd6e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6c4>
    fcd6:	6922      	ldr	r2, [r4, #16]
    fcd8:	2100      	movs	r1, #0
    fcda:	b10a      	cbz	r2, fce0 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x636>
    fcdc:	fbb0 f1f2 	udiv	r1, r0, r2
    fce0:	f894 0086 	ldrb.w	r0, [r4, #134]	; 0x86
    fce4:	280d      	cmp	r0, #13
    fce6:	d00c      	beq.n	fd02 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x658>
    fce8:	f8b4 007c 	ldrh.w	r0, [r4, #124]	; 0x7c
    fcec:	f8b4 2216 	ldrh.w	r2, [r4, #534]	; 0x216
    fcf0:	1843      	adds	r3, r0, r1
    fcf2:	1ad3      	subs	r3, r2, r3
    fcf4:	b21b      	sxth	r3, r3
    fcf6:	2b00      	cmp	r3, #0
    fcf8:	db06      	blt.n	fd08 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x65e>
    fcfa:	1c52      	adds	r2, r2, #1
    fcfc:	f8a4 2216 	strh.w	r2, [r4, #534]	; 0x216
    fd00:	e006      	b.n	fd10 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x666>
    fd02:	f8b4 0216 	ldrh.w	r0, [r4, #534]	; 0x216
    fd06:	e012      	b.n	fd2e <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x684>
    fd08:	1c49      	adds	r1, r1, #1
    fd0a:	4408      	add	r0, r1
    fd0c:	f8a4 0216 	strh.w	r0, [r4, #534]	; 0x216
    fd10:	f894 0219 	ldrb.w	r0, [r4, #537]	; 0x219
    fd14:	f88d 0000 	strb.w	r0, [sp]
    fd18:	9800      	ldr	r0, [sp, #0]
    fd1a:	9000      	str	r0, [sp, #0]
    fd1c:	f89d 0000 	ldrb.w	r0, [sp]
    fd20:	b940      	cbnz	r0, fd34 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x68a>
    fd22:	f8b4 0216 	ldrh.w	r0, [r4, #534]	; 0x216
    fd26:	f8b4 11cc 	ldrh.w	r1, [r4, #460]	; 0x1cc
    fd2a:	4288      	cmp	r0, r1
    fd2c:	d102      	bne.n	fd34 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x68a>
    fd2e:	1c40      	adds	r0, r0, #1
    fd30:	f8a4 0216 	strh.w	r0, [r4, #534]	; 0x216
    fd34:	f8b4 024a 	ldrh.w	r0, [r4, #586]	; 0x24a
    fd38:	1c40      	adds	r0, r0, #1
    fd3a:	f8a4 024a 	strh.w	r0, [r4, #586]	; 0x24a
    fd3e:	f8b4 00b6 	ldrh.w	r0, [r4, #182]	; 0xb6
    fd42:	f8b4 10b4 	ldrh.w	r1, [r4, #180]	; 0xb4
    fd46:	1a40      	subs	r0, r0, r1
    fd48:	f8b4 107c 	ldrh.w	r1, [r4, #124]	; 0x7c
    fd4c:	1e40      	subs	r0, r0, #1
    fd4e:	4408      	add	r0, r1
    fd50:	b285      	uxth	r5, r0
    fd52:	e026      	b.n	fda2 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6f8>
    fd54:	a801      	add	r0, sp, #4
    fd56:	2300      	movs	r3, #0
    fd58:	9000      	str	r0, [sp, #0]
    fd5a:	461a      	mov	r2, r3
    fd5c:	4620      	mov	r0, r4
    fd5e:	f7f8 fdb7 	bl	88d0 <sym_XVWN3IZ65SG2YZAV5STIEBPJ2RGWTP2JZ3UEJLQ+0x200>
    fd62:	2800      	cmp	r0, #0
    fd64:	d03b      	beq.n	fdde <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x734>
    fd66:	2801      	cmp	r0, #1
    fd68:	d004      	beq.n	fd74 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6ca>
    fd6a:	f240 6151 	movw	r1, #1617	; 0x651
    fd6e:	2030      	movs	r0, #48	; 0x30
    fd70:	f7f5 f9f0 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    fd74:	f8b4 0216 	ldrh.w	r0, [r4, #534]	; 0x216
    fd78:	f8b4 11c8 	ldrh.w	r1, [r4, #456]	; 0x1c8
    fd7c:	1a42      	subs	r2, r0, r1
    fd7e:	b212      	sxth	r2, r2
    fd80:	2a00      	cmp	r2, #0
    fd82:	da09      	bge.n	fd98 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6ee>
    fd84:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    fd88:	4402      	add	r2, r0
    fd8a:	1aaa      	subs	r2, r5, r2
    fd8c:	b212      	sxth	r2, r2
    fd8e:	2a00      	cmp	r2, #0
    fd90:	da02      	bge.n	fd98 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6ee>
    fd92:	f8a4 1216 	strh.w	r1, [r4, #534]	; 0x216
    fd96:	e004      	b.n	fda2 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6f8>
    fd98:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    fd9c:	4408      	add	r0, r1
    fd9e:	f8a4 0216 	strh.w	r0, [r4, #534]	; 0x216
    fda2:	f8b4 1216 	ldrh.w	r1, [r4, #534]	; 0x216
    fda6:	1a68      	subs	r0, r5, r1
    fda8:	b200      	sxth	r0, r0
    fdaa:	2800      	cmp	r0, #0
    fdac:	dad2      	bge.n	fd54 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x6aa>
    fdae:	f894 008a 	ldrb.w	r0, [r4, #138]	; 0x8a
    fdb2:	b190      	cbz	r0, fdda <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x730>
    fdb4:	2008      	movs	r0, #8
    fdb6:	f884 00a6 	strb.w	r0, [r4, #166]	; 0xa6
    fdba:	2208      	movs	r2, #8
    fdbc:	4621      	mov	r1, r4
    fdbe:	f104 009d 	add.w	r0, r4, #157	; 0x9d
    fdc2:	f7f7 f9ef 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    fdc6:	4620      	mov	r0, r4
    fdc8:	f000 f862 	bl	fe90 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ>
    fdcc:	4620      	mov	r0, r4
    fdce:	f7ff fe4c 	bl	fa6a <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x3c0>
    fdd2:	e8bd 407c 	ldmia.w	sp!, {r2, r3, r4, r5, r6, lr}
    fdd6:	f7f7 bab7 	b.w	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    fdda:	203e      	movs	r0, #62	; 0x3e
    fddc:	e7eb      	b.n	fdb6 <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y+0x70c>
    fdde:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
    fde0:	00fa01f4 	.word	0x00fa01f4
    fde4:	00640096 	.word	0x00640096
    fde8:	0032004b 	.word	0x0032004b
    fdec:	0014001e 	.word	0x0014001e
    fdf0:	0005000a 	.word	0x0005000a
    fdf4:	00010002 	.word	0x00010002
    fdf8:	eb00 00d1 	add.w	r0, r0, r1, lsr #3
    fdfc:	f001 0307 	and.w	r3, r1, #7
    fe00:	7802      	ldrb	r2, [r0, #0]
    fe02:	2101      	movs	r1, #1
    fe04:	4099      	lsls	r1, r3
    fe06:	438a      	bics	r2, r1
    fe08:	7002      	strb	r2, [r0, #0]
    fe0a:	4770      	bx	lr
    fe0c:	eb00 00d1 	add.w	r0, r0, r1, lsr #3
    fe10:	f001 0307 	and.w	r3, r1, #7
    fe14:	7802      	ldrb	r2, [r0, #0]
    fe16:	2101      	movs	r1, #1
    fe18:	4099      	lsls	r1, r3
    fe1a:	430a      	orrs	r2, r1
    fe1c:	7002      	strb	r2, [r0, #0]
    fe1e:	4770      	bx	lr

0000fe20 <sym_HT64RIVISXSWFJE3LL26YHKQRTRRXKVEDBUUUOQ>:
    fe20:	b510      	push	{r4, lr}
    fe22:	4604      	mov	r4, r0
    fe24:	f8d0 027c 	ldr.w	r0, [r0, #636]	; 0x27c
    fe28:	6921      	ldr	r1, [r4, #16]
    fe2a:	4288      	cmp	r0, r1
    fe2c:	d109      	bne.n	fe42 <sym_HT64RIVISXSWFJE3LL26YHKQRTRRXKVEDBUUUOQ+0x22>
    fe2e:	f8b4 1280 	ldrh.w	r1, [r4, #640]	; 0x280
    fe32:	8b22      	ldrh	r2, [r4, #24]
    fe34:	4291      	cmp	r1, r2
    fe36:	d104      	bne.n	fe42 <sym_HT64RIVISXSWFJE3LL26YHKQRTRRXKVEDBUUUOQ+0x22>
    fe38:	f8b4 1282 	ldrh.w	r1, [r4, #642]	; 0x282
    fe3c:	8b62      	ldrh	r2, [r4, #26]
    fe3e:	4291      	cmp	r1, r2
    fe40:	d016      	beq.n	fe70 <sym_HT64RIVISXSWFJE3LL26YHKQRTRRXKVEDBUUUOQ+0x50>
    fe42:	8821      	ldrh	r1, [r4, #0]
    fe44:	f8a4 11ae 	strh.w	r1, [r4, #430]	; 0x1ae
    fe48:	f7fe fb6e 	bl	e528 <sym_DSAIJDVMFSSNYDQYP4G3W4ZBYTG4PAWPSVOBJ2Y>
    fe4c:	f8a4 01b0 	strh.w	r0, [r4, #432]	; 0x1b0
    fe50:	f8b4 0280 	ldrh.w	r0, [r4, #640]	; 0x280
    fe54:	f8a4 01b2 	strh.w	r0, [r4, #434]	; 0x1b2
    fe58:	f8b4 0282 	ldrh.w	r0, [r4, #642]	; 0x282
    fe5c:	f8a4 01b4 	strh.w	r0, [r4, #436]	; 0x1b4
    fe60:	2206      	movs	r2, #6
    fe62:	4621      	mov	r1, r4
    fe64:	f504 70d1 	add.w	r0, r4, #418	; 0x1a2
    fe68:	f7f7 f99c 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
    fe6c:	f7f7 fa6c 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
    fe70:	2102      	movs	r1, #2
    fe72:	4620      	mov	r0, r4
    fe74:	f7f6 ffa0 	bl	6db8 <sym_4NT3PFFI5Z6RN57T2HW54HJZ23JEQUTUQPJLJGI>
    fe78:	2000      	movs	r0, #0
    fe7a:	f804 0f86 	strb.w	r0, [r4, #134]!
    fe7e:	2003      	movs	r0, #3
    fe80:	7120      	strb	r0, [r4, #4]
    fe82:	bd10      	pop	{r4, pc}

0000fe84 <sym_PDDLBAI7RAK2OQ7ZHFU33L5KMJV5YKPLX5ITXAY>:
    fe84:	f7f5 bd1a 	b.w	58bc <sym_3QFBRH4ZSIA64QP2I3K547Y5WIALGQTCBP5Y5SQ>

0000fe88 <sym_OTZAOT4DEZSL3R4MXRNUS2BIBKPPCOEO2SMZYAI>:
    fe88:	2000      	movs	r0, #0
    fe8a:	4770      	bx	lr

0000fe8c <sym_RUQGL7Y7CEVCWXKLY62UGVRWLQYUPKUGTSH7NVY>:
    fe8c:	f7f6 b9d6 	b.w	623c <sym_WCN6C6ROB2XGQKTGXN5OMY5TLRX5IYOWNO7A6PQ>

0000fe90 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ>:
    fe90:	2100      	movs	r1, #0
    fe92:	f880 1085 	strb.w	r1, [r0, #133]	; 0x85
    fe96:	f880 1086 	strb.w	r1, [r0, #134]	; 0x86
    fe9a:	f880 108a 	strb.w	r1, [r0, #138]	; 0x8a
    fe9e:	f890 11d3 	ldrb.w	r1, [r0, #467]	; 0x1d3
    fea2:	b109      	cbz	r1, fea8 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x18>
    fea4:	2102      	movs	r1, #2
    fea6:	e000      	b.n	feaa <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x1a>
    fea8:	2103      	movs	r1, #3
    feaa:	f7f8 bbd7 	b.w	865c <sym_EXAZKO22MNOFNIXIFHQ2Z4GAYMKBCE2UPJ6JSVI>
    feae:	f890 0094 	ldrb.w	r0, [r0, #148]	; 0x94
    feb2:	28fe      	cmp	r0, #254	; 0xfe
    feb4:	d001      	beq.n	feba <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x2a>
    feb6:	2001      	movs	r0, #1
    feb8:	4770      	bx	lr
    feba:	2000      	movs	r0, #0
    febc:	4770      	bx	lr
    febe:	b510      	push	{r4, lr}
    fec0:	2801      	cmp	r0, #1
    fec2:	d006      	beq.n	fed2 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x42>
    fec4:	2802      	cmp	r0, #2
    fec6:	d004      	beq.n	fed2 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x42>
    fec8:	f240 21a9 	movw	r1, #681	; 0x2a9
    fecc:	2006      	movs	r0, #6
    fece:	f7f5 f941 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
    fed2:	bd10      	pop	{r4, pc}
    fed4:	2801      	cmp	r0, #1
    fed6:	d002      	beq.n	fede <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x4e>
    fed8:	2802      	cmp	r0, #2
    feda:	d105      	bne.n	fee8 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x58>
    fedc:	e002      	b.n	fee4 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x54>
    fede:	2901      	cmp	r1, #1
    fee0:	d004      	beq.n	feec <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x5c>
    fee2:	e001      	b.n	fee8 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x58>
    fee4:	2902      	cmp	r1, #2
    fee6:	d001      	beq.n	feec <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x5c>
    fee8:	2000      	movs	r0, #0
    feea:	4770      	bx	lr
    feec:	2001      	movs	r0, #1
    feee:	4770      	bx	lr
    fef0:	1a40      	subs	r0, r0, r1
    fef2:	b200      	sxth	r0, r0
    fef4:	f647 71fe 	movw	r1, #32766	; 0x7ffe
    fef8:	4288      	cmp	r0, r1
    fefa:	dc01      	bgt.n	ff00 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x70>
    fefc:	2800      	cmp	r0, #0
    fefe:	dc01      	bgt.n	ff04 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x74>
    ff00:	2001      	movs	r0, #1
    ff02:	4770      	bx	lr
    ff04:	2000      	movs	r0, #0
    ff06:	4770      	bx	lr
    ff08:	4602      	mov	r2, r0
    ff0a:	2000      	movs	r0, #0
    ff0c:	2a16      	cmp	r2, #22
    ff0e:	d102      	bne.n	ff16 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x86>
    ff10:	4608      	mov	r0, r1
    ff12:	f7f9 bf9d 	b.w	9e50 <sym_GRKUQI62F6CK2HPCZKZRWSZ3PZVCGXTWPZAIMJA+0xfb0>
    ff16:	4770      	bx	lr
    ff18:	eb00 00d1 	add.w	r0, r0, r1, lsr #3
    ff1c:	f001 0107 	and.w	r1, r1, #7
    ff20:	7800      	ldrb	r0, [r0, #0]
    ff22:	40c8      	lsrs	r0, r1
    ff24:	f000 0001 	and.w	r0, r0, #1
    ff28:	4770      	bx	lr
    ff2a:	b118      	cbz	r0, ff34 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0xa4>
    ff2c:	2802      	cmp	r0, #2
    ff2e:	d001      	beq.n	ff34 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0xa4>
    ff30:	2001      	movs	r0, #1
    ff32:	4770      	bx	lr
    ff34:	2000      	movs	r0, #0
    ff36:	4770      	bx	lr

0000ff38 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ>:
    ff38:	b53e      	push	{r1, r2, r3, r4, r5, lr}
    ff3a:	7881      	ldrb	r1, [r0, #2]
    ff3c:	4604      	mov	r4, r0
    ff3e:	291a      	cmp	r1, #26
    ff40:	d025      	beq.n	ff8e <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x56>
    ff42:	dc0e      	bgt.n	ff62 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x2a>
    ff44:	2916      	cmp	r1, #22
    ff46:	d22c      	bcs.n	ffa2 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x6a>
    ff48:	e8df f001 	tbb	[pc, r1]
    ff4c:	2b2b2b2b 	.word	0x2b2b2b2b
    ff50:	2b2b212b 	.word	0x2b2b212b
    ff54:	2b2b2b2b 	.word	0x2b2b2b2b
    ff58:	2b2b2b2b 	.word	0x2b2b2b2b
    ff5c:	212b2b2b 	.word	0x212b2b2b
    ff60:	2121      	.short	0x2121
    ff62:	292a      	cmp	r1, #42	; 0x2a
    ff64:	d01d      	beq.n	ffa2 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x6a>
    ff66:	dc0b      	bgt.n	ff80 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x48>
    ff68:	f1a1 011e 	sub.w	r1, r1, #30
    ff6c:	290c      	cmp	r1, #12
    ff6e:	d218      	bcs.n	ffa2 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x6a>
    ff70:	e8df f001 	tbb	[pc, r1]
    ff74:	17171717 	.word	0x17171717
    ff78:	17171717 	.word	0x17171717
    ff7c:	0d171717 	.word	0x0d171717
    ff80:	393a      	subs	r1, #58	; 0x3a
    ff82:	2904      	cmp	r1, #4
    ff84:	d20d      	bcs.n	ffa2 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x6a>
    ff86:	e8df f001 	tbb	[pc, r1]
    ff8a:	020c      	.short	0x020c
    ff8c:	020c      	.short	0x020c
    ff8e:	8820      	ldrh	r0, [r4, #0]
    ff90:	f5b0 6f70 	cmp.w	r0, #3840	; 0xf00
    ff94:	d205      	bcs.n	ffa2 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x6a>
    ff96:	4669      	mov	r1, sp
    ff98:	f7fe fab5 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
    ff9c:	b118      	cbz	r0, ffa6 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x6e>
    ff9e:	2002      	movs	r0, #2
    ffa0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    ffa2:	2012      	movs	r0, #18
    ffa4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    ffa6:	9801      	ldr	r0, [sp, #4]
    ffa8:	f890 1118 	ldrb.w	r1, [r0, #280]	; 0x118
    ffac:	f88d 1008 	strb.w	r1, [sp, #8]
    ffb0:	9902      	ldr	r1, [sp, #8]
    ffb2:	9102      	str	r1, [sp, #8]
    ffb4:	f89d 1008 	ldrb.w	r1, [sp, #8]
    ffb8:	f500 708c 	add.w	r0, r0, #280	; 0x118
    ffbc:	b109      	cbz	r1, ffc2 <sym_CY3FVUNSUUR4I46K644NW3FXSFSLG3ETQWBRBHQ+0x8a>
    ffbe:	200c      	movs	r0, #12
    ffc0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    ffc2:	21ff      	movs	r1, #255	; 0xff
    ffc4:	7001      	strb	r1, [r0, #0]
    ffc6:	78a1      	ldrb	r1, [r4, #2]
    ffc8:	7041      	strb	r1, [r0, #1]
    ffca:	4668      	mov	r0, sp
    ffcc:	f7fe fe5a 	bl	ec84 <sym_24AALTDC2IQ6VNWU2ALOY4V3RG5R2RARTUG4AZY>
    ffd0:	2000      	movs	r0, #0
    ffd2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0000ffd4 <sym_JNP3XPG2S47QWEENF5PX2JQ36HNB7C2PPNDBQRI>:
    ffd4:	b510      	push	{r4, lr}
    ffd6:	4604      	mov	r4, r0
    ffd8:	f000 fe01 	bl	10bde <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3bc>
    ffdc:	b108      	cbz	r0, ffe2 <sym_JNP3XPG2S47QWEENF5PX2JQ36HNB7C2PPNDBQRI+0xe>
    ffde:	200c      	movs	r0, #12
    ffe0:	bd10      	pop	{r4, pc}
    ffe2:	7820      	ldrb	r0, [r4, #0]
    ffe4:	b118      	cbz	r0, ffee <sym_JNP3XPG2S47QWEENF5PX2JQ36HNB7C2PPNDBQRI+0x1a>
    ffe6:	2801      	cmp	r0, #1
    ffe8:	d001      	beq.n	ffee <sym_JNP3XPG2S47QWEENF5PX2JQ36HNB7C2PPNDBQRI+0x1a>
    ffea:	2012      	movs	r0, #18
    ffec:	bd10      	pop	{r4, pc}
    ffee:	f7ff ff9c 	bl	ff2a <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x9a>
    fff2:	1c61      	adds	r1, r4, #1
    fff4:	f7f6 fdae 	bl	6b54 <sym_GHVM34OXBYILMDKR3F5DVNCQCBMJUJL5PW2RQYQ>
    fff8:	b108      	cbz	r0, fffe <sym_JNP3XPG2S47QWEENF5PX2JQ36HNB7C2PPNDBQRI+0x2a>
    fffa:	2000      	movs	r0, #0
    fffc:	bd10      	pop	{r4, pc}
    fffe:	2007      	movs	r0, #7
   10000:	bd10      	pop	{r4, pc}

00010002 <sym_UL6TXQTTOV34QCAIQPVPFYEQSUUJPIEN42CTITI>:
   10002:	b510      	push	{r4, lr}
   10004:	f000 fdeb 	bl	10bde <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3bc>
   10008:	b108      	cbz	r0, 1000e <sym_UL6TXQTTOV34QCAIQPVPFYEQSUUJPIEN42CTITI+0xc>
   1000a:	200c      	movs	r0, #12
   1000c:	bd10      	pop	{r4, pc}
   1000e:	f7f6 fdc9 	bl	6ba4 <sym_KO3VCNGABVWM4325342CFFPZBSXFKFARUCMURAY>
   10012:	2000      	movs	r0, #0
   10014:	bd10      	pop	{r4, pc}

00010016 <sym_V4G4DUSXVGCZMSYXHZZWQMKMNZCZVEEIBVCQ7EQ>:
   10016:	b510      	push	{r4, lr}
   10018:	460b      	mov	r3, r1
   1001a:	2201      	movs	r2, #1
   1001c:	f100 0110 	add.w	r1, r0, #16
   10020:	f7fe fa53 	bl	e4ca <sym_L64WJ6W52HQBFQCTPO5LHELOWQEJNMIWLQKG6JY>
   10024:	2000      	movs	r0, #0
   10026:	bd10      	pop	{r4, pc}

00010028 <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA>:
   10028:	b510      	push	{r4, lr}
   1002a:	8800      	ldrh	r0, [r0, #0]
   1002c:	2100      	movs	r1, #0
   1002e:	f7fd ffdc 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
   10032:	b118      	cbz	r0, 1003c <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA+0x14>
   10034:	f890 1258 	ldrb.w	r1, [r0, #600]	; 0x258
   10038:	b111      	cbz	r1, 10040 <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA+0x18>
   1003a:	e007      	b.n	1004c <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA+0x24>
   1003c:	2002      	movs	r0, #2
   1003e:	bd10      	pop	{r4, pc}
   10040:	f890 1086 	ldrb.w	r1, [r0, #134]	; 0x86
   10044:	2914      	cmp	r1, #20
   10046:	d003      	beq.n	10050 <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA+0x28>
   10048:	2915      	cmp	r1, #21
   1004a:	d001      	beq.n	10050 <sym_FYIHUHKV4DLEPRADEPLDQO3YFUPWZFWRUJ4JAOA+0x28>
   1004c:	200c      	movs	r0, #12
   1004e:	bd10      	pop	{r4, pc}
   10050:	2102      	movs	r1, #2
   10052:	f880 1258 	strb.w	r1, [r0, #600]	; 0x258
   10056:	2000      	movs	r0, #0
   10058:	bd10      	pop	{r4, pc}

0001005a <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI>:
   1005a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1005c:	4605      	mov	r5, r0
   1005e:	8800      	ldrh	r0, [r0, #0]
   10060:	2100      	movs	r1, #0
   10062:	f7fd ffc2 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
   10066:	0004      	movs	r4, r0
   10068:	d003      	beq.n	10072 <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI+0x18>
   1006a:	f894 0258 	ldrb.w	r0, [r4, #600]	; 0x258
   1006e:	b110      	cbz	r0, 10076 <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI+0x1c>
   10070:	e011      	b.n	10096 <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI+0x3c>
   10072:	2002      	movs	r0, #2
   10074:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10076:	f894 0086 	ldrb.w	r0, [r4, #134]	; 0x86
   1007a:	2814      	cmp	r0, #20
   1007c:	d001      	beq.n	10082 <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI+0x28>
   1007e:	2815      	cmp	r0, #21
   10080:	d109      	bne.n	10096 <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI+0x3c>
   10082:	f894 028c 	ldrb.w	r0, [r4, #652]	; 0x28c
   10086:	f88d 0000 	strb.w	r0, [sp]
   1008a:	9800      	ldr	r0, [sp, #0]
   1008c:	9000      	str	r0, [sp, #0]
   1008e:	f89d 0000 	ldrb.w	r0, [sp]
   10092:	2601      	movs	r6, #1
   10094:	b108      	cbz	r0, 1009a <sym_NLJDQQVQW4HF3HHWCCOGCGX457WQXW2LVV5NUTI+0x40>
   10096:	200c      	movs	r0, #12
   10098:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1009a:	2210      	movs	r2, #16
   1009c:	1ca9      	adds	r1, r5, #2
   1009e:	f204 2059 	addw	r0, r4, #601	; 0x259
   100a2:	f7fc ff9b 	bl	cfdc <sym_DQONLUECJTIEYFOFJXXAPJO4POIAJKJNKBGVN5A>
   100a6:	f884 6258 	strb.w	r6, [r4, #600]	; 0x258
   100aa:	2000      	movs	r0, #0
   100ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000100ae <sym_PMB4FUQR4IQVAL4FOP3PPQDDXYDFQIUYDVZ6DGY>:
   100ae:	b510      	push	{r4, lr}
   100b0:	2108      	movs	r1, #8
   100b2:	f7f5 f8fb 	bl	52ac <sym_CVMXQJYKHZVHIOMGOYEICPLVAIQNUBL6USVNZSA>
   100b6:	2000      	movs	r0, #0
   100b8:	bd10      	pop	{r4, pc}

000100ba <sym_IZN3QWH7I4A7OX5E6DK53W35W3UX25DTZ6CQ57Q>:
   100ba:	b510      	push	{r4, lr}
   100bc:	4604      	mov	r4, r0
   100be:	f7fb f8a5 	bl	b20c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x138>
   100c2:	f7ff f920 	bl	f306 <sym_L5UCRJFFWEVVII5IYG6PAKIQHXM34B62KO6ERPY>
   100c6:	7020      	strb	r0, [r4, #0]
   100c8:	2000      	movs	r0, #0
   100ca:	bd10      	pop	{r4, pc}

000100cc <sym_IS5N626FV5MT54PZIWSKFZUUH6WWJWJ46G6YN3A>:
   100cc:	21fb      	movs	r1, #251	; 0xfb
   100ce:	8001      	strh	r1, [r0, #0]
   100d0:	f640 0248 	movw	r2, #2120	; 0x848
   100d4:	8042      	strh	r2, [r0, #2]
   100d6:	8081      	strh	r1, [r0, #4]
   100d8:	80c2      	strh	r2, [r0, #6]
   100da:	2000      	movs	r0, #0
   100dc:	4770      	bx	lr

000100de <sym_CT735EXQUXWPD7TNRP2WWTA3LGLYUEOZMPS7RMI>:
   100de:	b51c      	push	{r2, r3, r4, lr}
   100e0:	8800      	ldrh	r0, [r0, #0]
   100e2:	4669      	mov	r1, sp
   100e4:	f7fe fa0f 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   100e8:	2800      	cmp	r0, #0
   100ea:	d10d      	bne.n	10108 <sym_CT735EXQUXWPD7TNRP2WWTA3LGLYUEOZMPS7RMI+0x2a>
   100ec:	f89d 0000 	ldrb.w	r0, [sp]
   100f0:	9c01      	ldr	r4, [sp, #4]
   100f2:	2801      	cmp	r0, #1
   100f4:	f504 748c 	add.w	r4, r4, #280	; 0x118
   100f8:	d103      	bne.n	10102 <sym_CT735EXQUXWPD7TNRP2WWTA3LGLYUEOZMPS7RMI+0x24>
   100fa:	9801      	ldr	r0, [sp, #4]
   100fc:	f000 fcf0 	bl	10ae0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2be>
   10100:	b118      	cbz	r0, 1010a <sym_CT735EXQUXWPD7TNRP2WWTA3LGLYUEOZMPS7RMI+0x2c>
   10102:	7ce0      	ldrb	r0, [r4, #19]
   10104:	b118      	cbz	r0, 1010e <sym_CT735EXQUXWPD7TNRP2WWTA3LGLYUEOZMPS7RMI+0x30>
   10106:	203a      	movs	r0, #58	; 0x3a
   10108:	bd1c      	pop	{r2, r3, r4, pc}
   1010a:	2002      	movs	r0, #2
   1010c:	bd1c      	pop	{r2, r3, r4, pc}
   1010e:	2001      	movs	r0, #1
   10110:	74e0      	strb	r0, [r4, #19]
   10112:	2000      	movs	r0, #0
   10114:	bd1c      	pop	{r2, r3, r4, pc}

00010116 <sym_KQ364TAUBSTGBVLC6BUZ6LU5UQACEISDV2KKO5I>:
   10116:	b510      	push	{r4, lr}
   10118:	4604      	mov	r4, r0
   1011a:	20d8      	movs	r0, #216	; 0xd8
   1011c:	7020      	strb	r0, [r4, #0]
   1011e:	f000 fcdc 	bl	10ada <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b8>
   10122:	7060      	strb	r0, [r4, #1]
   10124:	2000      	movs	r0, #0
   10126:	bd10      	pop	{r4, pc}

00010128 <sym_5OKDNHIYSDG2NFFB242VCRESG3W37YENBGQLRBA>:
   10128:	2108      	movs	r1, #8
   1012a:	7001      	strb	r1, [r0, #0]
   1012c:	2000      	movs	r0, #0
   1012e:	4770      	bx	lr

00010130 <sym_FQNF6KMIBMQDKYS2BJP6ZB7BLEET53WUIWQK6FA>:
   10130:	b510      	push	{r4, lr}
   10132:	4604      	mov	r4, r0
   10134:	f000 fd53 	bl	10bde <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3bc>
   10138:	b108      	cbz	r0, 1013e <sym_FQNF6KMIBMQDKYS2BJP6ZB7BLEET53WUIWQK6FA+0xe>
   1013a:	200c      	movs	r0, #12
   1013c:	bd10      	pop	{r4, pc}
   1013e:	7820      	ldrb	r0, [r4, #0]
   10140:	b108      	cbz	r0, 10146 <sym_FQNF6KMIBMQDKYS2BJP6ZB7BLEET53WUIWQK6FA+0x16>
   10142:	2801      	cmp	r0, #1
   10144:	d107      	bne.n	10156 <sym_FQNF6KMIBMQDKYS2BJP6ZB7BLEET53WUIWQK6FA+0x26>
   10146:	f7ff fef0 	bl	ff2a <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x9a>
   1014a:	1c61      	adds	r1, r4, #1
   1014c:	f7fe f9b2 	bl	e4b4 <sym_JAE5CJ34QIQM34DAKQFWDERFAUN5NXFJM57HRLY>
   10150:	b108      	cbz	r0, 10156 <sym_FQNF6KMIBMQDKYS2BJP6ZB7BLEET53WUIWQK6FA+0x26>
   10152:	2000      	movs	r0, #0
   10154:	bd10      	pop	{r4, pc}
   10156:	2012      	movs	r0, #18
   10158:	bd10      	pop	{r4, pc}

0001015a <sym_KXE6R52JHXVKOK6AHXAXVCPJHWR4FK73UB2AK7I>:
   1015a:	b51c      	push	{r2, r3, r4, lr}
   1015c:	4604      	mov	r4, r0
   1015e:	f7fb f855 	bl	b20c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x138>
   10162:	2000      	movs	r0, #0
   10164:	f88d 0002 	strb.w	r0, [sp, #2]
   10168:	2103      	movs	r1, #3
   1016a:	f88d 1001 	strb.w	r1, [sp, #1]
   1016e:	f814 1b01 	ldrb.w	r1, [r4], #1
   10172:	f88d 1003 	strb.w	r1, [sp, #3]
   10176:	f88d 0000 	strb.w	r0, [sp]
   1017a:	4668      	mov	r0, sp
   1017c:	9401      	str	r4, [sp, #4]
   1017e:	f000 f97d 	bl	1047c <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY>
   10182:	bd1c      	pop	{r2, r3, r4, pc}

00010184 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ>:
   10184:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   10186:	4605      	mov	r5, r0
   10188:	f7fb f840 	bl	b20c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x138>
   1018c:	4606      	mov	r6, r0
   1018e:	7828      	ldrb	r0, [r5, #0]
   10190:	2400      	movs	r4, #0
   10192:	b160      	cbz	r0, 101ae <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x2a>
   10194:	f88d 4000 	strb.w	r4, [sp]
   10198:	2001      	movs	r0, #1
   1019a:	f10d 0101 	add.w	r1, sp, #1
   1019e:	f7f5 fe8f 	bl	5ec0 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI>
   101a2:	b120      	cbz	r0, 101ae <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x2a>
   101a4:	4668      	mov	r0, sp
   101a6:	f000 f897 	bl	102d8 <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II>
   101aa:	2800      	cmp	r0, #0
   101ac:	d112      	bne.n	101d4 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x50>
   101ae:	f88d 400c 	strb.w	r4, [sp, #12]
   101b2:	4630      	mov	r0, r6
   101b4:	f7ff f89d 	bl	f2f2 <sym_XRU76NANM3C4EMKWQU3DF6CELSRNDV6766IKPJI>
   101b8:	b118      	cbz	r0, 101c2 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x3e>
   101ba:	2080      	movs	r0, #128	; 0x80
   101bc:	f8ad 000d 	strh.w	r0, [sp, #13]
   101c0:	e001      	b.n	101c6 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x42>
   101c2:	f8ad 400d 	strh.w	r4, [sp, #13]
   101c6:	f88d 400f 	strb.w	r4, [sp, #15]
   101ca:	7828      	ldrb	r0, [r5, #0]
   101cc:	2801      	cmp	r0, #1
   101ce:	d003      	beq.n	101d8 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x54>
   101d0:	b138      	cbz	r0, 101e2 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x5e>
   101d2:	2012      	movs	r0, #18
   101d4:	b004      	add	sp, #16
   101d6:	bd70      	pop	{r4, r5, r6, pc}
   101d8:	a903      	add	r1, sp, #12
   101da:	4630      	mov	r0, r6
   101dc:	f7fb f834 	bl	b248 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ>
   101e0:	e7f8      	b.n	101d4 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x50>
   101e2:	4630      	mov	r0, r6
   101e4:	f000 fc92 	bl	10b0c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2ea>
   101e8:	e7f4      	b.n	101d4 <sym_JU2KBYZVAT7EYGVZA4FU7TNK2PDUQNCWUBE5MWQ+0x50>

000101ea <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI>:
   101ea:	b530      	push	{r4, r5, lr}
   101ec:	b08b      	sub	sp, #44	; 0x2c
   101ee:	4604      	mov	r4, r0
   101f0:	f7fb f80c 	bl	b20c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x138>
   101f4:	4602      	mov	r2, r0
   101f6:	7920      	ldrb	r0, [r4, #4]
   101f8:	2804      	cmp	r0, #4
   101fa:	d803      	bhi.n	10204 <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI+0x1a>
   101fc:	8860      	ldrh	r0, [r4, #2]
   101fe:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
   10202:	d902      	bls.n	1020a <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI+0x20>
   10204:	2012      	movs	r0, #18
   10206:	b00b      	add	sp, #44	; 0x2c
   10208:	bd30      	pop	{r4, r5, pc}
   1020a:	2500      	movs	r5, #0
   1020c:	f88d 5004 	strb.w	r5, [sp, #4]
   10210:	7921      	ldrb	r1, [r4, #4]
   10212:	9500      	str	r5, [sp, #0]
   10214:	f89d 0000 	ldrb.w	r0, [sp]
   10218:	2905      	cmp	r1, #5
   1021a:	f040 0010 	orr.w	r0, r0, #16
   1021e:	f88d 0000 	strb.w	r0, [sp]
   10222:	d254      	bcs.n	102ce <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI+0xe4>
   10224:	e8df f001 	tbb	[pc, r1]
   10228:	11050803 	.word	0x11050803
   1022c:	000b      	.short	0x000b
   1022e:	f040 0001 	orr.w	r0, r0, #1
   10232:	f040 0002 	orr.w	r0, r0, #2
   10236:	e006      	b.n	10246 <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI+0x5c>
   10238:	f040 0009 	orr.w	r0, r0, #9
   1023c:	e001      	b.n	10242 <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI+0x58>
   1023e:	f040 0001 	orr.w	r0, r0, #1
   10242:	f040 0004 	orr.w	r0, r0, #4
   10246:	f88d 0000 	strb.w	r0, [sp]
   1024a:	f8bd 0000 	ldrh.w	r0, [sp]
   1024e:	9000      	str	r0, [sp, #0]
   10250:	f8bd 0000 	ldrh.w	r0, [sp]
   10254:	f8ad 0005 	strh.w	r0, [sp, #5]
   10258:	8821      	ldrh	r1, [r4, #0]
   1025a:	f8dd 0006 	ldr.w	r0, [sp, #6]
   1025e:	f361 201f 	bfi	r0, r1, #8, #24
   10262:	f8cd 0006 	str.w	r0, [sp, #6]
   10266:	8861      	ldrh	r1, [r4, #2]
   10268:	f8dd 0009 	ldr.w	r0, [sp, #9]
   1026c:	f361 201f 	bfi	r0, r1, #8, #24
   10270:	f8cd 0009 	str.w	r0, [sp, #9]
   10274:	7b60      	ldrb	r0, [r4, #13]
   10276:	f88d 000d 	strb.w	r0, [sp, #13]
   1027a:	7960      	ldrb	r0, [r4, #5]
   1027c:	f88d 000e 	strb.w	r0, [sp, #14]
   10280:	79a0      	ldrb	r0, [r4, #6]
   10282:	f88d 000f 	strb.w	r0, [sp, #15]
   10286:	f8d4 0007 	ldr.w	r0, [r4, #7]
   1028a:	9004      	str	r0, [sp, #16]
   1028c:	f8b4 000b 	ldrh.w	r0, [r4, #11]
   10290:	f8ad 0014 	strh.w	r0, [sp, #20]
   10294:	7ba0      	ldrb	r0, [r4, #14]
   10296:	f88d 0016 	strb.w	r0, [sp, #22]
   1029a:	207f      	movs	r0, #127	; 0x7f
   1029c:	f88d 0017 	strb.w	r0, [sp, #23]
   102a0:	2001      	movs	r0, #1
   102a2:	f88d 0018 	strb.w	r0, [sp, #24]
   102a6:	f88d 5019 	strb.w	r5, [sp, #25]
   102aa:	f88d 001a 	strb.w	r0, [sp, #26]
   102ae:	f88d 501b 	strb.w	r5, [sp, #27]
   102b2:	4610      	mov	r0, r2
   102b4:	f7ff f839 	bl	f32a <sym_2T6B57C7Z3NDT5ASKUJUGCCL3DBEO2AO4XX23BI>
   102b8:	f88d 001c 	strb.w	r0, [sp, #28]
   102bc:	f88d 501d 	strb.w	r5, [sp, #29]
   102c0:	f88d 501e 	strb.w	r5, [sp, #30]
   102c4:	a909      	add	r1, sp, #36	; 0x24
   102c6:	a801      	add	r0, sp, #4
   102c8:	f7fa fe7c 	bl	afc4 <sym_A32XXMQ5QRPQRH3R656RZXETZB6Y54SG45FSCYI>
   102cc:	e79b      	b.n	10206 <sym_CC522QK4M5MTSPVPJNGJXKYD5O54FC2LFC3D3QI+0x1c>
   102ce:	f241 01cf 	movw	r1, #4303	; 0x10cf
   102d2:	2039      	movs	r0, #57	; 0x39
   102d4:	f7f4 ff3e 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>

000102d8 <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II>:
   102d8:	b570      	push	{r4, r5, r6, lr}
   102da:	4604      	mov	r4, r0
   102dc:	7800      	ldrb	r0, [r0, #0]
   102de:	2101      	movs	r1, #1
   102e0:	f7fd fe83 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
   102e4:	0005      	movs	r5, r0
   102e6:	d007      	beq.n	102f8 <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II+0x20>
   102e8:	f7ff f9c5 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
   102ec:	b160      	cbz	r0, 10308 <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II+0x30>
   102ee:	4628      	mov	r0, r5
   102f0:	f7ff f805 	bl	f2fe <sym_NGJGZTNK6YIH3QX2NKB6A6MT7N5AOKWA6ZOOANQ>
   102f4:	b110      	cbz	r0, 102fc <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II+0x24>
   102f6:	e005      	b.n	10304 <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II+0x2c>
   102f8:	2042      	movs	r0, #66	; 0x42
   102fa:	bd70      	pop	{r4, r5, r6, pc}
   102fc:	4628      	mov	r0, r5
   102fe:	f7fe fff4 	bl	f2ea <sym_UEZ3FVWFJ5XVLQBVVAHW7UTXVCC77F7ZYGOMLTQ>
   10302:	b108      	cbz	r0, 10308 <sym_7GRSXPCDN6SAIPL3YJGWJFDEBFB3EXAXYUBY2II+0x30>
   10304:	200c      	movs	r0, #12
   10306:	bd70      	pop	{r4, r5, r6, pc}
   10308:	1c61      	adds	r1, r4, #1
   1030a:	4628      	mov	r0, r5
   1030c:	f7ff f805 	bl	f31a <sym_UDZCFPCYSG5E2MUJ3CH3H5GF4YJLF3Y6KNH3ZRQ>
   10310:	2000      	movs	r0, #0
   10312:	bd70      	pop	{r4, r5, r6, pc}

00010314 <sym_Q5GJELDUJDXPR5M7PG33JSPACOMZ32BYQV2DESA>:
   10314:	b50e      	push	{r1, r2, r3, lr}
   10316:	8882      	ldrh	r2, [r0, #4]
   10318:	f244 2390 	movw	r3, #17040	; 0x4290
   1031c:	429a      	cmp	r2, r3
   1031e:	d901      	bls.n	10324 <sym_Q5GJELDUJDXPR5M7PG33JSPACOMZ32BYQV2DESA+0x10>
   10320:	2012      	movs	r0, #18
   10322:	bd0e      	pop	{r1, r2, r3, pc}
   10324:	f640 0348 	movw	r3, #2120	; 0x848
   10328:	429a      	cmp	r2, r3
   1032a:	d300      	bcc.n	1032e <sym_Q5GJELDUJDXPR5M7PG33JSPACOMZ32BYQV2DESA+0x1a>
   1032c:	461a      	mov	r2, r3
   1032e:	8803      	ldrh	r3, [r0, #0]
   10330:	f8ad 3000 	strh.w	r3, [sp]
   10334:	8843      	ldrh	r3, [r0, #2]
   10336:	f8ad 3002 	strh.w	r3, [sp, #2]
   1033a:	f8ad 2004 	strh.w	r2, [sp, #4]
   1033e:	8843      	ldrh	r3, [r0, #2]
   10340:	f8ad 3006 	strh.w	r3, [sp, #6]
   10344:	f8ad 2008 	strh.w	r2, [sp, #8]
   10348:	8800      	ldrh	r0, [r0, #0]
   1034a:	8008      	strh	r0, [r1, #0]
   1034c:	4668      	mov	r0, sp
   1034e:	f7fb f84d 	bl	b3ec <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1a4>
   10352:	bd0e      	pop	{r1, r2, r3, pc}

00010354 <sym_MBHLAUPQK3H6ERLQXCLUB2AQHB6N7MDDZSUQGSI>:
   10354:	b53e      	push	{r1, r2, r3, r4, r5, lr}
   10356:	4604      	mov	r4, r0
   10358:	f10d 0007 	add.w	r0, sp, #7
   1035c:	9000      	str	r0, [sp, #0]
   1035e:	7922      	ldrb	r2, [r4, #4]
   10360:	78e1      	ldrb	r1, [r4, #3]
   10362:	78a0      	ldrb	r0, [r4, #2]
   10364:	f10d 0306 	add.w	r3, sp, #6
   10368:	f000 fbfd 	bl	10b66 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x344>
   1036c:	2800      	cmp	r0, #0
   1036e:	d109      	bne.n	10384 <sym_MBHLAUPQK3H6ERLQXCLUB2AQHB6N7MDDZSUQGSI+0x30>
   10370:	8820      	ldrh	r0, [r4, #0]
   10372:	f8ad 0004 	strh.w	r0, [sp, #4]
   10376:	f8b4 0005 	ldrh.w	r0, [r4, #5]
   1037a:	f8ad 0008 	strh.w	r0, [sp, #8]
   1037e:	a801      	add	r0, sp, #4
   10380:	f000 f937 	bl	105f2 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ>
   10384:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

00010386 <sym_NITRJIWYGM7PLEIQEII3QZID3O3DS62GXB3UYIA>:
   10386:	b510      	push	{r4, lr}
   10388:	4604      	mov	r4, r0
   1038a:	2001      	movs	r0, #1
   1038c:	f000 fa83 	bl	10896 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x74>
   10390:	b128      	cbz	r0, 1039e <sym_NITRJIWYGM7PLEIQEII3QZID3O3DS62GXB3UYIA+0x18>
   10392:	4621      	mov	r1, r4
   10394:	2001      	movs	r0, #1
   10396:	f7f5 fdab 	bl	5ef0 <sym_QKSVBALUN2V4XT4OCC56LE75IAYLDFRRIVLBZ2Q>
   1039a:	2000      	movs	r0, #0
   1039c:	bd10      	pop	{r4, pc}
   1039e:	200c      	movs	r0, #12
   103a0:	bd10      	pop	{r4, pc}

000103a2 <sym_XYKOVFYGOSL56Y753SKDQGINYTUFZGQJGBB54WI>:
   103a2:	b51c      	push	{r2, r3, r4, lr}
   103a4:	4604      	mov	r4, r0
   103a6:	f7fa ff31 	bl	b20c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x138>
   103aa:	2000      	movs	r0, #0
   103ac:	f88d 0000 	strb.w	r0, [sp]
   103b0:	f88d 0002 	strb.w	r0, [sp, #2]
   103b4:	2003      	movs	r0, #3
   103b6:	f88d 0001 	strb.w	r0, [sp, #1]
   103ba:	f814 0b01 	ldrb.w	r0, [r4], #1
   103be:	f88d 0003 	strb.w	r0, [sp, #3]
   103c2:	4668      	mov	r0, sp
   103c4:	9401      	str	r4, [sp, #4]
   103c6:	f000 f8c2 	bl	1054e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA>
   103ca:	bd1c      	pop	{r2, r3, r4, pc}

000103cc <sym_JYVNTINWWHBNIBW6ZPFJYFKZBQTI25EUE75U36Y>:
   103cc:	b51c      	push	{r2, r3, r4, lr}
   103ce:	8801      	ldrh	r1, [r0, #0]
   103d0:	f8ad 1000 	strh.w	r1, [sp]
   103d4:	8841      	ldrh	r1, [r0, #2]
   103d6:	f8ad 1002 	strh.w	r1, [sp, #2]
   103da:	8801      	ldrh	r1, [r0, #0]
   103dc:	f8ad 1004 	strh.w	r1, [sp, #4]
   103e0:	8840      	ldrh	r0, [r0, #2]
   103e2:	f8ad 0006 	strh.w	r0, [sp, #6]
   103e6:	4668      	mov	r0, sp
   103e8:	f7fb f884 	bl	b4f4 <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x2ac>
   103ec:	bd1c      	pop	{r2, r3, r4, pc}

000103ee <sym_2USEL6R2GGJMMFO4XRNC6NIEFTFUU2HPLL2Z6FQ>:
   103ee:	b510      	push	{r4, lr}
   103f0:	f7f5 fda2 	bl	5f38 <sym_4UMPVHCMNEM5ENBBHCLGXZREGEKKHKHZOKNMH2I>
   103f4:	2000      	movs	r0, #0
   103f6:	bd10      	pop	{r4, pc}

000103f8 <sym_HZRUCXEK6VH2SKHLITFSCAH5JZW3VUS5CZD2RBY>:
   103f8:	b510      	push	{r4, lr}
   103fa:	460c      	mov	r4, r1
   103fc:	2100      	movs	r1, #0
   103fe:	f7fd fdf4 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
   10402:	b118      	cbz	r0, 1040c <sym_HZRUCXEK6VH2SKHLITFSCAH5JZW3VUS5CZD2RBY+0x14>
   10404:	2c02      	cmp	r4, #2
   10406:	d903      	bls.n	10410 <sym_HZRUCXEK6VH2SKHLITFSCAH5JZW3VUS5CZD2RBY+0x18>
   10408:	2012      	movs	r0, #18
   1040a:	bd10      	pop	{r4, pc}
   1040c:	2002      	movs	r0, #2
   1040e:	bd10      	pop	{r4, pc}
   10410:	f014 0101 	ands.w	r1, r4, #1
   10414:	f880 11d5 	strb.w	r1, [r0, #469]	; 0x1d5
   10418:	f3c4 0240 	ubfx	r2, r4, #1, #1
   1041c:	f880 21d4 	strb.w	r2, [r0, #468]	; 0x1d4
   10420:	d004      	beq.n	1042c <sym_HZRUCXEK6VH2SKHLITFSCAH5JZW3VUS5CZD2RBY+0x34>
   10422:	f890 11d2 	ldrb.w	r1, [r0, #466]	; 0x1d2
   10426:	b109      	cbz	r1, 1042c <sym_HZRUCXEK6VH2SKHLITFSCAH5JZW3VUS5CZD2RBY+0x34>
   10428:	f7ff f93f 	bl	f6aa <sym_EPRPLWOAI3YMJ24HN6AZUGT5NWULVXEG6CTCI2Y>
   1042c:	2000      	movs	r0, #0
   1042e:	bd10      	pop	{r4, pc}

00010430 <sym_4DOGMDZGTALJPSDK26RDOFYJAUF2WWYUQSK5XNA>:
   10430:	b51c      	push	{r2, r3, r4, lr}
   10432:	460c      	mov	r4, r1
   10434:	4669      	mov	r1, sp
   10436:	f7fe f866 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   1043a:	2800      	cmp	r0, #0
   1043c:	d105      	bne.n	1044a <sym_4DOGMDZGTALJPSDK26RDOFYJAUF2WWYUQSK5XNA+0x1a>
   1043e:	2100      	movs	r1, #0
   10440:	4622      	mov	r2, r4
   10442:	9801      	ldr	r0, [sp, #4]
   10444:	f000 faf3 	bl	10a2e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x20c>
   10448:	2000      	movs	r0, #0
   1044a:	bd1c      	pop	{r2, r3, r4, pc}

0001044c <sym_4JSL5B25NNB5WWK7I5BGUTCTKEZ4HYLOODANEEQ>:
   1044c:	b510      	push	{r4, lr}
   1044e:	4604      	mov	r4, r0
   10450:	2000      	movs	r0, #0
   10452:	f000 fa20 	bl	10896 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x74>
   10456:	b128      	cbz	r0, 10464 <sym_4JSL5B25NNB5WWK7I5BGUTCTKEZ4HYLOODANEEQ+0x18>
   10458:	4621      	mov	r1, r4
   1045a:	2000      	movs	r0, #0
   1045c:	f7f5 fd48 	bl	5ef0 <sym_QKSVBALUN2V4XT4OCC56LE75IAYLDFRRIVLBZ2Q>
   10460:	2000      	movs	r0, #0
   10462:	bd10      	pop	{r4, pc}
   10464:	200c      	movs	r0, #12
   10466:	bd10      	pop	{r4, pc}

00010468 <sym_J2SUO2NMPPNDQZAGB2FE5TAXJFMJ5FZXKAPNVFQ>:
   10468:	b510      	push	{r4, lr}
   1046a:	7800      	ldrb	r0, [r0, #0]
   1046c:	b100      	cbz	r0, 10470 <sym_J2SUO2NMPPNDQZAGB2FE5TAXJFMJ5FZXKAPNVFQ+0x8>
   1046e:	2001      	movs	r0, #1
   10470:	f7f8 f8b4 	bl	85dc <sym_O6J3MUC4KJEDMNJLCC5Z3G5LTC5IHVL4PW7F6QI>
   10474:	2000      	movs	r0, #0
   10476:	bd10      	pop	{r4, pc}

00010478 <sym_M6MZU5PVUKHQMWMMC4UT23L7SRBW44JZLP26X4I>:
   10478:	f7fa bfb8 	b.w	b3ec <sym_P35ZNYRPUOIDHAE32RQYT4RWXL5RC6UIZKLHPUQ+0x1a4>

0001047c <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY>:
   1047c:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
   10480:	4606      	mov	r6, r0
   10482:	7845      	ldrb	r5, [r0, #1]
   10484:	7800      	ldrb	r0, [r0, #0]
   10486:	2101      	movs	r1, #1
   10488:	f7fd fdaf 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
   1048c:	0004      	movs	r4, r0
   1048e:	d01e      	beq.n	104ce <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x52>
   10490:	f7fe feba 	bl	f208 <sym_U7WTPI24N35WTMGPC25KDS7Q3PHHHS7M5KI6IPY>
   10494:	78f1      	ldrb	r1, [r6, #3]
   10496:	4281      	cmp	r1, r0
   10498:	d800      	bhi.n	1049c <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x20>
   1049a:	4608      	mov	r0, r1
   1049c:	4607      	mov	r7, r0
   1049e:	2d04      	cmp	r5, #4
   104a0:	d018      	beq.n	104d4 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x58>
   104a2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   104a4:	f7fd fefe 	bl	e2a4 <sym_DPFAWTOI3GRLXCS5TV5FXLZJNKWMRLYTLT4DRFY>
   104a8:	4438      	add	r0, r7
   104aa:	b281      	uxth	r1, r0
   104ac:	4620      	mov	r0, r4
   104ae:	2201      	movs	r2, #1
   104b0:	f000 fa03 	bl	108ba <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x98>
   104b4:	2800      	cmp	r0, #0
   104b6:	d10b      	bne.n	104d0 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x54>
   104b8:	2d03      	cmp	r5, #3
   104ba:	d000      	beq.n	104be <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x42>
   104bc:	b1df      	cbz	r7, 104f6 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7a>
   104be:	4620      	mov	r0, r4
   104c0:	f7fe ff1b 	bl	f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>
   104c4:	7871      	ldrb	r1, [r6, #1]
   104c6:	2903      	cmp	r1, #3
   104c8:	d010      	beq.n	104ec <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x70>
   104ca:	b9a0      	cbnz	r0, 104f6 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7a>
   104cc:	e004      	b.n	104d8 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x5c>
   104ce:	2042      	movs	r0, #66	; 0x42
   104d0:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
   104d4:	b97f      	cbnz	r7, 104f6 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7a>
   104d6:	e7f2      	b.n	104be <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x42>
   104d8:	2904      	cmp	r1, #4
   104da:	d107      	bne.n	104ec <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x70>
   104dc:	4620      	mov	r0, r4
   104de:	f7ff f8ca 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
   104e2:	b140      	cbz	r0, 104f6 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7a>
   104e4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   104e6:	f7fd feac 	bl	e242 <sym_Z3P3D5U3YDA66QTFRMTODYQPS5XZL7N2E3M2DIY>
   104ea:	b120      	cbz	r0, 104f6 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7a>
   104ec:	2d01      	cmp	r5, #1
   104ee:	d004      	beq.n	104fa <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7e>
   104f0:	2d03      	cmp	r5, #3
   104f2:	d002      	beq.n	104fa <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x7e>
   104f4:	e00e      	b.n	10514 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x98>
   104f6:	2012      	movs	r0, #18
   104f8:	e7ea      	b.n	104d0 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x54>
   104fa:	4620      	mov	r0, r4
   104fc:	f7fe fefd 	bl	f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>
   10500:	b108      	cbz	r0, 10506 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x8a>
   10502:	2200      	movs	r2, #0
   10504:	e002      	b.n	1050c <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x90>
   10506:	2d01      	cmp	r5, #1
   10508:	d013      	beq.n	10532 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0xb6>
   1050a:	2201      	movs	r2, #1
   1050c:	4668      	mov	r0, sp
   1050e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   10510:	f7fd fe2f 	bl	e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>
   10514:	2d04      	cmp	r5, #4
   10516:	d018      	beq.n	1054a <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0xce>
   10518:	6872      	ldr	r2, [r6, #4]
   1051a:	463b      	mov	r3, r7
   1051c:	2101      	movs	r1, #1
   1051e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   10520:	f7fd fe5b 	bl	e1da <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY>
   10524:	b138      	cbz	r0, 10536 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0xba>
   10526:	7870      	ldrb	r0, [r6, #1]
   10528:	2802      	cmp	r0, #2
   1052a:	d006      	beq.n	1053a <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0xbe>
   1052c:	2803      	cmp	r0, #3
   1052e:	d004      	beq.n	1053a <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0xbe>
   10530:	e00b      	b.n	1054a <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0xce>
   10532:	2202      	movs	r2, #2
   10534:	e7ea      	b.n	1050c <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x90>
   10536:	2007      	movs	r0, #7
   10538:	e7ca      	b.n	104d0 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x54>
   1053a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1053c:	f7fd feb2 	bl	e2a4 <sym_DPFAWTOI3GRLXCS5TV5FXLZJNKWMRLYTLT4DRFY>
   10540:	4602      	mov	r2, r0
   10542:	2101      	movs	r1, #1
   10544:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   10546:	f7fd fe8a 	bl	e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>
   1054a:	2000      	movs	r0, #0
   1054c:	e7c0      	b.n	104d0 <sym_D6Z72QTHOBKAEBKPZKUE4VJPVZJ36GAIUXFUHKY+0x54>

0001054e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA>:
   1054e:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
   10552:	4607      	mov	r7, r0
   10554:	7845      	ldrb	r5, [r0, #1]
   10556:	78c6      	ldrb	r6, [r0, #3]
   10558:	7800      	ldrb	r0, [r0, #0]
   1055a:	2101      	movs	r1, #1
   1055c:	f7fd fd45 	bl	dfea <sym_5X75WALYYBUWN4XT5LYOZBIGSZHVNFKF5J4CSQI>
   10560:	0004      	movs	r4, r0
   10562:	d003      	beq.n	1056c <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x1e>
   10564:	f7fe fecb 	bl	f2fe <sym_NGJGZTNK6YIH3QX2NKB6A6MT7N5AOKWA6ZOOANQ>
   10568:	b118      	cbz	r0, 10572 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x24>
   1056a:	e003      	b.n	10574 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x26>
   1056c:	2042      	movs	r0, #66	; 0x42
   1056e:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
   10572:	2600      	movs	r6, #0
   10574:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   10576:	f7fd fe99 	bl	e2ac <sym_27RZBWKBTESKUPVNN3E7RHYQU6UH4RT372SK2WA>
   1057a:	4430      	add	r0, r6
   1057c:	b281      	uxth	r1, r0
   1057e:	4688      	mov	r8, r1
   10580:	4620      	mov	r0, r4
   10582:	2201      	movs	r2, #1
   10584:	f000 f999 	bl	108ba <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x98>
   10588:	2800      	cmp	r0, #0
   1058a:	d1f0      	bne.n	1056e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x20>
   1058c:	2d04      	cmp	r5, #4
   1058e:	d008      	beq.n	105a2 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x54>
   10590:	2d03      	cmp	r5, #3
   10592:	d00a      	beq.n	105aa <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x5c>
   10594:	b12e      	cbz	r6, 105a2 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x54>
   10596:	4620      	mov	r0, r4
   10598:	f7ff f86d 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
   1059c:	b118      	cbz	r0, 105a6 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x58>
   1059e:	200c      	movs	r0, #12
   105a0:	e7e5      	b.n	1056e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x20>
   105a2:	2012      	movs	r0, #18
   105a4:	e7e3      	b.n	1056e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x20>
   105a6:	2d01      	cmp	r5, #1
   105a8:	d10c      	bne.n	105c4 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x76>
   105aa:	4620      	mov	r0, r4
   105ac:	f7fe fea5 	bl	f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>
   105b0:	b108      	cbz	r0, 105b6 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x68>
   105b2:	2204      	movs	r2, #4
   105b4:	e002      	b.n	105bc <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x6e>
   105b6:	2d01      	cmp	r5, #1
   105b8:	d010      	beq.n	105dc <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x8e>
   105ba:	2205      	movs	r2, #5
   105bc:	4668      	mov	r0, sp
   105be:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   105c0:	f7fd fdd7 	bl	e172 <sym_YBUOIVJGKD57C5J4XCQFOKF4I5XT74ICLDOCNXA>
   105c4:	687a      	ldr	r2, [r7, #4]
   105c6:	4633      	mov	r3, r6
   105c8:	2100      	movs	r1, #0
   105ca:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   105cc:	f7fd fe05 	bl	e1da <sym_F5SXUQLY6DFZ5NXKJ4VFIGAK52D6AM5LN2AJKSY>
   105d0:	b130      	cbz	r0, 105e0 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x92>
   105d2:	2d02      	cmp	r5, #2
   105d4:	d006      	beq.n	105e4 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x96>
   105d6:	2d03      	cmp	r5, #3
   105d8:	d004      	beq.n	105e4 <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x96>
   105da:	e008      	b.n	105ee <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0xa0>
   105dc:	2206      	movs	r2, #6
   105de:	e7ed      	b.n	105bc <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x6e>
   105e0:	2007      	movs	r0, #7
   105e2:	e7c4      	b.n	1056e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x20>
   105e4:	4642      	mov	r2, r8
   105e6:	2100      	movs	r1, #0
   105e8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   105ea:	f7fd fe38 	bl	e25e <sym_OC5GPSERLPE7TKXSCU3QAZ62H3OM4MWFYV7WX2I>
   105ee:	2000      	movs	r0, #0
   105f0:	e7bd      	b.n	1056e <sym_MVDV5RBWBEZV6THUS3WDA3RV4H6NH2D4IESH3IA+0x20>

000105f2 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ>:
   105f2:	b510      	push	{r4, lr}
   105f4:	4604      	mov	r4, r0
   105f6:	8880      	ldrh	r0, [r0, #4]
   105f8:	b128      	cbz	r0, 10606 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ+0x14>
   105fa:	2801      	cmp	r0, #1
   105fc:	d003      	beq.n	10606 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ+0x14>
   105fe:	2802      	cmp	r0, #2
   10600:	d001      	beq.n	10606 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ+0x14>
   10602:	2012      	movs	r0, #18
   10604:	bd10      	pop	{r4, pc}
   10606:	78e0      	ldrb	r0, [r4, #3]
   10608:	f000 f9ee 	bl	109e8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1c6>
   1060c:	b148      	cbz	r0, 10622 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ+0x30>
   1060e:	78a0      	ldrb	r0, [r4, #2]
   10610:	f000 f9ea 	bl	109e8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1c6>
   10614:	b128      	cbz	r0, 10622 <sym_TWSXGABZDFOR6GMTPL43NA2Q7GCJDL7RARUHBMQ+0x30>
   10616:	4620      	mov	r0, r4
   10618:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1061c:	2101      	movs	r1, #1
   1061e:	f000 b890 	b.w	10742 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ>
   10622:	2011      	movs	r0, #17
   10624:	bd10      	pop	{r4, pc}

00010626 <sym_AB3LPEZLZTHWVJYT4X3CSIX3UJONE76BJDZFP2Y>:
   10626:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   10628:	460c      	mov	r4, r1
   1062a:	4605      	mov	r5, r0
   1062c:	8800      	ldrh	r0, [r0, #0]
   1062e:	4669      	mov	r1, sp
   10630:	f7fd ff69 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   10634:	2800      	cmp	r0, #0
   10636:	d106      	bne.n	10646 <sym_AB3LPEZLZTHWVJYT4X3CSIX3UJONE76BJDZFP2Y+0x20>
   10638:	9801      	ldr	r0, [sp, #4]
   1063a:	8829      	ldrh	r1, [r5, #0]
   1063c:	8021      	strh	r1, [r4, #0]
   1063e:	f8b0 00b0 	ldrh.w	r0, [r0, #176]	; 0xb0
   10642:	8060      	strh	r0, [r4, #2]
   10644:	2000      	movs	r0, #0
   10646:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}

00010648 <sym_5KZ3ESY4NUZKM5COQRZJAL6CXWIG2JSPGHV3RPQ>:
   10648:	b510      	push	{r4, lr}
   1064a:	4604      	mov	r4, r0
   1064c:	4601      	mov	r1, r0
   1064e:	2000      	movs	r0, #0
   10650:	f7f5 fc36 	bl	5ec0 <sym_WCOWXKSKBH7DOKKKINFZAPWXKW4NYAUCJWTUKBI>
   10654:	b910      	cbnz	r0, 1065c <sym_5KZ3ESY4NUZKM5COQRZJAL6CXWIG2JSPGHV3RPQ+0x14>
   10656:	2000      	movs	r0, #0
   10658:	6020      	str	r0, [r4, #0]
   1065a:	80a0      	strh	r0, [r4, #4]
   1065c:	2000      	movs	r0, #0
   1065e:	bd10      	pop	{r4, pc}

00010660 <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY>:
   10660:	b50e      	push	{r1, r2, r3, lr}
   10662:	8800      	ldrh	r0, [r0, #0]
   10664:	4669      	mov	r1, sp
   10666:	f7fd ff4e 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   1066a:	b960      	cbnz	r0, 10686 <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x26>
   1066c:	9801      	ldr	r0, [sp, #4]
   1066e:	f000 fa37 	bl	10ae0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2be>
   10672:	b140      	cbz	r0, 10686 <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x26>
   10674:	9801      	ldr	r0, [sp, #4]
   10676:	4601      	mov	r1, r0
   10678:	f890 212a 	ldrb.w	r2, [r0, #298]	; 0x12a
   1067c:	3078      	adds	r0, #120	; 0x78
   1067e:	f501 7195 	add.w	r1, r1, #298	; 0x12a
   10682:	b962      	cbnz	r2, 1069e <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x3e>
   10684:	e001      	b.n	1068a <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x2a>
   10686:	2002      	movs	r0, #2
   10688:	bd0e      	pop	{r1, r2, r3, pc}
   1068a:	f890 2056 	ldrb.w	r2, [r0, #86]	; 0x56
   1068e:	f88d 2008 	strb.w	r2, [sp, #8]
   10692:	9a02      	ldr	r2, [sp, #8]
   10694:	9202      	str	r2, [sp, #8]
   10696:	f89d 3008 	ldrb.w	r3, [sp, #8]
   1069a:	2201      	movs	r2, #1
   1069c:	b10b      	cbz	r3, 106a2 <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x42>
   1069e:	203a      	movs	r0, #58	; 0x3a
   106a0:	bd0e      	pop	{r1, r2, r3, pc}
   106a2:	f890 304d 	ldrb.w	r3, [r0, #77]	; 0x4d
   106a6:	079b      	lsls	r3, r3, #30
   106a8:	d008      	beq.n	106bc <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x5c>
   106aa:	2201      	movs	r2, #1
   106ac:	304e      	adds	r0, #78	; 0x4e
   106ae:	9901      	ldr	r1, [sp, #4]
   106b0:	f7f6 fd78 	bl	71a4 <sym_6DHRDOLEPQTXUFSZA5GRCPOYB3PIRRWQJXE2LLA>
   106b4:	f7f6 fe48 	bl	7348 <sym_ZGH42ABHAQFX3NKIMGIK7DGGJ5XWXU2KDVYEOMI>
   106b8:	2000      	movs	r0, #0
   106ba:	bd0e      	pop	{r1, r2, r3, pc}
   106bc:	700a      	strb	r2, [r1, #0]
   106be:	4668      	mov	r0, sp
   106c0:	f7fe fae0 	bl	ec84 <sym_24AALTDC2IQ6VNWU2ALOY4V3RG5R2RARTUG4AZY>
   106c4:	e7f8      	b.n	106b8 <sym_IP3LLUNJTDBIIPB3UG65MJFJZABGVNT2GN3EQPY+0x58>

000106c6 <sym_Q3C2XSZVED7JHVMCJN53G6AXVXF3ZOUR7A37OEQ>:
   106c6:	b57c      	push	{r2, r3, r4, r5, r6, lr}
   106c8:	460c      	mov	r4, r1
   106ca:	4605      	mov	r5, r0
   106cc:	8800      	ldrh	r0, [r0, #0]
   106ce:	4669      	mov	r1, sp
   106d0:	f7fd ff19 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   106d4:	b108      	cbz	r0, 106da <sym_Q3C2XSZVED7JHVMCJN53G6AXVXF3ZOUR7A37OEQ+0x14>
   106d6:	2002      	movs	r0, #2
   106d8:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
   106da:	78a8      	ldrb	r0, [r5, #2]
   106dc:	b130      	cbz	r0, 106ec <sym_Q3C2XSZVED7JHVMCJN53G6AXVXF3ZOUR7A37OEQ+0x26>
   106de:	f000 f9fc 	bl	10ada <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b8>
   106e2:	70a0      	strb	r0, [r4, #2]
   106e4:	8828      	ldrh	r0, [r5, #0]
   106e6:	8020      	strh	r0, [r4, #0]
   106e8:	2000      	movs	r0, #0
   106ea:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
   106ec:	9801      	ldr	r0, [sp, #4]
   106ee:	f890 0072 	ldrb.w	r0, [r0, #114]	; 0x72
   106f2:	e7f6      	b.n	106e2 <sym_Q3C2XSZVED7JHVMCJN53G6AXVXF3ZOUR7A37OEQ+0x1c>

000106f4 <sym_QA2HTUWXDQAGJZ32BSTQMVSMKKNETZBUHL37LYA>:
   106f4:	b510      	push	{r4, lr}
   106f6:	f7fa ff2d 	bl	b554 <sym_4W26TPGCKOCVVRKXQDBKGXGC2Y5LMZXNKS2QITA>
   106fa:	2000      	movs	r0, #0
   106fc:	bd10      	pop	{r4, pc}

000106fe <sym_ULWM63O6UPJLQWAHX3MM6KEQT4NBSDWNEO3LSBY>:
   106fe:	e92d 41fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, lr}
   10702:	4604      	mov	r4, r0
   10704:	8840      	ldrh	r0, [r0, #2]
   10706:	460d      	mov	r5, r1
   10708:	b1b8      	cbz	r0, 1073a <sym_ULWM63O6UPJLQWAHX3MM6KEQT4NBSDWNEO3LSBY+0x3c>
   1070a:	8820      	ldrh	r0, [r4, #0]
   1070c:	4669      	mov	r1, sp
   1070e:	f7fd fefa 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   10712:	2800      	cmp	r0, #0
   10714:	d10f      	bne.n	10736 <sym_ULWM63O6UPJLQWAHX3MM6KEQT4NBSDWNEO3LSBY+0x38>
   10716:	8820      	ldrh	r0, [r4, #0]
   10718:	8028      	strh	r0, [r5, #0]
   1071a:	9e01      	ldr	r6, [sp, #4]
   1071c:	f106 0510 	add.w	r5, r6, #16
   10720:	3678      	adds	r6, #120	; 0x78
   10722:	682f      	ldr	r7, [r5, #0]
   10724:	8862      	ldrh	r2, [r4, #2]
   10726:	4639      	mov	r1, r7
   10728:	4630      	mov	r0, r6
   1072a:	f7fe f83b 	bl	e7a4 <sym_3LQGLF52CJLOKQOJSNFVLTD3CW6GGPJMARVGQNQ>
   1072e:	6828      	ldr	r0, [r5, #0]
   10730:	42b8      	cmp	r0, r7
   10732:	d1f6      	bne.n	10722 <sym_ULWM63O6UPJLQWAHX3MM6KEQT4NBSDWNEO3LSBY+0x24>
   10734:	2000      	movs	r0, #0
   10736:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
   1073a:	2012      	movs	r0, #18
   1073c:	e7fb      	b.n	10736 <sym_ULWM63O6UPJLQWAHX3MM6KEQT4NBSDWNEO3LSBY+0x38>

0001073e <sym_5EMU3BEOS6JCQEXTZ5M5LP72YGJNCV3W3R43AOI>:
   1073e:	f000 b863 	b.w	10808 <sym_RGKYP5TXYS27EGT6ZHZS5EDDAZK5QGTWLBOBJEA>

00010742 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ>:
   10742:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10746:	b086      	sub	sp, #24
   10748:	4689      	mov	r9, r1
   1074a:	4607      	mov	r7, r0
   1074c:	8800      	ldrh	r0, [r0, #0]
   1074e:	a901      	add	r1, sp, #4
   10750:	f7fd fed9 	bl	e506 <sym_UHWWEFDYCEMO6BV2Q3GVLMFC37EIDJEWGQC2XUA>
   10754:	2800      	cmp	r0, #0
   10756:	d136      	bne.n	107c6 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x84>
   10758:	9802      	ldr	r0, [sp, #8]
   1075a:	4601      	mov	r1, r0
   1075c:	4688      	mov	r8, r1
   1075e:	f890 1176 	ldrb.w	r1, [r0, #374]	; 0x176
   10762:	f500 748c 	add.w	r4, r0, #280	; 0x118
   10766:	f88d 1000 	strb.w	r1, [sp]
   1076a:	9900      	ldr	r1, [sp, #0]
   1076c:	9100      	str	r1, [sp, #0]
   1076e:	f89d 1000 	ldrb.w	r1, [sp]
   10772:	3078      	adds	r0, #120	; 0x78
   10774:	b109      	cbz	r1, 1077a <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x38>
   10776:	2601      	movs	r6, #1
   10778:	e000      	b.n	1077c <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x3a>
   1077a:	2600      	movs	r6, #0
   1077c:	7b81      	ldrb	r1, [r0, #14]
   1077e:	2921      	cmp	r1, #33	; 0x21
   10780:	d100      	bne.n	10784 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x42>
   10782:	b13e      	cbz	r6, 10794 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x52>
   10784:	2500      	movs	r5, #0
   10786:	305c      	adds	r0, #92	; 0x5c
   10788:	2108      	movs	r1, #8
   1078a:	4682      	mov	sl, r0
   1078c:	f7ff fbc4 	bl	ff18 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x88>
   10790:	b110      	cbz	r0, 10798 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x56>
   10792:	e007      	b.n	107a4 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x62>
   10794:	2501      	movs	r5, #1
   10796:	e7f6      	b.n	10786 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x44>
   10798:	210b      	movs	r1, #11
   1079a:	4650      	mov	r0, sl
   1079c:	f7ff fbbc 	bl	ff18 <sym_IYZQNCOB4T4XO27DREWRIWJFVHVS355NEDBEGEQ+0x88>
   107a0:	b900      	cbnz	r0, 107a4 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x62>
   107a2:	b17d      	cbz	r5, 107c4 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x82>
   107a4:	a804      	add	r0, sp, #16
   107a6:	9000      	str	r0, [sp, #0]
   107a8:	f89d 0004 	ldrb.w	r0, [sp, #4]
   107ac:	ab03      	add	r3, sp, #12
   107ae:	463a      	mov	r2, r7
   107b0:	4641      	mov	r1, r8
   107b2:	f000 f972 	bl	10a9a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x278>
   107b6:	0005      	movs	r5, r0
   107b8:	d105      	bne.n	107c6 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x84>
   107ba:	340c      	adds	r4, #12
   107bc:	20ff      	movs	r0, #255	; 0xff
   107be:	7060      	strb	r0, [r4, #1]
   107c0:	b936      	cbnz	r6, 107d0 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x8e>
   107c2:	e003      	b.n	107cc <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x8a>
   107c4:	201a      	movs	r0, #26
   107c6:	b006      	add	sp, #24
   107c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   107cc:	7820      	ldrb	r0, [r4, #0]
   107ce:	b108      	cbz	r0, 107d4 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x92>
   107d0:	253a      	movs	r5, #58	; 0x3a
   107d2:	e012      	b.n	107fa <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0xb8>
   107d4:	f884 9000 	strb.w	r9, [r4]
   107d8:	f89d 000c 	ldrb.w	r0, [sp, #12]
   107dc:	70a0      	strb	r0, [r4, #2]
   107de:	f89d 1010 	ldrb.w	r1, [sp, #16]
   107e2:	70e1      	strb	r1, [r4, #3]
   107e4:	f88d 0000 	strb.w	r0, [sp]
   107e8:	f88d 1001 	strb.w	r1, [sp, #1]
   107ec:	88b8      	ldrh	r0, [r7, #4]
   107ee:	f8ad 0002 	strh.w	r0, [sp, #2]
   107f2:	4669      	mov	r1, sp
   107f4:	4640      	mov	r0, r8
   107f6:	f7fd ff46 	bl	e686 <sym_6NROXJNXJONASXBRH4ZGPEEQ42PSH3YLRTC74GQ>
   107fa:	2000      	movs	r0, #0
   107fc:	7060      	strb	r0, [r4, #1]
   107fe:	4628      	mov	r0, r5
   10800:	e7e1      	b.n	107c6 <sym_TTWYMXRKLVLI7DIZYVTKGZHSGKFWB63OVH3AYYQ+0x84>

00010802 <sym_266BMVQDBLXULMLATXWWN2P23YFP57RBL2ZNQ7A>:
   10802:	2008      	movs	r0, #8
   10804:	f7fa bf0c 	b.w	b620 <sym_N6TOG3AODPPFNS6LXFKKIADNGIMUMBS5BXPEFOY>

00010808 <sym_RGKYP5TXYS27EGT6ZHZS5EDDAZK5QGTWLBOBJEA>:
   10808:	b510      	push	{r4, lr}
   1080a:	f7fd fddf 	bl	e3cc <sym_BGPX36PUCNVPV3544HQ5RQFY5WG7CJAFVVBI7AY>
   1080e:	f7f6 f947 	bl	6aa0 <sym_62DUXM4M5AM4URNPP7IKDX3NCPAODBT4BMADGAY>
   10812:	f7fa ff27 	bl	b664 <sym_MJMICEV3AHUJUDNI6JLXYNXCJNL4PTPUQLXISYA>
   10816:	f7fe fa9f 	bl	ed58 <sym_5G7NLKZS4L5IIOBRUSBNVX2FPWE5MWDV7ZI2IXQ>
   1081a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1081e:	f7fa bcd3 	b.w	b1c8 <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0xf4>

00010822 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA>:
   10822:	f7f8 bb25 	b.w	8e70 <sym_B2B7AU2WDMX5JQNGTX4YKNCWQCXQIG5PWSSOSAI>
   10826:	f44f 71a4 	mov.w	r1, #328	; 0x148
   1082a:	4288      	cmp	r0, r1
   1082c:	d303      	bcc.n	10836 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x14>
   1082e:	f640 0148 	movw	r1, #2120	; 0x848
   10832:	4288      	cmp	r0, r1
   10834:	d300      	bcc.n	10838 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x16>
   10836:	4608      	mov	r0, r1
   10838:	b280      	uxth	r0, r0
   1083a:	4770      	bx	lr
   1083c:	07c1      	lsls	r1, r0, #31
   1083e:	d001      	beq.n	10844 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x22>
   10840:	2001      	movs	r0, #1
   10842:	4770      	bx	lr
   10844:	0780      	lsls	r0, r0, #30
   10846:	d501      	bpl.n	1084c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2a>
   10848:	2002      	movs	r0, #2
   1084a:	4770      	bx	lr
   1084c:	2000      	movs	r0, #0
   1084e:	4770      	bx	lr
   10850:	b510      	push	{r4, lr}
   10852:	2801      	cmp	r0, #1
   10854:	d006      	beq.n	10864 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x42>
   10856:	2802      	cmp	r0, #2
   10858:	d004      	beq.n	10864 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x42>
   1085a:	f240 21a9 	movw	r1, #681	; 0x2a9
   1085e:	2006      	movs	r0, #6
   10860:	f7f4 fc78 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10864:	bd10      	pop	{r4, pc}
   10866:	b50e      	push	{r1, r2, r3, lr}
   10868:	4669      	mov	r1, sp
   1086a:	2001      	movs	r0, #1
   1086c:	f7fd fbc7 	bl	dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>
   10870:	b150      	cbz	r0, 10888 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x66>
   10872:	f44f 71a3 	mov.w	r1, #326	; 0x146
   10876:	2039      	movs	r0, #57	; 0x39
   10878:	f7f4 fc6c 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   1087c:	9802      	ldr	r0, [sp, #8]
   1087e:	f7fe fefa 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
   10882:	b108      	cbz	r0, 10888 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x66>
   10884:	2001      	movs	r0, #1
   10886:	bd0e      	pop	{r1, r2, r3, pc}
   10888:	4668      	mov	r0, sp
   1088a:	f7f4 fea7 	bl	55dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>
   1088e:	2800      	cmp	r0, #0
   10890:	d0f4      	beq.n	1087c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x5a>
   10892:	2000      	movs	r0, #0
   10894:	bd0e      	pop	{r1, r2, r3, pc}
   10896:	b510      	push	{r4, lr}
   10898:	f7ff ffe5 	bl	10866 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x44>
   1089c:	b158      	cbz	r0, 108b6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x94>
   1089e:	f7fa fcb5 	bl	b20c <sym_PT2LT65JTEWXEGBFKFJG6BCMFVOJAD3UAGCYAUI+0x138>
   108a2:	4604      	mov	r4, r0
   108a4:	f7fe fd2b 	bl	f2fe <sym_NGJGZTNK6YIH3QX2NKB6A6MT7N5AOKWA6ZOOANQ>
   108a8:	b918      	cbnz	r0, 108b2 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x90>
   108aa:	4620      	mov	r0, r4
   108ac:	f7fe fd1d 	bl	f2ea <sym_UEZ3FVWFJ5XVLQBVVAHW7UTXVCC77F7ZYGOMLTQ>
   108b0:	b108      	cbz	r0, 108b6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x94>
   108b2:	2000      	movs	r0, #0
   108b4:	bd10      	pop	{r4, pc}
   108b6:	2001      	movs	r0, #1
   108b8:	bd10      	pop	{r4, pc}
   108ba:	b570      	push	{r4, r5, r6, lr}
   108bc:	460c      	mov	r4, r1
   108be:	4605      	mov	r5, r0
   108c0:	b112      	cbz	r2, 108c8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xa6>
   108c2:	291f      	cmp	r1, #31
   108c4:	d80c      	bhi.n	108e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xbe>
   108c6:	e016      	b.n	108f6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xd4>
   108c8:	f7f5 f952 	bl	5b70 <sym_LD2UWOJIHNEPQLGRHPDQLYGR7RM2YL5X5777QYQ>
   108cc:	42a0      	cmp	r0, r4
   108ce:	d201      	bcs.n	108d4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xb2>
   108d0:	2007      	movs	r0, #7
   108d2:	bd70      	pop	{r4, r5, r6, pc}
   108d4:	4628      	mov	r0, r5
   108d6:	f7fe fd10 	bl	f2fa <sym_BDDELQSYWHVCCHSF6HGFFAORZOC56R54KIF45KY>
   108da:	b118      	cbz	r0, 108e4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xc2>
   108dc:	2c1f      	cmp	r4, #31
   108de:	d901      	bls.n	108e4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xc2>
   108e0:	2012      	movs	r0, #18
   108e2:	bd70      	pop	{r4, r5, r6, pc}
   108e4:	4628      	mov	r0, r5
   108e6:	f7fe fd11 	bl	f30c <sym_WGJLFS2PDN6RZG7JWUITZ3W5MGJYYXFXIKI3GGQ>
   108ea:	b130      	cbz	r0, 108fa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xd8>
   108ec:	4621      	mov	r1, r4
   108ee:	4628      	mov	r0, r5
   108f0:	f7fe fcd8 	bl	f2a4 <sym_GNUIHYMK3THJZQYGL7BBI74HDMHN6SBQQRVNSAY>
   108f4:	b118      	cbz	r0, 108fe <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0xdc>
   108f6:	2000      	movs	r0, #0
   108f8:	bd70      	pop	{r4, r5, r6, pc}
   108fa:	2042      	movs	r0, #66	; 0x42
   108fc:	bd70      	pop	{r4, r5, r6, pc}
   108fe:	2045      	movs	r0, #69	; 0x45
   10900:	bd70      	pop	{r4, r5, r6, pc}
   10902:	b510      	push	{r4, lr}
   10904:	4604      	mov	r4, r0
   10906:	7840      	ldrb	r0, [r0, #1]
   10908:	06c1      	lsls	r1, r0, #27
   1090a:	d51c      	bpl.n	10946 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x124>
   1090c:	07c0      	lsls	r0, r0, #31
   1090e:	d00b      	beq.n	10928 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x106>
   10910:	f7fa fe5a 	bl	b5c8 <sym_PRWTRTI5GPQHIT26MFBSSOCWTUYYRLQLJWD2ZOI>
   10914:	b1b8      	cbz	r0, 10946 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x124>
   10916:	7860      	ldrb	r0, [r4, #1]
   10918:	06c1      	lsls	r1, r0, #27
   1091a:	d405      	bmi.n	10928 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x106>
   1091c:	0700      	lsls	r0, r0, #28
   1091e:	d503      	bpl.n	10928 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x106>
   10920:	7d20      	ldrb	r0, [r4, #20]
   10922:	2802      	cmp	r0, #2
   10924:	d10f      	bne.n	10946 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x124>
   10926:	e010      	b.n	1094a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x128>
   10928:	7d20      	ldrb	r0, [r4, #20]
   1092a:	2802      	cmp	r0, #2
   1092c:	d001      	beq.n	10932 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x110>
   1092e:	7ea0      	ldrb	r0, [r4, #26]
   10930:	b948      	cbnz	r0, 10946 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x124>
   10932:	7860      	ldrb	r0, [r4, #1]
   10934:	0700      	lsls	r0, r0, #28
   10936:	d408      	bmi.n	1094a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x128>
   10938:	f8d4 0005 	ldr.w	r0, [r4, #5]
   1093c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   10940:	ebb1 2f10 	cmp.w	r1, r0, lsr #8
   10944:	d201      	bcs.n	1094a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x128>
   10946:	2011      	movs	r0, #17
   10948:	bd10      	pop	{r4, pc}
   1094a:	2000      	movs	r0, #0
   1094c:	bd10      	pop	{r4, pc}
   1094e:	b538      	push	{r3, r4, r5, lr}
   10950:	4604      	mov	r4, r0
   10952:	7800      	ldrb	r0, [r0, #0]
   10954:	28ef      	cmp	r0, #239	; 0xef
   10956:	d843      	bhi.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   10958:	f8b4 0001 	ldrh.w	r0, [r4, #1]
   1095c:	f8ad 0000 	strh.w	r0, [sp]
   10960:	9800      	ldr	r0, [sp, #0]
   10962:	f000 f917 	bl	10b94 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x372>
   10966:	b3a0      	cbz	r0, 109d2 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1b0>
   10968:	7861      	ldrb	r1, [r4, #1]
   1096a:	0708      	lsls	r0, r1, #28
   1096c:	d40b      	bmi.n	10986 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x164>
   1096e:	f8d4 0002 	ldr.w	r0, [r4, #2]
   10972:	f8d4 3005 	ldr.w	r3, [r4, #5]
   10976:	0a02      	lsrs	r2, r0, #8
   10978:	ebb2 2f13 	cmp.w	r2, r3, lsr #8
   1097c:	d830      	bhi.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   1097e:	2220      	movs	r2, #32
   10980:	ebb2 2f10 	cmp.w	r2, r0, lsr #8
   10984:	d82c      	bhi.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   10986:	7a60      	ldrb	r0, [r4, #9]
   10988:	b318      	cbz	r0, 109d2 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1b0>
   1098a:	2807      	cmp	r0, #7
   1098c:	d828      	bhi.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   1098e:	7aa0      	ldrb	r0, [r4, #10]
   10990:	b128      	cbz	r0, 1099e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x17c>
   10992:	2801      	cmp	r0, #1
   10994:	d003      	beq.n	1099e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x17c>
   10996:	2802      	cmp	r0, #2
   10998:	d001      	beq.n	1099e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x17c>
   1099a:	2803      	cmp	r0, #3
   1099c:	d120      	bne.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   1099e:	074a      	lsls	r2, r1, #29
   109a0:	d403      	bmi.n	109aa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x188>
   109a2:	2802      	cmp	r0, #2
   109a4:	d001      	beq.n	109aa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x188>
   109a6:	2803      	cmp	r0, #3
   109a8:	d105      	bne.n	109b6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x194>
   109aa:	7ae0      	ldrb	r0, [r4, #11]
   109ac:	b108      	cbz	r0, 109b2 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x190>
   109ae:	2801      	cmp	r0, #1
   109b0:	d116      	bne.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   109b2:	0748      	lsls	r0, r1, #29
   109b4:	d407      	bmi.n	109c6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1a4>
   109b6:	7ca0      	ldrb	r0, [r4, #18]
   109b8:	b128      	cbz	r0, 109c6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1a4>
   109ba:	2801      	cmp	r0, #1
   109bc:	d003      	beq.n	109c6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1a4>
   109be:	2802      	cmp	r0, #2
   109c0:	d001      	beq.n	109c6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1a4>
   109c2:	2803      	cmp	r0, #3
   109c4:	d10c      	bne.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   109c6:	06c8      	lsls	r0, r1, #27
   109c8:	7d20      	ldrb	r0, [r4, #20]
   109ca:	d503      	bpl.n	109d4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1b2>
   109cc:	2801      	cmp	r0, #1
   109ce:	d107      	bne.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   109d0:	e002      	b.n	109d8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1b6>
   109d2:	e005      	b.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   109d4:	2802      	cmp	r0, #2
   109d6:	d003      	beq.n	109e0 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1be>
   109d8:	7e20      	ldrb	r0, [r4, #24]
   109da:	b118      	cbz	r0, 109e4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1c2>
   109dc:	2801      	cmp	r0, #1
   109de:	d001      	beq.n	109e4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1c2>
   109e0:	2012      	movs	r0, #18
   109e2:	bd38      	pop	{r3, r4, r5, pc}
   109e4:	2000      	movs	r0, #0
   109e6:	bd38      	pop	{r3, r4, r5, pc}
   109e8:	b510      	push	{r4, lr}
   109ea:	0004      	movs	r4, r0
   109ec:	d005      	beq.n	109fa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1d8>
   109ee:	f7fa fe29 	bl	b644 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ>
   109f2:	4384      	bics	r4, r0
   109f4:	d001      	beq.n	109fa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1d8>
   109f6:	2000      	movs	r0, #0
   109f8:	bd10      	pop	{r4, pc}
   109fa:	2001      	movs	r0, #1
   109fc:	bd10      	pop	{r4, pc}
   109fe:	28fb      	cmp	r0, #251	; 0xfb
   10a00:	d803      	bhi.n	10a0a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1e8>
   10a02:	f640 0048 	movw	r0, #2120	; 0x848
   10a06:	4281      	cmp	r1, r0
   10a08:	d901      	bls.n	10a0e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1ec>
   10a0a:	2011      	movs	r0, #17
   10a0c:	4770      	bx	lr
   10a0e:	2000      	movs	r0, #0
   10a10:	4770      	bx	lr
   10a12:	381b      	subs	r0, #27
   10a14:	28e1      	cmp	r0, #225	; 0xe1
   10a16:	d206      	bcs.n	10a26 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x204>
   10a18:	f5b1 7fa4 	cmp.w	r1, #328	; 0x148
   10a1c:	d303      	bcc.n	10a26 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x204>
   10a1e:	f244 2090 	movw	r0, #17040	; 0x4290
   10a22:	4281      	cmp	r1, r0
   10a24:	d901      	bls.n	10a2a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x208>
   10a26:	2012      	movs	r0, #18
   10a28:	4770      	bx	lr
   10a2a:	2000      	movs	r0, #0
   10a2c:	4770      	bx	lr
   10a2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10a32:	4606      	mov	r6, r0
   10a34:	f8b0 7056 	ldrh.w	r7, [r0, #86]	; 0x56
   10a38:	f8b0 4058 	ldrh.w	r4, [r0, #88]	; 0x58
   10a3c:	4615      	mov	r5, r2
   10a3e:	3030      	adds	r0, #48	; 0x30
   10a40:	f7f7 fdd2 	bl	85e8 <sym_VZU4MLS2BZIZVCMAEOYQRASTSKMJXHSO6FAK2JA>
   10a44:	4680      	mov	r8, r0
   10a46:	2102      	movs	r1, #2
   10a48:	f7fd fded 	bl	e626 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y>
   10a4c:	4287      	cmp	r7, r0
   10a4e:	d200      	bcs.n	10a52 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x230>
   10a50:	4638      	mov	r0, r7
   10a52:	4607      	mov	r7, r0
   10a54:	2102      	movs	r1, #2
   10a56:	4640      	mov	r0, r8
   10a58:	f7fd fde5 	bl	e626 <sym_CMGYAOMYUJOSH7VMLD3ENK3VLSIPR3DVYN2F44Y>
   10a5c:	4284      	cmp	r4, r0
   10a5e:	d200      	bcs.n	10a62 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x240>
   10a60:	4620      	mov	r0, r4
   10a62:	8831      	ldrh	r1, [r6, #0]
   10a64:	8029      	strh	r1, [r5, #0]
   10a66:	2f1b      	cmp	r7, #27
   10a68:	d913      	bls.n	10a92 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x270>
   10a6a:	2ffb      	cmp	r7, #251	; 0xfb
   10a6c:	d300      	bcc.n	10a70 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x24e>
   10a6e:	27fb      	movs	r7, #251	; 0xfb
   10a70:	806f      	strh	r7, [r5, #2]
   10a72:	281b      	cmp	r0, #27
   10a74:	d90f      	bls.n	10a96 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x274>
   10a76:	28fb      	cmp	r0, #251	; 0xfb
   10a78:	d300      	bcc.n	10a7c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x25a>
   10a7a:	20fb      	movs	r0, #251	; 0xfb
   10a7c:	80e8      	strh	r0, [r5, #6]
   10a7e:	4640      	mov	r0, r8
   10a80:	f7ff fed1 	bl	10826 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x4>
   10a84:	80a8      	strh	r0, [r5, #4]
   10a86:	4640      	mov	r0, r8
   10a88:	f7ff fecd 	bl	10826 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x4>
   10a8c:	8128      	strh	r0, [r5, #8]
   10a8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10a92:	271b      	movs	r7, #27
   10a94:	e7ec      	b.n	10a70 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x24e>
   10a96:	201b      	movs	r0, #27
   10a98:	e7f0      	b.n	10a7c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x25a>
   10a9a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10a9e:	7890      	ldrb	r0, [r2, #2]
   10aa0:	9e06      	ldr	r6, [sp, #24]
   10aa2:	461d      	mov	r5, r3
   10aa4:	4614      	mov	r4, r2
   10aa6:	b908      	cbnz	r0, 10aac <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x28a>
   10aa8:	f7fa fdcc 	bl	b644 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ>
   10aac:	78e4      	ldrb	r4, [r4, #3]
   10aae:	4607      	mov	r7, r0
   10ab0:	b914      	cbnz	r4, 10ab8 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x296>
   10ab2:	f7fa fdc7 	bl	b644 <sym_HA7EOSELAQYVMG5UXMJGQLLFEIRQPB7MNOSYOXQ>
   10ab6:	4604      	mov	r4, r0
   10ab8:	b16f      	cbz	r7, 10ad6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b4>
   10aba:	b164      	cbz	r4, 10ad6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b4>
   10abc:	4638      	mov	r0, r7
   10abe:	f7ff febd 	bl	1083c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1a>
   10ac2:	4620      	mov	r0, r4
   10ac4:	f7ff feba 	bl	1083c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x1a>
   10ac8:	b12f      	cbz	r7, 10ad6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b4>
   10aca:	b124      	cbz	r4, 10ad6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b4>
   10acc:	702f      	strb	r7, [r5, #0]
   10ace:	7034      	strb	r4, [r6, #0]
   10ad0:	2000      	movs	r0, #0
   10ad2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10ad6:	2009      	movs	r0, #9
   10ad8:	e7fb      	b.n	10ad2 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2b0>
   10ada:	207f      	movs	r0, #127	; 0x7f
   10adc:	f000 b83c 	b.w	10b58 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x336>
   10ae0:	b508      	push	{r3, lr}
   10ae2:	f890 1204 	ldrb.w	r1, [r0, #516]	; 0x204
   10ae6:	f890 00a5 	ldrb.w	r0, [r0, #165]	; 0xa5
   10aea:	f88d 0000 	strb.w	r0, [sp]
   10aee:	9800      	ldr	r0, [sp, #0]
   10af0:	9000      	str	r0, [sp, #0]
   10af2:	f89d 0000 	ldrb.w	r0, [sp]
   10af6:	b100      	cbz	r0, 10afa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2d8>
   10af8:	2001      	movs	r0, #1
   10afa:	1e40      	subs	r0, r0, #1
   10afc:	4208      	tst	r0, r1
   10afe:	d003      	beq.n	10b08 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2e6>
   10b00:	2904      	cmp	r1, #4
   10b02:	d001      	beq.n	10b08 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x2e6>
   10b04:	2001      	movs	r0, #1
   10b06:	bd08      	pop	{r3, pc}
   10b08:	2000      	movs	r0, #0
   10b0a:	bd08      	pop	{r3, pc}
   10b0c:	b570      	push	{r4, r5, r6, lr}
   10b0e:	4605      	mov	r5, r0
   10b10:	f7fe fbfc 	bl	f30c <sym_WGJLFS2PDN6RZG7JWUITZ3W5MGJYYXFXIKI3GGQ>
   10b14:	b170      	cbz	r0, 10b34 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x312>
   10b16:	4628      	mov	r0, r5
   10b18:	f7fe fdad 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
   10b1c:	2800      	cmp	r0, #0
   10b1e:	d008      	beq.n	10b32 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x310>
   10b20:	4628      	mov	r0, r5
   10b22:	f7fe fda5 	bl	f670 <sym_MHDCHYAEWBCIUYGOTWRWGZEJ6XEBEBUHOO5T6WY>
   10b26:	4604      	mov	r4, r0
   10b28:	4628      	mov	r0, r5
   10b2a:	f7fe fd7b 	bl	f624 <sym_7Q3OGK46EJ4CJTNREFMB4I3YQOYV4MCCW6KC7XI>
   10b2e:	b118      	cbz	r0, 10b38 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x316>
   10b30:	200c      	movs	r0, #12
   10b32:	bd70      	pop	{r4, r5, r6, pc}
   10b34:	2042      	movs	r0, #66	; 0x42
   10b36:	bd70      	pop	{r4, r5, r6, pc}
   10b38:	b164      	cbz	r4, 10b54 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x332>
   10b3a:	8820      	ldrh	r0, [r4, #0]
   10b3c:	f7fd fc13 	bl	e366 <sym_REO6MG4FRJTNQQ56RDJDYGEWFEO5TFVYGRW6OLI>
   10b40:	8820      	ldrh	r0, [r4, #0]
   10b42:	2100      	movs	r1, #0
   10b44:	f7f4 fd9a 	bl	567c <sym_4AWF7EXI3MMHUULTY73E756U3IY5DEXOZ265MZY>
   10b48:	b120      	cbz	r0, 10b54 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x332>
   10b4a:	f241 41fd 	movw	r1, #5373	; 0x14fd
   10b4e:	2039      	movs	r0, #57	; 0x39
   10b50:	f7f4 fb00 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10b54:	2000      	movs	r0, #0
   10b56:	bd70      	pop	{r4, r5, r6, pc}
   10b58:	b508      	push	{r3, lr}
   10b5a:	f640 1288 	movw	r2, #2440	; 0x988
   10b5e:	4669      	mov	r1, sp
   10b60:	f7f4 f9d8 	bl	4f14 <mpsl_fem_tx_power_split>
   10b64:	bd08      	pop	{r3, pc}
   10b66:	b530      	push	{r4, r5, lr}
   10b68:	f340 0400 	sbfx	r4, r0, #0, #1
   10b6c:	f340 0040 	sbfx	r0, r0, #1, #1
   10b70:	1c40      	adds	r0, r0, #1
   10b72:	9d03      	ldr	r5, [sp, #12]
   10b74:	1c64      	adds	r4, r4, #1
   10b76:	d000      	beq.n	10b7a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x358>
   10b78:	b119      	cbz	r1, 10b82 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x360>
   10b7a:	b100      	cbz	r0, 10b7e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x35c>
   10b7c:	b10a      	cbz	r2, 10b82 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x360>
   10b7e:	b91c      	cbnz	r4, 10b88 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x366>
   10b80:	e001      	b.n	10b86 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x364>
   10b82:	2011      	movs	r0, #17
   10b84:	bd30      	pop	{r4, r5, pc}
   10b86:	2100      	movs	r1, #0
   10b88:	7019      	strb	r1, [r3, #0]
   10b8a:	b900      	cbnz	r0, 10b8e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x36c>
   10b8c:	2200      	movs	r2, #0
   10b8e:	702a      	strb	r2, [r5, #0]
   10b90:	2000      	movs	r0, #0
   10b92:	bd30      	pop	{r4, r5, pc}
   10b94:	b2c0      	uxtb	r0, r0
   10b96:	06c1      	lsls	r1, r0, #27
   10b98:	d40c      	bmi.n	10bb4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x392>
   10b9a:	0681      	lsls	r1, r0, #26
   10b9c:	ea4f 71c0 	mov.w	r1, r0, lsl #31
   10ba0:	d503      	bpl.n	10baa <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x388>
   10ba2:	b9d1      	cbnz	r1, 10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10ba4:	0781      	lsls	r1, r0, #30
   10ba6:	d418      	bmi.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10ba8:	e001      	b.n	10bae <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x38c>
   10baa:	2900      	cmp	r1, #0
   10bac:	d1fa      	bne.n	10ba4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x382>
   10bae:	0700      	lsls	r0, r0, #28
   10bb0:	d413      	bmi.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10bb2:	e010      	b.n	10bd6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b4>
   10bb4:	0641      	lsls	r1, r0, #25
   10bb6:	d410      	bmi.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10bb8:	0681      	lsls	r1, r0, #26
   10bba:	d40e      	bmi.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10bbc:	07c1      	lsls	r1, r0, #31
   10bbe:	ea4f 7180 	mov.w	r1, r0, lsl #30
   10bc2:	d004      	beq.n	10bce <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3ac>
   10bc4:	2900      	cmp	r1, #0
   10bc6:	db02      	blt.n	10bce <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3ac>
   10bc8:	0740      	lsls	r0, r0, #29
   10bca:	d404      	bmi.n	10bd6 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b4>
   10bcc:	e005      	b.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10bce:	0701      	lsls	r1, r0, #28
   10bd0:	d403      	bmi.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10bd2:	0740      	lsls	r0, r0, #29
   10bd4:	d401      	bmi.n	10bda <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3b8>
   10bd6:	2001      	movs	r0, #1
   10bd8:	4770      	bx	lr
   10bda:	2000      	movs	r0, #0
   10bdc:	4770      	bx	lr
   10bde:	b53e      	push	{r1, r2, r3, r4, r5, lr}
   10be0:	4669      	mov	r1, sp
   10be2:	2001      	movs	r0, #1
   10be4:	f7fd fa0b 	bl	dffe <sym_3SKPFA625PNDCAQQU2M5BY77GYLRCXEEFZ5JBTY>
   10be8:	b178      	cbz	r0, 10c0a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3e8>
   10bea:	f44f 71b2 	mov.w	r1, #356	; 0x164
   10bee:	2039      	movs	r0, #57	; 0x39
   10bf0:	f7f4 fab0 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10bf4:	9c02      	ldr	r4, [sp, #8]
   10bf6:	4620      	mov	r0, r4
   10bf8:	f7fe fd3d 	bl	f676 <sym_VKORYLCFNIWNGETWJR24ZOUACQP66MFSZSXVABY>
   10bfc:	b128      	cbz	r0, 10c0a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3e8>
   10bfe:	4620      	mov	r0, r4
   10c00:	f7fe fbc0 	bl	f384 <sym_H6NC6L6VJY74V6C72Y6E5P4HGSZIVJQXMUOQZ5Y>
   10c04:	b108      	cbz	r0, 10c0a <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3e8>
   10c06:	2001      	movs	r0, #1
   10c08:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   10c0a:	4668      	mov	r0, sp
   10c0c:	f7f4 fce6 	bl	55dc <sym_6I4XEOIW7LI2E3Z53L54ZHQQHYICXR4H4JQWXLA>
   10c10:	2800      	cmp	r0, #0
   10c12:	d0ef      	beq.n	10bf4 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3d2>
   10c14:	2000      	movs	r0, #0
   10c16:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   10c18:	b510      	push	{r4, lr}
   10c1a:	f7fe fd2f 	bl	f67c <sym_3LXCSEW4O4NZFGMXLMWXSJJVGEQV4VDRFCVRV4Q>
   10c1e:	b108      	cbz	r0, 10c24 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x402>
   10c20:	21e7      	movs	r1, #231	; 0xe7
   10c22:	e003      	b.n	10c2c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x40a>
   10c24:	f7f6 fe5e 	bl	78e4 <sym_4WIY2RAFLOZNOS4O5BEVWEYHIO3NV42IZ2Q2NWQ>
   10c28:	b118      	cbz	r0, 10c32 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x410>
   10c2a:	21ec      	movs	r1, #236	; 0xec
   10c2c:	2001      	movs	r0, #1
   10c2e:	f7f4 fa91 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10c32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10c36:	2001      	movs	r0, #1
   10c38:	f7f4 bc66 	b.w	5508 <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A>
   10c3c:	6802      	ldr	r2, [r0, #0]
   10c3e:	b912      	cbnz	r2, 10c46 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x424>
   10c40:	6001      	str	r1, [r0, #0]
   10c42:	4770      	bx	lr
   10c44:	4602      	mov	r2, r0
   10c46:	6850      	ldr	r0, [r2, #4]
   10c48:	b108      	cbz	r0, 10c4e <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x42c>
   10c4a:	428a      	cmp	r2, r1
   10c4c:	d1fa      	bne.n	10c44 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x422>
   10c4e:	428a      	cmp	r2, r1
   10c50:	d0f7      	beq.n	10c42 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x420>
   10c52:	6051      	str	r1, [r2, #4]
   10c54:	4770      	bx	lr
   10c56:	b510      	push	{r4, lr}
   10c58:	4604      	mov	r4, r0
   10c5a:	e002      	b.n	10c62 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x440>
   10c5c:	6820      	ldr	r0, [r4, #0]
   10c5e:	4780      	blx	r0
   10c60:	6864      	ldr	r4, [r4, #4]
   10c62:	2c00      	cmp	r4, #0
   10c64:	d1fa      	bne.n	10c5c <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x43a>
   10c66:	bd10      	pop	{r4, pc}
   10c68:	b510      	push	{r4, lr}
   10c6a:	2000      	movs	r0, #0
   10c6c:	f7f4 fc4c 	bl	5508 <sym_HNCDHITBYWLO4GMOSPKCO7YXRRWIUQ2IKIZ4C5A>
   10c70:	f7f4 fe84 	bl	597c <sym_NOQRMQ5IH6SQFJEPI5A3UBMITO54HG4WO4DTTXA>
   10c74:	f7f5 f906 	bl	5e84 <sym_MJCF2WRL4I323V23HKVENOJWV5IXH54R5X6LJRY>
   10c78:	f7f5 fad2 	bl	6220 <sym_CZFK26FRDZ53FUV75DOIMFWVD4RTHYB6I22U4LA>
   10c7c:	2800      	cmp	r0, #0
   10c7e:	d003      	beq.n	10c88 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x466>
   10c80:	21c6      	movs	r1, #198	; 0xc6
   10c82:	2001      	movs	r0, #1
   10c84:	f7f4 fa66 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10c88:	bd10      	pop	{r4, pc}
   10c8a:	b510      	push	{r4, lr}
   10c8c:	f7ff ffc4 	bl	10c18 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x3f6>
   10c90:	f7ff f8fa 	bl	fe88 <sym_OTZAOT4DEZSL3R4MXRNUS2BIBKPPCOEO2SMZYAI>
   10c94:	2800      	cmp	r0, #0
   10c96:	d004      	beq.n	10ca2 <sym_XGMYPLGF3Q5IDBTHXI7LBKOVEGJV3YOSYITNMYA+0x480>
   10c98:	f240 1103 	movw	r1, #259	; 0x103
   10c9c:	2001      	movs	r0, #1
   10c9e:	f7f4 fa59 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10ca2:	bd10      	pop	{r4, pc}

00010ca4 <sym_R2552DB5ZKNDWW24PBGEV77VCDBC44WVAYRCUXQ>:
   10ca4:	f7f3 be8e 	b.w	49c4 <sym_ETIE3PCEXQYLK2GIVZENQ6V7PLBRV57MB7BDMNY>
   10ca8:	000b0001 	.word	0x000b0001
   10cac:	000a0002 	.word	0x000a0002
   10cb0:	00090005 	.word	0x00090005
   10cb4:	0008000a 	.word	0x0008000a
   10cb8:	00070014 	.word	0x00070014
   10cbc:	0006001e 	.word	0x0006001e
   10cc0:	00050032 	.word	0x00050032
   10cc4:	0004004b 	.word	0x0004004b
   10cc8:	00030064 	.word	0x00030064
   10ccc:	00020096 	.word	0x00020096
   10cd0:	000100fa 	.word	0x000100fa
   10cd4:	000001f4 	.word	0x000001f4

00010cd8 <sym_BIDMG7YHRFQNLIKRFVSOGOT6IXZCQ6UEJKN52VI>:
   10cd8:	b510      	push	{r4, lr}
   10cda:	f7fb f84d 	bl	bd78 <sym_RUQBFILZ5CHV2AAL6C3D2J5Y33TCCAPZTHBGZ3A>
   10cde:	f000 f81d 	bl	10d1c <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA>
   10ce2:	f7fa fd23 	bl	b72c <sym_LOTFHGQTFUFWGX7HOTL4Q2XATGIJRVIMCMOYRMA>
   10ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10cea:	f7fa be1d 	b.w	b928 <sym_TRMXENGHOH4VBQQZPIN222FLCEFU3Z3CD5C47DY>

00010cee <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ>:
   10cee:	b510      	push	{r4, lr}
   10cf0:	24c8      	movs	r4, #200	; 0xc8
   10cf2:	1e64      	subs	r4, r4, #1
   10cf4:	b2e4      	uxtb	r4, r4
   10cf6:	f7fa fd37 	bl	b768 <sym_KZ5CVONZGMGIGNMI7YD6HLN3FXAAJK6OMEJW6BQ>
   10cfa:	2802      	cmp	r0, #2
   10cfc:	d003      	beq.n	10d06 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x18>
   10cfe:	2801      	cmp	r0, #1
   10d00:	d000      	beq.n	10d04 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x16>
   10d02:	2000      	movs	r0, #0
   10d04:	bd10      	pop	{r4, pc}
   10d06:	2c00      	cmp	r4, #0
   10d08:	d1f3      	bne.n	10cf2 <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x4>
   10d0a:	219e      	movs	r1, #158	; 0x9e
   10d0c:	203b      	movs	r0, #59	; 0x3b
   10d0e:	f7f4 fa21 	bl	5154 <sym_476LRB5XNUARAHCHHC7ZAIGPFC5VZ4W2N4467LI>
   10d12:	5840      	ldr	r0, [r0, r1]
   10d14:	2800      	cmp	r0, #0
   10d16:	d000      	beq.n	10d1a <sym_ZG4AW57AAT4BVE2J2CU4KMCCWK46ENDRPKBYXEQ+0x2c>
   10d18:	2001      	movs	r0, #1
   10d1a:	4770      	bx	lr

00010d1c <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA>:
   10d1c:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
   10d20:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   10d24:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
   10d28:	f3bf 8f4f 	dsb	sy
   10d2c:	f3bf 8f6f 	isb	sy
   10d30:	f7fa be94 	b.w	ba5c <sym_6Q45YYTUN2KDQ5V5UGE3T2LTI5FNGX6WIJYLIDI+0x48>
   10d34:	2800      	cmp	r0, #0
   10d36:	db09      	blt.n	10d4c <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x30>
   10d38:	f000 021f 	and.w	r2, r0, #31
   10d3c:	2101      	movs	r1, #1
   10d3e:	4091      	lsls	r1, r2
   10d40:	0940      	lsrs	r0, r0, #5
   10d42:	0080      	lsls	r0, r0, #2
   10d44:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
   10d48:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
   10d4c:	4770      	bx	lr
   10d4e:	2800      	cmp	r0, #0
   10d50:	db0d      	blt.n	10d6e <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x52>
   10d52:	f000 021f 	and.w	r2, r0, #31
   10d56:	2101      	movs	r1, #1
   10d58:	4091      	lsls	r1, r2
   10d5a:	0940      	lsrs	r0, r0, #5
   10d5c:	0080      	lsls	r0, r0, #2
   10d5e:	f100 20e0 	add.w	r0, r0, #3758153728	; 0xe000e000
   10d62:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
   10d66:	f3bf 8f4f 	dsb	sy
   10d6a:	f3bf 8f6f 	isb	sy
   10d6e:	4770      	bx	lr
   10d70:	5840      	ldr	r0, [r0, r1]
   10d72:	2800      	cmp	r0, #0
   10d74:	d000      	beq.n	10d78 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x5c>
   10d76:	2001      	movs	r0, #1
   10d78:	4770      	bx	lr
   10d7a:	5840      	ldr	r0, [r0, r1]
   10d7c:	2800      	cmp	r0, #0
   10d7e:	d000      	beq.n	10d82 <sym_XPKSFPKFBNSTZZU4FUMGC3XRHAVS24BBL53HRMA+0x66>
   10d80:	2001      	movs	r0, #1
   10d82:	4770      	bx	lr

00010d84 <sym_2EA2WBXQOKCTPMK7YNDR6QM6MTGHJCDTPZEXNNA>:
   10d84:	b510      	push	{r4, lr}
   10d86:	4604      	mov	r4, r0
   10d88:	4608      	mov	r0, r1
   10d8a:	f7fb f91b 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
   10d8e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10d92:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
   10d96:	fbb0 f0f1 	udiv	r0, r0, r1
   10d9a:	1a20      	subs	r0, r4, r0
   10d9c:	1e80      	subs	r0, r0, #2
   10d9e:	bd10      	pop	{r4, pc}

00010da0 <sym_KM5SKFVNZKDXUQ7BDD3RZ5UCA5E3ZDVNWYJVR3Y>:
   10da0:	b510      	push	{r4, lr}
   10da2:	4604      	mov	r4, r0
   10da4:	4608      	mov	r0, r1
   10da6:	f7fb f90d 	bl	bfc4 <sym_UX6VBOIQ7ULLMX3I6UDFOFZ6IT2DVZKKVIEVRMY>
   10daa:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10dae:	fbb0 f0f1 	udiv	r0, r0, r1
   10db2:	1a20      	subs	r0, r4, r0
   10db4:	bd10      	pop	{r4, pc}
   10db6:	d8d8      	.short	0xd8d8
   10db8:	d8d8d8d8 	.word	0xd8d8d8d8
   10dbc:	d8d8d8d8 	.word	0xd8d8d8d8
   10dc0:	d8d8d8d8 	.word	0xd8d8d8d8
   10dc4:	d8d8d8d8 	.word	0xd8d8d8d8
   10dc8:	ececd8d8 	.word	0xececd8d8
   10dcc:	f0f0ecec 	.word	0xf0f0ecec
   10dd0:	f4f4f0f0 	.word	0xf4f4f0f0
   10dd4:	f8f8f4f4 	.word	0xf8f8f4f4
   10dd8:	fcfcf8f8 	.word	0xfcfcf8f8
   10ddc:	0000fcfc 	.word	0x0000fcfc
   10de0:	05040302 	.word	0x05040302
   10de4:	d8080706 	.word	0xd8080706
   10de8:	d8d8d8d8 	.word	0xd8d8d8d8
   10dec:	d8d8d8d8 	.word	0xd8d8d8d8
   10df0:	d8d8d8d8 	.word	0xd8d8d8d8
   10df4:	d8d8d8d8 	.word	0xd8d8d8d8
   10df8:	ecd8d8d8 	.word	0xecd8d8d8
   10dfc:	f0ececec 	.word	0xf0ececec
   10e00:	f4f0f0f0 	.word	0xf4f0f0f0
   10e04:	f8f4f4f4 	.word	0xf8f4f4f4
   10e08:	fcf8f8f8 	.word	0xfcf8f8f8
   10e0c:	00fcfcfc 	.word	0x00fcfcfc
   10e10:	04030000 	.word	0x04030000
   10e14:	1702080c 	.word	0x1702080c
   10e18:	0201010d 	.word	0x0201010d
   10e1c:	01010909 	.word	0x01010909
   10e20:	18090206 	.word	0x18090206
   10e24:	01010318 	.word	0x01010318
   10e28:	03030909 	.word	0x03030909
   10e2c:	01020305 	.word	0x01020305
   10e30:	24020222 	.word	0x24020222
   10e34:	04041009 	.word	0x04041009
   10e38:	00000505 	.word	0x00000505
   10e3c:	00000000 	.word	0x00000000

00010e40 <bsp_init>:
static uint8_t                   bsp_queue_buffer[sizeof(vitals_vital_sign_data_t) * BSP_APP_QUEUE_SIZE];

/***************************** - Public Functions - ********************************/

zephyr_err_t bsp_init()
{
   10e40:	b510      	push	{r4, lr}
    zephyr_err_t err = -EIO;
    bsp_work.vitals.heart_rate = ~(0);
   10e42:	4b1d      	ldr	r3, [pc, #116]	; (10eb8 <bsp_init+0x78>)
   10e44:	22ff      	movs	r2, #255	; 0xff
   10e46:	771a      	strb	r2, [r3, #28]
   10e48:	e012      	b.n	10e70 <bsp_init+0x30>
    {
        /*Add init functions to this part*/
        err = bsp_battery_gauge_init();
        if( ZEPHYR_ERR_SUCCESS != err )
        {
            printk("Battery gauge failed to init, err = %d\n" , err);
   10e4a:	481c      	ldr	r0, [pc, #112]	; (10ebc <bsp_init+0x7c>)
   10e4c:	f01b f8cc 	bl	2bfe8 <printk>
   10e50:	e013      	b.n	10e7a <bsp_init+0x3a>
        }
        err = bsp_display_init();
        if( ZEPHYR_ERR_SUCCESS != err )
        {
            printk("Display failed to init, err = %d\n" , err);
   10e52:	481b      	ldr	r0, [pc, #108]	; (10ec0 <bsp_init+0x80>)
   10e54:	f01b f8c8 	bl	2bfe8 <printk>
   10e58:	e014      	b.n	10e84 <bsp_init+0x44>
        }
        err = bsp_sensor_interface_init();
        if( ZEPHYR_ERR_SUCCESS != err )
        {
            printk("Sensor Interface failed to init, err = %d\n" , err);
   10e5a:	481a      	ldr	r0, [pc, #104]	; (10ec4 <bsp_init+0x84>)
   10e5c:	f01b f8c4 	bl	2bfe8 <printk>
   10e60:	e015      	b.n	10e8e <bsp_init+0x4e>
        if( ZEPHYR_ERR_SUCCESS != err )
        {
            printk("Sensor Interface failed to init, err = %d\n" , err);
        }

        bsp_display_print_string("Vitals status:\n"
   10e62:	a313      	add	r3, pc, #76	; (adr r3, 10eb0 <bsp_init+0x70>)
   10e64:	e9d3 2300 	ldrd	r2, r3, [r3]
   10e68:	4817      	ldr	r0, [pc, #92]	; (10ec8 <bsp_init+0x88>)
   10e6a:	f01a fffa 	bl	2be62 <bsp_display_print_string>
                                 " - Temperature: %fC\n",
                                 (float) 23.4);

    } while( ZEPHYR_ERR_SUCCESS != err );
   10e6e:	b1c4      	cbz	r4, 10ea2 <bsp_init+0x62>
        err = bsp_battery_gauge_init();
   10e70:	f003 fd2a 	bl	148c8 <bsp_battery_gauge_init>
        if( ZEPHYR_ERR_SUCCESS != err )
   10e74:	4601      	mov	r1, r0
   10e76:	2800      	cmp	r0, #0
   10e78:	d1e7      	bne.n	10e4a <bsp_init+0xa>
        err = bsp_display_init();
   10e7a:	f004 f8d1 	bl	15020 <bsp_display_init>
        if( ZEPHYR_ERR_SUCCESS != err )
   10e7e:	4601      	mov	r1, r0
   10e80:	2800      	cmp	r0, #0
   10e82:	d1e6      	bne.n	10e52 <bsp_init+0x12>
        err = bsp_sensor_interface_init();
   10e84:	f003 fa90 	bl	143a8 <bsp_sensor_interface_init>
        if( ZEPHYR_ERR_SUCCESS != err )
   10e88:	4601      	mov	r1, r0
   10e8a:	2800      	cmp	r0, #0
   10e8c:	d1e5      	bne.n	10e5a <bsp_init+0x1a>
        err = bsp_init_internal();
   10e8e:	f001 ff1d 	bl	12ccc <bsp_init_internal>
        if( ZEPHYR_ERR_SUCCESS != err )
   10e92:	4604      	mov	r4, r0
   10e94:	2800      	cmp	r0, #0
   10e96:	d0e4      	beq.n	10e62 <bsp_init+0x22>
            printk("Sensor Interface failed to init, err = %d\n" , err);
   10e98:	4601      	mov	r1, r0
   10e9a:	480a      	ldr	r0, [pc, #40]	; (10ec4 <bsp_init+0x84>)
   10e9c:	f01b f8a4 	bl	2bfe8 <printk>
   10ea0:	e7df      	b.n	10e62 <bsp_init+0x22>

    bsp_sensor_interface_pause_sampling();
   10ea2:	f01a feca 	bl	2bc3a <bsp_sensor_interface_pause_sampling>

    return err;
}
   10ea6:	4620      	mov	r0, r4
   10ea8:	bd10      	pop	{r4, pc}
   10eaa:	bf00      	nop
   10eac:	f3af 8000 	nop.w
   10eb0:	60000000 	.word	0x60000000
   10eb4:	40376666 	.word	0x40376666
   10eb8:	200028c4 	.word	0x200028c4
   10ebc:	00031468 	.word	0x00031468
   10ec0:	00031490 	.word	0x00031490
   10ec4:	000314b4 	.word	0x000314b4
   10ec8:	000314e0 	.word	0x000314e0
   10ecc:	00000000 	.word	0x00000000

00010ed0 <bsp_fft_radix2>:
}

/***************************** - Private Functions - *******************************/

static inline void bsp_fft_radix2( int16_t* x, complex_t* X, uint16_t N, uint16_t step )
{
   10ed0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10ed4:	ed2d 8b02 	vpush	{d8}
   10ed8:	b089      	sub	sp, #36	; 0x24
   10eda:	9003      	str	r0, [sp, #12]
   10edc:	468b      	mov	fp, r1
   10ede:	9304      	str	r3, [sp, #16]
    // At the lowest level pass through (delta T=0 means no phase).
    if (N == 1)
   10ee0:	2a01      	cmp	r2, #1
   10ee2:	d033      	beq.n	10f4c <bsp_fft_radix2+0x7c>
   10ee4:	ee08 2a10 	vmov	s16, r2
    {
        X[0] = (complex_t) x[0];
        return;
    }

    uint16_t idx = N / 2U;
   10ee8:	0852      	lsrs	r2, r2, #1
   10eea:	9201      	str	r2, [sp, #4]

    // Cooley-Tukey: recursively split in two, then combine beneath.
    bsp_fft_radix2(x, X, idx, 2 * step);
   10eec:	9b04      	ldr	r3, [sp, #16]
   10eee:	005b      	lsls	r3, r3, #1
   10ef0:	b29b      	uxth	r3, r3
   10ef2:	9305      	str	r3, [sp, #20]
    if (N == 1)
   10ef4:	2a01      	cmp	r2, #1
   10ef6:	d038      	beq.n	10f6a <bsp_fft_radix2+0x9a>
    uint16_t idx = N / 2U;
   10ef8:	9b01      	ldr	r3, [sp, #4]
   10efa:	085b      	lsrs	r3, r3, #1
   10efc:	9302      	str	r3, [sp, #8]
    bsp_fft_radix2(x, X, idx, 2 * step);
   10efe:	9a05      	ldr	r2, [sp, #20]
   10f00:	0054      	lsls	r4, r2, #1
   10f02:	b2a2      	uxth	r2, r4
   10f04:	9207      	str	r2, [sp, #28]
    if (N == 1)
   10f06:	2b01      	cmp	r3, #1
   10f08:	d067      	beq.n	10fda <bsp_fft_radix2+0x10a>
    uint16_t idx = N / 2U;
   10f0a:	9b02      	ldr	r3, [sp, #8]
   10f0c:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   10f10:	9b07      	ldr	r3, [sp, #28]
   10f12:	005c      	lsls	r4, r3, #1
   10f14:	b2a3      	uxth	r3, r4
   10f16:	9306      	str	r3, [sp, #24]
    if (N == 1)
   10f18:	f1ba 0f01 	cmp.w	sl, #1
   10f1c:	f000 8088 	beq.w	11030 <bsp_fft_radix2+0x160>
    uint16_t idx = N / 2U;
   10f20:	ea4f 095a 	mov.w	r9, sl, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   10f24:	9b06      	ldr	r3, [sp, #24]
   10f26:	005c      	lsls	r4, r3, #1
   10f28:	b2a5      	uxth	r5, r4
   10f2a:	462b      	mov	r3, r5
   10f2c:	464a      	mov	r2, r9
   10f2e:	9e03      	ldr	r6, [sp, #12]
   10f30:	4630      	mov	r0, r6
   10f32:	f7ff ffcd 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   10f36:	462b      	mov	r3, r5
   10f38:	464a      	mov	r2, r9
   10f3a:	eb0b 01c9 	add.w	r1, fp, r9, lsl #3
   10f3e:	4630      	mov	r0, r6
   10f40:	4420      	add	r0, r4
   10f42:	f7ff ffc5 	bl	10ed0 <bsp_fft_radix2>

    complex_t z;
    for (uint16_t k = 0; k < idx; k++)
   10f46:	f04f 0800 	mov.w	r8, #0
   10f4a:	e0bc      	b.n	110c6 <bsp_fft_radix2+0x1f6>
        X[0] = (complex_t) x[0];
   10f4c:	f9b0 3000 	ldrsh.w	r3, [r0]
   10f50:	ee07 3a90 	vmov	s15, r3
   10f54:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10f58:	edc1 7a00 	vstr	s15, [r1]
   10f5c:	2300      	movs	r3, #0
   10f5e:	604b      	str	r3, [r1, #4]
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
        X[k + idx] = X[k] - z;
        X[k]       = X[k] + z;
    }

}
   10f60:	b009      	add	sp, #36	; 0x24
   10f62:	ecbd 8b02 	vpop	{d8}
   10f66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        X[0] = (complex_t) x[0];
   10f6a:	9b03      	ldr	r3, [sp, #12]
   10f6c:	f9b3 3000 	ldrsh.w	r3, [r3]
   10f70:	ee07 3a90 	vmov	s15, r3
   10f74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10f78:	edc1 7a00 	vstr	s15, [r1]
   10f7c:	2300      	movs	r3, #0
   10f7e:	604b      	str	r3, [r1, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   10f80:	9b03      	ldr	r3, [sp, #12]
   10f82:	9a04      	ldr	r2, [sp, #16]
   10f84:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   10f88:	9306      	str	r3, [sp, #24]
   10f8a:	9b01      	ldr	r3, [sp, #4]
   10f8c:	eb0b 0ac3 	add.w	sl, fp, r3, lsl #3
    if (N == 1)
   10f90:	2b01      	cmp	r3, #1
   10f92:	f000 82f1 	beq.w	11578 <bsp_fft_radix2+0x6a8>
    uint16_t idx = N / 2U;
   10f96:	9b01      	ldr	r3, [sp, #4]
   10f98:	085b      	lsrs	r3, r3, #1
   10f9a:	9302      	str	r3, [sp, #8]
    bsp_fft_radix2(x, X, idx, 2 * step);
   10f9c:	9a05      	ldr	r2, [sp, #20]
   10f9e:	0054      	lsls	r4, r2, #1
   10fa0:	b2a2      	uxth	r2, r4
   10fa2:	9207      	str	r2, [sp, #28]
    if (N == 1)
   10fa4:	2b01      	cmp	r3, #1
   10fa6:	f000 82f9 	beq.w	1159c <bsp_fft_radix2+0x6cc>
    uint16_t idx = N / 2U;
   10faa:	9b02      	ldr	r3, [sp, #8]
   10fac:	ea4f 0953 	mov.w	r9, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   10fb0:	9b07      	ldr	r3, [sp, #28]
   10fb2:	005c      	lsls	r4, r3, #1
   10fb4:	b2a5      	uxth	r5, r4
   10fb6:	462b      	mov	r3, r5
   10fb8:	464a      	mov	r2, r9
   10fba:	4651      	mov	r1, sl
   10fbc:	9e06      	ldr	r6, [sp, #24]
   10fbe:	4630      	mov	r0, r6
   10fc0:	f7ff ff86 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   10fc4:	462b      	mov	r3, r5
   10fc6:	464a      	mov	r2, r9
   10fc8:	eb0a 01c9 	add.w	r1, sl, r9, lsl #3
   10fcc:	4630      	mov	r0, r6
   10fce:	4420      	add	r0, r4
   10fd0:	f7ff ff7e 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   10fd4:	f04f 0800 	mov.w	r8, #0
   10fd8:	e32c      	b.n	11634 <bsp_fft_radix2+0x764>
        X[0] = (complex_t) x[0];
   10fda:	9b03      	ldr	r3, [sp, #12]
   10fdc:	f9b3 3000 	ldrsh.w	r3, [r3]
   10fe0:	ee07 3a90 	vmov	s15, r3
   10fe4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10fe8:	edc1 7a00 	vstr	s15, [r1]
   10fec:	2300      	movs	r3, #0
   10fee:	604b      	str	r3, [r1, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   10ff0:	9b03      	ldr	r3, [sp, #12]
   10ff2:	9a05      	ldr	r2, [sp, #20]
   10ff4:	eb03 0542 	add.w	r5, r3, r2, lsl #1
   10ff8:	9b02      	ldr	r3, [sp, #8]
   10ffa:	eb0b 0ac3 	add.w	sl, fp, r3, lsl #3
    if (N == 1)
   10ffe:	2b01      	cmp	r3, #1
   11000:	f000 81b9 	beq.w	11376 <bsp_fft_radix2+0x4a6>
    uint16_t idx = N / 2U;
   11004:	9b02      	ldr	r3, [sp, #8]
   11006:	ea4f 0953 	mov.w	r9, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   1100a:	9b07      	ldr	r3, [sp, #28]
   1100c:	005c      	lsls	r4, r3, #1
   1100e:	b2a6      	uxth	r6, r4
   11010:	4633      	mov	r3, r6
   11012:	464a      	mov	r2, r9
   11014:	4651      	mov	r1, sl
   11016:	4628      	mov	r0, r5
   11018:	f7ff ff5a 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   1101c:	4633      	mov	r3, r6
   1101e:	464a      	mov	r2, r9
   11020:	eb0a 01c9 	add.w	r1, sl, r9, lsl #3
   11024:	1928      	adds	r0, r5, r4
   11026:	f7ff ff53 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   1102a:	f04f 0800 	mov.w	r8, #0
   1102e:	e1d2      	b.n	113d6 <bsp_fft_radix2+0x506>
        X[0] = (complex_t) x[0];
   11030:	9b03      	ldr	r3, [sp, #12]
   11032:	f9b3 3000 	ldrsh.w	r3, [r3]
   11036:	ee07 3a90 	vmov	s15, r3
   1103a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1103e:	edc1 7a00 	vstr	s15, [r1]
   11042:	2300      	movs	r3, #0
   11044:	604b      	str	r3, [r1, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11046:	9b03      	ldr	r3, [sp, #12]
   11048:	9a07      	ldr	r2, [sp, #28]
   1104a:	eb03 0542 	add.w	r5, r3, r2, lsl #1
   1104e:	eb0b 07ca 	add.w	r7, fp, sl, lsl #3
    if (N == 1)
   11052:	f1ba 0f01 	cmp.w	sl, #1
   11056:	f000 808f 	beq.w	11178 <bsp_fft_radix2+0x2a8>
    uint16_t idx = N / 2U;
   1105a:	ea4f 095a 	mov.w	r9, sl, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   1105e:	9b06      	ldr	r3, [sp, #24]
   11060:	005c      	lsls	r4, r3, #1
   11062:	b2a6      	uxth	r6, r4
   11064:	4633      	mov	r3, r6
   11066:	464a      	mov	r2, r9
   11068:	4639      	mov	r1, r7
   1106a:	4628      	mov	r0, r5
   1106c:	f7ff ff30 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11070:	4633      	mov	r3, r6
   11072:	464a      	mov	r2, r9
   11074:	eb07 01c9 	add.w	r1, r7, r9, lsl #3
   11078:	1928      	adds	r0, r5, r4
   1107a:	f7ff ff29 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   1107e:	f04f 0800 	mov.w	r8, #0
   11082:	f8cd a018 	str.w	sl, [sp, #24]
   11086:	46ba      	mov	sl, r7
   11088:	e09f      	b.n	111ca <bsp_fft_radix2+0x2fa>
        X[k + idx] = X[k] - z;
   1108a:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   1108e:	ed93 6a00 	vldr	s12, [r3]
   11092:	ee36 6a47 	vsub.f32	s12, s12, s14
   11096:	edd3 6a01 	vldr	s13, [r3, #4]
   1109a:	ee76 6ae7 	vsub.f32	s13, s13, s15
   1109e:	ed84 6a00 	vstr	s12, [r4]
   110a2:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   110a6:	edd3 6a00 	vldr	s13, [r3]
   110aa:	ee37 7a26 	vadd.f32	s14, s14, s13
   110ae:	edd3 6a01 	vldr	s13, [r3, #4]
   110b2:	ee77 7aa6 	vadd.f32	s15, s15, s13
   110b6:	ed83 7a00 	vstr	s14, [r3]
   110ba:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   110be:	f108 0801 	add.w	r8, r8, #1
   110c2:	fa1f f888 	uxth.w	r8, r8
   110c6:	45c1      	cmp	r9, r8
   110c8:	d9bd      	bls.n	11046 <bsp_fft_radix2+0x176>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   110ca:	ee07 8a90 	vmov	s15, r8
   110ce:	eef8 7a67 	vcvt.f32.u32	s15, s15
   110d2:	ee17 0a90 	vmov	r0, s15
   110d6:	f7ef f967 	bl	3a8 <__aeabi_f2d>
   110da:	4606      	mov	r6, r0
   110dc:	460f      	mov	r7, r1
   110de:	ee07 aa90 	vmov	s15, sl
   110e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   110e6:	ee17 0a90 	vmov	r0, s15
   110ea:	f7ef f95d 	bl	3a8 <__aeabi_f2d>
   110ee:	4604      	mov	r4, r0
   110f0:	460d      	mov	r5, r1
   110f2:	2200      	movs	r2, #0
   110f4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   110f8:	4630      	mov	r0, r6
   110fa:	4639      	mov	r1, r7
   110fc:	f7ef f9ac 	bl	458 <__aeabi_dmul>
   11100:	4622      	mov	r2, r4
   11102:	462b      	mov	r3, r5
   11104:	f7ef fad2 	bl	6ac <__aeabi_ddiv>
   11108:	f7ef fbb8 	bl	87c <__aeabi_d2f>
   1110c:	ee08 0a90 	vmov	s17, r0
   11110:	f60f 03bc 	addw	r3, pc, #2236	; 0x8bc
   11114:	e9d3 2300 	ldrd	r2, r3, [r3]
   11118:	4630      	mov	r0, r6
   1111a:	4639      	mov	r1, r7
   1111c:	f7ef f99c 	bl	458 <__aeabi_dmul>
   11120:	4622      	mov	r2, r4
   11122:	462b      	mov	r3, r5
   11124:	f7ef fac2 	bl	6ac <__aeabi_ddiv>
   11128:	f7ef fba8 	bl	87c <__aeabi_d2f>
   1112c:	eeb0 0a68 	vmov.f32	s0, s17
   11130:	ee00 0a90 	vmov	s1, r0
   11134:	f019 fcb8 	bl	2aaa8 <cexpf>
   11138:	eb08 0409 	add.w	r4, r8, r9
   1113c:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   11140:	ed94 1a00 	vldr	s2, [r4]
   11144:	edd4 1a01 	vldr	s3, [r4, #4]
   11148:	ee20 7a01 	vmul.f32	s14, s0, s2
   1114c:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11150:	ee37 7a67 	vsub.f32	s14, s14, s15
   11154:	ee60 7a21 	vmul.f32	s15, s0, s3
   11158:	ee60 6a81 	vmul.f32	s13, s1, s2
   1115c:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11160:	eeb4 7a67 	vcmp.f32	s14, s15
   11164:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11168:	d78f      	bvc.n	1108a <bsp_fft_radix2+0x1ba>
   1116a:	f7ef fd4d 	bl	c08 <__mulsc3>
   1116e:	eeb0 7a40 	vmov.f32	s14, s0
   11172:	eef0 7a60 	vmov.f32	s15, s1
   11176:	e788      	b.n	1108a <bsp_fft_radix2+0x1ba>
        X[0] = (complex_t) x[0];
   11178:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   1117c:	ee07 3a90 	vmov	s15, r3
   11180:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11184:	edc7 7a00 	vstr	s15, [r7]
   11188:	2300      	movs	r3, #0
   1118a:	607b      	str	r3, [r7, #4]
        return;
   1118c:	e078      	b.n	11280 <bsp_fft_radix2+0x3b0>
        X[k + idx] = X[k] - z;
   1118e:	eb0a 03c8 	add.w	r3, sl, r8, lsl #3
   11192:	ed93 6a00 	vldr	s12, [r3]
   11196:	ee36 6a47 	vsub.f32	s12, s12, s14
   1119a:	edd3 6a01 	vldr	s13, [r3, #4]
   1119e:	ee76 6ae7 	vsub.f32	s13, s13, s15
   111a2:	ed84 6a00 	vstr	s12, [r4]
   111a6:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   111aa:	edd3 6a00 	vldr	s13, [r3]
   111ae:	ee37 7a26 	vadd.f32	s14, s14, s13
   111b2:	edd3 6a01 	vldr	s13, [r3, #4]
   111b6:	ee77 7aa6 	vadd.f32	s15, s15, s13
   111ba:	ed83 7a00 	vstr	s14, [r3]
   111be:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   111c2:	f108 0801 	add.w	r8, r8, #1
   111c6:	fa1f f888 	uxth.w	r8, r8
   111ca:	45c1      	cmp	r9, r8
   111cc:	d956      	bls.n	1127c <bsp_fft_radix2+0x3ac>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   111ce:	ee07 8a90 	vmov	s15, r8
   111d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   111d6:	ee17 0a90 	vmov	r0, s15
   111da:	f7ef f8e5 	bl	3a8 <__aeabi_f2d>
   111de:	4606      	mov	r6, r0
   111e0:	460f      	mov	r7, r1
   111e2:	eddd 7a06 	vldr	s15, [sp, #24]
   111e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   111ea:	ee17 0a90 	vmov	r0, s15
   111ee:	f7ef f8db 	bl	3a8 <__aeabi_f2d>
   111f2:	4604      	mov	r4, r0
   111f4:	460d      	mov	r5, r1
   111f6:	2200      	movs	r2, #0
   111f8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   111fc:	4630      	mov	r0, r6
   111fe:	4639      	mov	r1, r7
   11200:	f7ef f92a 	bl	458 <__aeabi_dmul>
   11204:	4622      	mov	r2, r4
   11206:	462b      	mov	r3, r5
   11208:	f7ef fa50 	bl	6ac <__aeabi_ddiv>
   1120c:	f7ef fb36 	bl	87c <__aeabi_d2f>
   11210:	ee08 0a90 	vmov	s17, r0
   11214:	f20f 73b8 	addw	r3, pc, #1976	; 0x7b8
   11218:	e9d3 2300 	ldrd	r2, r3, [r3]
   1121c:	4630      	mov	r0, r6
   1121e:	4639      	mov	r1, r7
   11220:	f7ef f91a 	bl	458 <__aeabi_dmul>
   11224:	4622      	mov	r2, r4
   11226:	462b      	mov	r3, r5
   11228:	f7ef fa40 	bl	6ac <__aeabi_ddiv>
   1122c:	f7ef fb26 	bl	87c <__aeabi_d2f>
   11230:	eeb0 0a68 	vmov.f32	s0, s17
   11234:	ee00 0a90 	vmov	s1, r0
   11238:	f019 fc36 	bl	2aaa8 <cexpf>
   1123c:	eb08 0409 	add.w	r4, r8, r9
   11240:	eb0a 04c4 	add.w	r4, sl, r4, lsl #3
   11244:	ed94 1a00 	vldr	s2, [r4]
   11248:	edd4 1a01 	vldr	s3, [r4, #4]
   1124c:	ee20 7a01 	vmul.f32	s14, s0, s2
   11250:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11254:	ee37 7a67 	vsub.f32	s14, s14, s15
   11258:	ee60 7a21 	vmul.f32	s15, s0, s3
   1125c:	ee60 6a81 	vmul.f32	s13, s1, s2
   11260:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11264:	eeb4 7a67 	vcmp.f32	s14, s15
   11268:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1126c:	d78f      	bvc.n	1118e <bsp_fft_radix2+0x2be>
   1126e:	f7ef fccb 	bl	c08 <__mulsc3>
   11272:	eeb0 7a40 	vmov.f32	s14, s0
   11276:	eef0 7a60 	vmov.f32	s15, s1
   1127a:	e788      	b.n	1118e <bsp_fft_radix2+0x2be>
   1127c:	f8dd a018 	ldr.w	sl, [sp, #24]
    for (uint16_t k = 0; k < idx; k++)
   11280:	f04f 0800 	mov.w	r8, #0
   11284:	e01d      	b.n	112c2 <bsp_fft_radix2+0x3f2>
        X[k + idx] = X[k] - z;
   11286:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   1128a:	ed93 6a00 	vldr	s12, [r3]
   1128e:	ee36 6a47 	vsub.f32	s12, s12, s14
   11292:	edd3 6a01 	vldr	s13, [r3, #4]
   11296:	ee76 6ae7 	vsub.f32	s13, s13, s15
   1129a:	ed84 6a00 	vstr	s12, [r4]
   1129e:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   112a2:	edd3 6a00 	vldr	s13, [r3]
   112a6:	ee37 7a26 	vadd.f32	s14, s14, s13
   112aa:	edd3 6a01 	vldr	s13, [r3, #4]
   112ae:	ee77 7aa6 	vadd.f32	s15, s15, s13
   112b2:	ed83 7a00 	vstr	s14, [r3]
   112b6:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   112ba:	f108 0801 	add.w	r8, r8, #1
   112be:	fa1f f888 	uxth.w	r8, r8
   112c2:	45c2      	cmp	sl, r8
   112c4:	f67f ae94 	bls.w	10ff0 <bsp_fft_radix2+0x120>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   112c8:	ee07 8a90 	vmov	s15, r8
   112cc:	eef8 7a67 	vcvt.f32.u32	s15, s15
   112d0:	ee17 0a90 	vmov	r0, s15
   112d4:	f7ef f868 	bl	3a8 <__aeabi_f2d>
   112d8:	4606      	mov	r6, r0
   112da:	460f      	mov	r7, r1
   112dc:	eddd 7a02 	vldr	s15, [sp, #8]
   112e0:	eef8 7a67 	vcvt.f32.u32	s15, s15
   112e4:	ee17 0a90 	vmov	r0, s15
   112e8:	f7ef f85e 	bl	3a8 <__aeabi_f2d>
   112ec:	4604      	mov	r4, r0
   112ee:	460d      	mov	r5, r1
   112f0:	2200      	movs	r2, #0
   112f2:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   112f6:	4630      	mov	r0, r6
   112f8:	4639      	mov	r1, r7
   112fa:	f7ef f8ad 	bl	458 <__aeabi_dmul>
   112fe:	4622      	mov	r2, r4
   11300:	462b      	mov	r3, r5
   11302:	f7ef f9d3 	bl	6ac <__aeabi_ddiv>
   11306:	f7ef fab9 	bl	87c <__aeabi_d2f>
   1130a:	ee08 0a90 	vmov	s17, r0
   1130e:	f20f 63c0 	addw	r3, pc, #1728	; 0x6c0
   11312:	e9d3 2300 	ldrd	r2, r3, [r3]
   11316:	4630      	mov	r0, r6
   11318:	4639      	mov	r1, r7
   1131a:	f7ef f89d 	bl	458 <__aeabi_dmul>
   1131e:	4622      	mov	r2, r4
   11320:	462b      	mov	r3, r5
   11322:	f7ef f9c3 	bl	6ac <__aeabi_ddiv>
   11326:	f7ef faa9 	bl	87c <__aeabi_d2f>
   1132a:	eeb0 0a68 	vmov.f32	s0, s17
   1132e:	ee00 0a90 	vmov	s1, r0
   11332:	f019 fbb9 	bl	2aaa8 <cexpf>
   11336:	eb08 040a 	add.w	r4, r8, sl
   1133a:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   1133e:	ed94 1a00 	vldr	s2, [r4]
   11342:	edd4 1a01 	vldr	s3, [r4, #4]
   11346:	ee20 7a01 	vmul.f32	s14, s0, s2
   1134a:	ee60 7aa1 	vmul.f32	s15, s1, s3
   1134e:	ee37 7a67 	vsub.f32	s14, s14, s15
   11352:	ee60 7a21 	vmul.f32	s15, s0, s3
   11356:	ee60 6a81 	vmul.f32	s13, s1, s2
   1135a:	ee77 7aa6 	vadd.f32	s15, s15, s13
   1135e:	eeb4 7a67 	vcmp.f32	s14, s15
   11362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11366:	d78e      	bvc.n	11286 <bsp_fft_radix2+0x3b6>
   11368:	f7ef fc4e 	bl	c08 <__mulsc3>
   1136c:	eeb0 7a40 	vmov.f32	s14, s0
   11370:	eef0 7a60 	vmov.f32	s15, s1
   11374:	e787      	b.n	11286 <bsp_fft_radix2+0x3b6>
        X[0] = (complex_t) x[0];
   11376:	9b03      	ldr	r3, [sp, #12]
   11378:	9a05      	ldr	r2, [sp, #20]
   1137a:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   1137e:	ee07 3a90 	vmov	s15, r3
   11382:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11386:	edca 7a00 	vstr	s15, [sl]
   1138a:	2300      	movs	r3, #0
   1138c:	f8ca 3004 	str.w	r3, [sl, #4]
    for (uint16_t k = 0; k < idx; k++)
   11390:	f04f 0800 	mov.w	r8, #0
   11394:	f8dd 9008 	ldr.w	r9, [sp, #8]
   11398:	e094      	b.n	114c4 <bsp_fft_radix2+0x5f4>
        X[k + idx] = X[k] - z;
   1139a:	eb0a 03c8 	add.w	r3, sl, r8, lsl #3
   1139e:	ed93 6a00 	vldr	s12, [r3]
   113a2:	ee36 6a47 	vsub.f32	s12, s12, s14
   113a6:	edd3 6a01 	vldr	s13, [r3, #4]
   113aa:	ee76 6ae7 	vsub.f32	s13, s13, s15
   113ae:	ed84 6a00 	vstr	s12, [r4]
   113b2:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   113b6:	edd3 6a00 	vldr	s13, [r3]
   113ba:	ee37 7a26 	vadd.f32	s14, s14, s13
   113be:	edd3 6a01 	vldr	s13, [r3, #4]
   113c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
   113c6:	ed83 7a00 	vstr	s14, [r3]
   113ca:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   113ce:	f108 0801 	add.w	r8, r8, #1
   113d2:	fa1f f888 	uxth.w	r8, r8
   113d6:	45c1      	cmp	r9, r8
   113d8:	d9da      	bls.n	11390 <bsp_fft_radix2+0x4c0>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   113da:	ee07 8a90 	vmov	s15, r8
   113de:	eef8 7a67 	vcvt.f32.u32	s15, s15
   113e2:	ee17 0a90 	vmov	r0, s15
   113e6:	f7ee ffdf 	bl	3a8 <__aeabi_f2d>
   113ea:	4606      	mov	r6, r0
   113ec:	460f      	mov	r7, r1
   113ee:	eddd 7a02 	vldr	s15, [sp, #8]
   113f2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   113f6:	ee17 0a90 	vmov	r0, s15
   113fa:	f7ee ffd5 	bl	3a8 <__aeabi_f2d>
   113fe:	4604      	mov	r4, r0
   11400:	460d      	mov	r5, r1
   11402:	2200      	movs	r2, #0
   11404:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11408:	4630      	mov	r0, r6
   1140a:	4639      	mov	r1, r7
   1140c:	f7ef f824 	bl	458 <__aeabi_dmul>
   11410:	4622      	mov	r2, r4
   11412:	462b      	mov	r3, r5
   11414:	f7ef f94a 	bl	6ac <__aeabi_ddiv>
   11418:	f7ef fa30 	bl	87c <__aeabi_d2f>
   1141c:	ee08 0a90 	vmov	s17, r0
   11420:	f20f 53ac 	addw	r3, pc, #1452	; 0x5ac
   11424:	e9d3 2300 	ldrd	r2, r3, [r3]
   11428:	4630      	mov	r0, r6
   1142a:	4639      	mov	r1, r7
   1142c:	f7ef f814 	bl	458 <__aeabi_dmul>
   11430:	4622      	mov	r2, r4
   11432:	462b      	mov	r3, r5
   11434:	f7ef f93a 	bl	6ac <__aeabi_ddiv>
   11438:	f7ef fa20 	bl	87c <__aeabi_d2f>
   1143c:	eeb0 0a68 	vmov.f32	s0, s17
   11440:	ee00 0a90 	vmov	s1, r0
   11444:	f019 fb30 	bl	2aaa8 <cexpf>
   11448:	eb08 0409 	add.w	r4, r8, r9
   1144c:	eb0a 04c4 	add.w	r4, sl, r4, lsl #3
   11450:	ed94 1a00 	vldr	s2, [r4]
   11454:	edd4 1a01 	vldr	s3, [r4, #4]
   11458:	ee20 7a01 	vmul.f32	s14, s0, s2
   1145c:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11460:	ee37 7a67 	vsub.f32	s14, s14, s15
   11464:	ee60 7a21 	vmul.f32	s15, s0, s3
   11468:	ee60 6a81 	vmul.f32	s13, s1, s2
   1146c:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11470:	eeb4 7a67 	vcmp.f32	s14, s15
   11474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11478:	d78f      	bvc.n	1139a <bsp_fft_radix2+0x4ca>
   1147a:	f7ef fbc5 	bl	c08 <__mulsc3>
   1147e:	eeb0 7a40 	vmov.f32	s14, s0
   11482:	eef0 7a60 	vmov.f32	s15, s1
   11486:	e788      	b.n	1139a <bsp_fft_radix2+0x4ca>
        X[k + idx] = X[k] - z;
   11488:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   1148c:	ed93 6a00 	vldr	s12, [r3]
   11490:	ee36 6a47 	vsub.f32	s12, s12, s14
   11494:	edd3 6a01 	vldr	s13, [r3, #4]
   11498:	ee76 6ae7 	vsub.f32	s13, s13, s15
   1149c:	ed84 6a00 	vstr	s12, [r4]
   114a0:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   114a4:	edd3 6a00 	vldr	s13, [r3]
   114a8:	ee37 7a26 	vadd.f32	s14, s14, s13
   114ac:	edd3 6a01 	vldr	s13, [r3, #4]
   114b0:	ee77 7aa6 	vadd.f32	s15, s15, s13
   114b4:	ed83 7a00 	vstr	s14, [r3]
   114b8:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   114bc:	f108 0801 	add.w	r8, r8, #1
   114c0:	fa1f f888 	uxth.w	r8, r8
   114c4:	45c1      	cmp	r9, r8
   114c6:	f67f ad5b 	bls.w	10f80 <bsp_fft_radix2+0xb0>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   114ca:	ee07 8a90 	vmov	s15, r8
   114ce:	eef8 7a67 	vcvt.f32.u32	s15, s15
   114d2:	ee17 0a90 	vmov	r0, s15
   114d6:	f7ee ff67 	bl	3a8 <__aeabi_f2d>
   114da:	4606      	mov	r6, r0
   114dc:	460f      	mov	r7, r1
   114de:	eddd 7a01 	vldr	s15, [sp, #4]
   114e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   114e6:	ee17 0a90 	vmov	r0, s15
   114ea:	f7ee ff5d 	bl	3a8 <__aeabi_f2d>
   114ee:	4604      	mov	r4, r0
   114f0:	460d      	mov	r5, r1
   114f2:	2200      	movs	r2, #0
   114f4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   114f8:	4630      	mov	r0, r6
   114fa:	4639      	mov	r1, r7
   114fc:	f7ee ffac 	bl	458 <__aeabi_dmul>
   11500:	4622      	mov	r2, r4
   11502:	462b      	mov	r3, r5
   11504:	f7ef f8d2 	bl	6ac <__aeabi_ddiv>
   11508:	f7ef f9b8 	bl	87c <__aeabi_d2f>
   1150c:	ee08 0a90 	vmov	s17, r0
   11510:	f20f 43bc 	addw	r3, pc, #1212	; 0x4bc
   11514:	e9d3 2300 	ldrd	r2, r3, [r3]
   11518:	4630      	mov	r0, r6
   1151a:	4639      	mov	r1, r7
   1151c:	f7ee ff9c 	bl	458 <__aeabi_dmul>
   11520:	4622      	mov	r2, r4
   11522:	462b      	mov	r3, r5
   11524:	f7ef f8c2 	bl	6ac <__aeabi_ddiv>
   11528:	f7ef f9a8 	bl	87c <__aeabi_d2f>
   1152c:	eeb0 0a68 	vmov.f32	s0, s17
   11530:	ee00 0a90 	vmov	s1, r0
   11534:	f019 fab8 	bl	2aaa8 <cexpf>
   11538:	eb08 0409 	add.w	r4, r8, r9
   1153c:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   11540:	ed94 1a00 	vldr	s2, [r4]
   11544:	edd4 1a01 	vldr	s3, [r4, #4]
   11548:	ee20 7a01 	vmul.f32	s14, s0, s2
   1154c:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11550:	ee37 7a67 	vsub.f32	s14, s14, s15
   11554:	ee60 7a21 	vmul.f32	s15, s0, s3
   11558:	ee60 6a81 	vmul.f32	s13, s1, s2
   1155c:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11560:	eeb4 7a67 	vcmp.f32	s14, s15
   11564:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11568:	d78e      	bvc.n	11488 <bsp_fft_radix2+0x5b8>
   1156a:	f7ef fb4d 	bl	c08 <__mulsc3>
   1156e:	eeb0 7a40 	vmov.f32	s14, s0
   11572:	eef0 7a60 	vmov.f32	s15, s1
   11576:	e787      	b.n	11488 <bsp_fft_radix2+0x5b8>
        X[0] = (complex_t) x[0];
   11578:	9b03      	ldr	r3, [sp, #12]
   1157a:	9a04      	ldr	r2, [sp, #16]
   1157c:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   11580:	ee07 3a90 	vmov	s15, r3
   11584:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11588:	edca 7a00 	vstr	s15, [sl]
   1158c:	2300      	movs	r3, #0
   1158e:	f8ca 3004 	str.w	r3, [sl, #4]
    for (uint16_t k = 0; k < idx; k++)
   11592:	f04f 0800 	mov.w	r8, #0
   11596:	f8dd 9004 	ldr.w	r9, [sp, #4]
   1159a:	e1c1      	b.n	11920 <bsp_fft_radix2+0xa50>
        X[0] = (complex_t) x[0];
   1159c:	9b03      	ldr	r3, [sp, #12]
   1159e:	9a04      	ldr	r2, [sp, #16]
   115a0:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   115a4:	ee07 3a90 	vmov	s15, r3
   115a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   115ac:	edca 7a00 	vstr	s15, [sl]
   115b0:	2300      	movs	r3, #0
   115b2:	f8ca 3004 	str.w	r3, [sl, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   115b6:	9b06      	ldr	r3, [sp, #24]
   115b8:	9a05      	ldr	r2, [sp, #20]
   115ba:	eb03 0642 	add.w	r6, r3, r2, lsl #1
   115be:	9b02      	ldr	r3, [sp, #8]
   115c0:	eb0a 08c3 	add.w	r8, sl, r3, lsl #3
    if (N == 1)
   115c4:	2b01      	cmp	r3, #1
   115c6:	f000 808d 	beq.w	116e4 <bsp_fft_radix2+0x814>
    uint16_t idx = N / 2U;
   115ca:	9b02      	ldr	r3, [sp, #8]
   115cc:	085d      	lsrs	r5, r3, #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   115ce:	9b07      	ldr	r3, [sp, #28]
   115d0:	005c      	lsls	r4, r3, #1
   115d2:	b2a7      	uxth	r7, r4
   115d4:	463b      	mov	r3, r7
   115d6:	462a      	mov	r2, r5
   115d8:	4641      	mov	r1, r8
   115da:	4630      	mov	r0, r6
   115dc:	f7ff fc78 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   115e0:	463b      	mov	r3, r7
   115e2:	462a      	mov	r2, r5
   115e4:	eb08 01c5 	add.w	r1, r8, r5, lsl #3
   115e8:	1930      	adds	r0, r6, r4
   115ea:	f7ff fc71 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   115ee:	2400      	movs	r4, #0
   115f0:	f8cd a00c 	str.w	sl, [sp, #12]
   115f4:	46d9      	mov	r9, fp
   115f6:	e09f      	b.n	11738 <bsp_fft_radix2+0x868>
        X[k + idx] = X[k] - z;
   115f8:	eb0a 03c8 	add.w	r3, sl, r8, lsl #3
   115fc:	ed93 6a00 	vldr	s12, [r3]
   11600:	ee36 6a47 	vsub.f32	s12, s12, s14
   11604:	edd3 6a01 	vldr	s13, [r3, #4]
   11608:	ee76 6ae7 	vsub.f32	s13, s13, s15
   1160c:	ed84 6a00 	vstr	s12, [r4]
   11610:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11614:	edd3 6a00 	vldr	s13, [r3]
   11618:	ee37 7a26 	vadd.f32	s14, s14, s13
   1161c:	edd3 6a01 	vldr	s13, [r3, #4]
   11620:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11624:	ed83 7a00 	vstr	s14, [r3]
   11628:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   1162c:	f108 0801 	add.w	r8, r8, #1
   11630:	fa1f f888 	uxth.w	r8, r8
   11634:	45c1      	cmp	r9, r8
   11636:	d9be      	bls.n	115b6 <bsp_fft_radix2+0x6e6>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11638:	ee07 8a90 	vmov	s15, r8
   1163c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11640:	ee17 0a90 	vmov	r0, s15
   11644:	f7ee feb0 	bl	3a8 <__aeabi_f2d>
   11648:	4606      	mov	r6, r0
   1164a:	460f      	mov	r7, r1
   1164c:	eddd 7a02 	vldr	s15, [sp, #8]
   11650:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11654:	ee17 0a90 	vmov	r0, s15
   11658:	f7ee fea6 	bl	3a8 <__aeabi_f2d>
   1165c:	4604      	mov	r4, r0
   1165e:	460d      	mov	r5, r1
   11660:	2200      	movs	r2, #0
   11662:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11666:	4630      	mov	r0, r6
   11668:	4639      	mov	r1, r7
   1166a:	f7ee fef5 	bl	458 <__aeabi_dmul>
   1166e:	4622      	mov	r2, r4
   11670:	462b      	mov	r3, r5
   11672:	f7ef f81b 	bl	6ac <__aeabi_ddiv>
   11676:	f7ef f901 	bl	87c <__aeabi_d2f>
   1167a:	ee08 0a90 	vmov	s17, r0
   1167e:	a3d4      	add	r3, pc, #848	; (adr r3, 119d0 <bsp_fft_radix2+0xb00>)
   11680:	e9d3 2300 	ldrd	r2, r3, [r3]
   11684:	4630      	mov	r0, r6
   11686:	4639      	mov	r1, r7
   11688:	f7ee fee6 	bl	458 <__aeabi_dmul>
   1168c:	4622      	mov	r2, r4
   1168e:	462b      	mov	r3, r5
   11690:	f7ef f80c 	bl	6ac <__aeabi_ddiv>
   11694:	f7ef f8f2 	bl	87c <__aeabi_d2f>
   11698:	eeb0 0a68 	vmov.f32	s0, s17
   1169c:	ee00 0a90 	vmov	s1, r0
   116a0:	f019 fa02 	bl	2aaa8 <cexpf>
   116a4:	eb08 0409 	add.w	r4, r8, r9
   116a8:	eb0a 04c4 	add.w	r4, sl, r4, lsl #3
   116ac:	ed94 1a00 	vldr	s2, [r4]
   116b0:	edd4 1a01 	vldr	s3, [r4, #4]
   116b4:	ee20 7a01 	vmul.f32	s14, s0, s2
   116b8:	ee60 7aa1 	vmul.f32	s15, s1, s3
   116bc:	ee37 7a67 	vsub.f32	s14, s14, s15
   116c0:	ee60 7a21 	vmul.f32	s15, s0, s3
   116c4:	ee60 6a81 	vmul.f32	s13, s1, s2
   116c8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   116cc:	eeb4 7a67 	vcmp.f32	s14, s15
   116d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   116d4:	d790      	bvc.n	115f8 <bsp_fft_radix2+0x728>
   116d6:	f7ef fa97 	bl	c08 <__mulsc3>
   116da:	eeb0 7a40 	vmov.f32	s14, s0
   116de:	eef0 7a60 	vmov.f32	s15, s1
   116e2:	e789      	b.n	115f8 <bsp_fft_radix2+0x728>
        X[0] = (complex_t) x[0];
   116e4:	9b06      	ldr	r3, [sp, #24]
   116e6:	9a05      	ldr	r2, [sp, #20]
   116e8:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   116ec:	ee07 3a90 	vmov	s15, r3
   116f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   116f4:	edc8 7a00 	vstr	s15, [r8]
   116f8:	2300      	movs	r3, #0
   116fa:	f8c8 3004 	str.w	r3, [r8, #4]
        return;
   116fe:	e075      	b.n	117ec <bsp_fft_radix2+0x91c>
        X[k + idx] = X[k] - z;
   11700:	eb08 03c4 	add.w	r3, r8, r4, lsl #3
   11704:	ed93 6a00 	vldr	s12, [r3]
   11708:	ee36 6a47 	vsub.f32	s12, s12, s14
   1170c:	edd3 6a01 	vldr	s13, [r3, #4]
   11710:	ee76 6ae7 	vsub.f32	s13, s13, s15
   11714:	ed86 6a00 	vstr	s12, [r6]
   11718:	edc6 6a01 	vstr	s13, [r6, #4]
        X[k]       = X[k] + z;
   1171c:	edd3 6a00 	vldr	s13, [r3]
   11720:	ee37 7a26 	vadd.f32	s14, s14, s13
   11724:	edd3 6a01 	vldr	s13, [r3, #4]
   11728:	ee77 7aa6 	vadd.f32	s15, s15, s13
   1172c:	ed83 7a00 	vstr	s14, [r3]
   11730:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   11734:	3401      	adds	r4, #1
   11736:	b2a4      	uxth	r4, r4
   11738:	42a5      	cmp	r5, r4
   1173a:	d954      	bls.n	117e6 <bsp_fft_radix2+0x916>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   1173c:	ee07 4a90 	vmov	s15, r4
   11740:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11744:	ee17 0a90 	vmov	r0, s15
   11748:	f7ee fe2e 	bl	3a8 <__aeabi_f2d>
   1174c:	4682      	mov	sl, r0
   1174e:	468b      	mov	fp, r1
   11750:	eddd 7a02 	vldr	s15, [sp, #8]
   11754:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11758:	ee17 0a90 	vmov	r0, s15
   1175c:	f7ee fe24 	bl	3a8 <__aeabi_f2d>
   11760:	4606      	mov	r6, r0
   11762:	460f      	mov	r7, r1
   11764:	2200      	movs	r2, #0
   11766:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1176a:	4650      	mov	r0, sl
   1176c:	4659      	mov	r1, fp
   1176e:	f7ee fe73 	bl	458 <__aeabi_dmul>
   11772:	4632      	mov	r2, r6
   11774:	463b      	mov	r3, r7
   11776:	f7ee ff99 	bl	6ac <__aeabi_ddiv>
   1177a:	f7ef f87f 	bl	87c <__aeabi_d2f>
   1177e:	ee08 0a90 	vmov	s17, r0
   11782:	a393      	add	r3, pc, #588	; (adr r3, 119d0 <bsp_fft_radix2+0xb00>)
   11784:	e9d3 2300 	ldrd	r2, r3, [r3]
   11788:	4650      	mov	r0, sl
   1178a:	4659      	mov	r1, fp
   1178c:	f7ee fe64 	bl	458 <__aeabi_dmul>
   11790:	4632      	mov	r2, r6
   11792:	463b      	mov	r3, r7
   11794:	f7ee ff8a 	bl	6ac <__aeabi_ddiv>
   11798:	f7ef f870 	bl	87c <__aeabi_d2f>
   1179c:	eeb0 0a68 	vmov.f32	s0, s17
   117a0:	ee00 0a90 	vmov	s1, r0
   117a4:	f019 f980 	bl	2aaa8 <cexpf>
   117a8:	1966      	adds	r6, r4, r5
   117aa:	eb08 06c6 	add.w	r6, r8, r6, lsl #3
   117ae:	ed96 1a00 	vldr	s2, [r6]
   117b2:	edd6 1a01 	vldr	s3, [r6, #4]
   117b6:	ee20 7a01 	vmul.f32	s14, s0, s2
   117ba:	ee60 7aa1 	vmul.f32	s15, s1, s3
   117be:	ee37 7a67 	vsub.f32	s14, s14, s15
   117c2:	ee60 7a21 	vmul.f32	s15, s0, s3
   117c6:	ee60 6a81 	vmul.f32	s13, s1, s2
   117ca:	ee77 7aa6 	vadd.f32	s15, s15, s13
   117ce:	eeb4 7a67 	vcmp.f32	s14, s15
   117d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   117d6:	d793      	bvc.n	11700 <bsp_fft_radix2+0x830>
   117d8:	f7ef fa16 	bl	c08 <__mulsc3>
   117dc:	eeb0 7a40 	vmov.f32	s14, s0
   117e0:	eef0 7a60 	vmov.f32	s15, s1
   117e4:	e78c      	b.n	11700 <bsp_fft_radix2+0x830>
   117e6:	f8dd a00c 	ldr.w	sl, [sp, #12]
   117ea:	46cb      	mov	fp, r9
    for (uint16_t k = 0; k < idx; k++)
   117ec:	f04f 0800 	mov.w	r8, #0
   117f0:	f8dd 9008 	ldr.w	r9, [sp, #8]
   117f4:	e01d      	b.n	11832 <bsp_fft_radix2+0x962>
        X[k + idx] = X[k] - z;
   117f6:	eb0a 03c8 	add.w	r3, sl, r8, lsl #3
   117fa:	ed93 6a00 	vldr	s12, [r3]
   117fe:	ee36 6a47 	vsub.f32	s12, s12, s14
   11802:	edd3 6a01 	vldr	s13, [r3, #4]
   11806:	ee76 6ae7 	vsub.f32	s13, s13, s15
   1180a:	ed84 6a00 	vstr	s12, [r4]
   1180e:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11812:	edd3 6a00 	vldr	s13, [r3]
   11816:	ee37 7a26 	vadd.f32	s14, s14, s13
   1181a:	edd3 6a01 	vldr	s13, [r3, #4]
   1181e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11822:	ed83 7a00 	vstr	s14, [r3]
   11826:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   1182a:	f108 0801 	add.w	r8, r8, #1
   1182e:	fa1f f888 	uxth.w	r8, r8
   11832:	45c1      	cmp	r9, r8
   11834:	f67f aead 	bls.w	11592 <bsp_fft_radix2+0x6c2>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11838:	ee07 8a90 	vmov	s15, r8
   1183c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11840:	ee17 0a90 	vmov	r0, s15
   11844:	f7ee fdb0 	bl	3a8 <__aeabi_f2d>
   11848:	4606      	mov	r6, r0
   1184a:	460f      	mov	r7, r1
   1184c:	eddd 7a01 	vldr	s15, [sp, #4]
   11850:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11854:	ee17 0a90 	vmov	r0, s15
   11858:	f7ee fda6 	bl	3a8 <__aeabi_f2d>
   1185c:	4604      	mov	r4, r0
   1185e:	460d      	mov	r5, r1
   11860:	2200      	movs	r2, #0
   11862:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11866:	4630      	mov	r0, r6
   11868:	4639      	mov	r1, r7
   1186a:	f7ee fdf5 	bl	458 <__aeabi_dmul>
   1186e:	4622      	mov	r2, r4
   11870:	462b      	mov	r3, r5
   11872:	f7ee ff1b 	bl	6ac <__aeabi_ddiv>
   11876:	f7ef f801 	bl	87c <__aeabi_d2f>
   1187a:	ee08 0a90 	vmov	s17, r0
   1187e:	a354      	add	r3, pc, #336	; (adr r3, 119d0 <bsp_fft_radix2+0xb00>)
   11880:	e9d3 2300 	ldrd	r2, r3, [r3]
   11884:	4630      	mov	r0, r6
   11886:	4639      	mov	r1, r7
   11888:	f7ee fde6 	bl	458 <__aeabi_dmul>
   1188c:	4622      	mov	r2, r4
   1188e:	462b      	mov	r3, r5
   11890:	f7ee ff0c 	bl	6ac <__aeabi_ddiv>
   11894:	f7ee fff2 	bl	87c <__aeabi_d2f>
   11898:	eeb0 0a68 	vmov.f32	s0, s17
   1189c:	ee00 0a90 	vmov	s1, r0
   118a0:	f019 f902 	bl	2aaa8 <cexpf>
   118a4:	eb08 0409 	add.w	r4, r8, r9
   118a8:	eb0a 04c4 	add.w	r4, sl, r4, lsl #3
   118ac:	ed94 1a00 	vldr	s2, [r4]
   118b0:	edd4 1a01 	vldr	s3, [r4, #4]
   118b4:	ee20 7a01 	vmul.f32	s14, s0, s2
   118b8:	ee60 7aa1 	vmul.f32	s15, s1, s3
   118bc:	ee37 7a67 	vsub.f32	s14, s14, s15
   118c0:	ee60 7a21 	vmul.f32	s15, s0, s3
   118c4:	ee60 6a81 	vmul.f32	s13, s1, s2
   118c8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   118cc:	eeb4 7a67 	vcmp.f32	s14, s15
   118d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   118d4:	d78f      	bvc.n	117f6 <bsp_fft_radix2+0x926>
   118d6:	f7ef f997 	bl	c08 <__mulsc3>
   118da:	eeb0 7a40 	vmov.f32	s14, s0
   118de:	eef0 7a60 	vmov.f32	s15, s1
   118e2:	e788      	b.n	117f6 <bsp_fft_radix2+0x926>
        X[k + idx] = X[k] - z;
   118e4:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   118e8:	ed93 6a00 	vldr	s12, [r3]
   118ec:	ee36 6a47 	vsub.f32	s12, s12, s14
   118f0:	edd3 6a01 	vldr	s13, [r3, #4]
   118f4:	ee76 6ae7 	vsub.f32	s13, s13, s15
   118f8:	ed84 6a00 	vstr	s12, [r4]
   118fc:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11900:	edd3 6a00 	vldr	s13, [r3]
   11904:	ee37 7a26 	vadd.f32	s14, s14, s13
   11908:	edd3 6a01 	vldr	s13, [r3, #4]
   1190c:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11910:	ed83 7a00 	vstr	s14, [r3]
   11914:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   11918:	f108 0801 	add.w	r8, r8, #1
   1191c:	fa1f f888 	uxth.w	r8, r8
   11920:	45c8      	cmp	r8, r9
   11922:	f4bf ab1d 	bcs.w	10f60 <bsp_fft_radix2+0x90>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11926:	ee07 8a90 	vmov	s15, r8
   1192a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1192e:	ee17 0a90 	vmov	r0, s15
   11932:	f7ee fd39 	bl	3a8 <__aeabi_f2d>
   11936:	4606      	mov	r6, r0
   11938:	460f      	mov	r7, r1
   1193a:	eef8 7a48 	vcvt.f32.u32	s15, s16
   1193e:	ee17 0a90 	vmov	r0, s15
   11942:	f7ee fd31 	bl	3a8 <__aeabi_f2d>
   11946:	4604      	mov	r4, r0
   11948:	460d      	mov	r5, r1
   1194a:	2200      	movs	r2, #0
   1194c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11950:	4630      	mov	r0, r6
   11952:	4639      	mov	r1, r7
   11954:	f7ee fd80 	bl	458 <__aeabi_dmul>
   11958:	4622      	mov	r2, r4
   1195a:	462b      	mov	r3, r5
   1195c:	f7ee fea6 	bl	6ac <__aeabi_ddiv>
   11960:	f7ee ff8c 	bl	87c <__aeabi_d2f>
   11964:	ee08 0a90 	vmov	s17, r0
   11968:	a319      	add	r3, pc, #100	; (adr r3, 119d0 <bsp_fft_radix2+0xb00>)
   1196a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1196e:	4630      	mov	r0, r6
   11970:	4639      	mov	r1, r7
   11972:	f7ee fd71 	bl	458 <__aeabi_dmul>
   11976:	4622      	mov	r2, r4
   11978:	462b      	mov	r3, r5
   1197a:	f7ee fe97 	bl	6ac <__aeabi_ddiv>
   1197e:	f7ee ff7d 	bl	87c <__aeabi_d2f>
   11982:	eeb0 0a68 	vmov.f32	s0, s17
   11986:	ee00 0a90 	vmov	s1, r0
   1198a:	f019 f88d 	bl	2aaa8 <cexpf>
   1198e:	eb08 0409 	add.w	r4, r8, r9
   11992:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   11996:	ed94 1a00 	vldr	s2, [r4]
   1199a:	edd4 1a01 	vldr	s3, [r4, #4]
   1199e:	ee20 7a01 	vmul.f32	s14, s0, s2
   119a2:	ee60 7aa1 	vmul.f32	s15, s1, s3
   119a6:	ee37 7a67 	vsub.f32	s14, s14, s15
   119aa:	ee60 7a21 	vmul.f32	s15, s0, s3
   119ae:	ee60 6a81 	vmul.f32	s13, s1, s2
   119b2:	ee77 7aa6 	vadd.f32	s15, s15, s13
   119b6:	eeb4 7a67 	vcmp.f32	s14, s15
   119ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   119be:	d791      	bvc.n	118e4 <bsp_fft_radix2+0xa14>
   119c0:	f7ef f922 	bl	c08 <__mulsc3>
   119c4:	eeb0 7a40 	vmov.f32	s14, s0
   119c8:	eef0 7a60 	vmov.f32	s15, s1
   119cc:	e78a      	b.n	118e4 <bsp_fft_radix2+0xa14>
   119ce:	bf00      	nop
   119d0:	54442d18 	.word	0x54442d18
   119d4:	c01921fb 	.word	0xc01921fb

000119d8 <bsp_fft>:
{
   119d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   119dc:	ed2d 8b02 	vpush	{d8}
   119e0:	b087      	sub	sp, #28
   119e2:	9003      	str	r0, [sp, #12]
   119e4:	4693      	mov	fp, r2
    if (N == 1)
   119e6:	2901      	cmp	r1, #1
   119e8:	d025      	beq.n	11a36 <bsp_fft+0x5e>
   119ea:	ee08 1a10 	vmov	s16, r1
    uint16_t idx = N / 2U;
   119ee:	084b      	lsrs	r3, r1, #1
   119f0:	9301      	str	r3, [sp, #4]
    if (N == 1)
   119f2:	2b01      	cmp	r3, #1
   119f4:	d02e      	beq.n	11a54 <bsp_fft+0x7c>
    uint16_t idx = N / 2U;
   119f6:	9b01      	ldr	r3, [sp, #4]
   119f8:	085b      	lsrs	r3, r3, #1
   119fa:	9302      	str	r3, [sp, #8]
    if (N == 1)
   119fc:	2b01      	cmp	r3, #1
   119fe:	d05e      	beq.n	11abe <bsp_fft+0xe6>
    uint16_t idx = N / 2U;
   11a00:	9b02      	ldr	r3, [sp, #8]
   11a02:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    if (N == 1)
   11a06:	f1ba 0f01 	cmp.w	sl, #1
   11a0a:	f000 8087 	beq.w	11b1c <bsp_fft+0x144>
    uint16_t idx = N / 2U;
   11a0e:	ea4f 095a 	mov.w	r9, sl, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   11a12:	2310      	movs	r3, #16
   11a14:	464a      	mov	r2, r9
   11a16:	4659      	mov	r1, fp
   11a18:	9c03      	ldr	r4, [sp, #12]
   11a1a:	4620      	mov	r0, r4
   11a1c:	f7ff fa58 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11a20:	2310      	movs	r3, #16
   11a22:	464a      	mov	r2, r9
   11a24:	eb0b 01c9 	add.w	r1, fp, r9, lsl #3
   11a28:	4620      	mov	r0, r4
   11a2a:	4418      	add	r0, r3
   11a2c:	f7ff fa50 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   11a30:	f04f 0800 	mov.w	r8, #0
   11a34:	e0b8      	b.n	11ba8 <bsp_fft+0x1d0>
        X[0] = (complex_t) x[0];
   11a36:	f9b0 3000 	ldrsh.w	r3, [r0]
   11a3a:	ee07 3a90 	vmov	s15, r3
   11a3e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11a42:	edc2 7a00 	vstr	s15, [r2]
   11a46:	2300      	movs	r3, #0
   11a48:	6053      	str	r3, [r2, #4]
}
   11a4a:	b007      	add	sp, #28
   11a4c:	ecbd 8b02 	vpop	{d8}
   11a50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        X[0] = (complex_t) x[0];
   11a54:	9b03      	ldr	r3, [sp, #12]
   11a56:	f9b3 3000 	ldrsh.w	r3, [r3]
   11a5a:	ee07 3a90 	vmov	s15, r3
   11a5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11a62:	edc2 7a00 	vstr	s15, [r2]
   11a66:	2300      	movs	r3, #0
   11a68:	6053      	str	r3, [r2, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11a6a:	9b03      	ldr	r3, [sp, #12]
   11a6c:	3302      	adds	r3, #2
   11a6e:	9305      	str	r3, [sp, #20]
   11a70:	9b01      	ldr	r3, [sp, #4]
   11a72:	eb0b 04c3 	add.w	r4, fp, r3, lsl #3
    if (N == 1)
   11a76:	2b01      	cmp	r3, #1
   11a78:	f000 8418 	beq.w	122ac <bsp_fft+0x8d4>
    uint16_t idx = N / 2U;
   11a7c:	9b01      	ldr	r3, [sp, #4]
   11a7e:	085b      	lsrs	r3, r3, #1
   11a80:	9302      	str	r3, [sp, #8]
    if (N == 1)
   11a82:	2b01      	cmp	r3, #1
   11a84:	f000 8423 	beq.w	122ce <bsp_fft+0x8f6>
    uint16_t idx = N / 2U;
   11a88:	9b02      	ldr	r3, [sp, #8]
   11a8a:	085b      	lsrs	r3, r3, #1
   11a8c:	9304      	str	r3, [sp, #16]
    if (N == 1)
   11a8e:	2b01      	cmp	r3, #1
   11a90:	f000 844e 	beq.w	12330 <bsp_fft+0x958>
    uint16_t idx = N / 2U;
   11a94:	9b04      	ldr	r3, [sp, #16]
   11a96:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   11a9a:	2310      	movs	r3, #16
   11a9c:	4652      	mov	r2, sl
   11a9e:	4621      	mov	r1, r4
   11aa0:	9d05      	ldr	r5, [sp, #20]
   11aa2:	4628      	mov	r0, r5
   11aa4:	f7ff fa14 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11aa8:	2310      	movs	r3, #16
   11aaa:	4652      	mov	r2, sl
   11aac:	eb04 01ca 	add.w	r1, r4, sl, lsl #3
   11ab0:	4628      	mov	r0, r5
   11ab2:	4418      	add	r0, r3
   11ab4:	f7ff fa0c 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   11ab8:	2500      	movs	r5, #0
   11aba:	f000 bc7d 	b.w	123b8 <bsp_fft+0x9e0>
        X[0] = (complex_t) x[0];
   11abe:	9b03      	ldr	r3, [sp, #12]
   11ac0:	f9b3 3000 	ldrsh.w	r3, [r3]
   11ac4:	ee07 3a90 	vmov	s15, r3
   11ac8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11acc:	edc2 7a00 	vstr	s15, [r2]
   11ad0:	2300      	movs	r3, #0
   11ad2:	6053      	str	r3, [r2, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11ad4:	9b03      	ldr	r3, [sp, #12]
   11ad6:	3304      	adds	r3, #4
   11ad8:	9305      	str	r3, [sp, #20]
   11ada:	9b02      	ldr	r3, [sp, #8]
   11adc:	eb0b 08c3 	add.w	r8, fp, r3, lsl #3
    if (N == 1)
   11ae0:	2b01      	cmp	r3, #1
   11ae2:	f000 81b6 	beq.w	11e52 <bsp_fft+0x47a>
    uint16_t idx = N / 2U;
   11ae6:	9b02      	ldr	r3, [sp, #8]
   11ae8:	085b      	lsrs	r3, r3, #1
   11aea:	9304      	str	r3, [sp, #16]
    if (N == 1)
   11aec:	2b01      	cmp	r3, #1
   11aee:	f000 81c1 	beq.w	11e74 <bsp_fft+0x49c>
    uint16_t idx = N / 2U;
   11af2:	9b04      	ldr	r3, [sp, #16]
   11af4:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   11af8:	2310      	movs	r3, #16
   11afa:	4652      	mov	r2, sl
   11afc:	4641      	mov	r1, r8
   11afe:	9c05      	ldr	r4, [sp, #20]
   11b00:	4620      	mov	r0, r4
   11b02:	f7ff f9e5 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11b06:	2310      	movs	r3, #16
   11b08:	4652      	mov	r2, sl
   11b0a:	eb08 01ca 	add.w	r1, r8, sl, lsl #3
   11b0e:	4620      	mov	r0, r4
   11b10:	4418      	add	r0, r3
   11b12:	f7ff f9dd 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   11b16:	f04f 0900 	mov.w	r9, #0
   11b1a:	e1f4      	b.n	11f06 <bsp_fft+0x52e>
        X[0] = (complex_t) x[0];
   11b1c:	9b03      	ldr	r3, [sp, #12]
   11b1e:	f9b3 3000 	ldrsh.w	r3, [r3]
   11b22:	ee07 3a90 	vmov	s15, r3
   11b26:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11b2a:	edc2 7a00 	vstr	s15, [r2]
   11b2e:	2300      	movs	r3, #0
   11b30:	6053      	str	r3, [r2, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11b32:	9b03      	ldr	r3, [sp, #12]
   11b34:	f103 0408 	add.w	r4, r3, #8
   11b38:	eb0b 07ca 	add.w	r7, fp, sl, lsl #3
    if (N == 1)
   11b3c:	f1ba 0f01 	cmp.w	sl, #1
   11b40:	f000 808b 	beq.w	11c5a <bsp_fft+0x282>
    uint16_t idx = N / 2U;
   11b44:	ea4f 055a 	mov.w	r5, sl, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   11b48:	2310      	movs	r3, #16
   11b4a:	462a      	mov	r2, r5
   11b4c:	4639      	mov	r1, r7
   11b4e:	4620      	mov	r0, r4
   11b50:	f7ff f9be 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11b54:	2310      	movs	r3, #16
   11b56:	462a      	mov	r2, r5
   11b58:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
   11b5c:	18e0      	adds	r0, r4, r3
   11b5e:	f7ff f9b7 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   11b62:	2400      	movs	r4, #0
   11b64:	f8cd a010 	str.w	sl, [sp, #16]
   11b68:	46ba      	mov	sl, r7
   11b6a:	e09d      	b.n	11ca8 <bsp_fft+0x2d0>
        X[k + idx] = X[k] - z;
   11b6c:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   11b70:	ed93 6a00 	vldr	s12, [r3]
   11b74:	ee36 6a47 	vsub.f32	s12, s12, s14
   11b78:	edd3 6a01 	vldr	s13, [r3, #4]
   11b7c:	ee76 6ae7 	vsub.f32	s13, s13, s15
   11b80:	ed84 6a00 	vstr	s12, [r4]
   11b84:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11b88:	edd3 6a00 	vldr	s13, [r3]
   11b8c:	ee37 7a26 	vadd.f32	s14, s14, s13
   11b90:	edd3 6a01 	vldr	s13, [r3, #4]
   11b94:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11b98:	ed83 7a00 	vstr	s14, [r3]
   11b9c:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   11ba0:	f108 0801 	add.w	r8, r8, #1
   11ba4:	fa1f f888 	uxth.w	r8, r8
   11ba8:	45c1      	cmp	r9, r8
   11baa:	d9c2      	bls.n	11b32 <bsp_fft+0x15a>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11bac:	ee07 8a90 	vmov	s15, r8
   11bb0:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11bb4:	ee17 0a90 	vmov	r0, s15
   11bb8:	f7ee fbf6 	bl	3a8 <__aeabi_f2d>
   11bbc:	4606      	mov	r6, r0
   11bbe:	460f      	mov	r7, r1
   11bc0:	ee07 aa90 	vmov	s15, sl
   11bc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11bc8:	ee17 0a90 	vmov	r0, s15
   11bcc:	f7ee fbec 	bl	3a8 <__aeabi_f2d>
   11bd0:	4604      	mov	r4, r0
   11bd2:	460d      	mov	r5, r1
   11bd4:	2200      	movs	r2, #0
   11bd6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11bda:	4630      	mov	r0, r6
   11bdc:	4639      	mov	r1, r7
   11bde:	f7ee fc3b 	bl	458 <__aeabi_dmul>
   11be2:	4622      	mov	r2, r4
   11be4:	462b      	mov	r3, r5
   11be6:	f7ee fd61 	bl	6ac <__aeabi_ddiv>
   11bea:	f7ee fe47 	bl	87c <__aeabi_d2f>
   11bee:	ee08 0a90 	vmov	s17, r0
   11bf2:	f60f 63c4 	addw	r3, pc, #3780	; 0xec4
   11bf6:	e9d3 2300 	ldrd	r2, r3, [r3]
   11bfa:	4630      	mov	r0, r6
   11bfc:	4639      	mov	r1, r7
   11bfe:	f7ee fc2b 	bl	458 <__aeabi_dmul>
   11c02:	4622      	mov	r2, r4
   11c04:	462b      	mov	r3, r5
   11c06:	f7ee fd51 	bl	6ac <__aeabi_ddiv>
   11c0a:	f7ee fe37 	bl	87c <__aeabi_d2f>
   11c0e:	eeb0 0a68 	vmov.f32	s0, s17
   11c12:	ee00 0a90 	vmov	s1, r0
   11c16:	f018 ff47 	bl	2aaa8 <cexpf>
   11c1a:	eb08 0409 	add.w	r4, r8, r9
   11c1e:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   11c22:	ed94 1a00 	vldr	s2, [r4]
   11c26:	edd4 1a01 	vldr	s3, [r4, #4]
   11c2a:	ee20 7a01 	vmul.f32	s14, s0, s2
   11c2e:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11c32:	ee37 7a67 	vsub.f32	s14, s14, s15
   11c36:	ee60 7a21 	vmul.f32	s15, s0, s3
   11c3a:	ee60 6a81 	vmul.f32	s13, s1, s2
   11c3e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11c42:	eeb4 7a67 	vcmp.f32	s14, s15
   11c46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11c4a:	d78f      	bvc.n	11b6c <bsp_fft+0x194>
   11c4c:	f7ee ffdc 	bl	c08 <__mulsc3>
   11c50:	eeb0 7a40 	vmov.f32	s14, s0
   11c54:	eef0 7a60 	vmov.f32	s15, s1
   11c58:	e788      	b.n	11b6c <bsp_fft+0x194>
        X[0] = (complex_t) x[0];
   11c5a:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
   11c5e:	ee07 3a90 	vmov	s15, r3
   11c62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11c66:	edc7 7a00 	vstr	s15, [r7]
   11c6a:	2300      	movs	r3, #0
   11c6c:	607b      	str	r3, [r7, #4]
        return;
   11c6e:	e075      	b.n	11d5c <bsp_fft+0x384>
        X[k + idx] = X[k] - z;
   11c70:	eb0a 03c4 	add.w	r3, sl, r4, lsl #3
   11c74:	ed93 6a00 	vldr	s12, [r3]
   11c78:	ee36 6a47 	vsub.f32	s12, s12, s14
   11c7c:	edd3 6a01 	vldr	s13, [r3, #4]
   11c80:	ee76 6ae7 	vsub.f32	s13, s13, s15
   11c84:	ed86 6a00 	vstr	s12, [r6]
   11c88:	edc6 6a01 	vstr	s13, [r6, #4]
        X[k]       = X[k] + z;
   11c8c:	edd3 6a00 	vldr	s13, [r3]
   11c90:	ee37 7a26 	vadd.f32	s14, s14, s13
   11c94:	edd3 6a01 	vldr	s13, [r3, #4]
   11c98:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11c9c:	ed83 7a00 	vstr	s14, [r3]
   11ca0:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   11ca4:	3401      	adds	r4, #1
   11ca6:	b2a4      	uxth	r4, r4
   11ca8:	42a5      	cmp	r5, r4
   11caa:	d955      	bls.n	11d58 <bsp_fft+0x380>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11cac:	ee07 4a90 	vmov	s15, r4
   11cb0:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11cb4:	ee17 0a90 	vmov	r0, s15
   11cb8:	f7ee fb76 	bl	3a8 <__aeabi_f2d>
   11cbc:	4680      	mov	r8, r0
   11cbe:	4689      	mov	r9, r1
   11cc0:	eddd 7a04 	vldr	s15, [sp, #16]
   11cc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11cc8:	ee17 0a90 	vmov	r0, s15
   11ccc:	f7ee fb6c 	bl	3a8 <__aeabi_f2d>
   11cd0:	4606      	mov	r6, r0
   11cd2:	460f      	mov	r7, r1
   11cd4:	2200      	movs	r2, #0
   11cd6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11cda:	4640      	mov	r0, r8
   11cdc:	4649      	mov	r1, r9
   11cde:	f7ee fbbb 	bl	458 <__aeabi_dmul>
   11ce2:	4632      	mov	r2, r6
   11ce4:	463b      	mov	r3, r7
   11ce6:	f7ee fce1 	bl	6ac <__aeabi_ddiv>
   11cea:	f7ee fdc7 	bl	87c <__aeabi_d2f>
   11cee:	ee08 0a90 	vmov	s17, r0
   11cf2:	f60f 53c4 	addw	r3, pc, #3524	; 0xdc4
   11cf6:	e9d3 2300 	ldrd	r2, r3, [r3]
   11cfa:	4640      	mov	r0, r8
   11cfc:	4649      	mov	r1, r9
   11cfe:	f7ee fbab 	bl	458 <__aeabi_dmul>
   11d02:	4632      	mov	r2, r6
   11d04:	463b      	mov	r3, r7
   11d06:	f7ee fcd1 	bl	6ac <__aeabi_ddiv>
   11d0a:	f7ee fdb7 	bl	87c <__aeabi_d2f>
   11d0e:	eeb0 0a68 	vmov.f32	s0, s17
   11d12:	ee00 0a90 	vmov	s1, r0
   11d16:	f018 fec7 	bl	2aaa8 <cexpf>
   11d1a:	1966      	adds	r6, r4, r5
   11d1c:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
   11d20:	ed96 1a00 	vldr	s2, [r6]
   11d24:	edd6 1a01 	vldr	s3, [r6, #4]
   11d28:	ee20 7a01 	vmul.f32	s14, s0, s2
   11d2c:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11d30:	ee37 7a67 	vsub.f32	s14, s14, s15
   11d34:	ee60 7a21 	vmul.f32	s15, s0, s3
   11d38:	ee60 6a81 	vmul.f32	s13, s1, s2
   11d3c:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11d40:	eeb4 7a67 	vcmp.f32	s14, s15
   11d44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11d48:	d792      	bvc.n	11c70 <bsp_fft+0x298>
   11d4a:	f7ee ff5d 	bl	c08 <__mulsc3>
   11d4e:	eeb0 7a40 	vmov.f32	s14, s0
   11d52:	eef0 7a60 	vmov.f32	s15, s1
   11d56:	e78b      	b.n	11c70 <bsp_fft+0x298>
   11d58:	f8dd a010 	ldr.w	sl, [sp, #16]
    for (uint16_t k = 0; k < idx; k++)
   11d5c:	f04f 0800 	mov.w	r8, #0
   11d60:	e01d      	b.n	11d9e <bsp_fft+0x3c6>
        X[k + idx] = X[k] - z;
   11d62:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   11d66:	ed93 6a00 	vldr	s12, [r3]
   11d6a:	ee36 6a47 	vsub.f32	s12, s12, s14
   11d6e:	edd3 6a01 	vldr	s13, [r3, #4]
   11d72:	ee76 6ae7 	vsub.f32	s13, s13, s15
   11d76:	ed84 6a00 	vstr	s12, [r4]
   11d7a:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11d7e:	edd3 6a00 	vldr	s13, [r3]
   11d82:	ee37 7a26 	vadd.f32	s14, s14, s13
   11d86:	edd3 6a01 	vldr	s13, [r3, #4]
   11d8a:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11d8e:	ed83 7a00 	vstr	s14, [r3]
   11d92:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   11d96:	f108 0801 	add.w	r8, r8, #1
   11d9a:	fa1f f888 	uxth.w	r8, r8
   11d9e:	45c2      	cmp	sl, r8
   11da0:	f67f ae98 	bls.w	11ad4 <bsp_fft+0xfc>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11da4:	ee07 8a90 	vmov	s15, r8
   11da8:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11dac:	ee17 0a90 	vmov	r0, s15
   11db0:	f7ee fafa 	bl	3a8 <__aeabi_f2d>
   11db4:	4606      	mov	r6, r0
   11db6:	460f      	mov	r7, r1
   11db8:	eddd 7a02 	vldr	s15, [sp, #8]
   11dbc:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11dc0:	ee17 0a90 	vmov	r0, s15
   11dc4:	f7ee faf0 	bl	3a8 <__aeabi_f2d>
   11dc8:	4604      	mov	r4, r0
   11dca:	460d      	mov	r5, r1
   11dcc:	2200      	movs	r2, #0
   11dce:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11dd2:	4630      	mov	r0, r6
   11dd4:	4639      	mov	r1, r7
   11dd6:	f7ee fb3f 	bl	458 <__aeabi_dmul>
   11dda:	4622      	mov	r2, r4
   11ddc:	462b      	mov	r3, r5
   11dde:	f7ee fc65 	bl	6ac <__aeabi_ddiv>
   11de2:	f7ee fd4b 	bl	87c <__aeabi_d2f>
   11de6:	ee08 0a90 	vmov	s17, r0
   11dea:	f60f 43cc 	addw	r3, pc, #3276	; 0xccc
   11dee:	e9d3 2300 	ldrd	r2, r3, [r3]
   11df2:	4630      	mov	r0, r6
   11df4:	4639      	mov	r1, r7
   11df6:	f7ee fb2f 	bl	458 <__aeabi_dmul>
   11dfa:	4622      	mov	r2, r4
   11dfc:	462b      	mov	r3, r5
   11dfe:	f7ee fc55 	bl	6ac <__aeabi_ddiv>
   11e02:	f7ee fd3b 	bl	87c <__aeabi_d2f>
   11e06:	eeb0 0a68 	vmov.f32	s0, s17
   11e0a:	ee00 0a90 	vmov	s1, r0
   11e0e:	f018 fe4b 	bl	2aaa8 <cexpf>
   11e12:	eb08 040a 	add.w	r4, r8, sl
   11e16:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   11e1a:	ed94 1a00 	vldr	s2, [r4]
   11e1e:	edd4 1a01 	vldr	s3, [r4, #4]
   11e22:	ee20 7a01 	vmul.f32	s14, s0, s2
   11e26:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11e2a:	ee37 7a67 	vsub.f32	s14, s14, s15
   11e2e:	ee60 7a21 	vmul.f32	s15, s0, s3
   11e32:	ee60 6a81 	vmul.f32	s13, s1, s2
   11e36:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11e3a:	eeb4 7a67 	vcmp.f32	s14, s15
   11e3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11e42:	d78e      	bvc.n	11d62 <bsp_fft+0x38a>
   11e44:	f7ee fee0 	bl	c08 <__mulsc3>
   11e48:	eeb0 7a40 	vmov.f32	s14, s0
   11e4c:	eef0 7a60 	vmov.f32	s15, s1
   11e50:	e787      	b.n	11d62 <bsp_fft+0x38a>
        X[0] = (complex_t) x[0];
   11e52:	9b03      	ldr	r3, [sp, #12]
   11e54:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
   11e58:	ee07 3a90 	vmov	s15, r3
   11e5c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11e60:	edc8 7a00 	vstr	s15, [r8]
   11e64:	2300      	movs	r3, #0
   11e66:	f8c8 3004 	str.w	r3, [r8, #4]
    for (uint16_t k = 0; k < idx; k++)
   11e6a:	f04f 0800 	mov.w	r8, #0
   11e6e:	f8dd 9008 	ldr.w	r9, [sp, #8]
   11e72:	e1c1      	b.n	121f8 <bsp_fft+0x820>
        X[0] = (complex_t) x[0];
   11e74:	9b03      	ldr	r3, [sp, #12]
   11e76:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
   11e7a:	ee07 3a90 	vmov	s15, r3
   11e7e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11e82:	edc8 7a00 	vstr	s15, [r8]
   11e86:	2300      	movs	r3, #0
   11e88:	f8c8 3004 	str.w	r3, [r8, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11e8c:	9b05      	ldr	r3, [sp, #20]
   11e8e:	f103 0408 	add.w	r4, r3, #8
   11e92:	9b04      	ldr	r3, [sp, #16]
   11e94:	eb08 05c3 	add.w	r5, r8, r3, lsl #3
    if (N == 1)
   11e98:	2b01      	cmp	r3, #1
   11e9a:	f000 808d 	beq.w	11fb8 <bsp_fft+0x5e0>
    uint16_t idx = N / 2U;
   11e9e:	9b04      	ldr	r3, [sp, #16]
   11ea0:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   11ea4:	2310      	movs	r3, #16
   11ea6:	4652      	mov	r2, sl
   11ea8:	4629      	mov	r1, r5
   11eaa:	4620      	mov	r0, r4
   11eac:	f7ff f810 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   11eb0:	2310      	movs	r3, #16
   11eb2:	4652      	mov	r2, sl
   11eb4:	eb05 01ca 	add.w	r1, r5, sl, lsl #3
   11eb8:	18e0      	adds	r0, r4, r3
   11eba:	f7ff f809 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   11ebe:	f04f 0900 	mov.w	r9, #0
   11ec2:	f8cd 8014 	str.w	r8, [sp, #20]
   11ec6:	46a8      	mov	r8, r5
   11ec8:	e0a0      	b.n	1200c <bsp_fft+0x634>
        X[k + idx] = X[k] - z;
   11eca:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   11ece:	ed93 6a00 	vldr	s12, [r3]
   11ed2:	ee36 6a47 	vsub.f32	s12, s12, s14
   11ed6:	edd3 6a01 	vldr	s13, [r3, #4]
   11eda:	ee76 6ae7 	vsub.f32	s13, s13, s15
   11ede:	ed84 6a00 	vstr	s12, [r4]
   11ee2:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11ee6:	edd3 6a00 	vldr	s13, [r3]
   11eea:	ee37 7a26 	vadd.f32	s14, s14, s13
   11eee:	edd3 6a01 	vldr	s13, [r3, #4]
   11ef2:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11ef6:	ed83 7a00 	vstr	s14, [r3]
   11efa:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   11efe:	f109 0901 	add.w	r9, r9, #1
   11f02:	fa1f f989 	uxth.w	r9, r9
   11f06:	45ca      	cmp	sl, r9
   11f08:	d9c0      	bls.n	11e8c <bsp_fft+0x4b4>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   11f0a:	ee07 9a90 	vmov	s15, r9
   11f0e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11f12:	ee17 0a90 	vmov	r0, s15
   11f16:	f7ee fa47 	bl	3a8 <__aeabi_f2d>
   11f1a:	4606      	mov	r6, r0
   11f1c:	460f      	mov	r7, r1
   11f1e:	eddd 7a04 	vldr	s15, [sp, #16]
   11f22:	eef8 7a67 	vcvt.f32.u32	s15, s15
   11f26:	ee17 0a90 	vmov	r0, s15
   11f2a:	f7ee fa3d 	bl	3a8 <__aeabi_f2d>
   11f2e:	4604      	mov	r4, r0
   11f30:	460d      	mov	r5, r1
   11f32:	2200      	movs	r2, #0
   11f34:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   11f38:	4630      	mov	r0, r6
   11f3a:	4639      	mov	r1, r7
   11f3c:	f7ee fa8c 	bl	458 <__aeabi_dmul>
   11f40:	4622      	mov	r2, r4
   11f42:	462b      	mov	r3, r5
   11f44:	f7ee fbb2 	bl	6ac <__aeabi_ddiv>
   11f48:	f7ee fc98 	bl	87c <__aeabi_d2f>
   11f4c:	ee08 0a90 	vmov	s17, r0
   11f50:	f60f 3364 	addw	r3, pc, #2916	; 0xb64
   11f54:	e9d3 2300 	ldrd	r2, r3, [r3]
   11f58:	4630      	mov	r0, r6
   11f5a:	4639      	mov	r1, r7
   11f5c:	f7ee fa7c 	bl	458 <__aeabi_dmul>
   11f60:	4622      	mov	r2, r4
   11f62:	462b      	mov	r3, r5
   11f64:	f7ee fba2 	bl	6ac <__aeabi_ddiv>
   11f68:	f7ee fc88 	bl	87c <__aeabi_d2f>
   11f6c:	eeb0 0a68 	vmov.f32	s0, s17
   11f70:	ee00 0a90 	vmov	s1, r0
   11f74:	f018 fd98 	bl	2aaa8 <cexpf>
   11f78:	eb09 040a 	add.w	r4, r9, sl
   11f7c:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
   11f80:	ed94 1a00 	vldr	s2, [r4]
   11f84:	edd4 1a01 	vldr	s3, [r4, #4]
   11f88:	ee20 7a01 	vmul.f32	s14, s0, s2
   11f8c:	ee60 7aa1 	vmul.f32	s15, s1, s3
   11f90:	ee37 7a67 	vsub.f32	s14, s14, s15
   11f94:	ee60 7a21 	vmul.f32	s15, s0, s3
   11f98:	ee60 6a81 	vmul.f32	s13, s1, s2
   11f9c:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11fa0:	eeb4 7a67 	vcmp.f32	s14, s15
   11fa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11fa8:	d78f      	bvc.n	11eca <bsp_fft+0x4f2>
   11faa:	f7ee fe2d 	bl	c08 <__mulsc3>
   11fae:	eeb0 7a40 	vmov.f32	s14, s0
   11fb2:	eef0 7a60 	vmov.f32	s15, s1
   11fb6:	e788      	b.n	11eca <bsp_fft+0x4f2>
        X[0] = (complex_t) x[0];
   11fb8:	9b05      	ldr	r3, [sp, #20]
   11fba:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
   11fbe:	ee07 3a90 	vmov	s15, r3
   11fc2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   11fc6:	edc5 7a00 	vstr	s15, [r5]
   11fca:	2300      	movs	r3, #0
   11fcc:	606b      	str	r3, [r5, #4]
        return;
   11fce:	e078      	b.n	120c2 <bsp_fft+0x6ea>
        X[k + idx] = X[k] - z;
   11fd0:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   11fd4:	ed93 6a00 	vldr	s12, [r3]
   11fd8:	ee36 6a47 	vsub.f32	s12, s12, s14
   11fdc:	edd3 6a01 	vldr	s13, [r3, #4]
   11fe0:	ee76 6ae7 	vsub.f32	s13, s13, s15
   11fe4:	ed84 6a00 	vstr	s12, [r4]
   11fe8:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   11fec:	edd3 6a00 	vldr	s13, [r3]
   11ff0:	ee37 7a26 	vadd.f32	s14, s14, s13
   11ff4:	edd3 6a01 	vldr	s13, [r3, #4]
   11ff8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   11ffc:	ed83 7a00 	vstr	s14, [r3]
   12000:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   12004:	f109 0901 	add.w	r9, r9, #1
   12008:	fa1f f989 	uxth.w	r9, r9
   1200c:	45ca      	cmp	sl, r9
   1200e:	d956      	bls.n	120be <bsp_fft+0x6e6>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   12010:	ee07 9a90 	vmov	s15, r9
   12014:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12018:	ee17 0a90 	vmov	r0, s15
   1201c:	f7ee f9c4 	bl	3a8 <__aeabi_f2d>
   12020:	4606      	mov	r6, r0
   12022:	460f      	mov	r7, r1
   12024:	eddd 7a04 	vldr	s15, [sp, #16]
   12028:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1202c:	ee17 0a90 	vmov	r0, s15
   12030:	f7ee f9ba 	bl	3a8 <__aeabi_f2d>
   12034:	4604      	mov	r4, r0
   12036:	460d      	mov	r5, r1
   12038:	2200      	movs	r2, #0
   1203a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1203e:	4630      	mov	r0, r6
   12040:	4639      	mov	r1, r7
   12042:	f7ee fa09 	bl	458 <__aeabi_dmul>
   12046:	4622      	mov	r2, r4
   12048:	462b      	mov	r3, r5
   1204a:	f7ee fb2f 	bl	6ac <__aeabi_ddiv>
   1204e:	f7ee fc15 	bl	87c <__aeabi_d2f>
   12052:	ee08 0a90 	vmov	s17, r0
   12056:	f60f 2360 	addw	r3, pc, #2656	; 0xa60
   1205a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1205e:	4630      	mov	r0, r6
   12060:	4639      	mov	r1, r7
   12062:	f7ee f9f9 	bl	458 <__aeabi_dmul>
   12066:	4622      	mov	r2, r4
   12068:	462b      	mov	r3, r5
   1206a:	f7ee fb1f 	bl	6ac <__aeabi_ddiv>
   1206e:	f7ee fc05 	bl	87c <__aeabi_d2f>
   12072:	eeb0 0a68 	vmov.f32	s0, s17
   12076:	ee00 0a90 	vmov	s1, r0
   1207a:	f018 fd15 	bl	2aaa8 <cexpf>
   1207e:	eb09 040a 	add.w	r4, r9, sl
   12082:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
   12086:	ed94 1a00 	vldr	s2, [r4]
   1208a:	edd4 1a01 	vldr	s3, [r4, #4]
   1208e:	ee20 7a01 	vmul.f32	s14, s0, s2
   12092:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12096:	ee37 7a67 	vsub.f32	s14, s14, s15
   1209a:	ee60 7a21 	vmul.f32	s15, s0, s3
   1209e:	ee60 6a81 	vmul.f32	s13, s1, s2
   120a2:	ee77 7aa6 	vadd.f32	s15, s15, s13
   120a6:	eeb4 7a67 	vcmp.f32	s14, s15
   120aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   120ae:	d78f      	bvc.n	11fd0 <bsp_fft+0x5f8>
   120b0:	f7ee fdaa 	bl	c08 <__mulsc3>
   120b4:	eeb0 7a40 	vmov.f32	s14, s0
   120b8:	eef0 7a60 	vmov.f32	s15, s1
   120bc:	e788      	b.n	11fd0 <bsp_fft+0x5f8>
   120be:	f8dd 8014 	ldr.w	r8, [sp, #20]
    for (uint16_t k = 0; k < idx; k++)
   120c2:	f04f 0900 	mov.w	r9, #0
   120c6:	f8dd a010 	ldr.w	sl, [sp, #16]
   120ca:	e01d      	b.n	12108 <bsp_fft+0x730>
        X[k + idx] = X[k] - z;
   120cc:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   120d0:	ed93 6a00 	vldr	s12, [r3]
   120d4:	ee36 6a47 	vsub.f32	s12, s12, s14
   120d8:	edd3 6a01 	vldr	s13, [r3, #4]
   120dc:	ee76 6ae7 	vsub.f32	s13, s13, s15
   120e0:	ed84 6a00 	vstr	s12, [r4]
   120e4:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   120e8:	edd3 6a00 	vldr	s13, [r3]
   120ec:	ee37 7a26 	vadd.f32	s14, s14, s13
   120f0:	edd3 6a01 	vldr	s13, [r3, #4]
   120f4:	ee77 7aa6 	vadd.f32	s15, s15, s13
   120f8:	ed83 7a00 	vstr	s14, [r3]
   120fc:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   12100:	f109 0901 	add.w	r9, r9, #1
   12104:	fa1f f989 	uxth.w	r9, r9
   12108:	45ca      	cmp	sl, r9
   1210a:	f67f aeae 	bls.w	11e6a <bsp_fft+0x492>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   1210e:	ee07 9a90 	vmov	s15, r9
   12112:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12116:	ee17 0a90 	vmov	r0, s15
   1211a:	f7ee f945 	bl	3a8 <__aeabi_f2d>
   1211e:	4606      	mov	r6, r0
   12120:	460f      	mov	r7, r1
   12122:	eddd 7a02 	vldr	s15, [sp, #8]
   12126:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1212a:	ee17 0a90 	vmov	r0, s15
   1212e:	f7ee f93b 	bl	3a8 <__aeabi_f2d>
   12132:	4604      	mov	r4, r0
   12134:	460d      	mov	r5, r1
   12136:	2200      	movs	r2, #0
   12138:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1213c:	4630      	mov	r0, r6
   1213e:	4639      	mov	r1, r7
   12140:	f7ee f98a 	bl	458 <__aeabi_dmul>
   12144:	4622      	mov	r2, r4
   12146:	462b      	mov	r3, r5
   12148:	f7ee fab0 	bl	6ac <__aeabi_ddiv>
   1214c:	f7ee fb96 	bl	87c <__aeabi_d2f>
   12150:	ee08 0a90 	vmov	s17, r0
   12154:	f60f 1360 	addw	r3, pc, #2400	; 0x960
   12158:	e9d3 2300 	ldrd	r2, r3, [r3]
   1215c:	4630      	mov	r0, r6
   1215e:	4639      	mov	r1, r7
   12160:	f7ee f97a 	bl	458 <__aeabi_dmul>
   12164:	4622      	mov	r2, r4
   12166:	462b      	mov	r3, r5
   12168:	f7ee faa0 	bl	6ac <__aeabi_ddiv>
   1216c:	f7ee fb86 	bl	87c <__aeabi_d2f>
   12170:	eeb0 0a68 	vmov.f32	s0, s17
   12174:	ee00 0a90 	vmov	s1, r0
   12178:	f018 fc96 	bl	2aaa8 <cexpf>
   1217c:	eb09 040a 	add.w	r4, r9, sl
   12180:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
   12184:	ed94 1a00 	vldr	s2, [r4]
   12188:	edd4 1a01 	vldr	s3, [r4, #4]
   1218c:	ee20 7a01 	vmul.f32	s14, s0, s2
   12190:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12194:	ee37 7a67 	vsub.f32	s14, s14, s15
   12198:	ee60 7a21 	vmul.f32	s15, s0, s3
   1219c:	ee60 6a81 	vmul.f32	s13, s1, s2
   121a0:	ee77 7aa6 	vadd.f32	s15, s15, s13
   121a4:	eeb4 7a67 	vcmp.f32	s14, s15
   121a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   121ac:	d78e      	bvc.n	120cc <bsp_fft+0x6f4>
   121ae:	f7ee fd2b 	bl	c08 <__mulsc3>
   121b2:	eeb0 7a40 	vmov.f32	s14, s0
   121b6:	eef0 7a60 	vmov.f32	s15, s1
   121ba:	e787      	b.n	120cc <bsp_fft+0x6f4>
        X[k + idx] = X[k] - z;
   121bc:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   121c0:	ed93 6a00 	vldr	s12, [r3]
   121c4:	ee36 6a47 	vsub.f32	s12, s12, s14
   121c8:	edd3 6a01 	vldr	s13, [r3, #4]
   121cc:	ee76 6ae7 	vsub.f32	s13, s13, s15
   121d0:	ed84 6a00 	vstr	s12, [r4]
   121d4:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   121d8:	edd3 6a00 	vldr	s13, [r3]
   121dc:	ee37 7a26 	vadd.f32	s14, s14, s13
   121e0:	edd3 6a01 	vldr	s13, [r3, #4]
   121e4:	ee77 7aa6 	vadd.f32	s15, s15, s13
   121e8:	ed83 7a00 	vstr	s14, [r3]
   121ec:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   121f0:	f108 0801 	add.w	r8, r8, #1
   121f4:	fa1f f888 	uxth.w	r8, r8
   121f8:	45c1      	cmp	r9, r8
   121fa:	f67f ac36 	bls.w	11a6a <bsp_fft+0x92>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   121fe:	ee07 8a90 	vmov	s15, r8
   12202:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12206:	ee17 0a90 	vmov	r0, s15
   1220a:	f7ee f8cd 	bl	3a8 <__aeabi_f2d>
   1220e:	4606      	mov	r6, r0
   12210:	460f      	mov	r7, r1
   12212:	eddd 7a01 	vldr	s15, [sp, #4]
   12216:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1221a:	ee17 0a90 	vmov	r0, s15
   1221e:	f7ee f8c3 	bl	3a8 <__aeabi_f2d>
   12222:	4604      	mov	r4, r0
   12224:	460d      	mov	r5, r1
   12226:	2200      	movs	r2, #0
   12228:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   1222c:	4630      	mov	r0, r6
   1222e:	4639      	mov	r1, r7
   12230:	f7ee f912 	bl	458 <__aeabi_dmul>
   12234:	4622      	mov	r2, r4
   12236:	462b      	mov	r3, r5
   12238:	f7ee fa38 	bl	6ac <__aeabi_ddiv>
   1223c:	f7ee fb1e 	bl	87c <__aeabi_d2f>
   12240:	ee08 0a90 	vmov	s17, r0
   12244:	f60f 0370 	addw	r3, pc, #2160	; 0x870
   12248:	e9d3 2300 	ldrd	r2, r3, [r3]
   1224c:	4630      	mov	r0, r6
   1224e:	4639      	mov	r1, r7
   12250:	f7ee f902 	bl	458 <__aeabi_dmul>
   12254:	4622      	mov	r2, r4
   12256:	462b      	mov	r3, r5
   12258:	f7ee fa28 	bl	6ac <__aeabi_ddiv>
   1225c:	f7ee fb0e 	bl	87c <__aeabi_d2f>
   12260:	eeb0 0a68 	vmov.f32	s0, s17
   12264:	ee00 0a90 	vmov	s1, r0
   12268:	f018 fc1e 	bl	2aaa8 <cexpf>
   1226c:	eb08 0409 	add.w	r4, r8, r9
   12270:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   12274:	ed94 1a00 	vldr	s2, [r4]
   12278:	edd4 1a01 	vldr	s3, [r4, #4]
   1227c:	ee20 7a01 	vmul.f32	s14, s0, s2
   12280:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12284:	ee37 7a67 	vsub.f32	s14, s14, s15
   12288:	ee60 7a21 	vmul.f32	s15, s0, s3
   1228c:	ee60 6a81 	vmul.f32	s13, s1, s2
   12290:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12294:	eeb4 7a67 	vcmp.f32	s14, s15
   12298:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1229c:	d78e      	bvc.n	121bc <bsp_fft+0x7e4>
   1229e:	f7ee fcb3 	bl	c08 <__mulsc3>
   122a2:	eeb0 7a40 	vmov.f32	s14, s0
   122a6:	eef0 7a60 	vmov.f32	s15, s1
   122aa:	e787      	b.n	121bc <bsp_fft+0x7e4>
        X[0] = (complex_t) x[0];
   122ac:	9b03      	ldr	r3, [sp, #12]
   122ae:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   122b2:	ee07 3a90 	vmov	s15, r3
   122b6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   122ba:	edc4 7a00 	vstr	s15, [r4]
   122be:	2300      	movs	r3, #0
   122c0:	6063      	str	r3, [r4, #4]
    for (uint16_t k = 0; k < idx; k++)
   122c2:	f04f 0800 	mov.w	r8, #0
   122c6:	f8dd 9004 	ldr.w	r9, [sp, #4]
   122ca:	f000 bc17 	b.w	12afc <bsp_fft+0x1124>
        X[0] = (complex_t) x[0];
   122ce:	9b03      	ldr	r3, [sp, #12]
   122d0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   122d4:	ee07 3a90 	vmov	s15, r3
   122d8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   122dc:	edc4 7a00 	vstr	s15, [r4]
   122e0:	2300      	movs	r3, #0
   122e2:	6063      	str	r3, [r4, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   122e4:	9b05      	ldr	r3, [sp, #20]
   122e6:	3304      	adds	r3, #4
   122e8:	9304      	str	r3, [sp, #16]
   122ea:	9b02      	ldr	r3, [sp, #8]
   122ec:	eb04 05c3 	add.w	r5, r4, r3, lsl #3
    if (N == 1)
   122f0:	2b01      	cmp	r3, #1
   122f2:	f000 81b6 	beq.w	12662 <bsp_fft+0xc8a>
    uint16_t idx = N / 2U;
   122f6:	9b02      	ldr	r3, [sp, #8]
   122f8:	085b      	lsrs	r3, r3, #1
   122fa:	9303      	str	r3, [sp, #12]
    if (N == 1)
   122fc:	2b01      	cmp	r3, #1
   122fe:	f000 81bc 	beq.w	1267a <bsp_fft+0xca2>
    uint16_t idx = N / 2U;
   12302:	9b03      	ldr	r3, [sp, #12]
   12304:	085f      	lsrs	r7, r3, #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   12306:	2310      	movs	r3, #16
   12308:	463a      	mov	r2, r7
   1230a:	4629      	mov	r1, r5
   1230c:	9e04      	ldr	r6, [sp, #16]
   1230e:	4630      	mov	r0, r6
   12310:	f7fe fdde 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   12314:	2310      	movs	r3, #16
   12316:	463a      	mov	r2, r7
   12318:	eb05 01c7 	add.w	r1, r5, r7, lsl #3
   1231c:	4630      	mov	r0, r6
   1231e:	4418      	add	r0, r3
   12320:	f7fe fdd6 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   12324:	f04f 0a00 	mov.w	sl, #0
   12328:	9405      	str	r4, [sp, #20]
   1232a:	46a9      	mov	r9, r5
   1232c:	46b8      	mov	r8, r7
   1232e:	e1ce      	b.n	126ce <bsp_fft+0xcf6>
        X[0] = (complex_t) x[0];
   12330:	9b03      	ldr	r3, [sp, #12]
   12332:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   12336:	ee07 3a90 	vmov	s15, r3
   1233a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1233e:	edc4 7a00 	vstr	s15, [r4]
   12342:	2300      	movs	r3, #0
   12344:	6063      	str	r3, [r4, #4]
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   12346:	9b05      	ldr	r3, [sp, #20]
   12348:	f103 0508 	add.w	r5, r3, #8
   1234c:	9b04      	ldr	r3, [sp, #16]
   1234e:	eb04 07c3 	add.w	r7, r4, r3, lsl #3
    if (N == 1)
   12352:	2b01      	cmp	r3, #1
   12354:	f000 8089 	beq.w	1246a <bsp_fft+0xa92>
    uint16_t idx = N / 2U;
   12358:	9b04      	ldr	r3, [sp, #16]
   1235a:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   1235e:	2310      	movs	r3, #16
   12360:	4652      	mov	r2, sl
   12362:	4639      	mov	r1, r7
   12364:	4628      	mov	r0, r5
   12366:	f7fe fdb3 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   1236a:	2310      	movs	r3, #16
   1236c:	4652      	mov	r2, sl
   1236e:	eb07 01ca 	add.w	r1, r7, sl, lsl #3
   12372:	18e8      	adds	r0, r5, r3
   12374:	f7fe fdac 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   12378:	2500      	movs	r5, #0
   1237a:	9403      	str	r4, [sp, #12]
   1237c:	463c      	mov	r4, r7
   1237e:	e09c      	b.n	124ba <bsp_fft+0xae2>
        X[k + idx] = X[k] - z;
   12380:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   12384:	ed93 6a00 	vldr	s12, [r3]
   12388:	ee36 6a47 	vsub.f32	s12, s12, s14
   1238c:	edd3 6a01 	vldr	s13, [r3, #4]
   12390:	ee76 6ae7 	vsub.f32	s13, s13, s15
   12394:	ed86 6a00 	vstr	s12, [r6]
   12398:	edc6 6a01 	vstr	s13, [r6, #4]
        X[k]       = X[k] + z;
   1239c:	edd3 6a00 	vldr	s13, [r3]
   123a0:	ee37 7a26 	vadd.f32	s14, s14, s13
   123a4:	edd3 6a01 	vldr	s13, [r3, #4]
   123a8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   123ac:	ed83 7a00 	vstr	s14, [r3]
   123b0:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   123b4:	3501      	adds	r5, #1
   123b6:	b2ad      	uxth	r5, r5
   123b8:	45aa      	cmp	sl, r5
   123ba:	d9c4      	bls.n	12346 <bsp_fft+0x96e>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   123bc:	ee07 5a90 	vmov	s15, r5
   123c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
   123c4:	ee17 0a90 	vmov	r0, s15
   123c8:	f7ed ffee 	bl	3a8 <__aeabi_f2d>
   123cc:	4680      	mov	r8, r0
   123ce:	4689      	mov	r9, r1
   123d0:	eddd 7a04 	vldr	s15, [sp, #16]
   123d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
   123d8:	ee17 0a90 	vmov	r0, s15
   123dc:	f7ed ffe4 	bl	3a8 <__aeabi_f2d>
   123e0:	4606      	mov	r6, r0
   123e2:	460f      	mov	r7, r1
   123e4:	2200      	movs	r2, #0
   123e6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   123ea:	4640      	mov	r0, r8
   123ec:	4649      	mov	r1, r9
   123ee:	f7ee f833 	bl	458 <__aeabi_dmul>
   123f2:	4632      	mov	r2, r6
   123f4:	463b      	mov	r3, r7
   123f6:	f7ee f959 	bl	6ac <__aeabi_ddiv>
   123fa:	f7ee fa3f 	bl	87c <__aeabi_d2f>
   123fe:	ee08 0a90 	vmov	s17, r0
   12402:	f20f 63b4 	addw	r3, pc, #1716	; 0x6b4
   12406:	e9d3 2300 	ldrd	r2, r3, [r3]
   1240a:	4640      	mov	r0, r8
   1240c:	4649      	mov	r1, r9
   1240e:	f7ee f823 	bl	458 <__aeabi_dmul>
   12412:	4632      	mov	r2, r6
   12414:	463b      	mov	r3, r7
   12416:	f7ee f949 	bl	6ac <__aeabi_ddiv>
   1241a:	f7ee fa2f 	bl	87c <__aeabi_d2f>
   1241e:	eeb0 0a68 	vmov.f32	s0, s17
   12422:	ee00 0a90 	vmov	s1, r0
   12426:	f018 fb3f 	bl	2aaa8 <cexpf>
   1242a:	eb05 060a 	add.w	r6, r5, sl
   1242e:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
   12432:	ed96 1a00 	vldr	s2, [r6]
   12436:	edd6 1a01 	vldr	s3, [r6, #4]
   1243a:	ee20 7a01 	vmul.f32	s14, s0, s2
   1243e:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12442:	ee37 7a67 	vsub.f32	s14, s14, s15
   12446:	ee60 7a21 	vmul.f32	s15, s0, s3
   1244a:	ee60 6a81 	vmul.f32	s13, s1, s2
   1244e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12452:	eeb4 7a67 	vcmp.f32	s14, s15
   12456:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1245a:	d791      	bvc.n	12380 <bsp_fft+0x9a8>
   1245c:	f7ee fbd4 	bl	c08 <__mulsc3>
   12460:	eeb0 7a40 	vmov.f32	s14, s0
   12464:	eef0 7a60 	vmov.f32	s15, s1
   12468:	e78a      	b.n	12380 <bsp_fft+0x9a8>
        X[0] = (complex_t) x[0];
   1246a:	9b05      	ldr	r3, [sp, #20]
   1246c:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
   12470:	ee07 3a90 	vmov	s15, r3
   12474:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12478:	edc7 7a00 	vstr	s15, [r7]
   1247c:	2300      	movs	r3, #0
   1247e:	607b      	str	r3, [r7, #4]
        return;
   12480:	e075      	b.n	1256e <bsp_fft+0xb96>
        X[k + idx] = X[k] - z;
   12482:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   12486:	ed93 6a00 	vldr	s12, [r3]
   1248a:	ee36 6a47 	vsub.f32	s12, s12, s14
   1248e:	edd3 6a01 	vldr	s13, [r3, #4]
   12492:	ee76 6ae7 	vsub.f32	s13, s13, s15
   12496:	ed86 6a00 	vstr	s12, [r6]
   1249a:	edc6 6a01 	vstr	s13, [r6, #4]
        X[k]       = X[k] + z;
   1249e:	edd3 6a00 	vldr	s13, [r3]
   124a2:	ee37 7a26 	vadd.f32	s14, s14, s13
   124a6:	edd3 6a01 	vldr	s13, [r3, #4]
   124aa:	ee77 7aa6 	vadd.f32	s15, s15, s13
   124ae:	ed83 7a00 	vstr	s14, [r3]
   124b2:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   124b6:	3501      	adds	r5, #1
   124b8:	b2ad      	uxth	r5, r5
   124ba:	45aa      	cmp	sl, r5
   124bc:	d956      	bls.n	1256c <bsp_fft+0xb94>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   124be:	ee07 5a90 	vmov	s15, r5
   124c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   124c6:	ee17 0a90 	vmov	r0, s15
   124ca:	f7ed ff6d 	bl	3a8 <__aeabi_f2d>
   124ce:	4680      	mov	r8, r0
   124d0:	4689      	mov	r9, r1
   124d2:	eddd 7a04 	vldr	s15, [sp, #16]
   124d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   124da:	ee17 0a90 	vmov	r0, s15
   124de:	f7ed ff63 	bl	3a8 <__aeabi_f2d>
   124e2:	4606      	mov	r6, r0
   124e4:	460f      	mov	r7, r1
   124e6:	2200      	movs	r2, #0
   124e8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   124ec:	4640      	mov	r0, r8
   124ee:	4649      	mov	r1, r9
   124f0:	f7ed ffb2 	bl	458 <__aeabi_dmul>
   124f4:	4632      	mov	r2, r6
   124f6:	463b      	mov	r3, r7
   124f8:	f7ee f8d8 	bl	6ac <__aeabi_ddiv>
   124fc:	f7ee f9be 	bl	87c <__aeabi_d2f>
   12500:	ee08 0a90 	vmov	s17, r0
   12504:	f20f 53b0 	addw	r3, pc, #1456	; 0x5b0
   12508:	e9d3 2300 	ldrd	r2, r3, [r3]
   1250c:	4640      	mov	r0, r8
   1250e:	4649      	mov	r1, r9
   12510:	f7ed ffa2 	bl	458 <__aeabi_dmul>
   12514:	4632      	mov	r2, r6
   12516:	463b      	mov	r3, r7
   12518:	f7ee f8c8 	bl	6ac <__aeabi_ddiv>
   1251c:	f7ee f9ae 	bl	87c <__aeabi_d2f>
   12520:	eeb0 0a68 	vmov.f32	s0, s17
   12524:	ee00 0a90 	vmov	s1, r0
   12528:	f018 fabe 	bl	2aaa8 <cexpf>
   1252c:	eb05 060a 	add.w	r6, r5, sl
   12530:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
   12534:	ed96 1a00 	vldr	s2, [r6]
   12538:	edd6 1a01 	vldr	s3, [r6, #4]
   1253c:	ee20 7a01 	vmul.f32	s14, s0, s2
   12540:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12544:	ee37 7a67 	vsub.f32	s14, s14, s15
   12548:	ee60 7a21 	vmul.f32	s15, s0, s3
   1254c:	ee60 6a81 	vmul.f32	s13, s1, s2
   12550:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12554:	eeb4 7a67 	vcmp.f32	s14, s15
   12558:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1255c:	d791      	bvc.n	12482 <bsp_fft+0xaaa>
   1255e:	f7ee fb53 	bl	c08 <__mulsc3>
   12562:	eeb0 7a40 	vmov.f32	s14, s0
   12566:	eef0 7a60 	vmov.f32	s15, s1
   1256a:	e78a      	b.n	12482 <bsp_fft+0xaaa>
   1256c:	9c03      	ldr	r4, [sp, #12]
    for (uint16_t k = 0; k < idx; k++)
   1256e:	2500      	movs	r5, #0
   12570:	f8dd a010 	ldr.w	sl, [sp, #16]
   12574:	e01b      	b.n	125ae <bsp_fft+0xbd6>
        X[k + idx] = X[k] - z;
   12576:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   1257a:	ed93 6a00 	vldr	s12, [r3]
   1257e:	ee36 6a47 	vsub.f32	s12, s12, s14
   12582:	edd3 6a01 	vldr	s13, [r3, #4]
   12586:	ee76 6ae7 	vsub.f32	s13, s13, s15
   1258a:	ed86 6a00 	vstr	s12, [r6]
   1258e:	edc6 6a01 	vstr	s13, [r6, #4]
        X[k]       = X[k] + z;
   12592:	edd3 6a00 	vldr	s13, [r3]
   12596:	ee37 7a26 	vadd.f32	s14, s14, s13
   1259a:	edd3 6a01 	vldr	s13, [r3, #4]
   1259e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   125a2:	ed83 7a00 	vstr	s14, [r3]
   125a6:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   125aa:	3501      	adds	r5, #1
   125ac:	b2ad      	uxth	r5, r5
   125ae:	45aa      	cmp	sl, r5
   125b0:	f67f ae98 	bls.w	122e4 <bsp_fft+0x90c>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   125b4:	ee07 5a90 	vmov	s15, r5
   125b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
   125bc:	ee17 0a90 	vmov	r0, s15
   125c0:	f7ed fef2 	bl	3a8 <__aeabi_f2d>
   125c4:	4680      	mov	r8, r0
   125c6:	4689      	mov	r9, r1
   125c8:	eddd 7a02 	vldr	s15, [sp, #8]
   125cc:	eef8 7a67 	vcvt.f32.u32	s15, s15
   125d0:	ee17 0a90 	vmov	r0, s15
   125d4:	f7ed fee8 	bl	3a8 <__aeabi_f2d>
   125d8:	4606      	mov	r6, r0
   125da:	460f      	mov	r7, r1
   125dc:	2200      	movs	r2, #0
   125de:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   125e2:	4640      	mov	r0, r8
   125e4:	4649      	mov	r1, r9
   125e6:	f7ed ff37 	bl	458 <__aeabi_dmul>
   125ea:	4632      	mov	r2, r6
   125ec:	463b      	mov	r3, r7
   125ee:	f7ee f85d 	bl	6ac <__aeabi_ddiv>
   125f2:	f7ee f943 	bl	87c <__aeabi_d2f>
   125f6:	ee08 0a90 	vmov	s17, r0
   125fa:	f20f 43bc 	addw	r3, pc, #1212	; 0x4bc
   125fe:	e9d3 2300 	ldrd	r2, r3, [r3]
   12602:	4640      	mov	r0, r8
   12604:	4649      	mov	r1, r9
   12606:	f7ed ff27 	bl	458 <__aeabi_dmul>
   1260a:	4632      	mov	r2, r6
   1260c:	463b      	mov	r3, r7
   1260e:	f7ee f84d 	bl	6ac <__aeabi_ddiv>
   12612:	f7ee f933 	bl	87c <__aeabi_d2f>
   12616:	eeb0 0a68 	vmov.f32	s0, s17
   1261a:	ee00 0a90 	vmov	s1, r0
   1261e:	f018 fa43 	bl	2aaa8 <cexpf>
   12622:	eb05 060a 	add.w	r6, r5, sl
   12626:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
   1262a:	ed96 1a00 	vldr	s2, [r6]
   1262e:	edd6 1a01 	vldr	s3, [r6, #4]
   12632:	ee20 7a01 	vmul.f32	s14, s0, s2
   12636:	ee60 7aa1 	vmul.f32	s15, s1, s3
   1263a:	ee37 7a67 	vsub.f32	s14, s14, s15
   1263e:	ee60 7a21 	vmul.f32	s15, s0, s3
   12642:	ee60 6a81 	vmul.f32	s13, s1, s2
   12646:	ee77 7aa6 	vadd.f32	s15, s15, s13
   1264a:	eeb4 7a67 	vcmp.f32	s14, s15
   1264e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12652:	d790      	bvc.n	12576 <bsp_fft+0xb9e>
   12654:	f7ee fad8 	bl	c08 <__mulsc3>
   12658:	eeb0 7a40 	vmov.f32	s14, s0
   1265c:	eef0 7a60 	vmov.f32	s15, s1
   12660:	e789      	b.n	12576 <bsp_fft+0xb9e>
        X[0] = (complex_t) x[0];
   12662:	9b05      	ldr	r3, [sp, #20]
   12664:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
   12668:	ee07 3a90 	vmov	s15, r3
   1266c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12670:	edc5 7a00 	vstr	s15, [r5]
   12674:	2300      	movs	r3, #0
   12676:	606b      	str	r3, [r5, #4]
        return;
   12678:	e1a3      	b.n	129c2 <bsp_fft+0xfea>
        X[0] = (complex_t) x[0];
   1267a:	9b05      	ldr	r3, [sp, #20]
   1267c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
   12680:	ee07 3a90 	vmov	s15, r3
   12684:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12688:	edc5 7a00 	vstr	s15, [r5]
   1268c:	2300      	movs	r3, #0
   1268e:	606b      	str	r3, [r5, #4]
        return;
   12690:	e077      	b.n	12782 <bsp_fft+0xdaa>
        X[k + idx] = X[k] - z;
   12692:	eb09 03ca 	add.w	r3, r9, sl, lsl #3
   12696:	ed93 6a00 	vldr	s12, [r3]
   1269a:	ee36 6a47 	vsub.f32	s12, s12, s14
   1269e:	edd3 6a01 	vldr	s13, [r3, #4]
   126a2:	ee76 6ae7 	vsub.f32	s13, s13, s15
   126a6:	ed84 6a00 	vstr	s12, [r4]
   126aa:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   126ae:	edd3 6a00 	vldr	s13, [r3]
   126b2:	ee37 7a26 	vadd.f32	s14, s14, s13
   126b6:	edd3 6a01 	vldr	s13, [r3, #4]
   126ba:	ee77 7aa6 	vadd.f32	s15, s15, s13
   126be:	ed83 7a00 	vstr	s14, [r3]
   126c2:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   126c6:	f10a 0a01 	add.w	sl, sl, #1
   126ca:	fa1f fa8a 	uxth.w	sl, sl
   126ce:	45d0      	cmp	r8, sl
   126d0:	d955      	bls.n	1277e <bsp_fft+0xda6>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   126d2:	ee07 aa90 	vmov	s15, sl
   126d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   126da:	ee17 0a90 	vmov	r0, s15
   126de:	f7ed fe63 	bl	3a8 <__aeabi_f2d>
   126e2:	4606      	mov	r6, r0
   126e4:	460f      	mov	r7, r1
   126e6:	eddd 7a03 	vldr	s15, [sp, #12]
   126ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
   126ee:	ee17 0a90 	vmov	r0, s15
   126f2:	f7ed fe59 	bl	3a8 <__aeabi_f2d>
   126f6:	4604      	mov	r4, r0
   126f8:	460d      	mov	r5, r1
   126fa:	2200      	movs	r2, #0
   126fc:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   12700:	4630      	mov	r0, r6
   12702:	4639      	mov	r1, r7
   12704:	f7ed fea8 	bl	458 <__aeabi_dmul>
   12708:	4622      	mov	r2, r4
   1270a:	462b      	mov	r3, r5
   1270c:	f7ed ffce 	bl	6ac <__aeabi_ddiv>
   12710:	f7ee f8b4 	bl	87c <__aeabi_d2f>
   12714:	ee08 0a90 	vmov	s17, r0
   12718:	a3e7      	add	r3, pc, #924	; (adr r3, 12ab8 <bsp_fft+0x10e0>)
   1271a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1271e:	4630      	mov	r0, r6
   12720:	4639      	mov	r1, r7
   12722:	f7ed fe99 	bl	458 <__aeabi_dmul>
   12726:	4622      	mov	r2, r4
   12728:	462b      	mov	r3, r5
   1272a:	f7ed ffbf 	bl	6ac <__aeabi_ddiv>
   1272e:	f7ee f8a5 	bl	87c <__aeabi_d2f>
   12732:	eeb0 0a68 	vmov.f32	s0, s17
   12736:	ee00 0a90 	vmov	s1, r0
   1273a:	f018 f9b5 	bl	2aaa8 <cexpf>
   1273e:	eb0a 0408 	add.w	r4, sl, r8
   12742:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
   12746:	ed94 1a00 	vldr	s2, [r4]
   1274a:	edd4 1a01 	vldr	s3, [r4, #4]
   1274e:	ee20 7a01 	vmul.f32	s14, s0, s2
   12752:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12756:	ee37 7a67 	vsub.f32	s14, s14, s15
   1275a:	ee60 7a21 	vmul.f32	s15, s0, s3
   1275e:	ee60 6a81 	vmul.f32	s13, s1, s2
   12762:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12766:	eeb4 7a67 	vcmp.f32	s14, s15
   1276a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1276e:	d790      	bvc.n	12692 <bsp_fft+0xcba>
   12770:	f7ee fa4a 	bl	c08 <__mulsc3>
   12774:	eeb0 7a40 	vmov.f32	s14, s0
   12778:	eef0 7a60 	vmov.f32	s15, s1
   1277c:	e789      	b.n	12692 <bsp_fft+0xcba>
   1277e:	9c05      	ldr	r4, [sp, #20]
   12780:	464d      	mov	r5, r9
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   12782:	9b04      	ldr	r3, [sp, #16]
   12784:	f103 0608 	add.w	r6, r3, #8
   12788:	9b03      	ldr	r3, [sp, #12]
   1278a:	eb05 07c3 	add.w	r7, r5, r3, lsl #3
    if (N == 1)
   1278e:	2b01      	cmp	r3, #1
   12790:	d015      	beq.n	127be <bsp_fft+0xde6>
    uint16_t idx = N / 2U;
   12792:	9b03      	ldr	r3, [sp, #12]
   12794:	ea4f 0853 	mov.w	r8, r3, lsr #1
    bsp_fft_radix2(x, X, idx, 2 * step);
   12798:	2310      	movs	r3, #16
   1279a:	4642      	mov	r2, r8
   1279c:	4639      	mov	r1, r7
   1279e:	4630      	mov	r0, r6
   127a0:	f7fe fb96 	bl	10ed0 <bsp_fft_radix2>
    bsp_fft_radix2(&x[step], &X[idx], idx, 2 * step);
   127a4:	2310      	movs	r3, #16
   127a6:	4642      	mov	r2, r8
   127a8:	eb07 01c8 	add.w	r1, r7, r8, lsl #3
   127ac:	18f0      	adds	r0, r6, r3
   127ae:	f7fe fb8f 	bl	10ed0 <bsp_fft_radix2>
    for (uint16_t k = 0; k < idx; k++)
   127b2:	f04f 0a00 	mov.w	sl, #0
   127b6:	9404      	str	r4, [sp, #16]
   127b8:	9505      	str	r5, [sp, #20]
   127ba:	46b9      	mov	r9, r7
   127bc:	e029      	b.n	12812 <bsp_fft+0xe3a>
        X[0] = (complex_t) x[0];
   127be:	9b04      	ldr	r3, [sp, #16]
   127c0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
   127c4:	ee07 3a90 	vmov	s15, r3
   127c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   127cc:	edc7 7a00 	vstr	s15, [r7]
   127d0:	2300      	movs	r3, #0
   127d2:	607b      	str	r3, [r7, #4]
        return;
   127d4:	e077      	b.n	128c6 <bsp_fft+0xeee>
        X[k + idx] = X[k] - z;
   127d6:	eb09 03ca 	add.w	r3, r9, sl, lsl #3
   127da:	ed93 6a00 	vldr	s12, [r3]
   127de:	ee36 6a47 	vsub.f32	s12, s12, s14
   127e2:	edd3 6a01 	vldr	s13, [r3, #4]
   127e6:	ee76 6ae7 	vsub.f32	s13, s13, s15
   127ea:	ed84 6a00 	vstr	s12, [r4]
   127ee:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   127f2:	edd3 6a00 	vldr	s13, [r3]
   127f6:	ee37 7a26 	vadd.f32	s14, s14, s13
   127fa:	edd3 6a01 	vldr	s13, [r3, #4]
   127fe:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12802:	ed83 7a00 	vstr	s14, [r3]
   12806:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   1280a:	f10a 0a01 	add.w	sl, sl, #1
   1280e:	fa1f fa8a 	uxth.w	sl, sl
   12812:	45d0      	cmp	r8, sl
   12814:	d955      	bls.n	128c2 <bsp_fft+0xeea>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   12816:	ee07 aa90 	vmov	s15, sl
   1281a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1281e:	ee17 0a90 	vmov	r0, s15
   12822:	f7ed fdc1 	bl	3a8 <__aeabi_f2d>
   12826:	4606      	mov	r6, r0
   12828:	460f      	mov	r7, r1
   1282a:	eddd 7a03 	vldr	s15, [sp, #12]
   1282e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12832:	ee17 0a90 	vmov	r0, s15
   12836:	f7ed fdb7 	bl	3a8 <__aeabi_f2d>
   1283a:	4604      	mov	r4, r0
   1283c:	460d      	mov	r5, r1
   1283e:	2200      	movs	r2, #0
   12840:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   12844:	4630      	mov	r0, r6
   12846:	4639      	mov	r1, r7
   12848:	f7ed fe06 	bl	458 <__aeabi_dmul>
   1284c:	4622      	mov	r2, r4
   1284e:	462b      	mov	r3, r5
   12850:	f7ed ff2c 	bl	6ac <__aeabi_ddiv>
   12854:	f7ee f812 	bl	87c <__aeabi_d2f>
   12858:	ee08 0a90 	vmov	s17, r0
   1285c:	a396      	add	r3, pc, #600	; (adr r3, 12ab8 <bsp_fft+0x10e0>)
   1285e:	e9d3 2300 	ldrd	r2, r3, [r3]
   12862:	4630      	mov	r0, r6
   12864:	4639      	mov	r1, r7
   12866:	f7ed fdf7 	bl	458 <__aeabi_dmul>
   1286a:	4622      	mov	r2, r4
   1286c:	462b      	mov	r3, r5
   1286e:	f7ed ff1d 	bl	6ac <__aeabi_ddiv>
   12872:	f7ee f803 	bl	87c <__aeabi_d2f>
   12876:	eeb0 0a68 	vmov.f32	s0, s17
   1287a:	ee00 0a90 	vmov	s1, r0
   1287e:	f018 f913 	bl	2aaa8 <cexpf>
   12882:	eb0a 0408 	add.w	r4, sl, r8
   12886:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
   1288a:	ed94 1a00 	vldr	s2, [r4]
   1288e:	edd4 1a01 	vldr	s3, [r4, #4]
   12892:	ee20 7a01 	vmul.f32	s14, s0, s2
   12896:	ee60 7aa1 	vmul.f32	s15, s1, s3
   1289a:	ee37 7a67 	vsub.f32	s14, s14, s15
   1289e:	ee60 7a21 	vmul.f32	s15, s0, s3
   128a2:	ee60 6a81 	vmul.f32	s13, s1, s2
   128a6:	ee77 7aa6 	vadd.f32	s15, s15, s13
   128aa:	eeb4 7a67 	vcmp.f32	s14, s15
   128ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   128b2:	d790      	bvc.n	127d6 <bsp_fft+0xdfe>
   128b4:	f7ee f9a8 	bl	c08 <__mulsc3>
   128b8:	eeb0 7a40 	vmov.f32	s14, s0
   128bc:	eef0 7a60 	vmov.f32	s15, s1
   128c0:	e789      	b.n	127d6 <bsp_fft+0xdfe>
   128c2:	9c04      	ldr	r4, [sp, #16]
   128c4:	9d05      	ldr	r5, [sp, #20]
    for (uint16_t k = 0; k < idx; k++)
   128c6:	f04f 0a00 	mov.w	sl, #0
   128ca:	9404      	str	r4, [sp, #16]
   128cc:	46a9      	mov	r9, r5
   128ce:	f8dd 800c 	ldr.w	r8, [sp, #12]
   128d2:	e01d      	b.n	12910 <bsp_fft+0xf38>
        X[k + idx] = X[k] - z;
   128d4:	eb09 03ca 	add.w	r3, r9, sl, lsl #3
   128d8:	ed93 6a00 	vldr	s12, [r3]
   128dc:	ee36 6a47 	vsub.f32	s12, s12, s14
   128e0:	edd3 6a01 	vldr	s13, [r3, #4]
   128e4:	ee76 6ae7 	vsub.f32	s13, s13, s15
   128e8:	ed84 6a00 	vstr	s12, [r4]
   128ec:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   128f0:	edd3 6a00 	vldr	s13, [r3]
   128f4:	ee37 7a26 	vadd.f32	s14, s14, s13
   128f8:	edd3 6a01 	vldr	s13, [r3, #4]
   128fc:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12900:	ed83 7a00 	vstr	s14, [r3]
   12904:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   12908:	f10a 0a01 	add.w	sl, sl, #1
   1290c:	fa1f fa8a 	uxth.w	sl, sl
   12910:	45d0      	cmp	r8, sl
   12912:	d955      	bls.n	129c0 <bsp_fft+0xfe8>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   12914:	ee07 aa90 	vmov	s15, sl
   12918:	eef8 7a67 	vcvt.f32.u32	s15, s15
   1291c:	ee17 0a90 	vmov	r0, s15
   12920:	f7ed fd42 	bl	3a8 <__aeabi_f2d>
   12924:	4606      	mov	r6, r0
   12926:	460f      	mov	r7, r1
   12928:	eddd 7a02 	vldr	s15, [sp, #8]
   1292c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12930:	ee17 0a90 	vmov	r0, s15
   12934:	f7ed fd38 	bl	3a8 <__aeabi_f2d>
   12938:	4604      	mov	r4, r0
   1293a:	460d      	mov	r5, r1
   1293c:	2200      	movs	r2, #0
   1293e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   12942:	4630      	mov	r0, r6
   12944:	4639      	mov	r1, r7
   12946:	f7ed fd87 	bl	458 <__aeabi_dmul>
   1294a:	4622      	mov	r2, r4
   1294c:	462b      	mov	r3, r5
   1294e:	f7ed fead 	bl	6ac <__aeabi_ddiv>
   12952:	f7ed ff93 	bl	87c <__aeabi_d2f>
   12956:	ee08 0a90 	vmov	s17, r0
   1295a:	a357      	add	r3, pc, #348	; (adr r3, 12ab8 <bsp_fft+0x10e0>)
   1295c:	e9d3 2300 	ldrd	r2, r3, [r3]
   12960:	4630      	mov	r0, r6
   12962:	4639      	mov	r1, r7
   12964:	f7ed fd78 	bl	458 <__aeabi_dmul>
   12968:	4622      	mov	r2, r4
   1296a:	462b      	mov	r3, r5
   1296c:	f7ed fe9e 	bl	6ac <__aeabi_ddiv>
   12970:	f7ed ff84 	bl	87c <__aeabi_d2f>
   12974:	eeb0 0a68 	vmov.f32	s0, s17
   12978:	ee00 0a90 	vmov	s1, r0
   1297c:	f018 f894 	bl	2aaa8 <cexpf>
   12980:	eb0a 0408 	add.w	r4, sl, r8
   12984:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
   12988:	ed94 1a00 	vldr	s2, [r4]
   1298c:	edd4 1a01 	vldr	s3, [r4, #4]
   12990:	ee20 7a01 	vmul.f32	s14, s0, s2
   12994:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12998:	ee37 7a67 	vsub.f32	s14, s14, s15
   1299c:	ee60 7a21 	vmul.f32	s15, s0, s3
   129a0:	ee60 6a81 	vmul.f32	s13, s1, s2
   129a4:	ee77 7aa6 	vadd.f32	s15, s15, s13
   129a8:	eeb4 7a67 	vcmp.f32	s14, s15
   129ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   129b0:	d790      	bvc.n	128d4 <bsp_fft+0xefc>
   129b2:	f7ee f929 	bl	c08 <__mulsc3>
   129b6:	eeb0 7a40 	vmov.f32	s14, s0
   129ba:	eef0 7a60 	vmov.f32	s15, s1
   129be:	e789      	b.n	128d4 <bsp_fft+0xefc>
   129c0:	9c04      	ldr	r4, [sp, #16]
    for (uint16_t k = 0; k < idx; k++)
   129c2:	2500      	movs	r5, #0
   129c4:	f8dd a008 	ldr.w	sl, [sp, #8]
   129c8:	e01b      	b.n	12a02 <bsp_fft+0x102a>
        X[k + idx] = X[k] - z;
   129ca:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   129ce:	ed93 6a00 	vldr	s12, [r3]
   129d2:	ee36 6a47 	vsub.f32	s12, s12, s14
   129d6:	edd3 6a01 	vldr	s13, [r3, #4]
   129da:	ee76 6ae7 	vsub.f32	s13, s13, s15
   129de:	ed86 6a00 	vstr	s12, [r6]
   129e2:	edc6 6a01 	vstr	s13, [r6, #4]
        X[k]       = X[k] + z;
   129e6:	edd3 6a00 	vldr	s13, [r3]
   129ea:	ee37 7a26 	vadd.f32	s14, s14, s13
   129ee:	edd3 6a01 	vldr	s13, [r3, #4]
   129f2:	ee77 7aa6 	vadd.f32	s15, s15, s13
   129f6:	ed83 7a00 	vstr	s14, [r3]
   129fa:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   129fe:	3501      	adds	r5, #1
   12a00:	b2ad      	uxth	r5, r5
   12a02:	45aa      	cmp	sl, r5
   12a04:	f67f ac5d 	bls.w	122c2 <bsp_fft+0x8ea>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   12a08:	ee07 5a90 	vmov	s15, r5
   12a0c:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12a10:	ee17 0a90 	vmov	r0, s15
   12a14:	f7ed fcc8 	bl	3a8 <__aeabi_f2d>
   12a18:	4680      	mov	r8, r0
   12a1a:	4689      	mov	r9, r1
   12a1c:	eddd 7a01 	vldr	s15, [sp, #4]
   12a20:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12a24:	ee17 0a90 	vmov	r0, s15
   12a28:	f7ed fcbe 	bl	3a8 <__aeabi_f2d>
   12a2c:	4606      	mov	r6, r0
   12a2e:	460f      	mov	r7, r1
   12a30:	2200      	movs	r2, #0
   12a32:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   12a36:	4640      	mov	r0, r8
   12a38:	4649      	mov	r1, r9
   12a3a:	f7ed fd0d 	bl	458 <__aeabi_dmul>
   12a3e:	4632      	mov	r2, r6
   12a40:	463b      	mov	r3, r7
   12a42:	f7ed fe33 	bl	6ac <__aeabi_ddiv>
   12a46:	f7ed ff19 	bl	87c <__aeabi_d2f>
   12a4a:	ee08 0a90 	vmov	s17, r0
   12a4e:	a31a      	add	r3, pc, #104	; (adr r3, 12ab8 <bsp_fft+0x10e0>)
   12a50:	e9d3 2300 	ldrd	r2, r3, [r3]
   12a54:	4640      	mov	r0, r8
   12a56:	4649      	mov	r1, r9
   12a58:	f7ed fcfe 	bl	458 <__aeabi_dmul>
   12a5c:	4632      	mov	r2, r6
   12a5e:	463b      	mov	r3, r7
   12a60:	f7ed fe24 	bl	6ac <__aeabi_ddiv>
   12a64:	f7ed ff0a 	bl	87c <__aeabi_d2f>
   12a68:	eeb0 0a68 	vmov.f32	s0, s17
   12a6c:	ee00 0a90 	vmov	s1, r0
   12a70:	f018 f81a 	bl	2aaa8 <cexpf>
   12a74:	eb05 060a 	add.w	r6, r5, sl
   12a78:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
   12a7c:	ed96 1a00 	vldr	s2, [r6]
   12a80:	edd6 1a01 	vldr	s3, [r6, #4]
   12a84:	ee20 7a01 	vmul.f32	s14, s0, s2
   12a88:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12a8c:	ee37 7a67 	vsub.f32	s14, s14, s15
   12a90:	ee60 7a21 	vmul.f32	s15, s0, s3
   12a94:	ee60 6a81 	vmul.f32	s13, s1, s2
   12a98:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12a9c:	eeb4 7a67 	vcmp.f32	s14, s15
   12aa0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12aa4:	d791      	bvc.n	129ca <bsp_fft+0xff2>
   12aa6:	f7ee f8af 	bl	c08 <__mulsc3>
   12aaa:	eeb0 7a40 	vmov.f32	s14, s0
   12aae:	eef0 7a60 	vmov.f32	s15, s1
   12ab2:	e78a      	b.n	129ca <bsp_fft+0xff2>
   12ab4:	f3af 8000 	nop.w
   12ab8:	54442d18 	.word	0x54442d18
   12abc:	c01921fb 	.word	0xc01921fb
        X[k + idx] = X[k] - z;
   12ac0:	eb0b 03c8 	add.w	r3, fp, r8, lsl #3
   12ac4:	ed93 6a00 	vldr	s12, [r3]
   12ac8:	ee36 6a47 	vsub.f32	s12, s12, s14
   12acc:	edd3 6a01 	vldr	s13, [r3, #4]
   12ad0:	ee76 6ae7 	vsub.f32	s13, s13, s15
   12ad4:	ed84 6a00 	vstr	s12, [r4]
   12ad8:	edc4 6a01 	vstr	s13, [r4, #4]
        X[k]       = X[k] + z;
   12adc:	edd3 6a00 	vldr	s13, [r3]
   12ae0:	ee37 7a26 	vadd.f32	s14, s14, s13
   12ae4:	edd3 6a01 	vldr	s13, [r3, #4]
   12ae8:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12aec:	ed83 7a00 	vstr	s14, [r3]
   12af0:	edc3 7a01 	vstr	s15, [r3, #4]
    for (uint16_t k = 0; k < idx; k++)
   12af4:	f108 0801 	add.w	r8, r8, #1
   12af8:	fa1f f888 	uxth.w	r8, r8
   12afc:	45c1      	cmp	r9, r8
   12afe:	f67e afa4 	bls.w	11a4a <bsp_fft+0x72>
        z = cexpf( -2.0f * M_PI * I * ( (float) k) /( (float) N) ) * X[k + idx];
   12b02:	ee07 8a90 	vmov	s15, r8
   12b06:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12b0a:	ee17 0a90 	vmov	r0, s15
   12b0e:	f7ed fc4b 	bl	3a8 <__aeabi_f2d>
   12b12:	4606      	mov	r6, r0
   12b14:	460f      	mov	r7, r1
   12b16:	eef8 7a48 	vcvt.f32.u32	s15, s16
   12b1a:	ee17 0a90 	vmov	r0, s15
   12b1e:	f7ed fc43 	bl	3a8 <__aeabi_f2d>
   12b22:	4604      	mov	r4, r0
   12b24:	460d      	mov	r5, r1
   12b26:	2200      	movs	r2, #0
   12b28:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   12b2c:	4630      	mov	r0, r6
   12b2e:	4639      	mov	r1, r7
   12b30:	f7ed fc92 	bl	458 <__aeabi_dmul>
   12b34:	4622      	mov	r2, r4
   12b36:	462b      	mov	r3, r5
   12b38:	f7ed fdb8 	bl	6ac <__aeabi_ddiv>
   12b3c:	f7ed fe9e 	bl	87c <__aeabi_d2f>
   12b40:	ee08 0a90 	vmov	s17, r0
   12b44:	a31a      	add	r3, pc, #104	; (adr r3, 12bb0 <bsp_fft+0x11d8>)
   12b46:	e9d3 2300 	ldrd	r2, r3, [r3]
   12b4a:	4630      	mov	r0, r6
   12b4c:	4639      	mov	r1, r7
   12b4e:	f7ed fc83 	bl	458 <__aeabi_dmul>
   12b52:	4622      	mov	r2, r4
   12b54:	462b      	mov	r3, r5
   12b56:	f7ed fda9 	bl	6ac <__aeabi_ddiv>
   12b5a:	f7ed fe8f 	bl	87c <__aeabi_d2f>
   12b5e:	eeb0 0a68 	vmov.f32	s0, s17
   12b62:	ee00 0a90 	vmov	s1, r0
   12b66:	f017 ff9f 	bl	2aaa8 <cexpf>
   12b6a:	eb08 0409 	add.w	r4, r8, r9
   12b6e:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
   12b72:	ed94 1a00 	vldr	s2, [r4]
   12b76:	edd4 1a01 	vldr	s3, [r4, #4]
   12b7a:	ee20 7a01 	vmul.f32	s14, s0, s2
   12b7e:	ee60 7aa1 	vmul.f32	s15, s1, s3
   12b82:	ee37 7a67 	vsub.f32	s14, s14, s15
   12b86:	ee60 7a21 	vmul.f32	s15, s0, s3
   12b8a:	ee60 6a81 	vmul.f32	s13, s1, s2
   12b8e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   12b92:	eeb4 7a67 	vcmp.f32	s14, s15
   12b96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   12b9a:	d791      	bvc.n	12ac0 <bsp_fft+0x10e8>
   12b9c:	f7ee f834 	bl	c08 <__mulsc3>
   12ba0:	eeb0 7a40 	vmov.f32	s14, s0
   12ba4:	eef0 7a60 	vmov.f32	s15, s1
   12ba8:	e78a      	b.n	12ac0 <bsp_fft+0x10e8>
   12baa:	bf00      	nop
   12bac:	f3af 8000 	nop.w
   12bb0:	54442d18 	.word	0x54442d18
   12bb4:	c01921fb 	.word	0xc01921fb

00012bb8 <bsp_display_backlight_set_brightness>:
 *
 * */
zephyr_err_t bsp_display_backlight_set_brightness( uint16_t duty_cycle )
{
    zephyr_err_t err = -EINVAL;
    if( duty_cycle < BSP_DISPLAY_MAX_BRIGHTNESS )
   12bb8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   12bbc:	d274      	bcs.n	12ca8 <bsp_display_backlight_set_brightness+0xf0>
{
   12bbe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12bc2:	ed2d 8b02 	vpush	{d8}
   12bc6:	b087      	sub	sp, #28
   12bc8:	4605      	mov	r5, r0
    {
        float duty_cycle_f = (float) duty_cycle * 10.0f;
   12bca:	ee07 0a90 	vmov	s15, r0
   12bce:	eef8 7a67 	vcvt.f32.u32	s15, s15
   12bd2:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
   12bd6:	ee67 7a87 	vmul.f32	s15, s15, s14
        uint32_t pulse = (uint32_t)
                ((((10000.0f - 2*duty_cycle_f)) / (10000.0f - duty_cycle_f)) * ( (float) BSP_DISPLAY_BACKLIGHT_MAX_PERIOD));
   12bda:	ee77 6aa7 	vadd.f32	s13, s15, s15
   12bde:	ed9f 7a36 	vldr	s14, [pc, #216]	; 12cb8 <bsp_display_backlight_set_brightness+0x100>
   12be2:	ee77 6a66 	vsub.f32	s13, s14, s13
   12be6:	ee77 7a67 	vsub.f32	s15, s14, s15
   12bea:	ee86 8aa7 	vdiv.f32	s16, s13, s15
   12bee:	eddf 7a33 	vldr	s15, [pc, #204]	; 12cbc <bsp_display_backlight_set_brightness+0x104>
   12bf2:	ee28 8a27 	vmul.f32	s16, s16, s15
        uint32_t pulse = (uint32_t)
   12bf6:	eebc 8ac8 	vcvt.u32.f32	s16, s16
 * @see pwm_set_pulse_dt()
 */
static inline int pwm_set_dt(const struct pwm_dt_spec *spec, uint32_t period,
			     uint32_t pulse)
{
	return pwm_set(spec->dev, spec->channel, period, pulse, spec->flags);
   12bfa:	4b31      	ldr	r3, [pc, #196]	; (12cc0 <bsp_display_backlight_set_brightness+0x108>)
   12bfc:	6a9e      	ldr	r6, [r3, #40]	; 0x28
   12bfe:	f8d3 902c 	ldr.w	r9, [r3, #44]	; 0x2c
   12c02:	f8b3 8034 	ldrh.w	r8, [r3, #52]	; 0x34
	const struct pwm_driver_api *api =
   12c06:	68b3      	ldr	r3, [r6, #8]
	return api->get_cycles_per_sec(dev, channel, cycles);
   12c08:	685b      	ldr	r3, [r3, #4]
   12c0a:	aa04      	add	r2, sp, #16
   12c0c:	4649      	mov	r1, r9
   12c0e:	4630      	mov	r0, r6
   12c10:	4798      	blx	r3
	if (err < 0) {
   12c12:	2800      	cmp	r0, #0
   12c14:	db35      	blt.n	12c82 <bsp_display_backlight_set_brightness+0xca>
	period_cycles = (period * cycles_per_sec) / NSEC_PER_SEC;
   12c16:	9c04      	ldr	r4, [sp, #16]
   12c18:	f8dd b014 	ldr.w	fp, [sp, #20]
   12c1c:	4b29      	ldr	r3, [pc, #164]	; (12cc4 <bsp_display_backlight_set_brightness+0x10c>)
   12c1e:	fba4 a703 	umull	sl, r7, r4, r3
   12c22:	fb03 770b 	mla	r7, r3, fp, r7
   12c26:	a322      	add	r3, pc, #136	; (adr r3, 12cb0 <bsp_display_backlight_set_brightness+0xf8>)
   12c28:	e9d3 2300 	ldrd	r2, r3, [r3]
   12c2c:	4650      	mov	r0, sl
   12c2e:	4639      	mov	r1, r7
   12c30:	f7ed ffd2 	bl	bd8 <__aeabi_uldivmod>
   12c34:	9003      	str	r0, [sp, #12]
	if (period_cycles > UINT32_MAX) {
   12c36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12c3a:	4553      	cmp	r3, sl
   12c3c:	4b22      	ldr	r3, [pc, #136]	; (12cc8 <bsp_display_backlight_set_brightness+0x110>)
   12c3e:	41bb      	sbcs	r3, r7
   12c40:	d32c      	bcc.n	12c9c <bsp_display_backlight_set_brightness+0xe4>
	pulse_cycles = (pulse * cycles_per_sec) / NSEC_PER_SEC;
   12c42:	ee18 3a10 	vmov	r3, s16
   12c46:	fba3 7404 	umull	r7, r4, r3, r4
   12c4a:	fb03 4b0b 	mla	fp, r3, fp, r4
   12c4e:	a318      	add	r3, pc, #96	; (adr r3, 12cb0 <bsp_display_backlight_set_brightness+0xf8>)
   12c50:	e9d3 2300 	ldrd	r2, r3, [r3]
   12c54:	4638      	mov	r0, r7
   12c56:	4659      	mov	r1, fp
   12c58:	f7ed ffbe 	bl	bd8 <__aeabi_uldivmod>
   12c5c:	4603      	mov	r3, r0
	if (pulse_cycles > UINT32_MAX) {
   12c5e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12c62:	42ba      	cmp	r2, r7
   12c64:	4a18      	ldr	r2, [pc, #96]	; (12cc8 <bsp_display_backlight_set_brightness+0x110>)
   12c66:	eb72 020b 	sbcs.w	r2, r2, fp
   12c6a:	d31a      	bcc.n	12ca2 <bsp_display_backlight_set_brightness+0xea>
	const struct pwm_driver_api *api =
   12c6c:	68b2      	ldr	r2, [r6, #8]
	if (pulse > period) {
   12c6e:	9903      	ldr	r1, [sp, #12]
   12c70:	4299      	cmp	r1, r3
   12c72:	d310      	bcc.n	12c96 <bsp_display_backlight_set_brightness+0xde>
	return api->set_cycles(dev, channel, period, pulse, flags);
   12c74:	6814      	ldr	r4, [r2, #0]
   12c76:	f8cd 8000 	str.w	r8, [sp]
   12c7a:	460a      	mov	r2, r1
   12c7c:	4649      	mov	r1, r9
   12c7e:	4630      	mov	r0, r6
   12c80:	47a0      	blx	r4
        /**
         * T((1-d) - d)/(1-d)
         * **/
        err = pwm_set_dt(&afl240320a0.back_light_pwm, BSP_DISPLAY_BACKLIGHT_MAX_PERIOD ,  pulse );

        afl240320a0.screen_brightness = ( ZEPHYR_ERR_SUCCESS == err ) ? duty_cycle : afl240320a0.screen_brightness ;
   12c82:	b108      	cbz	r0, 12c88 <bsp_display_backlight_set_brightness+0xd0>
   12c84:	4b0e      	ldr	r3, [pc, #56]	; (12cc0 <bsp_display_backlight_set_brightness+0x108>)
   12c86:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
   12c88:	4b0d      	ldr	r3, [pc, #52]	; (12cc0 <bsp_display_backlight_set_brightness+0x108>)
   12c8a:	871d      	strh	r5, [r3, #56]	; 0x38

    }

    return err;
}
   12c8c:	b007      	add	sp, #28
   12c8e:	ecbd 8b02 	vpop	{d8}
   12c92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -EINVAL;
   12c96:	f06f 0015 	mvn.w	r0, #21
	return pwm_set_cycles(dev, channel, (uint32_t)period_cycles,
   12c9a:	e7f2      	b.n	12c82 <bsp_display_backlight_set_brightness+0xca>
		return -ENOTSUP;
   12c9c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   12ca0:	e7ef      	b.n	12c82 <bsp_display_backlight_set_brightness+0xca>
		return -ENOTSUP;
   12ca2:	f06f 0085 	mvn.w	r0, #133	; 0x85
   12ca6:	e7ec      	b.n	12c82 <bsp_display_backlight_set_brightness+0xca>
    zephyr_err_t err = -EINVAL;
   12ca8:	f06f 0015 	mvn.w	r0, #21
}
   12cac:	4770      	bx	lr
   12cae:	bf00      	nop
   12cb0:	3b9aca00 	.word	0x3b9aca00
   12cb4:	00000000 	.word	0x00000000
   12cb8:	461c4000 	.word	0x461c4000
   12cbc:	47c35000 	.word	0x47c35000
   12cc0:	20000350 	.word	0x20000350
   12cc4:	000186a0 	.word	0x000186a0
   12cc8:	3b9ac9ff 	.word	0x3b9ac9ff

00012ccc <bsp_init_internal>:
}

/***************************** - Private Functions - *******************************/

static zephyr_err_t bsp_init_internal()
{
   12ccc:	b508      	push	{r3, lr}
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;

    k_msgq_init(&bsp_data_queue , (char *) bsp_queue_buffer,
   12cce:	2302      	movs	r3, #2
   12cd0:	2214      	movs	r2, #20
   12cd2:	4905      	ldr	r1, [pc, #20]	; (12ce8 <bsp_init_internal+0x1c>)
   12cd4:	4805      	ldr	r0, [pc, #20]	; (12cec <bsp_init_internal+0x20>)
   12cd6:	f01d fe3a 	bl	3094e <k_msgq_init>
                sizeof(vitals_vital_sign_data_t) , BSP_APP_QUEUE_SIZE );

    k_work_init(&bsp_work.work , bsp_vital_prepping_work);
   12cda:	4905      	ldr	r1, [pc, #20]	; (12cf0 <bsp_init_internal+0x24>)
   12cdc:	4805      	ldr	r0, [pc, #20]	; (12cf4 <bsp_init_internal+0x28>)
   12cde:	f014 fc47 	bl	27570 <k_work_init>

    return err;
}
   12ce2:	2000      	movs	r0, #0
   12ce4:	bd08      	pop	{r3, pc}
   12ce6:	bf00      	nop
   12ce8:	2000289c 	.word	0x2000289c
   12cec:	20002868 	.word	0x20002868
   12cf0:	0002ba89 	.word	0x0002ba89
   12cf4:	200028c4 	.word	0x200028c4

00012cf8 <bsp_get_data>:
{
   12cf8:	b510      	push	{r4, lr}
   12cfa:	4604      	mov	r4, r0
   12cfc:	4608      	mov	r0, r1
    bsp_battery_gauge_get_parameters( &battery->voltage , &battery->temperature , &battery->rsoc , &battery->health );
   12cfe:	f101 0309 	add.w	r3, r1, #9
   12d02:	f101 0208 	add.w	r2, r1, #8
   12d06:	3104      	adds	r1, #4
   12d08:	f001 fe16 	bl	14938 <bsp_battery_gauge_get_parameters>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm2 = { .val = timeout };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.split.lo, parm2.split.hi, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
   12d0c:	2200      	movs	r2, #0
   12d0e:	2300      	movs	r3, #0
   12d10:	4621      	mov	r1, r4
   12d12:	4802      	ldr	r0, [pc, #8]	; (12d1c <bsp_get_data+0x24>)
   12d14:	f013 fdba 	bl	2688c <z_impl_k_msgq_get>
}
   12d18:	bd10      	pop	{r4, pc}
   12d1a:	bf00      	nop
   12d1c:	20002868 	.word	0x20002868

00012d20 <bsp_pause_sampling>:
{
   12d20:	b508      	push	{r3, lr}
    printk("sampling paused\n");
   12d22:	4804      	ldr	r0, [pc, #16]	; (12d34 <bsp_pause_sampling+0x14>)
   12d24:	f019 f960 	bl	2bfe8 <printk>
    bsp_sensor_interface_pause_sampling();
   12d28:	f018 ff87 	bl	2bc3a <bsp_sensor_interface_pause_sampling>
    bsp_sensor_interface_power_off_afe();
   12d2c:	f001 fc9c 	bl	14668 <bsp_sensor_interface_power_off_afe>
}
   12d30:	bd08      	pop	{r3, pc}
   12d32:	bf00      	nop
   12d34:	00031504 	.word	0x00031504

00012d38 <bsp_vital_submit_vital_reading>:

}


static void bsp_vital_submit_vital_reading( vitals_vital_sign_data_t reading )
{
   12d38:	b084      	sub	sp, #16
   12d3a:	b508      	push	{r3, lr}
   12d3c:	f10d 0c08 	add.w	ip, sp, #8
   12d40:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
	return z_impl_k_msgq_put(msgq, data, timeout);
   12d44:	2200      	movs	r2, #0
   12d46:	2300      	movs	r3, #0
   12d48:	4661      	mov	r1, ip
   12d4a:	4807      	ldr	r0, [pc, #28]	; (12d68 <bsp_vital_submit_vital_reading+0x30>)
   12d4c:	f013 fd04 	bl	26758 <z_impl_k_msgq_put>
    zephyr_err_t err = k_msgq_put( &bsp_data_queue , &reading , K_NO_WAIT );
    if( ZEPHYR_ERR_SUCCESS == err )
   12d50:	b118      	cbz	r0, 12d5a <bsp_vital_submit_vital_reading+0x22>
    {
        vital_app_flag_event( VITAL_APP_EVENTS_WORK_TO_DO );
        bsp_pause_sampling();
    }
   12d52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   12d56:	b004      	add	sp, #16
   12d58:	4770      	bx	lr
        vital_app_flag_event( VITAL_APP_EVENTS_WORK_TO_DO );
   12d5a:	2001      	movs	r0, #1
   12d5c:	f002 faa8 	bl	152b0 <vital_app_flag_event>
        bsp_pause_sampling();
   12d60:	f7ff ffde 	bl	12d20 <bsp_pause_sampling>
   12d64:	e7f5      	b.n	12d52 <bsp_vital_submit_vital_reading+0x1a>
   12d66:	bf00      	nop
   12d68:	20002868 	.word	0x20002868

00012d6c <bsp_resume_sampling>:
{
   12d6c:	b508      	push	{r3, lr}
    printk("sampling resumed\n");
   12d6e:	4804      	ldr	r0, [pc, #16]	; (12d80 <bsp_resume_sampling+0x14>)
   12d70:	f019 f93a 	bl	2bfe8 <printk>
    bsp_sensor_interface_power_on_afe();
   12d74:	f001 fc18 	bl	145a8 <bsp_sensor_interface_power_on_afe>
    bsp_sensor_interface_resume_sampling();
   12d78:	f018 ff63 	bl	2bc42 <bsp_sensor_interface_resume_sampling>
}
   12d7c:	bd08      	pop	{r3, pc}
   12d7e:	bf00      	nop
   12d80:	00031518 	.word	0x00031518

00012d84 <bsp_print_data>:
{
   12d84:	b084      	sub	sp, #16
   12d86:	b510      	push	{r4, lr}
   12d88:	b086      	sub	sp, #24
   12d8a:	ac08      	add	r4, sp, #32
   12d8c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    zephyr_err_t err = bsp_display_set_text_pos( 0 , 0 );
   12d90:	2100      	movs	r1, #0
   12d92:	4608      	mov	r0, r1
   12d94:	f002 f992 	bl	150bc <bsp_display_set_text_pos>
    if( ZEPHYR_ERR_SUCCESS == err )
   12d98:	b120      	cbz	r0, 12da4 <bsp_print_data+0x20>
}
   12d9a:	b006      	add	sp, #24
   12d9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12da0:	b004      	add	sp, #16
   12da2:	4770      	bx	lr
                                 vitals.temperature , vitals.heart_rate , vitals.acceleration , vitals.respiration ,
   12da4:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
   12da8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
                                 battery.health , battery.rsoc);
   12dac:	f89d 203d 	ldrb.w	r2, [sp, #61]	; 0x3d
   12db0:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
            bsp_display_print_string("Vitals status:\n"
   12db4:	9104      	str	r1, [sp, #16]
   12db6:	9203      	str	r2, [sp, #12]
   12db8:	9302      	str	r3, [sp, #8]
   12dba:	9809      	ldr	r0, [sp, #36]	; 0x24
   12dbc:	f7ed faf4 	bl	3a8 <__aeabi_f2d>
   12dc0:	e9cd 0100 	strd	r0, r1, [sp]
   12dc4:	4622      	mov	r2, r4
   12dc6:	9908      	ldr	r1, [sp, #32]
   12dc8:	4801      	ldr	r0, [pc, #4]	; (12dd0 <bsp_print_data+0x4c>)
   12dca:	f019 f84a 	bl	2be62 <bsp_display_print_string>
    return err;
   12dce:	e7e4      	b.n	12d9a <bsp_print_data+0x16>
   12dd0:	0003152c 	.word	0x0003152c

00012dd4 <bsp_submit_work>:
{
   12dd4:	b508      	push	{r3, lr}
    k_work_submit(&bsp_work.work);
   12dd6:	4802      	ldr	r0, [pc, #8]	; (12de0 <bsp_submit_work+0xc>)
   12dd8:	f014 fc40 	bl	2765c <k_work_submit>
}
   12ddc:	bd08      	pop	{r3, pc}
   12dde:	bf00      	nop
   12de0:	200028c4 	.word	0x200028c4

00012de4 <ad469x_spi_read>:
 * @notes      Performs a write then read onto the spi bus.
 *
 */

static zephyr_err_t ad469x_spi_read(bsp_ad469x_address_t reg , uint8_t* data )
{
   12de4:	b510      	push	{r4, lr}
   12de6:	b08c      	sub	sp, #48	; 0x30
   12de8:	f8ad 0004 	strh.w	r0, [sp, #4]
    zephyr_err_t err = -EINVAL;
    reg.readwrite = AD469X_READ_REGISTER;
   12dec:	f89d 3004 	ldrb.w	r3, [sp, #4]
   12df0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   12df4:	f88d 3004 	strb.w	r3, [sp, #4]

    zephyr_spi_buf_t spi_buf[] = {
   12df8:	ab01      	add	r3, sp, #4
   12dfa:	9306      	str	r3, [sp, #24]
   12dfc:	2302      	movs	r3, #2
   12dfe:	9307      	str	r3, [sp, #28]
   12e00:	2200      	movs	r2, #0
   12e02:	9208      	str	r2, [sp, #32]
   12e04:	9309      	str	r3, [sp, #36]	; 0x24
   12e06:	910a      	str	r1, [sp, #40]	; 0x28
   12e08:	2201      	movs	r2, #1
   12e0a:	920b      	str	r2, [sp, #44]	; 0x2c
            .buf = data,
            .len = 1,//Read 1 byte (should be the response)
        },
    };

    zephyr_spi_buf_set_t spi_bufs[] = {
   12e0c:	a906      	add	r1, sp, #24
   12e0e:	9102      	str	r1, [sp, #8]
   12e10:	9203      	str	r2, [sp, #12]
   12e12:	aa08      	add	r2, sp, #32
   12e14:	9204      	str	r2, [sp, #16]
   12e16:	9305      	str	r3, [sp, #20]
                .buffers = &spi_buf[AD469X_SPI_READ_BUF_POS_1],
                .count   = 2,
        },
    };

    err = spi_transceive(ad469x.spi_device, &ad469x.spi_config,
   12e18:	4904      	ldr	r1, [pc, #16]	; (12e2c <ad469x_spi_read+0x48>)
   12e1a:	6848      	ldr	r0, [r1, #4]
static inline int z_impl_spi_transceive(const struct device *dev,
					const struct spi_config *config,
					const struct spi_buf_set *tx_bufs,
					const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
   12e1c:	6883      	ldr	r3, [r0, #8]
		(const struct spi_driver_api *)dev->api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
   12e1e:	681c      	ldr	r4, [r3, #0]
   12e20:	ab04      	add	r3, sp, #16
   12e22:	aa02      	add	r2, sp, #8
   12e24:	3114      	adds	r1, #20
   12e26:	47a0      	blx	r4
                         &spi_bufs[AD469X_SPI_WRITE] , &spi_bufs[AD469X_SPI_READ] );

    return err;
}
   12e28:	b00c      	add	sp, #48	; 0x30
   12e2a:	bd10      	pop	{r4, pc}
   12e2c:	200005a0 	.word	0x200005a0

00012e30 <ad469x_spi_write>:
 *
 * @notes      Performs a write onto the spi bus.
 *
 */
static zephyr_err_t ad469x_spi_write(bsp_ad469x_address_t reg , uint8_t data )
{
   12e30:	b510      	push	{r4, lr}
   12e32:	b086      	sub	sp, #24

    zephyr_err_t err = -EINVAL;
    reg.readwrite = AD469X_WRITE_REGISTER;
   12e34:	f36f 10c7 	bfc	r0, #7, #1

    uint8_t buffer[ sizeof(uint16_t) + sizeof(uint8_t) ];

    memcpy( &buffer[0] , &reg.data , sizeof(uint16_t) );
   12e38:	f8ad 0014 	strh.w	r0, [sp, #20]
    buffer[2] = data;
   12e3c:	f88d 1016 	strb.w	r1, [sp, #22]

    zephyr_spi_buf_t spi_tx_buf = {
   12e40:	ab05      	add	r3, sp, #20
   12e42:	9303      	str	r3, [sp, #12]
   12e44:	2303      	movs	r3, #3
   12e46:	9304      	str	r3, [sp, #16]
        .buf = &buffer[0],
        .len = sizeof(uint16_t) + sizeof(uint8_t),
    };
    zephyr_spi_buf_set_t tx_buf = {
   12e48:	ab03      	add	r3, sp, #12
   12e4a:	9301      	str	r3, [sp, #4]
   12e4c:	2301      	movs	r3, #1
   12e4e:	9302      	str	r3, [sp, #8]
            .buffers = &spi_tx_buf,
            .count   = 1,
    };

    err = spi_write( ad469x.spi_device , &ad469x.spi_config , &tx_buf );
   12e50:	4904      	ldr	r1, [pc, #16]	; (12e64 <ad469x_spi_write+0x34>)
   12e52:	6848      	ldr	r0, [r1, #4]
	const struct spi_driver_api *api =
   12e54:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   12e56:	681c      	ldr	r4, [r3, #0]
   12e58:	2300      	movs	r3, #0
   12e5a:	aa01      	add	r2, sp, #4
   12e5c:	3114      	adds	r1, #20
   12e5e:	47a0      	blx	r4

    return err;
}
   12e60:	b006      	add	sp, #24
   12e62:	bd10      	pop	{r4, pc}
   12e64:	200005a0 	.word	0x200005a0

00012e68 <ad469x_seq_osr_clear>:
 *
 * @notes      Configure over sampling ratio to 1 in single and two cycle modes.
 *
 */
static zephyr_err_t ad469x_seq_osr_clear()
{
   12e68:	b510      	push	{r4, lr}
    zephyr_err_t err = -EINVAL;
    uint8_t i = 0;

    for (i = 0; i < AD469x_CHANNEL_NO; i++)
   12e6a:	2400      	movs	r4, #0
    zephyr_err_t err = -EINVAL;
   12e6c:	f06f 0215 	mvn.w	r2, #21
    for (i = 0; i < AD469x_CHANNEL_NO; i++)
   12e70:	e001      	b.n	12e76 <ad469x_seq_osr_clear+0xe>
   12e72:	3401      	adds	r4, #1
   12e74:	b2e4      	uxtb	r4, r4
   12e76:	2c0f      	cmp	r4, #15
   12e78:	d810      	bhi.n	12e9c <ad469x_seq_osr_clear+0x34>
    {
        err = ad469x_spi_write_set_bits(AD469x_REG_CONFIG_IN(i),
   12e7a:	f004 000f 	and.w	r0, r4, #15
   12e7e:	2200      	movs	r2, #0
   12e80:	2103      	movs	r1, #3
   12e82:	f040 0030 	orr.w	r0, r0, #48	; 0x30
   12e86:	f018 fe35 	bl	2baf4 <ad469x_spi_write_set_bits>
                                        AD469x_REG_CONFIG_IN_OSR_MASK, AD469x_REG_CONFIG_IN_OSR(AD469X_OSR_1));
        if( ZEPHYR_ERR_SUCCESS == err )
   12e8a:	4602      	mov	r2, r0
   12e8c:	2800      	cmp	r0, #0
   12e8e:	d1f0      	bne.n	12e72 <ad469x_seq_osr_clear+0xa>
        {
            ad469x.channel_resolution[i] = ad469x_device_resolution(AD469X_OSR_1);
   12e90:	4b05      	ldr	r3, [pc, #20]	; (12ea8 <ad469x_seq_osr_clear+0x40>)
   12e92:	4423      	add	r3, r4
   12e94:	2110      	movs	r1, #16
   12e96:	f883 108d 	strb.w	r1, [r3, #141]	; 0x8d
   12e9a:	e7ea      	b.n	12e72 <ad469x_seq_osr_clear+0xa>
        }

    }
    /* Set storage to minimum data width */
    ad469x.capture_data_width = ad469x_device_resolution(AD469X_OSR_1);
   12e9c:	4b02      	ldr	r3, [pc, #8]	; (12ea8 <ad469x_seq_osr_clear+0x40>)
   12e9e:	2110      	movs	r1, #16
   12ea0:	f883 115f 	strb.w	r1, [r3, #351]	; 0x15f

    return err;
}
   12ea4:	4610      	mov	r0, r2
   12ea6:	bd10      	pop	{r4, pc}
   12ea8:	200005a0 	.word	0x200005a0

00012eac <ad469x_spi_update_frequency>:
    return err;
}

static void ad469x_spi_update_frequency( uint32_t new_frequency )
{
    ad469x.spi_config.frequency = new_frequency;
   12eac:	4b01      	ldr	r3, [pc, #4]	; (12eb4 <ad469x_spi_update_frequency+0x8>)
   12eae:	6158      	str	r0, [r3, #20]
}
   12eb0:	4770      	bx	lr
   12eb2:	bf00      	nop
   12eb4:	200005a0 	.word	0x200005a0

00012eb8 <ad469x_queue_init>:
{
   12eb8:	b510      	push	{r4, lr}
    for (uint8_t idx = 0; (idx < AD469x_CHANNEL_NO); idx++)
   12eba:	2400      	movs	r4, #0
   12ebc:	e00d      	b.n	12eda <ad469x_queue_init+0x22>
        k_msgq_init(&adc_channel_queue[idx] , (uint8_t*) adc_queue_buffers[idx] ,
   12ebe:	2304      	movs	r3, #4
   12ec0:	2208      	movs	r2, #8
   12ec2:	4909      	ldr	r1, [pc, #36]	; (12ee8 <ad469x_queue_init+0x30>)
   12ec4:	eb01 1144 	add.w	r1, r1, r4, lsl #5
   12ec8:	4808      	ldr	r0, [pc, #32]	; (12eec <ad469x_queue_init+0x34>)
   12eca:	f04f 0c34 	mov.w	ip, #52	; 0x34
   12ece:	fb0c 0004 	mla	r0, ip, r4, r0
   12ed2:	f01d fd3c 	bl	3094e <k_msgq_init>
    for (uint8_t idx = 0; (idx < AD469x_CHANNEL_NO); idx++)
   12ed6:	3401      	adds	r4, #1
   12ed8:	b2e4      	uxtb	r4, r4
   12eda:	2c0f      	cmp	r4, #15
   12edc:	d9ef      	bls.n	12ebe <ad469x_queue_init+0x6>
	z_impl_k_event_init(event);
   12ede:	4804      	ldr	r0, [pc, #16]	; (12ef0 <ad469x_queue_init+0x38>)
   12ee0:	f01d ff23 	bl	30d2a <z_impl_k_event_init>
}
   12ee4:	bd10      	pop	{r4, pc}
   12ee6:	bf00      	nop
   12ee8:	20002c60 	.word	0x20002c60
   12eec:	200028ec 	.word	0x200028ec
   12ef0:	20002e80 	.word	0x20002e80

00012ef4 <ad469x_gpio_reset_cb>:
{
   12ef4:	b508      	push	{r3, lr}
	z_impl_k_event_post(event, events);
   12ef6:	2104      	movs	r1, #4
   12ef8:	4801      	ldr	r0, [pc, #4]	; (12f00 <ad469x_gpio_reset_cb+0xc>)
   12efa:	f01d ff1c 	bl	30d36 <z_impl_k_event_post>
}
   12efe:	bd08      	pop	{r3, pc}
   12f00:	200005fc 	.word	0x200005fc

00012f04 <ad469x_gpio_busy_cb>:
{
   12f04:	b508      	push	{r3, lr}
   12f06:	2102      	movs	r1, #2
   12f08:	4801      	ldr	r0, [pc, #4]	; (12f10 <ad469x_gpio_busy_cb+0xc>)
   12f0a:	f01d ff14 	bl	30d36 <z_impl_k_event_post>
}
   12f0e:	bd08      	pop	{r3, pc}
   12f10:	200005fc 	.word	0x200005fc

00012f14 <z_impl_gpio_pin_configure>:
{
   12f14:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12f18:	4605      	mov	r5, r0
   12f1a:	460e      	mov	r6, r1
   12f1c:	4614      	mov	r4, r2
	const struct gpio_driver_api *api =
   12f1e:	f8d0 a008 	ldr.w	sl, [r0, #8]
	__unused const struct gpio_driver_config *const cfg =
   12f22:	f8d0 b004 	ldr.w	fp, [r0, #4]
	struct gpio_driver_data *data =
   12f26:	f8d0 8010 	ldr.w	r8, [r0, #16]
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   12f2a:	f012 6ffc 	tst.w	r2, #132120576	; 0x7e00000
   12f2e:	d135      	bne.n	12f9c <z_impl_gpio_pin_configure+0x88>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   12f30:	f004 0330 	and.w	r3, r4, #48	; 0x30
   12f34:	2b30      	cmp	r3, #48	; 0x30
   12f36:	d03e      	beq.n	12fb6 <z_impl_gpio_pin_configure+0xa2>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   12f38:	f004 1302 	and.w	r3, r4, #131074	; 0x20002
   12f3c:	2b02      	cmp	r3, #2
   12f3e:	d047      	beq.n	12fd0 <z_impl_gpio_pin_configure+0xbc>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   12f40:	f004 0306 	and.w	r3, r4, #6
   12f44:	2b04      	cmp	r3, #4
   12f46:	d050      	beq.n	12fea <z_impl_gpio_pin_configure+0xd6>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   12f48:	f414 2740 	ands.w	r7, r4, #786432	; 0xc0000
   12f4c:	d002      	beq.n	12f54 <z_impl_gpio_pin_configure+0x40>
   12f4e:	f414 3f00 	tst.w	r4, #131072	; 0x20000
   12f52:	d057      	beq.n	13004 <z_impl_gpio_pin_configure+0xf0>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   12f54:	f5b7 2f40 	cmp.w	r7, #786432	; 0xc0000
   12f58:	d062      	beq.n	13020 <z_impl_gpio_pin_configure+0x10c>
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   12f5a:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
   12f5e:	d005      	beq.n	12f6c <z_impl_gpio_pin_configure+0x58>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   12f60:	b127      	cbz	r7, 12f6c <z_impl_gpio_pin_configure+0x58>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   12f62:	f014 0f01 	tst.w	r4, #1
   12f66:	d001      	beq.n	12f6c <z_impl_gpio_pin_configure+0x58>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   12f68:	f484 2440 	eor.w	r4, r4, #786432	; 0xc0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   12f6c:	f424 1980 	bic.w	r9, r4, #1048576	; 0x100000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   12f70:	f8db 3000 	ldr.w	r3, [fp]
   12f74:	2701      	movs	r7, #1
   12f76:	40b7      	lsls	r7, r6
   12f78:	423b      	tst	r3, r7
   12f7a:	d05f      	beq.n	1303c <z_impl_gpio_pin_configure+0x128>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   12f7c:	f014 0f01 	tst.w	r4, #1
   12f80:	d06a      	beq.n	13058 <z_impl_gpio_pin_configure+0x144>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   12f82:	f8d8 3000 	ldr.w	r3, [r8]
   12f86:	433b      	orrs	r3, r7
   12f88:	f8c8 3000 	str.w	r3, [r8]
	return api->pin_configure(port, pin, flags);
   12f8c:	f8da 3000 	ldr.w	r3, [sl]
   12f90:	464a      	mov	r2, r9
   12f92:	4631      	mov	r1, r6
   12f94:	4628      	mov	r0, r5
   12f96:	4798      	blx	r3
}
   12f98:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   12f9c:	4f32      	ldr	r7, [pc, #200]	; (13068 <z_impl_gpio_pin_configure+0x154>)
   12f9e:	f44f 722f 	mov.w	r2, #700	; 0x2bc
   12fa2:	4639      	mov	r1, r7
   12fa4:	4831      	ldr	r0, [pc, #196]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   12fa6:	f019 fac2 	bl	2c52e <assert_print>
   12faa:	f44f 712f 	mov.w	r1, #700	; 0x2bc
   12fae:	4638      	mov	r0, r7
   12fb0:	f019 fab6 	bl	2c520 <assert_post_action>
   12fb4:	e7bc      	b.n	12f30 <z_impl_gpio_pin_configure+0x1c>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   12fb6:	4f2c      	ldr	r7, [pc, #176]	; (13068 <z_impl_gpio_pin_configure+0x154>)
   12fb8:	f240 22bf 	movw	r2, #703	; 0x2bf
   12fbc:	4639      	mov	r1, r7
   12fbe:	482b      	ldr	r0, [pc, #172]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   12fc0:	f019 fab5 	bl	2c52e <assert_print>
   12fc4:	f240 21bf 	movw	r1, #703	; 0x2bf
   12fc8:	4638      	mov	r0, r7
   12fca:	f019 faa9 	bl	2c520 <assert_post_action>
   12fce:	e7b3      	b.n	12f38 <z_impl_gpio_pin_configure+0x24>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   12fd0:	4f25      	ldr	r7, [pc, #148]	; (13068 <z_impl_gpio_pin_configure+0x154>)
   12fd2:	f240 22c3 	movw	r2, #707	; 0x2c3
   12fd6:	4639      	mov	r1, r7
   12fd8:	4824      	ldr	r0, [pc, #144]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   12fda:	f019 faa8 	bl	2c52e <assert_print>
   12fde:	f240 21c3 	movw	r1, #707	; 0x2c3
   12fe2:	4638      	mov	r0, r7
   12fe4:	f019 fa9c 	bl	2c520 <assert_post_action>
   12fe8:	e7aa      	b.n	12f40 <z_impl_gpio_pin_configure+0x2c>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   12fea:	4f1f      	ldr	r7, [pc, #124]	; (13068 <z_impl_gpio_pin_configure+0x154>)
   12fec:	f240 22c7 	movw	r2, #711	; 0x2c7
   12ff0:	4639      	mov	r1, r7
   12ff2:	481e      	ldr	r0, [pc, #120]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   12ff4:	f019 fa9b 	bl	2c52e <assert_print>
   12ff8:	f240 21c7 	movw	r1, #711	; 0x2c7
   12ffc:	4638      	mov	r0, r7
   12ffe:	f019 fa8f 	bl	2c520 <assert_post_action>
   13002:	e7a1      	b.n	12f48 <z_impl_gpio_pin_configure+0x34>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   13004:	f8df 9060 	ldr.w	r9, [pc, #96]	; 13068 <z_impl_gpio_pin_configure+0x154>
   13008:	f240 22ca 	movw	r2, #714	; 0x2ca
   1300c:	4649      	mov	r1, r9
   1300e:	4817      	ldr	r0, [pc, #92]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   13010:	f019 fa8d 	bl	2c52e <assert_print>
   13014:	f240 21ca 	movw	r1, #714	; 0x2ca
   13018:	4648      	mov	r0, r9
   1301a:	f019 fa81 	bl	2c520 <assert_post_action>
   1301e:	e799      	b.n	12f54 <z_impl_gpio_pin_configure+0x40>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   13020:	f8df 9044 	ldr.w	r9, [pc, #68]	; 13068 <z_impl_gpio_pin_configure+0x154>
   13024:	f240 22ce 	movw	r2, #718	; 0x2ce
   13028:	4649      	mov	r1, r9
   1302a:	4810      	ldr	r0, [pc, #64]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   1302c:	f019 fa7f 	bl	2c52e <assert_print>
   13030:	f240 21ce 	movw	r1, #718	; 0x2ce
   13034:	4648      	mov	r0, r9
   13036:	f019 fa73 	bl	2c520 <assert_post_action>
   1303a:	e78e      	b.n	12f5a <z_impl_gpio_pin_configure+0x46>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1303c:	f8df b028 	ldr.w	fp, [pc, #40]	; 13068 <z_impl_gpio_pin_configure+0x154>
   13040:	f240 22da 	movw	r2, #730	; 0x2da
   13044:	4659      	mov	r1, fp
   13046:	4809      	ldr	r0, [pc, #36]	; (1306c <z_impl_gpio_pin_configure+0x158>)
   13048:	f019 fa71 	bl	2c52e <assert_print>
   1304c:	f240 21da 	movw	r1, #730	; 0x2da
   13050:	4658      	mov	r0, fp
   13052:	f019 fa65 	bl	2c520 <assert_post_action>
   13056:	e791      	b.n	12f7c <z_impl_gpio_pin_configure+0x68>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   13058:	f8d8 3000 	ldr.w	r3, [r8]
   1305c:	ea23 0307 	bic.w	r3, r3, r7
   13060:	f8c8 3000 	str.w	r3, [r8]
   13064:	e792      	b.n	12f8c <z_impl_gpio_pin_configure+0x78>
   13066:	bf00      	nop
   13068:	000315cc 	.word	0x000315cc
   1306c:	00031600 	.word	0x00031600

00013070 <ad469x_gpio_busy_init>:
{
   13070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @return a value from gpio_pin_configure()
 */
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
	return gpio_pin_configure(spec->port,
   13072:	4b20      	ldr	r3, [pc, #128]	; (130f4 <ad469x_gpio_busy_init+0x84>)
   13074:	6b58      	ldr	r0, [r3, #52]	; 0x34
   13076:	f893 1038 	ldrb.w	r1, [r3, #56]	; 0x38
				  spec->pin,
				  spec->dt_flags | extra_flags);
   1307a:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
	return gpio_pin_configure(spec->port,
   1307c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
		union { uintptr_t x; gpio_flags_t val; } parm2 = { .val = flags };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_GPIO_PIN_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_configure(port, pin, flags);
   13080:	f7ff ff48 	bl	12f14 <z_impl_gpio_pin_configure>
    if (ZEPHYR_ERR_SUCCESS == err)
   13084:	b100      	cbz	r0, 13088 <ad469x_gpio_busy_init+0x18>
}
   13086:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
   13088:	4b1a      	ldr	r3, [pc, #104]	; (130f4 <ad469x_gpio_busy_init+0x84>)
   1308a:	6b5c      	ldr	r4, [r3, #52]	; 0x34
   1308c:	f893 5038 	ldrb.w	r5, [r3, #56]	; 0x38
	const struct gpio_driver_api *api =
   13090:	68a6      	ldr	r6, [r4, #8]
	__unused const struct gpio_driver_config *const cfg =
   13092:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13094:	681a      	ldr	r2, [r3, #0]
   13096:	2301      	movs	r3, #1
   13098:	40ab      	lsls	r3, r5
   1309a:	421a      	tst	r2, r3
   1309c:	d019      	beq.n	130d2 <ad469x_gpio_busy_init+0x62>
	return api->pin_interrupt_configure(port, pin, mode, trig);
   1309e:	69b6      	ldr	r6, [r6, #24]
   130a0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   130a4:	f04f 72a0 	mov.w	r2, #20971520	; 0x1400000
   130a8:	4629      	mov	r1, r5
   130aa:	4620      	mov	r0, r4
   130ac:	47b0      	blx	r6
        if (ZEPHYR_ERR_SUCCESS == err)
   130ae:	2800      	cmp	r0, #0
   130b0:	d1e9      	bne.n	13086 <ad469x_gpio_busy_init+0x16>
                               BIT(ad469x.gpio_busy.gpio_spec.pin));
   130b2:	4b10      	ldr	r3, [pc, #64]	; (130f4 <ad469x_gpio_busy_init+0x84>)
   130b4:	f893 1038 	ldrb.w	r1, [r3, #56]	; 0x38
   130b8:	2201      	movs	r2, #1
   130ba:	408a      	lsls	r2, r1
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
   130bc:	490e      	ldr	r1, [pc, #56]	; (130f8 <ad469x_gpio_busy_init+0x88>)
   130be:	6419      	str	r1, [r3, #64]	; 0x40
	callback->pin_mask = pin_mask;
   130c0:	645a      	str	r2, [r3, #68]	; 0x44
            err = gpio_add_callback(ad469x.gpio_busy.gpio_spec.port, &ad469x.gpio_busy.gpio_callback);
   130c2:	6b58      	ldr	r0, [r3, #52]	; 0x34
 * Note: enables to add as many callback as needed on the same port.
 */
static inline int gpio_add_callback(const struct device *port,
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
   130c4:	6883      	ldr	r3, [r0, #8]
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
   130c6:	69db      	ldr	r3, [r3, #28]
   130c8:	b183      	cbz	r3, 130ec <ad469x_gpio_busy_init+0x7c>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   130ca:	2201      	movs	r2, #1
   130cc:	490b      	ldr	r1, [pc, #44]	; (130fc <ad469x_gpio_busy_init+0x8c>)
   130ce:	4798      	blx	r3
   130d0:	e7d9      	b.n	13086 <ad469x_gpio_busy_init+0x16>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   130d2:	4f0b      	ldr	r7, [pc, #44]	; (13100 <ad469x_gpio_busy_init+0x90>)
   130d4:	f44f 721f 	mov.w	r2, #636	; 0x27c
   130d8:	4639      	mov	r1, r7
   130da:	480a      	ldr	r0, [pc, #40]	; (13104 <ad469x_gpio_busy_init+0x94>)
   130dc:	f019 fa27 	bl	2c52e <assert_print>
   130e0:	f44f 711f 	mov.w	r1, #636	; 0x27c
   130e4:	4638      	mov	r0, r7
   130e6:	f019 fa1b 	bl	2c520 <assert_post_action>
   130ea:	e7d8      	b.n	1309e <ad469x_gpio_busy_init+0x2e>
		return -ENOTSUP;
   130ec:	f06f 0085 	mvn.w	r0, #133	; 0x85
    return err;
   130f0:	e7c9      	b.n	13086 <ad469x_gpio_busy_init+0x16>
   130f2:	bf00      	nop
   130f4:	200005a0 	.word	0x200005a0
   130f8:	00012f05 	.word	0x00012f05
   130fc:	200005dc 	.word	0x200005dc
   13100:	000315cc 	.word	0x000315cc
   13104:	00031600 	.word	0x00031600

00013108 <bsp_ad469x_get_data_event_handle>:
}
   13108:	4800      	ldr	r0, [pc, #0]	; (1310c <bsp_ad469x_get_data_event_handle+0x4>)
   1310a:	4770      	bx	lr
   1310c:	20002e80 	.word	0x20002e80

00013110 <bsp_ad469x_get_data_queues_handle>:
}
   13110:	4800      	ldr	r0, [pc, #0]	; (13114 <bsp_ad469x_get_data_queues_handle+0x4>)
   13112:	4770      	bx	lr
   13114:	200028ec 	.word	0x200028ec

00013118 <bsp_ad469x_adv_seq_osr>:
{
   13118:	b538      	push	{r3, r4, r5, lr}
    if ( (ad469x.channel_sequence != AD469X_SINGLE_CYCLE) && (ad469x.channel_sequence != AD469X_TWO_CYCLE) && (channel < AD469x_CHANNEL_NO ) )
   1311a:	4b18      	ldr	r3, [pc, #96]	; (1317c <bsp_ad469x_adv_seq_osr+0x64>)
   1311c:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
   13120:	2b01      	cmp	r3, #1
   13122:	d924      	bls.n	1316e <bsp_ad469x_adv_seq_osr+0x56>
   13124:	4604      	mov	r4, r0
   13126:	460d      	mov	r5, r1
   13128:	280f      	cmp	r0, #15
   1312a:	d823      	bhi.n	13174 <bsp_ad469x_adv_seq_osr+0x5c>
        err = ad469x_spi_write_set_bits(AD469x_REG_CONFIG_IN(channel),
   1312c:	f000 000f 	and.w	r0, r0, #15
   13130:	f001 0203 	and.w	r2, r1, #3
   13134:	2103      	movs	r1, #3
   13136:	f040 0030 	orr.w	r0, r0, #48	; 0x30
   1313a:	f018 fcdb 	bl	2baf4 <ad469x_spi_write_set_bits>
        if( err == ZEPHYR_ERR_SUCCESS)
   1313e:	b968      	cbnz	r0, 1315c <bsp_ad469x_adv_seq_osr+0x44>
    switch (in_osr)
   13140:	2d03      	cmp	r5, #3
   13142:	d810      	bhi.n	13166 <bsp_ad469x_adv_seq_osr+0x4e>
   13144:	e8df f005 	tbb	[pc, r5]
   13148:	0d0b1102 	.word	0x0d0b1102
   1314c:	2210      	movs	r2, #16
            ad469x.channel_resolution[channel] = ad469x_device_resolution(ratio);
   1314e:	4b0b      	ldr	r3, [pc, #44]	; (1317c <bsp_ad469x_adv_seq_osr+0x64>)
   13150:	441c      	add	r4, r3
   13152:	f884 208d 	strb.w	r2, [r4, #141]	; 0x8d
            ad469x.capture_data_width   = ad469x_device_resolution(AD469X_OSR_64);
   13156:	2213      	movs	r2, #19
   13158:	f883 215f 	strb.w	r2, [r3, #351]	; 0x15f
}
   1315c:	bd38      	pop	{r3, r4, r5, pc}
            ret_val = 18;
   1315e:	2212      	movs	r2, #18
            break;
   13160:	e7f5      	b.n	1314e <bsp_ad469x_adv_seq_osr+0x36>
            ret_val = 19;
   13162:	2213      	movs	r2, #19
            break;
   13164:	e7f3      	b.n	1314e <bsp_ad469x_adv_seq_osr+0x36>
            ret_val = ~( (uint8_t) 0U);
   13166:	22ff      	movs	r2, #255	; 0xff
            break;
   13168:	e7f1      	b.n	1314e <bsp_ad469x_adv_seq_osr+0x36>
            ret_val = 17;
   1316a:	2211      	movs	r2, #17
   1316c:	e7ef      	b.n	1314e <bsp_ad469x_adv_seq_osr+0x36>
    zephyr_err_t err = -EINVAL;
   1316e:	f06f 0015 	mvn.w	r0, #21
   13172:	e7f3      	b.n	1315c <bsp_ad469x_adv_seq_osr+0x44>
   13174:	f06f 0015 	mvn.w	r0, #21
    return err;
   13178:	e7f0      	b.n	1315c <bsp_ad469x_adv_seq_osr+0x44>
   1317a:	bf00      	nop
   1317c:	200005a0 	.word	0x200005a0

00013180 <bsp_ad469x_adv_seq_pair>:
{
   13180:	b538      	push	{r3, r4, r5, lr}
    if ( (ad469x.channel_sequence != AD469X_SINGLE_CYCLE) && (ad469x.channel_sequence != AD469X_TWO_CYCLE) && (channel < AD469x_CHANNEL_NO ) )
   13182:	4b11      	ldr	r3, [pc, #68]	; (131c8 <bsp_ad469x_adv_seq_pair+0x48>)
   13184:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
   13188:	2b01      	cmp	r3, #1
   1318a:	d916      	bls.n	131ba <bsp_ad469x_adv_seq_pair+0x3a>
   1318c:	460d      	mov	r5, r1
   1318e:	280f      	cmp	r0, #15
   13190:	d816      	bhi.n	131c0 <bsp_ad469x_adv_seq_pair+0x40>
        err = ad469x_spi_write_set_bits(AD469x_REG_CONFIG_IN(channel),
   13192:	f000 000f 	and.w	r0, r0, #15
   13196:	f040 0430 	orr.w	r4, r0, #48	; 0x30
                                        AD469x_REG_CONFIG_IN_PAIR(reference_pairing));
   1319a:	010a      	lsls	r2, r1, #4
        err = ad469x_spi_write_set_bits(AD469x_REG_CONFIG_IN(channel),
   1319c:	f002 0230 	and.w	r2, r2, #48	; 0x30
   131a0:	2130      	movs	r1, #48	; 0x30
   131a2:	4620      	mov	r0, r4
   131a4:	f018 fca6 	bl	2baf4 <ad469x_spi_write_set_bits>
        if( ZEPHYR_ERR_SUCCESS == err )
   131a8:	b930      	cbnz	r0, 131b8 <bsp_ad469x_adv_seq_pair+0x38>
            err = ad469x_spi_write_set_bits(AD469x_REG_CONFIG_IN(channel),
   131aa:	b105      	cbz	r5, 131ae <bsp_ad469x_adv_seq_pair+0x2e>
   131ac:	2540      	movs	r5, #64	; 0x40
   131ae:	462a      	mov	r2, r5
   131b0:	2140      	movs	r1, #64	; 0x40
   131b2:	4620      	mov	r0, r4
   131b4:	f018 fc9e 	bl	2baf4 <ad469x_spi_write_set_bits>
}
   131b8:	bd38      	pop	{r3, r4, r5, pc}
    zephyr_err_t err = -EINVAL;
   131ba:	f06f 0015 	mvn.w	r0, #21
   131be:	e7fb      	b.n	131b8 <bsp_ad469x_adv_seq_pair+0x38>
   131c0:	f06f 0015 	mvn.w	r0, #21
    return err;
   131c4:	e7f8      	b.n	131b8 <bsp_ad469x_adv_seq_pair+0x38>
   131c6:	bf00      	nop
   131c8:	200005a0 	.word	0x200005a0

000131cc <ad469x_adv_seq_init>:
{
   131cc:	b530      	push	{r4, r5, lr}
   131ce:	b08f      	sub	sp, #60	; 0x3c
    uint16_t defaults[] = AD469X_CHANNEL_DEFAULTS;
   131d0:	466c      	mov	r4, sp
   131d2:	4d31      	ldr	r5, [pc, #196]	; (13298 <ad469x_adv_seq_init+0xcc>)
   131d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   131d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   131d8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   131da:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   131dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   131de:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   131e0:	e895 0003 	ldmia.w	r5, {r0, r1}
   131e4:	f844 0b04 	str.w	r0, [r4], #4
   131e8:	8021      	strh	r1, [r4, #0]
    for (uint8_t idx = 0; idx < (AD469X_CHANNEL_DEFAULTS_LEN / 3U ); idx++ )
   131ea:	2200      	movs	r2, #0
   131ec:	e00e      	b.n	1320c <ad469x_adv_seq_init+0x40>
    switch (in_osr)
   131ee:	2010      	movs	r0, #16
        ad469x.channel_resolution[ defaults[arr_idx] ] = ad469x_device_resolution(ad469x.channel_osr[defaults[arr_idx]] );
   131f0:	492a      	ldr	r1, [pc, #168]	; (1329c <ad469x_adv_seq_init+0xd0>)
   131f2:	4429      	add	r1, r5
   131f4:	f881 008d 	strb.w	r0, [r1, #141]	; 0x8d
        ad469x.channel_reference[ defaults[arr_idx] ] = defaults[ arr_idx + 2];
   131f8:	3302      	adds	r3, #2
   131fa:	a80e      	add	r0, sp, #56	; 0x38
   131fc:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   13200:	f813 3c38 	ldrb.w	r3, [r3, #-56]
   13204:	f881 307d 	strb.w	r3, [r1, #125]	; 0x7d
    for (uint8_t idx = 0; idx < (AD469X_CHANNEL_DEFAULTS_LEN / 3U ); idx++ )
   13208:	3201      	adds	r2, #1
   1320a:	b2d2      	uxtb	r2, r2
   1320c:	2a08      	cmp	r2, #8
   1320e:	d827      	bhi.n	13260 <ad469x_adv_seq_init+0x94>
        arr_idx = 3*idx;
   13210:	eb02 0342 	add.w	r3, r2, r2, lsl #1
   13214:	b2db      	uxtb	r3, r3
        ad469x.channel_osr[ defaults[arr_idx] ] = defaults[ arr_idx + 1];
   13216:	1c58      	adds	r0, r3, #1
   13218:	a90e      	add	r1, sp, #56	; 0x38
   1321a:	eb01 0143 	add.w	r1, r1, r3, lsl #1
   1321e:	f831 5c38 	ldrh.w	r5, [r1, #-56]
   13222:	a90e      	add	r1, sp, #56	; 0x38
   13224:	eb01 0040 	add.w	r0, r1, r0, lsl #1
   13228:	f810 0c38 	ldrb.w	r0, [r0, #-56]
   1322c:	4c1b      	ldr	r4, [pc, #108]	; (1329c <ad469x_adv_seq_init+0xd0>)
   1322e:	442c      	add	r4, r5
   13230:	f884 006d 	strb.w	r0, [r4, #109]	; 0x6d
    switch (in_osr)
   13234:	2803      	cmp	r0, #3
   13236:	d80f      	bhi.n	13258 <ad469x_adv_seq_init+0x8c>
   13238:	a101      	add	r1, pc, #4	; (adr r1, 13240 <ad469x_adv_seq_init+0x74>)
   1323a:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   1323e:	bf00      	nop
   13240:	000131ef 	.word	0x000131ef
   13244:	0001325d 	.word	0x0001325d
   13248:	00013251 	.word	0x00013251
   1324c:	00013255 	.word	0x00013255
            ret_val = 18;
   13250:	2012      	movs	r0, #18
            break;
   13252:	e7cd      	b.n	131f0 <ad469x_adv_seq_init+0x24>
            ret_val = 19;
   13254:	2013      	movs	r0, #19
            break;
   13256:	e7cb      	b.n	131f0 <ad469x_adv_seq_init+0x24>
            ret_val = ~( (uint8_t) 0U);
   13258:	20ff      	movs	r0, #255	; 0xff
            break;
   1325a:	e7c9      	b.n	131f0 <ad469x_adv_seq_init+0x24>
            ret_val = 17;
   1325c:	2011      	movs	r0, #17
   1325e:	e7c7      	b.n	131f0 <ad469x_adv_seq_init+0x24>
    for (uint16_t idx = 0; (idx < AD469x_CHANNEL_NO) && (ZEPHYR_ERR_SUCCESS == err); idx++ )
   13260:	2400      	movs	r4, #0
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;
   13262:	4620      	mov	r0, r4
   13264:	e00d      	b.n	13282 <ad469x_adv_seq_init+0xb6>
        err = bsp_ad469x_adv_seq_osr( idx , ad469x.channel_osr[ idx ] );
   13266:	4d0d      	ldr	r5, [pc, #52]	; (1329c <ad469x_adv_seq_init+0xd0>)
   13268:	4425      	add	r5, r4
   1326a:	f895 106d 	ldrb.w	r1, [r5, #109]	; 0x6d
   1326e:	4620      	mov	r0, r4
   13270:	f7ff ff52 	bl	13118 <bsp_ad469x_adv_seq_osr>
        err = bsp_ad469x_adv_seq_pair( idx , ad469x.channel_reference[ idx ] );
   13274:	f895 107d 	ldrb.w	r1, [r5, #125]	; 0x7d
   13278:	4620      	mov	r0, r4
   1327a:	f7ff ff81 	bl	13180 <bsp_ad469x_adv_seq_pair>
    for (uint16_t idx = 0; (idx < AD469x_CHANNEL_NO) && (ZEPHYR_ERR_SUCCESS == err); idx++ )
   1327e:	3401      	adds	r4, #1
   13280:	b2a4      	uxth	r4, r4
   13282:	2c0f      	cmp	r4, #15
   13284:	d801      	bhi.n	1328a <ad469x_adv_seq_init+0xbe>
   13286:	2800      	cmp	r0, #0
   13288:	d0ed      	beq.n	13266 <ad469x_adv_seq_init+0x9a>
    ad469x.num_slots = 0;
   1328a:	4b04      	ldr	r3, [pc, #16]	; (1329c <ad469x_adv_seq_init+0xd0>)
   1328c:	2200      	movs	r2, #0
   1328e:	f883 215e 	strb.w	r2, [r3, #350]	; 0x15e
}
   13292:	b00f      	add	sp, #60	; 0x3c
   13294:	bd30      	pop	{r4, r5, pc}
   13296:	bf00      	nop
   13298:	000313b0 	.word	0x000313b0
   1329c:	200005a0 	.word	0x200005a0

000132a0 <bsp_ad469x_set_channel_sequence>:
{
   132a0:	b510      	push	{r4, lr}
   132a2:	4604      	mov	r4, r0
    switch (sequence)
   132a4:	2803      	cmp	r0, #3
   132a6:	d83c      	bhi.n	13322 <bsp_ad469x_set_channel_sequence+0x82>
   132a8:	e8df f000 	tbb	[pc, r0]
   132ac:	352c1702 	.word	0x352c1702
            err = ad469x_spi_write_set_bits(AD469x_REG_SEQ_CTRL,
   132b0:	2200      	movs	r2, #0
   132b2:	2180      	movs	r1, #128	; 0x80
   132b4:	2022      	movs	r0, #34	; 0x22
   132b6:	f018 fc1d 	bl	2baf4 <ad469x_spi_write_set_bits>
            if( ZEPHYR_ERR_SUCCESS == err )
   132ba:	bb40      	cbnz	r0, 1330e <bsp_ad469x_set_channel_sequence+0x6e>
                err = ad469x_spi_write_set_bits(AD469x_REG_SEQ_CTRL, AD469x_SEQ_CTRL_NUM_SLOTS_AS_MASK,
   132bc:	2200      	movs	r2, #0
   132be:	217f      	movs	r1, #127	; 0x7f
   132c0:	2022      	movs	r0, #34	; 0x22
   132c2:	f018 fc17 	bl	2baf4 <ad469x_spi_write_set_bits>
                if( ZEPHYR_ERR_SUCCESS == err )
   132c6:	bb10      	cbnz	r0, 1330e <bsp_ad469x_set_channel_sequence+0x6e>
                    err = ad469x_spi_write_set_bits(AD469x_REG_SETUP, AD469x_SETUP_CYC_CTRL_MASK,
   132c8:	2200      	movs	r2, #0
   132ca:	2102      	movs	r1, #2
   132cc:	2020      	movs	r0, #32
   132ce:	f018 fc11 	bl	2baf4 <ad469x_spi_write_set_bits>
                    if( ZEPHYR_ERR_SUCCESS == err )
   132d2:	b9e0      	cbnz	r0, 1330e <bsp_ad469x_set_channel_sequence+0x6e>
                        err = ad469x_seq_osr_clear();
   132d4:	f7ff fdc8 	bl	12e68 <ad469x_seq_osr_clear>
   132d8:	e019      	b.n	1330e <bsp_ad469x_set_channel_sequence+0x6e>
            err = ad469x_spi_write_set_bits(AD469x_REG_SEQ_CTRL, AD469x_SEQ_CTRL_STD_SEQ_EN_MASK,
   132da:	2200      	movs	r2, #0
   132dc:	2180      	movs	r1, #128	; 0x80
   132de:	2022      	movs	r0, #34	; 0x22
   132e0:	f018 fc08 	bl	2baf4 <ad469x_spi_write_set_bits>
            if( ZEPHYR_ERR_SUCCESS == err )
   132e4:	b998      	cbnz	r0, 1330e <bsp_ad469x_set_channel_sequence+0x6e>
                err = ad469x_spi_write_set_bits(AD469x_REG_SEQ_CTRL, AD469x_SEQ_CTRL_NUM_SLOTS_AS_MASK,
   132e6:	2200      	movs	r2, #0
   132e8:	217f      	movs	r1, #127	; 0x7f
   132ea:	2022      	movs	r0, #34	; 0x22
   132ec:	f018 fc02 	bl	2baf4 <ad469x_spi_write_set_bits>
                if (ZEPHYR_ERR_SUCCESS == err)
   132f0:	b968      	cbnz	r0, 1330e <bsp_ad469x_set_channel_sequence+0x6e>
                    err = ad469x_spi_write_set_bits(AD469x_REG_SETUP, AD469x_SETUP_CYC_CTRL_MASK,
   132f2:	2202      	movs	r2, #2
   132f4:	4611      	mov	r1, r2
   132f6:	2020      	movs	r0, #32
   132f8:	f018 fbfc 	bl	2baf4 <ad469x_spi_write_set_bits>
                    if (ZEPHYR_ERR_SUCCESS == err)
   132fc:	b938      	cbnz	r0, 1330e <bsp_ad469x_set_channel_sequence+0x6e>
                        err = ad469x_seq_osr_clear();
   132fe:	f7ff fdb3 	bl	12e68 <ad469x_seq_osr_clear>
   13302:	e004      	b.n	1330e <bsp_ad469x_set_channel_sequence+0x6e>
            err = ad469x_spi_write_set_bits(AD469x_REG_SEQ_CTRL, AD469x_SEQ_CTRL_STD_SEQ_EN_MASK,
   13304:	2280      	movs	r2, #128	; 0x80
   13306:	4611      	mov	r1, r2
   13308:	2022      	movs	r0, #34	; 0x22
   1330a:	f018 fbf3 	bl	2baf4 <ad469x_spi_write_set_bits>
    ad469x.channel_sequence = sequence;
   1330e:	4b06      	ldr	r3, [pc, #24]	; (13328 <bsp_ad469x_set_channel_sequence+0x88>)
   13310:	f883 406c 	strb.w	r4, [r3, #108]	; 0x6c
}
   13314:	bd10      	pop	{r4, pc}
            err = ad469x_spi_write_set_bits(AD469x_REG_SEQ_CTRL, AD469x_SEQ_CTRL_STD_SEQ_EN_MASK,
   13316:	2200      	movs	r2, #0
   13318:	2180      	movs	r1, #128	; 0x80
   1331a:	2022      	movs	r0, #34	; 0x22
   1331c:	f018 fbea 	bl	2baf4 <ad469x_spi_write_set_bits>
        break;
   13320:	e7f5      	b.n	1330e <bsp_ad469x_set_channel_sequence+0x6e>
    switch (sequence)
   13322:	f06f 0015 	mvn.w	r0, #21
   13326:	e7f2      	b.n	1330e <bsp_ad469x_set_channel_sequence+0x6e>
   13328:	200005a0 	.word	0x200005a0

0001332c <bsp_ad469x_adv_sequence_set_num_slots>:
{
   1332c:	b530      	push	{r4, r5, lr}
   1332e:	b083      	sub	sp, #12
   13330:	4604      	mov	r4, r0
    uint8_t write_num_slots = 0;
   13332:	2300      	movs	r3, #0
   13334:	f88d 3007 	strb.w	r3, [sp, #7]
    if ( 0x01 < num_slots )
   13338:	2801      	cmp	r0, #1
   1333a:	d904      	bls.n	13346 <bsp_ad469x_adv_sequence_set_num_slots+0x1a>
        write_num_slots = 0x7F & (num_slots - 1);
   1333c:	1e43      	subs	r3, r0, #1
   1333e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   13342:	f88d 3007 	strb.w	r3, [sp, #7]
    err = bsp_ad469x_reg_write( AD469x_REG_SEQ_CTRL , write_num_slots );
   13346:	f89d 1007 	ldrb.w	r1, [sp, #7]
   1334a:	2022      	movs	r0, #34	; 0x22
   1334c:	f018 fbf2 	bl	2bb34 <bsp_ad469x_reg_write>
    if( ZEPHYR_ERR_SUCCESS == err)
   13350:	4605      	mov	r5, r0
   13352:	b910      	cbnz	r0, 1335a <bsp_ad469x_adv_sequence_set_num_slots+0x2e>
        ad469x.num_slots = num_slots;
   13354:	4b05      	ldr	r3, [pc, #20]	; (1336c <bsp_ad469x_adv_sequence_set_num_slots+0x40>)
   13356:	f883 415e 	strb.w	r4, [r3, #350]	; 0x15e
    bsp_ad469x_reg_read( AD469x_REG_SEQ_CTRL , &write_num_slots);
   1335a:	f10d 0107 	add.w	r1, sp, #7
   1335e:	2022      	movs	r0, #34	; 0x22
   13360:	f018 fbf1 	bl	2bb46 <bsp_ad469x_reg_read>
}
   13364:	4628      	mov	r0, r5
   13366:	b003      	add	sp, #12
   13368:	bd30      	pop	{r4, r5, pc}
   1336a:	bf00      	nop
   1336c:	200005a0 	.word	0x200005a0

00013370 <bsp_ad469x_adv_sequence_set_slot>:
{
   13370:	b538      	push	{r3, r4, r5, lr}
   13372:	4605      	mov	r5, r0
   13374:	460c      	mov	r4, r1
    err = bsp_ad469x_reg_write( AD469x_REG_AS_SLOT(slot) , AD469x_REG_AS_SLOT_INX(channel) );
   13376:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   1337a:	f001 010f 	and.w	r1, r1, #15
   1337e:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   13382:	f018 fbd7 	bl	2bb34 <bsp_ad469x_reg_write>
    if( ZEPHYR_ERR_SUCCESS == err)
   13386:	b918      	cbnz	r0, 13390 <bsp_ad469x_adv_sequence_set_slot+0x20>
        ad469x.channel_slots[slot] = channel;
   13388:	4b02      	ldr	r3, [pc, #8]	; (13394 <bsp_ad469x_adv_sequence_set_slot+0x24>)
   1338a:	441d      	add	r5, r3
   1338c:	f885 40de 	strb.w	r4, [r5, #222]	; 0xde
}
   13390:	bd38      	pop	{r3, r4, r5, pc}
   13392:	bf00      	nop
   13394:	200005a0 	.word	0x200005a0

00013398 <bsp_ad469x_enter_conversion_mode>:
{
   13398:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1339c:	4604      	mov	r4, r0
    if( true == ad469x.conversion_mode )
   1339e:	4b37      	ldr	r3, [pc, #220]	; (1347c <bsp_ad469x_enter_conversion_mode+0xe4>)
   133a0:	f893 3162 	ldrb.w	r3, [r3, #354]	; 0x162
   133a4:	b14b      	cbz	r3, 133ba <bsp_ad469x_enter_conversion_mode+0x22>
        if( NULL != offset_needed)
   133a6:	2800      	cmp	r0, #0
   133a8:	d065      	beq.n	13476 <bsp_ad469x_enter_conversion_mode+0xde>
            *offset_needed = 0;
   133aa:	2500      	movs	r5, #0
   133ac:	7005      	strb	r5, [r0, #0]
    ad469x_spi_update_frequency( AD469X_CNV_MODE_SPI_FREQ );
   133ae:	4834      	ldr	r0, [pc, #208]	; (13480 <bsp_ad469x_enter_conversion_mode+0xe8>)
   133b0:	f7ff fd7c 	bl	12eac <ad469x_spi_update_frequency>
}
   133b4:	4628      	mov	r0, r5
   133b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        err = ad469x_spi_write_set_bits(AD469x_REG_SETUP,
   133ba:	2224      	movs	r2, #36	; 0x24
   133bc:	4611      	mov	r1, r2
   133be:	2020      	movs	r0, #32
   133c0:	f018 fb98 	bl	2baf4 <ad469x_spi_write_set_bits>
        ad469x.conversion_mode = true;
   133c4:	4e2d      	ldr	r6, [pc, #180]	; (1347c <bsp_ad469x_enter_conversion_mode+0xe4>)
   133c6:	2701      	movs	r7, #1
   133c8:	f886 7162 	strb.w	r7, [r6, #354]	; 0x162
            ad469x.spi_cs_control.gpio.pin = 22;
   133cc:	2316      	movs	r3, #22
   133ce:	7333      	strb	r3, [r6, #12]
	return gpio_pin_configure(spec->port,
   133d0:	6a30      	ldr	r0, [r6, #32]
   133d2:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
				  spec->dt_flags | extra_flags);
   133d6:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
	return gpio_pin_configure(spec->port,
   133d8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   133dc:	f7ff fd9a 	bl	12f14 <z_impl_gpio_pin_configure>
   133e0:	4605      	mov	r5, r0
            gpio_pin_set(ad469x.gpio_convert.gpio_spec.port, ad469x.gpio_convert.gpio_spec.pin , 0);
   133e2:	f8d6 8020 	ldr.w	r8, [r6, #32]
   133e6:	f896 9024 	ldrb.w	r9, [r6, #36]	; 0x24
	__unused const struct gpio_driver_config *const cfg =
   133ea:	f8d8 3004 	ldr.w	r3, [r8, #4]
	const struct gpio_driver_data *const data =
   133ee:	f8d8 6010 	ldr.w	r6, [r8, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   133f2:	681b      	ldr	r3, [r3, #0]
   133f4:	fa07 f709 	lsl.w	r7, r7, r9
   133f8:	423b      	tst	r3, r7
   133fa:	d017      	beq.n	1342c <bsp_ad469x_enter_conversion_mode+0x94>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   133fc:	6833      	ldr	r3, [r6, #0]
   133fe:	421f      	tst	r7, r3
   13400:	d122      	bne.n	13448 <bsp_ad469x_enter_conversion_mode+0xb0>
   13402:	2700      	movs	r7, #0
	__unused const struct gpio_driver_config *const cfg =
   13404:	f8d8 3004 	ldr.w	r3, [r8, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13408:	681b      	ldr	r3, [r3, #0]
   1340a:	2601      	movs	r6, #1
   1340c:	fa06 f609 	lsl.w	r6, r6, r9
   13410:	4233      	tst	r3, r6
   13412:	d01b      	beq.n	1344c <bsp_ad469x_enter_conversion_mode+0xb4>
	if (value != 0)	{
   13414:	b347      	cbz	r7, 13468 <bsp_ad469x_enter_conversion_mode+0xd0>
	const struct gpio_driver_api *api =
   13416:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return api->port_set_bits_raw(port, pins);
   1341a:	68db      	ldr	r3, [r3, #12]
   1341c:	4631      	mov	r1, r6
   1341e:	4640      	mov	r0, r8
   13420:	4798      	blx	r3
            if( NULL != offset_needed)
   13422:	2c00      	cmp	r4, #0
   13424:	d0c3      	beq.n	133ae <bsp_ad469x_enter_conversion_mode+0x16>
                *offset_needed = 2;
   13426:	2302      	movs	r3, #2
   13428:	7023      	strb	r3, [r4, #0]
   1342a:	e7c0      	b.n	133ae <bsp_ad469x_enter_conversion_mode+0x16>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1342c:	f8df a058 	ldr.w	sl, [pc, #88]	; 13488 <bsp_ad469x_enter_conversion_mode+0xf0>
   13430:	f240 5225 	movw	r2, #1317	; 0x525
   13434:	4651      	mov	r1, sl
   13436:	4813      	ldr	r0, [pc, #76]	; (13484 <bsp_ad469x_enter_conversion_mode+0xec>)
   13438:	f019 f879 	bl	2c52e <assert_print>
   1343c:	f240 5125 	movw	r1, #1317	; 0x525
   13440:	4650      	mov	r0, sl
   13442:	f019 f86d 	bl	2c520 <assert_post_action>
   13446:	e7d9      	b.n	133fc <bsp_ad469x_enter_conversion_mode+0x64>
		value = (value != 0) ? 0 : 1;
   13448:	2701      	movs	r7, #1
   1344a:	e7db      	b.n	13404 <bsp_ad469x_enter_conversion_mode+0x6c>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1344c:	f8df 9038 	ldr.w	r9, [pc, #56]	; 13488 <bsp_ad469x_enter_conversion_mode+0xf0>
   13450:	f240 42fc 	movw	r2, #1276	; 0x4fc
   13454:	4649      	mov	r1, r9
   13456:	480b      	ldr	r0, [pc, #44]	; (13484 <bsp_ad469x_enter_conversion_mode+0xec>)
   13458:	f019 f869 	bl	2c52e <assert_print>
   1345c:	f240 41fc 	movw	r1, #1276	; 0x4fc
   13460:	4648      	mov	r0, r9
   13462:	f019 f85d 	bl	2c520 <assert_post_action>
   13466:	e7d5      	b.n	13414 <bsp_ad469x_enter_conversion_mode+0x7c>
	const struct gpio_driver_api *api =
   13468:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return api->port_clear_bits_raw(port, pins);
   1346c:	691b      	ldr	r3, [r3, #16]
   1346e:	4631      	mov	r1, r6
   13470:	4640      	mov	r0, r8
   13472:	4798      	blx	r3
   13474:	e7d5      	b.n	13422 <bsp_ad469x_enter_conversion_mode+0x8a>
        err = ZEPHYR_ERR_SUCCESS;/*Already in conversion mode*/
   13476:	2500      	movs	r5, #0
   13478:	e799      	b.n	133ae <bsp_ad469x_enter_conversion_mode+0x16>
   1347a:	bf00      	nop
   1347c:	200005a0 	.word	0x200005a0
   13480:	003d0900 	.word	0x003d0900
   13484:	00031600 	.word	0x00031600
   13488:	000315cc 	.word	0x000315cc

0001348c <bsp_ad469x_trigger_reading>:
{
   1348c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13490:	b087      	sub	sp, #28
   13492:	4604      	mov	r4, r0
   13494:	4616      	mov	r6, r2
   13496:	9303      	str	r3, [sp, #12]
    uint8_t offset_account = 0;
   13498:	2300      	movs	r3, #0
   1349a:	f88d 3017 	strb.w	r3, [sp, #23]
    zephyr_err_t err = bsp_ad469x_enter_conversion_mode(&offset_account);
   1349e:	f10d 0017 	add.w	r0, sp, #23
   134a2:	f7ff ff79 	bl	13398 <bsp_ad469x_enter_conversion_mode>
    if( ZEPHYR_ERR_SUCCESS == err )
   134a6:	4607      	mov	r7, r0
   134a8:	b118      	cbz	r0, 134b2 <bsp_ad469x_trigger_reading+0x26>
}
   134aa:	4638      	mov	r0, r7
   134ac:	b007      	add	sp, #28
   134ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                uint8_t iter_amount = (uint8_t) 2 * (0x1 << (ad469x.channel_osr[slot_idx] << 0x1)) - offset_account;
   134b2:	f8df 9140 	ldr.w	r9, [pc, #320]	; 135f4 <bsp_ad469x_trigger_reading+0x168>
   134b6:	444c      	add	r4, r9
   134b8:	f894 406d 	ldrb.w	r4, [r4, #109]	; 0x6d
   134bc:	0063      	lsls	r3, r4, #1
   134be:	2402      	movs	r4, #2
   134c0:	409c      	lsls	r4, r3
   134c2:	b2e4      	uxtb	r4, r4
   134c4:	f89d 3017 	ldrb.w	r3, [sp, #23]
   134c8:	1ae4      	subs	r4, r4, r3
   134ca:	b2e4      	uxtb	r4, r4
                k_sched_lock();
   134cc:	f014 fc9a 	bl	27e04 <k_sched_lock>
                gpio_pin_set(ad469x.gpio_convert.gpio_spec.port, ad469x.gpio_convert.gpio_spec.pin, false);
   134d0:	f8d9 8020 	ldr.w	r8, [r9, #32]
   134d4:	f899 a024 	ldrb.w	sl, [r9, #36]	; 0x24
	__unused const struct gpio_driver_config *const cfg =
   134d8:	f8d8 3004 	ldr.w	r3, [r8, #4]
	const struct gpio_driver_data *const data =
   134dc:	f8d8 b010 	ldr.w	fp, [r8, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   134e0:	681b      	ldr	r3, [r3, #0]
   134e2:	f04f 0901 	mov.w	r9, #1
   134e6:	fa09 f90a 	lsl.w	r9, r9, sl
   134ea:	ea13 0f09 	tst.w	r3, r9
   134ee:	d01a      	beq.n	13526 <bsp_ad469x_trigger_reading+0x9a>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   134f0:	f8db 3000 	ldr.w	r3, [fp]
   134f4:	ea19 0f03 	tst.w	r9, r3
   134f8:	d121      	bne.n	1353e <bsp_ad469x_trigger_reading+0xb2>
   134fa:	46b9      	mov	r9, r7
	__unused const struct gpio_driver_config *const cfg =
   134fc:	f8d8 3004 	ldr.w	r3, [r8, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13500:	681b      	ldr	r3, [r3, #0]
   13502:	2201      	movs	r2, #1
   13504:	fa02 fa0a 	lsl.w	sl, r2, sl
   13508:	ea13 0f0a 	tst.w	r3, sl
   1350c:	d01a      	beq.n	13544 <bsp_ad469x_trigger_reading+0xb8>
	if (value != 0)	{
   1350e:	f1b9 0f00 	cmp.w	r9, #0
   13512:	d025      	beq.n	13560 <bsp_ad469x_trigger_reading+0xd4>
	const struct gpio_driver_api *api =
   13514:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return api->port_set_bits_raw(port, pins);
   13518:	68db      	ldr	r3, [r3, #12]
   1351a:	4651      	mov	r1, sl
   1351c:	4640      	mov	r0, r8
   1351e:	4798      	blx	r3
                for (uint8_t idx = 0; idx < iter_amount; idx++) {
   13520:	f04f 0800 	mov.w	r8, #0
	return gpio_pin_set_raw(port, pin, value);
   13524:	e02c      	b.n	13580 <bsp_ad469x_trigger_reading+0xf4>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13526:	f240 5225 	movw	r2, #1317	; 0x525
   1352a:	4930      	ldr	r1, [pc, #192]	; (135ec <bsp_ad469x_trigger_reading+0x160>)
   1352c:	4830      	ldr	r0, [pc, #192]	; (135f0 <bsp_ad469x_trigger_reading+0x164>)
   1352e:	f018 fffe 	bl	2c52e <assert_print>
   13532:	f240 5125 	movw	r1, #1317	; 0x525
   13536:	482d      	ldr	r0, [pc, #180]	; (135ec <bsp_ad469x_trigger_reading+0x160>)
   13538:	f018 fff2 	bl	2c520 <assert_post_action>
   1353c:	e7d8      	b.n	134f0 <bsp_ad469x_trigger_reading+0x64>
		value = (value != 0) ? 0 : 1;
   1353e:	f04f 0901 	mov.w	r9, #1
   13542:	e7db      	b.n	134fc <bsp_ad469x_trigger_reading+0x70>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13544:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 135ec <bsp_ad469x_trigger_reading+0x160>
   13548:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1354c:	4659      	mov	r1, fp
   1354e:	4828      	ldr	r0, [pc, #160]	; (135f0 <bsp_ad469x_trigger_reading+0x164>)
   13550:	f018 ffed 	bl	2c52e <assert_print>
   13554:	f240 41fc 	movw	r1, #1276	; 0x4fc
   13558:	4658      	mov	r0, fp
   1355a:	f018 ffe1 	bl	2c520 <assert_post_action>
   1355e:	e7d6      	b.n	1350e <bsp_ad469x_trigger_reading+0x82>
	const struct gpio_driver_api *api =
   13560:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return api->port_clear_bits_raw(port, pins);
   13564:	691b      	ldr	r3, [r3, #16]
   13566:	4651      	mov	r1, sl
   13568:	4640      	mov	r0, r8
   1356a:	4798      	blx	r3
   1356c:	e7d8      	b.n	13520 <bsp_ad469x_trigger_reading+0x94>
	const struct gpio_driver_api *api =
   1356e:	68ab      	ldr	r3, [r5, #8]
	return api->port_toggle_bits(port, pins);
   13570:	695b      	ldr	r3, [r3, #20]
   13572:	4649      	mov	r1, r9
   13574:	4628      	mov	r0, r5
   13576:	4798      	blx	r3
   13578:	f108 0801 	add.w	r8, r8, #1
   1357c:	fa5f f888 	uxtb.w	r8, r8
   13580:	45a0      	cmp	r8, r4
   13582:	d21a      	bcs.n	135ba <bsp_ad469x_trigger_reading+0x12e>
                    gpio_pin_toggle(ad469x.gpio_convert.gpio_spec.port, ad469x.gpio_convert.gpio_spec.pin);
   13584:	4b1b      	ldr	r3, [pc, #108]	; (135f4 <bsp_ad469x_trigger_reading+0x168>)
   13586:	6a1d      	ldr	r5, [r3, #32]
   13588:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
	__unused const struct gpio_driver_config *const cfg =
   1358c:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1358e:	681b      	ldr	r3, [r3, #0]
   13590:	f04f 0901 	mov.w	r9, #1
   13594:	fa09 f902 	lsl.w	r9, r9, r2
   13598:	ea13 0f09 	tst.w	r3, r9
   1359c:	d1e7      	bne.n	1356e <bsp_ad469x_trigger_reading+0xe2>
   1359e:	f8df b04c 	ldr.w	fp, [pc, #76]	; 135ec <bsp_ad469x_trigger_reading+0x160>
   135a2:	f240 524e 	movw	r2, #1358	; 0x54e
   135a6:	4659      	mov	r1, fp
   135a8:	4811      	ldr	r0, [pc, #68]	; (135f0 <bsp_ad469x_trigger_reading+0x164>)
   135aa:	f018 ffc0 	bl	2c52e <assert_print>
   135ae:	f240 514e 	movw	r1, #1358	; 0x54e
   135b2:	4658      	mov	r0, fp
   135b4:	f018 ffb4 	bl	2c520 <assert_post_action>
   135b8:	e7d9      	b.n	1356e <bsp_ad469x_trigger_reading+0xe2>
                k_sched_unlock();
   135ba:	f015 f937 	bl	2882c <k_sched_unlock>
	return z_impl_k_event_wait_all(event, events, reset, timeout);
   135be:	f8df 8038 	ldr.w	r8, [pc, #56]	; 135f8 <bsp_ad469x_trigger_reading+0x16c>
   135c2:	9600      	str	r6, [sp, #0]
   135c4:	9b03      	ldr	r3, [sp, #12]
   135c6:	9301      	str	r3, [sp, #4]
   135c8:	2200      	movs	r2, #0
   135ca:	2102      	movs	r1, #2
   135cc:	4640      	mov	r0, r8
   135ce:	f01d fbd0 	bl	30d72 <z_impl_k_event_wait_all>
   135d2:	4604      	mov	r4, r0
	z_impl_k_event_set_masked(event, events, events_mask);
   135d4:	2202      	movs	r2, #2
   135d6:	2100      	movs	r1, #0
   135d8:	4640      	mov	r0, r8
   135da:	f01d fbb7 	bl	30d4c <z_impl_k_event_set_masked>
                err = (ret_flags == 0) ? -EIO : ZEPHYR_ERR_SUCCESS;
   135de:	2c00      	cmp	r4, #0
   135e0:	f47f af63 	bne.w	134aa <bsp_ad469x_trigger_reading+0x1e>
   135e4:	f06f 0704 	mvn.w	r7, #4
    return err;
   135e8:	e75f      	b.n	134aa <bsp_ad469x_trigger_reading+0x1e>
   135ea:	bf00      	nop
   135ec:	000315cc 	.word	0x000315cc
   135f0:	00031600 	.word	0x00031600
   135f4:	200005a0 	.word	0x200005a0
   135f8:	200005fc 	.word	0x200005fc

000135fc <bsp_ad469x_gather_reading>:
{
   135fc:	b510      	push	{r4, lr}
   135fe:	b084      	sub	sp, #16
    zephyr_spi_buf_t spi_buf = {
   13600:	9002      	str	r0, [sp, #8]
   13602:	2303      	movs	r3, #3
   13604:	9303      	str	r3, [sp, #12]
    zephyr_spi_buf_set_t samples = {
   13606:	ab02      	add	r3, sp, #8
   13608:	9300      	str	r3, [sp, #0]
   1360a:	2301      	movs	r3, #1
   1360c:	9301      	str	r3, [sp, #4]
    err = spi_transceive(ad469x.spi_device, &ad469x.spi_config , NULL , &samples );
   1360e:	4905      	ldr	r1, [pc, #20]	; (13624 <bsp_ad469x_gather_reading+0x28>)
   13610:	6848      	ldr	r0, [r1, #4]
	const struct spi_driver_api *api =
   13612:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   13614:	681c      	ldr	r4, [r3, #0]
   13616:	466b      	mov	r3, sp
   13618:	2200      	movs	r2, #0
   1361a:	3114      	adds	r1, #20
   1361c:	47a0      	blx	r4
}
   1361e:	b004      	add	sp, #16
   13620:	bd10      	pop	{r4, pc}
   13622:	bf00      	nop
   13624:	200005a0 	.word	0x200005a0

00013628 <bsp_ad469x_process_raw>:
{
   13628:	b410      	push	{r4}
    raw_sample = ( raw_sample   & 0x0000FF00 ) | ( ( raw_sample & 0x00FF0000 ) >> 16 ) | ( ( raw_sample & 0x000000FF ) << 16 );
   1362a:	f402 4c7f 	and.w	ip, r2, #65280	; 0xff00
   1362e:	f3c2 4407 	ubfx	r4, r2, #16, #8
   13632:	ea4c 0c04 	orr.w	ip, ip, r4
   13636:	0412      	lsls	r2, r2, #16
   13638:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
   1363c:	ea4c 0202 	orr.w	r2, ip, r2
            .raw_reading  = raw_sample >> SIZE_OF_STATUS_BITS, /*Remove the 5 status bits*/
   13640:	0954      	lsrs	r4, r2, #5
    bsp_ad469x_reading_t reading = {
   13642:	6004      	str	r4, [r0, #0]
   13644:	f890 c004 	ldrb.w	ip, [r0, #4]
   13648:	f362 0c04 	bfi	ip, r2, #0, #5
   1364c:	f880 c004 	strb.w	ip, [r0, #4]
    reading.raw_reading = reading.raw_reading >> (0x3 - ad469x.channel_osr[slot] );
   13650:	4a05      	ldr	r2, [pc, #20]	; (13668 <bsp_ad469x_process_raw+0x40>)
   13652:	440a      	add	r2, r1
   13654:	f892 206d 	ldrb.w	r2, [r2, #109]	; 0x6d
   13658:	f1c2 0203 	rsb	r2, r2, #3
   1365c:	40d4      	lsrs	r4, r2
   1365e:	6004      	str	r4, [r0, #0]
}
   13660:	f85d 4b04 	ldr.w	r4, [sp], #4
   13664:	4770      	bx	lr
   13666:	bf00      	nop
   13668:	200005a0 	.word	0x200005a0

0001366c <bsp_ad469x_take_reading>:
{
   1366c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1366e:	b087      	sub	sp, #28
    uint32_t adc_sample = 0;
   13670:	2400      	movs	r4, #0
   13672:	9405      	str	r4, [sp, #20]
    for (uint8_t idx = 0; idx < ad469x.num_slots ; idx++)
   13674:	e001      	b.n	1367a <bsp_ad469x_take_reading+0xe>
   13676:	3401      	adds	r4, #1
   13678:	b2e4      	uxtb	r4, r4
   1367a:	4b1a      	ldr	r3, [pc, #104]	; (136e4 <bsp_ad469x_take_reading+0x78>)
   1367c:	f893 315e 	ldrb.w	r3, [r3, #350]	; 0x15e
   13680:	42a3      	cmp	r3, r4
   13682:	d92d      	bls.n	136e0 <bsp_ad469x_take_reading+0x74>
        channel_to_sample = ad469x.channel_slots[idx];
   13684:	4d17      	ldr	r5, [pc, #92]	; (136e4 <bsp_ad469x_take_reading+0x78>)
   13686:	4425      	add	r5, r4
   13688:	f895 70de 	ldrb.w	r7, [r5, #222]	; 0xde
        bsp_ad469x_trigger_reading( channel_to_sample , K_NO_WAIT/*K_USEC(10)*/ );
   1368c:	2200      	movs	r2, #0
   1368e:	2300      	movs	r3, #0
   13690:	4638      	mov	r0, r7
   13692:	f7ff fefb 	bl	1348c <bsp_ad469x_trigger_reading>
        bsp_ad469x_gather_reading( &adc_sample );
   13696:	a805      	add	r0, sp, #20
   13698:	f7ff ffb0 	bl	135fc <bsp_ad469x_gather_reading>
        processed_reading = bsp_ad469x_process_raw( channel_to_sample , adc_sample );
   1369c:	466e      	mov	r6, sp
   1369e:	9a05      	ldr	r2, [sp, #20]
   136a0:	4639      	mov	r1, r7
   136a2:	4630      	mov	r0, r6
   136a4:	f7ff ffc0 	bl	13628 <bsp_ad469x_process_raw>
   136a8:	ab03      	add	r3, sp, #12
   136aa:	e896 0003 	ldmia.w	r6, {r0, r1}
   136ae:	e883 0003 	stmia.w	r3, {r0, r1}
        if( ad469x.channel_slots[idx] == processed_reading.status.channel )
   136b2:	f895 20de 	ldrb.w	r2, [r5, #222]	; 0xde
   136b6:	f89d 3010 	ldrb.w	r3, [sp, #16]
   136ba:	f003 030f 	and.w	r3, r3, #15
   136be:	429a      	cmp	r2, r3
   136c0:	d1d9      	bne.n	13676 <bsp_ad469x_take_reading+0xa>
            k_msgq_put(&adc_channel_queue[channel_to_sample] , (void*) &processed_reading , K_NO_WAIT );
   136c2:	4809      	ldr	r0, [pc, #36]	; (136e8 <bsp_ad469x_take_reading+0x7c>)
   136c4:	2334      	movs	r3, #52	; 0x34
   136c6:	fb03 0007 	mla	r0, r3, r7, r0
	return z_impl_k_msgq_put(msgq, data, timeout);
   136ca:	2200      	movs	r2, #0
   136cc:	2300      	movs	r3, #0
   136ce:	a903      	add	r1, sp, #12
   136d0:	f013 f842 	bl	26758 <z_impl_k_msgq_put>
            k_event_post( &adc_read_event , (0x1 << channel_to_sample) );
   136d4:	2101      	movs	r1, #1
   136d6:	40b9      	lsls	r1, r7
	z_impl_k_event_post(event, events);
   136d8:	4804      	ldr	r0, [pc, #16]	; (136ec <bsp_ad469x_take_reading+0x80>)
   136da:	f01d fb2c 	bl	30d36 <z_impl_k_event_post>
   136de:	e7ca      	b.n	13676 <bsp_ad469x_take_reading+0xa>
}
   136e0:	b007      	add	sp, #28
   136e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   136e4:	200005a0 	.word	0x200005a0
   136e8:	200028ec 	.word	0x200028ec
   136ec:	20002e80 	.word	0x20002e80

000136f0 <bsp_ad469x_trigger_hardware_reset>:
{
   136f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    zephyr_err_t err = gpio_pin_set( ad469x.gpio_reset.gpio_spec.port , ad469x.gpio_reset.gpio_spec.pin , true );
   136f4:	4b66      	ldr	r3, [pc, #408]	; (13890 <bsp_ad469x_trigger_hardware_reset+0x1a0>)
   136f6:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   136f8:	f893 604c 	ldrb.w	r6, [r3, #76]	; 0x4c
	__unused const struct gpio_driver_config *const cfg =
   136fc:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   136fe:	6927      	ldr	r7, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13700:	681b      	ldr	r3, [r3, #0]
   13702:	2501      	movs	r5, #1
   13704:	40b5      	lsls	r5, r6
   13706:	422b      	tst	r3, r5
   13708:	d019      	beq.n	1373e <bsp_ad469x_trigger_hardware_reset+0x4e>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1370a:	683b      	ldr	r3, [r7, #0]
   1370c:	421d      	tst	r5, r3
   1370e:	d124      	bne.n	1375a <bsp_ad469x_trigger_hardware_reset+0x6a>
   13710:	2501      	movs	r5, #1
	__unused const struct gpio_driver_config *const cfg =
   13712:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13714:	681b      	ldr	r3, [r3, #0]
   13716:	2201      	movs	r2, #1
   13718:	fa02 f606 	lsl.w	r6, r2, r6
   1371c:	4233      	tst	r3, r6
   1371e:	d01e      	beq.n	1375e <bsp_ad469x_trigger_hardware_reset+0x6e>
	if (value != 0)	{
   13720:	b355      	cbz	r5, 13778 <bsp_ad469x_trigger_hardware_reset+0x88>
	const struct gpio_driver_api *api =
   13722:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   13724:	68db      	ldr	r3, [r3, #12]
   13726:	4631      	mov	r1, r6
   13728:	4620      	mov	r0, r4
   1372a:	4798      	blx	r3
   1372c:	4604      	mov	r4, r0
    if( ZEPHYR_ERR_SUCCESS == err )
   1372e:	b354      	cbz	r4, 13786 <bsp_ad469x_trigger_hardware_reset+0x96>
	return z_impl_k_sleep(timeout);
   13730:	200b      	movs	r0, #11
   13732:	2100      	movs	r1, #0
   13734:	f015 fb12 	bl	28d5c <z_impl_k_sleep>
}
   13738:	4620      	mov	r0, r4
   1373a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1373e:	f8df 8158 	ldr.w	r8, [pc, #344]	; 13898 <bsp_ad469x_trigger_hardware_reset+0x1a8>
   13742:	f240 5225 	movw	r2, #1317	; 0x525
   13746:	4641      	mov	r1, r8
   13748:	4852      	ldr	r0, [pc, #328]	; (13894 <bsp_ad469x_trigger_hardware_reset+0x1a4>)
   1374a:	f018 fef0 	bl	2c52e <assert_print>
   1374e:	f240 5125 	movw	r1, #1317	; 0x525
   13752:	4640      	mov	r0, r8
   13754:	f018 fee4 	bl	2c520 <assert_post_action>
   13758:	e7d7      	b.n	1370a <bsp_ad469x_trigger_hardware_reset+0x1a>
		value = (value != 0) ? 0 : 1;
   1375a:	2500      	movs	r5, #0
   1375c:	e7d9      	b.n	13712 <bsp_ad469x_trigger_hardware_reset+0x22>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1375e:	4f4e      	ldr	r7, [pc, #312]	; (13898 <bsp_ad469x_trigger_hardware_reset+0x1a8>)
   13760:	f240 42fc 	movw	r2, #1276	; 0x4fc
   13764:	4639      	mov	r1, r7
   13766:	484b      	ldr	r0, [pc, #300]	; (13894 <bsp_ad469x_trigger_hardware_reset+0x1a4>)
   13768:	f018 fee1 	bl	2c52e <assert_print>
   1376c:	f240 41fc 	movw	r1, #1276	; 0x4fc
   13770:	4638      	mov	r0, r7
   13772:	f018 fed5 	bl	2c520 <assert_post_action>
   13776:	e7d3      	b.n	13720 <bsp_ad469x_trigger_hardware_reset+0x30>
	const struct gpio_driver_api *api =
   13778:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   1377a:	691b      	ldr	r3, [r3, #16]
   1377c:	4631      	mov	r1, r6
   1377e:	4620      	mov	r0, r4
   13780:	4798      	blx	r3
   13782:	4604      	mov	r4, r0
   13784:	e7d3      	b.n	1372e <bsp_ad469x_trigger_hardware_reset+0x3e>
        err = gpio_pin_set( ad469x.gpio_reset.gpio_spec.port , ad469x.gpio_reset.gpio_spec.pin , false );
   13786:	4b42      	ldr	r3, [pc, #264]	; (13890 <bsp_ad469x_trigger_hardware_reset+0x1a0>)
   13788:	6c9f      	ldr	r7, [r3, #72]	; 0x48
   1378a:	f893 804c 	ldrb.w	r8, [r3, #76]	; 0x4c
	__unused const struct gpio_driver_config *const cfg =
   1378e:	687b      	ldr	r3, [r7, #4]
	const struct gpio_driver_data *const data =
   13790:	693d      	ldr	r5, [r7, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13792:	681b      	ldr	r3, [r3, #0]
   13794:	2601      	movs	r6, #1
   13796:	fa06 f608 	lsl.w	r6, r6, r8
   1379a:	4233      	tst	r3, r6
   1379c:	d034      	beq.n	13808 <bsp_ad469x_trigger_hardware_reset+0x118>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1379e:	682b      	ldr	r3, [r5, #0]
   137a0:	421e      	tst	r6, r3
   137a2:	d000      	beq.n	137a6 <bsp_ad469x_trigger_hardware_reset+0xb6>
		value = (value != 0) ? 0 : 1;
   137a4:	2401      	movs	r4, #1
	__unused const struct gpio_driver_config *const cfg =
   137a6:	687b      	ldr	r3, [r7, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   137a8:	681b      	ldr	r3, [r3, #0]
   137aa:	2501      	movs	r5, #1
   137ac:	fa05 f508 	lsl.w	r5, r5, r8
   137b0:	422b      	tst	r3, r5
   137b2:	d037      	beq.n	13824 <bsp_ad469x_trigger_hardware_reset+0x134>
	if (value != 0)	{
   137b4:	2c00      	cmp	r4, #0
   137b6:	d042      	beq.n	1383e <bsp_ad469x_trigger_hardware_reset+0x14e>
	const struct gpio_driver_api *api =
   137b8:	68bb      	ldr	r3, [r7, #8]
	return api->port_set_bits_raw(port, pins);
   137ba:	68db      	ldr	r3, [r3, #12]
   137bc:	4629      	mov	r1, r5
   137be:	4638      	mov	r0, r7
   137c0:	4798      	blx	r3
   137c2:	4604      	mov	r4, r0
        if( ZEPHYR_ERR_SUCCESS == err )
   137c4:	2c00      	cmp	r4, #0
   137c6:	d1b3      	bne.n	13730 <bsp_ad469x_trigger_hardware_reset+0x40>
            err = gpio_pin_set( ad469x.gpio_reset.gpio_spec.port , ad469x.gpio_reset.gpio_spec.pin , true );
   137c8:	4b31      	ldr	r3, [pc, #196]	; (13890 <bsp_ad469x_trigger_hardware_reset+0x1a0>)
   137ca:	6c9d      	ldr	r5, [r3, #72]	; 0x48
   137cc:	f893 804c 	ldrb.w	r8, [r3, #76]	; 0x4c
	__unused const struct gpio_driver_config *const cfg =
   137d0:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   137d2:	692e      	ldr	r6, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   137d4:	681b      	ldr	r3, [r3, #0]
   137d6:	2701      	movs	r7, #1
   137d8:	fa07 f708 	lsl.w	r7, r7, r8
   137dc:	423b      	tst	r3, r7
   137de:	d035      	beq.n	1384c <bsp_ad469x_trigger_hardware_reset+0x15c>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   137e0:	6833      	ldr	r3, [r6, #0]
   137e2:	421f      	tst	r7, r3
   137e4:	d100      	bne.n	137e8 <bsp_ad469x_trigger_hardware_reset+0xf8>
   137e6:	2401      	movs	r4, #1
	__unused const struct gpio_driver_config *const cfg =
   137e8:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   137ea:	681b      	ldr	r3, [r3, #0]
   137ec:	2601      	movs	r6, #1
   137ee:	fa06 f608 	lsl.w	r6, r6, r8
   137f2:	4233      	tst	r3, r6
   137f4:	d038      	beq.n	13868 <bsp_ad469x_trigger_hardware_reset+0x178>
	if (value != 0)	{
   137f6:	2c00      	cmp	r4, #0
   137f8:	d043      	beq.n	13882 <bsp_ad469x_trigger_hardware_reset+0x192>
	const struct gpio_driver_api *api =
   137fa:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   137fc:	68db      	ldr	r3, [r3, #12]
   137fe:	4631      	mov	r1, r6
   13800:	4628      	mov	r0, r5
   13802:	4798      	blx	r3
   13804:	4604      	mov	r4, r0
   13806:	e793      	b.n	13730 <bsp_ad469x_trigger_hardware_reset+0x40>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13808:	f8df 908c 	ldr.w	r9, [pc, #140]	; 13898 <bsp_ad469x_trigger_hardware_reset+0x1a8>
   1380c:	f240 5225 	movw	r2, #1317	; 0x525
   13810:	4649      	mov	r1, r9
   13812:	4820      	ldr	r0, [pc, #128]	; (13894 <bsp_ad469x_trigger_hardware_reset+0x1a4>)
   13814:	f018 fe8b 	bl	2c52e <assert_print>
   13818:	f240 5125 	movw	r1, #1317	; 0x525
   1381c:	4648      	mov	r0, r9
   1381e:	f018 fe7f 	bl	2c520 <assert_post_action>
   13822:	e7bc      	b.n	1379e <bsp_ad469x_trigger_hardware_reset+0xae>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13824:	4e1c      	ldr	r6, [pc, #112]	; (13898 <bsp_ad469x_trigger_hardware_reset+0x1a8>)
   13826:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1382a:	4631      	mov	r1, r6
   1382c:	4819      	ldr	r0, [pc, #100]	; (13894 <bsp_ad469x_trigger_hardware_reset+0x1a4>)
   1382e:	f018 fe7e 	bl	2c52e <assert_print>
   13832:	f240 41fc 	movw	r1, #1276	; 0x4fc
   13836:	4630      	mov	r0, r6
   13838:	f018 fe72 	bl	2c520 <assert_post_action>
   1383c:	e7ba      	b.n	137b4 <bsp_ad469x_trigger_hardware_reset+0xc4>
	const struct gpio_driver_api *api =
   1383e:	68bb      	ldr	r3, [r7, #8]
	return api->port_clear_bits_raw(port, pins);
   13840:	691b      	ldr	r3, [r3, #16]
   13842:	4629      	mov	r1, r5
   13844:	4638      	mov	r0, r7
   13846:	4798      	blx	r3
   13848:	4604      	mov	r4, r0
   1384a:	e7bb      	b.n	137c4 <bsp_ad469x_trigger_hardware_reset+0xd4>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1384c:	f8df 9048 	ldr.w	r9, [pc, #72]	; 13898 <bsp_ad469x_trigger_hardware_reset+0x1a8>
   13850:	f240 5225 	movw	r2, #1317	; 0x525
   13854:	4649      	mov	r1, r9
   13856:	480f      	ldr	r0, [pc, #60]	; (13894 <bsp_ad469x_trigger_hardware_reset+0x1a4>)
   13858:	f018 fe69 	bl	2c52e <assert_print>
   1385c:	f240 5125 	movw	r1, #1317	; 0x525
   13860:	4648      	mov	r0, r9
   13862:	f018 fe5d 	bl	2c520 <assert_post_action>
   13866:	e7bb      	b.n	137e0 <bsp_ad469x_trigger_hardware_reset+0xf0>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   13868:	4f0b      	ldr	r7, [pc, #44]	; (13898 <bsp_ad469x_trigger_hardware_reset+0x1a8>)
   1386a:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1386e:	4639      	mov	r1, r7
   13870:	4808      	ldr	r0, [pc, #32]	; (13894 <bsp_ad469x_trigger_hardware_reset+0x1a4>)
   13872:	f018 fe5c 	bl	2c52e <assert_print>
   13876:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1387a:	4638      	mov	r0, r7
   1387c:	f018 fe50 	bl	2c520 <assert_post_action>
   13880:	e7b9      	b.n	137f6 <bsp_ad469x_trigger_hardware_reset+0x106>
	const struct gpio_driver_api *api =
   13882:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   13884:	691b      	ldr	r3, [r3, #16]
   13886:	4631      	mov	r1, r6
   13888:	4628      	mov	r0, r5
   1388a:	4798      	blx	r3
   1388c:	4604      	mov	r4, r0
	return ret;
   1388e:	e74f      	b.n	13730 <bsp_ad469x_trigger_hardware_reset+0x40>
   13890:	200005a0 	.word	0x200005a0
   13894:	00031600 	.word	0x00031600
   13898:	000315cc 	.word	0x000315cc

0001389c <ad469x_gpio_reset_init>:
{
   1389c:	b510      	push	{r4, lr}
	return gpio_pin_configure(spec->port,
   1389e:	4b12      	ldr	r3, [pc, #72]	; (138e8 <ad469x_gpio_reset_init+0x4c>)
   138a0:	6c98      	ldr	r0, [r3, #72]	; 0x48
   138a2:	f893 104c 	ldrb.w	r1, [r3, #76]	; 0x4c
				  spec->dt_flags | extra_flags);
   138a6:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
	return gpio_pin_configure(spec->port,
   138aa:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   138ae:	f7ff fb31 	bl	12f14 <z_impl_gpio_pin_configure>
    if( ZEPHYR_ERR_SUCCESS == err )
   138b2:	4604      	mov	r4, r0
   138b4:	b118      	cbz	r0, 138be <ad469x_gpio_reset_init+0x22>
    bsp_ad469x_trigger_hardware_reset();
   138b6:	f7ff ff1b 	bl	136f0 <bsp_ad469x_trigger_hardware_reset>
}
   138ba:	4620      	mov	r0, r4
   138bc:	bd10      	pop	{r4, pc}
                           BIT(ad469x.gpio_reset.gpio_spec.pin));
   138be:	4b0a      	ldr	r3, [pc, #40]	; (138e8 <ad469x_gpio_reset_init+0x4c>)
   138c0:	f893 104c 	ldrb.w	r1, [r3, #76]	; 0x4c
   138c4:	2201      	movs	r2, #1
   138c6:	408a      	lsls	r2, r1
	callback->handler = handler;
   138c8:	4908      	ldr	r1, [pc, #32]	; (138ec <ad469x_gpio_reset_init+0x50>)
   138ca:	6559      	str	r1, [r3, #84]	; 0x54
	callback->pin_mask = pin_mask;
   138cc:	659a      	str	r2, [r3, #88]	; 0x58
        err = gpio_add_callback(ad469x.gpio_reset.gpio_spec.port, &ad469x.gpio_reset.gpio_callback);
   138ce:	6c98      	ldr	r0, [r3, #72]	; 0x48
	const struct gpio_driver_api *api =
   138d0:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   138d2:	69db      	ldr	r3, [r3, #28]
   138d4:	b123      	cbz	r3, 138e0 <ad469x_gpio_reset_init+0x44>
	return api->manage_callback(port, callback, true);
   138d6:	2201      	movs	r2, #1
   138d8:	4905      	ldr	r1, [pc, #20]	; (138f0 <ad469x_gpio_reset_init+0x54>)
   138da:	4798      	blx	r3
   138dc:	4604      	mov	r4, r0
   138de:	e7ea      	b.n	138b6 <ad469x_gpio_reset_init+0x1a>
		return -ENOTSUP;
   138e0:	f06f 0485 	mvn.w	r4, #133	; 0x85
   138e4:	e7e7      	b.n	138b6 <ad469x_gpio_reset_init+0x1a>
   138e6:	bf00      	nop
   138e8:	200005a0 	.word	0x200005a0
   138ec:	00012ef5 	.word	0x00012ef5
   138f0:	200005f0 	.word	0x200005f0

000138f4 <bsp_ad469x_init>:
{
   138f4:	b510      	push	{r4, lr}
   138f6:	b09e      	sub	sp, #120	; 0x78
    if( (device_is_ready(ad469x.spi_device) == true) &&
   138f8:	4b2e      	ldr	r3, [pc, #184]	; (139b4 <bsp_ad469x_init+0xc0>)
   138fa:	6858      	ldr	r0, [r3, #4]
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
   138fc:	f01c ffc2 	bl	30884 <z_device_is_ready>
   13900:	2800      	cmp	r0, #0
   13902:	d048      	beq.n	13996 <bsp_ad469x_init+0xa2>
        (device_is_ready(ad469x.gpio_convert.gpio_spec.port) == true) &&
   13904:	4b2b      	ldr	r3, [pc, #172]	; (139b4 <bsp_ad469x_init+0xc0>)
   13906:	6a18      	ldr	r0, [r3, #32]
   13908:	f01c ffbc 	bl	30884 <z_device_is_ready>
    if( (device_is_ready(ad469x.spi_device) == true) &&
   1390c:	2800      	cmp	r0, #0
   1390e:	d045      	beq.n	1399c <bsp_ad469x_init+0xa8>
        (device_is_ready(ad469x.gpio_busy.gpio_spec.port) == true) &&
   13910:	4b28      	ldr	r3, [pc, #160]	; (139b4 <bsp_ad469x_init+0xc0>)
   13912:	6b58      	ldr	r0, [r3, #52]	; 0x34
   13914:	f01c ffb6 	bl	30884 <z_device_is_ready>
        (device_is_ready(ad469x.gpio_convert.gpio_spec.port) == true) &&
   13918:	2800      	cmp	r0, #0
   1391a:	d042      	beq.n	139a2 <bsp_ad469x_init+0xae>
        (device_is_ready(ad469x.gpio_reset.gpio_spec.port) == true) &&
   1391c:	4b25      	ldr	r3, [pc, #148]	; (139b4 <bsp_ad469x_init+0xc0>)
   1391e:	6c98      	ldr	r0, [r3, #72]	; 0x48
   13920:	f01c ffb0 	bl	30884 <z_device_is_ready>
        (device_is_ready(ad469x.gpio_busy.gpio_spec.port) == true) &&
   13924:	2800      	cmp	r0, #0
   13926:	d03f      	beq.n	139a8 <bsp_ad469x_init+0xb4>
        (device_is_ready(ad469x.spi_cs_control.gpio.port) == true) )
   13928:	4b22      	ldr	r3, [pc, #136]	; (139b4 <bsp_ad469x_init+0xc0>)
   1392a:	6898      	ldr	r0, [r3, #8]
   1392c:	f01c ffaa 	bl	30884 <z_device_is_ready>
        (device_is_ready(ad469x.gpio_reset.gpio_spec.port) == true) &&
   13930:	2800      	cmp	r0, #0
   13932:	d03c      	beq.n	139ae <bsp_ad469x_init+0xba>
	z_impl_k_event_init(event);
   13934:	4820      	ldr	r0, [pc, #128]	; (139b8 <bsp_ad469x_init+0xc4>)
   13936:	f01d f9f8 	bl	30d2a <z_impl_k_event_init>
        ad469x_queue_init();
   1393a:	f7ff fabd 	bl	12eb8 <ad469x_queue_init>
        err = ad469x_gpio_reset_init();
   1393e:	f7ff ffad 	bl	1389c <ad469x_gpio_reset_init>
        if( ZEPHYR_ERR_SUCCESS == err )
   13942:	b108      	cbz	r0, 13948 <bsp_ad469x_init+0x54>
}
   13944:	b01e      	add	sp, #120	; 0x78
   13946:	bd10      	pop	{r4, pc}
            err = ad469x_gpio_busy_init();
   13948:	f7ff fb92 	bl	13070 <ad469x_gpio_busy_init>
            if( ZEPHYR_ERR_SUCCESS == err )
   1394c:	2800      	cmp	r0, #0
   1394e:	d1f9      	bne.n	13944 <bsp_ad469x_init+0x50>
                    err = bsp_ad469x_trigger_software_reset();
   13950:	f018 f918 	bl	2bb84 <bsp_ad469x_trigger_software_reset>
                    if( ZEPHYR_ERR_SUCCESS == err )
   13954:	2800      	cmp	r0, #0
   13956:	d1f5      	bne.n	13944 <bsp_ad469x_init+0x50>
                        err = bsp_ad469x_set_reg_access_mode(AD469x_BYTE_ACCESS);
   13958:	2000      	movs	r0, #0
   1395a:	f018 f8fe 	bl	2bb5a <bsp_ad469x_set_reg_access_mode>
                        if (ZEPHYR_ERR_SUCCESS == err)
   1395e:	2800      	cmp	r0, #0
   13960:	d1f0      	bne.n	13944 <bsp_ad469x_init+0x50>
                            err = bsp_ad469x_init_busy(AD469X_BUSY_GP0);
   13962:	2000      	movs	r0, #0
   13964:	f018 f902 	bl	2bb6c <bsp_ad469x_init_busy>
                            if (ZEPHYR_ERR_SUCCESS == err)
   13968:	2800      	cmp	r0, #0
   1396a:	d1eb      	bne.n	13944 <bsp_ad469x_init+0x50>
                                err = ad469x_adv_seq_init();
   1396c:	f7ff fc2e 	bl	131cc <ad469x_adv_seq_init>
                                if( ZEPHYR_ERR_SUCCESS == err )
   13970:	2800      	cmp	r0, #0
   13972:	d1e7      	bne.n	13944 <bsp_ad469x_init+0x50>
                                    err = bsp_ad469x_setup_advanced_sequencer( ad469x_default_as );
   13974:	4c11      	ldr	r4, [pc, #68]	; (139bc <bsp_ad469x_init+0xc8>)
   13976:	2271      	movs	r2, #113	; 0x71
   13978:	f104 0110 	add.w	r1, r4, #16
   1397c:	4668      	mov	r0, sp
   1397e:	f01d fa72 	bl	30e66 <memcpy>
   13982:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   13986:	f018 f924 	bl	2bbd2 <bsp_ad469x_setup_advanced_sequencer>
                                    if (ZEPHYR_ERR_SUCCESS == err)
   1398a:	2800      	cmp	r0, #0
   1398c:	d1da      	bne.n	13944 <bsp_ad469x_init+0x50>
                                        err = bsp_ad469x_start_advanced_sequencer(true);
   1398e:	2001      	movs	r0, #1
   13990:	f018 f915 	bl	2bbbe <bsp_ad469x_start_advanced_sequencer>
   13994:	e7d6      	b.n	13944 <bsp_ad469x_init+0x50>
    zephyr_err_t err = -ENODEV;
   13996:	f06f 0012 	mvn.w	r0, #18
   1399a:	e7d3      	b.n	13944 <bsp_ad469x_init+0x50>
   1399c:	f06f 0012 	mvn.w	r0, #18
   139a0:	e7d0      	b.n	13944 <bsp_ad469x_init+0x50>
   139a2:	f06f 0012 	mvn.w	r0, #18
   139a6:	e7cd      	b.n	13944 <bsp_ad469x_init+0x50>
   139a8:	f06f 0012 	mvn.w	r0, #18
   139ac:	e7ca      	b.n	13944 <bsp_ad469x_init+0x50>
   139ae:	f06f 0012 	mvn.w	r0, #18
    return err;
   139b2:	e7c7      	b.n	13944 <bsp_ad469x_init+0x50>
   139b4:	200005a0 	.word	0x200005a0
   139b8:	200005fc 	.word	0x200005fc
   139bc:	00031618 	.word	0x00031618

000139c0 <bsp_ad469x_get_slots_at_idx>:
    return ad469x.channel_slots[ idx ];
   139c0:	4b02      	ldr	r3, [pc, #8]	; (139cc <bsp_ad469x_get_slots_at_idx+0xc>)
   139c2:	4403      	add	r3, r0
}
   139c4:	f893 00de 	ldrb.w	r0, [r3, #222]	; 0xde
   139c8:	4770      	bx	lr
   139ca:	bf00      	nop
   139cc:	200005a0 	.word	0x200005a0

000139d0 <bsp_adc_reading_thread>:
}

/***************************** - Private Functions - *******************************/

__NO_RETURN static void bsp_adc_reading_thread(void* arg1 , void* arg2 , void* arg3 )
{
   139d0:	b500      	push	{lr}
   139d2:	b083      	sub	sp, #12
   139d4:	e014      	b.n	13a00 <bsp_adc_reading_thread+0x30>
        //We are only sampling low frequency signals so the timing is not significantly critical.
        err = k_mutex_lock( &adc_queue_lock , adc_sample_period );
        if( ZEPHYR_ERR_SUCCESS == err )
        {
            /*Take a sample of the desired channels*/
            bsp_ad469x_take_reading();
   139d6:	f7ff fe49 	bl	1366c <bsp_ad469x_take_reading>
	return z_impl_k_mutex_unlock(mutex);
   139da:	480e      	ldr	r0, [pc, #56]	; (13a14 <bsp_adc_reading_thread+0x44>)
   139dc:	f013 f8ee 	bl	26bbc <z_impl_k_mutex_unlock>
	return z_impl_k_event_wait(event, events, reset, timeout);
   139e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   139e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   139e8:	e9cd 2300 	strd	r2, r3, [sp]
   139ec:	2200      	movs	r2, #0
   139ee:	2101      	movs	r1, #1
   139f0:	4809      	ldr	r0, [pc, #36]	; (13a18 <bsp_adc_reading_thread+0x48>)
   139f2:	f01d f9af 	bl	30d54 <z_impl_k_event_wait>
            /*Unlock the mutex*/
            k_mutex_unlock( &adc_queue_lock );
        }
        /*Used to pause the thread at a known point*/
        k_event_wait(&adc_thread_events , BSP_ADC_PAUSE_SAMPLING_EVENT , false , K_FOREVER);
        k_sleep( adc_sample_period );
   139f6:	4b09      	ldr	r3, [pc, #36]	; (13a1c <bsp_adc_reading_thread+0x4c>)
   139f8:	e9d3 0100 	ldrd	r0, r1, [r3]
	return z_impl_k_sleep(timeout);
   139fc:	f015 f9ae 	bl	28d5c <z_impl_k_sleep>
        err = k_mutex_lock( &adc_queue_lock , adc_sample_period );
   13a00:	4b06      	ldr	r3, [pc, #24]	; (13a1c <bsp_adc_reading_thread+0x4c>)
   13a02:	e9d3 2300 	ldrd	r2, r3, [r3]
	return z_impl_k_mutex_lock(mutex, timeout);
   13a06:	4803      	ldr	r0, [pc, #12]	; (13a14 <bsp_adc_reading_thread+0x44>)
   13a08:	f012 ffe2 	bl	269d0 <z_impl_k_mutex_lock>
        if( ZEPHYR_ERR_SUCCESS == err )
   13a0c:	2800      	cmp	r0, #0
   13a0e:	d0e2      	beq.n	139d6 <bsp_adc_reading_thread+0x6>
   13a10:	e7e6      	b.n	139e0 <bsp_adc_reading_thread+0x10>
   13a12:	bf00      	nop
   13a14:	20002e98 	.word	0x20002e98
   13a18:	20002eac 	.word	0x20002eac
   13a1c:	20001d00 	.word	0x20001d00

00013a20 <bsp_adc_init>:
{
   13a20:	b510      	push	{r4, lr}
   13a22:	b088      	sub	sp, #32
    zephyr_err_t err = bsp_ad469x_init();
   13a24:	f7ff ff66 	bl	138f4 <bsp_ad469x_init>
    if( ZEPHYR_ERR_SUCCESS == err )
   13a28:	4604      	mov	r4, r0
   13a2a:	b110      	cbz	r0, 13a32 <bsp_adc_init+0x12>
}
   13a2c:	4620      	mov	r0, r4
   13a2e:	b008      	add	sp, #32
   13a30:	bd10      	pop	{r4, pc}
	return z_impl_k_mutex_init(mutex);
   13a32:	4818      	ldr	r0, [pc, #96]	; (13a94 <bsp_adc_init+0x74>)
   13a34:	f01c ffb5 	bl	309a2 <z_impl_k_mutex_init>
        if( ZEPHYR_ERR_SUCCESS == err )
   13a38:	4604      	mov	r4, r0
   13a3a:	2800      	cmp	r0, #0
   13a3c:	d1f6      	bne.n	13a2c <bsp_adc_init+0xc>
	z_impl_k_event_init(event);
   13a3e:	4816      	ldr	r0, [pc, #88]	; (13a98 <bsp_adc_init+0x78>)
   13a40:	f01d f973 	bl	30d2a <z_impl_k_event_init>
            adc_channel_queue = bsp_ad469x_get_data_queues_handle();
   13a44:	f7ff fb64 	bl	13110 <bsp_ad469x_get_data_queues_handle>
   13a48:	4b14      	ldr	r3, [pc, #80]	; (13a9c <bsp_adc_init+0x7c>)
   13a4a:	6018      	str	r0, [r3, #0]
            ad469x_events    = bsp_ad469x_get_data_event_handle();
   13a4c:	f7ff fb5c 	bl	13108 <bsp_ad469x_get_data_event_handle>
   13a50:	4b13      	ldr	r3, [pc, #76]	; (13aa0 <bsp_adc_init+0x80>)
   13a52:	6018      	str	r0, [r3, #0]
            adc_sample_period = K_MSEC( ADC_READ_PERIOD );
   13a54:	4b13      	ldr	r3, [pc, #76]	; (13aa4 <bsp_adc_init+0x84>)
   13a56:	f240 6067 	movw	r0, #1639	; 0x667
   13a5a:	2100      	movs	r1, #0
   13a5c:	e9c3 0100 	strd	r0, r1, [r3]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   13a60:	f640 42cd 	movw	r2, #3277	; 0xccd
   13a64:	2300      	movs	r3, #0
   13a66:	e9cd 2306 	strd	r2, r3, [sp, #24]
   13a6a:	2303      	movs	r3, #3
   13a6c:	9304      	str	r3, [sp, #16]
   13a6e:	2301      	movs	r3, #1
   13a70:	9303      	str	r3, [sp, #12]
   13a72:	2300      	movs	r3, #0
   13a74:	9302      	str	r3, [sp, #8]
   13a76:	9301      	str	r3, [sp, #4]
   13a78:	9300      	str	r3, [sp, #0]
   13a7a:	4b0b      	ldr	r3, [pc, #44]	; (13aa8 <bsp_adc_init+0x88>)
   13a7c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   13a80:	490a      	ldr	r1, [pc, #40]	; (13aac <bsp_adc_init+0x8c>)
   13a82:	480b      	ldr	r0, [pc, #44]	; (13ab0 <bsp_adc_init+0x90>)
   13a84:	f012 fd5e 	bl	26544 <z_impl_k_thread_create>
            adc_thread_tid = k_thread_create(&adc_thread, adc_thread_stack, ADC_THREAD_STACK,
   13a88:	4b0a      	ldr	r3, [pc, #40]	; (13ab4 <bsp_adc_init+0x94>)
   13a8a:	6018      	str	r0, [r3, #0]
	return z_impl_k_thread_name_set(thread, str);
   13a8c:	490a      	ldr	r1, [pc, #40]	; (13ab8 <bsp_adc_init+0x98>)
   13a8e:	f01c ff43 	bl	30918 <z_impl_k_thread_name_set>
    return err;
   13a92:	e7cb      	b.n	13a2c <bsp_adc_init+0xc>
   13a94:	20002e98 	.word	0x20002e98
   13a98:	20002eac 	.word	0x20002eac
   13a9c:	20002e94 	.word	0x20002e94
   13aa0:	20002e90 	.word	0x20002e90
   13aa4:	20001d00 	.word	0x20001d00
   13aa8:	000139d1 	.word	0x000139d1
   13aac:	20004780 	.word	0x20004780
   13ab0:	20001d08 	.word	0x20001d08
   13ab4:	20002ebc 	.word	0x20002ebc
   13ab8:	0003169c 	.word	0x0003169c

00013abc <bsp_adc_get_channel_reading>:
{
   13abc:	b5f0      	push	{r4, r5, r6, r7, lr}
   13abe:	b085      	sub	sp, #20
   13ac0:	460d      	mov	r5, r1
   13ac2:	4614      	mov	r4, r2
    slot_idx = bsp_ad469x_get_slots_at_idx( slot_idx );
   13ac4:	f7ff ff7c 	bl	139c0 <bsp_ad469x_get_slots_at_idx>
        ret_flags = k_event_wait(ad469x_events , 1 << slot_idx , false , timeout );
   13ac8:	4b1a      	ldr	r3, [pc, #104]	; (13b34 <bsp_adc_get_channel_reading+0x78>)
   13aca:	681e      	ldr	r6, [r3, #0]
   13acc:	2301      	movs	r3, #1
   13ace:	fa03 f100 	lsl.w	r1, r3, r0
	return z_impl_k_event_wait(event, events, reset, timeout);
   13ad2:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   13ad6:	e9cd 2300 	strd	r2, r3, [sp]
   13ada:	2200      	movs	r2, #0
   13adc:	4630      	mov	r0, r6
   13ade:	f01d f939 	bl	30d54 <z_impl_k_event_wait>
        if( ret_flags != 0  )
   13ae2:	b918      	cbnz	r0, 13aec <bsp_adc_get_channel_reading+0x30>
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;//k_mutex_lock( &adc_queue_lock , timeout );
   13ae4:	2600      	movs	r6, #0
}
   13ae6:	4630      	mov	r0, r6
   13ae8:	b005      	add	sp, #20
   13aea:	bdf0      	pop	{r4, r5, r6, r7, pc}
            ch_to_check = bsp_adc_event_to_ch( ret_flags );
   13aec:	f018 f892 	bl	2bc14 <bsp_adc_event_to_ch>
   13af0:	4607      	mov	r7, r0
            err = k_msgq_get(&adc_channel_queue[ch_to_check] , &adc_result , K_NO_WAIT);
   13af2:	4b11      	ldr	r3, [pc, #68]	; (13b38 <bsp_adc_get_channel_reading+0x7c>)
   13af4:	6818      	ldr	r0, [r3, #0]
   13af6:	2334      	movs	r3, #52	; 0x34
   13af8:	fb03 0007 	mla	r0, r3, r7, r0
	return z_impl_k_msgq_get(msgq, data, timeout);
   13afc:	2200      	movs	r2, #0
   13afe:	2300      	movs	r3, #0
   13b00:	a902      	add	r1, sp, #8
   13b02:	f012 fec3 	bl	2688c <z_impl_k_msgq_get>
            if ( ZEPHYR_ERR_SUCCESS == err )
   13b06:	4606      	mov	r6, r0
   13b08:	2800      	cmp	r0, #0
   13b0a:	d1ec      	bne.n	13ae6 <bsp_adc_get_channel_reading+0x2a>
                *sampled_data = adc_result.raw_reading;
   13b0c:	9b02      	ldr	r3, [sp, #8]
   13b0e:	602b      	str	r3, [r5, #0]
                flags->over_voltage = adc_result.status.ov_flag;
   13b10:	f89d 200c 	ldrb.w	r2, [sp, #12]
   13b14:	f3c2 1300 	ubfx	r3, r2, #4, #1
   13b18:	7063      	strb	r3, [r4, #1]
                flags->channel = adc_result.status.channel;
   13b1a:	7823      	ldrb	r3, [r4, #0]
   13b1c:	f362 0303 	bfi	r3, r2, #0, #4
   13b20:	7023      	strb	r3, [r4, #0]
                k_event_set_masked(ad469x_events , 0 , 1 << ch_to_check );
   13b22:	4b04      	ldr	r3, [pc, #16]	; (13b34 <bsp_adc_get_channel_reading+0x78>)
   13b24:	6818      	ldr	r0, [r3, #0]
   13b26:	2201      	movs	r2, #1
   13b28:	40ba      	lsls	r2, r7
	z_impl_k_event_set_masked(event, events, events_mask);
   13b2a:	2100      	movs	r1, #0
   13b2c:	f01d f90e 	bl	30d4c <z_impl_k_event_set_masked>
}
   13b30:	e7d9      	b.n	13ae6 <bsp_adc_get_channel_reading+0x2a>
   13b32:	bf00      	nop
   13b34:	20002e90 	.word	0x20002e90
   13b38:	20002e94 	.word	0x20002e94

00013b3c <bsp_adc_set_period>:
{
   13b3c:	b570      	push	{r4, r5, r6, lr}
   13b3e:	4606      	mov	r6, r0
   13b40:	460c      	mov	r4, r1
    zephyr_err_t err = k_mutex_lock( &adc_queue_lock , adc_sample_period );
   13b42:	4b08      	ldr	r3, [pc, #32]	; (13b64 <bsp_adc_set_period+0x28>)
   13b44:	e9d3 2300 	ldrd	r2, r3, [r3]
	return z_impl_k_mutex_lock(mutex, timeout);
   13b48:	4807      	ldr	r0, [pc, #28]	; (13b68 <bsp_adc_set_period+0x2c>)
   13b4a:	f012 ff41 	bl	269d0 <z_impl_k_mutex_lock>
    if( ZEPHYR_ERR_SUCCESS == err )
   13b4e:	4605      	mov	r5, r0
   13b50:	b108      	cbz	r0, 13b56 <bsp_adc_set_period+0x1a>
}
   13b52:	4628      	mov	r0, r5
   13b54:	bd70      	pop	{r4, r5, r6, pc}
        adc_sample_period = period;
   13b56:	4b03      	ldr	r3, [pc, #12]	; (13b64 <bsp_adc_set_period+0x28>)
   13b58:	601e      	str	r6, [r3, #0]
   13b5a:	605c      	str	r4, [r3, #4]
	return z_impl_k_mutex_unlock(mutex);
   13b5c:	4802      	ldr	r0, [pc, #8]	; (13b68 <bsp_adc_set_period+0x2c>)
   13b5e:	f013 f82d 	bl	26bbc <z_impl_k_mutex_unlock>
    return err;
   13b62:	e7f6      	b.n	13b52 <bsp_adc_set_period+0x16>
   13b64:	20001d00 	.word	0x20001d00
   13b68:	20002e98 	.word	0x20002e98

00013b6c <bsp_adc_get_period>:
    return adc_sample_period;
   13b6c:	4b02      	ldr	r3, [pc, #8]	; (13b78 <bsp_adc_get_period+0xc>)
   13b6e:	e9d3 2300 	ldrd	r2, r3, [r3]
   13b72:	e9c0 2300 	strd	r2, r3, [r0]
}
   13b76:	4770      	bx	lr
   13b78:	20001d00 	.word	0x20001d00

00013b7c <bsp_adc_stop_sampling>:
{
   13b7c:	b508      	push	{r3, lr}
	z_impl_k_event_set_masked(event, events, events_mask);
   13b7e:	2201      	movs	r2, #1
   13b80:	2100      	movs	r1, #0
   13b82:	4802      	ldr	r0, [pc, #8]	; (13b8c <bsp_adc_stop_sampling+0x10>)
   13b84:	f01d f8e2 	bl	30d4c <z_impl_k_event_set_masked>
}
   13b88:	bd08      	pop	{r3, pc}
   13b8a:	bf00      	nop
   13b8c:	20002eac 	.word	0x20002eac

00013b90 <bsp_adc_resume_sampling>:
{
   13b90:	b508      	push	{r3, lr}
	z_impl_k_event_set(event, events);
   13b92:	2101      	movs	r1, #1
   13b94:	4801      	ldr	r0, [pc, #4]	; (13b9c <bsp_adc_resume_sampling+0xc>)
   13b96:	f01d f8d3 	bl	30d40 <z_impl_k_event_set>
}
   13b9a:	bd08      	pop	{r3, pc}
   13b9c:	20002eac 	.word	0x20002eac

00013ba0 <bsp_heart_rate_signal_process>:
/***************************** - Public Functions - ********************************/



void bsp_heart_rate_signal_process( zephyr_k_work_t* calling_work )
{
   13ba0:	b530      	push	{r4, r5, lr}
   13ba2:	b083      	sub	sp, #12
    bsp_signal_processing_work_t* work_to_do = CONTAINER_OF( calling_work , bsp_signal_processing_work_t , work );
    /*Here is your data for the work*/
    uint32_t* raw_readings = work_to_do->in_data[0];
   13ba4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   13ba6:	681c      	ldr	r4, [r3, #0]
    uint8_t   raw_reading_num = work_to_do->readings_to_buffer;

    /*Ensure no other signal processing work thread is running when this is*/
    zephyr_err_t err = k_mutex_lock( &work_to_do->lock , K_FOREVER );
   13ba8:	f100 0514 	add.w	r5, r0, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   13bac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13bb0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13bb4:	4628      	mov	r0, r5
   13bb6:	f012 ff0b 	bl	269d0 <z_impl_k_mutex_lock>
    if( ZEPHYR_ERR_SUCCESS == err )
   13bba:	b1b8      	cbz	r0, 13bec <bsp_heart_rate_signal_process+0x4c>
        bsp_sensor_interface_publish_vital( VITALS_VITAL_TYPE_ID_HEART_RATE ,
                                            &data_storage_ptr , sizeof(uint16_t**) );
        k_mutex_unlock(&work_to_do->lock);
    }

}
   13bbc:	b003      	add	sp, #12
   13bbe:	bd30      	pop	{r4, r5, pc}
            ppg_data_storage[i] = raw_readings[i];
   13bc0:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
   13bc4:	4a0a      	ldr	r2, [pc, #40]	; (13bf0 <bsp_heart_rate_signal_process+0x50>)
   13bc6:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
        for (uint16_t i = 0; i < BSP_HEART_RATE_READINGS_TO_BUFFER ; i++)
   13bca:	3301      	adds	r3, #1
   13bcc:	b29b      	uxth	r3, r3
   13bce:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   13bd2:	d3f5      	bcc.n	13bc0 <bsp_heart_rate_signal_process+0x20>
        uint16_t** data_storage_ptr = (uint16_t **) &ppg_data_storage;
   13bd4:	4b06      	ldr	r3, [pc, #24]	; (13bf0 <bsp_heart_rate_signal_process+0x50>)
   13bd6:	9301      	str	r3, [sp, #4]
        bsp_sensor_interface_publish_vital( VITALS_VITAL_TYPE_ID_HEART_RATE ,
   13bd8:	2204      	movs	r2, #4
   13bda:	eb0d 0102 	add.w	r1, sp, r2
   13bde:	2002      	movs	r0, #2
   13be0:	f000 fc74 	bl	144cc <bsp_sensor_interface_publish_vital>
	return z_impl_k_mutex_unlock(mutex);
   13be4:	4628      	mov	r0, r5
   13be6:	f012 ffe9 	bl	26bbc <z_impl_k_mutex_unlock>
   13bea:	e7e7      	b.n	13bbc <bsp_heart_rate_signal_process+0x1c>
        for (uint16_t i = 0; i < BSP_HEART_RATE_READINGS_TO_BUFFER ; i++)
   13bec:	2300      	movs	r3, #0
   13bee:	e7ee      	b.n	13bce <bsp_heart_rate_signal_process+0x2e>
   13bf0:	20002ec0 	.word	0x20002ec0

00013bf4 <bsp_respiration_signal_process>:
/********************************* - Constants - ***********************************/
/********************************* - Variables - ***********************************/
/***************************** - Public Functions - ********************************/

void bsp_respiration_signal_process( zephyr_k_work_t* calling_work )
{
   13bf4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   13bf8:	ed2d 8b02 	vpush	{d8}
   13bfc:	b085      	sub	sp, #20
   13bfe:	af02      	add	r7, sp, #8
   13c00:	4606      	mov	r6, r0
    bsp_signal_processing_work_t* work_to_do = CONTAINER_OF( calling_work , bsp_signal_processing_work_t , work );
    /*Here is your data for the work*/
    int32_t*  raw_readings = work_to_do->in_data[0];
   13c02:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   13c04:	681d      	ldr	r5, [r3, #0]
    uint16_t   raw_reading_num = work_to_do->readings_to_buffer;
   13c06:	8d04      	ldrh	r4, [r0, #40]	; 0x28
    int16_t   raw_readings_16[work_to_do->readings_to_buffer];
   13c08:	0063      	lsls	r3, r4, #1
   13c0a:	3307      	adds	r3, #7
   13c0c:	08db      	lsrs	r3, r3, #3
   13c0e:	466a      	mov	r2, sp
   13c10:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
   13c14:	469d      	mov	sp, r3

    /*Ensure no other signal processing work thread is running when this is*/
    zephyr_err_t err = k_mutex_lock( &work_to_do->lock , K_FOREVER );
   13c16:	f100 0914 	add.w	r9, r0, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   13c1a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13c1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13c22:	4648      	mov	r0, r9
   13c24:	f012 fed4 	bl	269d0 <z_impl_k_mutex_lock>
    if( ZEPHYR_ERR_SUCCESS == err )
   13c28:	b188      	cbz	r0, 13c4e <bsp_respiration_signal_process+0x5a>

        k_free( Y );

        k_mutex_unlock(&work_to_do->lock);
    }
}
   13c2a:	370c      	adds	r7, #12
   13c2c:	46bd      	mov	sp, r7
   13c2e:	ecbd 8b02 	vpop	{d8}
   13c32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            total += (raw_readings[i]/8);
   13c36:	eb01 01e2 	add.w	r1, r1, r2, asr #3
        for(uint16_t i = 0 ; i < raw_reading_num ; i++)
   13c3a:	3301      	adds	r3, #1
   13c3c:	b29b      	uxth	r3, r3
   13c3e:	42a3      	cmp	r3, r4
   13c40:	d20a      	bcs.n	13c58 <bsp_respiration_signal_process+0x64>
            total += (raw_readings[i]/8);
   13c42:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
   13c46:	2a00      	cmp	r2, #0
   13c48:	daf5      	bge.n	13c36 <bsp_respiration_signal_process+0x42>
   13c4a:	3207      	adds	r2, #7
   13c4c:	e7f3      	b.n	13c36 <bsp_respiration_signal_process+0x42>
   13c4e:	f10d 0808 	add.w	r8, sp, #8
   13c52:	4601      	mov	r1, r0
        for(uint16_t i = 0 ; i < raw_reading_num ; i++)
   13c54:	2300      	movs	r3, #0
   13c56:	e7f2      	b.n	13c3e <bsp_respiration_signal_process+0x4a>
        int32_t average = total / (raw_reading_num);
   13c58:	fb91 f1f4 	sdiv	r1, r1, r4
        for(uint16_t i = 0 ; i < raw_reading_num ; i++)
   13c5c:	2300      	movs	r3, #0
   13c5e:	e005      	b.n	13c6c <bsp_respiration_signal_process+0x78>
            raw_readings_16[i] = (int16_t) (raw_readings[i]/8 - average);
   13c60:	ebc1 02e2 	rsb	r2, r1, r2, asr #3
   13c64:	f828 2013 	strh.w	r2, [r8, r3, lsl #1]
        for(uint16_t i = 0 ; i < raw_reading_num ; i++)
   13c68:	3301      	adds	r3, #1
   13c6a:	b29b      	uxth	r3, r3
   13c6c:	42a3      	cmp	r3, r4
   13c6e:	d205      	bcs.n	13c7c <bsp_respiration_signal_process+0x88>
            raw_readings_16[i] = (int16_t) (raw_readings[i]/8 - average);
   13c70:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
   13c74:	2a00      	cmp	r2, #0
   13c76:	daf3      	bge.n	13c60 <bsp_respiration_signal_process+0x6c>
   13c78:	3207      	adds	r2, #7
   13c7a:	e7f1      	b.n	13c60 <bsp_respiration_signal_process+0x6c>
        complex_t* Y = ( complex_t* ) k_calloc( raw_reading_num , sizeof(complex_t) );
   13c7c:	2108      	movs	r1, #8
   13c7e:	4620      	mov	r0, r4
   13c80:	f01d f895 	bl	30dae <k_calloc>
   13c84:	4605      	mov	r5, r0
        bsp_fft(raw_readings_16, raw_reading_num, Y);
   13c86:	4602      	mov	r2, r0
   13c88:	4621      	mov	r1, r4
   13c8a:	4640      	mov	r0, r8
   13c8c:	f7fd fea4 	bl	119d8 <bsp_fft>
        uint16_t peak_idx = 0U;
   13c90:	2300      	movs	r3, #0
   13c92:	807b      	strh	r3, [r7, #2]
        float peak = 0.0f;
   13c94:	2200      	movs	r2, #0
   13c96:	607a      	str	r2, [r7, #4]
        bsp_fft_find_peak( Y , raw_reading_num , &peak , &peak_idx , 0 );
   13c98:	9300      	str	r3, [sp, #0]
   13c9a:	1cbb      	adds	r3, r7, #2
   13c9c:	1d3a      	adds	r2, r7, #4
   13c9e:	4621      	mov	r1, r4
   13ca0:	4628      	mov	r0, r5
   13ca2:	f000 fe61 	bl	14968 <bsp_fft_find_peak>
        uint8_t respiration_rate = (uint8_t) (60.0f * AS_FLOAT(peak_idx) * (1.0f/(AS_FLOAT(bsp_sensor_interface_get_sample_rate() * (1 + work_to_do->readings_to_skip))/1000.0f))/AS_FLOAT(256));
   13ca6:	887b      	ldrh	r3, [r7, #2]
   13ca8:	ee08 3a10 	vmov	s16, r3
   13cac:	eeb8 8a48 	vcvt.f32.u32	s16, s16
   13cb0:	eddf 7a18 	vldr	s15, [pc, #96]	; 13d14 <bsp_respiration_signal_process+0x120>
   13cb4:	ee28 8a27 	vmul.f32	s16, s16, s15
   13cb8:	f017 ffc7 	bl	2bc4a <bsp_sensor_interface_get_sample_rate>
   13cbc:	ee07 0a90 	vmov	s15, r0
   13cc0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   13cc4:	f896 3038 	ldrb.w	r3, [r6, #56]	; 0x38
   13cc8:	3301      	adds	r3, #1
   13cca:	ee07 3a90 	vmov	s15, r3
   13cce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   13cd2:	ee67 7a87 	vmul.f32	s15, s15, s14
   13cd6:	eddf 6a10 	vldr	s13, [pc, #64]	; 13d18 <bsp_respiration_signal_process+0x124>
   13cda:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   13cde:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   13ce2:	eec6 7a87 	vdiv.f32	s15, s13, s14
   13ce6:	ee28 8a27 	vmul.f32	s16, s16, s15
   13cea:	eddf 7a0c 	vldr	s15, [pc, #48]	; 13d1c <bsp_respiration_signal_process+0x128>
   13cee:	ee28 8a27 	vmul.f32	s16, s16, s15
   13cf2:	eefc 7ac8 	vcvt.u32.f32	s15, s16
   13cf6:	ee17 3a90 	vmov	r3, s15
   13cfa:	707b      	strb	r3, [r7, #1]
        bsp_sensor_interface_publish_vital( VITALS_VITAL_TYPE_ID_RESPIRATION ,
   13cfc:	2201      	movs	r2, #1
   13cfe:	18b9      	adds	r1, r7, r2
   13d00:	4610      	mov	r0, r2
   13d02:	f000 fbe3 	bl	144cc <bsp_sensor_interface_publish_vital>
        k_free( Y );
   13d06:	4628      	mov	r0, r5
   13d08:	f01d f842 	bl	30d90 <k_free>
	return z_impl_k_mutex_unlock(mutex);
   13d0c:	4648      	mov	r0, r9
   13d0e:	f012 ff55 	bl	26bbc <z_impl_k_mutex_unlock>
   13d12:	e78a      	b.n	13c2a <bsp_respiration_signal_process+0x36>
   13d14:	42700000 	.word	0x42700000
   13d18:	447a0000 	.word	0x447a0000
   13d1c:	3b800000 	.word	0x3b800000

00013d20 <bsp_acceleration_signal_process>:
/********************************* - Constants - ***********************************/
/********************************* - Variables - ***********************************/
/***************************** - Public Functions - ********************************/

void bsp_acceleration_signal_process(zephyr_k_work_t* calling_work)
{
   13d20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13d24:	b083      	sub	sp, #12
     * Elements are:
     * in_data, in_data_len
     */
    bsp_signal_processing_work_t* work_to_do = CONTAINER_OF( calling_work , bsp_signal_processing_work_t , work );
    /*Here is your data for the work*/
    int32_t* raw_readings_x = work_to_do->in_data[0];
   13d26:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   13d28:	f8d3 9000 	ldr.w	r9, [r3]
    int32_t* raw_readings_y = work_to_do->in_data[1];
   13d2c:	f8d3 a004 	ldr.w	sl, [r3, #4]
    int32_t* raw_readings_z = work_to_do->in_data[2];
   13d30:	f8d3 b008 	ldr.w	fp, [r3, #8]

    uint8_t   raw_reading_num = work_to_do->readings_to_buffer;
   13d34:	f890 8028 	ldrb.w	r8, [r0, #40]	; 0x28

    // Value to be posted to the BLE characteristic has format
    // |<-immobile_periods(16)->|<-mobile_readings(8)->|<-status_information(8)->|
    uint32_t acceleration_vital_report = 0;
   13d38:	2300      	movs	r3, #0
   13d3a:	9301      	str	r3, [sp, #4]

    /*Ensure no other signal processing work thread is running when this is*/
    zephyr_err_t err = k_mutex_lock( &work_to_do->lock , K_FOREVER );
   13d3c:	f100 0614 	add.w	r6, r0, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   13d40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13d44:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13d48:	4630      	mov	r0, r6
   13d4a:	f012 fe41 	bl	269d0 <z_impl_k_mutex_lock>
    if( ZEPHYR_ERR_SUCCESS == err )
   13d4e:	b388      	cbz	r0, 13db4 <bsp_acceleration_signal_process+0x94>
                                            &acceleration_vital_report , sizeof(uint32_t) );

        k_mutex_unlock(&work_to_do->lock);
    }

}
   13d50:	b003      	add	sp, #12
   13d52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (uint8_t i = 0 ; i < raw_reading_num ; i++)
   13d56:	3401      	adds	r4, #1
   13d58:	b2e4      	uxtb	r4, r4
   13d5a:	4544      	cmp	r4, r8
   13d5c:	d22e      	bcs.n	13dbc <bsp_acceleration_signal_process+0x9c>
            reading_magnitude = (uint32_t) sqrtf( AS_FLOAT( raw_readings_x[i]*raw_readings_x[i] +
   13d5e:	f859 3024 	ldr.w	r3, [r9, r4, lsl #2]
   13d62:	ee07 3a90 	vmov	s15, r3
   13d66:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   13d6a:	ee27 0aa7 	vmul.f32	s0, s15, s15
   13d6e:	f85a 3024 	ldr.w	r3, [sl, r4, lsl #2]
   13d72:	fb03 f303 	mul.w	r3, r3, r3
   13d76:	ee07 3a90 	vmov	s15, r3
   13d7a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   13d7e:	ee77 7a80 	vadd.f32	s15, s15, s0
   13d82:	f85b 3024 	ldr.w	r3, [fp, r4, lsl #2]
   13d86:	fb03 f303 	mul.w	r3, r3, r3
   13d8a:	ee07 3a10 	vmov	s14, r3
   13d8e:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
   13d92:	ee30 0a27 	vadd.f32	s0, s0, s15
   13d96:	f016 ffaf 	bl	2acf8 <sqrtf>
   13d9a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   13d9e:	ee17 3a90 	vmov	r3, s15
            if(reading_magnitude > ACCELEROMETER_FALL_THRESHOLD)
   13da2:	2b64      	cmp	r3, #100	; 0x64
   13da4:	d901      	bls.n	13daa <bsp_acceleration_signal_process+0x8a>
                status_information |= ACCELEROMETER_FALL_WARNING_MASK;
   13da6:	f047 0701 	orr.w	r7, r7, #1
            if(reading_magnitude > ACCELEROMETER_MOBILE_THRESHOLD)
   13daa:	2b32      	cmp	r3, #50	; 0x32
   13dac:	d9d3      	bls.n	13d56 <bsp_acceleration_signal_process+0x36>
                mobile_readings++;
   13dae:	3501      	adds	r5, #1
   13db0:	b2ed      	uxtb	r5, r5
   13db2:	e7d0      	b.n	13d56 <bsp_acceleration_signal_process+0x36>
        for (uint8_t i = 0 ; i < raw_reading_num ; i++)
   13db4:	2400      	movs	r4, #0
        uint8_t status_information = 0;
   13db6:	4627      	mov	r7, r4
        uint8_t mobile_readings = 0;
   13db8:	4625      	mov	r5, r4
   13dba:	e7ce      	b.n	13d5a <bsp_acceleration_signal_process+0x3a>
        if(mobile_readings == 0)
   13dbc:	b9e5      	cbnz	r5, 13df8 <bsp_acceleration_signal_process+0xd8>
            immobile_periods++;
   13dbe:	4a10      	ldr	r2, [pc, #64]	; (13e00 <bsp_acceleration_signal_process+0xe0>)
   13dc0:	8813      	ldrh	r3, [r2, #0]
   13dc2:	3301      	adds	r3, #1
   13dc4:	8013      	strh	r3, [r2, #0]
        if(immobile_periods > ACCELEROMETER_IMMOBILE_WARNING_THRESHOLD)
   13dc6:	4b0e      	ldr	r3, [pc, #56]	; (13e00 <bsp_acceleration_signal_process+0xe0>)
   13dc8:	881a      	ldrh	r2, [r3, #0]
   13dca:	2a0a      	cmp	r2, #10
   13dcc:	d901      	bls.n	13dd2 <bsp_acceleration_signal_process+0xb2>
            status_information |= ACCELEROMETER_IMMOBILE_WARNING_MASK;
   13dce:	f047 0702 	orr.w	r7, r7, #2
        acceleration_vital_report |= immobile_periods << 16;
   13dd2:	9b01      	ldr	r3, [sp, #4]
   13dd4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   13dd8:	9301      	str	r3, [sp, #4]
        acceleration_vital_report |= mobile_readings << 8;
   13dda:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
   13dde:	9501      	str	r5, [sp, #4]
        acceleration_vital_report |= status_information;
   13de0:	432f      	orrs	r7, r5
   13de2:	9701      	str	r7, [sp, #4]
        bsp_sensor_interface_publish_vital( VITALS_VITAL_TYPE_ID_ACCELERATION ,
   13de4:	2204      	movs	r2, #4
   13de6:	eb0d 0102 	add.w	r1, sp, r2
   13dea:	2003      	movs	r0, #3
   13dec:	f000 fb6e 	bl	144cc <bsp_sensor_interface_publish_vital>
	return z_impl_k_mutex_unlock(mutex);
   13df0:	4630      	mov	r0, r6
   13df2:	f012 fee3 	bl	26bbc <z_impl_k_mutex_unlock>
   13df6:	e7ab      	b.n	13d50 <bsp_acceleration_signal_process+0x30>
            immobile_periods = 0;
   13df8:	4b01      	ldr	r3, [pc, #4]	; (13e00 <bsp_acceleration_signal_process+0xe0>)
   13dfa:	2200      	movs	r2, #0
   13dfc:	801a      	strh	r2, [r3, #0]
   13dfe:	e7e2      	b.n	13dc6 <bsp_acceleration_signal_process+0xa6>
   13e00:	20004708 	.word	0x20004708

00013e04 <bsp_thermometer_signal_process>:
/********************************* - Constants - ***********************************/
/********************************* - Variables - ***********************************/
/***************************** - Public Functions - ********************************/

void bsp_thermometer_signal_process(zephyr_k_work_t* calling_work)
{
   13e04:	b570      	push	{r4, r5, r6, lr}
   13e06:	b082      	sub	sp, #8
     * Elements are:
     * in_data, in_data_len
     */
    bsp_signal_processing_work_t* work_to_do = CONTAINER_OF( calling_work , bsp_signal_processing_work_t , work );
    /*Here is your data for the work*/
    uint32_t* raw_readings = work_to_do->in_data[0];
   13e08:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   13e0a:	681e      	ldr	r6, [r3, #0]
    /*from 0 to raw_reading_num - 1 readings*/
    uint16_t   raw_reading_num = work_to_do->readings_to_buffer;
   13e0c:	8d05      	ldrh	r5, [r0, #40]	; 0x28

    /*Ensure no other signal processing work thread is running when this is*/
    zephyr_err_t err = k_mutex_lock( &work_to_do->lock , K_FOREVER );
   13e0e:	f100 0414 	add.w	r4, r0, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   13e12:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13e16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13e1a:	4620      	mov	r0, r4
   13e1c:	f012 fdd8 	bl	269d0 <z_impl_k_mutex_lock>
    if( ZEPHYR_ERR_SUCCESS == err )
   13e20:	bb50      	cbnz	r0, 13e78 <bsp_thermometer_signal_process+0x74>
        // If using in-amp
        //(*raw_readings-19968) >> 6;

        // Without in-amp
        // do sign extension from 19-bit input
        uint32_t neweset_reading = raw_readings[raw_reading_num - 1];/*-1 as the buffer is 0 to raw_reading_num - 1*/
   13e22:	f105 4380 	add.w	r3, r5, #1073741824	; 0x40000000
   13e26:	3b01      	subs	r3, #1
   13e28:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
        uint32_t raw_temperature = (neweset_reading & BIT(18)) ?
                (neweset_reading  | ((uint32_t) GENMASK(31,19))) : (neweset_reading & ((uint32_t) GENMASK(18,0)));
   13e2c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   13e30:	d024      	beq.n	13e7c <bsp_thermometer_signal_process+0x78>
   13e32:	ea6f 3343 	mvn.w	r3, r3, lsl #13
   13e36:	ea6f 3353 	mvn.w	r3, r3, lsr #13
        int32_t temperature_old;
        memcpy(&temperature_old , &raw_temperature , sizeof(int32_t));

        temperature_old += BSP_AD469X_CALIBRATIONS_TEMPERATURE_OFFSET;
   13e3a:	f503 5312 	add.w	r3, r3, #9344	; 0x2480
   13e3e:	3308      	adds	r3, #8
        temperature_old = (int32_t) (1.4862f * ((float) temperature_old));
   13e40:	ee07 3a90 	vmov	s15, r3
   13e44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   13e48:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 13e84 <bsp_thermometer_signal_process+0x80>
   13e4c:	ee67 7a87 	vmul.f32	s15, s15, s14
   13e50:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   13e54:	ee17 3a90 	vmov	r3, s15
        // Map codes to temperature
        int32_t temperature = 200+((-65536 - temperature_old) >> 7);
   13e58:	f1c3 437f 	rsb	r3, r3, #4278190080	; 0xff000000
   13e5c:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
   13e60:	11db      	asrs	r3, r3, #7
   13e62:	33c8      	adds	r3, #200	; 0xc8
   13e64:	9301      	str	r3, [sp, #4]
#ifdef BSP_THERMOMETER_GIVE_RAW_READINGS
        printk("0x%x,%d,%d,\n",neweset_reading,temperature_old,temperature);
#endif


        bsp_sensor_interface_publish_vital( VITALS_VITAL_TYPE_ID_TEMPERATURE ,
   13e66:	2204      	movs	r2, #4
   13e68:	eb0d 0102 	add.w	r1, sp, r2
   13e6c:	2000      	movs	r0, #0
   13e6e:	f000 fb2d 	bl	144cc <bsp_sensor_interface_publish_vital>
	return z_impl_k_mutex_unlock(mutex);
   13e72:	4620      	mov	r0, r4
   13e74:	f012 fea2 	bl	26bbc <z_impl_k_mutex_unlock>
                                            &temperature , sizeof(int32_t) );

        k_mutex_unlock(&work_to_do->lock);
    }

}
   13e78:	b002      	add	sp, #8
   13e7a:	bd70      	pop	{r4, r5, r6, pc}
                (neweset_reading  | ((uint32_t) GENMASK(31,19))) : (neweset_reading & ((uint32_t) GENMASK(18,0)));
   13e7c:	f3c3 0312 	ubfx	r3, r3, #0, #19
   13e80:	e7db      	b.n	13e3a <bsp_thermometer_signal_process+0x36>
   13e82:	bf00      	nop
   13e84:	3fbe3bcd 	.word	0x3fbe3bcd

00013e88 <bsp_sensor_interface_slot_to_work_thread>:
        }
    }
}

static uint8_t bsp_sensor_interface_slot_to_work_thread( uint8_t slot , uint8_t* placed_slot )
{
   13e88:	4684      	mov	ip, r0
    uint8_t ret_val = 0xFF;
    for (uint8_t vitals_idx = 0; vitals_idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX; vitals_idx++)
   13e8a:	2000      	movs	r0, #0
   13e8c:	2803      	cmp	r0, #3
   13e8e:	d822      	bhi.n	13ed6 <bsp_sensor_interface_slot_to_work_thread+0x4e>
{
   13e90:	b410      	push	{r4}
   13e92:	e007      	b.n	13ea4 <bsp_sensor_interface_slot_to_work_thread+0x1c>
        for (uint8_t slots_idx = 0; slots_idx < sensor_work[vitals_idx].slots_used; slots_idx++)
        {
            if( sensor_work[vitals_idx].slots_to_watch[slots_idx] == slot )
            {
                ret_val = vitals_idx;
                *placed_slot = slots_idx;
   13e94:	700b      	strb	r3, [r1, #0]
            }
        }
    }
    func_return:
    return ret_val;
}
   13e96:	f85d 4b04 	ldr.w	r4, [sp], #4
   13e9a:	4770      	bx	lr
    for (uint8_t vitals_idx = 0; vitals_idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX; vitals_idx++)
   13e9c:	3001      	adds	r0, #1
   13e9e:	b2c0      	uxtb	r0, r0
   13ea0:	2803      	cmp	r0, #3
   13ea2:	d816      	bhi.n	13ed2 <bsp_sensor_interface_slot_to_work_thread+0x4a>
        for (uint8_t slots_idx = 0; slots_idx < sensor_work[vitals_idx].slots_used; slots_idx++)
   13ea4:	2300      	movs	r3, #0
   13ea6:	ebc0 1200 	rsb	r2, r0, r0, lsl #4
   13eaa:	4c0c      	ldr	r4, [pc, #48]	; (13edc <bsp_sensor_interface_slot_to_work_thread+0x54>)
   13eac:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   13eb0:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
   13eb4:	429a      	cmp	r2, r3
   13eb6:	d9f1      	bls.n	13e9c <bsp_sensor_interface_slot_to_work_thread+0x14>
            if( sensor_work[vitals_idx].slots_to_watch[slots_idx] == slot )
   13eb8:	ebc0 1200 	rsb	r2, r0, r0, lsl #4
   13ebc:	4c07      	ldr	r4, [pc, #28]	; (13edc <bsp_sensor_interface_slot_to_work_thread+0x54>)
   13ebe:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   13ec2:	441a      	add	r2, r3
   13ec4:	f892 2035 	ldrb.w	r2, [r2, #53]	; 0x35
   13ec8:	4562      	cmp	r2, ip
   13eca:	d0e3      	beq.n	13e94 <bsp_sensor_interface_slot_to_work_thread+0xc>
        for (uint8_t slots_idx = 0; slots_idx < sensor_work[vitals_idx].slots_used; slots_idx++)
   13ecc:	3301      	adds	r3, #1
   13ece:	b2db      	uxtb	r3, r3
   13ed0:	e7e9      	b.n	13ea6 <bsp_sensor_interface_slot_to_work_thread+0x1e>
    uint8_t ret_val = 0xFF;
   13ed2:	20ff      	movs	r0, #255	; 0xff
   13ed4:	e7df      	b.n	13e96 <bsp_sensor_interface_slot_to_work_thread+0xe>
   13ed6:	20ff      	movs	r0, #255	; 0xff
}
   13ed8:	4770      	bx	lr
   13eda:	bf00      	nop
   13edc:	20000780 	.word	0x20000780

00013ee0 <bsp_sensor_interface_thread>:
{
   13ee0:	b580      	push	{r7, lr}
   13ee2:	b086      	sub	sp, #24
    uint8_t slot_max = bsp_adc_get_number_of_channels();
   13ee4:	f017 fea2 	bl	2bc2c <bsp_adc_get_number_of_channels>
   13ee8:	4605      	mov	r5, r0
        for (uint8_t slot = 0; slot < slot_max ; slot++ )
   13eea:	2400      	movs	r4, #0
   13eec:	42ac      	cmp	r4, r5
   13eee:	d2fc      	bcs.n	13eea <bsp_sensor_interface_thread+0xa>
            err = bsp_adc_get_channel_reading( slot , &sample, &status_flags, K_FOREVER);
   13ef0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   13ef4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13ef8:	e9cd 2300 	strd	r2, r3, [sp]
   13efc:	aa04      	add	r2, sp, #16
   13efe:	a905      	add	r1, sp, #20
   13f00:	4620      	mov	r0, r4
   13f02:	f7ff fddb 	bl	13abc <bsp_adc_get_channel_reading>
            if( ZEPHYR_ERR_SUCCESS == err )
   13f06:	b910      	cbnz	r0, 13f0e <bsp_sensor_interface_thread+0x2e>
                if( status_flags.over_voltage == false )
   13f08:	f89d 3011 	ldrb.w	r3, [sp, #17]
   13f0c:	b113      	cbz	r3, 13f14 <bsp_sensor_interface_thread+0x34>
        for (uint8_t slot = 0; slot < slot_max ; slot++ )
   13f0e:	3401      	adds	r4, #1
   13f10:	b2e4      	uxtb	r4, r4
   13f12:	e7eb      	b.n	13eec <bsp_sensor_interface_thread+0xc>
                    work_slot = bsp_sensor_interface_slot_to_work_thread( slot , &placed_slot );
   13f14:	f10d 010f 	add.w	r1, sp, #15
   13f18:	4620      	mov	r0, r4
   13f1a:	f7ff ffb5 	bl	13e88 <bsp_sensor_interface_slot_to_work_thread>
   13f1e:	4606      	mov	r6, r0
                    if( sensor_work[work_slot].skipped_readings == sensor_work[work_slot].readings_to_skip  )
   13f20:	ebc0 1200 	rsb	r2, r0, r0, lsl #4
   13f24:	4b33      	ldr	r3, [pc, #204]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13f26:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   13f2a:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
   13f2e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
   13f32:	429a      	cmp	r2, r3
   13f34:	d008      	beq.n	13f48 <bsp_sensor_interface_thread+0x68>
                        sensor_work[work_slot].skipped_readings = sensor_work[work_slot].skipped_readings + 1;
   13f36:	3201      	adds	r2, #1
   13f38:	ebc0 1600 	rsb	r6, r0, r0, lsl #4
   13f3c:	4b2d      	ldr	r3, [pc, #180]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13f3e:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   13f42:	f886 2039 	strb.w	r2, [r6, #57]	; 0x39
   13f46:	e7e2      	b.n	13f0e <bsp_sensor_interface_thread+0x2e>
                        sensor_work[work_slot].skipped_readings = 0;
   13f48:	ebc0 1300 	rsb	r3, r0, r0, lsl #4
   13f4c:	4a29      	ldr	r2, [pc, #164]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13f4e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   13f52:	2200      	movs	r2, #0
   13f54:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
                        if( sensor_work[work_slot].amount_filled[placed_slot] < sensor_work[work_slot].readings_to_buffer )
   13f58:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   13f5a:	f89d 000f 	ldrb.w	r0, [sp, #15]
   13f5e:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
   13f62:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
   13f64:	4299      	cmp	r1, r3
   13f66:	d212      	bcs.n	13f8e <bsp_sensor_interface_thread+0xae>
                            sensor_work[work_slot].in_data[placed_slot][ sensor_work[work_slot].amount_filled[placed_slot] ] = sample;
   13f68:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
   13f6c:	4a21      	ldr	r2, [pc, #132]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13f6e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   13f72:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   13f74:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
   13f78:	9805      	ldr	r0, [sp, #20]
   13f7a:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
                            sensor_work[work_slot].amount_filled[placed_slot]++;
   13f7e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   13f80:	f89d 100f 	ldrb.w	r1, [sp, #15]
   13f84:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   13f88:	3301      	adds	r3, #1
   13f8a:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
                        if( sensor_work[work_slot].readings_to_buffer == sensor_work[work_slot].amount_filled[placed_slot] )
   13f8e:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
   13f92:	4a18      	ldr	r2, [pc, #96]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13f94:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   13f98:	f8b3 c028 	ldrh.w	ip, [r3, #40]	; 0x28
   13f9c:	6b1f      	ldr	r7, [r3, #48]	; 0x30
   13f9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   13fa2:	f837 3013 	ldrh.w	r3, [r7, r3, lsl #1]
   13fa6:	459c      	cmp	ip, r3
   13fa8:	d1b1      	bne.n	13f0e <bsp_sensor_interface_thread+0x2e>
                            for (uint8_t idx = 0; (idx < sensor_work[work_slot].slots_used) && (all_set == true); idx++) {
   13faa:	2300      	movs	r3, #0
                            bool all_set = true;
   13fac:	2001      	movs	r0, #1
   13fae:	e007      	b.n	13fc0 <bsp_sensor_interface_thread+0xe0>
                                all_set = (sensor_work[work_slot].readings_to_buffer ==
   13fb0:	f837 0013 	ldrh.w	r0, [r7, r3, lsl #1]
   13fb4:	4584      	cmp	ip, r0
   13fb6:	bf14      	ite	ne
   13fb8:	2000      	movne	r0, #0
   13fba:	2001      	moveq	r0, #1
                            for (uint8_t idx = 0; (idx < sensor_work[work_slot].slots_used) && (all_set == true); idx++) {
   13fbc:	3301      	adds	r3, #1
   13fbe:	b2db      	uxtb	r3, r3
   13fc0:	ebc6 1206 	rsb	r2, r6, r6, lsl #4
   13fc4:	490b      	ldr	r1, [pc, #44]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13fc6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   13fca:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
   13fce:	429a      	cmp	r2, r3
   13fd0:	d901      	bls.n	13fd6 <bsp_sensor_interface_thread+0xf6>
   13fd2:	2800      	cmp	r0, #0
   13fd4:	d1ec      	bne.n	13fb0 <bsp_sensor_interface_thread+0xd0>
                            if (true == all_set)
   13fd6:	2800      	cmp	r0, #0
   13fd8:	d099      	beq.n	13f0e <bsp_sensor_interface_thread+0x2e>

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
   13fda:	0052      	lsls	r2, r2, #1
   13fdc:	2100      	movs	r1, #0
   13fde:	4638      	mov	r0, r7
   13fe0:	f01c ff62 	bl	30ea8 <memset>
                                k_work_submit(&sensor_work[work_slot].work);
   13fe4:	4b03      	ldr	r3, [pc, #12]	; (13ff4 <bsp_sensor_interface_thread+0x114>)
   13fe6:	203c      	movs	r0, #60	; 0x3c
   13fe8:	fb00 3006 	mla	r0, r0, r6, r3
   13fec:	f013 fb36 	bl	2765c <k_work_submit>
   13ff0:	e78d      	b.n	13f0e <bsp_sensor_interface_thread+0x2e>
   13ff2:	bf00      	nop
   13ff4:	20000780 	.word	0x20000780

00013ff8 <z_impl_gpio_pin_configure>:
{
   13ff8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13ffc:	4605      	mov	r5, r0
   13ffe:	460e      	mov	r6, r1
   14000:	4614      	mov	r4, r2
	const struct gpio_driver_api *api =
   14002:	f8d0 a008 	ldr.w	sl, [r0, #8]
	__unused const struct gpio_driver_config *const cfg =
   14006:	f8d0 b004 	ldr.w	fp, [r0, #4]
	struct gpio_driver_data *data =
   1400a:	f8d0 8010 	ldr.w	r8, [r0, #16]
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   1400e:	f012 6ffc 	tst.w	r2, #132120576	; 0x7e00000
   14012:	d135      	bne.n	14080 <z_impl_gpio_pin_configure+0x88>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   14014:	f004 0330 	and.w	r3, r4, #48	; 0x30
   14018:	2b30      	cmp	r3, #48	; 0x30
   1401a:	d03e      	beq.n	1409a <z_impl_gpio_pin_configure+0xa2>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   1401c:	f004 1302 	and.w	r3, r4, #131074	; 0x20002
   14020:	2b02      	cmp	r3, #2
   14022:	d047      	beq.n	140b4 <z_impl_gpio_pin_configure+0xbc>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   14024:	f004 0306 	and.w	r3, r4, #6
   14028:	2b04      	cmp	r3, #4
   1402a:	d050      	beq.n	140ce <z_impl_gpio_pin_configure+0xd6>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   1402c:	f414 2740 	ands.w	r7, r4, #786432	; 0xc0000
   14030:	d002      	beq.n	14038 <z_impl_gpio_pin_configure+0x40>
   14032:	f414 3f00 	tst.w	r4, #131072	; 0x20000
   14036:	d057      	beq.n	140e8 <z_impl_gpio_pin_configure+0xf0>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   14038:	f5b7 2f40 	cmp.w	r7, #786432	; 0xc0000
   1403c:	d062      	beq.n	14104 <z_impl_gpio_pin_configure+0x10c>
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   1403e:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
   14042:	d005      	beq.n	14050 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   14044:	b127      	cbz	r7, 14050 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   14046:	f014 0f01 	tst.w	r4, #1
   1404a:	d001      	beq.n	14050 <z_impl_gpio_pin_configure+0x58>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   1404c:	f484 2440 	eor.w	r4, r4, #786432	; 0xc0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   14050:	f424 1980 	bic.w	r9, r4, #1048576	; 0x100000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14054:	f8db 3000 	ldr.w	r3, [fp]
   14058:	2701      	movs	r7, #1
   1405a:	40b7      	lsls	r7, r6
   1405c:	423b      	tst	r3, r7
   1405e:	d05f      	beq.n	14120 <z_impl_gpio_pin_configure+0x128>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   14060:	f014 0f01 	tst.w	r4, #1
   14064:	d06a      	beq.n	1413c <z_impl_gpio_pin_configure+0x144>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   14066:	f8d8 3000 	ldr.w	r3, [r8]
   1406a:	433b      	orrs	r3, r7
   1406c:	f8c8 3000 	str.w	r3, [r8]
	return api->pin_configure(port, pin, flags);
   14070:	f8da 3000 	ldr.w	r3, [sl]
   14074:	464a      	mov	r2, r9
   14076:	4631      	mov	r1, r6
   14078:	4628      	mov	r0, r5
   1407a:	4798      	blx	r3
}
   1407c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   14080:	4f32      	ldr	r7, [pc, #200]	; (1414c <z_impl_gpio_pin_configure+0x154>)
   14082:	f44f 722f 	mov.w	r2, #700	; 0x2bc
   14086:	4639      	mov	r1, r7
   14088:	4831      	ldr	r0, [pc, #196]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   1408a:	f018 fa50 	bl	2c52e <assert_print>
   1408e:	f44f 712f 	mov.w	r1, #700	; 0x2bc
   14092:	4638      	mov	r0, r7
   14094:	f018 fa44 	bl	2c520 <assert_post_action>
   14098:	e7bc      	b.n	14014 <z_impl_gpio_pin_configure+0x1c>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   1409a:	4f2c      	ldr	r7, [pc, #176]	; (1414c <z_impl_gpio_pin_configure+0x154>)
   1409c:	f240 22bf 	movw	r2, #703	; 0x2bf
   140a0:	4639      	mov	r1, r7
   140a2:	482b      	ldr	r0, [pc, #172]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   140a4:	f018 fa43 	bl	2c52e <assert_print>
   140a8:	f240 21bf 	movw	r1, #703	; 0x2bf
   140ac:	4638      	mov	r0, r7
   140ae:	f018 fa37 	bl	2c520 <assert_post_action>
   140b2:	e7b3      	b.n	1401c <z_impl_gpio_pin_configure+0x24>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   140b4:	4f25      	ldr	r7, [pc, #148]	; (1414c <z_impl_gpio_pin_configure+0x154>)
   140b6:	f240 22c3 	movw	r2, #707	; 0x2c3
   140ba:	4639      	mov	r1, r7
   140bc:	4824      	ldr	r0, [pc, #144]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   140be:	f018 fa36 	bl	2c52e <assert_print>
   140c2:	f240 21c3 	movw	r1, #707	; 0x2c3
   140c6:	4638      	mov	r0, r7
   140c8:	f018 fa2a 	bl	2c520 <assert_post_action>
   140cc:	e7aa      	b.n	14024 <z_impl_gpio_pin_configure+0x2c>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   140ce:	4f1f      	ldr	r7, [pc, #124]	; (1414c <z_impl_gpio_pin_configure+0x154>)
   140d0:	f240 22c7 	movw	r2, #711	; 0x2c7
   140d4:	4639      	mov	r1, r7
   140d6:	481e      	ldr	r0, [pc, #120]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   140d8:	f018 fa29 	bl	2c52e <assert_print>
   140dc:	f240 21c7 	movw	r1, #711	; 0x2c7
   140e0:	4638      	mov	r0, r7
   140e2:	f018 fa1d 	bl	2c520 <assert_post_action>
   140e6:	e7a1      	b.n	1402c <z_impl_gpio_pin_configure+0x34>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   140e8:	f8df 9060 	ldr.w	r9, [pc, #96]	; 1414c <z_impl_gpio_pin_configure+0x154>
   140ec:	f240 22ca 	movw	r2, #714	; 0x2ca
   140f0:	4649      	mov	r1, r9
   140f2:	4817      	ldr	r0, [pc, #92]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   140f4:	f018 fa1b 	bl	2c52e <assert_print>
   140f8:	f240 21ca 	movw	r1, #714	; 0x2ca
   140fc:	4648      	mov	r0, r9
   140fe:	f018 fa0f 	bl	2c520 <assert_post_action>
   14102:	e799      	b.n	14038 <z_impl_gpio_pin_configure+0x40>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   14104:	f8df 9044 	ldr.w	r9, [pc, #68]	; 1414c <z_impl_gpio_pin_configure+0x154>
   14108:	f240 22ce 	movw	r2, #718	; 0x2ce
   1410c:	4649      	mov	r1, r9
   1410e:	4810      	ldr	r0, [pc, #64]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   14110:	f018 fa0d 	bl	2c52e <assert_print>
   14114:	f240 21ce 	movw	r1, #718	; 0x2ce
   14118:	4648      	mov	r0, r9
   1411a:	f018 fa01 	bl	2c520 <assert_post_action>
   1411e:	e78e      	b.n	1403e <z_impl_gpio_pin_configure+0x46>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14120:	f8df b028 	ldr.w	fp, [pc, #40]	; 1414c <z_impl_gpio_pin_configure+0x154>
   14124:	f240 22da 	movw	r2, #730	; 0x2da
   14128:	4659      	mov	r1, fp
   1412a:	4809      	ldr	r0, [pc, #36]	; (14150 <z_impl_gpio_pin_configure+0x158>)
   1412c:	f018 f9ff 	bl	2c52e <assert_print>
   14130:	f240 21da 	movw	r1, #730	; 0x2da
   14134:	4658      	mov	r0, fp
   14136:	f018 f9f3 	bl	2c520 <assert_post_action>
   1413a:	e791      	b.n	14060 <z_impl_gpio_pin_configure+0x68>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   1413c:	f8d8 3000 	ldr.w	r3, [r8]
   14140:	ea23 0307 	bic.w	r3, r3, r7
   14144:	f8c8 3000 	str.w	r3, [r8]
   14148:	e792      	b.n	14070 <z_impl_gpio_pin_configure+0x78>
   1414a:	bf00      	nop
   1414c:	000315cc 	.word	0x000315cc
   14150:	00031600 	.word	0x00031600

00014154 <bsp_sensor_interface_init_ppg_gpios>:
{

}

static zephyr_err_t bsp_sensor_interface_init_ppg_gpios(void)
{
   14154:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    zephyr_err_t err = -EIO;

    for ( uint8_t idx = 0; (idx < (uint8_t) BSP_SENSOR_INTERFACE_PPG_LED_MAX) ; idx++ )
   14158:	2400      	movs	r4, #0
    zephyr_err_t err = -EIO;
   1415a:	f06f 0604 	mvn.w	r6, #4
    for ( uint8_t idx = 0; (idx < (uint8_t) BSP_SENSOR_INTERFACE_PPG_LED_MAX) ; idx++ )
   1415e:	e011      	b.n	14184 <bsp_sensor_interface_init_ppg_gpios+0x30>
	callback->handler = handler;
   14160:	4b22      	ldr	r3, [pc, #136]	; (141ec <bsp_sensor_interface_init_ppg_gpios+0x98>)
   14162:	f8c8 3004 	str.w	r3, [r8, #4]
	callback->pin_mask = pin_mask;
   14166:	f8c8 7008 	str.w	r7, [r8, #8]
        if( ZEPHYR_ERR_SUCCESS == err )
        {
            /*Init start convert GPIO and callback*/
            gpio_init_callback(&ppg_led_gpios[idx].gpio_callback, bsp_sensor_interface_ppg_cb,
                               BIT(ppg_led_gpios[idx].gpio_spec.pin));
            gpio_add_callback(ppg_led_gpios[idx].gpio_spec.port, &ppg_led_gpios[idx].gpio_callback);
   1416a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   1416e:	4b20      	ldr	r3, [pc, #128]	; (141f0 <bsp_sensor_interface_init_ppg_gpios+0x9c>)
   14170:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
	const struct gpio_driver_api *api =
   14174:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   14176:	69db      	ldr	r3, [r3, #28]
   14178:	b113      	cbz	r3, 14180 <bsp_sensor_interface_init_ppg_gpios+0x2c>
	return api->manage_callback(port, callback, true);
   1417a:	2201      	movs	r2, #1
   1417c:	4641      	mov	r1, r8
   1417e:	4798      	blx	r3
    for ( uint8_t idx = 0; (idx < (uint8_t) BSP_SENSOR_INTERFACE_PPG_LED_MAX) ; idx++ )
   14180:	3401      	adds	r4, #1
   14182:	b2e4      	uxtb	r4, r4
   14184:	2c03      	cmp	r4, #3
   14186:	d82d      	bhi.n	141e4 <bsp_sensor_interface_init_ppg_gpios+0x90>
        err = gpio_pin_configure_dt(&ppg_led_gpios[idx].gpio_spec, GPIO_OUTPUT);
   14188:	4625      	mov	r5, r4
   1418a:	4a19      	ldr	r2, [pc, #100]	; (141f0 <bsp_sensor_interface_init_ppg_gpios+0x9c>)
   1418c:	eb04 0184 	add.w	r1, r4, r4, lsl #2
   14190:	eb02 0381 	add.w	r3, r2, r1, lsl #2
	return gpio_pin_configure(spec->port,
   14194:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   14198:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   1419a:	88da      	ldrh	r2, [r3, #6]
	return gpio_pin_configure(spec->port,
   1419c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   141a0:	f7ff ff2a 	bl	13ff8 <z_impl_gpio_pin_configure>
        if( ZEPHYR_ERR_SUCCESS == err )
   141a4:	4606      	mov	r6, r0
   141a6:	2800      	cmp	r0, #0
   141a8:	d1ea      	bne.n	14180 <bsp_sensor_interface_init_ppg_gpios+0x2c>
            gpio_init_callback(&ppg_led_gpios[idx].gpio_callback, bsp_sensor_interface_ppg_cb,
   141aa:	4911      	ldr	r1, [pc, #68]	; (141f0 <bsp_sensor_interface_init_ppg_gpios+0x9c>)
   141ac:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   141b0:	009b      	lsls	r3, r3, #2
   141b2:	3308      	adds	r3, #8
                               BIT(ppg_led_gpios[idx].gpio_spec.pin));
   141b4:	eb04 0284 	add.w	r2, r4, r4, lsl #2
   141b8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   141bc:	7912      	ldrb	r2, [r2, #4]
   141be:	2701      	movs	r7, #1
   141c0:	4097      	lsls	r7, r2
	__ASSERT(callback, "Callback pointer should not be NULL");
   141c2:	eb11 0803 	adds.w	r8, r1, r3
   141c6:	d1cb      	bne.n	14160 <bsp_sensor_interface_init_ppg_gpios+0xc>
   141c8:	f8df 902c 	ldr.w	r9, [pc, #44]	; 141f8 <bsp_sensor_interface_init_ppg_gpios+0xa4>
   141cc:	f240 526d 	movw	r2, #1389	; 0x56d
   141d0:	4649      	mov	r1, r9
   141d2:	4808      	ldr	r0, [pc, #32]	; (141f4 <bsp_sensor_interface_init_ppg_gpios+0xa0>)
   141d4:	f018 f9ab 	bl	2c52e <assert_print>
   141d8:	f240 516d 	movw	r1, #1389	; 0x56d
   141dc:	4648      	mov	r0, r9
   141de:	f018 f99f 	bl	2c520 <assert_post_action>
   141e2:	e7bd      	b.n	14160 <bsp_sensor_interface_init_ppg_gpios+0xc>
        }
    }

    return err;
}
   141e4:	4630      	mov	r0, r6
   141e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   141ea:	bf00      	nop
   141ec:	0002bc39 	.word	0x0002bc39
   141f0:	20000730 	.word	0x20000730
   141f4:	00031600 	.word	0x00031600
   141f8:	000315cc 	.word	0x000315cc

000141fc <bsp_sensor_interface_gpio_init>:
{
   141fc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return gpio_pin_configure(spec->port,
   14200:	4b61      	ldr	r3, [pc, #388]	; (14388 <bsp_sensor_interface_gpio_init+0x18c>)
   14202:	6818      	ldr	r0, [r3, #0]
   14204:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   14206:	88da      	ldrh	r2, [r3, #6]
	return gpio_pin_configure(spec->port,
   14208:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   1420c:	f7ff fef4 	bl	13ff8 <z_impl_gpio_pin_configure>
    if( ZEPHYR_ERR_SUCCESS == err )
   14210:	4604      	mov	r4, r0
   14212:	b110      	cbz	r0, 1421a <bsp_sensor_interface_gpio_init+0x1e>
}
   14214:	4620      	mov	r0, r4
   14216:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                           BIT(gpio_afe_enable.gpio_spec.pin));
   1421a:	4b5b      	ldr	r3, [pc, #364]	; (14388 <bsp_sensor_interface_gpio_init+0x18c>)
   1421c:	7919      	ldrb	r1, [r3, #4]
   1421e:	2201      	movs	r2, #1
   14220:	408a      	lsls	r2, r1
	callback->handler = handler;
   14222:	495a      	ldr	r1, [pc, #360]	; (1438c <bsp_sensor_interface_gpio_init+0x190>)
   14224:	60d9      	str	r1, [r3, #12]
	callback->pin_mask = pin_mask;
   14226:	611a      	str	r2, [r3, #16]
        gpio_add_callback(gpio_afe_enable.gpio_spec.port, &gpio_afe_enable.gpio_callback);
   14228:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_api *api =
   1422a:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   1422c:	69db      	ldr	r3, [r3, #28]
   1422e:	b113      	cbz	r3, 14236 <bsp_sensor_interface_gpio_init+0x3a>
	return api->manage_callback(port, callback, true);
   14230:	2201      	movs	r2, #1
   14232:	4957      	ldr	r1, [pc, #348]	; (14390 <bsp_sensor_interface_gpio_init+0x194>)
   14234:	4798      	blx	r3
	return gpio_pin_configure(spec->port,
   14236:	4b57      	ldr	r3, [pc, #348]	; (14394 <bsp_sensor_interface_gpio_init+0x198>)
   14238:	6818      	ldr	r0, [r3, #0]
   1423a:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   1423c:	88da      	ldrh	r2, [r3, #6]
	return gpio_pin_configure(spec->port,
   1423e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   14242:	f7ff fed9 	bl	13ff8 <z_impl_gpio_pin_configure>
        if( ZEPHYR_ERR_SUCCESS == err )
   14246:	4680      	mov	r8, r0
   14248:	b1f8      	cbz	r0, 1428a <bsp_sensor_interface_gpio_init+0x8e>
	return gpio_pin_set(spec->port, spec->pin, value);
   1424a:	4b4f      	ldr	r3, [pc, #316]	; (14388 <bsp_sensor_interface_gpio_init+0x18c>)
   1424c:	681d      	ldr	r5, [r3, #0]
   1424e:	f893 9004 	ldrb.w	r9, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   14252:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   14254:	692e      	ldr	r6, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14256:	681b      	ldr	r3, [r3, #0]
   14258:	2701      	movs	r7, #1
   1425a:	fa07 f709 	lsl.w	r7, r7, r9
   1425e:	423b      	tst	r3, r7
   14260:	d071      	beq.n	14346 <bsp_sensor_interface_gpio_init+0x14a>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   14262:	6833      	ldr	r3, [r6, #0]
   14264:	421f      	tst	r7, r3
   14266:	d100      	bne.n	1426a <bsp_sensor_interface_gpio_init+0x6e>
   14268:	2401      	movs	r4, #1
	__unused const struct gpio_driver_config *const cfg =
   1426a:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1426c:	681b      	ldr	r3, [r3, #0]
   1426e:	2601      	movs	r6, #1
   14270:	fa06 f609 	lsl.w	r6, r6, r9
   14274:	4233      	tst	r3, r6
   14276:	d074      	beq.n	14362 <bsp_sensor_interface_gpio_init+0x166>
	if (value != 0)	{
   14278:	2c00      	cmp	r4, #0
   1427a:	d07f      	beq.n	1437c <bsp_sensor_interface_gpio_init+0x180>
	const struct gpio_driver_api *api =
   1427c:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   1427e:	68db      	ldr	r3, [r3, #12]
   14280:	4631      	mov	r1, r6
   14282:	4628      	mov	r0, r5
   14284:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
   14286:	4644      	mov	r4, r8
    return err;
   14288:	e7c4      	b.n	14214 <bsp_sensor_interface_gpio_init+0x18>
                               BIT(gpio_output_enable.gpio_spec.pin));
   1428a:	4b42      	ldr	r3, [pc, #264]	; (14394 <bsp_sensor_interface_gpio_init+0x198>)
   1428c:	7919      	ldrb	r1, [r3, #4]
   1428e:	2201      	movs	r2, #1
   14290:	408a      	lsls	r2, r1
	callback->handler = handler;
   14292:	4941      	ldr	r1, [pc, #260]	; (14398 <bsp_sensor_interface_gpio_init+0x19c>)
   14294:	60d9      	str	r1, [r3, #12]
	callback->pin_mask = pin_mask;
   14296:	611a      	str	r2, [r3, #16]
            err = gpio_add_callback(gpio_output_enable.gpio_spec.port, &gpio_output_enable.gpio_callback);
   14298:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_api *api =
   1429a:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   1429c:	69db      	ldr	r3, [r3, #28]
   1429e:	b34b      	cbz	r3, 142f4 <bsp_sensor_interface_gpio_init+0xf8>
	return api->manage_callback(port, callback, true);
   142a0:	2201      	movs	r2, #1
   142a2:	493e      	ldr	r1, [pc, #248]	; (1439c <bsp_sensor_interface_gpio_init+0x1a0>)
   142a4:	4798      	blx	r3
   142a6:	4607      	mov	r7, r0
	return gpio_pin_set(spec->port, spec->pin, value);
   142a8:	4b3a      	ldr	r3, [pc, #232]	; (14394 <bsp_sensor_interface_gpio_init+0x198>)
   142aa:	681d      	ldr	r5, [r3, #0]
   142ac:	f893 a004 	ldrb.w	sl, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   142b0:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   142b2:	692e      	ldr	r6, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   142b4:	681b      	ldr	r3, [r3, #0]
   142b6:	f04f 0901 	mov.w	r9, #1
   142ba:	fa09 f90a 	lsl.w	r9, r9, sl
   142be:	ea13 0f09 	tst.w	r3, r9
   142c2:	d01a      	beq.n	142fa <bsp_sensor_interface_gpio_init+0xfe>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   142c4:	6833      	ldr	r3, [r6, #0]
   142c6:	ea19 0f03 	tst.w	r9, r3
   142ca:	d101      	bne.n	142d0 <bsp_sensor_interface_gpio_init+0xd4>
   142cc:	f04f 0801 	mov.w	r8, #1
	__unused const struct gpio_driver_config *const cfg =
   142d0:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   142d2:	681b      	ldr	r3, [r3, #0]
   142d4:	2601      	movs	r6, #1
   142d6:	fa06 f60a 	lsl.w	r6, r6, sl
   142da:	4233      	tst	r3, r6
   142dc:	d01b      	beq.n	14316 <bsp_sensor_interface_gpio_init+0x11a>
	if (value != 0)	{
   142de:	f1b8 0f00 	cmp.w	r8, #0
   142e2:	d026      	beq.n	14332 <bsp_sensor_interface_gpio_init+0x136>
	const struct gpio_driver_api *api =
   142e4:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   142e6:	68db      	ldr	r3, [r3, #12]
   142e8:	4631      	mov	r1, r6
   142ea:	4628      	mov	r0, r5
   142ec:	4798      	blx	r3
            if( ZEPHYR_ERR_SUCCESS == err )
   142ee:	b337      	cbz	r7, 1433e <bsp_sensor_interface_gpio_init+0x142>
            err = gpio_add_callback(gpio_output_enable.gpio_spec.port, &gpio_output_enable.gpio_callback);
   142f0:	46b8      	mov	r8, r7
   142f2:	e7aa      	b.n	1424a <bsp_sensor_interface_gpio_init+0x4e>
		return -ENOTSUP;
   142f4:	f06f 0785 	mvn.w	r7, #133	; 0x85
   142f8:	e7d6      	b.n	142a8 <bsp_sensor_interface_gpio_init+0xac>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   142fa:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 143a4 <bsp_sensor_interface_gpio_init+0x1a8>
   142fe:	f240 5225 	movw	r2, #1317	; 0x525
   14302:	4659      	mov	r1, fp
   14304:	4826      	ldr	r0, [pc, #152]	; (143a0 <bsp_sensor_interface_gpio_init+0x1a4>)
   14306:	f018 f912 	bl	2c52e <assert_print>
   1430a:	f240 5125 	movw	r1, #1317	; 0x525
   1430e:	4658      	mov	r0, fp
   14310:	f018 f906 	bl	2c520 <assert_post_action>
   14314:	e7d6      	b.n	142c4 <bsp_sensor_interface_gpio_init+0xc8>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14316:	f8df 908c 	ldr.w	r9, [pc, #140]	; 143a4 <bsp_sensor_interface_gpio_init+0x1a8>
   1431a:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1431e:	4649      	mov	r1, r9
   14320:	481f      	ldr	r0, [pc, #124]	; (143a0 <bsp_sensor_interface_gpio_init+0x1a4>)
   14322:	f018 f904 	bl	2c52e <assert_print>
   14326:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1432a:	4648      	mov	r0, r9
   1432c:	f018 f8f8 	bl	2c520 <assert_post_action>
   14330:	e7d5      	b.n	142de <bsp_sensor_interface_gpio_init+0xe2>
	const struct gpio_driver_api *api =
   14332:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   14334:	691b      	ldr	r3, [r3, #16]
   14336:	4631      	mov	r1, r6
   14338:	4628      	mov	r0, r5
   1433a:	4798      	blx	r3
   1433c:	e7d7      	b.n	142ee <bsp_sensor_interface_gpio_init+0xf2>
                err = bsp_sensor_interface_init_ppg_gpios();
   1433e:	f7ff ff09 	bl	14154 <bsp_sensor_interface_init_ppg_gpios>
   14342:	4680      	mov	r8, r0
   14344:	e781      	b.n	1424a <bsp_sensor_interface_gpio_init+0x4e>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14346:	f8df a05c 	ldr.w	sl, [pc, #92]	; 143a4 <bsp_sensor_interface_gpio_init+0x1a8>
   1434a:	f240 5225 	movw	r2, #1317	; 0x525
   1434e:	4651      	mov	r1, sl
   14350:	4813      	ldr	r0, [pc, #76]	; (143a0 <bsp_sensor_interface_gpio_init+0x1a4>)
   14352:	f018 f8ec 	bl	2c52e <assert_print>
   14356:	f240 5125 	movw	r1, #1317	; 0x525
   1435a:	4650      	mov	r0, sl
   1435c:	f018 f8e0 	bl	2c520 <assert_post_action>
   14360:	e77f      	b.n	14262 <bsp_sensor_interface_gpio_init+0x66>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14362:	4f10      	ldr	r7, [pc, #64]	; (143a4 <bsp_sensor_interface_gpio_init+0x1a8>)
   14364:	f240 42fc 	movw	r2, #1276	; 0x4fc
   14368:	4639      	mov	r1, r7
   1436a:	480d      	ldr	r0, [pc, #52]	; (143a0 <bsp_sensor_interface_gpio_init+0x1a4>)
   1436c:	f018 f8df 	bl	2c52e <assert_print>
   14370:	f240 41fc 	movw	r1, #1276	; 0x4fc
   14374:	4638      	mov	r0, r7
   14376:	f018 f8d3 	bl	2c520 <assert_post_action>
   1437a:	e77d      	b.n	14278 <bsp_sensor_interface_gpio_init+0x7c>
	const struct gpio_driver_api *api =
   1437c:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   1437e:	691b      	ldr	r3, [r3, #16]
   14380:	4631      	mov	r1, r6
   14382:	4628      	mov	r0, r5
   14384:	4798      	blx	r3
   14386:	e77e      	b.n	14286 <bsp_sensor_interface_gpio_init+0x8a>
   14388:	20000708 	.word	0x20000708
   1438c:	0002bc35 	.word	0x0002bc35
   14390:	20000710 	.word	0x20000710
   14394:	2000071c 	.word	0x2000071c
   14398:	0002bc37 	.word	0x0002bc37
   1439c:	20000724 	.word	0x20000724
   143a0:	00031600 	.word	0x00031600
   143a4:	000315cc 	.word	0x000315cc

000143a8 <bsp_sensor_interface_init>:
{
   143a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   143ac:	b088      	sub	sp, #32
    zephyr_err_t err = bsp_sensor_interface_gpio_init();
   143ae:	f7ff ff25 	bl	141fc <bsp_sensor_interface_gpio_init>
    if( ZEPHYR_ERR_SUCCESS == err)
   143b2:	4606      	mov	r6, r0
   143b4:	b118      	cbz	r0, 143be <bsp_sensor_interface_init+0x16>
}
   143b6:	4630      	mov	r0, r6
   143b8:	b008      	add	sp, #32
   143ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        err = bsp_adc_init();
   143be:	f7ff fb2f 	bl	13a20 <bsp_adc_init>
        if( ZEPHYR_ERR_SUCCESS == err)
   143c2:	4606      	mov	r6, r0
   143c4:	2800      	cmp	r0, #0
   143c6:	d1f6      	bne.n	143b6 <bsp_sensor_interface_init+0xe>
            bsp_adc_set_period(K_MSEC(50) );
   143c8:	f240 6067 	movw	r0, #1639	; 0x667
   143cc:	2100      	movs	r1, #0
   143ce:	f7ff fbb5 	bl	13b3c <bsp_adc_set_period>
            for (uint8_t idx = 0; (idx < VITALS_VITAL_TYPE_ID_MAX) && ( ZEPHYR_ERR_SUCCESS == err) ; idx++)
   143d2:	2700      	movs	r7, #0
   143d4:	e019      	b.n	1440a <bsp_sensor_interface_init+0x62>
                    sensor_work[idx].in_data[slot_idx] = k_calloc( sensor_work[idx].readings_to_buffer , sizeof(uint32_t) );
   143d6:	ebc5 1305 	rsb	r3, r5, r5, lsl #4
   143da:	4a2f      	ldr	r2, [pc, #188]	; (14498 <bsp_sensor_interface_init+0xf0>)
   143dc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   143e0:	f8d3 802c 	ldr.w	r8, [r3, #44]	; 0x2c
   143e4:	2104      	movs	r1, #4
   143e6:	8d18      	ldrh	r0, [r3, #40]	; 0x28
   143e8:	f01c fce1 	bl	30dae <k_calloc>
   143ec:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
                for (uint8_t slot_idx = 0; slot_idx < sensor_work[idx].slots_used ; slot_idx++ )
   143f0:	3401      	adds	r4, #1
   143f2:	b2e4      	uxtb	r4, r4
   143f4:	ebc5 1305 	rsb	r3, r5, r5, lsl #4
   143f8:	4a27      	ldr	r2, [pc, #156]	; (14498 <bsp_sensor_interface_init+0xf0>)
   143fa:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   143fe:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   14402:	42a3      	cmp	r3, r4
   14404:	d8e7      	bhi.n	143d6 <bsp_sensor_interface_init+0x2e>
            for (uint8_t idx = 0; (idx < VITALS_VITAL_TYPE_ID_MAX) && ( ZEPHYR_ERR_SUCCESS == err) ; idx++)
   14406:	3701      	adds	r7, #1
   14408:	b2ff      	uxtb	r7, r7
   1440a:	2f03      	cmp	r7, #3
   1440c:	d824      	bhi.n	14458 <bsp_sensor_interface_init+0xb0>
   1440e:	bb1e      	cbnz	r6, 14458 <bsp_sensor_interface_init+0xb0>
                k_work_init( &sensor_work[idx].work , sensor_work[idx].work_handler );
   14410:	463d      	mov	r5, r7
   14412:	4e21      	ldr	r6, [pc, #132]	; (14498 <bsp_sensor_interface_init+0xf0>)
   14414:	013c      	lsls	r4, r7, #4
   14416:	ebc7 1807 	rsb	r8, r7, r7, lsl #4
   1441a:	eb06 0888 	add.w	r8, r6, r8, lsl #2
   1441e:	f8d8 1010 	ldr.w	r1, [r8, #16]
   14422:	4640      	mov	r0, r8
   14424:	f013 f8a4 	bl	27570 <k_work_init>
                err = k_mutex_init( &sensor_work[idx].lock );
   14428:	1be0      	subs	r0, r4, r7
   1442a:	0080      	lsls	r0, r0, #2
   1442c:	3010      	adds	r0, #16
   1442e:	4430      	add	r0, r6
   14430:	3004      	adds	r0, #4
	return z_impl_k_mutex_init(mutex);
   14432:	f01c fab6 	bl	309a2 <z_impl_k_mutex_init>
   14436:	4606      	mov	r6, r0
                sensor_work[idx].in_data = k_calloc( sensor_work[idx].slots_used , sizeof(uint32_t*) );
   14438:	2104      	movs	r1, #4
   1443a:	f898 0034 	ldrb.w	r0, [r8, #52]	; 0x34
   1443e:	f01c fcb6 	bl	30dae <k_calloc>
   14442:	f8c8 002c 	str.w	r0, [r8, #44]	; 0x2c
                sensor_work[idx].amount_filled = k_calloc( sensor_work[idx].slots_used , sizeof(uint16_t) );
   14446:	2102      	movs	r1, #2
   14448:	f898 0034 	ldrb.w	r0, [r8, #52]	; 0x34
   1444c:	f01c fcaf 	bl	30dae <k_calloc>
   14450:	f8c8 0030 	str.w	r0, [r8, #48]	; 0x30
                for (uint8_t slot_idx = 0; slot_idx < sensor_work[idx].slots_used ; slot_idx++ )
   14454:	2400      	movs	r4, #0
   14456:	e7cd      	b.n	143f4 <bsp_sensor_interface_init+0x4c>
            k_msgq_init(&sensor_interface_queue , (char *) queue_buffer,
   14458:	2310      	movs	r3, #16
   1445a:	2212      	movs	r2, #18
   1445c:	490f      	ldr	r1, [pc, #60]	; (1449c <bsp_sensor_interface_init+0xf4>)
   1445e:	4810      	ldr	r0, [pc, #64]	; (144a0 <bsp_sensor_interface_init+0xf8>)
   14460:	f01c fa75 	bl	3094e <k_msgq_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   14464:	2200      	movs	r2, #0
   14466:	2300      	movs	r3, #0
   14468:	e9cd 2306 	strd	r2, r3, [sp, #24]
   1446c:	2301      	movs	r3, #1
   1446e:	9304      	str	r3, [sp, #16]
   14470:	2302      	movs	r3, #2
   14472:	9303      	str	r3, [sp, #12]
   14474:	2300      	movs	r3, #0
   14476:	9302      	str	r3, [sp, #8]
   14478:	9301      	str	r3, [sp, #4]
   1447a:	9300      	str	r3, [sp, #0]
   1447c:	4b09      	ldr	r3, [pc, #36]	; (144a4 <bsp_sensor_interface_init+0xfc>)
   1447e:	f44f 7200 	mov.w	r2, #512	; 0x200
   14482:	4909      	ldr	r1, [pc, #36]	; (144a8 <bsp_sensor_interface_init+0x100>)
   14484:	4809      	ldr	r0, [pc, #36]	; (144ac <bsp_sensor_interface_init+0x104>)
   14486:	f012 f85d 	bl	26544 <z_impl_k_thread_create>
            sensor_thread_tid = k_thread_create(&sensor_thread, sensor_thread_stack, SENSOR_THREAD_STACK,
   1448a:	4b09      	ldr	r3, [pc, #36]	; (144b0 <bsp_sensor_interface_init+0x108>)
   1448c:	6018      	str	r0, [r3, #0]
	return z_impl_k_thread_name_set(thread, str);
   1448e:	4909      	ldr	r1, [pc, #36]	; (144b4 <bsp_sensor_interface_init+0x10c>)
   14490:	f01c fa42 	bl	30918 <z_impl_k_thread_name_set>
    return err;
   14494:	e78f      	b.n	143b6 <bsp_sensor_interface_init+0xe>
   14496:	bf00      	nop
   14498:	20000780 	.word	0x20000780
   1449c:	20003820 	.word	0x20003820
   144a0:	20003940 	.word	0x20003940
   144a4:	00013ee1 	.word	0x00013ee1
   144a8:	20004c00 	.word	0x20004c00
   144ac:	20001dd8 	.word	0x20001dd8
   144b0:	20003974 	.word	0x20003974
   144b4:	000316a0 	.word	0x000316a0

000144b8 <bsp_sensor_interface_receive_vital>:
{
   144b8:	b508      	push	{r3, lr}
   144ba:	4601      	mov	r1, r0
	return z_impl_k_msgq_get(msgq, data, timeout);
   144bc:	2200      	movs	r2, #0
   144be:	2300      	movs	r3, #0
   144c0:	4801      	ldr	r0, [pc, #4]	; (144c8 <bsp_sensor_interface_receive_vital+0x10>)
   144c2:	f012 f9e3 	bl	2688c <z_impl_k_msgq_get>
}
   144c6:	bd08      	pop	{r3, pc}
   144c8:	20003940 	.word	0x20003940

000144cc <bsp_sensor_interface_publish_vital>:
{
   144cc:	b510      	push	{r4, lr}
   144ce:	b086      	sub	sp, #24
    putting_data.vital= vital;
   144d0:	f88d 0004 	strb.w	r0, [sp, #4]
    putting_data.data_size = sizeof_data;
   144d4:	f88d 2015 	strb.w	r2, [sp, #21]
    memcpy( &putting_data.data_buffer[0] , data , sizeof_data );
   144d8:	2311      	movs	r3, #17
   144da:	f10d 0005 	add.w	r0, sp, #5
   144de:	f01c fcd0 	bl	30e82 <__memcpy_chk>
	return z_impl_k_msgq_put(msgq, data, timeout);
   144e2:	2200      	movs	r2, #0
   144e4:	2300      	movs	r3, #0
   144e6:	a901      	add	r1, sp, #4
   144e8:	4805      	ldr	r0, [pc, #20]	; (14500 <bsp_sensor_interface_publish_vital+0x34>)
   144ea:	f012 f935 	bl	26758 <z_impl_k_msgq_put>
    if( ZEPHYR_ERR_SUCCESS == err )
   144ee:	4604      	mov	r4, r0
   144f0:	b110      	cbz	r0, 144f8 <bsp_sensor_interface_publish_vital+0x2c>
}
   144f2:	4620      	mov	r0, r4
   144f4:	b006      	add	sp, #24
   144f6:	bd10      	pop	{r4, pc}
        bsp_submit_work();
   144f8:	f7fe fc6c 	bl	12dd4 <bsp_submit_work>
   144fc:	e7f9      	b.n	144f2 <bsp_sensor_interface_publish_vital+0x26>
   144fe:	bf00      	nop
   14500:	20003940 	.word	0x20003940

00014504 <bsp_sensor_interface_ppg_set>:
{

}

zephyr_err_t bsp_sensor_interface_ppg_set( uint8_t led ,  uint8_t on_or_off )
{
   14504:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14508:	4688      	mov	r8, r1
    return gpio_pin_set_dt( &ppg_led_gpios[led].gpio_spec , on_or_off );
   1450a:	460f      	mov	r7, r1
	return gpio_pin_set(spec->port, spec->pin, value);
   1450c:	4b23      	ldr	r3, [pc, #140]	; (1459c <bsp_sensor_interface_ppg_set+0x98>)
   1450e:	eb00 0280 	add.w	r2, r0, r0, lsl #2
   14512:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
   14516:	eb03 0082 	add.w	r0, r3, r2, lsl #2
   1451a:	f890 9004 	ldrb.w	r9, [r0, #4]
	__unused const struct gpio_driver_config *const cfg =
   1451e:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   14520:	6925      	ldr	r5, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14522:	681b      	ldr	r3, [r3, #0]
   14524:	2601      	movs	r6, #1
   14526:	fa06 f609 	lsl.w	r6, r6, r9
   1452a:	4233      	tst	r3, r6
   1452c:	d014      	beq.n	14558 <bsp_sensor_interface_ppg_set+0x54>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1452e:	682b      	ldr	r3, [r5, #0]
   14530:	421e      	tst	r6, r3
   14532:	d002      	beq.n	1453a <bsp_sensor_interface_ppg_set+0x36>
		value = (value != 0) ? 0 : 1;
   14534:	fab8 f788 	clz	r7, r8
   14538:	097f      	lsrs	r7, r7, #5
	__unused const struct gpio_driver_config *const cfg =
   1453a:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1453c:	681b      	ldr	r3, [r3, #0]
   1453e:	2501      	movs	r5, #1
   14540:	fa05 f509 	lsl.w	r5, r5, r9
   14544:	422b      	tst	r3, r5
   14546:	d015      	beq.n	14574 <bsp_sensor_interface_ppg_set+0x70>
	if (value != 0)	{
   14548:	b30f      	cbz	r7, 1458e <bsp_sensor_interface_ppg_set+0x8a>
	const struct gpio_driver_api *api =
   1454a:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   1454c:	68db      	ldr	r3, [r3, #12]
   1454e:	4629      	mov	r1, r5
   14550:	4620      	mov	r0, r4
   14552:	4798      	blx	r3
   14554:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14558:	f8df a048 	ldr.w	sl, [pc, #72]	; 145a4 <bsp_sensor_interface_ppg_set+0xa0>
   1455c:	f240 5225 	movw	r2, #1317	; 0x525
   14560:	4651      	mov	r1, sl
   14562:	480f      	ldr	r0, [pc, #60]	; (145a0 <bsp_sensor_interface_ppg_set+0x9c>)
   14564:	f017 ffe3 	bl	2c52e <assert_print>
   14568:	f240 5125 	movw	r1, #1317	; 0x525
   1456c:	4650      	mov	r0, sl
   1456e:	f017 ffd7 	bl	2c520 <assert_post_action>
   14572:	e7dc      	b.n	1452e <bsp_sensor_interface_ppg_set+0x2a>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14574:	4e0b      	ldr	r6, [pc, #44]	; (145a4 <bsp_sensor_interface_ppg_set+0xa0>)
   14576:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1457a:	4631      	mov	r1, r6
   1457c:	4808      	ldr	r0, [pc, #32]	; (145a0 <bsp_sensor_interface_ppg_set+0x9c>)
   1457e:	f017 ffd6 	bl	2c52e <assert_print>
   14582:	f240 41fc 	movw	r1, #1276	; 0x4fc
   14586:	4630      	mov	r0, r6
   14588:	f017 ffca 	bl	2c520 <assert_post_action>
   1458c:	e7dc      	b.n	14548 <bsp_sensor_interface_ppg_set+0x44>
	const struct gpio_driver_api *api =
   1458e:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   14590:	691b      	ldr	r3, [r3, #16]
   14592:	4629      	mov	r1, r5
   14594:	4620      	mov	r0, r4
   14596:	4798      	blx	r3
    return gpio_pin_set_dt( &ppg_led_gpios[led].gpio_spec , on_or_off );
   14598:	e7dc      	b.n	14554 <bsp_sensor_interface_ppg_set+0x50>
   1459a:	bf00      	nop
   1459c:	20000730 	.word	0x20000730
   145a0:	00031600 	.word	0x00031600
   145a4:	000315cc 	.word	0x000315cc

000145a8 <bsp_sensor_interface_power_on_afe>:
{
   145a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return gpio_pin_set(spec->port, spec->pin, value);
   145ac:	4b2b      	ldr	r3, [pc, #172]	; (1465c <bsp_sensor_interface_power_on_afe+0xb4>)
   145ae:	681c      	ldr	r4, [r3, #0]
   145b0:	791f      	ldrb	r7, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   145b2:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   145b4:	6925      	ldr	r5, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   145b6:	681b      	ldr	r3, [r3, #0]
   145b8:	2601      	movs	r6, #1
   145ba:	40be      	lsls	r6, r7
   145bc:	4233      	tst	r3, r6
   145be:	d014      	beq.n	145ea <bsp_sensor_interface_power_on_afe+0x42>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   145c0:	682b      	ldr	r3, [r5, #0]
   145c2:	421e      	tst	r6, r3
   145c4:	d11f      	bne.n	14606 <bsp_sensor_interface_power_on_afe+0x5e>
   145c6:	2601      	movs	r6, #1
	__unused const struct gpio_driver_config *const cfg =
   145c8:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   145ca:	681b      	ldr	r3, [r3, #0]
   145cc:	2501      	movs	r5, #1
   145ce:	40bd      	lsls	r5, r7
   145d0:	422b      	tst	r3, r5
   145d2:	d01a      	beq.n	1460a <bsp_sensor_interface_power_on_afe+0x62>
	if (value != 0)	{
   145d4:	b336      	cbz	r6, 14624 <bsp_sensor_interface_power_on_afe+0x7c>
	const struct gpio_driver_api *api =
   145d6:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   145d8:	68db      	ldr	r3, [r3, #12]
   145da:	4629      	mov	r1, r5
   145dc:	4620      	mov	r0, r4
   145de:	4798      	blx	r3
   145e0:	4604      	mov	r4, r0
    if(ZEPHYR_ERR_SUCCESS == err)
   145e2:	b334      	cbz	r4, 14632 <bsp_sensor_interface_power_on_afe+0x8a>
}
   145e4:	4620      	mov	r0, r4
   145e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   145ea:	f8df 8078 	ldr.w	r8, [pc, #120]	; 14664 <bsp_sensor_interface_power_on_afe+0xbc>
   145ee:	f240 5225 	movw	r2, #1317	; 0x525
   145f2:	4641      	mov	r1, r8
   145f4:	481a      	ldr	r0, [pc, #104]	; (14660 <bsp_sensor_interface_power_on_afe+0xb8>)
   145f6:	f017 ff9a 	bl	2c52e <assert_print>
   145fa:	f240 5125 	movw	r1, #1317	; 0x525
   145fe:	4640      	mov	r0, r8
   14600:	f017 ff8e 	bl	2c520 <assert_post_action>
   14604:	e7dc      	b.n	145c0 <bsp_sensor_interface_power_on_afe+0x18>
		value = (value != 0) ? 0 : 1;
   14606:	2600      	movs	r6, #0
   14608:	e7de      	b.n	145c8 <bsp_sensor_interface_power_on_afe+0x20>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1460a:	4f16      	ldr	r7, [pc, #88]	; (14664 <bsp_sensor_interface_power_on_afe+0xbc>)
   1460c:	f240 42fc 	movw	r2, #1276	; 0x4fc
   14610:	4639      	mov	r1, r7
   14612:	4813      	ldr	r0, [pc, #76]	; (14660 <bsp_sensor_interface_power_on_afe+0xb8>)
   14614:	f017 ff8b 	bl	2c52e <assert_print>
   14618:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1461c:	4638      	mov	r0, r7
   1461e:	f017 ff7f 	bl	2c520 <assert_post_action>
   14622:	e7d7      	b.n	145d4 <bsp_sensor_interface_power_on_afe+0x2c>
	const struct gpio_driver_api *api =
   14624:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   14626:	691b      	ldr	r3, [r3, #16]
   14628:	4629      	mov	r1, r5
   1462a:	4620      	mov	r0, r4
   1462c:	4798      	blx	r3
   1462e:	4604      	mov	r4, r0
   14630:	e7d7      	b.n	145e2 <bsp_sensor_interface_power_on_afe+0x3a>
        k_sleep(K_MSEC(40));
   14632:	f240 561f 	movw	r6, #1311	; 0x51f
   14636:	2700      	movs	r7, #0
	return z_impl_k_sleep(timeout);
   14638:	4630      	mov	r0, r6
   1463a:	4639      	mov	r1, r7
   1463c:	f014 fb8e 	bl	28d5c <z_impl_k_sleep>
        bsp_sensor_interface_ppg_set(BSP_SENSOR_INTERFACE_PPG_LED_0 , true );
   14640:	2101      	movs	r1, #1
   14642:	2000      	movs	r0, #0
   14644:	f7ff ff5e 	bl	14504 <bsp_sensor_interface_ppg_set>
        bsp_sensor_interface_ppg_set(BSP_SENSOR_INTERFACE_PPG_LED_1 , true );
   14648:	2101      	movs	r1, #1
   1464a:	4608      	mov	r0, r1
   1464c:	f7ff ff5a 	bl	14504 <bsp_sensor_interface_ppg_set>
   14650:	4630      	mov	r0, r6
   14652:	4639      	mov	r1, r7
   14654:	f014 fb82 	bl	28d5c <z_impl_k_sleep>
    return err;
   14658:	e7c4      	b.n	145e4 <bsp_sensor_interface_power_on_afe+0x3c>
   1465a:	bf00      	nop
   1465c:	20000708 	.word	0x20000708
   14660:	00031600 	.word	0x00031600
   14664:	000315cc 	.word	0x000315cc

00014668 <bsp_sensor_interface_power_off_afe>:
{
   14668:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return gpio_pin_set(spec->port, spec->pin, value);
   1466c:	4b25      	ldr	r3, [pc, #148]	; (14704 <bsp_sensor_interface_power_off_afe+0x9c>)
   1466e:	681c      	ldr	r4, [r3, #0]
   14670:	791f      	ldrb	r7, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   14672:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   14674:	6925      	ldr	r5, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14676:	681b      	ldr	r3, [r3, #0]
   14678:	2601      	movs	r6, #1
   1467a:	40be      	lsls	r6, r7
   1467c:	4233      	tst	r3, r6
   1467e:	d014      	beq.n	146aa <bsp_sensor_interface_power_off_afe+0x42>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   14680:	682b      	ldr	r3, [r5, #0]
   14682:	421e      	tst	r6, r3
   14684:	d11f      	bne.n	146c6 <bsp_sensor_interface_power_off_afe+0x5e>
   14686:	2600      	movs	r6, #0
	__unused const struct gpio_driver_config *const cfg =
   14688:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1468a:	681b      	ldr	r3, [r3, #0]
   1468c:	2501      	movs	r5, #1
   1468e:	40bd      	lsls	r5, r7
   14690:	422b      	tst	r3, r5
   14692:	d01a      	beq.n	146ca <bsp_sensor_interface_power_off_afe+0x62>
	if (value != 0)	{
   14694:	b336      	cbz	r6, 146e4 <bsp_sensor_interface_power_off_afe+0x7c>
	const struct gpio_driver_api *api =
   14696:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   14698:	68db      	ldr	r3, [r3, #12]
   1469a:	4629      	mov	r1, r5
   1469c:	4620      	mov	r0, r4
   1469e:	4798      	blx	r3
   146a0:	4604      	mov	r4, r0
    if(ZEPHYR_ERR_SUCCESS == err)
   146a2:	b334      	cbz	r4, 146f2 <bsp_sensor_interface_power_off_afe+0x8a>
}
   146a4:	4620      	mov	r0, r4
   146a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   146aa:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1470c <bsp_sensor_interface_power_off_afe+0xa4>
   146ae:	f240 5225 	movw	r2, #1317	; 0x525
   146b2:	4641      	mov	r1, r8
   146b4:	4814      	ldr	r0, [pc, #80]	; (14708 <bsp_sensor_interface_power_off_afe+0xa0>)
   146b6:	f017 ff3a 	bl	2c52e <assert_print>
   146ba:	f240 5125 	movw	r1, #1317	; 0x525
   146be:	4640      	mov	r0, r8
   146c0:	f017 ff2e 	bl	2c520 <assert_post_action>
   146c4:	e7dc      	b.n	14680 <bsp_sensor_interface_power_off_afe+0x18>
		value = (value != 0) ? 0 : 1;
   146c6:	2601      	movs	r6, #1
   146c8:	e7de      	b.n	14688 <bsp_sensor_interface_power_off_afe+0x20>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   146ca:	4f10      	ldr	r7, [pc, #64]	; (1470c <bsp_sensor_interface_power_off_afe+0xa4>)
   146cc:	f240 42fc 	movw	r2, #1276	; 0x4fc
   146d0:	4639      	mov	r1, r7
   146d2:	480d      	ldr	r0, [pc, #52]	; (14708 <bsp_sensor_interface_power_off_afe+0xa0>)
   146d4:	f017 ff2b 	bl	2c52e <assert_print>
   146d8:	f240 41fc 	movw	r1, #1276	; 0x4fc
   146dc:	4638      	mov	r0, r7
   146de:	f017 ff1f 	bl	2c520 <assert_post_action>
   146e2:	e7d7      	b.n	14694 <bsp_sensor_interface_power_off_afe+0x2c>
	const struct gpio_driver_api *api =
   146e4:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   146e6:	691b      	ldr	r3, [r3, #16]
   146e8:	4629      	mov	r1, r5
   146ea:	4620      	mov	r0, r4
   146ec:	4798      	blx	r3
   146ee:	4604      	mov	r4, r0
   146f0:	e7d7      	b.n	146a2 <bsp_sensor_interface_power_off_afe+0x3a>
        bsp_sensor_interface_ppg_set(BSP_SENSOR_INTERFACE_PPG_LED_0 , false );
   146f2:	2100      	movs	r1, #0
   146f4:	4608      	mov	r0, r1
   146f6:	f7ff ff05 	bl	14504 <bsp_sensor_interface_ppg_set>
        bsp_sensor_interface_ppg_set(BSP_SENSOR_INTERFACE_PPG_LED_1 , false );
   146fa:	2100      	movs	r1, #0
   146fc:	2001      	movs	r0, #1
   146fe:	f7ff ff01 	bl	14504 <bsp_sensor_interface_ppg_set>
    return err;
   14702:	e7cf      	b.n	146a4 <bsp_sensor_interface_power_off_afe+0x3c>
   14704:	20000708 	.word	0x20000708
   14708:	00031600 	.word	0x00031600
   1470c:	000315cc 	.word	0x000315cc

00014710 <bsp_lc709204f_write_cmd>:
}

/*Low level read/write methods*/

static zephyr_err_t bsp_lc709204f_write_cmd( bsp_lc709204f_word_t cmd )
{
   14710:	b510      	push	{r4, lr}
   14712:	b086      	sub	sp, #24
   14714:	466b      	mov	r3, sp
   14716:	e883 0003 	stmia.w	r3, {r0, r1}
    uint8_t write_amount = sizeof(uint8_t) + sizeof(uint16_t) + sizeof(uint8_t);
    uint8_t write_buffer[sizeof(uint8_t) + sizeof(uint16_t) + sizeof(uint8_t)] = {
            [BSP_LC709204F_CMD_POS] = cmd.cmd,
   1471a:	f89d 3000 	ldrb.w	r3, [sp]
    uint8_t write_buffer[sizeof(uint8_t) + sizeof(uint16_t) + sizeof(uint8_t)] = {
   1471e:	f88d 3014 	strb.w	r3, [sp, #20]
            [BSP_LC709204F_DATA_LB_POS] = (cmd.data & 0x00FF),
   14722:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    uint8_t write_buffer[sizeof(uint8_t) + sizeof(uint16_t) + sizeof(uint8_t)] = {
   14726:	f88d 3015 	strb.w	r3, [sp, #21]
            [BSP_LC709204F_DATA_UB_POS] = (cmd.data & 0xFF00) >> 0x8,
   1472a:	0a1b      	lsrs	r3, r3, #8
    uint8_t write_buffer[sizeof(uint8_t) + sizeof(uint16_t) + sizeof(uint8_t)] = {
   1472c:	f88d 3016 	strb.w	r3, [sp, #22]
            [BSP_LC709204F_CRC_POS] = cmd.crc,
   14730:	f89d 3004 	ldrb.w	r3, [sp, #4]
    uint8_t write_buffer[sizeof(uint8_t) + sizeof(uint16_t) + sizeof(uint8_t)] = {
   14734:	f88d 3017 	strb.w	r3, [sp, #23]
    };

    return i2c_write( lc709204f.i2c_device , write_buffer , write_amount , lc709204f.slave_address);
   14738:	4b08      	ldr	r3, [pc, #32]	; (1475c <bsp_lc709204f_write_cmd+0x4c>)
   1473a:	6818      	ldr	r0, [r3, #0]
   1473c:	891b      	ldrh	r3, [r3, #8]
static inline int i2c_write(const struct device *dev, const uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	struct i2c_msg msg;

	msg.buf = (uint8_t *)buf;
   1473e:	aa05      	add	r2, sp, #20
   14740:	9202      	str	r2, [sp, #8]
	msg.len = num_bytes;
   14742:	2204      	movs	r2, #4
   14744:	9203      	str	r2, [sp, #12]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   14746:	2202      	movs	r2, #2
   14748:	f88d 2010 	strb.w	r2, [sp, #16]
	const struct i2c_driver_api *api =
   1474c:	6882      	ldr	r2, [r0, #8]
	int res =  api->transfer(dev, msgs, num_msgs, addr);
   1474e:	6894      	ldr	r4, [r2, #8]
   14750:	2201      	movs	r2, #1
   14752:	a902      	add	r1, sp, #8
   14754:	47a0      	blx	r4
}
   14756:	b006      	add	sp, #24
   14758:	bd10      	pop	{r4, pc}
   1475a:	bf00      	nop
   1475c:	20000870 	.word	0x20000870

00014760 <bsp_lc709204f_read_cmd>:

static zephyr_err_t bsp_lc709204f_read_cmd( bsp_lc709204f_word_t* cmd )
{
   14760:	b510      	push	{r4, lr}
   14762:	b084      	sub	sp, #16
    uint8_t* data_ptr = (uint8_t*) &cmd->data;
   14764:	1c82      	adds	r2, r0, #2

    return i2c_read( lc709204f.i2c_device , data_ptr , sizeof(uint16_t) , lc709204f.slave_address);
   14766:	4b08      	ldr	r3, [pc, #32]	; (14788 <bsp_lc709204f_read_cmd+0x28>)
   14768:	6818      	ldr	r0, [r3, #0]
   1476a:	891b      	ldrh	r3, [r3, #8]
static inline int i2c_read(const struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
	struct i2c_msg msg;

	msg.buf = buf;
   1476c:	9201      	str	r2, [sp, #4]
	msg.len = num_bytes;
   1476e:	2202      	movs	r2, #2
   14770:	9202      	str	r2, [sp, #8]
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   14772:	2203      	movs	r2, #3
   14774:	f88d 200c 	strb.w	r2, [sp, #12]
	const struct i2c_driver_api *api =
   14778:	6882      	ldr	r2, [r0, #8]
	int res =  api->transfer(dev, msgs, num_msgs, addr);
   1477a:	6894      	ldr	r4, [r2, #8]
   1477c:	2201      	movs	r2, #1
   1477e:	a901      	add	r1, sp, #4
   14780:	47a0      	blx	r4
}
   14782:	b004      	add	sp, #16
   14784:	bd10      	pop	{r4, pc}
   14786:	bf00      	nop
   14788:	20000870 	.word	0x20000870

0001478c <bsp_lc709204f_compute_crc>:

static uint8_t bsp_lc709204f_compute_crc( bsp_lc709204f_word_t cmd )
{
   1478c:	b510      	push	{r4, lr}
   1478e:	b082      	sub	sp, #8
   14790:	ab02      	add	r3, sp, #8
   14792:	e903 0003 	stmdb	r3, {r0, r1}
    uint8_t ret_val = 0;

    ret_val = bsp_lc709204f_compute_crc_byte( ret_val , ((uint8_t) lc709204f.slave_address) << 1 );
   14796:	4b0b      	ldr	r3, [pc, #44]	; (147c4 <bsp_lc709204f_compute_crc+0x38>)
   14798:	7a19      	ldrb	r1, [r3, #8]
   1479a:	0049      	lsls	r1, r1, #1
   1479c:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
   147a0:	2000      	movs	r0, #0
   147a2:	f017 fa78 	bl	2bc96 <bsp_lc709204f_compute_crc_byte>
    ret_val = bsp_lc709204f_compute_crc_byte( ret_val , cmd.cmd );
   147a6:	f89d 1000 	ldrb.w	r1, [sp]
   147aa:	f017 fa74 	bl	2bc96 <bsp_lc709204f_compute_crc_byte>
    ret_val = bsp_lc709204f_compute_crc_byte( ret_val , 0xFF & cmd.data );
   147ae:	f8bd 4002 	ldrh.w	r4, [sp, #2]
   147b2:	b2e1      	uxtb	r1, r4
   147b4:	f017 fa6f 	bl	2bc96 <bsp_lc709204f_compute_crc_byte>
    ret_val = bsp_lc709204f_compute_crc_byte( ret_val , (0xFF00 & cmd.data) >> 0x8 );
   147b8:	0a21      	lsrs	r1, r4, #8
   147ba:	f017 fa6c 	bl	2bc96 <bsp_lc709204f_compute_crc_byte>

    return ret_val;
}
   147be:	b002      	add	sp, #8
   147c0:	bd10      	pop	{r4, pc}
   147c2:	bf00      	nop
   147c4:	20000870 	.word	0x20000870

000147c8 <bsp_battery_gauge_fetch_params>:
{
   147c8:	b530      	push	{r4, r5, lr}
   147ca:	b083      	sub	sp, #12
   147cc:	4605      	mov	r5, r0
    for (uint8_t idx = 0; (idx < BSP_BATTERY_GAUGE_NUM_PARAMS) && (ZEPHYR_ERR_SUCCESS == err); idx++)
   147ce:	2400      	movs	r4, #0
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;
   147d0:	4620      	mov	r0, r4
    for (uint8_t idx = 0; (idx < BSP_BATTERY_GAUGE_NUM_PARAMS) && (ZEPHYR_ERR_SUCCESS == err); idx++)
   147d2:	e007      	b.n	147e4 <bsp_battery_gauge_fetch_params+0x1c>
        err = bsp_lc709204f_read( commands[idx] , &rx_data[idx] );
   147d4:	eb0d 0144 	add.w	r1, sp, r4, lsl #1
   147d8:	4b17      	ldr	r3, [pc, #92]	; (14838 <bsp_battery_gauge_fetch_params+0x70>)
   147da:	5d18      	ldrb	r0, [r3, r4]
   147dc:	f017 fa6f 	bl	2bcbe <bsp_lc709204f_read>
    for (uint8_t idx = 0; (idx < BSP_BATTERY_GAUGE_NUM_PARAMS) && (ZEPHYR_ERR_SUCCESS == err); idx++)
   147e0:	3401      	adds	r4, #1
   147e2:	b2e4      	uxtb	r4, r4
   147e4:	2c03      	cmp	r4, #3
   147e6:	d801      	bhi.n	147ec <bsp_battery_gauge_fetch_params+0x24>
   147e8:	2800      	cmp	r0, #0
   147ea:	d0f3      	beq.n	147d4 <bsp_battery_gauge_fetch_params+0xc>
    if(ZEPHYR_ERR_SUCCESS == err)
   147ec:	bb08      	cbnz	r0, 14832 <bsp_battery_gauge_fetch_params+0x6a>
        params->voltage     = ( (float) rx_data[BSP_LC709204F_VOLTAGE_POS] ) / 1000.0f;
   147ee:	f8bd 3000 	ldrh.w	r3, [sp]
   147f2:	ee07 3a90 	vmov	s15, r3
   147f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   147fa:	eddf 6a10 	vldr	s13, [pc, #64]	; 1483c <bsp_battery_gauge_fetch_params+0x74>
   147fe:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   14802:	ed85 7a00 	vstr	s14, [r5]
        params->temperature = BSP_LC709204F_TEMP_CONST * ( (float) rx_data[BSP_LC709204F_TEMPERATURE_POS] - BSP_LC709204F_ZERO_DEGREES );
   14806:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   1480a:	ee07 3a90 	vmov	s15, r3
   1480e:	eef8 7a67 	vcvt.f32.u32	s15, s15
   14812:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 14840 <bsp_battery_gauge_fetch_params+0x78>
   14816:	ee77 7ac7 	vsub.f32	s15, s15, s14
   1481a:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 14844 <bsp_battery_gauge_fetch_params+0x7c>
   1481e:	ee67 7a87 	vmul.f32	s15, s15, s14
   14822:	edc5 7a01 	vstr	s15, [r5, #4]
        params->rsoc        = rx_data[BSP_LC709204F_RSOC_POS];
   14826:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   1482a:	722b      	strb	r3, [r5, #8]
        params->health      = rx_data[BSP_LC709204F_HEALTH_POS];
   1482c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   14830:	726b      	strb	r3, [r5, #9]
}
   14832:	b003      	add	sp, #12
   14834:	bd30      	pop	{r4, r5, pc}
   14836:	bf00      	nop
   14838:	000316cc 	.word	0x000316cc
   1483c:	447a0000 	.word	0x447a0000
   14840:	452ac000 	.word	0x452ac000
   14844:	3dcccccd 	.word	0x3dcccccd

00014848 <bsp_lc709204f_init>:
{
   14848:	b510      	push	{r4, lr}
   1484a:	b086      	sub	sp, #24
    uint8_t init_cmds[] = {
   1484c:	4b0f      	ldr	r3, [pc, #60]	; (1488c <bsp_lc709204f_init+0x44>)
   1484e:	e893 0003 	ldmia.w	r3, {r0, r1}
   14852:	9004      	str	r0, [sp, #16]
   14854:	f88d 1014 	strb.w	r1, [sp, #20]
    uint16_t init_data[] = {
   14858:	4a0d      	ldr	r2, [pc, #52]	; (14890 <bsp_lc709204f_init+0x48>)
   1485a:	ab01      	add	r3, sp, #4
   1485c:	ca07      	ldmia	r2, {r0, r1, r2}
   1485e:	c303      	stmia	r3!, {r0, r1}
   14860:	801a      	strh	r2, [r3, #0]
    for (uint8_t idx = 0; (idx < (sizeof(init_cmds) / sizeof(init_cmds[0]))) && ( ZEPHYR_ERR_SUCCESS == err); idx++)
   14862:	2400      	movs	r4, #0
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;
   14864:	4620      	mov	r0, r4
    for (uint8_t idx = 0; (idx < (sizeof(init_cmds) / sizeof(init_cmds[0]))) && ( ZEPHYR_ERR_SUCCESS == err); idx++)
   14866:	e00b      	b.n	14880 <bsp_lc709204f_init+0x38>
        err = bsp_lc709204f_write( init_cmds[idx] , init_data[idx] );
   14868:	ab06      	add	r3, sp, #24
   1486a:	eb03 0244 	add.w	r2, r3, r4, lsl #1
   1486e:	4423      	add	r3, r4
   14870:	f832 1c14 	ldrh.w	r1, [r2, #-20]
   14874:	f813 0c08 	ldrb.w	r0, [r3, #-8]
   14878:	f017 fa43 	bl	2bd02 <bsp_lc709204f_write>
    for (uint8_t idx = 0; (idx < (sizeof(init_cmds) / sizeof(init_cmds[0]))) && ( ZEPHYR_ERR_SUCCESS == err); idx++)
   1487c:	3401      	adds	r4, #1
   1487e:	b2e4      	uxtb	r4, r4
   14880:	2c04      	cmp	r4, #4
   14882:	d801      	bhi.n	14888 <bsp_lc709204f_init+0x40>
   14884:	2800      	cmp	r0, #0
   14886:	d0ef      	beq.n	14868 <bsp_lc709204f_init+0x20>
}
   14888:	b006      	add	sp, #24
   1488a:	bd10      	pop	{r4, pc}
   1488c:	000316b4 	.word	0x000316b4
   14890:	000313e8 	.word	0x000313e8

00014894 <bsp_battery_gauge_reading_thread>:
{
   14894:	b500      	push	{lr}
   14896:	b083      	sub	sp, #12
        bsp_battery_gauge_fetch_params( &lc709204f.parameters );
   14898:	4c0a      	ldr	r4, [pc, #40]	; (148c4 <bsp_battery_gauge_reading_thread+0x30>)
   1489a:	f104 0020 	add.w	r0, r4, #32
   1489e:	f7ff ff93 	bl	147c8 <bsp_battery_gauge_fetch_params>
	return z_impl_k_event_wait(event, events, reset, timeout);
   148a2:	342c      	adds	r4, #44	; 0x2c
   148a4:	f04f 62e1 	mov.w	r2, #117964800	; 0x7080000
   148a8:	2300      	movs	r3, #0
   148aa:	e9cd 2300 	strd	r2, r3, [sp]
   148ae:	2200      	movs	r2, #0
   148b0:	2101      	movs	r1, #1
   148b2:	4620      	mov	r0, r4
   148b4:	f01c fa4e 	bl	30d54 <z_impl_k_event_wait>
	z_impl_k_event_set_masked(event, events, events_mask);
   148b8:	2201      	movs	r2, #1
   148ba:	2100      	movs	r1, #0
   148bc:	4620      	mov	r0, r4
   148be:	f01c fa45 	bl	30d4c <z_impl_k_event_set_masked>
    while( true )
   148c2:	e7e9      	b.n	14898 <bsp_battery_gauge_reading_thread+0x4>
   148c4:	20000870 	.word	0x20000870

000148c8 <bsp_battery_gauge_init>:
{
   148c8:	b510      	push	{r4, lr}
   148ca:	b088      	sub	sp, #32
    zephyr_err_t err = i2c_configure( lc709204f.i2c_device, lc709204f.i2c_config );
   148cc:	4b14      	ldr	r3, [pc, #80]	; (14920 <bsp_battery_gauge_init+0x58>)
   148ce:	6818      	ldr	r0, [r3, #0]
   148d0:	6859      	ldr	r1, [r3, #4]
	const struct i2c_driver_api *api =
   148d2:	6883      	ldr	r3, [r0, #8]
	return api->configure(dev, dev_config);
   148d4:	681b      	ldr	r3, [r3, #0]
   148d6:	4798      	blx	r3
    if( ZEPHYR_ERR_SUCCESS == err )
   148d8:	4604      	mov	r4, r0
   148da:	b110      	cbz	r0, 148e2 <bsp_battery_gauge_init+0x1a>
}
   148dc:	4620      	mov	r0, r4
   148de:	b008      	add	sp, #32
   148e0:	bd10      	pop	{r4, pc}
        err = bsp_lc709204f_init();
   148e2:	f7ff ffb1 	bl	14848 <bsp_lc709204f_init>
        if( ZEPHYR_ERR_SUCCESS == err)
   148e6:	4604      	mov	r4, r0
   148e8:	2800      	cmp	r0, #0
   148ea:	d1f7      	bne.n	148dc <bsp_battery_gauge_init+0x14>
	z_impl_k_event_init(event);
   148ec:	480d      	ldr	r0, [pc, #52]	; (14924 <bsp_battery_gauge_init+0x5c>)
   148ee:	f01c fa1c 	bl	30d2a <z_impl_k_event_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   148f2:	2200      	movs	r2, #0
   148f4:	2300      	movs	r3, #0
   148f6:	e9cd 2306 	strd	r2, r3, [sp, #24]
   148fa:	2303      	movs	r3, #3
   148fc:	9304      	str	r3, [sp, #16]
   148fe:	230a      	movs	r3, #10
   14900:	9303      	str	r3, [sp, #12]
   14902:	2300      	movs	r3, #0
   14904:	9302      	str	r3, [sp, #8]
   14906:	9301      	str	r3, [sp, #4]
   14908:	9300      	str	r3, [sp, #0]
   1490a:	4b07      	ldr	r3, [pc, #28]	; (14928 <bsp_battery_gauge_init+0x60>)
   1490c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   14910:	4906      	ldr	r1, [pc, #24]	; (1492c <bsp_battery_gauge_init+0x64>)
   14912:	4807      	ldr	r0, [pc, #28]	; (14930 <bsp_battery_gauge_init+0x68>)
   14914:	f011 fe16 	bl	26544 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   14918:	4906      	ldr	r1, [pc, #24]	; (14934 <bsp_battery_gauge_init+0x6c>)
   1491a:	f01b fffd 	bl	30918 <z_impl_k_thread_name_set>
    return err;
   1491e:	e7dd      	b.n	148dc <bsp_battery_gauge_init+0x14>
   14920:	20000870 	.word	0x20000870
   14924:	2000089c 	.word	0x2000089c
   14928:	00014895 	.word	0x00014895
   1492c:	20004e80 	.word	0x20004e80
   14930:	20001ea8 	.word	0x20001ea8
   14934:	000316bc 	.word	0x000316bc

00014938 <bsp_battery_gauge_get_parameters>:
    if( NULL != voltage )
   14938:	4684      	mov	ip, r0
   1493a:	b118      	cbz	r0, 14944 <bsp_battery_gauge_get_parameters+0xc>
        *voltage = lc709204f.parameters.voltage;
   1493c:	4809      	ldr	r0, [pc, #36]	; (14964 <bsp_battery_gauge_get_parameters+0x2c>)
   1493e:	6a00      	ldr	r0, [r0, #32]
   14940:	f8cc 0000 	str.w	r0, [ip]
    if( NULL != temperature )
   14944:	b111      	cbz	r1, 1494c <bsp_battery_gauge_get_parameters+0x14>
        *temperature = lc709204f.parameters.temperature;
   14946:	4807      	ldr	r0, [pc, #28]	; (14964 <bsp_battery_gauge_get_parameters+0x2c>)
   14948:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1494a:	6008      	str	r0, [r1, #0]
    if( NULL != rsoc )
   1494c:	b11a      	cbz	r2, 14956 <bsp_battery_gauge_get_parameters+0x1e>
        *rsoc = lc709204f.parameters.rsoc;
   1494e:	4905      	ldr	r1, [pc, #20]	; (14964 <bsp_battery_gauge_get_parameters+0x2c>)
   14950:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
   14954:	7011      	strb	r1, [r2, #0]
    if( NULL != health )
   14956:	b11b      	cbz	r3, 14960 <bsp_battery_gauge_get_parameters+0x28>
        *health = lc709204f.parameters.health;
   14958:	4a02      	ldr	r2, [pc, #8]	; (14964 <bsp_battery_gauge_get_parameters+0x2c>)
   1495a:	f892 2029 	ldrb.w	r2, [r2, #41]	; 0x29
   1495e:	701a      	strb	r2, [r3, #0]
}
   14960:	4770      	bx	lr
   14962:	bf00      	nop
   14964:	20000870 	.word	0x20000870

00014968 <bsp_fft_find_peak>:
{
   14968:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1496c:	ed2d 8b02 	vpush	{d8}
   14970:	4605      	mov	r5, r0
   14972:	4688      	mov	r8, r1
   14974:	4617      	mov	r7, r2
   14976:	461e      	mov	r6, r3
   14978:	f8bd 4020 	ldrh.w	r4, [sp, #32]
    float old_peak = 0.0f;
   1497c:	ed9f 8a14 	vldr	s16, [pc, #80]	; 149d0 <bsp_fft_find_peak+0x68>
    for (uint16_t idx = start_point; idx < (uint16_t) ((N - 0x1) / 0x2); idx++)
   14980:	e001      	b.n	14986 <bsp_fft_find_peak+0x1e>
   14982:	3401      	adds	r4, #1
   14984:	b2a4      	uxth	r4, r4
   14986:	f108 3cff 	add.w	ip, r8, #4294967295	; 0xffffffff
   1498a:	eb0c 7cdc 	add.w	ip, ip, ip, lsr #31
   1498e:	f3cc 0c4f 	ubfx	ip, ip, #1, #16
   14992:	45a4      	cmp	ip, r4
   14994:	d916      	bls.n	149c4 <bsp_fft_find_peak+0x5c>
        new_peak = cabsf( X[idx] ) / ( (float) N);
   14996:	eb05 0cc4 	add.w	ip, r5, r4, lsl #3
   1499a:	ed9c 0a00 	vldr	s0, [ip]
   1499e:	eddc 0a01 	vldr	s1, [ip, #4]
   149a2:	f01c fa1a 	bl	30dda <cabsf>
   149a6:	ee07 8a90 	vmov	s15, r8
   149aa:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   149ae:	eec0 7a07 	vdiv.f32	s15, s0, s14
        if( old_peak < new_peak )
   149b2:	eeb4 8ae7 	vcmpe.f32	s16, s15
   149b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   149ba:	d5e2      	bpl.n	14982 <bsp_fft_find_peak+0x1a>
            *peak_idx = idx;
   149bc:	8034      	strh	r4, [r6, #0]
            old_peak = new_peak;
   149be:	eeb0 8a67 	vmov.f32	s16, s15
   149c2:	e7de      	b.n	14982 <bsp_fft_find_peak+0x1a>
    *peak = old_peak;
   149c4:	ed87 8a00 	vstr	s16, [r7]
}
   149c8:	ecbd 8b02 	vpop	{d8}
   149cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   149d0:	00000000 	.word	0x00000000

000149d4 <bsp_display_wake_up_cb>:
    return err;
}


static void bsp_display_wake_up_cb(const zephyr_device_t* port, zephyr_gpio_callback_t* cb, gpio_port_pins_t pins)
{
   149d4:	b510      	push	{r4, lr}
   149d6:	b082      	sub	sp, #8
    afl240320a0.sleep_state = BSP_DISPLAY_LIGHT_SLEEP_STATE_FULL;
   149d8:	4c08      	ldr	r4, [pc, #32]	; (149fc <bsp_display_wake_up_cb+0x28>)
   149da:	2300      	movs	r3, #0
   149dc:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
    /*Turn on display and enable TFT_EN GPIO*/
    k_work_submit(&afl240320a0.display_work);
   149e0:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
   149e4:	f012 fe3a 	bl	2765c <k_work_submit>
    k_timer_start(&afl240320a0.sleep_timer , afl240320a0.dim_time , afl240320a0.dim_time );
   149e8:	e9d4 232c 	ldrd	r2, r3, [r4, #176]	; 0xb0
	z_impl_k_timer_start(timer, duration, period);
   149ec:	e9cd 2300 	strd	r2, r3, [sp]
   149f0:	f104 0070 	add.w	r0, r4, #112	; 0x70
   149f4:	f014 fee0 	bl	297b8 <z_impl_k_timer_start>
}
   149f8:	b002      	add	sp, #8
   149fa:	bd10      	pop	{r4, pc}
   149fc:	20000350 	.word	0x20000350

00014a00 <z_impl_gpio_pin_configure>:
{
   14a00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14a04:	4605      	mov	r5, r0
   14a06:	460e      	mov	r6, r1
   14a08:	4614      	mov	r4, r2
	const struct gpio_driver_api *api =
   14a0a:	f8d0 a008 	ldr.w	sl, [r0, #8]
	__unused const struct gpio_driver_config *const cfg =
   14a0e:	f8d0 b004 	ldr.w	fp, [r0, #4]
	struct gpio_driver_data *data =
   14a12:	f8d0 8010 	ldr.w	r8, [r0, #16]
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   14a16:	f012 6ffc 	tst.w	r2, #132120576	; 0x7e00000
   14a1a:	d135      	bne.n	14a88 <z_impl_gpio_pin_configure+0x88>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   14a1c:	f004 0330 	and.w	r3, r4, #48	; 0x30
   14a20:	2b30      	cmp	r3, #48	; 0x30
   14a22:	d03e      	beq.n	14aa2 <z_impl_gpio_pin_configure+0xa2>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   14a24:	f004 1302 	and.w	r3, r4, #131074	; 0x20002
   14a28:	2b02      	cmp	r3, #2
   14a2a:	d047      	beq.n	14abc <z_impl_gpio_pin_configure+0xbc>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   14a2c:	f004 0306 	and.w	r3, r4, #6
   14a30:	2b04      	cmp	r3, #4
   14a32:	d050      	beq.n	14ad6 <z_impl_gpio_pin_configure+0xd6>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   14a34:	f414 2740 	ands.w	r7, r4, #786432	; 0xc0000
   14a38:	d002      	beq.n	14a40 <z_impl_gpio_pin_configure+0x40>
   14a3a:	f414 3f00 	tst.w	r4, #131072	; 0x20000
   14a3e:	d057      	beq.n	14af0 <z_impl_gpio_pin_configure+0xf0>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   14a40:	f5b7 2f40 	cmp.w	r7, #786432	; 0xc0000
   14a44:	d062      	beq.n	14b0c <z_impl_gpio_pin_configure+0x10c>
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   14a46:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
   14a4a:	d005      	beq.n	14a58 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   14a4c:	b127      	cbz	r7, 14a58 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   14a4e:	f014 0f01 	tst.w	r4, #1
   14a52:	d001      	beq.n	14a58 <z_impl_gpio_pin_configure+0x58>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   14a54:	f484 2440 	eor.w	r4, r4, #786432	; 0xc0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   14a58:	f424 1980 	bic.w	r9, r4, #1048576	; 0x100000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14a5c:	f8db 3000 	ldr.w	r3, [fp]
   14a60:	2701      	movs	r7, #1
   14a62:	40b7      	lsls	r7, r6
   14a64:	423b      	tst	r3, r7
   14a66:	d05f      	beq.n	14b28 <z_impl_gpio_pin_configure+0x128>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   14a68:	f014 0f01 	tst.w	r4, #1
   14a6c:	d06a      	beq.n	14b44 <z_impl_gpio_pin_configure+0x144>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   14a6e:	f8d8 3000 	ldr.w	r3, [r8]
   14a72:	433b      	orrs	r3, r7
   14a74:	f8c8 3000 	str.w	r3, [r8]
	return api->pin_configure(port, pin, flags);
   14a78:	f8da 3000 	ldr.w	r3, [sl]
   14a7c:	464a      	mov	r2, r9
   14a7e:	4631      	mov	r1, r6
   14a80:	4628      	mov	r0, r5
   14a82:	4798      	blx	r3
}
   14a84:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   14a88:	4f32      	ldr	r7, [pc, #200]	; (14b54 <z_impl_gpio_pin_configure+0x154>)
   14a8a:	f44f 722f 	mov.w	r2, #700	; 0x2bc
   14a8e:	4639      	mov	r1, r7
   14a90:	4831      	ldr	r0, [pc, #196]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14a92:	f017 fd4c 	bl	2c52e <assert_print>
   14a96:	f44f 712f 	mov.w	r1, #700	; 0x2bc
   14a9a:	4638      	mov	r0, r7
   14a9c:	f017 fd40 	bl	2c520 <assert_post_action>
   14aa0:	e7bc      	b.n	14a1c <z_impl_gpio_pin_configure+0x1c>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   14aa2:	4f2c      	ldr	r7, [pc, #176]	; (14b54 <z_impl_gpio_pin_configure+0x154>)
   14aa4:	f240 22bf 	movw	r2, #703	; 0x2bf
   14aa8:	4639      	mov	r1, r7
   14aaa:	482b      	ldr	r0, [pc, #172]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14aac:	f017 fd3f 	bl	2c52e <assert_print>
   14ab0:	f240 21bf 	movw	r1, #703	; 0x2bf
   14ab4:	4638      	mov	r0, r7
   14ab6:	f017 fd33 	bl	2c520 <assert_post_action>
   14aba:	e7b3      	b.n	14a24 <z_impl_gpio_pin_configure+0x24>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   14abc:	4f25      	ldr	r7, [pc, #148]	; (14b54 <z_impl_gpio_pin_configure+0x154>)
   14abe:	f240 22c3 	movw	r2, #707	; 0x2c3
   14ac2:	4639      	mov	r1, r7
   14ac4:	4824      	ldr	r0, [pc, #144]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14ac6:	f017 fd32 	bl	2c52e <assert_print>
   14aca:	f240 21c3 	movw	r1, #707	; 0x2c3
   14ace:	4638      	mov	r0, r7
   14ad0:	f017 fd26 	bl	2c520 <assert_post_action>
   14ad4:	e7aa      	b.n	14a2c <z_impl_gpio_pin_configure+0x2c>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   14ad6:	4f1f      	ldr	r7, [pc, #124]	; (14b54 <z_impl_gpio_pin_configure+0x154>)
   14ad8:	f240 22c7 	movw	r2, #711	; 0x2c7
   14adc:	4639      	mov	r1, r7
   14ade:	481e      	ldr	r0, [pc, #120]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14ae0:	f017 fd25 	bl	2c52e <assert_print>
   14ae4:	f240 21c7 	movw	r1, #711	; 0x2c7
   14ae8:	4638      	mov	r0, r7
   14aea:	f017 fd19 	bl	2c520 <assert_post_action>
   14aee:	e7a1      	b.n	14a34 <z_impl_gpio_pin_configure+0x34>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   14af0:	f8df 9060 	ldr.w	r9, [pc, #96]	; 14b54 <z_impl_gpio_pin_configure+0x154>
   14af4:	f240 22ca 	movw	r2, #714	; 0x2ca
   14af8:	4649      	mov	r1, r9
   14afa:	4817      	ldr	r0, [pc, #92]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14afc:	f017 fd17 	bl	2c52e <assert_print>
   14b00:	f240 21ca 	movw	r1, #714	; 0x2ca
   14b04:	4648      	mov	r0, r9
   14b06:	f017 fd0b 	bl	2c520 <assert_post_action>
   14b0a:	e799      	b.n	14a40 <z_impl_gpio_pin_configure+0x40>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   14b0c:	f8df 9044 	ldr.w	r9, [pc, #68]	; 14b54 <z_impl_gpio_pin_configure+0x154>
   14b10:	f240 22ce 	movw	r2, #718	; 0x2ce
   14b14:	4649      	mov	r1, r9
   14b16:	4810      	ldr	r0, [pc, #64]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14b18:	f017 fd09 	bl	2c52e <assert_print>
   14b1c:	f240 21ce 	movw	r1, #718	; 0x2ce
   14b20:	4648      	mov	r0, r9
   14b22:	f017 fcfd 	bl	2c520 <assert_post_action>
   14b26:	e78e      	b.n	14a46 <z_impl_gpio_pin_configure+0x46>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14b28:	f8df b028 	ldr.w	fp, [pc, #40]	; 14b54 <z_impl_gpio_pin_configure+0x154>
   14b2c:	f240 22da 	movw	r2, #730	; 0x2da
   14b30:	4659      	mov	r1, fp
   14b32:	4809      	ldr	r0, [pc, #36]	; (14b58 <z_impl_gpio_pin_configure+0x158>)
   14b34:	f017 fcfb 	bl	2c52e <assert_print>
   14b38:	f240 21da 	movw	r1, #730	; 0x2da
   14b3c:	4658      	mov	r0, fp
   14b3e:	f017 fcef 	bl	2c520 <assert_post_action>
   14b42:	e791      	b.n	14a68 <z_impl_gpio_pin_configure+0x68>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   14b44:	f8d8 3000 	ldr.w	r3, [r8]
   14b48:	ea23 0307 	bic.w	r3, r3, r7
   14b4c:	f8c8 3000 	str.w	r3, [r8]
   14b50:	e792      	b.n	14a78 <z_impl_gpio_pin_configure+0x78>
   14b52:	bf00      	nop
   14b54:	000315cc 	.word	0x000315cc
   14b58:	00031600 	.word	0x00031600

00014b5c <bsp_display_print_char>:
{
   14b5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14b60:	b08b      	sub	sp, #44	; 0x2c
   14b62:	4680      	mov	r8, r0
   14b64:	468a      	mov	sl, r1
    uint8_t*                           image_buffer = k_malloc(0);
   14b66:	2000      	movs	r0, #0
   14b68:	f01c f91b 	bl	30da2 <k_malloc>
   14b6c:	4683      	mov	fp, r0
    for (uint16_t idx = 0; (idx < num_chars) && (ZEPHYR_ERR_SUCCESS == err); idx++)
   14b6e:	2400      	movs	r4, #0
    char                               prev_char = '\0';
   14b70:	4625      	mov	r5, r4
    uint8_t*                           buffer_ptr = NULL;
   14b72:	9403      	str	r4, [sp, #12]
    zephyr_err_t                       err = ZEPHYR_ERR_SUCCESS;
   14b74:	4627      	mov	r7, r4
    for (uint16_t idx = 0; (idx < num_chars) && (ZEPHYR_ERR_SUCCESS == err); idx++)
   14b76:	e03e      	b.n	14bf6 <bsp_display_print_char+0x9a>
            k_free(image_buffer);
   14b78:	4658      	mov	r0, fp
   14b7a:	f01c f909 	bl	30d90 <k_free>
            char_image          = bsp_display_find_font(chars[idx], &times16pt);
   14b7e:	493e      	ldr	r1, [pc, #248]	; (14c78 <bsp_display_print_char+0x11c>)
   14b80:	f899 0000 	ldrb.w	r0, [r9]
   14b84:	f017 f8d3 	bl	2bd2e <bsp_display_find_font>
   14b88:	4605      	mov	r5, r0
            image_desc.pitch    = char_image->width;
   14b8a:	8883      	ldrh	r3, [r0, #4]
   14b8c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
            image_desc.width    = char_image->width;
   14b90:	f8ad 3020 	strh.w	r3, [sp, #32]
            image_desc.height   = char_image->height;
   14b94:	88c0      	ldrh	r0, [r0, #6]
   14b96:	f8ad 0022 	strh.w	r0, [sp, #34]	; 0x22
            image_desc.buf_size = BSP_DISPLAY_PIXEL_SCALE * image_desc.width * image_desc.height;
   14b9a:	fb03 f000 	mul.w	r0, r3, r0
   14b9e:	0040      	lsls	r0, r0, #1
   14ba0:	9007      	str	r0, [sp, #28]
            image_buffer = k_malloc(sizeof(uint8_t) * image_desc.buf_size );
   14ba2:	f01c f8fe 	bl	30da2 <k_malloc>
   14ba6:	4683      	mov	fp, r0
            if( afl240320a0.text_page.colour.colour != 0xFFFF )
   14ba8:	4b34      	ldr	r3, [pc, #208]	; (14c7c <bsp_display_print_char+0x120>)
   14baa:	f8b3 205a 	ldrh.w	r2, [r3, #90]	; 0x5a
   14bae:	f64f 73ff 	movw	r3, #65535	; 0xffff
   14bb2:	429a      	cmp	r2, r3
   14bb4:	d00d      	beq.n	14bd2 <bsp_display_print_char+0x76>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   14bb6:	9a07      	ldr	r2, [sp, #28]
   14bb8:	6829      	ldr	r1, [r5, #0]
   14bba:	f01c f954 	bl	30e66 <memcpy>
                bsp_display_buffer_colour( image_buffer , &image_desc , afl240320a0.text_page.colour );
   14bbe:	4b2f      	ldr	r3, [pc, #188]	; (14c7c <bsp_display_print_char+0x120>)
   14bc0:	f8b3 205a 	ldrh.w	r2, [r3, #90]	; 0x5a
   14bc4:	a907      	add	r1, sp, #28
   14bc6:	4658      	mov	r0, fp
   14bc8:	f017 f8c6 	bl	2bd58 <bsp_display_buffer_colour>
                buffer_ptr = image_buffer;
   14bcc:	f8cd b00c 	str.w	fp, [sp, #12]
   14bd0:	e021      	b.n	14c16 <bsp_display_print_char+0xba>
                buffer_ptr = (uint8_t*) char_image->data;
   14bd2:	682b      	ldr	r3, [r5, #0]
   14bd4:	9303      	str	r3, [sp, #12]
   14bd6:	e01e      	b.n	14c16 <bsp_display_print_char+0xba>
            afl240320a0.text_page.y_pos += image_desc.height;
   14bd8:	440a      	add	r2, r1
   14bda:	4b28      	ldr	r3, [pc, #160]	; (14c7c <bsp_display_print_char+0x120>)
   14bdc:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
   14be0:	e005      	b.n	14bee <bsp_display_print_char+0x92>
        afl240320a0.text_page.x_pos += image_desc.pitch;
   14be2:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   14be6:	441a      	add	r2, r3
   14be8:	4b24      	ldr	r3, [pc, #144]	; (14c7c <bsp_display_print_char+0x120>)
   14bea:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
        prev_char = chars[idx];
   14bee:	f899 5000 	ldrb.w	r5, [r9]
    for (uint16_t idx = 0; (idx < num_chars) && (ZEPHYR_ERR_SUCCESS == err); idx++)
   14bf2:	3401      	adds	r4, #1
   14bf4:	b2a4      	uxth	r4, r4
   14bf6:	4554      	cmp	r4, sl
   14bf8:	d239      	bcs.n	14c6e <bsp_display_print_char+0x112>
   14bfa:	2f00      	cmp	r7, #0
   14bfc:	d137      	bne.n	14c6e <bsp_display_print_char+0x112>
        if( true == bsp_display_handle_cmd_chars(chars[idx]))
   14bfe:	eb08 0904 	add.w	r9, r8, r4
   14c02:	f818 0004 	ldrb.w	r0, [r8, r4]
   14c06:	f000 f83b 	bl	14c80 <bsp_display_handle_cmd_chars>
   14c0a:	2800      	cmp	r0, #0
   14c0c:	d1f1      	bne.n	14bf2 <bsp_display_print_char+0x96>
        if (prev_char != chars[idx])
   14c0e:	f818 3004 	ldrb.w	r3, [r8, r4]
   14c12:	42ab      	cmp	r3, r5
   14c14:	d1b0      	bne.n	14b78 <bsp_display_print_char+0x1c>
        err = display_write(afl240320a0.display_device,
   14c16:	4d19      	ldr	r5, [pc, #100]	; (14c7c <bsp_display_print_char+0x120>)
   14c18:	6828      	ldr	r0, [r5, #0]
static inline int display_write(const struct device *dev, const uint16_t x,
				const uint16_t y,
				const struct display_buffer_descriptor *desc,
				const void *buf)
{
	struct display_driver_api *api =
   14c1a:	6883      	ldr	r3, [r0, #8]
		(struct display_driver_api *)dev->api;

	return api->write(dev, x, y, desc, buf);
   14c1c:	689f      	ldr	r7, [r3, #8]
   14c1e:	ae07      	add	r6, sp, #28
   14c20:	9b03      	ldr	r3, [sp, #12]
   14c22:	9300      	str	r3, [sp, #0]
   14c24:	4633      	mov	r3, r6
   14c26:	f8b5 2050 	ldrh.w	r2, [r5, #80]	; 0x50
   14c2a:	f8b5 1052 	ldrh.w	r1, [r5, #82]	; 0x52
   14c2e:	47b8      	blx	r7
   14c30:	4607      	mov	r7, r0
        bsp_display_update_pos( image_desc );
   14c32:	ab04      	add	r3, sp, #16
   14c34:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   14c38:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    if ((afl240320a0.text_page.x_pos + image_desc.width) >= afl240320a0.text_page.page_width)
   14c3c:	f8b5 2052 	ldrh.w	r2, [r5, #82]	; 0x52
   14c40:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   14c44:	4413      	add	r3, r2
   14c46:	f8b5 1054 	ldrh.w	r1, [r5, #84]	; 0x54
   14c4a:	428b      	cmp	r3, r1
   14c4c:	dbc9      	blt.n	14be2 <bsp_display_print_char+0x86>
        afl240320a0.text_page.x_pos = 0;
   14c4e:	2200      	movs	r2, #0
   14c50:	f8a5 2052 	strh.w	r2, [r5, #82]	; 0x52
        if ((afl240320a0.text_page.y_pos + image_desc.height) >= afl240320a0.text_page.page_height)
   14c54:	f8b5 2050 	ldrh.w	r2, [r5, #80]	; 0x50
   14c58:	f8bd 1016 	ldrh.w	r1, [sp, #22]
   14c5c:	1850      	adds	r0, r2, r1
   14c5e:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
   14c62:	4298      	cmp	r0, r3
   14c64:	dbb8      	blt.n	14bd8 <bsp_display_print_char+0x7c>
            afl240320a0.text_page.y_pos = 0;
   14c66:	2200      	movs	r2, #0
   14c68:	f8a5 2050 	strh.w	r2, [r5, #80]	; 0x50
   14c6c:	e7bf      	b.n	14bee <bsp_display_print_char+0x92>
}
   14c6e:	4638      	mov	r0, r7
   14c70:	b00b      	add	sp, #44	; 0x2c
   14c72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14c76:	bf00      	nop
   14c78:	0003851c 	.word	0x0003851c
   14c7c:	20000350 	.word	0x20000350

00014c80 <bsp_display_handle_cmd_chars>:
    switch ( c )
   14c80:	280a      	cmp	r0, #10
   14c82:	d005      	beq.n	14c90 <bsp_display_handle_cmd_chars+0x10>
   14c84:	280d      	cmp	r0, #13
   14c86:	d00e      	beq.n	14ca6 <bsp_display_handle_cmd_chars+0x26>
   14c88:	2809      	cmp	r0, #9
   14c8a:	d012      	beq.n	14cb2 <bsp_display_handle_cmd_chars+0x32>
   14c8c:	2000      	movs	r0, #0
   14c8e:	4770      	bx	lr
            afl240320a0.text_page.y_pos += 19;
   14c90:	4b0d      	ldr	r3, [pc, #52]	; (14cc8 <bsp_display_handle_cmd_chars+0x48>)
   14c92:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
   14c96:	3213      	adds	r2, #19
   14c98:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
            afl240320a0.text_page.x_pos = 0;
   14c9c:	2200      	movs	r2, #0
   14c9e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    bool ret_val = true;
   14ca2:	2001      	movs	r0, #1
        break;
   14ca4:	4770      	bx	lr
            afl240320a0.text_page.x_pos = 0;
   14ca6:	4b08      	ldr	r3, [pc, #32]	; (14cc8 <bsp_display_handle_cmd_chars+0x48>)
   14ca8:	2200      	movs	r2, #0
   14caa:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    bool ret_val = true;
   14cae:	2001      	movs	r0, #1
}
   14cb0:	4770      	bx	lr
{
   14cb2:	b510      	push	{r4, lr}
            bsp_display_print_char(BSP_DISPLAY_CHAR_TAB, strlen(BSP_DISPLAY_CHAR_TAB));
   14cb4:	4c05      	ldr	r4, [pc, #20]	; (14ccc <bsp_display_handle_cmd_chars+0x4c>)
   14cb6:	4620      	mov	r0, r4
   14cb8:	f7f7 fff7 	bl	ccaa <strlen>
   14cbc:	b281      	uxth	r1, r0
   14cbe:	4620      	mov	r0, r4
   14cc0:	f7ff ff4c 	bl	14b5c <bsp_display_print_char>
    bool ret_val = true;
   14cc4:	2001      	movs	r0, #1
}
   14cc6:	bd10      	pop	{r4, pc}
   14cc8:	20000350 	.word	0x20000350
   14ccc:	000316d0 	.word	0x000316d0

00014cd0 <bsp_display_display_wakeup_gpio_init>:
{
   14cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return gpio_pin_configure(spec->port,
   14cd2:	4b20      	ldr	r3, [pc, #128]	; (14d54 <bsp_display_display_wakeup_gpio_init+0x84>)
   14cd4:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
   14cd6:	f893 1060 	ldrb.w	r1, [r3, #96]	; 0x60
				  spec->dt_flags | extra_flags);
   14cda:	f8b3 2062 	ldrh.w	r2, [r3, #98]	; 0x62
	return gpio_pin_configure(spec->port,
   14cde:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   14ce2:	f7ff fe8d 	bl	14a00 <z_impl_gpio_pin_configure>
    if (ZEPHYR_ERR_SUCCESS == err)
   14ce6:	b100      	cbz	r0, 14cea <bsp_display_display_wakeup_gpio_init+0x1a>
}
   14ce8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
   14cea:	4b1a      	ldr	r3, [pc, #104]	; (14d54 <bsp_display_display_wakeup_gpio_init+0x84>)
   14cec:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
   14cee:	f893 5060 	ldrb.w	r5, [r3, #96]	; 0x60
	const struct gpio_driver_api *api =
   14cf2:	68a6      	ldr	r6, [r4, #8]
	__unused const struct gpio_driver_config *const cfg =
   14cf4:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14cf6:	681a      	ldr	r2, [r3, #0]
   14cf8:	2301      	movs	r3, #1
   14cfa:	40ab      	lsls	r3, r5
   14cfc:	421a      	tst	r2, r3
   14cfe:	d019      	beq.n	14d34 <bsp_display_display_wakeup_gpio_init+0x64>
	return api->pin_interrupt_configure(port, pin, mode, trig);
   14d00:	69b6      	ldr	r6, [r6, #24]
   14d02:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   14d06:	f04f 72a0 	mov.w	r2, #20971520	; 0x1400000
   14d0a:	4629      	mov	r1, r5
   14d0c:	4620      	mov	r0, r4
   14d0e:	47b0      	blx	r6
        if (ZEPHYR_ERR_SUCCESS == err)
   14d10:	2800      	cmp	r0, #0
   14d12:	d1e9      	bne.n	14ce8 <bsp_display_display_wakeup_gpio_init+0x18>
                               BIT(afl240320a0.wake_up_gpio.gpio_spec.pin));
   14d14:	4b0f      	ldr	r3, [pc, #60]	; (14d54 <bsp_display_display_wakeup_gpio_init+0x84>)
   14d16:	f893 1060 	ldrb.w	r1, [r3, #96]	; 0x60
   14d1a:	2201      	movs	r2, #1
   14d1c:	408a      	lsls	r2, r1
	callback->handler = handler;
   14d1e:	490e      	ldr	r1, [pc, #56]	; (14d58 <bsp_display_display_wakeup_gpio_init+0x88>)
   14d20:	6699      	str	r1, [r3, #104]	; 0x68
	callback->pin_mask = pin_mask;
   14d22:	66da      	str	r2, [r3, #108]	; 0x6c
            err = gpio_add_callback(afl240320a0.wake_up_gpio.gpio_spec.port, &afl240320a0.wake_up_gpio.gpio_callback);
   14d24:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
	const struct gpio_driver_api *api =
   14d26:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   14d28:	69db      	ldr	r3, [r3, #28]
   14d2a:	b183      	cbz	r3, 14d4e <bsp_display_display_wakeup_gpio_init+0x7e>
	return api->manage_callback(port, callback, true);
   14d2c:	2201      	movs	r2, #1
   14d2e:	490b      	ldr	r1, [pc, #44]	; (14d5c <bsp_display_display_wakeup_gpio_init+0x8c>)
   14d30:	4798      	blx	r3
   14d32:	e7d9      	b.n	14ce8 <bsp_display_display_wakeup_gpio_init+0x18>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14d34:	4f0a      	ldr	r7, [pc, #40]	; (14d60 <bsp_display_display_wakeup_gpio_init+0x90>)
   14d36:	f44f 721f 	mov.w	r2, #636	; 0x27c
   14d3a:	4639      	mov	r1, r7
   14d3c:	4809      	ldr	r0, [pc, #36]	; (14d64 <bsp_display_display_wakeup_gpio_init+0x94>)
   14d3e:	f017 fbf6 	bl	2c52e <assert_print>
   14d42:	f44f 711f 	mov.w	r1, #636	; 0x27c
   14d46:	4638      	mov	r0, r7
   14d48:	f017 fbea 	bl	2c520 <assert_post_action>
   14d4c:	e7d8      	b.n	14d00 <bsp_display_display_wakeup_gpio_init+0x30>
		return -ENOTSUP;
   14d4e:	f06f 0085 	mvn.w	r0, #133	; 0x85
    return err;
   14d52:	e7c9      	b.n	14ce8 <bsp_display_display_wakeup_gpio_init+0x18>
   14d54:	20000350 	.word	0x20000350
   14d58:	000149d5 	.word	0x000149d5
   14d5c:	200003b4 	.word	0x200003b4
   14d60:	000315cc 	.word	0x000315cc
   14d64:	00031600 	.word	0x00031600

00014d68 <bsp_display_init_blk_gpio>:
{
   14d68:	b508      	push	{r3, lr}
	return gpio_pin_configure(spec->port,
   14d6a:	4b0e      	ldr	r3, [pc, #56]	; (14da4 <bsp_display_init_blk_gpio+0x3c>)
   14d6c:	6958      	ldr	r0, [r3, #20]
   14d6e:	7e19      	ldrb	r1, [r3, #24]
				  spec->dt_flags | extra_flags);
   14d70:	8b5a      	ldrh	r2, [r3, #26]
	return gpio_pin_configure(spec->port,
   14d72:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   14d76:	f7ff fe43 	bl	14a00 <z_impl_gpio_pin_configure>
    if( ZEPHYR_ERR_SUCCESS == err )
   14d7a:	b100      	cbz	r0, 14d7e <bsp_display_init_blk_gpio+0x16>
}
   14d7c:	bd08      	pop	{r3, pc}
                           BIT(afl240320a0.back_light_gpio.gpio_spec.pin));
   14d7e:	4b09      	ldr	r3, [pc, #36]	; (14da4 <bsp_display_init_blk_gpio+0x3c>)
   14d80:	7e19      	ldrb	r1, [r3, #24]
   14d82:	2201      	movs	r2, #1
   14d84:	408a      	lsls	r2, r1
	callback->handler = handler;
   14d86:	4908      	ldr	r1, [pc, #32]	; (14da8 <bsp_display_init_blk_gpio+0x40>)
   14d88:	6219      	str	r1, [r3, #32]
	callback->pin_mask = pin_mask;
   14d8a:	625a      	str	r2, [r3, #36]	; 0x24
        err = gpio_add_callback(afl240320a0.back_light_gpio.gpio_spec.port, &afl240320a0.back_light_gpio.gpio_callback);
   14d8c:	6958      	ldr	r0, [r3, #20]
	const struct gpio_driver_api *api =
   14d8e:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   14d90:	69db      	ldr	r3, [r3, #28]
   14d92:	b11b      	cbz	r3, 14d9c <bsp_display_init_blk_gpio+0x34>
	return api->manage_callback(port, callback, true);
   14d94:	2201      	movs	r2, #1
   14d96:	4905      	ldr	r1, [pc, #20]	; (14dac <bsp_display_init_blk_gpio+0x44>)
   14d98:	4798      	blx	r3
   14d9a:	e7ef      	b.n	14d7c <bsp_display_init_blk_gpio+0x14>
		return -ENOTSUP;
   14d9c:	f06f 0085 	mvn.w	r0, #133	; 0x85
    return err;
   14da0:	e7ec      	b.n	14d7c <bsp_display_init_blk_gpio+0x14>
   14da2:	bf00      	nop
   14da4:	20000350 	.word	0x20000350
   14da8:	0002bd8d 	.word	0x0002bd8d
   14dac:	2000036c 	.word	0x2000036c

00014db0 <bsp_display_init_tft_enable_gpio>:
{
    return gpio_pin_set_dt( &afl240320a0.enable_gpio.gpio_spec , on_off );
}

static zephyr_err_t bsp_display_init_tft_enable_gpio(void)
{
   14db0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gpio_pin_configure(spec->port,
   14db4:	4b30      	ldr	r3, [pc, #192]	; (14e78 <bsp_display_init_tft_enable_gpio+0xc8>)
   14db6:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   14db8:	f893 1040 	ldrb.w	r1, [r3, #64]	; 0x40
				  spec->dt_flags | extra_flags);
   14dbc:	f8b3 2042 	ldrh.w	r2, [r3, #66]	; 0x42
	return gpio_pin_configure(spec->port,
   14dc0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   14dc4:	f7ff fe1c 	bl	14a00 <z_impl_gpio_pin_configure>
    zephyr_err_t err = gpio_pin_configure_dt(&afl240320a0.enable_gpio.gpio_spec, GPIO_OUTPUT);
    if( ZEPHYR_ERR_SUCCESS == err )
   14dc8:	4604      	mov	r4, r0
   14dca:	b110      	cbz	r0, 14dd2 <bsp_display_init_tft_enable_gpio+0x22>
        err = gpio_add_callback(afl240320a0.enable_gpio.gpio_spec.port, &afl240320a0.enable_gpio.gpio_callback);
        gpio_pin_set_dt(&afl240320a0.enable_gpio.gpio_spec,1);
    }

    return err;
}
   14dcc:	4620      	mov	r0, r4
   14dce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                           BIT(afl240320a0.enable_gpio.gpio_spec.pin));
   14dd2:	4b29      	ldr	r3, [pc, #164]	; (14e78 <bsp_display_init_tft_enable_gpio+0xc8>)
   14dd4:	f893 1040 	ldrb.w	r1, [r3, #64]	; 0x40
   14dd8:	2201      	movs	r2, #1
   14dda:	408a      	lsls	r2, r1
	callback->handler = handler;
   14ddc:	4927      	ldr	r1, [pc, #156]	; (14e7c <bsp_display_init_tft_enable_gpio+0xcc>)
   14dde:	6499      	str	r1, [r3, #72]	; 0x48
	callback->pin_mask = pin_mask;
   14de0:	64da      	str	r2, [r3, #76]	; 0x4c
        err = gpio_add_callback(afl240320a0.enable_gpio.gpio_spec.port, &afl240320a0.enable_gpio.gpio_callback);
   14de2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
	const struct gpio_driver_api *api =
   14de4:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
   14de6:	69db      	ldr	r3, [r3, #28]
   14de8:	b313      	cbz	r3, 14e30 <bsp_display_init_tft_enable_gpio+0x80>
	return api->manage_callback(port, callback, true);
   14dea:	2201      	movs	r2, #1
   14dec:	4924      	ldr	r1, [pc, #144]	; (14e80 <bsp_display_init_tft_enable_gpio+0xd0>)
   14dee:	4798      	blx	r3
   14df0:	4680      	mov	r8, r0
	return gpio_pin_set(spec->port, spec->pin, value);
   14df2:	4b21      	ldr	r3, [pc, #132]	; (14e78 <bsp_display_init_tft_enable_gpio+0xc8>)
   14df4:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
   14df6:	f893 9040 	ldrb.w	r9, [r3, #64]	; 0x40
	__unused const struct gpio_driver_config *const cfg =
   14dfa:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   14dfc:	692e      	ldr	r6, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14dfe:	681b      	ldr	r3, [r3, #0]
   14e00:	2701      	movs	r7, #1
   14e02:	fa07 f709 	lsl.w	r7, r7, r9
   14e06:	423b      	tst	r3, r7
   14e08:	d015      	beq.n	14e36 <bsp_display_init_tft_enable_gpio+0x86>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   14e0a:	6833      	ldr	r3, [r6, #0]
   14e0c:	421f      	tst	r7, r3
   14e0e:	d100      	bne.n	14e12 <bsp_display_init_tft_enable_gpio+0x62>
   14e10:	2401      	movs	r4, #1
	__unused const struct gpio_driver_config *const cfg =
   14e12:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14e14:	681b      	ldr	r3, [r3, #0]
   14e16:	2601      	movs	r6, #1
   14e18:	fa06 f609 	lsl.w	r6, r6, r9
   14e1c:	4233      	tst	r3, r6
   14e1e:	d018      	beq.n	14e52 <bsp_display_init_tft_enable_gpio+0xa2>
	if (value != 0)	{
   14e20:	b324      	cbz	r4, 14e6c <bsp_display_init_tft_enable_gpio+0xbc>
	const struct gpio_driver_api *api =
   14e22:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   14e24:	68db      	ldr	r3, [r3, #12]
   14e26:	4631      	mov	r1, r6
   14e28:	4628      	mov	r0, r5
   14e2a:	4798      	blx	r3
   14e2c:	4644      	mov	r4, r8
    return err;
   14e2e:	e7cd      	b.n	14dcc <bsp_display_init_tft_enable_gpio+0x1c>
		return -ENOTSUP;
   14e30:	f06f 0885 	mvn.w	r8, #133	; 0x85
   14e34:	e7dd      	b.n	14df2 <bsp_display_init_tft_enable_gpio+0x42>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14e36:	f8df a050 	ldr.w	sl, [pc, #80]	; 14e88 <bsp_display_init_tft_enable_gpio+0xd8>
   14e3a:	f240 5225 	movw	r2, #1317	; 0x525
   14e3e:	4651      	mov	r1, sl
   14e40:	4810      	ldr	r0, [pc, #64]	; (14e84 <bsp_display_init_tft_enable_gpio+0xd4>)
   14e42:	f017 fb74 	bl	2c52e <assert_print>
   14e46:	f240 5125 	movw	r1, #1317	; 0x525
   14e4a:	4650      	mov	r0, sl
   14e4c:	f017 fb68 	bl	2c520 <assert_post_action>
   14e50:	e7db      	b.n	14e0a <bsp_display_init_tft_enable_gpio+0x5a>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14e52:	4f0d      	ldr	r7, [pc, #52]	; (14e88 <bsp_display_init_tft_enable_gpio+0xd8>)
   14e54:	f240 42fc 	movw	r2, #1276	; 0x4fc
   14e58:	4639      	mov	r1, r7
   14e5a:	480a      	ldr	r0, [pc, #40]	; (14e84 <bsp_display_init_tft_enable_gpio+0xd4>)
   14e5c:	f017 fb67 	bl	2c52e <assert_print>
   14e60:	f240 41fc 	movw	r1, #1276	; 0x4fc
   14e64:	4638      	mov	r0, r7
   14e66:	f017 fb5b 	bl	2c520 <assert_post_action>
   14e6a:	e7d9      	b.n	14e20 <bsp_display_init_tft_enable_gpio+0x70>
	const struct gpio_driver_api *api =
   14e6c:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   14e6e:	691b      	ldr	r3, [r3, #16]
   14e70:	4631      	mov	r1, r6
   14e72:	4628      	mov	r0, r5
   14e74:	4798      	blx	r3
   14e76:	e7d9      	b.n	14e2c <bsp_display_init_tft_enable_gpio+0x7c>
   14e78:	20000350 	.word	0x20000350
   14e7c:	0002bd8b 	.word	0x0002bd8b
   14e80:	20000394 	.word	0x20000394
   14e84:	00031600 	.word	0x00031600
   14e88:	000315cc 	.word	0x000315cc

00014e8c <bsp_display_tft_enable>:
{
   14e8c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   14e90:	4605      	mov	r5, r0
	return gpio_pin_set(spec->port, spec->pin, value);
   14e92:	4b21      	ldr	r3, [pc, #132]	; (14f18 <bsp_display_tft_enable+0x8c>)
   14e94:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
   14e96:	f893 8040 	ldrb.w	r8, [r3, #64]	; 0x40
	__unused const struct gpio_driver_config *const cfg =
   14e9a:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   14e9c:	6926      	ldr	r6, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14e9e:	681b      	ldr	r3, [r3, #0]
   14ea0:	2701      	movs	r7, #1
   14ea2:	fa07 f708 	lsl.w	r7, r7, r8
   14ea6:	423b      	tst	r3, r7
   14ea8:	d014      	beq.n	14ed4 <bsp_display_tft_enable+0x48>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   14eaa:	6833      	ldr	r3, [r6, #0]
   14eac:	421f      	tst	r7, r3
   14eae:	d002      	beq.n	14eb6 <bsp_display_tft_enable+0x2a>
		value = (value != 0) ? 0 : 1;
   14eb0:	fab5 f585 	clz	r5, r5
   14eb4:	096d      	lsrs	r5, r5, #5
	__unused const struct gpio_driver_config *const cfg =
   14eb6:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14eb8:	681b      	ldr	r3, [r3, #0]
   14eba:	2601      	movs	r6, #1
   14ebc:	fa06 f608 	lsl.w	r6, r6, r8
   14ec0:	4233      	tst	r3, r6
   14ec2:	d015      	beq.n	14ef0 <bsp_display_tft_enable+0x64>
	if (value != 0)	{
   14ec4:	b30d      	cbz	r5, 14f0a <bsp_display_tft_enable+0x7e>
	const struct gpio_driver_api *api =
   14ec6:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   14ec8:	68db      	ldr	r3, [r3, #12]
   14eca:	4631      	mov	r1, r6
   14ecc:	4620      	mov	r0, r4
   14ece:	4798      	blx	r3
}
   14ed0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14ed4:	f8df 9048 	ldr.w	r9, [pc, #72]	; 14f20 <bsp_display_tft_enable+0x94>
   14ed8:	f240 5225 	movw	r2, #1317	; 0x525
   14edc:	4649      	mov	r1, r9
   14ede:	480f      	ldr	r0, [pc, #60]	; (14f1c <bsp_display_tft_enable+0x90>)
   14ee0:	f017 fb25 	bl	2c52e <assert_print>
   14ee4:	f240 5125 	movw	r1, #1317	; 0x525
   14ee8:	4648      	mov	r0, r9
   14eea:	f017 fb19 	bl	2c520 <assert_post_action>
   14eee:	e7dc      	b.n	14eaa <bsp_display_tft_enable+0x1e>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   14ef0:	4f0b      	ldr	r7, [pc, #44]	; (14f20 <bsp_display_tft_enable+0x94>)
   14ef2:	f240 42fc 	movw	r2, #1276	; 0x4fc
   14ef6:	4639      	mov	r1, r7
   14ef8:	4808      	ldr	r0, [pc, #32]	; (14f1c <bsp_display_tft_enable+0x90>)
   14efa:	f017 fb18 	bl	2c52e <assert_print>
   14efe:	f240 41fc 	movw	r1, #1276	; 0x4fc
   14f02:	4638      	mov	r0, r7
   14f04:	f017 fb0c 	bl	2c520 <assert_post_action>
   14f08:	e7dc      	b.n	14ec4 <bsp_display_tft_enable+0x38>
	const struct gpio_driver_api *api =
   14f0a:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   14f0c:	691b      	ldr	r3, [r3, #16]
   14f0e:	4631      	mov	r1, r6
   14f10:	4620      	mov	r0, r4
   14f12:	4798      	blx	r3
    return gpio_pin_set_dt( &afl240320a0.enable_gpio.gpio_spec , on_off );
   14f14:	e7dc      	b.n	14ed0 <bsp_display_tft_enable+0x44>
   14f16:	bf00      	nop
   14f18:	20000350 	.word	0x20000350
   14f1c:	00031600 	.word	0x00031600
   14f20:	000315cc 	.word	0x000315cc

00014f24 <bsp_display_sleep_timer_exp>:
{
   14f24:	b510      	push	{r4, lr}
   14f26:	b082      	sub	sp, #8
    switch (afl240320a0.sleep_state)
   14f28:	4b18      	ldr	r3, [pc, #96]	; (14f8c <bsp_display_sleep_timer_exp+0x68>)
   14f2a:	f893 30a8 	ldrb.w	r3, [r3, #168]	; 0xa8
   14f2e:	b2db      	uxtb	r3, r3
   14f30:	2b01      	cmp	r3, #1
   14f32:	d019      	beq.n	14f68 <bsp_display_sleep_timer_exp+0x44>
   14f34:	2b02      	cmp	r3, #2
   14f36:	d024      	beq.n	14f82 <bsp_display_sleep_timer_exp+0x5e>
   14f38:	b10b      	cbz	r3, 14f3e <bsp_display_sleep_timer_exp+0x1a>
}
   14f3a:	b002      	add	sp, #8
   14f3c:	bd10      	pop	{r4, pc}
            bsp_display_backlight_fade( (int16_t) afl240320a0.screen_brightness , 100 , K_SECONDS(2) );
   14f3e:	4c13      	ldr	r4, [pc, #76]	; (14f8c <bsp_display_sleep_timer_exp+0x68>)
   14f40:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   14f44:	2300      	movs	r3, #0
   14f46:	2164      	movs	r1, #100	; 0x64
   14f48:	f9b4 0038 	ldrsh.w	r0, [r4, #56]	; 0x38
   14f4c:	f016 ff23 	bl	2bd96 <bsp_display_backlight_fade>
            afl240320a0.sleep_state = BSP_DISPLAY_LIGHT_SLEEP_STATE_DIM;
   14f50:	2301      	movs	r3, #1
   14f52:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
            k_timer_start(&afl240320a0.sleep_timer , afl240320a0.off_time , afl240320a0.off_time );
   14f56:	e9d4 232e 	ldrd	r2, r3, [r4, #184]	; 0xb8
   14f5a:	e9cd 2300 	strd	r2, r3, [sp]
   14f5e:	f104 0070 	add.w	r0, r4, #112	; 0x70
   14f62:	f014 fc29 	bl	297b8 <z_impl_k_timer_start>
        break;
   14f66:	e7e8      	b.n	14f3a <bsp_display_sleep_timer_exp+0x16>
            afl240320a0.sleep_state = BSP_DISPLAY_LIGHT_SLEEP_STATE_OFF;
   14f68:	4c08      	ldr	r4, [pc, #32]	; (14f8c <bsp_display_sleep_timer_exp+0x68>)
   14f6a:	2302      	movs	r3, #2
   14f6c:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
	z_impl_k_timer_stop(timer);
   14f70:	f104 0070 	add.w	r0, r4, #112	; 0x70
   14f74:	f01b fe5f 	bl	30c36 <z_impl_k_timer_stop>
            k_work_submit(&afl240320a0.display_work);
   14f78:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
   14f7c:	f012 fb6e 	bl	2765c <k_work_submit>
        break;
   14f80:	e7db      	b.n	14f3a <bsp_display_sleep_timer_exp+0x16>
   14f82:	4803      	ldr	r0, [pc, #12]	; (14f90 <bsp_display_sleep_timer_exp+0x6c>)
   14f84:	f01b fe57 	bl	30c36 <z_impl_k_timer_stop>
}
   14f88:	e7d7      	b.n	14f3a <bsp_display_sleep_timer_exp+0x16>
   14f8a:	bf00      	nop
   14f8c:	20000350 	.word	0x20000350
   14f90:	200003c0 	.word	0x200003c0

00014f94 <bsp_display_draw_rectangle>:
{
   14f94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14f98:	b087      	sub	sp, #28
   14f9a:	4607      	mov	r7, r0
   14f9c:	460d      	mov	r5, r1
   14f9e:	461e      	mov	r6, r3
   14fa0:	f8bd 8038 	ldrh.w	r8, [sp, #56]	; 0x38
    zephyr_display_buffer_descriptor_t rect_desc = {
   14fa4:	f44f 60a0 	mov.w	r0, #1280	; 0x500
   14fa8:	9003      	str	r0, [sp, #12]
   14faa:	f8ad 2010 	strh.w	r2, [sp, #16]
   14fae:	2302      	movs	r3, #2
   14fb0:	f8ad 3012 	strh.w	r3, [sp, #18]
   14fb4:	f8ad 2014 	strh.w	r2, [sp, #20]
    uint8_t* rect_buf = k_malloc( sizeof(uint8_t) * BSP_DISPLAY_MAX_BUFFER_SIZE );
   14fb8:	f01b fef3 	bl	30da2 <k_malloc>
   14fbc:	4604      	mov	r4, r0
    uint8_t lb = 0x00FF & colour.colour;
   14fbe:	fa5f f388 	uxtb.w	r3, r8
    uint8_t ub = (0xFF00 & colour.colour) >> 8;
   14fc2:	f3c8 2e07 	ubfx	lr, r8, #8, #8
    for (uint32_t idx = 0; idx < BSP_DISPLAY_MAX_BUFFER_SIZE; idx += sizeof(uint16_t) )
   14fc6:	2200      	movs	r2, #0
   14fc8:	e005      	b.n	14fd6 <bsp_display_draw_rectangle+0x42>
        rect_buf[idx]   = lb;
   14fca:	54a3      	strb	r3, [r4, r2]
        rect_buf[idx+1] = ub;
   14fcc:	f102 0c01 	add.w	ip, r2, #1
   14fd0:	f804 e00c 	strb.w	lr, [r4, ip]
    for (uint32_t idx = 0; idx < BSP_DISPLAY_MAX_BUFFER_SIZE; idx += sizeof(uint16_t) )
   14fd4:	3202      	adds	r2, #2
   14fd6:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
   14fda:	d3f6      	bcc.n	14fca <bsp_display_draw_rectangle+0x36>
    for (uint16_t idx = 0; idx < height / 2; ++idx)
   14fdc:	f04f 0800 	mov.w	r8, #0
    zephyr_err_t err = -EINVAL;
   14fe0:	f06f 0915 	mvn.w	r9, #21
   14fe4:	e010      	b.n	15008 <bsp_display_draw_rectangle+0x74>
        err = display_write( afl240320a0.display_device , x_pos , y_pos ,&rect_desc , rect_buf );
   14fe6:	4b0d      	ldr	r3, [pc, #52]	; (1501c <bsp_display_draw_rectangle+0x88>)
   14fe8:	6818      	ldr	r0, [r3, #0]
	struct display_driver_api *api =
   14fea:	6883      	ldr	r3, [r0, #8]
	return api->write(dev, x, y, desc, buf);
   14fec:	f8d3 9008 	ldr.w	r9, [r3, #8]
   14ff0:	9400      	str	r4, [sp, #0]
   14ff2:	ab03      	add	r3, sp, #12
   14ff4:	462a      	mov	r2, r5
   14ff6:	4639      	mov	r1, r7
   14ff8:	47c8      	blx	r9
   14ffa:	4681      	mov	r9, r0
        y_pos+=2;
   14ffc:	3502      	adds	r5, #2
   14ffe:	b2ad      	uxth	r5, r5
    for (uint16_t idx = 0; idx < height / 2; ++idx)
   15000:	f108 0801 	add.w	r8, r8, #1
   15004:	fa1f f888 	uxth.w	r8, r8
   15008:	ebb8 0f56 	cmp.w	r8, r6, lsr #1
   1500c:	d3eb      	bcc.n	14fe6 <bsp_display_draw_rectangle+0x52>
    k_free( rect_buf );
   1500e:	4620      	mov	r0, r4
   15010:	f01b febe 	bl	30d90 <k_free>
}
   15014:	4648      	mov	r0, r9
   15016:	b007      	add	sp, #28
   15018:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1501c:	20000350 	.word	0x20000350

00015020 <bsp_display_init>:
{
   15020:	b538      	push	{r3, r4, r5, lr}
    afl240320a0.off_time = K_SECONDS(20);
   15022:	4b23      	ldr	r3, [pc, #140]	; (150b0 <bsp_display_init+0x90>)
   15024:	f44f 2020 	mov.w	r0, #655360	; 0xa0000
   15028:	2100      	movs	r1, #0
   1502a:	e9c3 012e 	strd	r0, r1, [r3, #184]	; 0xb8
    afl240320a0.dim_time = K_SECONDS(20);
   1502e:	e9c3 012c 	strd	r0, r1, [r3, #176]	; 0xb0
    zephyr_err_t err = bsp_display_init_tft_enable_gpio();
   15032:	f7ff febd 	bl	14db0 <bsp_display_init_tft_enable_gpio>
    if(ZEPHYR_ERR_SUCCESS == err)
   15036:	4604      	mov	r4, r0
   15038:	b108      	cbz	r0, 1503e <bsp_display_init+0x1e>
}
   1503a:	4620      	mov	r0, r4
   1503c:	bd38      	pop	{r3, r4, r5, pc}
        err = bsp_display_init_blk_gpio();
   1503e:	f7ff fe93 	bl	14d68 <bsp_display_init_blk_gpio>
        if(ZEPHYR_ERR_SUCCESS == err)
   15042:	4604      	mov	r4, r0
   15044:	2800      	cmp	r0, #0
   15046:	d1f8      	bne.n	1503a <bsp_display_init+0x1a>
            err = bsp_display_display_wakeup_gpio_init();
   15048:	f7ff fe42 	bl	14cd0 <bsp_display_display_wakeup_gpio_init>
            if(ZEPHYR_ERR_SUCCESS == err)
   1504c:	4604      	mov	r4, r0
   1504e:	2800      	cmp	r0, #0
   15050:	d1f3      	bne.n	1503a <bsp_display_init+0x1a>
                err = display_set_pixel_format(afl240320a0.display_device, PIXEL_FORMAT_RGB_565);
   15052:	4b17      	ldr	r3, [pc, #92]	; (150b0 <bsp_display_init+0x90>)
   15054:	6818      	ldr	r0, [r3, #0]
 */
static inline int
display_set_pixel_format(const struct device *dev,
			 const enum display_pixel_format pixel_format)
{
	struct display_driver_api *api =
   15056:	6883      	ldr	r3, [r0, #8]
		(struct display_driver_api *)dev->api;

	return api->set_pixel_format(dev, pixel_format);
   15058:	6a1b      	ldr	r3, [r3, #32]
   1505a:	2110      	movs	r1, #16
   1505c:	4798      	blx	r3
                if (ZEPHYR_ERR_SUCCESS == err)
   1505e:	4604      	mov	r4, r0
   15060:	2800      	cmp	r0, #0
   15062:	d1ea      	bne.n	1503a <bsp_display_init+0x1a>
                    err = bsp_display_clear();
   15064:	f016 feef 	bl	2be46 <bsp_display_clear>
                    if (ZEPHYR_ERR_SUCCESS == err)
   15068:	4604      	mov	r4, r0
   1506a:	2800      	cmp	r0, #0
   1506c:	d1e5      	bne.n	1503a <bsp_display_init+0x1a>
                        err = display_blanking_off(afl240320a0.display_device);
   1506e:	4b10      	ldr	r3, [pc, #64]	; (150b0 <bsp_display_init+0x90>)
   15070:	6818      	ldr	r0, [r3, #0]
	struct display_driver_api *api =
   15072:	6883      	ldr	r3, [r0, #8]
	return api->blanking_off(dev);
   15074:	685b      	ldr	r3, [r3, #4]
   15076:	4798      	blx	r3
                        if (ZEPHYR_ERR_SUCCESS == err)
   15078:	4604      	mov	r4, r0
   1507a:	2800      	cmp	r0, #0
   1507c:	d1dd      	bne.n	1503a <bsp_display_init+0x1a>
                            display_get_capabilities(afl240320a0.display_device, &afl240320a0.display_capabilities);
   1507e:	4d0c      	ldr	r5, [pc, #48]	; (150b0 <bsp_display_init+0x90>)
   15080:	4629      	mov	r1, r5
   15082:	f851 0b04 	ldr.w	r0, [r1], #4
	struct display_driver_api *api =
   15086:	6883      	ldr	r3, [r0, #8]
	api->get_capabilities(dev, capabilities);
   15088:	69db      	ldr	r3, [r3, #28]
   1508a:	4798      	blx	r3
                            err = bsp_display_backlight_set_brightness( AFL240320A0_DEFAULT_BRIGHTNESS );
   1508c:	20fa      	movs	r0, #250	; 0xfa
   1508e:	f7fd fd93 	bl	12bb8 <bsp_display_backlight_set_brightness>
   15092:	4604      	mov	r4, r0
                            k_timer_init(&afl240320a0.sleep_timer , bsp_display_sleep_timer_exp , NULL );
   15094:	2200      	movs	r2, #0
   15096:	4907      	ldr	r1, [pc, #28]	; (150b4 <bsp_display_init+0x94>)
   15098:	f105 0070 	add.w	r0, r5, #112	; 0x70
   1509c:	f01b fdbf 	bl	30c1e <k_timer_init>
                            k_work_init(&afl240320a0.display_work,bsp_display_work_handler);
   150a0:	4905      	ldr	r1, [pc, #20]	; (150b8 <bsp_display_init+0x98>)
   150a2:	f105 00c0 	add.w	r0, r5, #192	; 0xc0
   150a6:	f012 fa63 	bl	27570 <k_work_init>
                            bsp_display_clear();
   150aa:	f016 fecc 	bl	2be46 <bsp_display_clear>
    return err;
   150ae:	e7c4      	b.n	1503a <bsp_display_init+0x1a>
   150b0:	20000350 	.word	0x20000350
   150b4:	00014f25 	.word	0x00014f25
   150b8:	00015169 	.word	0x00015169

000150bc <bsp_display_set_text_pos>:
    if( (x_pos < afl240320a0.text_page.page_width) && (y_pos < afl240320a0.text_page.page_height) )
   150bc:	4b0b      	ldr	r3, [pc, #44]	; (150ec <bsp_display_set_text_pos+0x30>)
   150be:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
   150c2:	4283      	cmp	r3, r0
   150c4:	d90b      	bls.n	150de <bsp_display_set_text_pos+0x22>
   150c6:	4b09      	ldr	r3, [pc, #36]	; (150ec <bsp_display_set_text_pos+0x30>)
   150c8:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
   150cc:	428b      	cmp	r3, r1
   150ce:	d909      	bls.n	150e4 <bsp_display_set_text_pos+0x28>
        afl240320a0.text_page.x_pos = x_pos;
   150d0:	4b06      	ldr	r3, [pc, #24]	; (150ec <bsp_display_set_text_pos+0x30>)
   150d2:	f8a3 0052 	strh.w	r0, [r3, #82]	; 0x52
        afl240320a0.text_page.x_pos = y_pos;
   150d6:	f8a3 1052 	strh.w	r1, [r3, #82]	; 0x52
        err = ZEPHYR_ERR_SUCCESS;
   150da:	2000      	movs	r0, #0
   150dc:	4770      	bx	lr
    zephyr_err_t err = -EINVAL;
   150de:	f06f 0015 	mvn.w	r0, #21
   150e2:	4770      	bx	lr
   150e4:	f06f 0015 	mvn.w	r0, #21
}
   150e8:	4770      	bx	lr
   150ea:	bf00      	nop
   150ec:	20000350 	.word	0x20000350

000150f0 <bsp_display_turn_on>:
{
   150f0:	b538      	push	{r3, r4, r5, lr}
    zephyr_err_t err = bsp_display_tft_enable( true );
   150f2:	2001      	movs	r0, #1
   150f4:	f7ff feca 	bl	14e8c <bsp_display_tft_enable>
   150f8:	4604      	mov	r4, r0
	return z_impl_k_sleep(timeout);
   150fa:	f44f 7024 	mov.w	r0, #656	; 0x290
   150fe:	2100      	movs	r1, #0
   15100:	f013 fe2c 	bl	28d5c <z_impl_k_sleep>
    if( ZEPHYR_ERR_SUCCESS == err )
   15104:	b10c      	cbz	r4, 1510a <bsp_display_turn_on+0x1a>
}
   15106:	4620      	mov	r0, r4
   15108:	bd38      	pop	{r3, r4, r5, pc}
        err = bsp_display_backlight_fade( 0 , AFL240320A0_DEFAULT_BRIGHTNESS ,
   1510a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1510e:	2300      	movs	r3, #0
   15110:	21fa      	movs	r1, #250	; 0xfa
   15112:	2000      	movs	r0, #0
   15114:	f016 fe3f 	bl	2bd96 <bsp_display_backlight_fade>
                                              BSP_DISPLAY_FADE_TIME );
   15118:	f44f 3480 	mov.w	r4, #65536	; 0x10000
   1511c:	2500      	movs	r5, #0
            err = bsp_display_backlight_fade( 0 , AFL240320A0_DEFAULT_BRIGHTNESS ,
   1511e:	4622      	mov	r2, r4
   15120:	462b      	mov	r3, r5
   15122:	21fa      	movs	r1, #250	; 0xfa
   15124:	2000      	movs	r0, #0
   15126:	f016 fe36 	bl	2bd96 <bsp_display_backlight_fade>
            bsp_display_print_string("AMOGUS");
   1512a:	4805      	ldr	r0, [pc, #20]	; (15140 <bsp_display_turn_on+0x50>)
   1512c:	f016 fe99 	bl	2be62 <bsp_display_print_string>
            err = bsp_display_backlight_fade( AFL240320A0_DEFAULT_BRIGHTNESS , 0 ,
   15130:	4622      	mov	r2, r4
   15132:	462b      	mov	r3, r5
   15134:	2100      	movs	r1, #0
   15136:	20fa      	movs	r0, #250	; 0xfa
   15138:	f016 fe2d 	bl	2bd96 <bsp_display_backlight_fade>
        while(1)
   1513c:	e7ec      	b.n	15118 <bsp_display_turn_on+0x28>
   1513e:	bf00      	nop
   15140:	000316d8 	.word	0x000316d8

00015144 <bsp_display_turn_off>:
{
   15144:	b508      	push	{r3, lr}
    zephyr_err_t err = bsp_display_backlight_fade( (int16_t) afl240320a0.screen_brightness , 0 ,
   15146:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1514a:	2300      	movs	r3, #0
   1514c:	2100      	movs	r1, #0
   1514e:	4805      	ldr	r0, [pc, #20]	; (15164 <bsp_display_turn_off+0x20>)
   15150:	f9b0 0038 	ldrsh.w	r0, [r0, #56]	; 0x38
   15154:	f016 fe1f 	bl	2bd96 <bsp_display_backlight_fade>
    if( ZEPHYR_ERR_SUCCESS == err )
   15158:	b100      	cbz	r0, 1515c <bsp_display_turn_off+0x18>
}
   1515a:	bd08      	pop	{r3, pc}
        err = bsp_display_tft_enable( false );
   1515c:	2000      	movs	r0, #0
   1515e:	f7ff fe95 	bl	14e8c <bsp_display_tft_enable>
   15162:	e7fa      	b.n	1515a <bsp_display_turn_off+0x16>
   15164:	20000350 	.word	0x20000350

00015168 <bsp_display_work_handler>:
{
   15168:	b508      	push	{r3, lr}
    if( afl240320a0.sleep_state == BSP_DISPLAY_LIGHT_SLEEP_STATE_FULL )
   1516a:	4b08      	ldr	r3, [pc, #32]	; (1518c <bsp_display_work_handler+0x24>)
   1516c:	f893 30a8 	ldrb.w	r3, [r3, #168]	; 0xa8
   15170:	b133      	cbz	r3, 15180 <bsp_display_work_handler+0x18>
    if( afl240320a0.sleep_state == BSP_DISPLAY_LIGHT_SLEEP_STATE_OFF )
   15172:	4b06      	ldr	r3, [pc, #24]	; (1518c <bsp_display_work_handler+0x24>)
   15174:	f893 30a8 	ldrb.w	r3, [r3, #168]	; 0xa8
   15178:	b2db      	uxtb	r3, r3
   1517a:	2b02      	cmp	r3, #2
   1517c:	d003      	beq.n	15186 <bsp_display_work_handler+0x1e>
}
   1517e:	bd08      	pop	{r3, pc}
        bsp_display_turn_on();
   15180:	f7ff ffb6 	bl	150f0 <bsp_display_turn_on>
   15184:	e7f5      	b.n	15172 <bsp_display_work_handler+0xa>
        bsp_display_turn_off();
   15186:	f7ff ffdd 	bl	15144 <bsp_display_turn_off>
}
   1518a:	e7f8      	b.n	1517e <bsp_display_work_handler+0x16>
   1518c:	20000350 	.word	0x20000350

00015190 <main>:
struct gpio_dt_spec tx = TX;

#endif

void main(void)
{
   15190:	b510      	push	{r4, lr}
   15192:	e012      	b.n	151ba <main+0x2a>
                    {
                        printk("Vital's Monitor initialised successfully\n");
                    }
                    else
                    {
                        printk("App failed to Init!\n");
   15194:	4810      	ldr	r0, [pc, #64]	; (151d8 <main+0x48>)
   15196:	f016 ff27 	bl	2bfe8 <printk>
   1519a:	f640 40cd 	movw	r0, #3277	; 0xccd
   1519e:	2100      	movs	r1, #0
   151a0:	f013 fddc 	bl	28d5c <z_impl_k_sleep>
   151a4:	e008      	b.n	151b8 <main+0x28>
   151a6:	4604      	mov	r4, r0
                k_sleep(K_MSEC(100));
            }
        }
        else
        {
            printk("BSP failed to Init!\n");
   151a8:	480c      	ldr	r0, [pc, #48]	; (151dc <main+0x4c>)
   151aa:	f016 ff1d 	bl	2bfe8 <printk>
   151ae:	f640 40cd 	movw	r0, #3277	; 0xccd
   151b2:	2100      	movs	r1, #0
   151b4:	f013 fdd2 	bl	28d5c <z_impl_k_sleep>
            k_sleep(K_MSEC(100));
        }

    } while( err != ZEPHYR_ERR_SUCCESS );
   151b8:	b164      	cbz	r4, 151d4 <main+0x44>
        err = bsp_init();
   151ba:	f7fb fe41 	bl	10e40 <bsp_init>
        if( ZEPHYR_ERR_SUCCESS == err )
   151be:	2800      	cmp	r0, #0
   151c0:	d1f1      	bne.n	151a6 <main+0x16>
                    err = vital_app_init();
   151c2:	f000 f82b 	bl	1521c <vital_app_init>
                    if( ZEPHYR_ERR_SUCCESS == err )
   151c6:	4604      	mov	r4, r0
   151c8:	2800      	cmp	r0, #0
   151ca:	d1e3      	bne.n	15194 <main+0x4>
                        printk("Vital's Monitor initialised successfully\n");
   151cc:	4804      	ldr	r0, [pc, #16]	; (151e0 <main+0x50>)
   151ce:	f016 ff0b 	bl	2bfe8 <printk>
   151d2:	e7f1      	b.n	151b8 <main+0x28>
#endif
}
   151d4:	bd10      	pop	{r4, pc}
   151d6:	bf00      	nop
   151d8:	00038cbc 	.word	0x00038cbc
   151dc:	00038cd4 	.word	0x00038cd4
   151e0:	00038c90 	.word	0x00038c90

000151e4 <app_update_state>:
{
    k_work_submit(&app_adc_work);
}

static void app_update_state( vital_app_state_e new_state )
{
   151e4:	b538      	push	{r3, r4, r5, lr}
   151e6:	4604      	mov	r4, r0
    printk("App: changing state from %s to %s\n" , app_state_to_str[app_state] , app_state_to_str[new_state] );
   151e8:	4b05      	ldr	r3, [pc, #20]	; (15200 <app_update_state+0x1c>)
   151ea:	4d06      	ldr	r5, [pc, #24]	; (15204 <app_update_state+0x20>)
   151ec:	7829      	ldrb	r1, [r5, #0]
   151ee:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
   151f2:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
   151f6:	4804      	ldr	r0, [pc, #16]	; (15208 <app_update_state+0x24>)
   151f8:	f016 fef6 	bl	2bfe8 <printk>
    app_state = new_state;
   151fc:	702c      	strb	r4, [r5, #0]
}
   151fe:	bd38      	pop	{r3, r4, r5, pc}
   15200:	200008ac 	.word	0x200008ac
   15204:	2000470c 	.word	0x2000470c
   15208:	00038cec 	.word	0x00038cec

0001520c <app_resume_adc_sampling>:
{
   1520c:	b508      	push	{r3, lr}
    k_work_submit(&app_adc_work);
   1520e:	4802      	ldr	r0, [pc, #8]	; (15218 <app_resume_adc_sampling+0xc>)
   15210:	f012 fa24 	bl	2765c <k_work_submit>
}
   15214:	bd08      	pop	{r3, pc}
   15216:	bf00      	nop
   15218:	20003978 	.word	0x20003978

0001521c <vital_app_init>:
{
   1521c:	b510      	push	{r4, lr}
   1521e:	b088      	sub	sp, #32
    time_to_next_sample = K_SECONDS(90);
   15220:	4b18      	ldr	r3, [pc, #96]	; (15284 <vital_app_init+0x68>)
   15222:	f44f 1034 	mov.w	r0, #2949120	; 0x2d0000
   15226:	2100      	movs	r1, #0
   15228:	e9c3 0100 	strd	r0, r1, [r3]
	z_impl_k_event_init(event);
   1522c:	4816      	ldr	r0, [pc, #88]	; (15288 <vital_app_init+0x6c>)
   1522e:	f01b fd7c 	bl	30d2a <z_impl_k_event_init>
    k_work_init( &app_adc_work , app_adc_work_handler );
   15232:	4916      	ldr	r1, [pc, #88]	; (1528c <vital_app_init+0x70>)
   15234:	4816      	ldr	r0, [pc, #88]	; (15290 <vital_app_init+0x74>)
   15236:	f012 f99b 	bl	27570 <k_work_init>
    k_timer_init(&app_adc_sample_timer, app_resume_adc_sampling, NULL);
   1523a:	2200      	movs	r2, #0
   1523c:	4915      	ldr	r1, [pc, #84]	; (15294 <vital_app_init+0x78>)
   1523e:	4816      	ldr	r0, [pc, #88]	; (15298 <vital_app_init+0x7c>)
   15240:	f01b fced 	bl	30c1e <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   15244:	2200      	movs	r2, #0
   15246:	2300      	movs	r3, #0
   15248:	e9cd 2306 	strd	r2, r3, [sp, #24]
   1524c:	2301      	movs	r3, #1
   1524e:	9304      	str	r3, [sp, #16]
   15250:	2303      	movs	r3, #3
   15252:	9303      	str	r3, [sp, #12]
   15254:	2300      	movs	r3, #0
   15256:	9302      	str	r3, [sp, #8]
   15258:	9301      	str	r3, [sp, #4]
   1525a:	9300      	str	r3, [sp, #0]
   1525c:	4b0f      	ldr	r3, [pc, #60]	; (1529c <vital_app_init+0x80>)
   1525e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   15262:	490f      	ldr	r1, [pc, #60]	; (152a0 <vital_app_init+0x84>)
   15264:	480f      	ldr	r0, [pc, #60]	; (152a4 <vital_app_init+0x88>)
   15266:	f011 f96d 	bl	26544 <z_impl_k_thread_create>
    app_thread_tid = k_thread_create(&app_thread, app_thread_stack, APP_THREAD_STACK,
   1526a:	4c0f      	ldr	r4, [pc, #60]	; (152a8 <vital_app_init+0x8c>)
   1526c:	6020      	str	r0, [r4, #0]
	return z_impl_k_thread_name_set(thread, str);
   1526e:	490f      	ldr	r1, [pc, #60]	; (152ac <vital_app_init+0x90>)
   15270:	f01b fb52 	bl	30918 <z_impl_k_thread_name_set>
    if( NULL != app_thread_tid )
   15274:	6823      	ldr	r3, [r4, #0]
   15276:	b113      	cbz	r3, 1527e <vital_app_init+0x62>
        err = ZEPHYR_ERR_SUCCESS;
   15278:	2000      	movs	r0, #0
}
   1527a:	b008      	add	sp, #32
   1527c:	bd10      	pop	{r4, pc}
    zephyr_err_t err = -EIO;
   1527e:	f06f 0004 	mvn.w	r0, #4
   15282:	e7fa      	b.n	1527a <vital_app_init+0x5e>
   15284:	20002080 	.word	0x20002080
   15288:	200039a8 	.word	0x200039a8
   1528c:	0002beaf 	.word	0x0002beaf
   15290:	20003978 	.word	0x20003978
   15294:	0001520d 	.word	0x0001520d
   15298:	20001f78 	.word	0x20001f78
   1529c:	00015395 	.word	0x00015395
   152a0:	20005300 	.word	0x20005300
   152a4:	20001fb0 	.word	0x20001fb0
   152a8:	200039b8 	.word	0x200039b8
   152ac:	00038d10 	.word	0x00038d10

000152b0 <vital_app_flag_event>:
{
   152b0:	b508      	push	{r3, lr}
   152b2:	4601      	mov	r1, r0
	z_impl_k_event_post(event, events);
   152b4:	4801      	ldr	r0, [pc, #4]	; (152bc <vital_app_flag_event+0xc>)
   152b6:	f01b fd3e 	bl	30d36 <z_impl_k_event_post>
}
   152ba:	bd08      	pop	{r3, pc}
   152bc:	200039a8 	.word	0x200039a8

000152c0 <vital_app_clear_event>:
{
   152c0:	b508      	push	{r3, lr}
   152c2:	4602      	mov	r2, r0
	z_impl_k_event_set_masked(event, events, events_mask);
   152c4:	2100      	movs	r1, #0
   152c6:	4802      	ldr	r0, [pc, #8]	; (152d0 <vital_app_clear_event+0x10>)
   152c8:	f01b fd40 	bl	30d4c <z_impl_k_event_set_masked>
}
   152cc:	bd08      	pop	{r3, pc}
   152ce:	bf00      	nop
   152d0:	200039a8 	.word	0x200039a8

000152d4 <vital_app_running_task>:
{
   152d4:	b510      	push	{r4, lr}
   152d6:	b08a      	sub	sp, #40	; 0x28
    vitals_vital_sign_data_t new_vitals = {
   152d8:	2300      	movs	r3, #0
   152da:	9305      	str	r3, [sp, #20]
   152dc:	9306      	str	r3, [sp, #24]
   152de:	9307      	str	r3, [sp, #28]
   152e0:	9308      	str	r3, [sp, #32]
   152e2:	9309      	str	r3, [sp, #36]	; 0x24
   152e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   152e8:	9305      	str	r3, [sp, #20]
   152ea:	4a1f      	ldr	r2, [pc, #124]	; (15368 <vital_app_running_task+0x94>)
   152ec:	9206      	str	r2, [sp, #24]
   152ee:	f88d 301c 	strb.w	r3, [sp, #28]
   152f2:	23ff      	movs	r3, #255	; 0xff
   152f4:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    zephyr_err_t err = bsp_get_data( &new_vitals, &app_data.battery );
   152f8:	491c      	ldr	r1, [pc, #112]	; (1536c <vital_app_running_task+0x98>)
   152fa:	a805      	add	r0, sp, #20
   152fc:	f7fd fcfc 	bl	12cf8 <bsp_get_data>
    if(ZEPHYR_ERR_SUCCESS == err)
   15300:	bb48      	cbnz	r0, 15356 <vital_app_running_task+0x82>
        app_data.vitals.temperature = (new_vitals.temperature != (uint32_t)~(0U)) ? new_vitals.temperature : app_data.vitals.temperature ;
   15302:	9a05      	ldr	r2, [sp, #20]
   15304:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
   15308:	d020      	beq.n	1534c <vital_app_running_task+0x78>
   1530a:	4b18      	ldr	r3, [pc, #96]	; (1536c <vital_app_running_task+0x98>)
   1530c:	60da      	str	r2, [r3, #12]
        app_data.vitals.acceleration = (new_vitals.acceleration != NAN) ? new_vitals.acceleration : app_data.vitals.acceleration ;
   1530e:	9a06      	ldr	r2, [sp, #24]
   15310:	611a      	str	r2, [r3, #16]
        app_data.vitals.respiration = (new_vitals.respiration != ((uint32_t)~(0U))) ? new_vitals.respiration : app_data.vitals.respiration ;
   15312:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
   15316:	779a      	strb	r2, [r3, #30]
        app_data.vitals.heart_rate = (new_vitals.heart_rate != ((uint8_t)~(0U))) ? new_vitals.heart_rate : app_data.vitals.heart_rate ;
   15318:	f89d 201c 	ldrb.w	r2, [sp, #28]
   1531c:	2aff      	cmp	r2, #255	; 0xff
   1531e:	d018      	beq.n	15352 <vital_app_running_task+0x7e>
   15320:	4b12      	ldr	r3, [pc, #72]	; (1536c <vital_app_running_task+0x98>)
   15322:	751a      	strb	r2, [r3, #20]
        app_data.vitals.heart_rate_raw  = new_vitals.heart_rate_raw;
   15324:	9a08      	ldr	r2, [sp, #32]
   15326:	619a      	str	r2, [r3, #24]
        app_data.vitals.heart_rate_raw_len = new_vitals.heart_rate_raw_len;
   15328:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   1532c:	839a      	strh	r2, [r3, #28]
        err = bsp_print_data( app_data.vitals , app_data.battery);
   1532e:	ac01      	add	r4, sp, #4
   15330:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   15334:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   15338:	69da      	ldr	r2, [r3, #28]
   1533a:	9200      	str	r2, [sp, #0]
   1533c:	330c      	adds	r3, #12
   1533e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   15340:	f7fd fd20 	bl	12d84 <bsp_print_data>
   15344:	4604      	mov	r4, r0
}
   15346:	4620      	mov	r0, r4
   15348:	b00a      	add	sp, #40	; 0x28
   1534a:	bd10      	pop	{r4, pc}
        app_data.vitals.temperature = (new_vitals.temperature != (uint32_t)~(0U)) ? new_vitals.temperature : app_data.vitals.temperature ;
   1534c:	4b07      	ldr	r3, [pc, #28]	; (1536c <vital_app_running_task+0x98>)
   1534e:	68da      	ldr	r2, [r3, #12]
   15350:	e7db      	b.n	1530a <vital_app_running_task+0x36>
        app_data.vitals.heart_rate = (new_vitals.heart_rate != ((uint8_t)~(0U))) ? new_vitals.heart_rate : app_data.vitals.heart_rate ;
   15352:	7d1a      	ldrb	r2, [r3, #20]
   15354:	e7e4      	b.n	15320 <vital_app_running_task+0x4c>
   15356:	4604      	mov	r4, r0
        if( -ENOMSG == err )
   15358:	f110 0f23 	cmn.w	r0, #35	; 0x23
   1535c:	d1f3      	bne.n	15346 <vital_app_running_task+0x72>
            vital_app_clear_event(VITAL_APP_EVENTS_WORK_TO_DO);
   1535e:	2001      	movs	r0, #1
   15360:	f7ff ffae 	bl	152c0 <vital_app_clear_event>
    return err;
   15364:	e7ef      	b.n	15346 <vital_app_running_task+0x72>
   15366:	bf00      	nop
   15368:	7fc00000 	.word	0x7fc00000
   1536c:	20003988 	.word	0x20003988

00015370 <vital_app_event_is_set>:
{
   15370:	b500      	push	{lr}
   15372:	b083      	sub	sp, #12
   15374:	4601      	mov	r1, r0
	return z_impl_k_event_wait(event, events, reset, timeout);
   15376:	9200      	str	r2, [sp, #0]
   15378:	9301      	str	r3, [sp, #4]
   1537a:	2200      	movs	r2, #0
   1537c:	4804      	ldr	r0, [pc, #16]	; (15390 <vital_app_event_is_set+0x20>)
   1537e:	f01b fce9 	bl	30d54 <z_impl_k_event_wait>
}
   15382:	3800      	subs	r0, #0
   15384:	bf18      	it	ne
   15386:	2001      	movne	r0, #1
   15388:	b003      	add	sp, #12
   1538a:	f85d fb04 	ldr.w	pc, [sp], #4
   1538e:	bf00      	nop
   15390:	200039a8 	.word	0x200039a8

00015394 <vital_app_application>:
{
   15394:	b580      	push	{r7, lr}
   15396:	b088      	sub	sp, #32
   15398:	e00c      	b.n	153b4 <vital_app_application+0x20>
                k_timer_start( &app_adc_sample_timer , time_to_next_sample , time_to_next_sample );
   1539a:	4b56      	ldr	r3, [pc, #344]	; (154f4 <vital_app_application+0x160>)
   1539c:	e9d3 2300 	ldrd	r2, r3, [r3]
	z_impl_k_timer_start(timer, duration, period);
   153a0:	e9cd 2300 	strd	r2, r3, [sp]
   153a4:	4854      	ldr	r0, [pc, #336]	; (154f8 <vital_app_application+0x164>)
   153a6:	f014 fa07 	bl	297b8 <z_impl_k_timer_start>
                app_update_state(VITAL_APP_IDLE);
   153aa:	2003      	movs	r0, #3
   153ac:	f7ff ff1a 	bl	151e4 <app_update_state>
                bsp_resume_sampling();
   153b0:	f7fd fcdc 	bl	12d6c <bsp_resume_sampling>
        switch (app_state)
   153b4:	4b51      	ldr	r3, [pc, #324]	; (154fc <vital_app_application+0x168>)
   153b6:	781b      	ldrb	r3, [r3, #0]
   153b8:	2b03      	cmp	r3, #3
   153ba:	f200 8094 	bhi.w	154e6 <vital_app_application+0x152>
   153be:	a201      	add	r2, pc, #4	; (adr r2, 153c4 <vital_app_application+0x30>)
   153c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   153c4:	0001539b 	.word	0x0001539b
   153c8:	000153d5 	.word	0x000153d5
   153cc:	00015469 	.word	0x00015469
   153d0:	000154b1 	.word	0x000154b1
                err = vital_app_running_task();
   153d4:	f7ff ff7e 	bl	152d4 <vital_app_running_task>
                if( ZEPHYR_ERR_SUCCESS == err )
   153d8:	2800      	cmp	r0, #0
   153da:	d13f      	bne.n	1545c <vital_app_application+0xc8>
                           ((float)app_data.vitals.temperature) / 10.0f , app_data.vitals.heart_rate , app_data.vitals.acceleration,
   153dc:	4b48      	ldr	r3, [pc, #288]	; (15500 <vital_app_application+0x16c>)
   153de:	edd3 7a03 	vldr	s15, [r3, #12]
   153e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   153e6:	7d1e      	ldrb	r6, [r3, #20]
   153e8:	691f      	ldr	r7, [r3, #16]
                           app_data.vitals.respiration , app_data.battery.health , app_data.battery.rsoc);
   153ea:	f893 801e 	ldrb.w	r8, [r3, #30]
   153ee:	f893 9009 	ldrb.w	r9, [r3, #9]
   153f2:	f893 a008 	ldrb.w	sl, [r3, #8]
                    printk("Vitals status:\n"
   153f6:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
   153fa:	eec7 7a87 	vdiv.f32	s15, s15, s14
   153fe:	ee17 0a90 	vmov	r0, s15
   15402:	f7ea ffd1 	bl	3a8 <__aeabi_f2d>
   15406:	4604      	mov	r4, r0
   15408:	460d      	mov	r5, r1
   1540a:	f8cd a018 	str.w	sl, [sp, #24]
   1540e:	f8cd 9014 	str.w	r9, [sp, #20]
   15412:	f8cd 8010 	str.w	r8, [sp, #16]
   15416:	4638      	mov	r0, r7
   15418:	f7ea ffc6 	bl	3a8 <__aeabi_f2d>
   1541c:	e9cd 0102 	strd	r0, r1, [sp, #8]
   15420:	9600      	str	r6, [sp, #0]
   15422:	4622      	mov	r2, r4
   15424:	462b      	mov	r3, r5
   15426:	4837      	ldr	r0, [pc, #220]	; (15504 <vital_app_application+0x170>)
   15428:	f016 fdde 	bl	2bfe8 <printk>
                    if(true == vital_app_event_is_set(VITAL_APP_EVENTS_CLIENT_SUBSCRIBED,K_NO_WAIT) &&
   1542c:	2200      	movs	r2, #0
   1542e:	2300      	movs	r3, #0
   15430:	2008      	movs	r0, #8
   15432:	f7ff ff9d 	bl	15370 <vital_app_event_is_set>
   15436:	b128      	cbz	r0, 15444 <vital_app_application+0xb0>
                      (true == vital_app_event_is_set(VITAL_APP_EVENTS_BLE_CONNECTED,K_NO_WAIT)))
   15438:	2200      	movs	r2, #0
   1543a:	2300      	movs	r3, #0
   1543c:	2002      	movs	r0, #2
   1543e:	f7ff ff97 	bl	15370 <vital_app_event_is_set>
                    if(true == vital_app_event_is_set(VITAL_APP_EVENTS_CLIENT_SUBSCRIBED,K_NO_WAIT) &&
   15442:	b938      	cbnz	r0, 15454 <vital_app_application+0xc0>
                        vital_gatt_add_to_queue( app_data.vitals );
   15444:	4b2e      	ldr	r3, [pc, #184]	; (15500 <vital_app_application+0x16c>)
   15446:	69da      	ldr	r2, [r3, #28]
   15448:	9200      	str	r2, [sp, #0]
   1544a:	330c      	adds	r3, #12
   1544c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   1544e:	f000 fa33 	bl	158b8 <vital_gatt_add_to_queue>
   15452:	e7af      	b.n	153b4 <vital_app_application+0x20>
                        app_update_state(VITAL_APP_TRANSMITTING);
   15454:	2002      	movs	r0, #2
   15456:	f7ff fec5 	bl	151e4 <app_update_state>
   1545a:	e7ab      	b.n	153b4 <vital_app_application+0x20>
                    bsp_pause_sampling();
   1545c:	f7fd fc60 	bl	12d20 <bsp_pause_sampling>
                    app_update_state(VITAL_APP_IDLE);
   15460:	2003      	movs	r0, #3
   15462:	f7ff febf 	bl	151e4 <app_update_state>
   15466:	e7a5      	b.n	153b4 <vital_app_application+0x20>
                if((true == vital_app_event_is_set(VITAL_APP_EVENTS_BLE_CONNECTED,K_NO_WAIT)) &&
   15468:	2200      	movs	r2, #0
   1546a:	2300      	movs	r3, #0
   1546c:	2002      	movs	r0, #2
   1546e:	f7ff ff7f 	bl	15370 <vital_app_event_is_set>
   15472:	b128      	cbz	r0, 15480 <vital_app_application+0xec>
                   (true == vital_app_event_is_set(VITAL_APP_EVENTS_DATA_WAITING,K_NO_WAIT)))
   15474:	2200      	movs	r2, #0
   15476:	2300      	movs	r3, #0
   15478:	2004      	movs	r0, #4
   1547a:	f7ff ff79 	bl	15370 <vital_app_event_is_set>
                if((true == vital_app_event_is_set(VITAL_APP_EVENTS_BLE_CONNECTED,K_NO_WAIT)) &&
   1547e:	b918      	cbnz	r0, 15488 <vital_app_application+0xf4>
                    app_update_state(VITAL_APP_IDLE);
   15480:	2003      	movs	r0, #3
   15482:	f7ff feaf 	bl	151e4 <app_update_state>
            break;
   15486:	e795      	b.n	153b4 <vital_app_application+0x20>
                    err = vital_app_transmitting_task();
   15488:	f016 fd15 	bl	2beb6 <vital_app_transmitting_task>
                    if( (ZEPHYR_ERR_SUCCESS == err) )
   1548c:	b140      	cbz	r0, 154a0 <vital_app_application+0x10c>
                        if( -ENODATA == err )
   1548e:	f110 0f3d 	cmn.w	r0, #61	; 0x3d
   15492:	d009      	beq.n	154a8 <vital_app_application+0x114>
	return z_impl_k_sleep(timeout);
   15494:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   15498:	2100      	movs	r1, #0
   1549a:	f013 fc5f 	bl	28d5c <z_impl_k_sleep>
   1549e:	e789      	b.n	153b4 <vital_app_application+0x20>
                        app_update_state(VITAL_APP_RUNNING);
   154a0:	2001      	movs	r0, #1
   154a2:	f7ff fe9f 	bl	151e4 <app_update_state>
   154a6:	e785      	b.n	153b4 <vital_app_application+0x20>
                            app_update_state(VITAL_APP_RUNNING);
   154a8:	2001      	movs	r0, #1
   154aa:	f7ff fe9b 	bl	151e4 <app_update_state>
   154ae:	e781      	b.n	153b4 <vital_app_application+0x20>
	return z_impl_k_event_wait(event, events, reset, timeout);
   154b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   154b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   154b8:	e9cd 2300 	strd	r2, r3, [sp]
   154bc:	2200      	movs	r2, #0
   154be:	2109      	movs	r1, #9
   154c0:	4811      	ldr	r0, [pc, #68]	; (15508 <vital_app_application+0x174>)
   154c2:	f01b fc47 	bl	30d54 <z_impl_k_event_wait>
   154c6:	4604      	mov	r4, r0
                if( false != (event_flags & ( VITAL_APP_EVENTS_DATA_WAITING | VITAL_APP_EVENTS_CLIENT_SUBSCRIBED ) ) )
   154c8:	f010 0f0c 	tst.w	r0, #12
   154cc:	d107      	bne.n	154de <vital_app_application+0x14a>
                if( false != (event_flags & VITAL_APP_EVENTS_WORK_TO_DO) )
   154ce:	f014 0f01 	tst.w	r4, #1
   154d2:	f43f af6f 	beq.w	153b4 <vital_app_application+0x20>
                    app_update_state(VITAL_APP_RUNNING);
   154d6:	2001      	movs	r0, #1
   154d8:	f7ff fe84 	bl	151e4 <app_update_state>
   154dc:	e76a      	b.n	153b4 <vital_app_application+0x20>
                    app_update_state(VITAL_APP_TRANSMITTING);
   154de:	2002      	movs	r0, #2
   154e0:	f7ff fe80 	bl	151e4 <app_update_state>
   154e4:	e7f3      	b.n	154ce <vital_app_application+0x13a>
                printk("APP: ERROR: Entered unknown state\n");
   154e6:	4809      	ldr	r0, [pc, #36]	; (1550c <vital_app_application+0x178>)
   154e8:	f016 fd7e 	bl	2bfe8 <printk>
                app_state = VITAL_APP_INIT;
   154ec:	4b03      	ldr	r3, [pc, #12]	; (154fc <vital_app_application+0x168>)
   154ee:	2200      	movs	r2, #0
   154f0:	701a      	strb	r2, [r3, #0]
        switch (app_state)
   154f2:	e75f      	b.n	153b4 <vital_app_application+0x20>
   154f4:	20002080 	.word	0x20002080
   154f8:	20001f78 	.word	0x20001f78
   154fc:	2000470c 	.word	0x2000470c
   15500:	20003988 	.word	0x20003988
   15504:	00038d1c 	.word	0x00038d1c
   15508:	200039a8 	.word	0x200039a8
   1550c:	00038dbc 	.word	0x00038dbc

00015510 <vital_app_set_new_adc_period>:
{
   15510:	b530      	push	{r4, r5, lr}
   15512:	b085      	sub	sp, #20
   15514:	4605      	mov	r5, r0
   15516:	460c      	mov	r4, r1
	z_impl_k_timer_start(timer, duration, period);
   15518:	9000      	str	r0, [sp, #0]
   1551a:	9101      	str	r1, [sp, #4]
   1551c:	4602      	mov	r2, r0
   1551e:	460b      	mov	r3, r1
   15520:	4806      	ldr	r0, [pc, #24]	; (1553c <vital_app_set_new_adc_period+0x2c>)
   15522:	f014 f949 	bl	297b8 <z_impl_k_timer_start>
    memcpy( &time_to_next_sample , &refresh_time , sizeof(k_timeout_t) );
   15526:	4b06      	ldr	r3, [pc, #24]	; (15540 <vital_app_set_new_adc_period+0x30>)
   15528:	9502      	str	r5, [sp, #8]
   1552a:	9403      	str	r4, [sp, #12]
   1552c:	aa04      	add	r2, sp, #16
   1552e:	e912 0003 	ldmdb	r2, {r0, r1}
   15532:	e883 0003 	stmia.w	r3, {r0, r1}
}
   15536:	b005      	add	sp, #20
   15538:	bd30      	pop	{r4, r5, pc}
   1553a:	bf00      	nop
   1553c:	20001f78 	.word	0x20001f78
   15540:	20002080 	.word	0x20002080

00015544 <vital_app_update_vital>:
    switch (vital)
   15544:	2803      	cmp	r0, #3
   15546:	d812      	bhi.n	1556e <vital_app_update_vital+0x2a>
   15548:	e8df f000 	tbb	[pc, r0]
   1554c:	0e0a0602 	.word	0x0e0a0602
            memcpy( &app_data.vitals.temperature , value , sizeof(float) );
   15550:	680a      	ldr	r2, [r1, #0]
   15552:	4b07      	ldr	r3, [pc, #28]	; (15570 <vital_app_update_vital+0x2c>)
   15554:	60da      	str	r2, [r3, #12]
        break;
   15556:	4770      	bx	lr
            app_data.vitals.respiration = (uint8_t) val;
   15558:	780a      	ldrb	r2, [r1, #0]
   1555a:	4b05      	ldr	r3, [pc, #20]	; (15570 <vital_app_update_vital+0x2c>)
   1555c:	779a      	strb	r2, [r3, #30]
        break;
   1555e:	4770      	bx	lr
            app_data.vitals.heart_rate = (uint8_t) val;
   15560:	780a      	ldrb	r2, [r1, #0]
   15562:	4b03      	ldr	r3, [pc, #12]	; (15570 <vital_app_update_vital+0x2c>)
   15564:	751a      	strb	r2, [r3, #20]
        break;
   15566:	4770      	bx	lr
            memcpy( &app_data.vitals.acceleration , value , sizeof(float) );
   15568:	680a      	ldr	r2, [r1, #0]
   1556a:	4b01      	ldr	r3, [pc, #4]	; (15570 <vital_app_update_vital+0x2c>)
   1556c:	611a      	str	r2, [r3, #16]
}
   1556e:	4770      	bx	lr
   15570:	20003988 	.word	0x20003988

00015574 <connectable_adv_start>:
}

/***************************** - Private Functions - *******************************/

static void connectable_adv_start(void)
{
   15574:	b500      	push	{lr}
   15576:	b083      	sub	sp, #12

    zephyr_err_t err;
    err = bt_le_adv_start(advertising_parameters, advertising_data, ARRAY_SIZE(advertising_data), NULL, 0);
   15578:	2300      	movs	r3, #0
   1557a:	9300      	str	r3, [sp, #0]
   1557c:	2202      	movs	r2, #2
   1557e:	4906      	ldr	r1, [pc, #24]	; (15598 <connectable_adv_start+0x24>)
   15580:	4806      	ldr	r0, [pc, #24]	; (1559c <connectable_adv_start+0x28>)
   15582:	f005 fe39 	bl	1b1f8 <bt_le_adv_start>

    if ( ZEPHYR_ERR_SUCCESS == err)
   15586:	b110      	cbz	r0, 1558e <connectable_adv_start+0x1a>
    {
        printk("Failed to start connectable advertising (err %d)\n", err);
    }

}
   15588:	b003      	add	sp, #12
   1558a:	f85d fb04 	ldr.w	pc, [sp], #4
   1558e:	4601      	mov	r1, r0
        printk("Failed to start connectable advertising (err %d)\n", err);
   15590:	4803      	ldr	r0, [pc, #12]	; (155a0 <connectable_adv_start+0x2c>)
   15592:	f016 fd29 	bl	2bfe8 <printk>
}
   15596:	e7f7      	b.n	15588 <connectable_adv_start+0x14>
   15598:	00038ee8 	.word	0x00038ee8
   1559c:	200008bc 	.word	0x200008bc
   155a0:	00038e08 	.word	0x00038e08

000155a4 <connected>:
{
    connectable_adv_start();
}

static void connected(zephyr_bt_conn_t *conn, uint8_t err)
{
   155a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   155a6:	b093      	sub	sp, #76	; 0x4c
    char addr[BT_ADDR_LE_STR_LEN];

    if ( ZEPHYR_ERR_SUCCESS == err )
   155a8:	2900      	cmp	r1, #0
   155aa:	d151      	bne.n	15650 <connected+0xac>
   155ac:	4605      	mov	r5, r0
    {
        bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   155ae:	f017 fe76 	bl	2d29e <bt_conn_get_dst>
   155b2:	4604      	mov	r4, r0
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
   155b4:	7803      	ldrb	r3, [r0, #0]
   155b6:	2b03      	cmp	r3, #3
   155b8:	d844      	bhi.n	15644 <connected+0xa0>
   155ba:	e8df f003 	tbb	[pc, r3]
   155be:	2d02      	.short	0x2d02
   155c0:	3d37      	.short	0x3d37
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
   155c2:	4b25      	ldr	r3, [pc, #148]	; (15658 <connected+0xb4>)
   155c4:	e893 0003 	ldmia.w	r3, {r0, r1}
   155c8:	9007      	str	r0, [sp, #28]
   155ca:	f8ad 1020 	strh.w	r1, [sp, #32]
   155ce:	0c09      	lsrs	r1, r1, #16
   155d0:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
   155d4:	79a3      	ldrb	r3, [r4, #6]
   155d6:	7962      	ldrb	r2, [r4, #5]
   155d8:	7921      	ldrb	r1, [r4, #4]
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
   155da:	78e0      	ldrb	r0, [r4, #3]
   155dc:	78a6      	ldrb	r6, [r4, #2]
   155de:	7864      	ldrb	r4, [r4, #1]
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
   155e0:	af07      	add	r7, sp, #28
   155e2:	9705      	str	r7, [sp, #20]
   155e4:	9404      	str	r4, [sp, #16]
   155e6:	9603      	str	r6, [sp, #12]
   155e8:	9002      	str	r0, [sp, #8]
   155ea:	9101      	str	r1, [sp, #4]
   155ec:	9200      	str	r2, [sp, #0]
   155ee:	4a1b      	ldr	r2, [pc, #108]	; (1565c <connected+0xb8>)
   155f0:	211e      	movs	r1, #30
   155f2:	a80a      	add	r0, sp, #40	; 0x28
   155f4:	f016 fd06 	bl	2c004 <snprintk>

        printk("Connected %s\n", addr);
   155f8:	a90a      	add	r1, sp, #40	; 0x28
   155fa:	4819      	ldr	r0, [pc, #100]	; (15660 <connected+0xbc>)
   155fc:	f016 fcf4 	bl	2bfe8 <printk>

        vital_app_flag_event(VITAL_APP_EVENTS_BLE_CONNECTED);
   15600:	2002      	movs	r0, #2
   15602:	f7ff fe55 	bl	152b0 <vital_app_flag_event>

        printk("Max MTU: %u\n" ,  bt_gatt_get_mtu(conn) );
   15606:	4628      	mov	r0, r5
   15608:	f019 fae2 	bl	2ebd0 <bt_gatt_get_mtu>
   1560c:	4601      	mov	r1, r0
   1560e:	4815      	ldr	r0, [pc, #84]	; (15664 <connected+0xc0>)
   15610:	f016 fcea 	bl	2bfe8 <printk>
    }
    else
    {
        printk("Connection Failed, %d\n" , err );
    }
}
   15614:	b013      	add	sp, #76	; 0x4c
   15616:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strcpy(type, "random");
   15618:	4b13      	ldr	r3, [pc, #76]	; (15668 <connected+0xc4>)
   1561a:	e893 0003 	ldmia.w	r3, {r0, r1}
   1561e:	9007      	str	r0, [sp, #28]
   15620:	f8ad 1020 	strh.w	r1, [sp, #32]
   15624:	0c09      	lsrs	r1, r1, #16
   15626:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
		break;
   1562a:	e7d3      	b.n	155d4 <connected+0x30>
		strcpy(type, "public-id");
   1562c:	4a0f      	ldr	r2, [pc, #60]	; (1566c <connected+0xc8>)
   1562e:	ab07      	add	r3, sp, #28
   15630:	ca07      	ldmia	r2, {r0, r1, r2}
   15632:	c303      	stmia	r3!, {r0, r1}
   15634:	801a      	strh	r2, [r3, #0]
		break;
   15636:	e7cd      	b.n	155d4 <connected+0x30>
		strcpy(type, "random-id");
   15638:	4a0d      	ldr	r2, [pc, #52]	; (15670 <connected+0xcc>)
   1563a:	ab07      	add	r3, sp, #28
   1563c:	ca07      	ldmia	r2, {r0, r1, r2}
   1563e:	c303      	stmia	r3!, {r0, r1}
   15640:	801a      	strh	r2, [r3, #0]
		break;
   15642:	e7c7      	b.n	155d4 <connected+0x30>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
   15644:	4a0b      	ldr	r2, [pc, #44]	; (15674 <connected+0xd0>)
   15646:	210a      	movs	r1, #10
   15648:	a807      	add	r0, sp, #28
   1564a:	f016 fcdb 	bl	2c004 <snprintk>
		break;
   1564e:	e7c1      	b.n	155d4 <connected+0x30>
        printk("Connection Failed, %d\n" , err );
   15650:	4809      	ldr	r0, [pc, #36]	; (15678 <connected+0xd4>)
   15652:	f016 fcc9 	bl	2bfe8 <printk>
}
   15656:	e7dd      	b.n	15614 <connected+0x70>
   15658:	00038e3c 	.word	0x00038e3c
   1565c:	00038e54 	.word	0x00038e54
   15660:	00038e78 	.word	0x00038e78
   15664:	00038e88 	.word	0x00038e88
   15668:	00038e44 	.word	0x00038e44
   1566c:	00038eb0 	.word	0x00038eb0
   15670:	00038ebc 	.word	0x00038ebc
   15674:	00038e4c 	.word	0x00038e4c
   15678:	00038e98 	.word	0x00038e98

0001567c <disconnected>:

static void disconnected(zephyr_bt_conn_t *conn, uint8_t reason)
{
   1567c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1567e:	b093      	sub	sp, #76	; 0x4c
   15680:	460d      	mov	r5, r1
    char addr[BT_ADDR_LE_STR_LEN];

    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
   15682:	f017 fe0c 	bl	2d29e <bt_conn_get_dst>
   15686:	4604      	mov	r4, r0
	switch (addr->type) {
   15688:	7803      	ldrb	r3, [r0, #0]
   1568a:	2b03      	cmp	r3, #3
   1568c:	d841      	bhi.n	15712 <disconnected+0x96>
   1568e:	e8df f003 	tbb	[pc, r3]
   15692:	2a02      	.short	0x2a02
   15694:	3a34      	.short	0x3a34
		strcpy(type, "public");
   15696:	4b22      	ldr	r3, [pc, #136]	; (15720 <disconnected+0xa4>)
   15698:	e893 0003 	ldmia.w	r3, {r0, r1}
   1569c:	9007      	str	r0, [sp, #28]
   1569e:	f8ad 1020 	strh.w	r1, [sp, #32]
   156a2:	0c09      	lsrs	r1, r1, #16
   156a4:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
   156a8:	79a3      	ldrb	r3, [r4, #6]
   156aa:	7962      	ldrb	r2, [r4, #5]
   156ac:	7921      	ldrb	r1, [r4, #4]
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
   156ae:	78e0      	ldrb	r0, [r4, #3]
   156b0:	78a6      	ldrb	r6, [r4, #2]
   156b2:	7864      	ldrb	r4, [r4, #1]
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
   156b4:	af07      	add	r7, sp, #28
   156b6:	9705      	str	r7, [sp, #20]
   156b8:	9404      	str	r4, [sp, #16]
   156ba:	9603      	str	r6, [sp, #12]
   156bc:	9002      	str	r0, [sp, #8]
   156be:	9101      	str	r1, [sp, #4]
   156c0:	9200      	str	r2, [sp, #0]
   156c2:	4a18      	ldr	r2, [pc, #96]	; (15724 <disconnected+0xa8>)
   156c4:	211e      	movs	r1, #30
   156c6:	a80a      	add	r0, sp, #40	; 0x28
   156c8:	f016 fc9c 	bl	2c004 <snprintk>

    printk("Disconnected: %s (reason %u)\n", addr, reason);
   156cc:	462a      	mov	r2, r5
   156ce:	a90a      	add	r1, sp, #40	; 0x28
   156d0:	4815      	ldr	r0, [pc, #84]	; (15728 <disconnected+0xac>)
   156d2:	f016 fc89 	bl	2bfe8 <printk>

    vital_app_clear_event( VITAL_APP_EVENTS_BLE_CONNECTED );
   156d6:	2002      	movs	r0, #2
   156d8:	f7ff fdf2 	bl	152c0 <vital_app_clear_event>

    /* Process the disconnect logic in the workqueue so that
     * the BLE stack is finished with the connection bookkeeping
     * logic and advertising is possible.
     */
    k_work_submit(&advertising_work);
   156dc:	4813      	ldr	r0, [pc, #76]	; (1572c <disconnected+0xb0>)
   156de:	f011 ffbd 	bl	2765c <k_work_submit>
}
   156e2:	b013      	add	sp, #76	; 0x4c
   156e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strcpy(type, "random");
   156e6:	4b12      	ldr	r3, [pc, #72]	; (15730 <disconnected+0xb4>)
   156e8:	e893 0003 	ldmia.w	r3, {r0, r1}
   156ec:	9007      	str	r0, [sp, #28]
   156ee:	f8ad 1020 	strh.w	r1, [sp, #32]
   156f2:	0c09      	lsrs	r1, r1, #16
   156f4:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
		break;
   156f8:	e7d6      	b.n	156a8 <disconnected+0x2c>
		strcpy(type, "public-id");
   156fa:	4a0e      	ldr	r2, [pc, #56]	; (15734 <disconnected+0xb8>)
   156fc:	ab07      	add	r3, sp, #28
   156fe:	ca07      	ldmia	r2, {r0, r1, r2}
   15700:	c303      	stmia	r3!, {r0, r1}
   15702:	801a      	strh	r2, [r3, #0]
		break;
   15704:	e7d0      	b.n	156a8 <disconnected+0x2c>
		strcpy(type, "random-id");
   15706:	4a0c      	ldr	r2, [pc, #48]	; (15738 <disconnected+0xbc>)
   15708:	ab07      	add	r3, sp, #28
   1570a:	ca07      	ldmia	r2, {r0, r1, r2}
   1570c:	c303      	stmia	r3!, {r0, r1}
   1570e:	801a      	strh	r2, [r3, #0]
		break;
   15710:	e7ca      	b.n	156a8 <disconnected+0x2c>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
   15712:	4a0a      	ldr	r2, [pc, #40]	; (1573c <disconnected+0xc0>)
   15714:	210a      	movs	r1, #10
   15716:	a807      	add	r0, sp, #28
   15718:	f016 fc74 	bl	2c004 <snprintk>
		break;
   1571c:	e7c4      	b.n	156a8 <disconnected+0x2c>
   1571e:	bf00      	nop
   15720:	00038e3c 	.word	0x00038e3c
   15724:	00038e54 	.word	0x00038e54
   15728:	00038ec8 	.word	0x00038ec8
   1572c:	200008d8 	.word	0x200008d8
   15730:	00038e44 	.word	0x00038e44
   15734:	00038eb0 	.word	0x00038eb0
   15738:	00038ebc 	.word	0x00038ebc
   1573c:	00038e4c 	.word	0x00038e4c

00015740 <vital_gatt_ccc_changed_func>:
}



static void vital_gatt_ccc_changed_func(const struct bt_gatt_attr *attr, uint16_t value)
{
   15740:	b508      	push	{r3, lr}
    ARG_UNUSED(attr);
    notify_enabled = (value == BT_GATT_CCC_NOTIFY);
   15742:	2901      	cmp	r1, #1
   15744:	bf14      	ite	ne
   15746:	2100      	movne	r1, #0
   15748:	2101      	moveq	r1, #1
   1574a:	4b0a      	ldr	r3, [pc, #40]	; (15774 <vital_gatt_ccc_changed_func+0x34>)
   1574c:	7019      	strb	r1, [r3, #0]
    printk("Notification %s\n", notify_enabled ? "enabled" : "disabled");
   1574e:	781b      	ldrb	r3, [r3, #0]
   15750:	b153      	cbz	r3, 15768 <vital_gatt_ccc_changed_func+0x28>
   15752:	4909      	ldr	r1, [pc, #36]	; (15778 <vital_gatt_ccc_changed_func+0x38>)
   15754:	4809      	ldr	r0, [pc, #36]	; (1577c <vital_gatt_ccc_changed_func+0x3c>)
   15756:	f016 fc47 	bl	2bfe8 <printk>

    if( true == notify_enabled )
   1575a:	4b06      	ldr	r3, [pc, #24]	; (15774 <vital_gatt_ccc_changed_func+0x34>)
   1575c:	781b      	ldrb	r3, [r3, #0]
   1575e:	b12b      	cbz	r3, 1576c <vital_gatt_ccc_changed_func+0x2c>
    {
        vital_app_flag_event(VITAL_APP_EVENTS_CLIENT_SUBSCRIBED);
   15760:	2008      	movs	r0, #8
   15762:	f7ff fda5 	bl	152b0 <vital_app_flag_event>
    else
    {
        vital_app_clear_event(VITAL_APP_EVENTS_CLIENT_SUBSCRIBED);
    }

}
   15766:	bd08      	pop	{r3, pc}
    printk("Notification %s\n", notify_enabled ? "enabled" : "disabled");
   15768:	4905      	ldr	r1, [pc, #20]	; (15780 <vital_gatt_ccc_changed_func+0x40>)
   1576a:	e7f3      	b.n	15754 <vital_gatt_ccc_changed_func+0x14>
        vital_app_clear_event(VITAL_APP_EVENTS_CLIENT_SUBSCRIBED);
   1576c:	2008      	movs	r0, #8
   1576e:	f7ff fda7 	bl	152c0 <vital_app_clear_event>
}
   15772:	e7f8      	b.n	15766 <vital_gatt_ccc_changed_func+0x26>
   15774:	2000470d 	.word	0x2000470d
   15778:	00038f04 	.word	0x00038f04
   1577c:	00038f0c 	.word	0x00038f0c
   15780:	00038ef8 	.word	0x00038ef8

00015784 <vital_gatt_write_callback>:

static ssize_t vital_gatt_write_callback(struct bt_conn *conn , const struct bt_gatt_attr *attr,
                    const void *buf , uint16_t len, uint16_t offset, uint8_t flags)
{
   15784:	b500      	push	{lr}
   15786:	b085      	sub	sp, #20
   15788:	4611      	mov	r1, r2

    vital_gatt_rx_config_t config = vital_gatt_parse_rx( (uint8_t*) buf , len);
   1578a:	461a      	mov	r2, r3
   1578c:	a801      	add	r0, sp, #4
   1578e:	f016 fba5 	bl	2bedc <vital_gatt_parse_rx>
    uint16_t rx_as_two_bytes;

    printk("Received config cmd: %x\n" , config.config_id );
   15792:	f8bd 1004 	ldrh.w	r1, [sp, #4]
   15796:	481a      	ldr	r0, [pc, #104]	; (15800 <vital_gatt_write_callback+0x7c>)
   15798:	f016 fc26 	bl	2bfe8 <printk>

    switch (config.config_id)
   1579c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   157a0:	2b02      	cmp	r3, #2
   157a2:	d01d      	beq.n	157e0 <vital_gatt_write_callback+0x5c>
   157a4:	2bff      	cmp	r3, #255	; 0xff
   157a6:	d022      	beq.n	157ee <vital_gatt_write_callback+0x6a>
   157a8:	2b01      	cmp	r3, #1
   157aa:	d003      	beq.n	157b4 <vital_gatt_write_callback+0x30>
        default:
        break;
    }

    return 0;
}
   157ac:	2000      	movs	r0, #0
   157ae:	b005      	add	sp, #20
   157b0:	f85d fb04 	ldr.w	pc, [sp], #4
            rx_as_two_bytes = ((uint16_t*)config.data)[0];
   157b4:	f8bd 0006 	ldrh.w	r0, [sp, #6]
            vital_app_set_new_adc_period( K_SECONDS(rx_as_two_bytes) );
   157b8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   157bc:	fb03 f000 	mul.w	r0, r3, r0
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
   157c0:	0c41      	lsrs	r1, r0, #17
   157c2:	03c0      	lsls	r0, r0, #15
   157c4:	f240 33e7 	movw	r3, #999	; 0x3e7
   157c8:	18c0      	adds	r0, r0, r3
   157ca:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   157ce:	f04f 0300 	mov.w	r3, #0
   157d2:	f141 0100 	adc.w	r1, r1, #0
   157d6:	f7eb f9ff 	bl	bd8 <__aeabi_uldivmod>
   157da:	f7ff fe99 	bl	15510 <vital_app_set_new_adc_period>
        break;
   157de:	e7e5      	b.n	157ac <vital_gatt_write_callback+0x28>
            vital_app_update_vital( config.data[0] , config.data + 1 );
   157e0:	f10d 0107 	add.w	r1, sp, #7
   157e4:	f89d 0006 	ldrb.w	r0, [sp, #6]
   157e8:	f7ff feac 	bl	15544 <vital_app_update_vital>
        break;
   157ec:	e7de      	b.n	157ac <vital_gatt_write_callback+0x28>
            rx_as_two_bytes = ((uint16_t*)config.data)[0];
   157ee:	f8bd 3006 	ldrh.w	r3, [sp, #6]
            k_event_post( &gatt_events , BIT(rx_as_two_bytes) );
   157f2:	2101      	movs	r1, #1
   157f4:	4099      	lsls	r1, r3
	z_impl_k_event_post(event, events);
   157f6:	4803      	ldr	r0, [pc, #12]	; (15804 <vital_gatt_write_callback+0x80>)
   157f8:	f01b fa9d 	bl	30d36 <z_impl_k_event_post>
}
   157fc:	e7d6      	b.n	157ac <vital_gatt_write_callback+0x28>
   157fe:	bf00      	nop
   15800:	00038f20 	.word	0x00038f20
   15804:	200039bc 	.word	0x200039bc

00015808 <vital_gatt_notify>:
{
   15808:	b570      	push	{r4, r5, r6, lr}
   1580a:	b088      	sub	sp, #32
   1580c:	4605      	mov	r5, r0
    zephyr_err_t err = bt_gatt_notify_uuid(NULL ,&vital_read_service[vital_to_update].uuid_16.uuid ,
   1580e:	4c25      	ldr	r4, [pc, #148]	; (158a4 <vital_gatt_notify+0x9c>)
   15810:	f04f 0c54 	mov.w	ip, #84	; 0x54
   15814:	fb0c fc00 	mul.w	ip, ip, r0
   15818:	f10c 0348 	add.w	r3, ip, #72	; 0x48
   1581c:	4423      	add	r3, r4
   1581e:	3304      	adds	r3, #4
                              &vital_read_service[vital_to_update].data.data_ptr[bytes_sent],
   15820:	4464      	add	r4, ip
   15822:	6c60      	ldr	r0, [r4, #68]	; 0x44
   15824:	4401      	add	r1, r0
				      const struct bt_gatt_attr *attr,
				      const void *data, uint16_t len)
{
	struct bt_gatt_notify_params params;

	memset(&params, 0, sizeof(params));
   15826:	2000      	movs	r0, #0
   15828:	9002      	str	r0, [sp, #8]
   1582a:	9003      	str	r0, [sp, #12]
   1582c:	9004      	str	r0, [sp, #16]
   1582e:	9005      	str	r0, [sp, #20]
   15830:	9006      	str	r0, [sp, #24]
   15832:	9007      	str	r0, [sp, #28]

	params.uuid = uuid;
   15834:	9302      	str	r3, [sp, #8]
	params.attr = attr;
   15836:	4b1c      	ldr	r3, [pc, #112]	; (158a8 <vital_gatt_notify+0xa0>)
   15838:	9303      	str	r3, [sp, #12]
	params.data = data;
   1583a:	9104      	str	r1, [sp, #16]
	params.len = len;
   1583c:	f8ad 2014 	strh.w	r2, [sp, #20]
#if defined(CONFIG_BT_EATT)
	params.chan_opt = BT_ATT_CHAN_OPT_NONE;
#endif /* CONFIG_BT_EATT */

	return bt_gatt_notify_cb(conn, &params);
   15840:	a902      	add	r1, sp, #8
   15842:	f008 fe05 	bl	1e450 <bt_gatt_notify_cb>
    if( ZEPHYR_ERR_SUCCESS == err )
   15846:	4604      	mov	r4, r0
   15848:	b110      	cbz	r0, 15850 <vital_gatt_notify+0x48>
}
   1584a:	4620      	mov	r0, r4
   1584c:	b008      	add	sp, #32
   1584e:	bd70      	pop	{r4, r5, r6, pc}
        printk("Submitting, waiting for acknowledgement on %d\n" , vital_to_update);
   15850:	4629      	mov	r1, r5
   15852:	4816      	ldr	r0, [pc, #88]	; (158ac <vital_gatt_notify+0xa4>)
   15854:	f016 fbc8 	bl	2bfe8 <printk>
        ret_val = k_event_wait( &gatt_events , BIT(vital_to_update) , false , K_SECONDS(10) );
   15858:	2601      	movs	r6, #1
   1585a:	40ae      	lsls	r6, r5
	return z_impl_k_event_wait(event, events, reset, timeout);
   1585c:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
   15860:	2300      	movs	r3, #0
   15862:	e9cd 2300 	strd	r2, r3, [sp]
   15866:	2200      	movs	r2, #0
   15868:	4631      	mov	r1, r6
   1586a:	4811      	ldr	r0, [pc, #68]	; (158b0 <vital_gatt_notify+0xa8>)
   1586c:	f01b fa72 	bl	30d54 <z_impl_k_event_wait>
        err = (ret_val == 0) ? -EBADE : ZEPHYR_ERR_SUCCESS ;
   15870:	b910      	cbnz	r0, 15878 <vital_gatt_notify+0x70>
   15872:	f06f 0431 	mvn.w	r4, #49	; 0x31
    return err;
   15876:	e7e8      	b.n	1584a <vital_gatt_notify+0x42>
	z_impl_k_event_set_masked(event, events, events_mask);
   15878:	4632      	mov	r2, r6
   1587a:	2100      	movs	r1, #0
   1587c:	480c      	ldr	r0, [pc, #48]	; (158b0 <vital_gatt_notify+0xa8>)
   1587e:	f01b fa65 	bl	30d4c <z_impl_k_event_set_masked>
            printk("Acknowledged\n");
   15882:	480c      	ldr	r0, [pc, #48]	; (158b4 <vital_gatt_notify+0xac>)
   15884:	f016 fbb0 	bl	2bfe8 <printk>
 *
 * Any value other than 0 makes sense only in validation testing context.
 */
static inline void ring_buf_internal_reset(struct ring_buf *buf, int32_t value)
{
	buf->put_head = buf->put_tail = buf->put_base = value;
   15888:	4806      	ldr	r0, [pc, #24]	; (158a4 <vital_gatt_notify+0x9c>)
   1588a:	2354      	movs	r3, #84	; 0x54
   1588c:	fb03 0505 	mla	r5, r3, r5, r0
   15890:	2300      	movs	r3, #0
   15892:	60eb      	str	r3, [r5, #12]
   15894:	60ab      	str	r3, [r5, #8]
   15896:	606b      	str	r3, [r5, #4]
	buf->get_head = buf->get_tail = buf->get_base = value;
   15898:	61ab      	str	r3, [r5, #24]
   1589a:	616b      	str	r3, [r5, #20]
   1589c:	612b      	str	r3, [r5, #16]
            vital_read_service[vital_to_update].data.len = 0;
   1589e:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
   158a2:	e7d2      	b.n	1584a <vital_gatt_notify+0x42>
   158a4:	200009a0 	.word	0x200009a0
   158a8:	00038f7c 	.word	0x00038f7c
   158ac:	00038f3c 	.word	0x00038f3c
   158b0:	200039bc 	.word	0x200039bc
   158b4:	00038f6c 	.word	0x00038f6c

000158b8 <vital_gatt_add_to_queue>:
{
   158b8:	b084      	sub	sp, #16
   158ba:	b570      	push	{r4, r5, r6, lr}
   158bc:	b086      	sub	sp, #24
   158be:	ac0a      	add	r4, sp, #40	; 0x28
   158c0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    void* vitals_ptrs[] = { &vital_data.temperature , &vital_data.respiration ,
   158c4:	9402      	str	r4, [sp, #8]
   158c6:	f10d 033a 	add.w	r3, sp, #58	; 0x3a
   158ca:	9303      	str	r3, [sp, #12]
                            vital_data.heart_rate_raw , &vital_data.acceleration };
   158cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    void* vitals_ptrs[] = { &vital_data.temperature , &vital_data.respiration ,
   158ce:	9304      	str	r3, [sp, #16]
   158d0:	ab0b      	add	r3, sp, #44	; 0x2c
   158d2:	9305      	str	r3, [sp, #20]
    uint16_t vitals_size[] = { sizeof(int32_t) , sizeof(uint8_t) ,
   158d4:	4a25      	ldr	r2, [pc, #148]	; (1596c <vital_gatt_add_to_queue+0xb4>)
   158d6:	466b      	mov	r3, sp
   158d8:	e892 0003 	ldmia.w	r2, {r0, r1}
   158dc:	e883 0003 	stmia.w	r3, {r0, r1}
    for (uint8_t idx = 0; (idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX) ; idx++ )
   158e0:	2400      	movs	r4, #0
   158e2:	e00f      	b.n	15904 <vital_gatt_add_to_queue+0x4c>
            vital_read_service[idx].data.data_ptr = vitals_ptrs[idx];
   158e4:	ab06      	add	r3, sp, #24
   158e6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   158ea:	f853 2c10 	ldr.w	r2, [r3, #-16]
   158ee:	4b20      	ldr	r3, [pc, #128]	; (15970 <vital_gatt_add_to_queue+0xb8>)
   158f0:	2154      	movs	r1, #84	; 0x54
   158f2:	fb01 3304 	mla	r3, r1, r4, r3
   158f6:	645a      	str	r2, [r3, #68]	; 0x44
            vital_read_service[idx].data.len = vital_data.heart_rate_raw_len;
   158f8:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
   158fc:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
    for (uint8_t idx = 0; (idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX) ; idx++ )
   15900:	3401      	adds	r4, #1
   15902:	b2e4      	uxtb	r4, r4
   15904:	2c03      	cmp	r4, #3
   15906:	d828      	bhi.n	1595a <vital_gatt_add_to_queue+0xa2>
        if (idx != VITALS_VITAL_TYPE_ID_HEART_RATE)
   15908:	2c02      	cmp	r4, #2
   1590a:	d0eb      	beq.n	158e4 <vital_gatt_add_to_queue+0x2c>
            put = ring_buf_put( &vital_read_service[idx].data.ring_buffer, vitals_ptrs[idx] , vitals_size[idx] );
   1590c:	4626      	mov	r6, r4
   1590e:	ab06      	add	r3, sp, #24
   15910:	eb03 0344 	add.w	r3, r3, r4, lsl #1
   15914:	f833 5c18 	ldrh.w	r5, [r3, #-24]
   15918:	462a      	mov	r2, r5
   1591a:	ab06      	add	r3, sp, #24
   1591c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   15920:	f853 1c10 	ldr.w	r1, [r3, #-16]
   15924:	4b12      	ldr	r3, [pc, #72]	; (15970 <vital_gatt_add_to_queue+0xb8>)
   15926:	2054      	movs	r0, #84	; 0x54
   15928:	fb00 3004 	mla	r0, r0, r4, r3
   1592c:	f001 fcd0 	bl	172d0 <ring_buf_put>
            if( put > 0)
   15930:	2800      	cmp	r0, #0
   15932:	d0e5      	beq.n	15900 <vital_gatt_add_to_queue+0x48>
                        (vital_read_service[idx].data.len > vital_read_service[idx].ring_buffer_size) ?
   15934:	4b0e      	ldr	r3, [pc, #56]	; (15970 <vital_gatt_add_to_queue+0xb8>)
   15936:	2254      	movs	r2, #84	; 0x54
   15938:	fb02 3304 	mla	r3, r2, r4, r3
   1593c:	f8b3 1048 	ldrh.w	r1, [r3, #72]	; 0x48
   15940:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
                vital_read_service[idx].data.len =
   15944:	4291      	cmp	r1, r2
   15946:	d801      	bhi.n	1594c <vital_gatt_add_to_queue+0x94>
   15948:	440d      	add	r5, r1
   1594a:	b2aa      	uxth	r2, r5
   1594c:	4b08      	ldr	r3, [pc, #32]	; (15970 <vital_gatt_add_to_queue+0xb8>)
   1594e:	2154      	movs	r1, #84	; 0x54
   15950:	fb01 3606 	mla	r6, r1, r6, r3
   15954:	f8a6 2048 	strh.w	r2, [r6, #72]	; 0x48
   15958:	e7d2      	b.n	15900 <vital_gatt_add_to_queue+0x48>
        vital_app_flag_event(VITAL_APP_EVENTS_DATA_WAITING);
   1595a:	2004      	movs	r0, #4
   1595c:	f7ff fca8 	bl	152b0 <vital_app_flag_event>
}
   15960:	2000      	movs	r0, #0
   15962:	b006      	add	sp, #24
   15964:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   15968:	b004      	add	sp, #16
   1596a:	4770      	bx	lr
   1596c:	000313f4 	.word	0x000313f4
   15970:	200009a0 	.word	0x200009a0

00015974 <vital_gatt_update_reading>:
{
   15974:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15978:	4605      	mov	r5, r0
    zephyr_err_t err = k_mutex_lock( &vital_read_service[vital_to_update].data.lock , K_NO_WAIT );
   1597a:	2754      	movs	r7, #84	; 0x54
   1597c:	fb00 f707 	mul.w	r7, r0, r7
   15980:	f107 0320 	add.w	r3, r7, #32
   15984:	4f2a      	ldr	r7, [pc, #168]	; (15a30 <vital_gatt_update_reading+0xbc>)
   15986:	441f      	add	r7, r3
	return z_impl_k_mutex_lock(mutex, timeout);
   15988:	2200      	movs	r2, #0
   1598a:	2300      	movs	r3, #0
   1598c:	4638      	mov	r0, r7
   1598e:	f011 f81f 	bl	269d0 <z_impl_k_mutex_lock>
    if( ZEPHYR_ERR_SUCCESS == err )
   15992:	4682      	mov	sl, r0
   15994:	2800      	cmp	r0, #0
   15996:	d13e      	bne.n	15a16 <vital_gatt_update_reading+0xa2>
        uint8_t num_whole = vital_read_service[vital_to_update].data.len / VITAL_GATT_TX_AMOUNT;
   15998:	4b25      	ldr	r3, [pc, #148]	; (15a30 <vital_gatt_update_reading+0xbc>)
   1599a:	2254      	movs	r2, #84	; 0x54
   1599c:	fb02 3305 	mla	r3, r2, r5, r3
   159a0:	f8b3 8048 	ldrh.w	r8, [r3, #72]	; 0x48
   159a4:	4e23      	ldr	r6, [pc, #140]	; (15a34 <vital_gatt_update_reading+0xc0>)
   159a6:	fba6 3608 	umull	r3, r6, r6, r8
   159aa:	0933      	lsrs	r3, r6, #4
   159ac:	461e      	mov	r6, r3
        uint8_t num_part = vital_read_service[vital_to_update].data.len % VITAL_GATT_TX_AMOUNT;
   159ae:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   159b2:	eba8 0883 	sub.w	r8, r8, r3, lsl #2
   159b6:	fa1f f988 	uxth.w	r9, r8
   159ba:	fa5f f888 	uxtb.w	r8, r8
        for (uint16_t i = 0; (i <  num_whole) && ( -ENOTCONN != err ); i++)
   159be:	2400      	movs	r4, #0
   159c0:	e00a      	b.n	159d8 <vital_gatt_update_reading+0x64>
            err = vital_gatt_notify( vital_to_update , VITAL_GATT_TX_AMOUNT * i , VITAL_GATT_TX_AMOUNT );
   159c2:	eb04 0184 	add.w	r1, r4, r4, lsl #2
   159c6:	0089      	lsls	r1, r1, #2
   159c8:	b289      	uxth	r1, r1
   159ca:	2214      	movs	r2, #20
   159cc:	4628      	mov	r0, r5
   159ce:	f7ff ff1b 	bl	15808 <vital_gatt_notify>
   159d2:	4682      	mov	sl, r0
        for (uint16_t i = 0; (i <  num_whole) && ( -ENOTCONN != err ); i++)
   159d4:	3401      	adds	r4, #1
   159d6:	b2a4      	uxth	r4, r4
   159d8:	b2f1      	uxtb	r1, r6
   159da:	428c      	cmp	r4, r1
   159dc:	d202      	bcs.n	159e4 <vital_gatt_update_reading+0x70>
   159de:	f11a 0f80 	cmn.w	sl, #128	; 0x80
   159e2:	d1ee      	bne.n	159c2 <vital_gatt_update_reading+0x4e>
        if((num_part > 0) && (err == ZEPHYR_ERR_SUCCESS) )
   159e4:	f1b8 0f00 	cmp.w	r8, #0
   159e8:	d002      	beq.n	159f0 <vital_gatt_update_reading+0x7c>
   159ea:	f1ba 0f00 	cmp.w	sl, #0
   159ee:	d015      	beq.n	15a1c <vital_gatt_update_reading+0xa8>
        if( ZEPHYR_ERR_SUCCESS == err )
   159f0:	f1ba 0f00 	cmp.w	sl, #0
   159f4:	d10c      	bne.n	15a10 <vital_gatt_update_reading+0x9c>
	buf->put_head = buf->put_tail = buf->put_base = value;
   159f6:	4b0e      	ldr	r3, [pc, #56]	; (15a30 <vital_gatt_update_reading+0xbc>)
   159f8:	2254      	movs	r2, #84	; 0x54
   159fa:	fb02 3505 	mla	r5, r2, r5, r3
   159fe:	2300      	movs	r3, #0
   15a00:	60eb      	str	r3, [r5, #12]
   15a02:	60ab      	str	r3, [r5, #8]
   15a04:	606b      	str	r3, [r5, #4]
	buf->get_head = buf->get_tail = buf->get_base = value;
   15a06:	61ab      	str	r3, [r5, #24]
   15a08:	616b      	str	r3, [r5, #20]
   15a0a:	612b      	str	r3, [r5, #16]
            vital_read_service[vital_to_update].data.len = 0;
   15a0c:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
	return z_impl_k_mutex_unlock(mutex);
   15a10:	4638      	mov	r0, r7
   15a12:	f011 f8d3 	bl	26bbc <z_impl_k_mutex_unlock>
}
   15a16:	4650      	mov	r0, sl
   15a18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            err = vital_gatt_notify( vital_to_update , num_whole * VITAL_GATT_TX_AMOUNT , num_part );
   15a1c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
   15a20:	fa5f f289 	uxtb.w	r2, r9
   15a24:	0089      	lsls	r1, r1, #2
   15a26:	4628      	mov	r0, r5
   15a28:	f7ff feee 	bl	15808 <vital_gatt_notify>
   15a2c:	4682      	mov	sl, r0
   15a2e:	e7df      	b.n	159f0 <vital_gatt_update_reading+0x7c>
   15a30:	200009a0 	.word	0x200009a0
   15a34:	cccccccd 	.word	0xcccccccd

00015a38 <sys_notify_finalize>:
	return rv;
}

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   15a38:	b570      	push	{r4, r5, r6, lr}
   15a3a:	4604      	mov	r4, r0
   15a3c:	460d      	mov	r5, r1
};

/** @internal */
static inline uint32_t sys_notify_get_method(const struct sys_notify *notify)
{
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   15a3e:	6843      	ldr	r3, [r0, #4]

	return method & SYS_NOTIFY_METHOD_MASK;
   15a40:	f003 0303 	and.w	r3, r3, #3
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
   15a44:	6081      	str	r1, [r0, #8]
	switch (method) {
   15a46:	2b02      	cmp	r3, #2
   15a48:	d013      	beq.n	15a72 <sys_notify_finalize+0x3a>
   15a4a:	2b03      	cmp	r3, #3
   15a4c:	d00e      	beq.n	15a6c <sys_notify_finalize+0x34>
   15a4e:	2b01      	cmp	r3, #1
   15a50:	d012      	beq.n	15a78 <sys_notify_finalize+0x40>
		break;
	case SYS_NOTIFY_METHOD_SIGNAL:
		sig = notify->method.signal;
		break;
	default:
		__ASSERT_NO_MSG(false);
   15a52:	4e0e      	ldr	r6, [pc, #56]	; (15a8c <sys_notify_finalize+0x54>)
   15a54:	2245      	movs	r2, #69	; 0x45
   15a56:	4631      	mov	r1, r6
   15a58:	480d      	ldr	r0, [pc, #52]	; (15a90 <sys_notify_finalize+0x58>)
   15a5a:	f016 fd68 	bl	2c52e <assert_print>
   15a5e:	2145      	movs	r1, #69	; 0x45
   15a60:	4630      	mov	r0, r6
   15a62:	f016 fd5d 	bl	2c520 <assert_post_action>
	sys_notify_generic_callback rv = NULL;
   15a66:	2600      	movs	r6, #0
	struct k_poll_signal *sig = NULL;
   15a68:	4630      	mov	r0, r6
   15a6a:	e007      	b.n	15a7c <sys_notify_finalize+0x44>
		rv = notify->method.callback;
   15a6c:	6806      	ldr	r6, [r0, #0]
	struct k_poll_signal *sig = NULL;
   15a6e:	2000      	movs	r0, #0
		break;
   15a70:	e004      	b.n	15a7c <sys_notify_finalize+0x44>
		sig = notify->method.signal;
   15a72:	6800      	ldr	r0, [r0, #0]
	sys_notify_generic_callback rv = NULL;
   15a74:	2600      	movs	r6, #0
		break;
   15a76:	e001      	b.n	15a7c <sys_notify_finalize+0x44>
	switch (method) {
   15a78:	2600      	movs	r6, #0
   15a7a:	4630      	mov	r0, r6
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   15a7c:	2300      	movs	r3, #0
   15a7e:	6063      	str	r3, [r4, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
   15a80:	b110      	cbz	r0, 15a88 <sys_notify_finalize+0x50>
		union { uintptr_t x; int val; } parm1 = { .val = result };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
   15a82:	4629      	mov	r1, r5
   15a84:	f014 fae2 	bl	2a04c <z_impl_k_poll_signal_raise>
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   15a88:	4630      	mov	r0, r6
   15a8a:	bd70      	pop	{r4, r5, r6, pc}
   15a8c:	000390a8 	.word	0x000390a8
   15a90:	00031600 	.word	0x00031600

00015a94 <char_out>:

	return c;
}

static int char_out(int c, void *ctx_p)
{
   15a94:	b508      	push	{r3, lr}
	(void) ctx_p;
	return _char_out(c);
   15a96:	4b02      	ldr	r3, [pc, #8]	; (15aa0 <char_out+0xc>)
   15a98:	681b      	ldr	r3, [r3, #0]
   15a9a:	4798      	blx	r3
}
   15a9c:	bd08      	pop	{r3, pc}
   15a9e:	bf00      	nop
   15aa0:	20000af0 	.word	0x20000af0

00015aa4 <__printk_hook_install>:
	_char_out = fn;
   15aa4:	4b01      	ldr	r3, [pc, #4]	; (15aac <__printk_hook_install+0x8>)
   15aa6:	6018      	str	r0, [r3, #0]
}
   15aa8:	4770      	bx	lr
   15aaa:	bf00      	nop
   15aac:	20000af0 	.word	0x20000af0

00015ab0 <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
   15ab0:	b500      	push	{lr}
   15ab2:	b083      	sub	sp, #12
   15ab4:	4602      	mov	r2, r0
   15ab6:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
   15ab8:	2100      	movs	r1, #0
   15aba:	9100      	str	r1, [sp, #0]
   15abc:	4802      	ldr	r0, [pc, #8]	; (15ac8 <vprintk+0x18>)
   15abe:	f001 f897 	bl	16bf0 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
   15ac2:	b003      	add	sp, #12
   15ac4:	f85d fb04 	ldr.w	pc, [sp], #4
   15ac8:	00015a95 	.word	0x00015a95

00015acc <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   15acc:	b510      	push	{r4, lr}
   15ace:	b086      	sub	sp, #24
   15ad0:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
   15ad2:	9003      	str	r0, [sp, #12]
   15ad4:	9104      	str	r1, [sp, #16]
   15ad6:	2100      	movs	r1, #0
   15ad8:	9105      	str	r1, [sp, #20]
   15ada:	9100      	str	r1, [sp, #0]
   15adc:	a903      	add	r1, sp, #12
   15ade:	4806      	ldr	r0, [pc, #24]	; (15af8 <vsnprintk+0x2c>)
   15ae0:	f001 f886 	bl	16bf0 <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
   15ae4:	9b05      	ldr	r3, [sp, #20]
   15ae6:	9a04      	ldr	r2, [sp, #16]
   15ae8:	4293      	cmp	r3, r2
   15aea:	da01      	bge.n	15af0 <vsnprintk+0x24>
		str[ctx.count] = '\0';
   15aec:	2200      	movs	r2, #0
   15aee:	54e2      	strb	r2, [r4, r3]
	}

	return ctx.count;
}
   15af0:	9805      	ldr	r0, [sp, #20]
   15af2:	b006      	add	sp, #24
   15af4:	bd10      	pop	{r4, pc}
   15af6:	bf00      	nop
   15af8:	0002bfb7 	.word	0x0002bfb7

00015afc <process_complete>:
 * from the manager to the output list for notification.
 */
static void process_complete(struct onoff_manager *mgr,
			     sys_slist_t *clients,
			     int res)
{
   15afc:	b538      	push	{r3, r4, r5, lr}
   15afe:	4604      	mov	r4, r0
   15b00:	468c      	mov	ip, r1
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15b02:	8b83      	ldrh	r3, [r0, #28]

	if (res < 0) {
   15b04:	2a00      	cmp	r2, #0
   15b06:	db13      	blt.n	15b30 <process_complete+0x34>
   15b08:	f003 0307 	and.w	r3, r3, #7
		/* Enter ERROR state and notify all clients. */
		*clients = mgr->clients;
		sys_slist_init(&mgr->clients);
		set_state(mgr, ONOFF_STATE_ERROR);
	} else if ((state == ONOFF_STATE_TO_ON)
		   || (state == ONOFF_STATE_RESETTING)) {
   15b0c:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   15b0e:	2a01      	cmp	r2, #1
   15b10:	d91a      	bls.n	15b48 <process_complete+0x4c>
			set_state(mgr, ONOFF_STATE_OFF);
		}
		if (process_recheck(mgr) != EVT_NOP) {
			mgr->flags |= ONOFF_FLAG_RECHECK;
		}
	} else if (state == ONOFF_STATE_TO_OFF) {
   15b12:	2b04      	cmp	r3, #4
   15b14:	d04e      	beq.n	15bb4 <process_complete+0xb8>
		set_state(mgr, ONOFF_STATE_OFF);
		if (process_recheck(mgr) != EVT_NOP) {
			mgr->flags |= ONOFF_FLAG_RECHECK;
		}
	} else {
		__ASSERT_NO_MSG(false);
   15b16:	4c2e      	ldr	r4, [pc, #184]	; (15bd0 <process_complete+0xd4>)
   15b18:	f240 121b 	movw	r2, #283	; 0x11b
   15b1c:	4621      	mov	r1, r4
   15b1e:	482d      	ldr	r0, [pc, #180]	; (15bd4 <process_complete+0xd8>)
   15b20:	f016 fd05 	bl	2c52e <assert_print>
   15b24:	f240 111b 	movw	r1, #283	; 0x11b
   15b28:	4620      	mov	r0, r4
   15b2a:	f016 fcf9 	bl	2c520 <assert_post_action>
	}
}
   15b2e:	bd38      	pop	{r3, r4, r5, pc}
		*clients = mgr->clients;
   15b30:	e9d0 0100 	ldrd	r0, r1, [r0]
   15b34:	e88c 0003 	stmia.w	ip, {r0, r1}
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
   15b38:	2300      	movs	r3, #0
   15b3a:	6023      	str	r3, [r4, #0]
	list->tail = NULL;
   15b3c:	6063      	str	r3, [r4, #4]
		set_state(mgr, ONOFF_STATE_ERROR);
   15b3e:	2101      	movs	r1, #1
   15b40:	4620      	mov	r0, r4
   15b42:	f016 fa6d 	bl	2c020 <set_state>
   15b46:	e7f2      	b.n	15b2e <process_complete+0x32>
		*clients = mgr->clients;
   15b48:	e9d0 0100 	ldrd	r0, r1, [r0]
   15b4c:	e88c 0003 	stmia.w	ip, {r0, r1}
	list->head = NULL;
   15b50:	2200      	movs	r2, #0
   15b52:	6022      	str	r2, [r4, #0]
	list->tail = NULL;
   15b54:	6062      	str	r2, [r4, #4]
		if (state == ONOFF_STATE_TO_ON) {
   15b56:	2b06      	cmp	r3, #6
   15b58:	d00f      	beq.n	15b7a <process_complete+0x7e>
			__ASSERT_NO_MSG(state == ONOFF_STATE_RESETTING);
   15b5a:	2b05      	cmp	r3, #5
   15b5c:	d11d      	bne.n	15b9a <process_complete+0x9e>
			set_state(mgr, ONOFF_STATE_OFF);
   15b5e:	2100      	movs	r1, #0
   15b60:	4620      	mov	r0, r4
   15b62:	f016 fa5d 	bl	2c020 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
   15b66:	4620      	mov	r0, r4
   15b68:	f016 fa81 	bl	2c06e <process_recheck>
   15b6c:	2800      	cmp	r0, #0
   15b6e:	d0de      	beq.n	15b2e <process_complete+0x32>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   15b70:	8ba3      	ldrh	r3, [r4, #28]
   15b72:	f043 0320 	orr.w	r3, r3, #32
   15b76:	83a3      	strh	r3, [r4, #28]
   15b78:	e7d9      	b.n	15b2e <process_complete+0x32>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   15b7a:	f8dc 3000 	ldr.w	r3, [ip]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   15b7e:	b13b      	cbz	r3, 15b90 <process_complete+0x94>
				mgr->refs += 1U;
   15b80:	8be2      	ldrh	r2, [r4, #30]
   15b82:	3201      	adds	r2, #1
   15b84:	83e2      	strh	r2, [r4, #30]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
   15b86:	2b00      	cmp	r3, #0
   15b88:	d0f9      	beq.n	15b7e <process_complete+0x82>
	return node->next;
   15b8a:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   15b8c:	2b00      	cmp	r3, #0
   15b8e:	d1f6      	bne.n	15b7e <process_complete+0x82>
			set_state(mgr, ONOFF_STATE_ON);
   15b90:	2102      	movs	r1, #2
   15b92:	4620      	mov	r0, r4
   15b94:	f016 fa44 	bl	2c020 <set_state>
   15b98:	e7e5      	b.n	15b66 <process_complete+0x6a>
			__ASSERT_NO_MSG(state == ONOFF_STATE_RESETTING);
   15b9a:	4d0d      	ldr	r5, [pc, #52]	; (15bd0 <process_complete+0xd4>)
   15b9c:	f240 1209 	movw	r2, #265	; 0x109
   15ba0:	4629      	mov	r1, r5
   15ba2:	480c      	ldr	r0, [pc, #48]	; (15bd4 <process_complete+0xd8>)
   15ba4:	f016 fcc3 	bl	2c52e <assert_print>
   15ba8:	f240 1109 	movw	r1, #265	; 0x109
   15bac:	4628      	mov	r0, r5
   15bae:	f016 fcb7 	bl	2c520 <assert_post_action>
   15bb2:	e7d4      	b.n	15b5e <process_complete+0x62>
		set_state(mgr, ONOFF_STATE_OFF);
   15bb4:	2100      	movs	r1, #0
   15bb6:	f016 fa33 	bl	2c020 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
   15bba:	4620      	mov	r0, r4
   15bbc:	f016 fa57 	bl	2c06e <process_recheck>
   15bc0:	2800      	cmp	r0, #0
   15bc2:	d0b4      	beq.n	15b2e <process_complete+0x32>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   15bc4:	8ba3      	ldrh	r3, [r4, #28]
   15bc6:	f043 0320 	orr.w	r3, r3, #32
   15bca:	83a3      	strh	r3, [r4, #28]
   15bcc:	e7af      	b.n	15b2e <process_complete+0x32>
   15bce:	bf00      	nop
   15bd0:	000390cc 	.word	0x000390cc
   15bd4:	00031600 	.word	0x00031600

00015bd8 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   15bd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15bdc:	b083      	sub	sp, #12
   15bde:	4604      	mov	r4, r0
   15be0:	4616      	mov	r6, r2
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15be2:	8b83      	ldrh	r3, [r0, #28]
   15be4:	f003 0707 	and.w	r7, r3, #7
	int res = 0;
	bool processing = ((mgr->flags & ONOFF_FLAG_PROCESSING) != 0);
   15be8:	f003 0808 	and.w	r8, r3, #8

	__ASSERT_NO_MSG(evt != EVT_NOP);
   15bec:	460d      	mov	r5, r1
   15bee:	b131      	cbz	r1, 15bfe <process_event+0x26>

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   15bf0:	f1b8 0f00 	cmp.w	r8, #0
   15bf4:	d111      	bne.n	15c1a <process_event+0x42>
	list->head = NULL;
   15bf6:	2300      	movs	r3, #0
   15bf8:	9300      	str	r3, [sp, #0]
	list->tail = NULL;
   15bfa:	9301      	str	r3, [sp, #4]
}
   15bfc:	e0a7      	b.n	15d4e <process_event+0x176>
	__ASSERT_NO_MSG(evt != EVT_NOP);
   15bfe:	f8df 9304 	ldr.w	r9, [pc, #772]	; 15f04 <process_event+0x32c>
   15c02:	f240 1233 	movw	r2, #307	; 0x133
   15c06:	4649      	mov	r1, r9
   15c08:	48bd      	ldr	r0, [pc, #756]	; (15f00 <process_event+0x328>)
   15c0a:	f016 fc90 	bl	2c52e <assert_print>
   15c0e:	f240 1133 	movw	r1, #307	; 0x133
   15c12:	4648      	mov	r0, r9
   15c14:	f016 fc84 	bl	2c520 <assert_post_action>
   15c18:	e7ea      	b.n	15bf0 <process_event+0x18>
		if (evt == EVT_COMPLETE) {
   15c1a:	2d01      	cmp	r5, #1
   15c1c:	d013      	beq.n	15c46 <process_event+0x6e>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);
   15c1e:	2d02      	cmp	r5, #2
   15c20:	d116      	bne.n	15c50 <process_event+0x78>

			mgr->flags |= ONOFF_FLAG_RECHECK;
   15c22:	8ba3      	ldrh	r3, [r4, #28]
   15c24:	f043 0320 	orr.w	r3, r3, #32
   15c28:	83a3      	strh	r3, [r4, #28]
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   15c2a:	f104 0014 	add.w	r0, r4, #20
   15c2e:	f010 fd49 	bl	266c4 <z_spin_unlock_valid>
   15c32:	2800      	cmp	r0, #0
   15c34:	f000 8176 	beq.w	15f24 <process_event+0x34c>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   15c38:	f386 8811 	msr	BASEPRI, r6
   15c3c:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   15c40:	b003      	add	sp, #12
   15c42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   15c46:	8ba3      	ldrh	r3, [r4, #28]
   15c48:	f043 0310 	orr.w	r3, r3, #16
   15c4c:	83a3      	strh	r3, [r4, #28]
   15c4e:	e7ec      	b.n	15c2a <process_event+0x52>
			__ASSERT_NO_MSG(evt == EVT_RECHECK);
   15c50:	4dac      	ldr	r5, [pc, #688]	; (15f04 <process_event+0x32c>)
   15c52:	f44f 729e 	mov.w	r2, #316	; 0x13c
   15c56:	4629      	mov	r1, r5
   15c58:	48a9      	ldr	r0, [pc, #676]	; (15f00 <process_event+0x328>)
   15c5a:	f016 fc68 	bl	2c52e <assert_print>
   15c5e:	f44f 719e 	mov.w	r1, #316	; 0x13c
   15c62:	4628      	mov	r0, r5
   15c64:	f016 fc5c 	bl	2c520 <assert_post_action>
   15c68:	e7db      	b.n	15c22 <process_event+0x4a>
			evt = process_recheck(mgr);
   15c6a:	4620      	mov	r0, r4
   15c6c:	f016 f9ff 	bl	2c06e <process_recheck>
   15c70:	4605      	mov	r5, r0
   15c72:	e06e      	b.n	15d52 <process_event+0x17a>
			res = mgr->last_res;
   15c74:	f8d4 9018 	ldr.w	r9, [r4, #24]
			process_complete(mgr, &clients, res);
   15c78:	464a      	mov	r2, r9
   15c7a:	4669      	mov	r1, sp
   15c7c:	4620      	mov	r0, r4
   15c7e:	f7ff ff3d 	bl	15afc <process_complete>
		onoff_transition_fn transit = NULL;
   15c82:	2500      	movs	r5, #0
   15c84:	e010      	b.n	15ca8 <process_event+0xd0>
			__ASSERT_NO_MSG(state == ONOFF_STATE_OFF);
   15c86:	2f00      	cmp	r7, #0
   15c88:	d17f      	bne.n	15d8a <process_event+0x1b2>
	return list->head;
   15c8a:	6823      	ldr	r3, [r4, #0]
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
   15c8c:	2b00      	cmp	r3, #0
   15c8e:	f000 8089 	beq.w	15da4 <process_event+0x1cc>
			transit = mgr->transitions->start;
   15c92:	6923      	ldr	r3, [r4, #16]
   15c94:	681d      	ldr	r5, [r3, #0]
			__ASSERT_NO_MSG(transit != NULL);
   15c96:	2d00      	cmp	r5, #0
   15c98:	f000 8091 	beq.w	15dbe <process_event+0x1e6>
			set_state(mgr, ONOFF_STATE_TO_ON);
   15c9c:	2106      	movs	r1, #6
   15c9e:	4620      	mov	r0, r4
   15ca0:	f016 f9be 	bl	2c020 <set_state>
		res = 0;
   15ca4:	f04f 0900 	mov.w	r9, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   15ca8:	8ba3      	ldrh	r3, [r4, #28]
   15caa:	f003 0807 	and.w	r8, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   15cae:	45b8      	cmp	r8, r7
   15cb0:	f000 8100 	beq.w	15eb4 <process_event+0x2dc>
   15cb4:	68a2      	ldr	r2, [r4, #8]
   15cb6:	2a00      	cmp	r2, #0
   15cb8:	f000 80fe 	beq.w	15eb8 <process_event+0x2e0>
   15cbc:	2201      	movs	r2, #1
		if (do_monitors
   15cbe:	4617      	mov	r7, r2
   15cc0:	b91a      	cbnz	r2, 15cca <process_event+0xf2>
   15cc2:	9a00      	ldr	r2, [sp, #0]
		    || !sys_slist_is_empty(&clients)
   15cc4:	2a00      	cmp	r2, #0
   15cc6:	f000 80f9 	beq.w	15ebc <process_event+0x2e4>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   15cca:	f043 0308 	orr.w	r3, r3, #8
			mgr->flags = flags;
   15cce:	83a3      	strh	r3, [r4, #28]
			k_spin_unlock(&mgr->lock, key);
   15cd0:	f104 0a14 	add.w	sl, r4, #20
   15cd4:	4650      	mov	r0, sl
   15cd6:	f010 fcf5 	bl	266c4 <z_spin_unlock_valid>
   15cda:	2800      	cmp	r0, #0
   15cdc:	f000 80f2 	beq.w	15ec4 <process_event+0x2ec>
   15ce0:	f386 8811 	msr	BASEPRI, r6
   15ce4:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   15ce8:	2f00      	cmp	r7, #0
   15cea:	f040 80f7 	bne.w	15edc <process_event+0x304>
   15cee:	9b00      	ldr	r3, [sp, #0]
			if (!sys_slist_is_empty(&clients)) {
   15cf0:	b12b      	cbz	r3, 15cfe <process_event+0x126>
				notify_all(mgr, &clients, state, res);
   15cf2:	464b      	mov	r3, r9
   15cf4:	4642      	mov	r2, r8
   15cf6:	4669      	mov	r1, sp
   15cf8:	4620      	mov	r0, r4
   15cfa:	f016 f9fa 	bl	2c0f2 <notify_all>
			if (transit != NULL) {
   15cfe:	b115      	cbz	r5, 15d06 <process_event+0x12e>
				transit(mgr, transition_complete);
   15d00:	4981      	ldr	r1, [pc, #516]	; (15f08 <process_event+0x330>)
   15d02:	4620      	mov	r0, r4
   15d04:	47a8      	blx	r5
	__asm__ volatile(
   15d06:	f04f 0340 	mov.w	r3, #64	; 0x40
   15d0a:	f3ef 8611 	mrs	r6, BASEPRI
   15d0e:	f383 8812 	msr	BASEPRI_MAX, r3
   15d12:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   15d16:	4650      	mov	r0, sl
   15d18:	f010 fcc4 	bl	266a4 <z_spin_lock_valid>
   15d1c:	2800      	cmp	r0, #0
   15d1e:	f000 80e3 	beq.w	15ee8 <process_event+0x310>
	z_spin_lock_set_owner(l);
   15d22:	4650      	mov	r0, sl
   15d24:	f010 fcde 	bl	266e4 <z_spin_lock_set_owner>
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   15d28:	8ba3      	ldrh	r3, [r4, #28]
   15d2a:	f023 0308 	bic.w	r3, r3, #8
   15d2e:	83a3      	strh	r3, [r4, #28]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   15d30:	8ba3      	ldrh	r3, [r4, #28]
   15d32:	f013 0f10 	tst.w	r3, #16
   15d36:	f000 80eb 	beq.w	15f10 <process_event+0x338>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   15d3a:	f023 0310 	bic.w	r3, r3, #16
   15d3e:	83a3      	strh	r3, [r4, #28]
			evt = EVT_COMPLETE;
   15d40:	2501      	movs	r5, #1
		state = mgr->flags & ONOFF_STATE_MASK;
   15d42:	8ba7      	ldrh	r7, [r4, #28]
   15d44:	f007 0707 	and.w	r7, r7, #7
	} while (evt != EVT_NOP);
   15d48:	2d00      	cmp	r5, #0
   15d4a:	f43f af6e 	beq.w	15c2a <process_event+0x52>
		if (evt == EVT_RECHECK) {
   15d4e:	2d02      	cmp	r5, #2
   15d50:	d08b      	beq.n	15c6a <process_event+0x92>
		if (evt == EVT_NOP) {
   15d52:	2d00      	cmp	r5, #0
   15d54:	f43f af69 	beq.w	15c2a <process_event+0x52>
		if (evt == EVT_COMPLETE) {
   15d58:	2d01      	cmp	r5, #1
   15d5a:	d08b      	beq.n	15c74 <process_event+0x9c>
		} else if (evt == EVT_START) {
   15d5c:	2d03      	cmp	r5, #3
   15d5e:	d092      	beq.n	15c86 <process_event+0xae>
		} else if (evt == EVT_STOP) {
   15d60:	2d04      	cmp	r5, #4
   15d62:	d03a      	beq.n	15dda <process_event+0x202>
		} else if (evt == EVT_RESET) {
   15d64:	2d05      	cmp	r5, #5
   15d66:	f040 8096 	bne.w	15e96 <process_event+0x2be>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
   15d6a:	2f01      	cmp	r7, #1
   15d6c:	d16b      	bne.n	15e46 <process_event+0x26e>
   15d6e:	6823      	ldr	r3, [r4, #0]
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
   15d70:	2b00      	cmp	r3, #0
   15d72:	d075      	beq.n	15e60 <process_event+0x288>
			transit = mgr->transitions->reset;
   15d74:	6923      	ldr	r3, [r4, #16]
   15d76:	689d      	ldr	r5, [r3, #8]
			__ASSERT_NO_MSG(transit != NULL);
   15d78:	2d00      	cmp	r5, #0
   15d7a:	d07e      	beq.n	15e7a <process_event+0x2a2>
			set_state(mgr, ONOFF_STATE_RESETTING);
   15d7c:	2105      	movs	r1, #5
   15d7e:	4620      	mov	r0, r4
   15d80:	f016 f94e 	bl	2c020 <set_state>
		res = 0;
   15d84:	f04f 0900 	mov.w	r9, #0
   15d88:	e78e      	b.n	15ca8 <process_event+0xd0>
			__ASSERT_NO_MSG(state == ONOFF_STATE_OFF);
   15d8a:	4d5e      	ldr	r5, [pc, #376]	; (15f04 <process_event+0x32c>)
   15d8c:	f44f 72ab 	mov.w	r2, #342	; 0x156
   15d90:	4629      	mov	r1, r5
   15d92:	485b      	ldr	r0, [pc, #364]	; (15f00 <process_event+0x328>)
   15d94:	f016 fbcb 	bl	2c52e <assert_print>
   15d98:	f44f 71ab 	mov.w	r1, #342	; 0x156
   15d9c:	4628      	mov	r0, r5
   15d9e:	f016 fbbf 	bl	2c520 <assert_post_action>
   15da2:	e772      	b.n	15c8a <process_event+0xb2>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
   15da4:	4d57      	ldr	r5, [pc, #348]	; (15f04 <process_event+0x32c>)
   15da6:	f240 1257 	movw	r2, #343	; 0x157
   15daa:	4629      	mov	r1, r5
   15dac:	4854      	ldr	r0, [pc, #336]	; (15f00 <process_event+0x328>)
   15dae:	f016 fbbe 	bl	2c52e <assert_print>
   15db2:	f240 1157 	movw	r1, #343	; 0x157
   15db6:	4628      	mov	r0, r5
   15db8:	f016 fbb2 	bl	2c520 <assert_post_action>
   15dbc:	e769      	b.n	15c92 <process_event+0xba>
			__ASSERT_NO_MSG(transit != NULL);
   15dbe:	f8df 8144 	ldr.w	r8, [pc, #324]	; 15f04 <process_event+0x32c>
   15dc2:	f44f 72ad 	mov.w	r2, #346	; 0x15a
   15dc6:	4641      	mov	r1, r8
   15dc8:	484d      	ldr	r0, [pc, #308]	; (15f00 <process_event+0x328>)
   15dca:	f016 fbb0 	bl	2c52e <assert_print>
   15dce:	f44f 71ad 	mov.w	r1, #346	; 0x15a
   15dd2:	4640      	mov	r0, r8
   15dd4:	f016 fba4 	bl	2c520 <assert_post_action>
   15dd8:	e760      	b.n	15c9c <process_event+0xc4>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ON);
   15dda:	2f02      	cmp	r7, #2
   15ddc:	d10b      	bne.n	15df6 <process_event+0x21e>
			__ASSERT_NO_MSG(mgr->refs == 0);
   15dde:	8be3      	ldrh	r3, [r4, #30]
   15de0:	b9b3      	cbnz	r3, 15e10 <process_event+0x238>
			transit = mgr->transitions->stop;
   15de2:	6923      	ldr	r3, [r4, #16]
   15de4:	685d      	ldr	r5, [r3, #4]
			__ASSERT_NO_MSG(transit != NULL);
   15de6:	b305      	cbz	r5, 15e2a <process_event+0x252>
			set_state(mgr, ONOFF_STATE_TO_OFF);
   15de8:	2104      	movs	r1, #4
   15dea:	4620      	mov	r0, r4
   15dec:	f016 f918 	bl	2c020 <set_state>
		res = 0;
   15df0:	f04f 0900 	mov.w	r9, #0
   15df4:	e758      	b.n	15ca8 <process_event+0xd0>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ON);
   15df6:	4d43      	ldr	r5, [pc, #268]	; (15f04 <process_event+0x32c>)
   15df8:	f240 125d 	movw	r2, #349	; 0x15d
   15dfc:	4629      	mov	r1, r5
   15dfe:	4840      	ldr	r0, [pc, #256]	; (15f00 <process_event+0x328>)
   15e00:	f016 fb95 	bl	2c52e <assert_print>
   15e04:	f240 115d 	movw	r1, #349	; 0x15d
   15e08:	4628      	mov	r0, r5
   15e0a:	f016 fb89 	bl	2c520 <assert_post_action>
   15e0e:	e7e6      	b.n	15dde <process_event+0x206>
			__ASSERT_NO_MSG(mgr->refs == 0);
   15e10:	4d3c      	ldr	r5, [pc, #240]	; (15f04 <process_event+0x32c>)
   15e12:	f44f 72af 	mov.w	r2, #350	; 0x15e
   15e16:	4629      	mov	r1, r5
   15e18:	4839      	ldr	r0, [pc, #228]	; (15f00 <process_event+0x328>)
   15e1a:	f016 fb88 	bl	2c52e <assert_print>
   15e1e:	f44f 71af 	mov.w	r1, #350	; 0x15e
   15e22:	4628      	mov	r0, r5
   15e24:	f016 fb7c 	bl	2c520 <assert_post_action>
   15e28:	e7db      	b.n	15de2 <process_event+0x20a>
			__ASSERT_NO_MSG(transit != NULL);
   15e2a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 15f04 <process_event+0x32c>
   15e2e:	f240 1261 	movw	r2, #353	; 0x161
   15e32:	4641      	mov	r1, r8
   15e34:	4832      	ldr	r0, [pc, #200]	; (15f00 <process_event+0x328>)
   15e36:	f016 fb7a 	bl	2c52e <assert_print>
   15e3a:	f240 1161 	movw	r1, #353	; 0x161
   15e3e:	4640      	mov	r0, r8
   15e40:	f016 fb6e 	bl	2c520 <assert_post_action>
   15e44:	e7d0      	b.n	15de8 <process_event+0x210>
			__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
   15e46:	4d2f      	ldr	r5, [pc, #188]	; (15f04 <process_event+0x32c>)
   15e48:	f44f 72b2 	mov.w	r2, #356	; 0x164
   15e4c:	4629      	mov	r1, r5
   15e4e:	482c      	ldr	r0, [pc, #176]	; (15f00 <process_event+0x328>)
   15e50:	f016 fb6d 	bl	2c52e <assert_print>
   15e54:	f44f 71b2 	mov.w	r1, #356	; 0x164
   15e58:	4628      	mov	r0, r5
   15e5a:	f016 fb61 	bl	2c520 <assert_post_action>
   15e5e:	e786      	b.n	15d6e <process_event+0x196>
			__ASSERT_NO_MSG(!sys_slist_is_empty(&mgr->clients));
   15e60:	4d28      	ldr	r5, [pc, #160]	; (15f04 <process_event+0x32c>)
   15e62:	f240 1265 	movw	r2, #357	; 0x165
   15e66:	4629      	mov	r1, r5
   15e68:	4825      	ldr	r0, [pc, #148]	; (15f00 <process_event+0x328>)
   15e6a:	f016 fb60 	bl	2c52e <assert_print>
   15e6e:	f240 1165 	movw	r1, #357	; 0x165
   15e72:	4628      	mov	r0, r5
   15e74:	f016 fb54 	bl	2c520 <assert_post_action>
   15e78:	e77c      	b.n	15d74 <process_event+0x19c>
			__ASSERT_NO_MSG(transit != NULL);
   15e7a:	f8df 8088 	ldr.w	r8, [pc, #136]	; 15f04 <process_event+0x32c>
   15e7e:	f44f 72b4 	mov.w	r2, #360	; 0x168
   15e82:	4641      	mov	r1, r8
   15e84:	481e      	ldr	r0, [pc, #120]	; (15f00 <process_event+0x328>)
   15e86:	f016 fb52 	bl	2c52e <assert_print>
   15e8a:	f44f 71b4 	mov.w	r1, #360	; 0x168
   15e8e:	4640      	mov	r0, r8
   15e90:	f016 fb46 	bl	2c520 <assert_post_action>
   15e94:	e772      	b.n	15d7c <process_event+0x1a4>
			__ASSERT_NO_MSG(false);
   15e96:	4d1b      	ldr	r5, [pc, #108]	; (15f04 <process_event+0x32c>)
   15e98:	f240 126b 	movw	r2, #363	; 0x16b
   15e9c:	4629      	mov	r1, r5
   15e9e:	4818      	ldr	r0, [pc, #96]	; (15f00 <process_event+0x328>)
   15ea0:	f016 fb45 	bl	2c52e <assert_print>
   15ea4:	f240 116b 	movw	r1, #363	; 0x16b
   15ea8:	4628      	mov	r0, r5
   15eaa:	f016 fb39 	bl	2c520 <assert_post_action>
		onoff_transition_fn transit = NULL;
   15eae:	2500      	movs	r5, #0
		res = 0;
   15eb0:	46a9      	mov	r9, r5
   15eb2:	e6f9      	b.n	15ca8 <process_event+0xd0>
				   && !sys_slist_is_empty(&mgr->monitors);
   15eb4:	2200      	movs	r2, #0
   15eb6:	e702      	b.n	15cbe <process_event+0xe6>
   15eb8:	2200      	movs	r2, #0
   15eba:	e700      	b.n	15cbe <process_event+0xe6>
		    || (transit != NULL)) {
   15ebc:	2d00      	cmp	r5, #0
   15ebe:	f47f af04 	bne.w	15cca <process_event+0xf2>
   15ec2:	e735      	b.n	15d30 <process_event+0x158>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   15ec4:	f8df b044 	ldr.w	fp, [pc, #68]	; 15f0c <process_event+0x334>
   15ec8:	22b9      	movs	r2, #185	; 0xb9
   15eca:	4659      	mov	r1, fp
   15ecc:	480c      	ldr	r0, [pc, #48]	; (15f00 <process_event+0x328>)
   15ece:	f016 fb2e 	bl	2c52e <assert_print>
   15ed2:	21b9      	movs	r1, #185	; 0xb9
   15ed4:	4658      	mov	r0, fp
   15ed6:	f016 fb23 	bl	2c520 <assert_post_action>
   15eda:	e701      	b.n	15ce0 <process_event+0x108>
				notify_monitors(mgr, state, res);
   15edc:	464a      	mov	r2, r9
   15ede:	4641      	mov	r1, r8
   15ee0:	4620      	mov	r0, r4
   15ee2:	f016 f8a5 	bl	2c030 <notify_monitors>
   15ee6:	e702      	b.n	15cee <process_event+0x116>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   15ee8:	4d08      	ldr	r5, [pc, #32]	; (15f0c <process_event+0x334>)
   15eea:	228e      	movs	r2, #142	; 0x8e
   15eec:	4629      	mov	r1, r5
   15eee:	4804      	ldr	r0, [pc, #16]	; (15f00 <process_event+0x328>)
   15ef0:	f016 fb1d 	bl	2c52e <assert_print>
   15ef4:	218e      	movs	r1, #142	; 0x8e
   15ef6:	4628      	mov	r0, r5
   15ef8:	f016 fb12 	bl	2c520 <assert_post_action>
   15efc:	e711      	b.n	15d22 <process_event+0x14a>
   15efe:	bf00      	nop
   15f00:	00031600 	.word	0x00031600
   15f04:	000390cc 	.word	0x000390cc
   15f08:	00015f45 	.word	0x00015f45
   15f0c:	000390f0 	.word	0x000390f0
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   15f10:	f013 0f20 	tst.w	r3, #32
   15f14:	d004      	beq.n	15f20 <process_event+0x348>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   15f16:	f023 0320 	bic.w	r3, r3, #32
   15f1a:	83a3      	strh	r3, [r4, #28]
			evt = EVT_RECHECK;
   15f1c:	2502      	movs	r5, #2
   15f1e:	e710      	b.n	15d42 <process_event+0x16a>
		evt = EVT_NOP;
   15f20:	2500      	movs	r5, #0
   15f22:	e70e      	b.n	15d42 <process_event+0x16a>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   15f24:	4c05      	ldr	r4, [pc, #20]	; (15f3c <process_event+0x364>)
   15f26:	22b9      	movs	r2, #185	; 0xb9
   15f28:	4621      	mov	r1, r4
   15f2a:	4805      	ldr	r0, [pc, #20]	; (15f40 <process_event+0x368>)
   15f2c:	f016 faff 	bl	2c52e <assert_print>
   15f30:	21b9      	movs	r1, #185	; 0xb9
   15f32:	4620      	mov	r0, r4
   15f34:	f016 faf4 	bl	2c520 <assert_post_action>
   15f38:	e67e      	b.n	15c38 <process_event+0x60>
   15f3a:	bf00      	nop
   15f3c:	000390f0 	.word	0x000390f0
   15f40:	00031600 	.word	0x00031600

00015f44 <transition_complete>:
{
   15f44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15f48:	4604      	mov	r4, r0
   15f4a:	460d      	mov	r5, r1
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
   15f4c:	f100 0614 	add.w	r6, r0, #20
   15f50:	f04f 0340 	mov.w	r3, #64	; 0x40
   15f54:	f3ef 8711 	mrs	r7, BASEPRI
   15f58:	f383 8812 	msr	BASEPRI_MAX, r3
   15f5c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   15f60:	4630      	mov	r0, r6
   15f62:	f010 fb9f 	bl	266a4 <z_spin_lock_valid>
   15f66:	b150      	cbz	r0, 15f7e <transition_complete+0x3a>
	z_spin_lock_set_owner(l);
   15f68:	4630      	mov	r0, r6
   15f6a:	f010 fbbb 	bl	266e4 <z_spin_lock_set_owner>
	mgr->last_res = res;
   15f6e:	61a5      	str	r5, [r4, #24]
	process_event(mgr, EVT_COMPLETE, key);
   15f70:	463a      	mov	r2, r7
   15f72:	2101      	movs	r1, #1
   15f74:	4620      	mov	r0, r4
   15f76:	f7ff fe2f 	bl	15bd8 <process_event>
}
   15f7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   15f7e:	f8df 801c 	ldr.w	r8, [pc, #28]	; 15f9c <transition_complete+0x58>
   15f82:	228e      	movs	r2, #142	; 0x8e
   15f84:	4641      	mov	r1, r8
   15f86:	4804      	ldr	r0, [pc, #16]	; (15f98 <transition_complete+0x54>)
   15f88:	f016 fad1 	bl	2c52e <assert_print>
   15f8c:	218e      	movs	r1, #142	; 0x8e
   15f8e:	4640      	mov	r0, r8
   15f90:	f016 fac6 	bl	2c520 <assert_post_action>
   15f94:	e7e8      	b.n	15f68 <transition_complete+0x24>
   15f96:	bf00      	nop
   15f98:	00031600 	.word	0x00031600
   15f9c:	000390f0 	.word	0x000390f0

00015fa0 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   15fa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15fa4:	4604      	mov	r4, r0
   15fa6:	4688      	mov	r8, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   15fa8:	f016 f87a 	bl	2c0a0 <validate_args>

	if (rv < 0) {
   15fac:	1e06      	subs	r6, r0, #0
   15fae:	db53      	blt.n	16058 <onoff_request+0xb8>
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
   15fb0:	f104 0714 	add.w	r7, r4, #20
   15fb4:	f04f 0340 	mov.w	r3, #64	; 0x40
   15fb8:	f3ef 8911 	mrs	r9, BASEPRI
   15fbc:	f383 8812 	msr	BASEPRI_MAX, r3
   15fc0:	f3bf 8f6f 	isb	sy
   15fc4:	4638      	mov	r0, r7
   15fc6:	f010 fb6d 	bl	266a4 <z_spin_lock_valid>
   15fca:	b1e8      	cbz	r0, 16008 <onoff_request+0x68>
	z_spin_lock_set_owner(l);
   15fcc:	4638      	mov	r0, r7
   15fce:	f010 fb89 	bl	266e4 <z_spin_lock_set_owner>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15fd2:	8ba5      	ldrh	r5, [r4, #28]
   15fd4:	f005 0507 	and.w	r5, r5, #7

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   15fd8:	8be3      	ldrh	r3, [r4, #30]
   15fda:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15fde:	4293      	cmp	r3, r2
   15fe0:	d050      	beq.n	16084 <onoff_request+0xe4>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
   15fe2:	462e      	mov	r6, r5
	if (state == ONOFF_STATE_ON) {
   15fe4:	2d02      	cmp	r5, #2
   15fe6:	d01a      	beq.n	1601e <onoff_request+0x7e>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
	} else if ((state == ONOFF_STATE_OFF)
   15fe8:	b305      	cbz	r5, 1602c <onoff_request+0x8c>
		   || (state == ONOFF_STATE_TO_OFF)
   15fea:	2d04      	cmp	r5, #4
   15fec:	d01e      	beq.n	1602c <onoff_request+0x8c>
		   || (state == ONOFF_STATE_TO_ON)) {
   15fee:	2d06      	cmp	r5, #6
   15ff0:	d01c      	beq.n	1602c <onoff_request+0x8c>
		/* Start if OFF, queue client */
		start = (state == ONOFF_STATE_OFF);
		add_client = true;
	} else if (state == ONOFF_STATE_RESETTING) {
   15ff2:	2d05      	cmp	r5, #5
   15ff4:	d04d      	beq.n	16092 <onoff_request+0xf2>
		rv = -ENOTSUP;
	} else {
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
   15ff6:	2d01      	cmp	r5, #1
   15ff8:	d131      	bne.n	1605e <onoff_request+0xbe>
		rv = -EIO;
   15ffa:	f06f 0604 	mvn.w	r6, #4
	bool notify = false;            /* do client notification */
   15ffe:	f04f 0a00 	mov.w	sl, #0
	bool start = false;             /* trigger a start transition */
   16002:	4653      	mov	r3, sl
	bool add_client = false;        /* add client to pending list */
   16004:	4652      	mov	r2, sl
   16006:	e017      	b.n	16038 <onoff_request+0x98>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   16008:	4d36      	ldr	r5, [pc, #216]	; (160e4 <onoff_request+0x144>)
   1600a:	228e      	movs	r2, #142	; 0x8e
   1600c:	4629      	mov	r1, r5
   1600e:	4836      	ldr	r0, [pc, #216]	; (160e8 <onoff_request+0x148>)
   16010:	f016 fa8d 	bl	2c52e <assert_print>
   16014:	218e      	movs	r1, #142	; 0x8e
   16016:	4628      	mov	r0, r5
   16018:	f016 fa82 	bl	2c520 <assert_post_action>
   1601c:	e7d6      	b.n	15fcc <onoff_request+0x2c>
		mgr->refs += 1U;
   1601e:	3301      	adds	r3, #1
   16020:	83e3      	strh	r3, [r4, #30]
		notify = true;
   16022:	f04f 0a01 	mov.w	sl, #1
	bool start = false;             /* trigger a start transition */
   16026:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
   16028:	461a      	mov	r2, r3
   1602a:	e005      	b.n	16038 <onoff_request+0x98>
		start = (state == ONOFF_STATE_OFF);
   1602c:	fab5 f385 	clz	r3, r5
   16030:	095b      	lsrs	r3, r3, #5
	bool notify = false;            /* do client notification */
   16032:	f04f 0a00 	mov.w	sl, #0
		add_client = true;
   16036:	2201      	movs	r2, #1
	}

out:
	if (add_client) {
   16038:	b142      	cbz	r2, 1604c <onoff_request+0xac>
	parent->next = child;
   1603a:	2200      	movs	r2, #0
   1603c:	f8c8 2000 	str.w	r2, [r8]
	return list->tail;
   16040:	6862      	ldr	r2, [r4, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   16042:	b36a      	cbz	r2, 160a0 <onoff_request+0x100>
	parent->next = child;
   16044:	f8c2 8000 	str.w	r8, [r2]
	list->tail = node;
   16048:	f8c4 8004 	str.w	r8, [r4, #4]
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
   1604c:	b36b      	cbz	r3, 160aa <onoff_request+0x10a>
		process_event(mgr, EVT_RECHECK, key);
   1604e:	464a      	mov	r2, r9
   16050:	2102      	movs	r1, #2
   16052:	4620      	mov	r0, r4
   16054:	f7ff fdc0 	bl	15bd8 <process_event>
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
   16058:	4630      	mov	r0, r6
   1605a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
   1605e:	4e23      	ldr	r6, [pc, #140]	; (160ec <onoff_request+0x14c>)
   16060:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
   16064:	4631      	mov	r1, r6
   16066:	4820      	ldr	r0, [pc, #128]	; (160e8 <onoff_request+0x148>)
   16068:	f016 fa61 	bl	2c52e <assert_print>
   1606c:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   16070:	4630      	mov	r0, r6
   16072:	f016 fa55 	bl	2c520 <assert_post_action>
		rv = -EIO;
   16076:	f06f 0604 	mvn.w	r6, #4
	bool notify = false;            /* do client notification */
   1607a:	f04f 0a00 	mov.w	sl, #0
	bool start = false;             /* trigger a start transition */
   1607e:	4653      	mov	r3, sl
	bool add_client = false;        /* add client to pending list */
   16080:	4652      	mov	r2, sl
   16082:	e7d9      	b.n	16038 <onoff_request+0x98>
		rv = -EAGAIN;
   16084:	f06f 060a 	mvn.w	r6, #10
	bool notify = false;            /* do client notification */
   16088:	f04f 0a00 	mov.w	sl, #0
	bool start = false;             /* trigger a start transition */
   1608c:	4653      	mov	r3, sl
	bool add_client = false;        /* add client to pending list */
   1608e:	4652      	mov	r2, sl
   16090:	e7d2      	b.n	16038 <onoff_request+0x98>
		rv = -ENOTSUP;
   16092:	f06f 0685 	mvn.w	r6, #133	; 0x85
	bool notify = false;            /* do client notification */
   16096:	f04f 0a00 	mov.w	sl, #0
	bool start = false;             /* trigger a start transition */
   1609a:	4653      	mov	r3, sl
	bool add_client = false;        /* add client to pending list */
   1609c:	4652      	mov	r2, sl
   1609e:	e7cb      	b.n	16038 <onoff_request+0x98>
   160a0:	f8c4 8004 	str.w	r8, [r4, #4]
	list->head = node;
   160a4:	f8c4 8000 	str.w	r8, [r4]
}
   160a8:	e7d0      	b.n	1604c <onoff_request+0xac>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   160aa:	4638      	mov	r0, r7
   160ac:	f010 fb0a 	bl	266c4 <z_spin_unlock_valid>
   160b0:	b168      	cbz	r0, 160ce <onoff_request+0x12e>
	__asm__ volatile(
   160b2:	f389 8811 	msr	BASEPRI, r9
   160b6:	f3bf 8f6f 	isb	sy
		if (notify) {
   160ba:	f1ba 0f00 	cmp.w	sl, #0
   160be:	d0cb      	beq.n	16058 <onoff_request+0xb8>
			notify_one(mgr, cli, state, 0);
   160c0:	2300      	movs	r3, #0
   160c2:	462a      	mov	r2, r5
   160c4:	4641      	mov	r1, r8
   160c6:	4620      	mov	r0, r4
   160c8:	f016 f800 	bl	2c0cc <notify_one>
   160cc:	e7c4      	b.n	16058 <onoff_request+0xb8>
   160ce:	4f05      	ldr	r7, [pc, #20]	; (160e4 <onoff_request+0x144>)
   160d0:	22b9      	movs	r2, #185	; 0xb9
   160d2:	4639      	mov	r1, r7
   160d4:	4804      	ldr	r0, [pc, #16]	; (160e8 <onoff_request+0x148>)
   160d6:	f016 fa2a 	bl	2c52e <assert_print>
   160da:	21b9      	movs	r1, #185	; 0xb9
   160dc:	4638      	mov	r0, r7
   160de:	f016 fa1f 	bl	2c520 <assert_post_action>
   160e2:	e7e6      	b.n	160b2 <onoff_request+0x112>
   160e4:	000390f0 	.word	0x000390f0
   160e8:	00031600 	.word	0x00031600
   160ec:	000390cc 	.word	0x000390cc

000160f0 <sys_heap_free>:
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
}

void sys_heap_free(struct sys_heap *heap, void *mem)
{
	if (mem == NULL) {
   160f0:	b3b1      	cbz	r1, 16160 <sys_heap_free+0x70>
{
   160f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		return; /* ISO C free() semantics */
	}
	struct z_heap *h = heap->heap;
   160f6:	6804      	ldr	r4, [r0, #0]
	chunkid_t c = mem_to_chunkid(h, mem);
   160f8:	4620      	mov	r0, r4
   160fa:	f016 f8ba 	bl	2c272 <mem_to_chunkid>
   160fe:	4605      	mov	r5, r0

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
   16100:	00c6      	lsls	r6, r0, #3

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   16102:	1cb7      	adds	r7, r6, #2
   16104:	5be3      	ldrh	r3, [r4, r7]

	/*
	 * This should catch many double-free cases.
	 * This is cheap enough so let's do it all the time.
	 */
	__ASSERT(chunk_used(h, c),
   16106:	f013 0f01 	tst.w	r3, #1
   1610a:	d012      	beq.n	16132 <sys_heap_free+0x42>
   1610c:	5be3      	ldrh	r3, [r4, r7]
	return c - chunk_field(h, c, LEFT_SIZE);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
	return c + chunk_size(h, c);
   1610e:	eb05 0353 	add.w	r3, r5, r3, lsr #1
		return ((uint16_t *)cmem)[f];
   16112:	f834 2033 	ldrh.w	r2, [r4, r3, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   16116:	1a9b      	subs	r3, r3, r2
	/*
	 * It is easy to catch many common memory overflow cases with
	 * a quick check on this and next chunk header fields that are
	 * immediately before and after the freed memory.
	 */
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
   16118:	429d      	cmp	r5, r3
   1611a:	d116      	bne.n	1614a <sys_heap_free+0x5a>
	void *cmem = &buf[c];
   1611c:	4426      	add	r6, r4
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   1611e:	8873      	ldrh	r3, [r6, #2]
   16120:	f023 0301 	bic.w	r3, r3, #1
   16124:	8073      	strh	r3, [r6, #2]
#ifdef CONFIG_SYS_HEAP_LISTENER
	heap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), mem,
				  chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	free_chunk(h, c);
   16126:	4629      	mov	r1, r5
   16128:	4620      	mov	r0, r4
   1612a:	f016 f8be 	bl	2c2aa <free_chunk>
}
   1612e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT(chunk_used(h, c),
   16132:	f8df 8034 	ldr.w	r8, [pc, #52]	; 16168 <sys_heap_free+0x78>
   16136:	22ac      	movs	r2, #172	; 0xac
   16138:	4641      	mov	r1, r8
   1613a:	480a      	ldr	r0, [pc, #40]	; (16164 <sys_heap_free+0x74>)
   1613c:	f016 f9f7 	bl	2c52e <assert_print>
   16140:	21ac      	movs	r1, #172	; 0xac
   16142:	4640      	mov	r0, r8
   16144:	f016 f9ec 	bl	2c520 <assert_post_action>
   16148:	e7e0      	b.n	1610c <sys_heap_free+0x1c>
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
   1614a:	4f07      	ldr	r7, [pc, #28]	; (16168 <sys_heap_free+0x78>)
   1614c:	22b4      	movs	r2, #180	; 0xb4
   1614e:	4639      	mov	r1, r7
   16150:	4804      	ldr	r0, [pc, #16]	; (16164 <sys_heap_free+0x74>)
   16152:	f016 f9ec 	bl	2c52e <assert_print>
   16156:	21b4      	movs	r1, #180	; 0xb4
   16158:	4638      	mov	r0, r7
   1615a:	f016 f9e1 	bl	2c520 <assert_post_action>
   1615e:	e7dd      	b.n	1611c <sys_heap_free+0x2c>
   16160:	4770      	bx	lr
   16162:	bf00      	nop
   16164:	00031600 	.word	0x00031600
   16168:	00039120 	.word	0x00039120

0001616c <sys_heap_aligned_alloc>:

	return mem;
}

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   1616c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   16170:	460c      	mov	r4, r1
   16172:	4615      	mov	r5, r2
	struct z_heap *h = heap->heap;
   16174:	6806      	ldr	r6, [r0, #0]
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   16176:	424b      	negs	r3, r1
   16178:	ea03 0801 	and.w	r8, r3, r1
	if (align != rew) {
   1617c:	ea31 0303 	bics.w	r3, r1, r3
   16180:	d041      	beq.n	16206 <sys_heap_aligned_alloc+0x9a>
		align -= rew;
   16182:	eba1 0408 	sub.w	r4, r1, r8
		gap = MIN(rew, chunk_header_bytes(h));
   16186:	f1b8 0f03 	cmp.w	r8, #3
   1618a:	d847      	bhi.n	1621c <sys_heap_aligned_alloc+0xb0>
   1618c:	4647      	mov	r7, r8
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
   1618e:	1e63      	subs	r3, r4, #1
   16190:	4223      	tst	r3, r4
   16192:	d145      	bne.n	16220 <sys_heap_aligned_alloc+0xb4>

	if (bytes == 0 || size_too_big(h, bytes)) {
   16194:	2d00      	cmp	r5, #0
   16196:	d065      	beq.n	16264 <sys_heap_aligned_alloc+0xf8>
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
   16198:	68b3      	ldr	r3, [r6, #8]
   1619a:	ebb3 0fd5 	cmp.w	r3, r5, lsr #3
   1619e:	d963      	bls.n	16268 <sys_heap_aligned_alloc+0xfc>
	/*
	 * Find a free block that is guaranteed to fit.
	 * We over-allocate to account for alignment and then free
	 * the extra allocations afterwards.
	 */
	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
   161a0:	1961      	adds	r1, r4, r5
   161a2:	1bc9      	subs	r1, r1, r7
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   161a4:	310b      	adds	r1, #11
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   161a6:	08c9      	lsrs	r1, r1, #3
   161a8:	4630      	mov	r0, r6
   161aa:	f016 f8af 	bl	2c30c <alloc_chunk>

	if (c0 == 0) {
   161ae:	4607      	mov	r7, r0
   161b0:	2800      	cmp	r0, #0
   161b2:	d05b      	beq.n	1626c <sys_heap_aligned_alloc+0x100>
		return NULL;
	}
	uint8_t *mem = chunk_mem(h, c0);
   161b4:	4601      	mov	r1, r0
   161b6:	4630      	mov	r0, r6
   161b8:	f015 ffd8 	bl	2c16c <chunk_mem>

	/* Align allocated memory */
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   161bc:	4440      	add	r0, r8
   161be:	4420      	add	r0, r4
   161c0:	3801      	subs	r0, #1
   161c2:	4264      	negs	r4, r4
   161c4:	4004      	ands	r4, r0
   161c6:	eba4 0408 	sub.w	r4, r4, r8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   161ca:	4425      	add	r5, r4
   161cc:	3507      	adds	r5, #7
   161ce:	f025 0507 	bic.w	r5, r5, #7

	/* Get corresponding chunks */
	chunkid_t c = mem_to_chunkid(h, mem);
   161d2:	4621      	mov	r1, r4
   161d4:	4630      	mov	r0, r6
   161d6:	f016 f84c 	bl	2c272 <mem_to_chunkid>
   161da:	4680      	mov	r8, r0
	chunkid_t c_end = end - chunk_buf(h);
   161dc:	1bad      	subs	r5, r5, r6
   161de:	10ed      	asrs	r5, r5, #3
	CHECK(c >= c0 && c  < c_end && c_end <= c0 + padded_sz);

	/* Split and free unused prefix */
	if (c > c0) {
   161e0:	4287      	cmp	r7, r0
   161e2:	d32b      	bcc.n	1623c <sys_heap_aligned_alloc+0xd0>
	void *cmem = &buf[c];
   161e4:	ea4f 07c8 	mov.w	r7, r8, lsl #3
		return ((uint16_t *)cmem)[f];
   161e8:	eb06 03c8 	add.w	r3, r6, r8, lsl #3
   161ec:	885b      	ldrh	r3, [r3, #2]
	return c + chunk_size(h, c);
   161ee:	eb08 0353 	add.w	r3, r8, r3, lsr #1
		split_chunks(h, c0, c);
		free_list_add(h, c0);
	}

	/* Split and free unused suffix */
	if (right_chunk(h, c) > c_end) {
   161f2:	429d      	cmp	r5, r3
   161f4:	d32c      	bcc.n	16250 <sys_heap_aligned_alloc+0xe4>
	void *cmem = &buf[c];
   161f6:	443e      	add	r6, r7
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   161f8:	8873      	ldrh	r3, [r6, #2]
   161fa:	f043 0301 	orr.w	r3, r3, #1
   161fe:	8073      	strh	r3, [r6, #2]
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
   16200:	4620      	mov	r0, r4
   16202:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   16206:	2904      	cmp	r1, #4
   16208:	d903      	bls.n	16212 <sys_heap_aligned_alloc+0xa6>
		rew = 0;
   1620a:	f04f 0800 	mov.w	r8, #0
		gap = chunk_header_bytes(h);
   1620e:	2704      	movs	r7, #4
   16210:	e7bd      	b.n	1618e <sys_heap_aligned_alloc+0x22>
			return sys_heap_alloc(heap, bytes);
   16212:	4611      	mov	r1, r2
   16214:	f016 f8b5 	bl	2c382 <sys_heap_alloc>
   16218:	4604      	mov	r4, r0
   1621a:	e7f1      	b.n	16200 <sys_heap_aligned_alloc+0x94>
		gap = MIN(rew, chunk_header_bytes(h));
   1621c:	2704      	movs	r7, #4
   1621e:	e7b6      	b.n	1618e <sys_heap_aligned_alloc+0x22>
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
   16220:	f8df 9050 	ldr.w	r9, [pc, #80]	; 16274 <sys_heap_aligned_alloc+0x108>
   16224:	f44f 72a0 	mov.w	r2, #320	; 0x140
   16228:	4649      	mov	r1, r9
   1622a:	4811      	ldr	r0, [pc, #68]	; (16270 <sys_heap_aligned_alloc+0x104>)
   1622c:	f016 f97f 	bl	2c52e <assert_print>
   16230:	f44f 71a0 	mov.w	r1, #320	; 0x140
   16234:	4648      	mov	r0, r9
   16236:	f016 f973 	bl	2c520 <assert_post_action>
   1623a:	e7ab      	b.n	16194 <sys_heap_aligned_alloc+0x28>
		split_chunks(h, c0, c);
   1623c:	4602      	mov	r2, r0
   1623e:	4639      	mov	r1, r7
   16240:	4630      	mov	r0, r6
   16242:	f015 ffdf 	bl	2c204 <split_chunks>
		free_list_add(h, c0);
   16246:	4639      	mov	r1, r7
   16248:	4630      	mov	r0, r6
   1624a:	f016 f822 	bl	2c292 <free_list_add>
   1624e:	e7c9      	b.n	161e4 <sys_heap_aligned_alloc+0x78>
		split_chunks(h, c, c_end);
   16250:	462a      	mov	r2, r5
   16252:	4641      	mov	r1, r8
   16254:	4630      	mov	r0, r6
   16256:	f015 ffd5 	bl	2c204 <split_chunks>
		free_list_add(h, c_end);
   1625a:	4629      	mov	r1, r5
   1625c:	4630      	mov	r0, r6
   1625e:	f016 f818 	bl	2c292 <free_list_add>
   16262:	e7c8      	b.n	161f6 <sys_heap_aligned_alloc+0x8a>
		return NULL;
   16264:	2400      	movs	r4, #0
   16266:	e7cb      	b.n	16200 <sys_heap_aligned_alloc+0x94>
   16268:	2400      	movs	r4, #0
   1626a:	e7c9      	b.n	16200 <sys_heap_aligned_alloc+0x94>
		return NULL;
   1626c:	2400      	movs	r4, #0
   1626e:	e7c7      	b.n	16200 <sys_heap_aligned_alloc+0x94>
   16270:	00031600 	.word	0x00031600
   16274:	00039120 	.word	0x00039120

00016278 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   16278:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1627c:	4606      	mov	r6, r0
   1627e:	460d      	mov	r5, r1
   16280:	4614      	mov	r4, r2
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
   16282:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
   16286:	d222      	bcs.n	162ce <sys_heap_init+0x56>
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
   16288:	2c04      	cmp	r4, #4
   1628a:	d92d      	bls.n	162e8 <sys_heap_init+0x70>
	bytes -= heap_footer_bytes(bytes);
   1628c:	1f22      	subs	r2, r4, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   1628e:	1dec      	adds	r4, r5, #7
   16290:	f024 0407 	bic.w	r4, r4, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   16294:	4415      	add	r5, r2
   16296:	f025 0507 	bic.w	r5, r5, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   1629a:	1b2d      	subs	r5, r5, r4
   1629c:	ea4f 08d5 	mov.w	r8, r5, lsr #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
   162a0:	2d17      	cmp	r5, #23
   162a2:	d92e      	bls.n	16302 <sys_heap_init+0x8a>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   162a4:	6034      	str	r4, [r6, #0]
	h->end_chunk = heap_sz;
   162a6:	f8c4 8008 	str.w	r8, [r4, #8]
	h->avail_buckets = 0;
   162aa:	2300      	movs	r3, #0
   162ac:	60e3      	str	r3, [r4, #12]
	return 31 - __builtin_clz(usable_sz);
   162ae:	fab8 f688 	clz	r6, r8
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   162b2:	f1c6 0720 	rsb	r7, r6, #32
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   162b6:	f1c6 0624 	rsb	r6, r6, #36	; 0x24
   162ba:	00b6      	lsls	r6, r6, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   162bc:	3607      	adds	r6, #7
   162be:	ea4f 09d6 	mov.w	r9, r6, lsr #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
   162c2:	f109 0301 	add.w	r3, r9, #1
   162c6:	4543      	cmp	r3, r8
   162c8:	d828      	bhi.n	1631c <sys_heap_init+0xa4>
{
   162ca:	2300      	movs	r3, #0
   162cc:	e039      	b.n	16342 <sys_heap_init+0xca>
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
   162ce:	4f30      	ldr	r7, [pc, #192]	; (16390 <sys_heap_init+0x118>)
   162d0:	f240 12e3 	movw	r2, #483	; 0x1e3
   162d4:	4639      	mov	r1, r7
   162d6:	482f      	ldr	r0, [pc, #188]	; (16394 <sys_heap_init+0x11c>)
   162d8:	f016 f929 	bl	2c52e <assert_print>
   162dc:	f240 11e3 	movw	r1, #483	; 0x1e3
   162e0:	4638      	mov	r0, r7
   162e2:	f016 f91d 	bl	2c520 <assert_post_action>
   162e6:	e7cf      	b.n	16288 <sys_heap_init+0x10>
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
   162e8:	4f29      	ldr	r7, [pc, #164]	; (16390 <sys_heap_init+0x118>)
   162ea:	f44f 72f5 	mov.w	r2, #490	; 0x1ea
   162ee:	4639      	mov	r1, r7
   162f0:	4828      	ldr	r0, [pc, #160]	; (16394 <sys_heap_init+0x11c>)
   162f2:	f016 f91c 	bl	2c52e <assert_print>
   162f6:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
   162fa:	4638      	mov	r0, r7
   162fc:	f016 f910 	bl	2c520 <assert_post_action>
   16300:	e7c4      	b.n	1628c <sys_heap_init+0x14>
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
   16302:	4f23      	ldr	r7, [pc, #140]	; (16390 <sys_heap_init+0x118>)
   16304:	f240 12f3 	movw	r2, #499	; 0x1f3
   16308:	4639      	mov	r1, r7
   1630a:	4822      	ldr	r0, [pc, #136]	; (16394 <sys_heap_init+0x11c>)
   1630c:	f016 f90f 	bl	2c52e <assert_print>
   16310:	f240 11f3 	movw	r1, #499	; 0x1f3
   16314:	4638      	mov	r0, r7
   16316:	f016 f903 	bl	2c520 <assert_post_action>
   1631a:	e7c3      	b.n	162a4 <sys_heap_init+0x2c>
	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
   1631c:	f8df a070 	ldr.w	sl, [pc, #112]	; 16390 <sys_heap_init+0x118>
   16320:	f44f 7201 	mov.w	r2, #516	; 0x204
   16324:	4651      	mov	r1, sl
   16326:	481b      	ldr	r0, [pc, #108]	; (16394 <sys_heap_init+0x11c>)
   16328:	f016 f901 	bl	2c52e <assert_print>
   1632c:	f44f 7101 	mov.w	r1, #516	; 0x204
   16330:	4650      	mov	r0, sl
   16332:	f016 f8f5 	bl	2c520 <assert_post_action>
   16336:	e7c8      	b.n	162ca <sys_heap_init+0x52>

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
   16338:	1d1a      	adds	r2, r3, #4
   1633a:	2100      	movs	r1, #0
   1633c:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
   16340:	3301      	adds	r3, #1
   16342:	42bb      	cmp	r3, r7
   16344:	dbf8      	blt.n	16338 <sys_heap_init+0xc0>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   16346:	ea4f 0349 	mov.w	r3, r9, lsl #1
		((uint16_t *)cmem)[f] = val;
   1634a:	b29b      	uxth	r3, r3
   1634c:	8063      	strh	r3, [r4, #2]
   1634e:	2200      	movs	r2, #0
   16350:	8022      	strh	r2, [r4, #0]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   16352:	f043 0301 	orr.w	r3, r3, #1
   16356:	8063      	strh	r3, [r4, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   16358:	eba8 0809 	sub.w	r8, r8, r9
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   1635c:	ea4f 0148 	mov.w	r1, r8, lsl #1
	void *cmem = &buf[c];
   16360:	f026 0607 	bic.w	r6, r6, #7
		((uint16_t *)cmem)[f] = val;
   16364:	1cb3      	adds	r3, r6, #2
   16366:	52e1      	strh	r1, [r4, r3]
   16368:	f824 9006 	strh.w	r9, [r4, r6]
	void *cmem = &buf[c];
   1636c:	f025 0307 	bic.w	r3, r5, #7
		((uint16_t *)cmem)[f] = val;
   16370:	1ca9      	adds	r1, r5, #2
   16372:	5262      	strh	r2, [r4, r1]
   16374:	4425      	add	r5, r4
   16376:	f824 8003 	strh.w	r8, [r4, r3]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   1637a:	886b      	ldrh	r3, [r5, #2]
   1637c:	f043 0301 	orr.w	r3, r3, #1
   16380:	806b      	strh	r3, [r5, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   16382:	4649      	mov	r1, r9
   16384:	4620      	mov	r0, r4
   16386:	f015 ff84 	bl	2c292 <free_list_add>
}
   1638a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1638e:	bf00      	nop
   16390:	00039120 	.word	0x00039120
   16394:	00031600 	.word	0x00031600

00016398 <extract_decimal>:
 * the referenced text.
 *
 * @return the decoded integer value.
 */
static size_t extract_decimal(const char **str)
{
   16398:	4684      	mov	ip, r0
	const char *sp = *str;
   1639a:	6802      	ldr	r2, [r0, #0]
	size_t val = 0;
   1639c:	2000      	movs	r0, #0

	while (isdigit((int)(unsigned char)*sp)) {
   1639e:	e005      	b.n	163ac <extract_decimal+0x14>
		val = 10U * val + *sp++ - '0';
   163a0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   163a4:	3201      	adds	r2, #1
   163a6:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   163aa:	3830      	subs	r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   163ac:	7813      	ldrb	r3, [r2, #0]
   163ae:	4904      	ldr	r1, [pc, #16]	; (163c0 <extract_decimal+0x28>)
   163b0:	5c59      	ldrb	r1, [r3, r1]
   163b2:	f011 0f04 	tst.w	r1, #4
   163b6:	d1f3      	bne.n	163a0 <extract_decimal+0x8>
	}
	*str = sp;
   163b8:	f8cc 2000 	str.w	r2, [ip]
	return val;
}
   163bc:	4770      	bx	lr
   163be:	bf00      	nop
   163c0:	0003c4c5 	.word	0x0003c4c5

000163c4 <extract_conversion>:
 *
 * @return pointer to the first character that follows the specification.
 */
static inline const char *extract_conversion(struct conversion *conv,
					     const char *sp)
{
   163c4:	b570      	push	{r4, r5, r6, lr}
   163c6:	b082      	sub	sp, #8
   163c8:	4604      	mov	r4, r0
	*conv = (struct conversion) {
   163ca:	2300      	movs	r3, #0
   163cc:	6003      	str	r3, [r0, #0]
   163ce:	6043      	str	r3, [r0, #4]
   163d0:	6083      	str	r3, [r0, #8]
	/* Skip over the opening %.  If the conversion specifier is %,
	 * that's the only thing that should be there, so
	 * fast-exit.
	 */
	++sp;
	if (*sp == '%') {
   163d2:	784b      	ldrb	r3, [r1, #1]
   163d4:	2b25      	cmp	r3, #37	; 0x25
   163d6:	d002      	beq.n	163de <extract_conversion+0x1a>
   163d8:	1c4e      	adds	r6, r1, #1
	bool loop = true;
   163da:	2501      	movs	r5, #1
   163dc:	e01f      	b.n	1641e <extract_conversion+0x5a>
		conv->specifier = *sp++;
   163de:	1c88      	adds	r0, r1, #2
   163e0:	70e3      	strb	r3, [r4, #3]
		return sp;
   163e2:	e146      	b.n	16672 <extract_conversion+0x2ae>
			conv->flag_dash = true;
   163e4:	7823      	ldrb	r3, [r4, #0]
   163e6:	f043 0304 	orr.w	r3, r3, #4
   163ea:	7023      	strb	r3, [r4, #0]
		if (loop) {
   163ec:	b1b5      	cbz	r5, 1641c <extract_conversion+0x58>
			++sp;
   163ee:	3601      	adds	r6, #1
   163f0:	e014      	b.n	1641c <extract_conversion+0x58>
			conv->flag_plus = true;
   163f2:	7823      	ldrb	r3, [r4, #0]
   163f4:	f043 0308 	orr.w	r3, r3, #8
   163f8:	7023      	strb	r3, [r4, #0]
			break;
   163fa:	e7f7      	b.n	163ec <extract_conversion+0x28>
			conv->flag_space = true;
   163fc:	7823      	ldrb	r3, [r4, #0]
   163fe:	f043 0310 	orr.w	r3, r3, #16
   16402:	7023      	strb	r3, [r4, #0]
			break;
   16404:	e7f2      	b.n	163ec <extract_conversion+0x28>
			conv->flag_hash = true;
   16406:	7823      	ldrb	r3, [r4, #0]
   16408:	f043 0320 	orr.w	r3, r3, #32
   1640c:	7023      	strb	r3, [r4, #0]
			break;
   1640e:	e7ed      	b.n	163ec <extract_conversion+0x28>
			conv->flag_zero = true;
   16410:	7823      	ldrb	r3, [r4, #0]
   16412:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   16416:	7023      	strb	r3, [r4, #0]
			break;
   16418:	e7e8      	b.n	163ec <extract_conversion+0x28>
		switch (*sp) {
   1641a:	2500      	movs	r5, #0
	} while (loop);
   1641c:	b345      	cbz	r5, 16470 <extract_conversion+0xac>
		switch (*sp) {
   1641e:	7833      	ldrb	r3, [r6, #0]
   16420:	3b20      	subs	r3, #32
   16422:	2b10      	cmp	r3, #16
   16424:	d8f9      	bhi.n	1641a <extract_conversion+0x56>
   16426:	a201      	add	r2, pc, #4	; (adr r2, 1642c <extract_conversion+0x68>)
   16428:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1642c:	000163fd 	.word	0x000163fd
   16430:	0001641b 	.word	0x0001641b
   16434:	0001641b 	.word	0x0001641b
   16438:	00016407 	.word	0x00016407
   1643c:	0001641b 	.word	0x0001641b
   16440:	0001641b 	.word	0x0001641b
   16444:	0001641b 	.word	0x0001641b
   16448:	0001641b 	.word	0x0001641b
   1644c:	0001641b 	.word	0x0001641b
   16450:	0001641b 	.word	0x0001641b
   16454:	0001641b 	.word	0x0001641b
   16458:	000163f3 	.word	0x000163f3
   1645c:	0001641b 	.word	0x0001641b
   16460:	000163e5 	.word	0x000163e5
   16464:	0001641b 	.word	0x0001641b
   16468:	0001641b 	.word	0x0001641b
   1646c:	00016411 	.word	0x00016411
	if (conv->flag_zero && conv->flag_dash) {
   16470:	7823      	ldrb	r3, [r4, #0]
   16472:	f003 0344 	and.w	r3, r3, #68	; 0x44
   16476:	2b44      	cmp	r3, #68	; 0x44
   16478:	d05f      	beq.n	1653a <extract_conversion+0x176>
	}

	sp = extract_flags(conv, sp);
	sp = extract_width(conv, sp);
   1647a:	9601      	str	r6, [sp, #4]
	conv->width_present = true;
   1647c:	7823      	ldrb	r3, [r4, #0]
   1647e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   16482:	7023      	strb	r3, [r4, #0]
	if (*sp == '*') {
   16484:	7833      	ldrb	r3, [r6, #0]
   16486:	2b2a      	cmp	r3, #42	; 0x2a
   16488:	d05c      	beq.n	16544 <extract_conversion+0x180>
	size_t width = extract_decimal(&sp);
   1648a:	a801      	add	r0, sp, #4
   1648c:	f7ff ff84 	bl	16398 <extract_decimal>
	if (sp != wp) {
   16490:	9b01      	ldr	r3, [sp, #4]
   16492:	429e      	cmp	r6, r3
   16494:	d00f      	beq.n	164b6 <extract_conversion+0xf2>
		conv->width_present = true;
   16496:	7823      	ldrb	r3, [r4, #0]
   16498:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1649c:	7023      	strb	r3, [r4, #0]
		conv->width_value = width;
   1649e:	6060      	str	r0, [r4, #4]
		conv->unsupported |= ((conv->width_value < 0)
   164a0:	b2db      	uxtb	r3, r3
   164a2:	f3c3 0340 	ubfx	r3, r3, #1, #1
				      || (width != (size_t)conv->width_value));
   164a6:	2800      	cmp	r0, #0
   164a8:	db54      	blt.n	16554 <extract_conversion+0x190>
   164aa:	2200      	movs	r2, #0
		conv->unsupported |= ((conv->width_value < 0)
   164ac:	4313      	orrs	r3, r2
   164ae:	7822      	ldrb	r2, [r4, #0]
   164b0:	f363 0241 	bfi	r2, r3, #1, #1
   164b4:	7022      	strb	r2, [r4, #0]
	return sp;
   164b6:	9b01      	ldr	r3, [sp, #4]
	sp = extract_prec(conv, sp);
   164b8:	9301      	str	r3, [sp, #4]
	conv->prec_present = (*sp == '.');
   164ba:	781b      	ldrb	r3, [r3, #0]
   164bc:	2b2e      	cmp	r3, #46	; 0x2e
   164be:	bf14      	ite	ne
   164c0:	2300      	movne	r3, #0
   164c2:	2301      	moveq	r3, #1
   164c4:	7862      	ldrb	r2, [r4, #1]
   164c6:	f363 0241 	bfi	r2, r3, #1, #1
   164ca:	7062      	strb	r2, [r4, #1]
	if (!conv->prec_present) {
   164cc:	2b00      	cmp	r3, #0
   164ce:	d043      	beq.n	16558 <extract_conversion+0x194>
	++sp;
   164d0:	9b01      	ldr	r3, [sp, #4]
   164d2:	1c5a      	adds	r2, r3, #1
   164d4:	9201      	str	r2, [sp, #4]
	if (*sp == '*') {
   164d6:	785b      	ldrb	r3, [r3, #1]
   164d8:	2b2a      	cmp	r3, #42	; 0x2a
   164da:	d03f      	beq.n	1655c <extract_conversion+0x198>
	size_t prec = extract_decimal(&sp);
   164dc:	a801      	add	r0, sp, #4
   164de:	f7ff ff5b 	bl	16398 <extract_decimal>
	conv->prec_value = prec;
   164e2:	60a0      	str	r0, [r4, #8]
	conv->unsupported |= ((conv->prec_value < 0)
   164e4:	7823      	ldrb	r3, [r4, #0]
   164e6:	f3c3 0340 	ubfx	r3, r3, #1, #1
			      || (prec != (size_t)conv->prec_value));
   164ea:	2800      	cmp	r0, #0
   164ec:	db3e      	blt.n	1656c <extract_conversion+0x1a8>
   164ee:	2200      	movs	r2, #0
	conv->unsupported |= ((conv->prec_value < 0)
   164f0:	4313      	orrs	r3, r2
   164f2:	7822      	ldrb	r2, [r4, #0]
   164f4:	f363 0241 	bfi	r2, r3, #1, #1
   164f8:	7022      	strb	r2, [r4, #0]
	return sp;
   164fa:	9801      	ldr	r0, [sp, #4]
	switch (*sp) {
   164fc:	7803      	ldrb	r3, [r0, #0]
   164fe:	3b4c      	subs	r3, #76	; 0x4c
   16500:	2b2e      	cmp	r3, #46	; 0x2e
   16502:	f200 809e 	bhi.w	16642 <extract_conversion+0x27e>
   16506:	e8df f003 	tbb	[pc, r3]
   1650a:	9c91      	.short	0x9c91
   1650c:	9c9c9c9c 	.word	0x9c9c9c9c
   16510:	9c9c9c9c 	.word	0x9c9c9c9c
   16514:	9c9c9c9c 	.word	0x9c9c9c9c
   16518:	9c9c9c9c 	.word	0x9c9c9c9c
   1651c:	9c9c9c9c 	.word	0x9c9c9c9c
   16520:	9c9c9c9c 	.word	0x9c9c9c9c
   16524:	9c339c9c 	.word	0x9c339c9c
   16528:	9c459c57 	.word	0x9c459c57
   1652c:	9c9c9c9c 	.word	0x9c9c9c9c
   16530:	9c8a9c9c 	.word	0x9c8a9c9c
   16534:	9c9c9c9c 	.word	0x9c9c9c9c
   16538:	83          	.byte	0x83
   16539:	00          	.byte	0x00
		conv->flag_zero = false;
   1653a:	7823      	ldrb	r3, [r4, #0]
   1653c:	f36f 1386 	bfc	r3, #6, #1
   16540:	7023      	strb	r3, [r4, #0]
   16542:	e79a      	b.n	1647a <extract_conversion+0xb6>
		conv->width_star = true;
   16544:	7863      	ldrb	r3, [r4, #1]
   16546:	f043 0301 	orr.w	r3, r3, #1
   1654a:	7063      	strb	r3, [r4, #1]
		return ++sp;
   1654c:	4633      	mov	r3, r6
   1654e:	3301      	adds	r3, #1
   16550:	9301      	str	r3, [sp, #4]
   16552:	e7b1      	b.n	164b8 <extract_conversion+0xf4>
				      || (width != (size_t)conv->width_value));
   16554:	2201      	movs	r2, #1
   16556:	e7a9      	b.n	164ac <extract_conversion+0xe8>
		return sp;
   16558:	9801      	ldr	r0, [sp, #4]
   1655a:	e7cf      	b.n	164fc <extract_conversion+0x138>
		conv->prec_star = true;
   1655c:	7863      	ldrb	r3, [r4, #1]
   1655e:	f043 0304 	orr.w	r3, r3, #4
   16562:	7063      	strb	r3, [r4, #1]
		return ++sp;
   16564:	4610      	mov	r0, r2
   16566:	3001      	adds	r0, #1
   16568:	9001      	str	r0, [sp, #4]
   1656a:	e7c7      	b.n	164fc <extract_conversion+0x138>
			      || (prec != (size_t)conv->prec_value));
   1656c:	2201      	movs	r2, #1
   1656e:	e7bf      	b.n	164f0 <extract_conversion+0x12c>
		if (*++sp == 'h') {
   16570:	1c42      	adds	r2, r0, #1
   16572:	7843      	ldrb	r3, [r0, #1]
   16574:	2b68      	cmp	r3, #104	; 0x68
   16576:	d006      	beq.n	16586 <extract_conversion+0x1c2>
			conv->length_mod = LENGTH_H;
   16578:	7863      	ldrb	r3, [r4, #1]
   1657a:	2102      	movs	r1, #2
   1657c:	f361 03c6 	bfi	r3, r1, #3, #4
   16580:	7063      	strb	r3, [r4, #1]
		if (*++sp == 'h') {
   16582:	4610      	mov	r0, r2
   16584:	e01e      	b.n	165c4 <extract_conversion+0x200>
			conv->length_mod = LENGTH_HH;
   16586:	7863      	ldrb	r3, [r4, #1]
   16588:	2201      	movs	r2, #1
   1658a:	f362 03c6 	bfi	r3, r2, #3, #4
   1658e:	7063      	strb	r3, [r4, #1]
			++sp;
   16590:	3002      	adds	r0, #2
   16592:	e017      	b.n	165c4 <extract_conversion+0x200>
		if (*++sp == 'l') {
   16594:	1c42      	adds	r2, r0, #1
   16596:	7843      	ldrb	r3, [r0, #1]
   16598:	2b6c      	cmp	r3, #108	; 0x6c
   1659a:	d006      	beq.n	165aa <extract_conversion+0x1e6>
			conv->length_mod = LENGTH_L;
   1659c:	7863      	ldrb	r3, [r4, #1]
   1659e:	2103      	movs	r1, #3
   165a0:	f361 03c6 	bfi	r3, r1, #3, #4
   165a4:	7063      	strb	r3, [r4, #1]
		if (*++sp == 'l') {
   165a6:	4610      	mov	r0, r2
   165a8:	e00c      	b.n	165c4 <extract_conversion+0x200>
			conv->length_mod = LENGTH_LL;
   165aa:	7863      	ldrb	r3, [r4, #1]
   165ac:	2204      	movs	r2, #4
   165ae:	f362 03c6 	bfi	r3, r2, #3, #4
   165b2:	7063      	strb	r3, [r4, #1]
			++sp;
   165b4:	3002      	adds	r0, #2
   165b6:	e005      	b.n	165c4 <extract_conversion+0x200>
		conv->length_mod = LENGTH_J;
   165b8:	7863      	ldrb	r3, [r4, #1]
   165ba:	2205      	movs	r2, #5
   165bc:	f362 03c6 	bfi	r3, r2, #3, #4
   165c0:	7063      	strb	r3, [r4, #1]
		++sp;
   165c2:	3001      	adds	r0, #1
	conv->specifier = *sp++;
   165c4:	f810 2b01 	ldrb.w	r2, [r0], #1
   165c8:	70e2      	strb	r2, [r4, #3]
	switch (conv->specifier) {
   165ca:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
   165ce:	2b37      	cmp	r3, #55	; 0x37
   165d0:	f200 80a0 	bhi.w	16714 <extract_conversion+0x350>
   165d4:	e8df f003 	tbb	[pc, r3]
   165d8:	9e9e9e5e 	.word	0x9e9e9e5e
   165dc:	9e5e5e5e 	.word	0x9e5e5e5e
   165e0:	9e9e9e9e 	.word	0x9e9e9e9e
   165e4:	9e9e9e9e 	.word	0x9e9e9e9e
   165e8:	9e9e9e9e 	.word	0x9e9e9e9e
   165ec:	4f9e9e9e 	.word	0x4f9e9e9e
   165f0:	9e9e9e9e 	.word	0x9e9e9e9e
   165f4:	9e9e9e9e 	.word	0x9e9e9e9e
   165f8:	3a4f9e5e 	.word	0x3a4f9e5e
   165fc:	9e5e5e5e 	.word	0x9e5e5e5e
   16600:	9e9e9e3a 	.word	0x9e9e9e3a
   16604:	934f879e 	.word	0x934f879e
   16608:	9e939e9e 	.word	0x9e939e9e
   1660c:	4f9e9e4f 	.word	0x4f9e9e4f
		conv->length_mod = LENGTH_Z;
   16610:	7863      	ldrb	r3, [r4, #1]
   16612:	2206      	movs	r2, #6
   16614:	f362 03c6 	bfi	r3, r2, #3, #4
   16618:	7063      	strb	r3, [r4, #1]
		++sp;
   1661a:	3001      	adds	r0, #1
		break;
   1661c:	e7d2      	b.n	165c4 <extract_conversion+0x200>
		conv->length_mod = LENGTH_T;
   1661e:	7863      	ldrb	r3, [r4, #1]
   16620:	2207      	movs	r2, #7
   16622:	f362 03c6 	bfi	r3, r2, #3, #4
   16626:	7063      	strb	r3, [r4, #1]
		++sp;
   16628:	3001      	adds	r0, #1
		break;
   1662a:	e7cb      	b.n	165c4 <extract_conversion+0x200>
		conv->length_mod = LENGTH_UPPER_L;
   1662c:	7863      	ldrb	r3, [r4, #1]
   1662e:	2208      	movs	r2, #8
   16630:	f362 03c6 	bfi	r3, r2, #3, #4
   16634:	7063      	strb	r3, [r4, #1]
		++sp;
   16636:	3001      	adds	r0, #1
		conv->unsupported = true;
   16638:	7823      	ldrb	r3, [r4, #0]
   1663a:	f043 0302 	orr.w	r3, r3, #2
   1663e:	7023      	strb	r3, [r4, #0]
		break;
   16640:	e7c0      	b.n	165c4 <extract_conversion+0x200>
		conv->length_mod = LENGTH_NONE;
   16642:	7863      	ldrb	r3, [r4, #1]
   16644:	f36f 03c6 	bfc	r3, #3, #4
   16648:	7063      	strb	r3, [r4, #1]
		break;
   1664a:	e7bb      	b.n	165c4 <extract_conversion+0x200>
		conv->specifier_cat = SPECIFIER_SINT;
   1664c:	78a3      	ldrb	r3, [r4, #2]
   1664e:	2101      	movs	r1, #1
   16650:	f361 0302 	bfi	r3, r1, #0, #3
   16654:	70a3      	strb	r3, [r4, #2]
		if (conv->length_mod == LENGTH_UPPER_L) {
   16656:	7863      	ldrb	r3, [r4, #1]
   16658:	f003 0378 	and.w	r3, r3, #120	; 0x78
   1665c:	2b40      	cmp	r3, #64	; 0x40
   1665e:	d010      	beq.n	16682 <extract_conversion+0x2be>
		if (conv->specifier == 'c') {
   16660:	2a63      	cmp	r2, #99	; 0x63
   16662:	d013      	beq.n	1668c <extract_conversion+0x2c8>
	conv->unsupported |= unsupported;
   16664:	7823      	ldrb	r3, [r4, #0]
   16666:	f3c3 0240 	ubfx	r2, r3, #1, #1
   1666a:	4315      	orrs	r5, r2
   1666c:	f365 0341 	bfi	r3, r5, #1, #1
   16670:	7023      	strb	r3, [r4, #0]
	sp = extract_length(conv, sp);
	sp = extract_specifier(conv, sp);

	return sp;
}
   16672:	b002      	add	sp, #8
   16674:	bd70      	pop	{r4, r5, r6, pc}
		conv->specifier_cat = SPECIFIER_UINT;
   16676:	78a3      	ldrb	r3, [r4, #2]
   16678:	2102      	movs	r1, #2
   1667a:	f361 0302 	bfi	r3, r1, #0, #3
   1667e:	70a3      	strb	r3, [r4, #2]
   16680:	e7e9      	b.n	16656 <extract_conversion+0x292>
			conv->invalid = true;
   16682:	7821      	ldrb	r1, [r4, #0]
   16684:	f041 0101 	orr.w	r1, r1, #1
   16688:	7021      	strb	r1, [r4, #0]
   1668a:	e7e9      	b.n	16660 <extract_conversion+0x29c>
			unsupported = (conv->length_mod != LENGTH_NONE);
   1668c:	1e1d      	subs	r5, r3, #0
   1668e:	bf18      	it	ne
   16690:	2501      	movne	r5, #1
   16692:	e7e7      	b.n	16664 <extract_conversion+0x2a0>
		conv->specifier_cat = SPECIFIER_FP;
   16694:	78a3      	ldrb	r3, [r4, #2]
   16696:	2104      	movs	r1, #4
   16698:	f361 0302 	bfi	r3, r1, #0, #3
   1669c:	70a3      	strb	r3, [r4, #2]
			|| (conv->specifier == 'A');
   1669e:	2a61      	cmp	r2, #97	; 0x61
   166a0:	d01a      	beq.n	166d8 <extract_conversion+0x314>
   166a2:	2a41      	cmp	r2, #65	; 0x41
   166a4:	d016      	beq.n	166d4 <extract_conversion+0x310>
   166a6:	2200      	movs	r2, #0
		conv->specifier_a = (conv->specifier == 'a')
   166a8:	7863      	ldrb	r3, [r4, #1]
   166aa:	f362 13c7 	bfi	r3, r2, #7, #1
   166ae:	7063      	strb	r3, [r4, #1]
		if (conv->specifier_a
   166b0:	b2db      	uxtb	r3, r3
   166b2:	f994 2001 	ldrsb.w	r2, [r4, #1]
   166b6:	2a00      	cmp	r2, #0
   166b8:	db31      	blt.n	1671e <extract_conversion+0x35a>
		if (conv->length_mod == LENGTH_L) {
   166ba:	f003 0378 	and.w	r3, r3, #120	; 0x78
   166be:	2b18      	cmp	r3, #24
   166c0:	d00c      	beq.n	166dc <extract_conversion+0x318>
		} else if ((conv->length_mod != LENGTH_NONE)
   166c2:	2b00      	cmp	r3, #0
   166c4:	d0ce      	beq.n	16664 <extract_conversion+0x2a0>
			   && (conv->length_mod != LENGTH_UPPER_L)) {
   166c6:	2b40      	cmp	r3, #64	; 0x40
   166c8:	d0cc      	beq.n	16664 <extract_conversion+0x2a0>
			conv->invalid = true;
   166ca:	7823      	ldrb	r3, [r4, #0]
   166cc:	f043 0301 	orr.w	r3, r3, #1
   166d0:	7023      	strb	r3, [r4, #0]
   166d2:	e7c7      	b.n	16664 <extract_conversion+0x2a0>
			|| (conv->specifier == 'A');
   166d4:	2201      	movs	r2, #1
   166d6:	e7e7      	b.n	166a8 <extract_conversion+0x2e4>
   166d8:	2201      	movs	r2, #1
   166da:	e7e5      	b.n	166a8 <extract_conversion+0x2e4>
			conv->length_mod = LENGTH_NONE;
   166dc:	7863      	ldrb	r3, [r4, #1]
   166de:	f36f 03c6 	bfc	r3, #3, #4
   166e2:	7063      	strb	r3, [r4, #1]
   166e4:	e7be      	b.n	16664 <extract_conversion+0x2a0>
		conv->specifier_cat = SPECIFIER_PTR;
   166e6:	78a3      	ldrb	r3, [r4, #2]
   166e8:	2203      	movs	r2, #3
   166ea:	f362 0302 	bfi	r3, r2, #0, #3
   166ee:	70a3      	strb	r3, [r4, #2]
		if (conv->length_mod == LENGTH_UPPER_L) {
   166f0:	7863      	ldrb	r3, [r4, #1]
   166f2:	f003 0378 	and.w	r3, r3, #120	; 0x78
   166f6:	2b40      	cmp	r3, #64	; 0x40
   166f8:	d1b4      	bne.n	16664 <extract_conversion+0x2a0>
			unsupported = true;
   166fa:	2501      	movs	r5, #1
   166fc:	e7b2      	b.n	16664 <extract_conversion+0x2a0>
		conv->specifier_cat = SPECIFIER_PTR;
   166fe:	78a3      	ldrb	r3, [r4, #2]
   16700:	2203      	movs	r2, #3
   16702:	f362 0302 	bfi	r3, r2, #0, #3
   16706:	70a3      	strb	r3, [r4, #2]
		if (conv->length_mod != LENGTH_NONE) {
   16708:	7863      	ldrb	r3, [r4, #1]
   1670a:	f013 0f78 	tst.w	r3, #120	; 0x78
   1670e:	d0a9      	beq.n	16664 <extract_conversion+0x2a0>
			unsupported = true;
   16710:	2501      	movs	r5, #1
   16712:	e7a7      	b.n	16664 <extract_conversion+0x2a0>
		conv->invalid = true;
   16714:	7823      	ldrb	r3, [r4, #0]
   16716:	f043 0301 	orr.w	r3, r3, #1
   1671a:	7023      	strb	r3, [r4, #0]
		break;
   1671c:	e7a2      	b.n	16664 <extract_conversion+0x2a0>
			unsupported = true;
   1671e:	2501      	movs	r5, #1
   16720:	e7a0      	b.n	16664 <extract_conversion+0x2a0>
   16722:	bf00      	nop

00016724 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
   16724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16728:	b083      	sub	sp, #12
   1672a:	4604      	mov	r4, r0
   1672c:	460d      	mov	r5, r1
   1672e:	9201      	str	r2, [sp, #4]
   16730:	469a      	mov	sl, r3
   16732:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	bool upcase = isupper((int)conv->specifier);
   16734:	78d3      	ldrb	r3, [r2, #3]
   16736:	4a32      	ldr	r2, [pc, #200]	; (16800 <encode_uint+0xdc>)
   16738:	f813 b002 	ldrb.w	fp, [r3, r2]
   1673c:	f00b 0b03 	and.w	fp, fp, #3
	switch (specifier) {
   16740:	2b6f      	cmp	r3, #111	; 0x6f
   16742:	d00f      	beq.n	16764 <encode_uint+0x40>
   16744:	d906      	bls.n	16754 <encode_uint+0x30>
   16746:	2b70      	cmp	r3, #112	; 0x70
   16748:	d00f      	beq.n	1676a <encode_uint+0x46>
   1674a:	2b78      	cmp	r3, #120	; 0x78
   1674c:	d110      	bne.n	16770 <encode_uint+0x4c>
		return 16;
   1674e:	f04f 0910 	mov.w	r9, #16
   16752:	e023      	b.n	1679c <encode_uint+0x78>
	switch (specifier) {
   16754:	2b58      	cmp	r3, #88	; 0x58
   16756:	d002      	beq.n	1675e <encode_uint+0x3a>
   16758:	f04f 090a 	mov.w	r9, #10
   1675c:	e01e      	b.n	1679c <encode_uint+0x78>
		return 16;
   1675e:	f04f 0910 	mov.w	r9, #16
   16762:	e01b      	b.n	1679c <encode_uint+0x78>
		return 8;
   16764:	f04f 0908 	mov.w	r9, #8
   16768:	e018      	b.n	1679c <encode_uint+0x78>
		return 16;
   1676a:	f04f 0910 	mov.w	r9, #16
   1676e:	e015      	b.n	1679c <encode_uint+0x78>
	switch (specifier) {
   16770:	f04f 090a 	mov.w	r9, #10
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);
   16774:	e012      	b.n	1679c <encode_uint+0x78>

	do {
		unsigned int lsv = (unsigned int)(value % radix);

		*--bp = (lsv <= 9) ? ('0' + lsv)
   16776:	b2d2      	uxtb	r2, r2
   16778:	3230      	adds	r2, #48	; 0x30
   1677a:	b2d2      	uxtb	r2, r2
   1677c:	f806 2d01 	strb.w	r2, [r6, #-1]!
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
   16780:	463a      	mov	r2, r7
   16782:	4643      	mov	r3, r8
   16784:	4620      	mov	r0, r4
   16786:	4629      	mov	r1, r5
   16788:	f7ea fa26 	bl	bd8 <__aeabi_uldivmod>
	} while ((value != 0) && (bps < bp));
   1678c:	42bc      	cmp	r4, r7
   1678e:	f175 0300 	sbcs.w	r3, r5, #0
   16792:	d319      	bcc.n	167c8 <encode_uint+0xa4>
   16794:	4556      	cmp	r6, sl
   16796:	d917      	bls.n	167c8 <encode_uint+0xa4>
		value /= radix;
   16798:	4604      	mov	r4, r0
   1679a:	460d      	mov	r5, r1
		unsigned int lsv = (unsigned int)(value % radix);
   1679c:	f04f 0800 	mov.w	r8, #0
   167a0:	464f      	mov	r7, r9
   167a2:	464a      	mov	r2, r9
   167a4:	4643      	mov	r3, r8
   167a6:	4620      	mov	r0, r4
   167a8:	4629      	mov	r1, r5
   167aa:	f7ea fa15 	bl	bd8 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   167ae:	2a09      	cmp	r2, #9
   167b0:	d9e1      	bls.n	16776 <encode_uint+0x52>
   167b2:	f1bb 0f01 	cmp.w	fp, #1
   167b6:	d003      	beq.n	167c0 <encode_uint+0x9c>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
   167b8:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
   167ba:	3257      	adds	r2, #87	; 0x57
   167bc:	b2d2      	uxtb	r2, r2
   167be:	e7dd      	b.n	1677c <encode_uint+0x58>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
   167c0:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
   167c2:	3237      	adds	r2, #55	; 0x37
   167c4:	b2d2      	uxtb	r2, r2
   167c6:	e7d9      	b.n	1677c <encode_uint+0x58>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
   167c8:	9b01      	ldr	r3, [sp, #4]
   167ca:	781b      	ldrb	r3, [r3, #0]
   167cc:	f013 0f20 	tst.w	r3, #32
   167d0:	d005      	beq.n	167de <encode_uint+0xba>
		if (radix == 8) {
   167d2:	f1b9 0f08 	cmp.w	r9, #8
   167d6:	d006      	beq.n	167e6 <encode_uint+0xc2>
			conv->altform_0 = true;
		} else if (radix == 16) {
   167d8:	f1b9 0f10 	cmp.w	r9, #16
   167dc:	d009      	beq.n	167f2 <encode_uint+0xce>
			;
		}
	}

	return bp;
}
   167de:	4630      	mov	r0, r6
   167e0:	b003      	add	sp, #12
   167e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			conv->altform_0 = true;
   167e6:	9a01      	ldr	r2, [sp, #4]
   167e8:	7893      	ldrb	r3, [r2, #2]
   167ea:	f043 0308 	orr.w	r3, r3, #8
   167ee:	7093      	strb	r3, [r2, #2]
   167f0:	e7f5      	b.n	167de <encode_uint+0xba>
			conv->altform_0c = true;
   167f2:	9a01      	ldr	r2, [sp, #4]
   167f4:	7893      	ldrb	r3, [r2, #2]
   167f6:	f043 0310 	orr.w	r3, r3, #16
   167fa:	7093      	strb	r3, [r2, #2]
   167fc:	e7ef      	b.n	167de <encode_uint+0xba>
   167fe:	bf00      	nop
   16800:	0003c4c5 	.word	0x0003c4c5

00016804 <encode_float>:
			  struct conversion *conv,
			  int precision,
			  char *sign,
			  char *bps,
			  const char **bpe)
{
   16804:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16808:	b087      	sub	sp, #28
   1680a:	4617      	mov	r7, r2
   1680c:	461e      	mov	r6, r3
   1680e:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
	char *buf = bps;

	/* Prepend the sign: '-' if negative, flags control
	 * non-negative behavior.
	 */
	if ((u.u64 & SIGN_MASK) != 0U) {
   16812:	4602      	mov	r2, r0
   16814:	1e0b      	subs	r3, r1, #0
   16816:	db07      	blt.n	16828 <encode_float+0x24>
		*sign = '-';
	} else if (conv->flag_plus) {
   16818:	7839      	ldrb	r1, [r7, #0]
   1681a:	f011 0f08 	tst.w	r1, #8
   1681e:	d014      	beq.n	1684a <encode_float+0x46>
		*sign = '+';
   16820:	212b      	movs	r1, #43	; 0x2b
   16822:	9810      	ldr	r0, [sp, #64]	; 0x40
   16824:	7001      	strb	r1, [r0, #0]
   16826:	e002      	b.n	1682e <encode_float+0x2a>
		*sign = '-';
   16828:	212d      	movs	r1, #45	; 0x2d
   1682a:	9810      	ldr	r0, [sp, #64]	; 0x40
   1682c:	7001      	strb	r1, [r0, #0]
	}

	/* Extract the non-negative offset exponent and fraction.  Record
	 * whether the value is subnormal.
	 */
	char c = conv->specifier;
   1682e:	f897 8003 	ldrb.w	r8, [r7, #3]
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
   16832:	f3c3 540a 	ubfx	r4, r3, #20, #11
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
   16836:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1683a:	9204      	str	r2, [sp, #16]
   1683c:	9305      	str	r3, [sp, #20]
	bool is_subnormal = (expo == 0) && (fract != 0);
   1683e:	b95c      	cbnz	r4, 16858 <encode_float+0x54>
   16840:	ea52 0103 	orrs.w	r1, r2, r3
   16844:	d128      	bne.n	16898 <encode_float+0x94>
   16846:	2100      	movs	r1, #0
   16848:	e007      	b.n	1685a <encode_float+0x56>
	} else if (conv->flag_space) {
   1684a:	f011 0f10 	tst.w	r1, #16
   1684e:	d0ee      	beq.n	1682e <encode_float+0x2a>
		*sign = ' ';
   16850:	2120      	movs	r1, #32
   16852:	9810      	ldr	r0, [sp, #64]	; 0x40
   16854:	7001      	strb	r1, [r0, #0]
   16856:	e7ea      	b.n	1682e <encode_float+0x2a>
	bool is_subnormal = (expo == 0) && (fract != 0);
   16858:	2100      	movs	r1, #0

	/* Exponent of all-ones signals infinity or NaN, which are
	 * text constants regardless of specifier.
	 */
	if (expo == BIT_MASK(EXPONENT_BITS)) {
   1685a:	f240 70ff 	movw	r0, #2047	; 0x7ff
   1685e:	4284      	cmp	r4, r0
   16860:	d01c      	beq.n	1689c <encode_float+0x98>
		*bpe = buf;
		return bps;
	}

	/* The case of an F specifier is no longer relevant. */
	if (c == 'F') {
   16862:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
   16866:	d05d      	beq.n	16924 <encode_float+0x120>

	/* Remainder of code operates on a 64-bit fraction, so shift up (and
	 * discard garbage from the exponent where the implicit 1 would be
	 * stored).
	 */
	fract <<= EXPONENT_BITS;
   16868:	02db      	lsls	r3, r3, #11
   1686a:	ea43 5352 	orr.w	r3, r3, r2, lsr #21
   1686e:	02d2      	lsls	r2, r2, #11
   16870:	9204      	str	r2, [sp, #16]
   16872:	9305      	str	r3, [sp, #20]
	fract &= ~SIGN_MASK;
   16874:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   16878:	9305      	str	r3, [sp, #20]

	/* Non-zero values need normalization. */
	if ((expo | fract) != 0) {
   1687a:	4322      	orrs	r2, r4
   1687c:	ea43 73e4 	orr.w	r3, r3, r4, asr #31
   16880:	4313      	orrs	r3, r2
   16882:	d007      	beq.n	16894 <encode_float+0x90>
		if (is_subnormal) {
   16884:	2900      	cmp	r1, #0
   16886:	d151      	bne.n	1692c <encode_float+0x128>
		}
		/* Adjust the offset exponent to be signed rather than offset,
		 * and set the implicit 1 bit in the (shifted) 53-bit
		 * fraction.
		 */
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
   16888:	f2a4 34fe 	subw	r4, r4, #1022	; 0x3fe
		fract |= BIT_63;
   1688c:	9b05      	ldr	r3, [sp, #20]
   1688e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   16892:	9305      	str	r3, [sp, #20]
		c = 'f';
   16894:	2500      	movs	r5, #0
   16896:	e06a      	b.n	1696e <encode_float+0x16a>
	bool is_subnormal = (expo == 0) && (fract != 0);
   16898:	2101      	movs	r1, #1
   1689a:	e7de      	b.n	1685a <encode_float+0x56>
		if (fract == 0) {
   1689c:	4313      	orrs	r3, r2
   1689e:	d124      	bne.n	168ea <encode_float+0xe6>
			if (isupper((unsigned char)c)) {
   168a0:	4b9d      	ldr	r3, [pc, #628]	; (16b18 <encode_float+0x314>)
   168a2:	f818 3003 	ldrb.w	r3, [r8, r3]
   168a6:	f003 0303 	and.w	r3, r3, #3
   168aa:	2b01      	cmp	r3, #1
   168ac:	d011      	beq.n	168d2 <encode_float+0xce>
				*buf++ = 'i';
   168ae:	2369      	movs	r3, #105	; 0x69
   168b0:	f889 3000 	strb.w	r3, [r9]
				*buf++ = 'n';
   168b4:	236e      	movs	r3, #110	; 0x6e
   168b6:	f889 3001 	strb.w	r3, [r9, #1]
				*buf++ = 'f';
   168ba:	f109 0203 	add.w	r2, r9, #3
   168be:	2366      	movs	r3, #102	; 0x66
   168c0:	f889 3002 	strb.w	r3, [r9, #2]
		conv->flag_zero = false;
   168c4:	783b      	ldrb	r3, [r7, #0]
   168c6:	f36f 1386 	bfc	r3, #6, #1
   168ca:	703b      	strb	r3, [r7, #0]
		*bpe = buf;
   168cc:	9b12      	ldr	r3, [sp, #72]	; 0x48
   168ce:	601a      	str	r2, [r3, #0]
		return bps;
   168d0:	e178      	b.n	16bc4 <encode_float+0x3c0>
				*buf++ = 'I';
   168d2:	2349      	movs	r3, #73	; 0x49
   168d4:	f889 3000 	strb.w	r3, [r9]
				*buf++ = 'N';
   168d8:	234e      	movs	r3, #78	; 0x4e
   168da:	f889 3001 	strb.w	r3, [r9, #1]
				*buf++ = 'F';
   168de:	f109 0203 	add.w	r2, r9, #3
   168e2:	2346      	movs	r3, #70	; 0x46
   168e4:	f889 3002 	strb.w	r3, [r9, #2]
   168e8:	e7ec      	b.n	168c4 <encode_float+0xc0>
			if (isupper((unsigned char)c)) {
   168ea:	4b8b      	ldr	r3, [pc, #556]	; (16b18 <encode_float+0x314>)
   168ec:	f818 3003 	ldrb.w	r3, [r8, r3]
   168f0:	f003 0303 	and.w	r3, r3, #3
   168f4:	2b01      	cmp	r3, #1
   168f6:	d00a      	beq.n	1690e <encode_float+0x10a>
				*buf++ = 'n';
   168f8:	236e      	movs	r3, #110	; 0x6e
   168fa:	f889 3000 	strb.w	r3, [r9]
				*buf++ = 'a';
   168fe:	2261      	movs	r2, #97	; 0x61
   16900:	f889 2001 	strb.w	r2, [r9, #1]
				*buf++ = 'n';
   16904:	f109 0203 	add.w	r2, r9, #3
   16908:	f889 3002 	strb.w	r3, [r9, #2]
   1690c:	e7da      	b.n	168c4 <encode_float+0xc0>
				*buf++ = 'N';
   1690e:	234e      	movs	r3, #78	; 0x4e
   16910:	f889 3000 	strb.w	r3, [r9]
				*buf++ = 'A';
   16914:	2241      	movs	r2, #65	; 0x41
   16916:	f889 2001 	strb.w	r2, [r9, #1]
				*buf++ = 'N';
   1691a:	f109 0203 	add.w	r2, r9, #3
   1691e:	f889 3002 	strb.w	r3, [r9, #2]
   16922:	e7cf      	b.n	168c4 <encode_float+0xc0>
		c = 'f';
   16924:	f04f 0866 	mov.w	r8, #102	; 0x66
   16928:	e79e      	b.n	16868 <encode_float+0x64>
				expo--;
   1692a:	3c01      	subs	r4, #1
			while (((fract <<= 1) & BIT_63) == 0) {
   1692c:	9b04      	ldr	r3, [sp, #16]
   1692e:	9a05      	ldr	r2, [sp, #20]
   16930:	18db      	adds	r3, r3, r3
   16932:	4152      	adcs	r2, r2
   16934:	9304      	str	r3, [sp, #16]
   16936:	9205      	str	r2, [sp, #20]
   16938:	2a00      	cmp	r2, #0
   1693a:	daf6      	bge.n	1692a <encode_float+0x126>
   1693c:	e7a4      	b.n	16888 <encode_float+0x84>
		/*
		 * Make room to allow a multiplication by 5 without overflow.
		 * We test only the top part for faster code.
		 */
		do {
			fract >>= 1;
   1693e:	9b05      	ldr	r3, [sp, #20]
   16940:	9a04      	ldr	r2, [sp, #16]
   16942:	0852      	lsrs	r2, r2, #1
   16944:	ea42 72c3 	orr.w	r2, r2, r3, lsl #31
   16948:	085b      	lsrs	r3, r3, #1
   1694a:	9204      	str	r2, [sp, #16]
   1694c:	9305      	str	r3, [sp, #20]
			expo++;
   1694e:	4621      	mov	r1, r4
   16950:	3401      	adds	r4, #1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
   16952:	f1b3 3f33 	cmp.w	r3, #858993459	; 0x33333333
   16956:	d2f2      	bcs.n	1693e <encode_float+0x13a>

		/* Perform fract * 5 * 2 / 10 */
		fract *= 5U;
   16958:	009c      	lsls	r4, r3, #2
   1695a:	ea44 7492 	orr.w	r4, r4, r2, lsr #30
   1695e:	0090      	lsls	r0, r2, #2
   16960:	1882      	adds	r2, r0, r2
   16962:	eb43 0304 	adc.w	r3, r3, r4
   16966:	9204      	str	r2, [sp, #16]
   16968:	9305      	str	r3, [sp, #20]
		expo++;
   1696a:	1c8c      	adds	r4, r1, #2
		decexp--;
   1696c:	3d01      	subs	r5, #1
	while (expo < -2) {
   1696e:	f114 0f02 	cmn.w	r4, #2
   16972:	dbe4      	blt.n	1693e <encode_float+0x13a>
   16974:	e014      	b.n	169a0 <encode_float+0x19c>
		/*
		 * Perform fract / 5 / 2 * 10.
		 * The +2 is there to do round the result of the division
		 * by 5 not to lose too much precision in extreme cases.
		 */
		fract += 2;
   16976:	9b04      	ldr	r3, [sp, #16]
   16978:	3302      	adds	r3, #2
   1697a:	9a05      	ldr	r2, [sp, #20]
   1697c:	f142 0200 	adc.w	r2, r2, #0
   16980:	9304      	str	r3, [sp, #16]
   16982:	9205      	str	r2, [sp, #20]
		_ldiv5(&fract);
   16984:	a804      	add	r0, sp, #16
   16986:	f015 fd2e 	bl	2c3e6 <_ldiv5>
		expo--;
   1698a:	3c01      	subs	r4, #1
		decexp++;
   1698c:	3501      	adds	r5, #1

		/* Bring back our fractional number to full scale */
		do {
			fract <<= 1;
   1698e:	9904      	ldr	r1, [sp, #16]
   16990:	9b05      	ldr	r3, [sp, #20]
   16992:	1849      	adds	r1, r1, r1
   16994:	415b      	adcs	r3, r3
   16996:	9104      	str	r1, [sp, #16]
   16998:	9305      	str	r3, [sp, #20]
			expo--;
   1699a:	3c01      	subs	r4, #1
		} while (!(fract & BIT_63));
   1699c:	2b00      	cmp	r3, #0
   1699e:	daf6      	bge.n	1698e <encode_float+0x18a>
	while (expo > 0) {
   169a0:	2c00      	cmp	r4, #0
   169a2:	dce8      	bgt.n	16976 <encode_float+0x172>
	/*
	 * The binary fractional point is located somewhere above bit 63.
	 * Move it between bits 59 and 60 to give 4 bits of room to the
	 * integer part.
	 */
	fract >>= (4 - expo);
   169a4:	f1c4 0104 	rsb	r1, r4, #4
   169a8:	9a05      	ldr	r2, [sp, #20]
   169aa:	341c      	adds	r4, #28
   169ac:	f1a1 0020 	sub.w	r0, r1, #32
   169b0:	9b04      	ldr	r3, [sp, #16]
   169b2:	40cb      	lsrs	r3, r1
   169b4:	fa02 f404 	lsl.w	r4, r2, r4
   169b8:	4323      	orrs	r3, r4
   169ba:	fa22 f000 	lsr.w	r0, r2, r0
   169be:	4303      	orrs	r3, r0
   169c0:	40ca      	lsrs	r2, r1
   169c2:	9304      	str	r3, [sp, #16]
   169c4:	9205      	str	r2, [sp, #20]

	if ((c == 'g') || (c == 'G')) {
   169c6:	f1b8 0f67 	cmp.w	r8, #103	; 0x67
   169ca:	d014      	beq.n	169f6 <encode_float+0x1f2>
   169cc:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
   169d0:	d011      	beq.n	169f6 <encode_float+0x1f2>
	bool prune_zero = false;
   169d2:	f04f 0b00 	mov.w	fp, #0
			prune_zero = true;
		}
	}

	int decimals;
	if (c == 'f') {
   169d6:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
   169da:	d02a      	beq.n	16a32 <encode_float+0x22e>
		decimals = precision + decexp;
		if (decimals < 0) {
			decimals = 0;
		}
	} else {
		decimals = precision + 1;
   169dc:	f106 0a01 	add.w	sl, r6, #1
	}

	int digit_count = 16;
   169e0:	2310      	movs	r3, #16
   169e2:	9303      	str	r3, [sp, #12]

	if (decimals > 16) {
   169e4:	459a      	cmp	sl, r3
   169e6:	dd00      	ble.n	169ea <encode_float+0x1e6>
		decimals = 16;
   169e8:	469a      	mov	sl, r3
	}

	/* Round the value to the last digit being printed. */
	uint64_t round = BIT64(59); /* 0.5 */
   169ea:	2200      	movs	r2, #0
   169ec:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   169f0:	e9cd 2300 	strd	r2, r3, [sp]
	while (decimals--) {
   169f4:	e029      	b.n	16a4a <encode_float+0x246>
		if (decexp < (-4 + 1) || decexp > precision) {
   169f6:	f115 0f03 	cmn.w	r5, #3
   169fa:	db01      	blt.n	16a00 <encode_float+0x1fc>
   169fc:	42b5      	cmp	r5, r6
   169fe:	dd11      	ble.n	16a24 <encode_float+0x220>
			c += 'e' - 'g';  /* e or E */
   16a00:	f1a8 0802 	sub.w	r8, r8, #2
   16a04:	fa5f f888 	uxtb.w	r8, r8
			if (precision > 0) {
   16a08:	2e00      	cmp	r6, #0
   16a0a:	dd00      	ble.n	16a0e <encode_float+0x20a>
				precision--;
   16a0c:	3e01      	subs	r6, #1
		if (!conv->flag_hash && (precision > 0)) {
   16a0e:	783b      	ldrb	r3, [r7, #0]
   16a10:	f3c3 1b40 	ubfx	fp, r3, #5, #1
   16a14:	f013 0f20 	tst.w	r3, #32
   16a18:	d108      	bne.n	16a2c <encode_float+0x228>
   16a1a:	2e00      	cmp	r6, #0
   16a1c:	dddb      	ble.n	169d6 <encode_float+0x1d2>
			prune_zero = true;
   16a1e:	f04f 0b01 	mov.w	fp, #1
   16a22:	e7d8      	b.n	169d6 <encode_float+0x1d2>
			precision -= decexp;
   16a24:	1b76      	subs	r6, r6, r5
			c = 'f';
   16a26:	f04f 0866 	mov.w	r8, #102	; 0x66
   16a2a:	e7f0      	b.n	16a0e <encode_float+0x20a>
	bool prune_zero = false;
   16a2c:	f04f 0b00 	mov.w	fp, #0
   16a30:	e7d1      	b.n	169d6 <encode_float+0x1d2>
		if (decimals < 0) {
   16a32:	eb15 0a06 	adds.w	sl, r5, r6
   16a36:	d5d3      	bpl.n	169e0 <encode_float+0x1dc>
	int digit_count = 16;
   16a38:	2310      	movs	r3, #16
   16a3a:	9303      	str	r3, [sp, #12]
			decimals = 0;
   16a3c:	f04f 0a00 	mov.w	sl, #0
   16a40:	e7d3      	b.n	169ea <encode_float+0x1e6>
		_ldiv10(&round);
   16a42:	4668      	mov	r0, sp
   16a44:	f015 fcea 	bl	2c41c <_ldiv10>
	while (decimals--) {
   16a48:	46a2      	mov	sl, r4
   16a4a:	f10a 34ff 	add.w	r4, sl, #4294967295	; 0xffffffff
   16a4e:	f1ba 0f00 	cmp.w	sl, #0
   16a52:	d1f6      	bne.n	16a42 <encode_float+0x23e>
	}
	fract += round;
   16a54:	9b04      	ldr	r3, [sp, #16]
   16a56:	9a00      	ldr	r2, [sp, #0]
   16a58:	189b      	adds	r3, r3, r2
   16a5a:	9a05      	ldr	r2, [sp, #20]
   16a5c:	9901      	ldr	r1, [sp, #4]
   16a5e:	eb42 0201 	adc.w	r2, r2, r1
   16a62:	9304      	str	r3, [sp, #16]
   16a64:	9205      	str	r2, [sp, #20]
	/* Make sure rounding didn't make fract >= 1.0 */
	if (fract >= BIT64(60)) {
   16a66:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   16a6a:	4299      	cmp	r1, r3
   16a6c:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
   16a70:	4193      	sbcs	r3, r2
   16a72:	d306      	bcc.n	16a82 <encode_float+0x27e>
		_ldiv10(&fract);
		decexp++;
	}

	if (c == 'f') {
   16a74:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
   16a78:	d138      	bne.n	16aec <encode_float+0x2e8>
		if (decexp > 0) {
   16a7a:	2d00      	cmp	r5, #0
   16a7c:	dd31      	ble.n	16ae2 <encode_float+0x2de>
	char *buf = bps;
   16a7e:	464c      	mov	r4, r9
   16a80:	e00b      	b.n	16a9a <encode_float+0x296>
		_ldiv10(&fract);
   16a82:	a804      	add	r0, sp, #16
   16a84:	f015 fcca 	bl	2c41c <_ldiv10>
		decexp++;
   16a88:	3501      	adds	r5, #1
   16a8a:	e7f3      	b.n	16a74 <encode_float+0x270>
			/* Emit the digits above the decimal point. */
			while (decexp > 0 && digit_count > 0) {
				*buf++ = _get_digit(&fract, &digit_count);
   16a8c:	a903      	add	r1, sp, #12
   16a8e:	a804      	add	r0, sp, #16
   16a90:	f015 fcd0 	bl	2c434 <_get_digit>
   16a94:	f804 0b01 	strb.w	r0, [r4], #1
				decexp--;
   16a98:	3d01      	subs	r5, #1
			while (decexp > 0 && digit_count > 0) {
   16a9a:	2d00      	cmp	r5, #0
   16a9c:	dd02      	ble.n	16aa4 <encode_float+0x2a0>
   16a9e:	9b03      	ldr	r3, [sp, #12]
   16aa0:	2b00      	cmp	r3, #0
   16aa2:	dcf3      	bgt.n	16a8c <encode_float+0x288>
			}

			conv->pad0_value = decexp;
   16aa4:	607d      	str	r5, [r7, #4]

			decexp = 0;
   16aa6:	4655      	mov	r5, sl
		}

		/* Emit the decimal point only if required by the alternative
		 * format, or if more digits are to follow.
		 */
		if (conv->flag_hash || (precision > 0)) {
   16aa8:	783b      	ldrb	r3, [r7, #0]
   16aaa:	f013 0f20 	tst.w	r3, #32
   16aae:	d101      	bne.n	16ab4 <encode_float+0x2b0>
   16ab0:	2e00      	cmp	r6, #0
   16ab2:	dd02      	ble.n	16aba <encode_float+0x2b6>
			*buf++ = '.';
   16ab4:	232e      	movs	r3, #46	; 0x2e
   16ab6:	f804 3b01 	strb.w	r3, [r4], #1
		}

		if (decexp < 0 && precision > 0) {
   16aba:	2d00      	cmp	r5, #0
   16abc:	da35      	bge.n	16b2a <encode_float+0x326>
   16abe:	2e00      	cmp	r6, #0
   16ac0:	dd33      	ble.n	16b2a <encode_float+0x326>
			conv->pad0_value = -decexp;
   16ac2:	426b      	negs	r3, r5
   16ac4:	607b      	str	r3, [r7, #4]
			if (conv->pad0_value > precision) {
   16ac6:	429e      	cmp	r6, r3
   16ac8:	da00      	bge.n	16acc <encode_float+0x2c8>
				conv->pad0_value = precision;
   16aca:	607e      	str	r6, [r7, #4]
			}

			precision -= conv->pad0_value;
   16acc:	687b      	ldr	r3, [r7, #4]
   16ace:	1af6      	subs	r6, r6, r3
			conv->pad_postdp = (conv->pad0_value > 0);
   16ad0:	2b00      	cmp	r3, #0
   16ad2:	bfd4      	ite	le
   16ad4:	2300      	movle	r3, #0
   16ad6:	2301      	movgt	r3, #1
   16ad8:	78ba      	ldrb	r2, [r7, #2]
   16ada:	f363 1245 	bfi	r2, r3, #5, #1
   16ade:	70ba      	strb	r2, [r7, #2]
   16ae0:	e023      	b.n	16b2a <encode_float+0x326>
			*buf++ = '0';
   16ae2:	464c      	mov	r4, r9
   16ae4:	2330      	movs	r3, #48	; 0x30
   16ae6:	f804 3b01 	strb.w	r3, [r4], #1
   16aea:	e7dd      	b.n	16aa8 <encode_float+0x2a4>
		}
	} else { /* e or E */
		/* Emit the one digit before the decimal.  If it's not zero,
		 * this is significant so reduce the base-10 exponent.
		 */
		*buf = _get_digit(&fract, &digit_count);
   16aec:	a903      	add	r1, sp, #12
   16aee:	a804      	add	r0, sp, #16
   16af0:	f015 fca0 	bl	2c434 <_get_digit>
   16af4:	464c      	mov	r4, r9
   16af6:	f804 0b01 	strb.w	r0, [r4], #1
		if (*buf++ != '0') {
   16afa:	2830      	cmp	r0, #48	; 0x30
   16afc:	d000      	beq.n	16b00 <encode_float+0x2fc>
			decexp--;
   16afe:	3d01      	subs	r5, #1
		}

		/* Emit the decimal point only if required by the alternative
		 * format, or if more digits are to follow.
		 */
		if (conv->flag_hash || (precision > 0)) {
   16b00:	783b      	ldrb	r3, [r7, #0]
   16b02:	f013 0f20 	tst.w	r3, #32
   16b06:	d101      	bne.n	16b0c <encode_float+0x308>
   16b08:	2e00      	cmp	r6, #0
   16b0a:	dd0e      	ble.n	16b2a <encode_float+0x326>
			*buf++ = '.';
   16b0c:	f109 0402 	add.w	r4, r9, #2
   16b10:	232e      	movs	r3, #46	; 0x2e
   16b12:	f889 3001 	strb.w	r3, [r9, #1]
   16b16:	e008      	b.n	16b2a <encode_float+0x326>
   16b18:	0003c4c5 	.word	0x0003c4c5
		}
	}

	while (precision > 0 && digit_count > 0) {
		*buf++ = _get_digit(&fract, &digit_count);
   16b1c:	a903      	add	r1, sp, #12
   16b1e:	a804      	add	r0, sp, #16
   16b20:	f015 fc88 	bl	2c434 <_get_digit>
   16b24:	f804 0b01 	strb.w	r0, [r4], #1
		precision--;
   16b28:	3e01      	subs	r6, #1
	while (precision > 0 && digit_count > 0) {
   16b2a:	2e00      	cmp	r6, #0
   16b2c:	dd02      	ble.n	16b34 <encode_float+0x330>
   16b2e:	9b03      	ldr	r3, [sp, #12]
   16b30:	2b00      	cmp	r3, #0
   16b32:	dcf3      	bgt.n	16b1c <encode_float+0x318>
	}

	conv->pad0_pre_exp = precision;
   16b34:	60be      	str	r6, [r7, #8]

	if (prune_zero) {
   16b36:	f1bb 0f00 	cmp.w	fp, #0
   16b3a:	d009      	beq.n	16b50 <encode_float+0x34c>
		conv->pad0_pre_exp = 0;
   16b3c:	2300      	movs	r3, #0
   16b3e:	60bb      	str	r3, [r7, #8]
		while (*--buf == '0') {
   16b40:	4623      	mov	r3, r4
   16b42:	461c      	mov	r4, r3
   16b44:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   16b48:	2a30      	cmp	r2, #48	; 0x30
   16b4a:	d0fa      	beq.n	16b42 <encode_float+0x33e>
			;
		}
		if (*buf != '.') {
   16b4c:	2a2e      	cmp	r2, #46	; 0x2e
   16b4e:	d03d      	beq.n	16bcc <encode_float+0x3c8>
			buf++;
		}
	}

	/* Emit the explicit exponent, if format requires it. */
	if ((c == 'e') || (c == 'E')) {
   16b50:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
   16b54:	d002      	beq.n	16b5c <encode_float+0x358>
   16b56:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
   16b5a:	d126      	bne.n	16baa <encode_float+0x3a6>
		*buf++ = c;
   16b5c:	f884 8000 	strb.w	r8, [r4]
		if (decexp < 0) {
   16b60:	2d00      	cmp	r5, #0
   16b62:	db35      	blt.n	16bd0 <encode_float+0x3cc>
			decexp = -decexp;
			*buf++ = '-';
		} else {
			*buf++ = '+';
   16b64:	1ca2      	adds	r2, r4, #2
   16b66:	232b      	movs	r3, #43	; 0x2b
   16b68:	7063      	strb	r3, [r4, #1]
		}

		/* At most 3 digits to the decimal.  Spit them out. */
		if (decexp >= 100) {
   16b6a:	2d63      	cmp	r5, #99	; 0x63
   16b6c:	dd0c      	ble.n	16b88 <encode_float+0x384>
			*buf++ = (decexp / 100) + '0';
   16b6e:	491e      	ldr	r1, [pc, #120]	; (16be8 <encode_float+0x3e4>)
   16b70:	fb81 3105 	smull	r3, r1, r1, r5
   16b74:	17eb      	asrs	r3, r5, #31
   16b76:	ebc3 1361 	rsb	r3, r3, r1, asr #5
   16b7a:	f103 0130 	add.w	r1, r3, #48	; 0x30
   16b7e:	f802 1b01 	strb.w	r1, [r2], #1
			decexp %= 100;
   16b82:	2164      	movs	r1, #100	; 0x64
   16b84:	fb01 5513 	mls	r5, r1, r3, r5
		}

		*buf++ = (decexp / 10) + '0';
   16b88:	4918      	ldr	r1, [pc, #96]	; (16bec <encode_float+0x3e8>)
   16b8a:	fb81 3105 	smull	r3, r1, r1, r5
   16b8e:	17eb      	asrs	r3, r5, #31
   16b90:	ebc3 03a1 	rsb	r3, r3, r1, asr #2
   16b94:	f103 0130 	add.w	r1, r3, #48	; 0x30
   16b98:	4614      	mov	r4, r2
   16b9a:	f804 1b02 	strb.w	r1, [r4], #2
		*buf++ = (decexp % 10) + '0';
   16b9e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   16ba2:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
   16ba6:	3330      	adds	r3, #48	; 0x30
   16ba8:	7053      	strb	r3, [r2, #1]
	}

	/* Cache whether there's padding required */
	conv->pad_fp = (conv->pad0_value > 0)
   16baa:	687b      	ldr	r3, [r7, #4]
		|| (conv->pad0_pre_exp > 0);
   16bac:	2b00      	cmp	r3, #0
   16bae:	dd14      	ble.n	16bda <encode_float+0x3d6>
   16bb0:	f04f 0a01 	mov.w	sl, #1
	conv->pad_fp = (conv->pad0_value > 0)
   16bb4:	78bb      	ldrb	r3, [r7, #2]
   16bb6:	f36a 1386 	bfi	r3, sl, #6, #1
   16bba:	70bb      	strb	r3, [r7, #2]

	/* Set the end of the encoded sequence, and return its start.  Also
	 * store EOS as a non-digit/non-decimal value so we don't have to
	 * check against bpe when iterating in multiple places.
	 */
	*bpe = buf;
   16bbc:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16bbe:	601c      	str	r4, [r3, #0]
	*buf = 0;
   16bc0:	2300      	movs	r3, #0
   16bc2:	7023      	strb	r3, [r4, #0]
	return bps;
}
   16bc4:	4648      	mov	r0, r9
   16bc6:	b007      	add	sp, #28
   16bc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while (*--buf == '0') {
   16bcc:	461c      	mov	r4, r3
   16bce:	e7bf      	b.n	16b50 <encode_float+0x34c>
			decexp = -decexp;
   16bd0:	426d      	negs	r5, r5
			*buf++ = '-';
   16bd2:	1ca2      	adds	r2, r4, #2
   16bd4:	232d      	movs	r3, #45	; 0x2d
   16bd6:	7063      	strb	r3, [r4, #1]
   16bd8:	e7c7      	b.n	16b6a <encode_float+0x366>
		|| (conv->pad0_pre_exp > 0);
   16bda:	68bb      	ldr	r3, [r7, #8]
   16bdc:	2b00      	cmp	r3, #0
   16bde:	dde9      	ble.n	16bb4 <encode_float+0x3b0>
   16be0:	f04f 0a01 	mov.w	sl, #1
   16be4:	e7e6      	b.n	16bb4 <encode_float+0x3b0>
   16be6:	bf00      	nop
   16be8:	51eb851f 	.word	0x51eb851f
   16bec:	66666667 	.word	0x66666667

00016bf0 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
   16bf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16bf4:	b097      	sub	sp, #92	; 0x5c
   16bf6:	4606      	mov	r6, r0
   16bf8:	460d      	mov	r5, r1
   16bfa:	4617      	mov	r7, r2
   16bfc:	9305      	str	r3, [sp, #20]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   16bfe:	2400      	movs	r4, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   16c00:	7838      	ldrb	r0, [r7, #0]
   16c02:	2800      	cmp	r0, #0
   16c04:	f000 835c 	beq.w	172c0 <z_cbvprintf_impl+0x6d0>
		if (*fp != '%') {
   16c08:	2825      	cmp	r0, #37	; 0x25
   16c0a:	d007      	beq.n	16c1c <z_cbvprintf_impl+0x2c>
			OUTC(*fp++);
   16c0c:	3701      	adds	r7, #1
   16c0e:	4629      	mov	r1, r5
   16c10:	47b0      	blx	r6
   16c12:	2800      	cmp	r0, #0
   16c14:	f2c0 8355 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   16c18:	3401      	adds	r4, #1
			continue;
   16c1a:	e7f1      	b.n	16c00 <z_cbvprintf_impl+0x10>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
   16c1c:	2300      	movs	r3, #0
   16c1e:	9308      	str	r3, [sp, #32]
   16c20:	9309      	str	r3, [sp, #36]	; 0x24
   16c22:	930a      	str	r3, [sp, #40]	; 0x28
   16c24:	930b      	str	r3, [sp, #44]	; 0x2c
   16c26:	930c      	str	r3, [sp, #48]	; 0x30
   16c28:	930d      	str	r3, [sp, #52]	; 0x34
		union argument_value *const value = &state.value;
		const char *sp = fp;
		int width = -1;
		int precision = -1;
		const char *bps = NULL;
		const char *bpe = buf + sizeof(buf);
   16c2a:	f10d 0255 	add.w	r2, sp, #85	; 0x55
   16c2e:	9207      	str	r2, [sp, #28]
		char sign = 0;
   16c30:	f88d 301b 	strb.w	r3, [sp, #27]

		fp = extract_conversion(conv, sp);
   16c34:	4639      	mov	r1, r7
   16c36:	a80a      	add	r0, sp, #40	; 0x28
   16c38:	f7ff fbc4 	bl	163c4 <extract_conversion>
   16c3c:	4681      	mov	r9, r0

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
   16c3e:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
   16c42:	f013 0f01 	tst.w	r3, #1
   16c46:	f000 80a1 	beq.w	16d8c <z_cbvprintf_impl+0x19c>
			width = va_arg(ap, int);
   16c4a:	9b05      	ldr	r3, [sp, #20]
   16c4c:	1d1a      	adds	r2, r3, #4
   16c4e:	9205      	str	r2, [sp, #20]
   16c50:	f8d3 8000 	ldr.w	r8, [r3]

			if (width < 0) {
   16c54:	f1b8 0f00 	cmp.w	r8, #0
   16c58:	f2c0 808f 	blt.w	16d7a <z_cbvprintf_impl+0x18a>

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
   16c5c:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
   16c60:	f013 0f04 	tst.w	r3, #4
   16c64:	f000 80a5 	beq.w	16db2 <z_cbvprintf_impl+0x1c2>
			int arg = va_arg(ap, int);
   16c68:	9b05      	ldr	r3, [sp, #20]
   16c6a:	1d1a      	adds	r2, r3, #4
   16c6c:	9205      	str	r2, [sp, #20]
   16c6e:	f8d3 a000 	ldr.w	sl, [r3]

			if (arg < 0) {
   16c72:	f1ba 0f00 	cmp.w	sl, #0
   16c76:	f2c0 8093 	blt.w	16da0 <z_cbvprintf_impl+0x1b0>
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
   16c7a:	2300      	movs	r3, #0
   16c7c:	930b      	str	r3, [sp, #44]	; 0x2c
		conv->pad0_pre_exp = 0;
   16c7e:	930c      	str	r3, [sp, #48]	; 0x30

		/* FP conversion requires knowing the precision. */
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
		    && (conv->specifier_cat == SPECIFIER_FP)
   16c80:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   16c84:	f003 0307 	and.w	r3, r3, #7
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
   16c88:	2b04      	cmp	r3, #4
   16c8a:	f000 809b 	beq.w	16dc4 <z_cbvprintf_impl+0x1d4>
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
   16c8e:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   16c92:	f003 0307 	and.w	r3, r3, #7
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
   16c96:	f89d 2029 	ldrb.w	r2, [sp, #41]	; 0x29
   16c9a:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
   16c9e:	2b01      	cmp	r3, #1
   16ca0:	f000 80a0 	beq.w	16de4 <z_cbvprintf_impl+0x1f4>
			if (length_mod == LENGTH_HH) {
				value->sint = (signed char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
   16ca4:	2b02      	cmp	r3, #2
   16ca6:	f000 80e5 	beq.w	16e74 <z_cbvprintf_impl+0x284>
			if (length_mod == LENGTH_HH) {
				value->uint = (unsigned char)value->uint;
			} else if (length_mod == LENGTH_H) {
				value->uint = (unsigned short)value->uint;
			}
		} else if (specifier_cat == SPECIFIER_FP) {
   16caa:	2b04      	cmp	r3, #4
   16cac:	f000 8136 	beq.w	16f1c <z_cbvprintf_impl+0x32c>
			if (length_mod == LENGTH_UPPER_L) {
				value->ldbl = va_arg(ap, long double);
			} else {
				value->dbl = va_arg(ap, double);
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
   16cb0:	2b03      	cmp	r3, #3
   16cb2:	f000 814d 	beq.w	16f50 <z_cbvprintf_impl+0x360>
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
   16cb6:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
   16cba:	f012 0f03 	tst.w	r2, #3
   16cbe:	f040 814d 	bne.w	16f5c <z_cbvprintf_impl+0x36c>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
   16cc2:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
   16cc6:	3b25      	subs	r3, #37	; 0x25
   16cc8:	2b53      	cmp	r3, #83	; 0x53
   16cca:	f200 815a 	bhi.w	16f82 <z_cbvprintf_impl+0x392>
   16cce:	e8df f013 	tbh	[pc, r3, lsl #1]
   16cd2:	0151      	.short	0x0151
   16cd4:	01580158 	.word	0x01580158
   16cd8:	01580158 	.word	0x01580158
   16cdc:	01580158 	.word	0x01580158
   16ce0:	01580158 	.word	0x01580158
   16ce4:	01580158 	.word	0x01580158
   16ce8:	01580158 	.word	0x01580158
   16cec:	01580158 	.word	0x01580158
   16cf0:	01580158 	.word	0x01580158
   16cf4:	01580158 	.word	0x01580158
   16cf8:	01580158 	.word	0x01580158
   16cfc:	01580158 	.word	0x01580158
   16d00:	01580158 	.word	0x01580158
   16d04:	01580158 	.word	0x01580158
   16d08:	02150158 	.word	0x02150158
   16d0c:	01580158 	.word	0x01580158
   16d10:	02150158 	.word	0x02150158
   16d14:	02150215 	.word	0x02150215
   16d18:	01580158 	.word	0x01580158
   16d1c:	01580158 	.word	0x01580158
   16d20:	01580158 	.word	0x01580158
   16d24:	01580158 	.word	0x01580158
   16d28:	01580158 	.word	0x01580158
   16d2c:	01580158 	.word	0x01580158
   16d30:	01580158 	.word	0x01580158
   16d34:	01580158 	.word	0x01580158
   16d38:	015801b1 	.word	0x015801b1
   16d3c:	01580158 	.word	0x01580158
   16d40:	01580158 	.word	0x01580158
   16d44:	01580158 	.word	0x01580158
   16d48:	02150158 	.word	0x02150158
   16d4c:	019d0158 	.word	0x019d0158
   16d50:	021501a5 	.word	0x021501a5
   16d54:	02150215 	.word	0x02150215
   16d58:	01a50158 	.word	0x01a50158
   16d5c:	01580158 	.word	0x01580158
   16d60:	01580158 	.word	0x01580158
   16d64:	01b101f3 	.word	0x01b101f3
   16d68:	015801db 	.word	0x015801db
   16d6c:	015a0158 	.word	0x015a0158
   16d70:	01b10158 	.word	0x01b10158
   16d74:	01580158 	.word	0x01580158
   16d78:	01b1      	.short	0x01b1
				conv->flag_dash = true;
   16d7a:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   16d7e:	f043 0304 	orr.w	r3, r3, #4
   16d82:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
				width = -width;
   16d86:	f1c8 0800 	rsb	r8, r8, #0
   16d8a:	e767      	b.n	16c5c <z_cbvprintf_impl+0x6c>
		} else if (conv->width_present) {
   16d8c:	f99d 3028 	ldrsb.w	r3, [sp, #40]	; 0x28
   16d90:	2b00      	cmp	r3, #0
   16d92:	db02      	blt.n	16d9a <z_cbvprintf_impl+0x1aa>
		int width = -1;
   16d94:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   16d98:	e760      	b.n	16c5c <z_cbvprintf_impl+0x6c>
			width = conv->width_value;
   16d9a:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   16d9e:	e75d      	b.n	16c5c <z_cbvprintf_impl+0x6c>
				conv->prec_present = false;
   16da0:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
   16da4:	f36f 0341 	bfc	r3, #1, #1
   16da8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
		int precision = -1;
   16dac:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   16db0:	e763      	b.n	16c7a <z_cbvprintf_impl+0x8a>
		} else if (conv->prec_present) {
   16db2:	f013 0f02 	tst.w	r3, #2
   16db6:	d002      	beq.n	16dbe <z_cbvprintf_impl+0x1ce>
			precision = conv->prec_value;
   16db8:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   16dbc:	e75d      	b.n	16c7a <z_cbvprintf_impl+0x8a>
		int precision = -1;
   16dbe:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   16dc2:	e75a      	b.n	16c7a <z_cbvprintf_impl+0x8a>
		    && !conv->prec_present) {
   16dc4:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
   16dc8:	f013 0f02 	tst.w	r3, #2
   16dcc:	f47f af5f 	bne.w	16c8e <z_cbvprintf_impl+0x9e>
			if (conv->specifier_a) {
   16dd0:	f99d 3029 	ldrsb.w	r3, [sp, #41]	; 0x29
   16dd4:	2b00      	cmp	r3, #0
   16dd6:	db02      	blt.n	16dde <z_cbvprintf_impl+0x1ee>
				precision = 6;
   16dd8:	f04f 0a06 	mov.w	sl, #6
   16ddc:	e757      	b.n	16c8e <z_cbvprintf_impl+0x9e>
				precision = FRACTION_HEX;
   16dde:	f04f 0a0d 	mov.w	sl, #13
   16de2:	e754      	b.n	16c8e <z_cbvprintf_impl+0x9e>
			switch (length_mod) {
   16de4:	1ed3      	subs	r3, r2, #3
   16de6:	2b04      	cmp	r3, #4
   16de8:	d804      	bhi.n	16df4 <z_cbvprintf_impl+0x204>
   16dea:	e8df f003 	tbb	[pc, r3]
   16dee:	1d0b      	.short	0x1d0b
   16df0:	3529      	.short	0x3529
   16df2:	35          	.byte	0x35
   16df3:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
   16df4:	9b05      	ldr	r3, [sp, #20]
   16df6:	1d19      	adds	r1, r3, #4
   16df8:	9105      	str	r1, [sp, #20]
   16dfa:	681b      	ldr	r3, [r3, #0]
   16dfc:	17d9      	asrs	r1, r3, #31
   16dfe:	9308      	str	r3, [sp, #32]
   16e00:	9109      	str	r1, [sp, #36]	; 0x24
				break;
   16e02:	e006      	b.n	16e12 <z_cbvprintf_impl+0x222>
					value->sint = va_arg(ap, long);
   16e04:	9b05      	ldr	r3, [sp, #20]
   16e06:	1d19      	adds	r1, r3, #4
   16e08:	9105      	str	r1, [sp, #20]
   16e0a:	681b      	ldr	r3, [r3, #0]
   16e0c:	17d9      	asrs	r1, r3, #31
   16e0e:	9308      	str	r3, [sp, #32]
   16e10:	9109      	str	r1, [sp, #36]	; 0x24
			if (length_mod == LENGTH_HH) {
   16e12:	2a01      	cmp	r2, #1
   16e14:	d028      	beq.n	16e68 <z_cbvprintf_impl+0x278>
			} else if (length_mod == LENGTH_H) {
   16e16:	2a02      	cmp	r2, #2
   16e18:	f47f af4d 	bne.w	16cb6 <z_cbvprintf_impl+0xc6>
				value->sint = (short)value->sint;
   16e1c:	f9bd 3020 	ldrsh.w	r3, [sp, #32]
   16e20:	17da      	asrs	r2, r3, #31
   16e22:	9308      	str	r3, [sp, #32]
   16e24:	9209      	str	r2, [sp, #36]	; 0x24
   16e26:	e746      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
					(sint_value_type)va_arg(ap, long long);
   16e28:	9b05      	ldr	r3, [sp, #20]
   16e2a:	3307      	adds	r3, #7
   16e2c:	f023 0307 	bic.w	r3, r3, #7
   16e30:	f103 0108 	add.w	r1, r3, #8
   16e34:	9105      	str	r1, [sp, #20]
   16e36:	e9d3 0100 	ldrd	r0, r1, [r3]
				value->sint =
   16e3a:	e9cd 0108 	strd	r0, r1, [sp, #32]
				break;
   16e3e:	e7e8      	b.n	16e12 <z_cbvprintf_impl+0x222>
					(sint_value_type)va_arg(ap, intmax_t);
   16e40:	9b05      	ldr	r3, [sp, #20]
   16e42:	3307      	adds	r3, #7
   16e44:	f023 0307 	bic.w	r3, r3, #7
   16e48:	f103 0108 	add.w	r1, r3, #8
   16e4c:	9105      	str	r1, [sp, #20]
   16e4e:	e9d3 0100 	ldrd	r0, r1, [r3]
				value->sint =
   16e52:	e9cd 0108 	strd	r0, r1, [sp, #32]
				break;
   16e56:	e7dc      	b.n	16e12 <z_cbvprintf_impl+0x222>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   16e58:	9b05      	ldr	r3, [sp, #20]
   16e5a:	1d19      	adds	r1, r3, #4
   16e5c:	9105      	str	r1, [sp, #20]
   16e5e:	681b      	ldr	r3, [r3, #0]
   16e60:	17d9      	asrs	r1, r3, #31
				value->sint =
   16e62:	9308      	str	r3, [sp, #32]
   16e64:	9109      	str	r1, [sp, #36]	; 0x24
				break;
   16e66:	e7d4      	b.n	16e12 <z_cbvprintf_impl+0x222>
				value->sint = (signed char)value->sint;
   16e68:	f99d 3020 	ldrsb.w	r3, [sp, #32]
   16e6c:	17da      	asrs	r2, r3, #31
   16e6e:	9308      	str	r3, [sp, #32]
   16e70:	9209      	str	r2, [sp, #36]	; 0x24
   16e72:	e720      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
			switch (length_mod) {
   16e74:	1ed3      	subs	r3, r2, #3
   16e76:	2b04      	cmp	r3, #4
   16e78:	d804      	bhi.n	16e84 <z_cbvprintf_impl+0x294>
   16e7a:	e8df f003 	tbb	[pc, r3]
   16e7e:	1f0b      	.short	0x1f0b
   16e80:	4135      	.short	0x4135
   16e82:	41          	.byte	0x41
   16e83:	00          	.byte	0x00
				value->uint = va_arg(ap, unsigned int);
   16e84:	9b05      	ldr	r3, [sp, #20]
   16e86:	1d19      	adds	r1, r3, #4
   16e88:	9105      	str	r1, [sp, #20]
   16e8a:	681b      	ldr	r3, [r3, #0]
   16e8c:	9308      	str	r3, [sp, #32]
   16e8e:	2300      	movs	r3, #0
   16e90:	9309      	str	r3, [sp, #36]	; 0x24
				break;
   16e92:	e01e      	b.n	16ed2 <z_cbvprintf_impl+0x2e2>
				    && (conv->specifier == 'c')) {
   16e94:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
				if ((!WCHAR_IS_SIGNED)
   16e98:	2b63      	cmp	r3, #99	; 0x63
   16e9a:	d007      	beq.n	16eac <z_cbvprintf_impl+0x2bc>
					value->uint = va_arg(ap, unsigned long);
   16e9c:	9b05      	ldr	r3, [sp, #20]
   16e9e:	1d19      	adds	r1, r3, #4
   16ea0:	9105      	str	r1, [sp, #20]
   16ea2:	681b      	ldr	r3, [r3, #0]
   16ea4:	9308      	str	r3, [sp, #32]
   16ea6:	2300      	movs	r3, #0
   16ea8:	9309      	str	r3, [sp, #36]	; 0x24
   16eaa:	e012      	b.n	16ed2 <z_cbvprintf_impl+0x2e2>
					value->uint = (wchar_t)va_arg(ap,
   16eac:	9b05      	ldr	r3, [sp, #20]
   16eae:	1d19      	adds	r1, r3, #4
   16eb0:	9105      	str	r1, [sp, #20]
   16eb2:	681b      	ldr	r3, [r3, #0]
   16eb4:	9308      	str	r3, [sp, #32]
   16eb6:	2300      	movs	r3, #0
   16eb8:	9309      	str	r3, [sp, #36]	; 0x24
   16eba:	e00a      	b.n	16ed2 <z_cbvprintf_impl+0x2e2>
					(uint_value_type)va_arg(ap,
   16ebc:	9b05      	ldr	r3, [sp, #20]
   16ebe:	3307      	adds	r3, #7
   16ec0:	f023 0307 	bic.w	r3, r3, #7
   16ec4:	f103 0108 	add.w	r1, r3, #8
   16ec8:	9105      	str	r1, [sp, #20]
   16eca:	e9d3 0100 	ldrd	r0, r1, [r3]
				value->uint =
   16ece:	e9cd 0108 	strd	r0, r1, [sp, #32]
			if (length_mod == LENGTH_HH) {
   16ed2:	2a01      	cmp	r2, #1
   16ed4:	d01c      	beq.n	16f10 <z_cbvprintf_impl+0x320>
			} else if (length_mod == LENGTH_H) {
   16ed6:	2a02      	cmp	r2, #2
   16ed8:	f47f aeed 	bne.w	16cb6 <z_cbvprintf_impl+0xc6>
				value->uint = (unsigned short)value->uint;
   16edc:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   16ee0:	9308      	str	r3, [sp, #32]
   16ee2:	2300      	movs	r3, #0
   16ee4:	9309      	str	r3, [sp, #36]	; 0x24
   16ee6:	e6e6      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
					(uint_value_type)va_arg(ap,
   16ee8:	9b05      	ldr	r3, [sp, #20]
   16eea:	3307      	adds	r3, #7
   16eec:	f023 0307 	bic.w	r3, r3, #7
   16ef0:	f103 0108 	add.w	r1, r3, #8
   16ef4:	9105      	str	r1, [sp, #20]
   16ef6:	e9d3 0100 	ldrd	r0, r1, [r3]
				value->uint =
   16efa:	e9cd 0108 	strd	r0, r1, [sp, #32]
				break;
   16efe:	e7e8      	b.n	16ed2 <z_cbvprintf_impl+0x2e2>
					(uint_value_type)va_arg(ap, size_t);
   16f00:	9b05      	ldr	r3, [sp, #20]
   16f02:	1d19      	adds	r1, r3, #4
   16f04:	9105      	str	r1, [sp, #20]
   16f06:	681b      	ldr	r3, [r3, #0]
				value->uint =
   16f08:	9308      	str	r3, [sp, #32]
   16f0a:	2300      	movs	r3, #0
   16f0c:	9309      	str	r3, [sp, #36]	; 0x24
				break;
   16f0e:	e7e0      	b.n	16ed2 <z_cbvprintf_impl+0x2e2>
				value->uint = (unsigned char)value->uint;
   16f10:	f89d 3020 	ldrb.w	r3, [sp, #32]
   16f14:	9308      	str	r3, [sp, #32]
   16f16:	2300      	movs	r3, #0
   16f18:	9309      	str	r3, [sp, #36]	; 0x24
   16f1a:	e6cc      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
			if (length_mod == LENGTH_UPPER_L) {
   16f1c:	2a08      	cmp	r2, #8
   16f1e:	d00b      	beq.n	16f38 <z_cbvprintf_impl+0x348>
				value->dbl = va_arg(ap, double);
   16f20:	9b05      	ldr	r3, [sp, #20]
   16f22:	3307      	adds	r3, #7
   16f24:	f023 0307 	bic.w	r3, r3, #7
   16f28:	f103 0208 	add.w	r2, r3, #8
   16f2c:	9205      	str	r2, [sp, #20]
   16f2e:	e9d3 2300 	ldrd	r2, r3, [r3]
   16f32:	e9cd 2308 	strd	r2, r3, [sp, #32]
   16f36:	e6be      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
				value->ldbl = va_arg(ap, long double);
   16f38:	9b05      	ldr	r3, [sp, #20]
   16f3a:	3307      	adds	r3, #7
   16f3c:	f023 0307 	bic.w	r3, r3, #7
   16f40:	f103 0208 	add.w	r2, r3, #8
   16f44:	9205      	str	r2, [sp, #20]
   16f46:	e9d3 2300 	ldrd	r2, r3, [r3]
   16f4a:	e9cd 2308 	strd	r2, r3, [sp, #32]
   16f4e:	e6b2      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
			value->ptr = va_arg(ap, void *);
   16f50:	9b05      	ldr	r3, [sp, #20]
   16f52:	1d1a      	adds	r2, r3, #4
   16f54:	9205      	str	r2, [sp, #20]
   16f56:	681b      	ldr	r3, [r3, #0]
   16f58:	9308      	str	r3, [sp, #32]
   16f5a:	e6ac      	b.n	16cb6 <z_cbvprintf_impl+0xc6>
			OUTS(sp, fp);
   16f5c:	464b      	mov	r3, r9
   16f5e:	463a      	mov	r2, r7
   16f60:	4629      	mov	r1, r5
   16f62:	4630      	mov	r0, r6
   16f64:	f015 fa84 	bl	2c470 <outs>
   16f68:	2800      	cmp	r0, #0
   16f6a:	f2c0 81aa 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   16f6e:	4404      	add	r4, r0
		fp = extract_conversion(conv, sp);
   16f70:	464f      	mov	r7, r9
			continue;
   16f72:	e645      	b.n	16c00 <z_cbvprintf_impl+0x10>
		case '%':
			OUTC('%');
   16f74:	4629      	mov	r1, r5
   16f76:	2025      	movs	r0, #37	; 0x25
   16f78:	47b0      	blx	r6
   16f7a:	2800      	cmp	r0, #0
   16f7c:	f2c0 81a1 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   16f80:	3401      	adds	r4, #1
		fp = extract_conversion(conv, sp);
   16f82:	464f      	mov	r7, r9

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
			continue;
   16f84:	e63c      	b.n	16c00 <z_cbvprintf_impl+0x10>
			bps = (const char *)value->ptr;
   16f86:	9f08      	ldr	r7, [sp, #32]
			if (precision >= 0) {
   16f88:	f1ba 0f00 	cmp.w	sl, #0
   16f8c:	db3a      	blt.n	17004 <z_cbvprintf_impl+0x414>
				len = strnlen(bps, precision);
   16f8e:	4651      	mov	r1, sl
   16f90:	4638      	mov	r0, r7
   16f92:	f019 ffa4 	bl	30ede <strnlen>
			bpe = bps + len;
   16f96:	4438      	add	r0, r7
   16f98:	9007      	str	r0, [sp, #28]
		if (bps == NULL) {
   16f9a:	2f00      	cmp	r7, #0
   16f9c:	d0f1      	beq.n	16f82 <z_cbvprintf_impl+0x392>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
   16f9e:	9b07      	ldr	r3, [sp, #28]
   16fa0:	1bdb      	subs	r3, r3, r7
		int pad_len = 0;

		if (sign != 0) {
   16fa2:	f89d 001b 	ldrb.w	r0, [sp, #27]
   16fa6:	b100      	cbz	r0, 16faa <z_cbvprintf_impl+0x3ba>
			nj_len += 1U;
   16fa8:	3301      	adds	r3, #1
		}

		if (conv->altform_0c) {
   16faa:	f89d 102a 	ldrb.w	r1, [sp, #42]	; 0x2a
   16fae:	f011 0f10 	tst.w	r1, #16
   16fb2:	f000 80b2 	beq.w	1711a <z_cbvprintf_impl+0x52a>
			nj_len += 2U;
   16fb6:	3302      	adds	r3, #2
		} else if (conv->altform_0) {
			nj_len += 1U;
		}

		nj_len += conv->pad0_value;
   16fb8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16fba:	4413      	add	r3, r2
		if (conv->pad_fp) {
   16fbc:	f011 0f40 	tst.w	r1, #64	; 0x40
   16fc0:	d001      	beq.n	16fc6 <z_cbvprintf_impl+0x3d6>
			nj_len += conv->pad0_pre_exp;
   16fc2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   16fc4:	4413      	add	r3, r2
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
   16fc6:	f1b8 0f00 	cmp.w	r8, #0
   16fca:	f340 80bf 	ble.w	1714c <z_cbvprintf_impl+0x55c>
			width -= (int)nj_len;
   16fce:	eba8 0803 	sub.w	r8, r8, r3

			if (!conv->flag_dash) {
   16fd2:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   16fd6:	f013 0f04 	tst.w	r3, #4
   16fda:	f040 80b7 	bne.w	1714c <z_cbvprintf_impl+0x55c>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
   16fde:	f013 0f40 	tst.w	r3, #64	; 0x40
   16fe2:	f000 80a0 	beq.w	17126 <z_cbvprintf_impl+0x536>
					if (sign != 0) {
   16fe6:	2800      	cmp	r0, #0
   16fe8:	f000 80a0 	beq.w	1712c <z_cbvprintf_impl+0x53c>
						OUTC(sign);
   16fec:	4629      	mov	r1, r5
   16fee:	47b0      	blx	r6
   16ff0:	2800      	cmp	r0, #0
   16ff2:	f2c0 8166 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   16ff6:	3401      	adds	r4, #1
						sign = 0;
   16ff8:	2300      	movs	r3, #0
   16ffa:	f88d 301b 	strb.w	r3, [sp, #27]
					}
					pad = '0';
   16ffe:	f04f 0a30 	mov.w	sl, #48	; 0x30
   17002:	e095      	b.n	17130 <z_cbvprintf_impl+0x540>
				len = strlen(bps);
   17004:	4638      	mov	r0, r7
   17006:	f7f5 fe50 	bl	ccaa <strlen>
   1700a:	e7c4      	b.n	16f96 <z_cbvprintf_impl+0x3a6>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1700c:	9b08      	ldr	r3, [sp, #32]
   1700e:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
			bpe = buf + 1;
   17012:	f10d 033d 	add.w	r3, sp, #61	; 0x3d
   17016:	9307      	str	r3, [sp, #28]
			bps = buf;
   17018:	af0f      	add	r7, sp, #60	; 0x3c
			break;
   1701a:	e7be      	b.n	16f9a <z_cbvprintf_impl+0x3aa>
			if (conv->flag_plus) {
   1701c:	f012 0f08 	tst.w	r2, #8
   17020:	d022      	beq.n	17068 <z_cbvprintf_impl+0x478>
				sign = '+';
   17022:	232b      	movs	r3, #43	; 0x2b
   17024:	f88d 301b 	strb.w	r3, [sp, #27]
			sint = value->sint;
   17028:	9a08      	ldr	r2, [sp, #32]
   1702a:	9b09      	ldr	r3, [sp, #36]	; 0x24
			if (sint < 0) {
   1702c:	2b00      	cmp	r3, #0
   1702e:	db22      	blt.n	17076 <z_cbvprintf_impl+0x486>
				value->uint = (uint_value_type)sint;
   17030:	9208      	str	r2, [sp, #32]
   17032:	9309      	str	r3, [sp, #36]	; 0x24
			bps = encode_uint(value->uint, conv, buf, bpe);
   17034:	9b07      	ldr	r3, [sp, #28]
   17036:	9300      	str	r3, [sp, #0]
   17038:	ab0f      	add	r3, sp, #60	; 0x3c
   1703a:	aa0a      	add	r2, sp, #40	; 0x28
   1703c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   17040:	f7ff fb70 	bl	16724 <encode_uint>
   17044:	4607      	mov	r7, r0
			if (precision >= 0) {
   17046:	f1ba 0f00 	cmp.w	sl, #0
   1704a:	dba6      	blt.n	16f9a <z_cbvprintf_impl+0x3aa>
				size_t len = bpe - bps;
   1704c:	9b07      	ldr	r3, [sp, #28]
   1704e:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
   17050:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
   17054:	f36f 1286 	bfc	r2, #6, #1
   17058:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
				if (len < (size_t)precision) {
   1705c:	459a      	cmp	sl, r3
   1705e:	d99c      	bls.n	16f9a <z_cbvprintf_impl+0x3aa>
					conv->pad0_value = precision - (int)len;
   17060:	ebaa 0303 	sub.w	r3, sl, r3
   17064:	930b      	str	r3, [sp, #44]	; 0x2c
   17066:	e798      	b.n	16f9a <z_cbvprintf_impl+0x3aa>
			} else if (conv->flag_space) {
   17068:	f012 0f10 	tst.w	r2, #16
   1706c:	d0dc      	beq.n	17028 <z_cbvprintf_impl+0x438>
				sign = ' ';
   1706e:	2320      	movs	r3, #32
   17070:	f88d 301b 	strb.w	r3, [sp, #27]
   17074:	e7d8      	b.n	17028 <z_cbvprintf_impl+0x438>
				sign = '-';
   17076:	212d      	movs	r1, #45	; 0x2d
   17078:	f88d 101b 	strb.w	r1, [sp, #27]
				value->uint = (uint_value_type)-sint;
   1707c:	4252      	negs	r2, r2
   1707e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   17082:	9208      	str	r2, [sp, #32]
   17084:	9309      	str	r3, [sp, #36]	; 0x24
   17086:	e7d5      	b.n	17034 <z_cbvprintf_impl+0x444>
			if (value->ptr != NULL) {
   17088:	9808      	ldr	r0, [sp, #32]
   1708a:	b918      	cbnz	r0, 17094 <z_cbvprintf_impl+0x4a4>
			bpe = bps + 5;
   1708c:	4f8e      	ldr	r7, [pc, #568]	; (172c8 <z_cbvprintf_impl+0x6d8>)
   1708e:	9707      	str	r7, [sp, #28]
			bps = "(nil)";
   17090:	3f05      	subs	r7, #5
			break;
   17092:	e782      	b.n	16f9a <z_cbvprintf_impl+0x3aa>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   17094:	9b07      	ldr	r3, [sp, #28]
   17096:	9300      	str	r3, [sp, #0]
   17098:	ab0f      	add	r3, sp, #60	; 0x3c
   1709a:	aa0a      	add	r2, sp, #40	; 0x28
   1709c:	2100      	movs	r1, #0
   1709e:	f7ff fb41 	bl	16724 <encode_uint>
   170a2:	4607      	mov	r7, r0
				conv->altform_0c = true;
   170a4:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   170a8:	f043 0310 	orr.w	r3, r3, #16
   170ac:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
				conv->specifier = 'x';
   170b0:	2378      	movs	r3, #120	; 0x78
   170b2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
				goto prec_int_pad0;
   170b6:	e7c6      	b.n	17046 <z_cbvprintf_impl+0x456>
				store_count(conv, value->ptr, count);
   170b8:	9a08      	ldr	r2, [sp, #32]
	switch ((enum length_mod_enum)conv->length_mod) {
   170ba:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
   170be:	f3c3 03c3 	ubfx	r3, r3, #3, #4
   170c2:	2b07      	cmp	r3, #7
   170c4:	f63f af5d 	bhi.w	16f82 <z_cbvprintf_impl+0x392>
   170c8:	e8df f003 	tbb	[pc, r3]
   170cc:	0a080604 	.word	0x0a080604
   170d0:	1614100c 	.word	0x1614100c
		*(int *)dp = count;
   170d4:	6014      	str	r4, [r2, #0]
		break;
   170d6:	e754      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(signed char *)dp = (signed char)count;
   170d8:	7014      	strb	r4, [r2, #0]
		break;
   170da:	e752      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(short *)dp = (short)count;
   170dc:	8014      	strh	r4, [r2, #0]
		break;
   170de:	e750      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(long *)dp = (long)count;
   170e0:	6014      	str	r4, [r2, #0]
		break;
   170e2:	e74e      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(long long *)dp = (long long)count;
   170e4:	17e3      	asrs	r3, r4, #31
   170e6:	6014      	str	r4, [r2, #0]
   170e8:	6053      	str	r3, [r2, #4]
		break;
   170ea:	e74a      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(intmax_t *)dp = (intmax_t)count;
   170ec:	17e3      	asrs	r3, r4, #31
   170ee:	6014      	str	r4, [r2, #0]
   170f0:	6053      	str	r3, [r2, #4]
		break;
   170f2:	e746      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(size_t *)dp = (size_t)count;
   170f4:	6014      	str	r4, [r2, #0]
		break;
   170f6:	e744      	b.n	16f82 <z_cbvprintf_impl+0x392>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   170f8:	6014      	str	r4, [r2, #0]
}
   170fa:	e742      	b.n	16f82 <z_cbvprintf_impl+0x392>
				bps = encode_float(value->dbl, conv, precision,
   170fc:	ab07      	add	r3, sp, #28
   170fe:	9302      	str	r3, [sp, #8]
   17100:	ab0f      	add	r3, sp, #60	; 0x3c
   17102:	9301      	str	r3, [sp, #4]
   17104:	f10d 031b 	add.w	r3, sp, #27
   17108:	9300      	str	r3, [sp, #0]
   1710a:	4653      	mov	r3, sl
   1710c:	aa0a      	add	r2, sp, #40	; 0x28
   1710e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   17112:	f7ff fb77 	bl	16804 <encode_float>
   17116:	4607      	mov	r7, r0
			break;
   17118:	e73f      	b.n	16f9a <z_cbvprintf_impl+0x3aa>
		} else if (conv->altform_0) {
   1711a:	f011 0f08 	tst.w	r1, #8
   1711e:	f43f af4b 	beq.w	16fb8 <z_cbvprintf_impl+0x3c8>
			nj_len += 1U;
   17122:	3301      	adds	r3, #1
   17124:	e748      	b.n	16fb8 <z_cbvprintf_impl+0x3c8>
				char pad = ' ';
   17126:	f04f 0a20 	mov.w	sl, #32
   1712a:	e001      	b.n	17130 <z_cbvprintf_impl+0x540>
					pad = '0';
   1712c:	f04f 0a30 	mov.w	sl, #48	; 0x30
   17130:	4643      	mov	r3, r8
				}

				while (width-- > 0) {
   17132:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
   17136:	2b00      	cmp	r3, #0
   17138:	dd08      	ble.n	1714c <z_cbvprintf_impl+0x55c>
					OUTC(pad);
   1713a:	4629      	mov	r1, r5
   1713c:	4650      	mov	r0, sl
   1713e:	47b0      	blx	r6
   17140:	2800      	cmp	r0, #0
   17142:	f2c0 80be 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   17146:	3401      	adds	r4, #1
				while (width-- > 0) {
   17148:	4643      	mov	r3, r8
   1714a:	e7f2      	b.n	17132 <z_cbvprintf_impl+0x542>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
   1714c:	f89d 001b 	ldrb.w	r0, [sp, #27]
   17150:	b128      	cbz	r0, 1715e <z_cbvprintf_impl+0x56e>
			OUTC(sign);
   17152:	4629      	mov	r1, r5
   17154:	47b0      	blx	r6
   17156:	2800      	cmp	r0, #0
   17158:	f2c0 80b3 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   1715c:	3401      	adds	r4, #1
		}

		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
   1715e:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   17162:	f013 0f40 	tst.w	r3, #64	; 0x40
   17166:	d06c      	beq.n	17242 <z_cbvprintf_impl+0x652>
			const char *cp = bps;

			if (conv->specifier_a) {
   17168:	f99d 3029 	ldrsb.w	r3, [sp, #41]	; 0x29
   1716c:	2b00      	cmp	r3, #0
   1716e:	da0b      	bge.n	17188 <z_cbvprintf_impl+0x598>
				/* Only padding is pre_exp */
				while (*cp != 'p') {
   17170:	7838      	ldrb	r0, [r7, #0]
   17172:	2870      	cmp	r0, #112	; 0x70
   17174:	d04e      	beq.n	17214 <z_cbvprintf_impl+0x624>
					OUTC(*cp++);
   17176:	3701      	adds	r7, #1
   17178:	4629      	mov	r1, r5
   1717a:	47b0      	blx	r6
   1717c:	2800      	cmp	r0, #0
   1717e:	f2c0 80a0 	blt.w	172c2 <z_cbvprintf_impl+0x6d2>
   17182:	3401      	adds	r4, #1
   17184:	e7f4      	b.n	17170 <z_cbvprintf_impl+0x580>
				}
			} else {
				while (isdigit((unsigned char)*cp)) {
					OUTC(*cp++);
   17186:	3401      	adds	r4, #1
				while (isdigit((unsigned char)*cp)) {
   17188:	7838      	ldrb	r0, [r7, #0]
   1718a:	4b50      	ldr	r3, [pc, #320]	; (172cc <z_cbvprintf_impl+0x6dc>)
   1718c:	5cc3      	ldrb	r3, [r0, r3]
   1718e:	f013 0f04 	tst.w	r3, #4
   17192:	d005      	beq.n	171a0 <z_cbvprintf_impl+0x5b0>
					OUTC(*cp++);
   17194:	3701      	adds	r7, #1
   17196:	4629      	mov	r1, r5
   17198:	47b0      	blx	r6
   1719a:	2800      	cmp	r0, #0
   1719c:	daf3      	bge.n	17186 <z_cbvprintf_impl+0x596>
   1719e:	e090      	b.n	172c2 <z_cbvprintf_impl+0x6d2>
				}

				pad_len = conv->pad0_value;
   171a0:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
				if (!conv->pad_postdp) {
   171a4:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   171a8:	f013 0f20 	tst.w	r3, #32
   171ac:	d00f      	beq.n	171ce <z_cbvprintf_impl+0x5de>
					while (pad_len-- > 0) {
						OUTC('0');
					}
				}

				if (*cp == '.') {
   171ae:	7838      	ldrb	r0, [r7, #0]
   171b0:	282e      	cmp	r0, #46	; 0x2e
   171b2:	d01b      	beq.n	171ec <z_cbvprintf_impl+0x5fc>
					 */
					while (pad_len-- > 0) {
						OUTC('0');
					}
				}
				while (isdigit((unsigned char)*cp)) {
   171b4:	7838      	ldrb	r0, [r7, #0]
   171b6:	4b45      	ldr	r3, [pc, #276]	; (172cc <z_cbvprintf_impl+0x6dc>)
   171b8:	5cc3      	ldrb	r3, [r0, r3]
   171ba:	f013 0f04 	tst.w	r3, #4
   171be:	d029      	beq.n	17214 <z_cbvprintf_impl+0x624>
					OUTC(*cp++);
   171c0:	3701      	adds	r7, #1
   171c2:	4629      	mov	r1, r5
   171c4:	47b0      	blx	r6
   171c6:	2800      	cmp	r0, #0
   171c8:	db7b      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   171ca:	3401      	adds	r4, #1
   171cc:	e7f2      	b.n	171b4 <z_cbvprintf_impl+0x5c4>
					while (pad_len-- > 0) {
   171ce:	f10a 3bff 	add.w	fp, sl, #4294967295	; 0xffffffff
   171d2:	f1ba 0f00 	cmp.w	sl, #0
   171d6:	dd07      	ble.n	171e8 <z_cbvprintf_impl+0x5f8>
						OUTC('0');
   171d8:	4629      	mov	r1, r5
   171da:	2030      	movs	r0, #48	; 0x30
   171dc:	47b0      	blx	r6
   171de:	2800      	cmp	r0, #0
   171e0:	db6f      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   171e2:	3401      	adds	r4, #1
					while (pad_len-- > 0) {
   171e4:	46da      	mov	sl, fp
   171e6:	e7f2      	b.n	171ce <z_cbvprintf_impl+0x5de>
   171e8:	46da      	mov	sl, fp
   171ea:	e7e0      	b.n	171ae <z_cbvprintf_impl+0x5be>
					OUTC(*cp++);
   171ec:	3701      	adds	r7, #1
   171ee:	4629      	mov	r1, r5
   171f0:	47b0      	blx	r6
   171f2:	2800      	cmp	r0, #0
   171f4:	db65      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   171f6:	3401      	adds	r4, #1
					while (pad_len-- > 0) {
   171f8:	e001      	b.n	171fe <z_cbvprintf_impl+0x60e>
						OUTC('0');
   171fa:	3401      	adds	r4, #1
					while (pad_len-- > 0) {
   171fc:	46da      	mov	sl, fp
   171fe:	f10a 3bff 	add.w	fp, sl, #4294967295	; 0xffffffff
   17202:	f1ba 0f00 	cmp.w	sl, #0
   17206:	ddd5      	ble.n	171b4 <z_cbvprintf_impl+0x5c4>
						OUTC('0');
   17208:	4629      	mov	r1, r5
   1720a:	2030      	movs	r0, #48	; 0x30
   1720c:	47b0      	blx	r6
   1720e:	2800      	cmp	r0, #0
   17210:	daf3      	bge.n	171fa <z_cbvprintf_impl+0x60a>
   17212:	e056      	b.n	172c2 <z_cbvprintf_impl+0x6d2>
				}
			}

			pad_len = conv->pad0_pre_exp;
   17214:	9b0c      	ldr	r3, [sp, #48]	; 0x30
			while (pad_len-- > 0) {
   17216:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
   1721a:	2b00      	cmp	r3, #0
   1721c:	dd07      	ble.n	1722e <z_cbvprintf_impl+0x63e>
				OUTC('0');
   1721e:	4629      	mov	r1, r5
   17220:	2030      	movs	r0, #48	; 0x30
   17222:	47b0      	blx	r6
   17224:	2800      	cmp	r0, #0
   17226:	db4c      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   17228:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
   1722a:	4653      	mov	r3, sl
   1722c:	e7f3      	b.n	17216 <z_cbvprintf_impl+0x626>
			}

			OUTS(cp, bpe);
   1722e:	9b07      	ldr	r3, [sp, #28]
   17230:	463a      	mov	r2, r7
   17232:	4629      	mov	r1, r5
   17234:	4630      	mov	r0, r6
   17236:	f015 f91b 	bl	2c470 <outs>
   1723a:	2800      	cmp	r0, #0
   1723c:	db41      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   1723e:	4404      	add	r4, r0
   17240:	e033      	b.n	172aa <z_cbvprintf_impl+0x6ba>
		} else {
			if (conv->altform_0c | conv->altform_0) {
   17242:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   17246:	f3c3 1200 	ubfx	r2, r3, #4, #1
   1724a:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   1724e:	4313      	orrs	r3, r2
   17250:	d005      	beq.n	1725e <z_cbvprintf_impl+0x66e>
				OUTC('0');
   17252:	4629      	mov	r1, r5
   17254:	2030      	movs	r0, #48	; 0x30
   17256:	47b0      	blx	r6
   17258:	2800      	cmp	r0, #0
   1725a:	db32      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   1725c:	3401      	adds	r4, #1
			}

			if (conv->altform_0c) {
   1725e:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   17262:	f013 0f10 	tst.w	r3, #16
   17266:	d006      	beq.n	17276 <z_cbvprintf_impl+0x686>
				OUTC(conv->specifier);
   17268:	4629      	mov	r1, r5
   1726a:	f89d 002b 	ldrb.w	r0, [sp, #43]	; 0x2b
   1726e:	47b0      	blx	r6
   17270:	2800      	cmp	r0, #0
   17272:	db26      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   17274:	3401      	adds	r4, #1
			}

			pad_len = conv->pad0_value;
   17276:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			while (pad_len-- > 0) {
   17278:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
   1727c:	2b00      	cmp	r3, #0
   1727e:	dd07      	ble.n	17290 <z_cbvprintf_impl+0x6a0>
				OUTC('0');
   17280:	4629      	mov	r1, r5
   17282:	2030      	movs	r0, #48	; 0x30
   17284:	47b0      	blx	r6
   17286:	2800      	cmp	r0, #0
   17288:	db1b      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   1728a:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
   1728c:	4653      	mov	r3, sl
   1728e:	e7f3      	b.n	17278 <z_cbvprintf_impl+0x688>
			}

			OUTS(bps, bpe);
   17290:	9b07      	ldr	r3, [sp, #28]
   17292:	463a      	mov	r2, r7
   17294:	4629      	mov	r1, r5
   17296:	4630      	mov	r0, r6
   17298:	f015 f8ea 	bl	2c470 <outs>
   1729c:	2800      	cmp	r0, #0
   1729e:	db10      	blt.n	172c2 <z_cbvprintf_impl+0x6d2>
   172a0:	4404      	add	r4, r0
   172a2:	e002      	b.n	172aa <z_cbvprintf_impl+0x6ba>
		}

		/* Finish left justification */
		while (width > 0) {
			OUTC(' ');
   172a4:	3401      	adds	r4, #1
			--width;
   172a6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		while (width > 0) {
   172aa:	f1b8 0f00 	cmp.w	r8, #0
   172ae:	dd05      	ble.n	172bc <z_cbvprintf_impl+0x6cc>
			OUTC(' ');
   172b0:	4629      	mov	r1, r5
   172b2:	2020      	movs	r0, #32
   172b4:	47b0      	blx	r6
   172b6:	2800      	cmp	r0, #0
   172b8:	daf4      	bge.n	172a4 <z_cbvprintf_impl+0x6b4>
   172ba:	e002      	b.n	172c2 <z_cbvprintf_impl+0x6d2>
		fp = extract_conversion(conv, sp);
   172bc:	464f      	mov	r7, r9
   172be:	e49f      	b.n	16c00 <z_cbvprintf_impl+0x10>
		}
	}

	return count;
   172c0:	4620      	mov	r0, r4
#undef OUTS
#undef OUTC
}
   172c2:	b017      	add	sp, #92	; 0x5c
   172c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   172c8:	00039149 	.word	0x00039149
   172cc:	0003c4c5 	.word	0x0003c4c5

000172d0 <ring_buf_put>:

	return 0;
}

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
   172d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   172d4:	b082      	sub	sp, #8
   172d6:	4680      	mov	r8, r0
   172d8:	460e      	mov	r6, r1
   172da:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   172dc:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
   172de:	462a      	mov	r2, r5
   172e0:	a901      	add	r1, sp, #4
   172e2:	4640      	mov	r0, r8
   172e4:	f015 f8de 	bl	2c4a4 <ring_buf_put_claim>
   172e8:	4604      	mov	r4, r0
   172ea:	4602      	mov	r2, r0
   172ec:	4631      	mov	r1, r6
   172ee:	9801      	ldr	r0, [sp, #4]
   172f0:	f019 fdb9 	bl	30e66 <memcpy>
		memcpy(dst, data, partial_size);
		total_size += partial_size;
   172f4:	4427      	add	r7, r4
		size -= partial_size;
		data += partial_size;
   172f6:	4426      	add	r6, r4
	} while (size && partial_size);
   172f8:	1b2d      	subs	r5, r5, r4
   172fa:	d001      	beq.n	17300 <ring_buf_put+0x30>
   172fc:	2c00      	cmp	r4, #0
   172fe:	d1ee      	bne.n	172de <ring_buf_put+0xe>

	err = ring_buf_put_finish(buf, total_size);
   17300:	4639      	mov	r1, r7
   17302:	4640      	mov	r0, r8
   17304:	f015 f8ee 	bl	2c4e4 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
   17308:	b918      	cbnz	r0, 17312 <ring_buf_put+0x42>
	ARG_UNUSED(err);

	return total_size;
}
   1730a:	4638      	mov	r0, r7
   1730c:	b002      	add	sp, #8
   1730e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(err == 0);
   17312:	4c05      	ldr	r4, [pc, #20]	; (17328 <ring_buf_put+0x58>)
   17314:	2249      	movs	r2, #73	; 0x49
   17316:	4621      	mov	r1, r4
   17318:	4804      	ldr	r0, [pc, #16]	; (1732c <ring_buf_put+0x5c>)
   1731a:	f015 f908 	bl	2c52e <assert_print>
   1731e:	2149      	movs	r1, #73	; 0x49
   17320:	4620      	mov	r0, r4
   17322:	f015 f8fd 	bl	2c520 <assert_post_action>
	return total_size;
   17326:	e7f0      	b.n	1730a <ring_buf_put+0x3a>
   17328:	0003914c 	.word	0x0003914c
   1732c:	00031600 	.word	0x00031600

00017330 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   17330:	f00b bd62 	b.w	22df8 <SystemInit>

00017334 <minimal_hexdump_line_print>:
{
	vprintk(fmt, ap);
}

static void minimal_hexdump_line_print(const char *data, size_t length)
{
   17334:	b570      	push	{r4, r5, r6, lr}
   17336:	4606      	mov	r6, r0
   17338:	460d      	mov	r5, r1
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
   1733a:	2400      	movs	r4, #0
   1733c:	e003      	b.n	17346 <minimal_hexdump_line_print+0x12>
		if (i < length) {
			printk("%02x ", (unsigned char)data[i] & 0xFFu);
		} else {
			printk("   ");
   1733e:	4815      	ldr	r0, [pc, #84]	; (17394 <minimal_hexdump_line_print+0x60>)
   17340:	f014 fe52 	bl	2bfe8 <printk>
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
   17344:	3401      	adds	r4, #1
   17346:	2c07      	cmp	r4, #7
   17348:	d806      	bhi.n	17358 <minimal_hexdump_line_print+0x24>
		if (i < length) {
   1734a:	42ac      	cmp	r4, r5
   1734c:	d2f7      	bcs.n	1733e <minimal_hexdump_line_print+0xa>
			printk("%02x ", (unsigned char)data[i] & 0xFFu);
   1734e:	5d31      	ldrb	r1, [r6, r4]
   17350:	4811      	ldr	r0, [pc, #68]	; (17398 <minimal_hexdump_line_print+0x64>)
   17352:	f014 fe49 	bl	2bfe8 <printk>
   17356:	e7f5      	b.n	17344 <minimal_hexdump_line_print+0x10>
		}
	}

	printk("|");
   17358:	4810      	ldr	r0, [pc, #64]	; (1739c <minimal_hexdump_line_print+0x68>)
   1735a:	f014 fe45 	bl	2bfe8 <printk>

	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
   1735e:	2400      	movs	r4, #0
   17360:	e003      	b.n	1736a <minimal_hexdump_line_print+0x36>
		if (i < length) {
			unsigned char c = data[i];

			printk("%c", isprint((int)c) != 0 ? c : '.');
   17362:	480f      	ldr	r0, [pc, #60]	; (173a0 <minimal_hexdump_line_print+0x6c>)
   17364:	f014 fe40 	bl	2bfe8 <printk>
	for (size_t i = 0U; i < HEXDUMP_BYTES_IN_LINE; i++) {
   17368:	3401      	adds	r4, #1
   1736a:	2c07      	cmp	r4, #7
   1736c:	d80d      	bhi.n	1738a <minimal_hexdump_line_print+0x56>
		if (i < length) {
   1736e:	42ac      	cmp	r4, r5
   17370:	d207      	bcs.n	17382 <minimal_hexdump_line_print+0x4e>
			unsigned char c = data[i];
   17372:	5d31      	ldrb	r1, [r6, r4]
			printk("%c", isprint((int)c) != 0 ? c : '.');
   17374:	4b0b      	ldr	r3, [pc, #44]	; (173a4 <minimal_hexdump_line_print+0x70>)
   17376:	5ccb      	ldrb	r3, [r1, r3]
   17378:	f013 0f97 	tst.w	r3, #151	; 0x97
   1737c:	d1f1      	bne.n	17362 <minimal_hexdump_line_print+0x2e>
   1737e:	212e      	movs	r1, #46	; 0x2e
   17380:	e7ef      	b.n	17362 <minimal_hexdump_line_print+0x2e>
		} else {
			printk(" ");
   17382:	4809      	ldr	r0, [pc, #36]	; (173a8 <minimal_hexdump_line_print+0x74>)
   17384:	f014 fe30 	bl	2bfe8 <printk>
   17388:	e7ee      	b.n	17368 <minimal_hexdump_line_print+0x34>
		}
	}
	printk("\n");
   1738a:	4808      	ldr	r0, [pc, #32]	; (173ac <minimal_hexdump_line_print+0x78>)
   1738c:	f014 fe2c 	bl	2bfe8 <printk>
}
   17390:	bd70      	pop	{r4, r5, r6, pc}
   17392:	bf00      	nop
   17394:	0003917c 	.word	0x0003917c
   17398:	00039174 	.word	0x00039174
   1739c:	00039180 	.word	0x00039180
   173a0:	00039184 	.word	0x00039184
   173a4:	0003c4c5 	.word	0x0003c4c5
   173a8:	00039178 	.word	0x00039178
   173ac:	0003bd44 	.word	0x0003bd44

000173b0 <z_log_minimal_hexdump_print>:

void z_log_minimal_hexdump_print(int level, const void *data, size_t size)
{
   173b0:	b570      	push	{r4, r5, r6, lr}
   173b2:	4606      	mov	r6, r0
   173b4:	460d      	mov	r5, r1
   173b6:	4614      	mov	r4, r2
	const char *data_buffer = (const char *)data;
	while (size > 0U) {
   173b8:	e00b      	b.n	173d2 <z_log_minimal_hexdump_print+0x22>
	z_log_minimal_printk("\n"); \
} while (false)

static inline char z_log_minimal_level_to_char(int level)
{
	switch (level) {
   173ba:	2145      	movs	r1, #69	; 0x45
		printk("%c: ", z_log_minimal_level_to_char(level));
   173bc:	4811      	ldr	r0, [pc, #68]	; (17404 <z_log_minimal_hexdump_print+0x54>)
   173be:	f014 fe13 	bl	2bfe8 <printk>
		minimal_hexdump_line_print(data_buffer, size);
   173c2:	4621      	mov	r1, r4
   173c4:	4628      	mov	r0, r5
   173c6:	f7ff ffb5 	bl	17334 <minimal_hexdump_line_print>

		if (size < HEXDUMP_BYTES_IN_LINE) {
   173ca:	2c07      	cmp	r4, #7
   173cc:	d918      	bls.n	17400 <z_log_minimal_hexdump_print+0x50>
			break;
		}

		size -= HEXDUMP_BYTES_IN_LINE;
   173ce:	3c08      	subs	r4, #8
		data_buffer += HEXDUMP_BYTES_IN_LINE;
   173d0:	3508      	adds	r5, #8
	while (size > 0U) {
   173d2:	b1ac      	cbz	r4, 17400 <z_log_minimal_hexdump_print+0x50>
   173d4:	1e73      	subs	r3, r6, #1
   173d6:	2b03      	cmp	r3, #3
   173d8:	d80e      	bhi.n	173f8 <z_log_minimal_hexdump_print+0x48>
   173da:	a201      	add	r2, pc, #4	; (adr r2, 173e0 <z_log_minimal_hexdump_print+0x30>)
   173dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   173e0:	000173bb 	.word	0x000173bb
   173e4:	000173fd 	.word	0x000173fd
   173e8:	000173f1 	.word	0x000173f1
   173ec:	000173f5 	.word	0x000173f5
	case LOG_LEVEL_ERR:
		return 'E';
	case LOG_LEVEL_WRN:
		return 'W';
	case LOG_LEVEL_INF:
		return 'I';
   173f0:	2149      	movs	r1, #73	; 0x49
   173f2:	e7e3      	b.n	173bc <z_log_minimal_hexdump_print+0xc>
	case LOG_LEVEL_DBG:
		return 'D';
   173f4:	2144      	movs	r1, #68	; 0x44
   173f6:	e7e1      	b.n	173bc <z_log_minimal_hexdump_print+0xc>
	default:
		return '?';
   173f8:	213f      	movs	r1, #63	; 0x3f
   173fa:	e7df      	b.n	173bc <z_log_minimal_hexdump_print+0xc>
		return 'W';
   173fc:	2157      	movs	r1, #87	; 0x57
   173fe:	e7dd      	b.n	173bc <z_log_minimal_hexdump_print+0xc>
	}
}
   17400:	bd70      	pop	{r4, r5, r6, pc}
   17402:	bf00      	nop
   17404:	00039188 	.word	0x00039188

00017408 <pm_resume_devices>:

	return 0;
}

static void pm_resume_devices(void)
{
   17408:	b510      	push	{r4, lr}
	for (int i = (num_susp - 1); i >= 0; i--) {
   1740a:	4b08      	ldr	r3, [pc, #32]	; (1742c <pm_resume_devices+0x24>)
   1740c:	681c      	ldr	r4, [r3, #0]
   1740e:	3c01      	subs	r4, #1
   17410:	e006      	b.n	17420 <pm_resume_devices+0x18>
		pm_device_action_run(__pm_device_slots_start[i],
   17412:	2101      	movs	r1, #1
   17414:	4b06      	ldr	r3, [pc, #24]	; (17430 <pm_resume_devices+0x28>)
   17416:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
   1741a:	f000 fa8f 	bl	1793c <pm_device_action_run>
	for (int i = (num_susp - 1); i >= 0; i--) {
   1741e:	3c01      	subs	r4, #1
   17420:	2c00      	cmp	r4, #0
   17422:	daf6      	bge.n	17412 <pm_resume_devices+0xa>
				    PM_DEVICE_ACTION_RESUME);
	}

	num_susp = 0;
   17424:	4b01      	ldr	r3, [pc, #4]	; (1742c <pm_resume_devices+0x24>)
   17426:	2200      	movs	r2, #0
   17428:	601a      	str	r2, [r3, #0]
}
   1742a:	bd10      	pop	{r4, pc}
   1742c:	200039cc 	.word	0x200039cc
   17430:	20000e28 	.word	0x20000e28

00017434 <pm_suspend_devices>:
{
   17434:	b530      	push	{r4, r5, lr}
   17436:	b085      	sub	sp, #20
	devc = z_device_get_all_static(&devs);
   17438:	a803      	add	r0, sp, #12
   1743a:	f00e fcb1 	bl	25da0 <z_device_get_all_static>
	num_susp = 0;
   1743e:	4b23      	ldr	r3, [pc, #140]	; (174cc <pm_suspend_devices+0x98>)
   17440:	2200      	movs	r2, #0
   17442:	601a      	str	r2, [r3, #0]
	for (const struct device *dev = devs + devc - 1; dev >= devs; dev--) {
   17444:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   17448:	0084      	lsls	r4, r0, #2
   1744a:	f1a4 031c 	sub.w	r3, r4, #28
   1744e:	9c03      	ldr	r4, [sp, #12]
   17450:	441c      	add	r4, r3
   17452:	e00c      	b.n	1746e <pm_suspend_devices+0x3a>
			LOG_ERR("Device %s did not enter %s state (%d)",
   17454:	6824      	ldr	r4, [r4, #0]
   17456:	2001      	movs	r0, #1
   17458:	f000 fa5a 	bl	17910 <pm_device_state_str>
   1745c:	4603      	mov	r3, r0
   1745e:	9500      	str	r5, [sp, #0]
   17460:	4622      	mov	r2, r4
   17462:	2145      	movs	r1, #69	; 0x45
   17464:	481a      	ldr	r0, [pc, #104]	; (174d0 <pm_suspend_devices+0x9c>)
   17466:	f015 f871 	bl	2c54c <z_log_minimal_printk>
			return ret;
   1746a:	e02b      	b.n	174c4 <pm_suspend_devices+0x90>
	for (const struct device *dev = devs + devc - 1; dev >= devs; dev--) {
   1746c:	3c1c      	subs	r4, #28
   1746e:	9b03      	ldr	r3, [sp, #12]
   17470:	429c      	cmp	r4, r3
   17472:	d326      	bcc.n	174c2 <pm_suspend_devices+0x8e>
		if (pm_device_is_busy(dev) || pm_device_state_is_locked(dev)
   17474:	4620      	mov	r0, r4
   17476:	f015 f882 	bl	2c57e <pm_device_is_busy>
   1747a:	2800      	cmp	r0, #0
   1747c:	d1f6      	bne.n	1746c <pm_suspend_devices+0x38>
   1747e:	4620      	mov	r0, r4
   17480:	f015 f895 	bl	2c5ae <pm_device_state_is_locked>
   17484:	2800      	cmp	r0, #0
   17486:	d1f1      	bne.n	1746c <pm_suspend_devices+0x38>
		    || pm_device_wakeup_is_enabled(dev) ||
   17488:	4620      	mov	r0, r4
   1748a:	f015 f884 	bl	2c596 <pm_device_wakeup_is_enabled>
   1748e:	2800      	cmp	r0, #0
   17490:	d1ec      	bne.n	1746c <pm_suspend_devices+0x38>
		ret = pm_device_action_run(dev, PM_DEVICE_ACTION_SUSPEND);
   17492:	2100      	movs	r1, #0
   17494:	4620      	mov	r0, r4
   17496:	f000 fa51 	bl	1793c <pm_device_action_run>
   1749a:	4605      	mov	r5, r0
		if ((ret == -ENOSYS) || (ret == -ENOTSUP) || (ret == -EALREADY)) {
   1749c:	f110 0f58 	cmn.w	r0, #88	; 0x58
   174a0:	d0e4      	beq.n	1746c <pm_suspend_devices+0x38>
   174a2:	f110 0f86 	cmn.w	r0, #134	; 0x86
   174a6:	d0e1      	beq.n	1746c <pm_suspend_devices+0x38>
   174a8:	f110 0f78 	cmn.w	r0, #120	; 0x78
   174ac:	d0de      	beq.n	1746c <pm_suspend_devices+0x38>
		} else if (ret < 0) {
   174ae:	2800      	cmp	r0, #0
   174b0:	dbd0      	blt.n	17454 <pm_suspend_devices+0x20>
		__pm_device_slots_start[num_susp] = dev;
   174b2:	4a06      	ldr	r2, [pc, #24]	; (174cc <pm_suspend_devices+0x98>)
   174b4:	6813      	ldr	r3, [r2, #0]
   174b6:	4907      	ldr	r1, [pc, #28]	; (174d4 <pm_suspend_devices+0xa0>)
   174b8:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
		num_susp++;
   174bc:	3301      	adds	r3, #1
   174be:	6013      	str	r3, [r2, #0]
   174c0:	e7d4      	b.n	1746c <pm_suspend_devices+0x38>
	return 0;
   174c2:	2500      	movs	r5, #0
}
   174c4:	4628      	mov	r0, r5
   174c6:	b005      	add	sp, #20
   174c8:	bd30      	pop	{r4, r5, pc}
   174ca:	bf00      	nop
   174cc:	200039cc 	.word	0x200039cc
   174d0:	00039190 	.word	0x00039190
   174d4:	20000e28 	.word	0x20000e28

000174d8 <pm_system_resume>:
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}

void pm_system_resume(void)
{
   174d8:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
   174da:	4b3b      	ldr	r3, [pc, #236]	; (175c8 <pm_system_resume+0xf0>)
   174dc:	7d1d      	ldrb	r5, [r3, #20]
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   174de:	f005 031f 	and.w	r3, r5, #31
   174e2:	2201      	movs	r2, #1
   174e4:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   174e6:	0969      	lsrs	r1, r5, #5
   174e8:	4b38      	ldr	r3, [pc, #224]	; (175cc <pm_system_resume+0xf4>)
   174ea:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   174ee:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   174f0:	f3bf 8f5b 	dmb	ish
   174f4:	e853 1f00 	ldrex	r1, [r3]
   174f8:	ea01 0400 	and.w	r4, r1, r0
   174fc:	e843 4600 	strex	r6, r4, [r3]
   17500:	2e00      	cmp	r6, #0
   17502:	d1f7      	bne.n	174f4 <pm_system_resume+0x1c>
   17504:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   17508:	420a      	tst	r2, r1
   1750a:	d100      	bne.n	1750e <pm_system_resume+0x36>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
			0, 0};
	}
}
   1750c:	bd70      	pop	{r4, r5, r6, pc}
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
   1750e:	4a30      	ldr	r2, [pc, #192]	; (175d0 <pm_system_resume+0xf8>)
   17510:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   17514:	0098      	lsls	r0, r3, #2
   17516:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	if (pm_state_exit_post_ops != NULL) {
   1751a:	492e      	ldr	r1, [pc, #184]	; (175d4 <pm_system_resume+0xfc>)
   1751c:	b1a9      	cbz	r1, 1754a <pm_system_resume+0x72>
		pm_state_exit_post_ops(info->state, info->substate_id);
   1751e:	7859      	ldrb	r1, [r3, #1]
   17520:	5c10      	ldrb	r0, [r2, r0]
   17522:	f015 fa12 	bl	2c94a <pm_state_exit_post_ops>
	__asm__ volatile(
   17526:	f04f 0340 	mov.w	r3, #64	; 0x40
   1752a:	f3ef 8611 	mrs	r6, BASEPRI
   1752e:	f383 8812 	msr	BASEPRI_MAX, r3
   17532:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17536:	4828      	ldr	r0, [pc, #160]	; (175d8 <pm_system_resume+0x100>)
   17538:	f00f f8b4 	bl	266a4 <z_spin_lock_valid>
   1753c:	b158      	cbz	r0, 17556 <pm_system_resume+0x7e>
	z_spin_lock_set_owner(l);
   1753e:	4826      	ldr	r0, [pc, #152]	; (175d8 <pm_system_resume+0x100>)
   17540:	f00f f8d0 	bl	266e4 <z_spin_lock_set_owner>
	return list->head;
   17544:	4b25      	ldr	r3, [pc, #148]	; (175dc <pm_system_resume+0x104>)
   17546:	681c      	ldr	r4, [r3, #0]
   17548:	e01b      	b.n	17582 <pm_system_resume+0xaa>
	__asm__ volatile(
   1754a:	2300      	movs	r3, #0
   1754c:	f383 8811 	msr	BASEPRI, r3
   17550:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   17554:	e7e7      	b.n	17526 <pm_system_resume+0x4e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17556:	4c22      	ldr	r4, [pc, #136]	; (175e0 <pm_system_resume+0x108>)
   17558:	228e      	movs	r2, #142	; 0x8e
   1755a:	4621      	mov	r1, r4
   1755c:	4821      	ldr	r0, [pc, #132]	; (175e4 <pm_system_resume+0x10c>)
   1755e:	f014 ffe6 	bl	2c52e <assert_print>
   17562:	218e      	movs	r1, #142	; 0x8e
   17564:	4620      	mov	r0, r4
   17566:	f014 ffdb 	bl	2c520 <assert_post_action>
   1756a:	e7e8      	b.n	1753e <pm_system_resume+0x66>
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1756c:	4b16      	ldr	r3, [pc, #88]	; (175c8 <pm_system_resume+0xf0>)
   1756e:	7d1b      	ldrb	r3, [r3, #20]
   17570:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   17574:	4916      	ldr	r1, [pc, #88]	; (175d0 <pm_system_resume+0xf8>)
   17576:	f811 0023 	ldrb.w	r0, [r1, r3, lsl #2]
   1757a:	4790      	blx	r2
Z_GENLIST_PEEK_NEXT(slist, snode)
   1757c:	b10c      	cbz	r4, 17582 <pm_system_resume+0xaa>
	return node->next;
   1757e:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   17580:	b124      	cbz	r4, 1758c <pm_system_resume+0xb4>
   17582:	b11c      	cbz	r4, 1758c <pm_system_resume+0xb4>
			callback = notifier->state_exit;
   17584:	68a2      	ldr	r2, [r4, #8]
		if (callback) {
   17586:	2a00      	cmp	r2, #0
   17588:	d1f0      	bne.n	1756c <pm_system_resume+0x94>
   1758a:	e7f7      	b.n	1757c <pm_system_resume+0xa4>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1758c:	4812      	ldr	r0, [pc, #72]	; (175d8 <pm_system_resume+0x100>)
   1758e:	f00f f899 	bl	266c4 <z_spin_unlock_valid>
   17592:	b170      	cbz	r0, 175b2 <pm_system_resume+0xda>
	__asm__ volatile(
   17594:	f386 8811 	msr	BASEPRI, r6
   17598:	f3bf 8f6f 	isb	sy
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   1759c:	4a0c      	ldr	r2, [pc, #48]	; (175d0 <pm_system_resume+0xf8>)
   1759e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   175a2:	00a9      	lsls	r1, r5, #2
   175a4:	eb02 0585 	add.w	r5, r2, r5, lsl #2
   175a8:	2300      	movs	r3, #0
   175aa:	5053      	str	r3, [r2, r1]
   175ac:	606b      	str	r3, [r5, #4]
   175ae:	60ab      	str	r3, [r5, #8]
}
   175b0:	e7ac      	b.n	1750c <pm_system_resume+0x34>
   175b2:	4c0b      	ldr	r4, [pc, #44]	; (175e0 <pm_system_resume+0x108>)
   175b4:	22b9      	movs	r2, #185	; 0xb9
   175b6:	4621      	mov	r1, r4
   175b8:	480a      	ldr	r0, [pc, #40]	; (175e4 <pm_system_resume+0x10c>)
   175ba:	f014 ffb8 	bl	2c52e <assert_print>
   175be:	21b9      	movs	r1, #185	; 0xb9
   175c0:	4620      	mov	r0, r4
   175c2:	f014 ffad 	bl	2c520 <assert_post_action>
   175c6:	e7e5      	b.n	17594 <pm_system_resume+0xbc>
   175c8:	200046a4 	.word	0x200046a4
   175cc:	200039f8 	.word	0x200039f8
   175d0:	200039ec 	.word	0x200039ec
   175d4:	0002c94b 	.word	0x0002c94b
   175d8:	200039d4 	.word	0x200039d4
   175dc:	200039d8 	.word	0x200039d8
   175e0:	000390f0 	.word	0x000390f0
   175e4:	00031600 	.word	0x00031600

000175e8 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
   175e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   175ea:	4604      	mov	r4, r0
	uint8_t id = CURRENT_CPU;
   175ec:	4b91      	ldr	r3, [pc, #580]	; (17834 <pm_system_suspend+0x24c>)
   175ee:	7d1d      	ldrb	r5, [r3, #20]
	__asm__ volatile(
   175f0:	f04f 0340 	mov.w	r3, #64	; 0x40
   175f4:	f3ef 8611 	mrs	r6, BASEPRI
   175f8:	f383 8812 	msr	BASEPRI_MAX, r3
   175fc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17600:	488d      	ldr	r0, [pc, #564]	; (17838 <pm_system_suspend+0x250>)
   17602:	f00f f84f 	bl	266a4 <z_spin_lock_valid>
   17606:	2800      	cmp	r0, #0
   17608:	d05a      	beq.n	176c0 <pm_system_suspend+0xd8>
	z_spin_lock_set_owner(l);
   1760a:	488b      	ldr	r0, [pc, #556]	; (17838 <pm_system_suspend+0x250>)
   1760c:	f00f f86a 	bl	266e4 <z_spin_lock_set_owner>
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
   17610:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   17614:	4a89      	ldr	r2, [pc, #548]	; (1783c <pm_system_suspend+0x254>)
   17616:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
   1761a:	2b00      	cmp	r3, #0
   1761c:	d05b      	beq.n	176d6 <pm_system_suspend+0xee>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
   1761e:	eb05 0c45 	add.w	ip, r5, r5, lsl #1
   17622:	4b87      	ldr	r3, [pc, #540]	; (17840 <pm_system_suspend+0x258>)
   17624:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   17628:	4617      	mov	r7, r2
   1762a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1762e:	ea4f 0e83 	mov.w	lr, r3, lsl #2
   17632:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   17636:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   1763a:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
   1763e:	2300      	movs	r3, #0
   17640:	f807 300e 	strb.w	r3, [r7, lr]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   17644:	487c      	ldr	r0, [pc, #496]	; (17838 <pm_system_suspend+0x250>)
   17646:	f00f f83d 	bl	266c4 <z_spin_unlock_valid>
   1764a:	2800      	cmp	r0, #0
   1764c:	d052      	beq.n	176f4 <pm_system_suspend+0x10c>
	__asm__ volatile(
   1764e:	f386 8811 	msr	BASEPRI, r6
   17652:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
   17656:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1765a:	4a79      	ldr	r2, [pc, #484]	; (17840 <pm_system_suspend+0x258>)
   1765c:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
   17660:	2b00      	cmp	r3, #0
   17662:	f000 80e5 	beq.w	17830 <pm_system_suspend+0x248>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
   17666:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   1766a:	d14e      	bne.n	1770a <pm_system_suspend+0x122>
			     z_cpus_pm_state[id].exit_latency_us),
				     true);
	}

#if defined(CONFIG_PM_DEVICE) && !defined(CONFIG_PM_DEVICE_RUNTIME_EXCLUSIVE)
	if ((z_cpus_pm_state[id].state != PM_STATE_RUNTIME_IDLE) &&
   1766c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   17670:	4a73      	ldr	r2, [pc, #460]	; (17840 <pm_system_suspend+0x258>)
   17672:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
   17676:	2b01      	cmp	r3, #1
   17678:	d00d      	beq.n	17696 <pm_system_suspend+0xae>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   1767a:	4b72      	ldr	r3, [pc, #456]	; (17844 <pm_system_suspend+0x25c>)
   1767c:	f3bf 8f5b 	dmb	ish
   17680:	e853 2f00 	ldrex	r2, [r3]
   17684:	1e51      	subs	r1, r2, #1
   17686:	e843 1000 	strex	r0, r1, [r3]
   1768a:	2800      	cmp	r0, #0
   1768c:	d1f8      	bne.n	17680 <pm_system_suspend+0x98>
   1768e:	f3bf 8f5b 	dmb	ish
   17692:	2a01      	cmp	r2, #1
   17694:	d04e      	beq.n	17734 <pm_system_suspend+0x14c>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   17696:	f010 fbb5 	bl	27e04 <k_sched_lock>
	__asm__ volatile(
   1769a:	f04f 0340 	mov.w	r3, #64	; 0x40
   1769e:	f3ef 8611 	mrs	r6, BASEPRI
   176a2:	f383 8812 	msr	BASEPRI_MAX, r3
   176a6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   176aa:	4867      	ldr	r0, [pc, #412]	; (17848 <pm_system_suspend+0x260>)
   176ac:	f00e fffa 	bl	266a4 <z_spin_lock_valid>
   176b0:	2800      	cmp	r0, #0
   176b2:	d058      	beq.n	17766 <pm_system_suspend+0x17e>
	z_spin_lock_set_owner(l);
   176b4:	4864      	ldr	r0, [pc, #400]	; (17848 <pm_system_suspend+0x260>)
   176b6:	f00f f815 	bl	266e4 <z_spin_lock_set_owner>
	return list->head;
   176ba:	4b64      	ldr	r3, [pc, #400]	; (1784c <pm_system_suspend+0x264>)
   176bc:	681c      	ldr	r4, [r3, #0]
   176be:	e068      	b.n	17792 <pm_system_suspend+0x1aa>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   176c0:	4f63      	ldr	r7, [pc, #396]	; (17850 <pm_system_suspend+0x268>)
   176c2:	228e      	movs	r2, #142	; 0x8e
   176c4:	4639      	mov	r1, r7
   176c6:	4863      	ldr	r0, [pc, #396]	; (17854 <pm_system_suspend+0x26c>)
   176c8:	f014 ff31 	bl	2c52e <assert_print>
   176cc:	218e      	movs	r1, #142	; 0x8e
   176ce:	4638      	mov	r0, r7
   176d0:	f014 ff26 	bl	2c520 <assert_post_action>
   176d4:	e799      	b.n	1760a <pm_system_suspend+0x22>
		info = pm_policy_next_state(id, ticks);
   176d6:	4621      	mov	r1, r4
   176d8:	4628      	mov	r0, r5
   176da:	f000 f8c5 	bl	17868 <pm_policy_next_state>
		if (info != NULL) {
   176de:	2800      	cmp	r0, #0
   176e0:	d0b0      	beq.n	17644 <pm_system_suspend+0x5c>
			z_cpus_pm_state[id] = *info;
   176e2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   176e6:	4a56      	ldr	r2, [pc, #344]	; (17840 <pm_system_suspend+0x258>)
   176e8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   176ec:	c807      	ldmia	r0, {r0, r1, r2}
   176ee:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   176f2:	e7a7      	b.n	17644 <pm_system_suspend+0x5c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   176f4:	4f56      	ldr	r7, [pc, #344]	; (17850 <pm_system_suspend+0x268>)
   176f6:	22b9      	movs	r2, #185	; 0xb9
   176f8:	4639      	mov	r1, r7
   176fa:	4856      	ldr	r0, [pc, #344]	; (17854 <pm_system_suspend+0x26c>)
   176fc:	f014 ff17 	bl	2c52e <assert_print>
   17700:	21b9      	movs	r1, #185	; 0xb9
   17702:	4638      	mov	r0, r7
   17704:	f014 ff0c 	bl	2c520 <assert_post_action>
   17708:	e7a1      	b.n	1764e <pm_system_suspend+0x66>
		     k_us_to_ticks_ceil32(
   1770a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   1770e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   17712:	6898      	ldr	r0, [r3, #8]
			return (uint32_t)((t * to_hz + off) / from_hz);
   17714:	0c41      	lsrs	r1, r0, #17
   17716:	03c0      	lsls	r0, r0, #15
   17718:	4b4f      	ldr	r3, [pc, #316]	; (17858 <pm_system_suspend+0x270>)
   1771a:	18c0      	adds	r0, r0, r3
   1771c:	4a4f      	ldr	r2, [pc, #316]	; (1785c <pm_system_suspend+0x274>)
   1771e:	f04f 0300 	mov.w	r3, #0
   17722:	f141 0100 	adc.w	r1, r1, #0
   17726:	f7e9 fa57 	bl	bd8 <__aeabi_uldivmod>
		z_set_timeout_expiry(ticks -
   1772a:	2101      	movs	r1, #1
   1772c:	1a20      	subs	r0, r4, r0
   1772e:	f011 fe2f 	bl	29390 <z_set_timeout_expiry>
   17732:	e79b      	b.n	1766c <pm_system_suspend+0x84>
		if (pm_suspend_devices()) {
   17734:	f7ff fe7e 	bl	17434 <pm_suspend_devices>
   17738:	2800      	cmp	r0, #0
   1773a:	d0ac      	beq.n	17696 <pm_system_suspend+0xae>
			pm_resume_devices();
   1773c:	f7ff fe64 	bl	17408 <pm_resume_devices>
			z_cpus_pm_state[id].state = PM_STATE_ACTIVE;
   17740:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   17744:	00ab      	lsls	r3, r5, #2
   17746:	2000      	movs	r0, #0
   17748:	4a3d      	ldr	r2, [pc, #244]	; (17840 <pm_system_suspend+0x258>)
   1774a:	54d0      	strb	r0, [r2, r3]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1774c:	4b3d      	ldr	r3, [pc, #244]	; (17844 <pm_system_suspend+0x25c>)
   1774e:	f3bf 8f5b 	dmb	ish
   17752:	e853 2f00 	ldrex	r2, [r3]
   17756:	3201      	adds	r2, #1
   17758:	e843 2100 	strex	r1, r2, [r3]
   1775c:	2900      	cmp	r1, #0
   1775e:	d1f8      	bne.n	17752 <pm_system_suspend+0x16a>
   17760:	f3bf 8f5b 	dmb	ish
			return false;
   17764:	e055      	b.n	17812 <pm_system_suspend+0x22a>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17766:	4c3a      	ldr	r4, [pc, #232]	; (17850 <pm_system_suspend+0x268>)
   17768:	228e      	movs	r2, #142	; 0x8e
   1776a:	4621      	mov	r1, r4
   1776c:	4839      	ldr	r0, [pc, #228]	; (17854 <pm_system_suspend+0x26c>)
   1776e:	f014 fede 	bl	2c52e <assert_print>
   17772:	218e      	movs	r1, #142	; 0x8e
   17774:	4620      	mov	r0, r4
   17776:	f014 fed3 	bl	2c520 <assert_post_action>
   1777a:	e79b      	b.n	176b4 <pm_system_suspend+0xcc>
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1777c:	4b2d      	ldr	r3, [pc, #180]	; (17834 <pm_system_suspend+0x24c>)
   1777e:	7d1b      	ldrb	r3, [r3, #20]
   17780:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   17784:	492e      	ldr	r1, [pc, #184]	; (17840 <pm_system_suspend+0x258>)
   17786:	f811 0023 	ldrb.w	r0, [r1, r3, lsl #2]
   1778a:	4790      	blx	r2
Z_GENLIST_PEEK_NEXT(slist, snode)
   1778c:	b10c      	cbz	r4, 17792 <pm_system_suspend+0x1aa>
	return node->next;
   1778e:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   17790:	b124      	cbz	r4, 1779c <pm_system_suspend+0x1b4>
   17792:	b11c      	cbz	r4, 1779c <pm_system_suspend+0x1b4>
			callback = notifier->state_entry;
   17794:	6862      	ldr	r2, [r4, #4]
		if (callback) {
   17796:	2a00      	cmp	r2, #0
   17798:	d1f0      	bne.n	1777c <pm_system_suspend+0x194>
   1779a:	e7f7      	b.n	1778c <pm_system_suspend+0x1a4>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1779c:	482a      	ldr	r0, [pc, #168]	; (17848 <pm_system_suspend+0x260>)
   1779e:	f00e ff91 	bl	266c4 <z_spin_unlock_valid>
   177a2:	b3b8      	cbz	r0, 17814 <pm_system_suspend+0x22c>
	__asm__ volatile(
   177a4:	f386 8811 	msr	BASEPRI, r6
   177a8:	f3bf 8f6f 	isb	sy
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   177ac:	f005 031f 	and.w	r3, r5, #31
   177b0:	2101      	movs	r1, #1
   177b2:	4099      	lsls	r1, r3

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   177b4:	096b      	lsrs	r3, r5, #5
   177b6:	4a2a      	ldr	r2, [pc, #168]	; (17860 <pm_system_suspend+0x278>)
   177b8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   177bc:	f3bf 8f5b 	dmb	ish
   177c0:	e853 2f00 	ldrex	r2, [r3]
   177c4:	430a      	orrs	r2, r1
   177c6:	e843 2000 	strex	r0, r2, [r3]
   177ca:	2800      	cmp	r0, #0
   177cc:	d1f8      	bne.n	177c0 <pm_system_suspend+0x1d8>
   177ce:	f3bf 8f5b 	dmb	ish
	if (pm_state_set != NULL) {
   177d2:	4b24      	ldr	r3, [pc, #144]	; (17864 <pm_system_suspend+0x27c>)
   177d4:	b15b      	cbz	r3, 177ee <pm_system_suspend+0x206>
		pm_state_set(info->state, info->substate_id);
   177d6:	4a1a      	ldr	r2, [pc, #104]	; (17840 <pm_system_suspend+0x258>)
   177d8:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   177dc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   177e0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   177e4:	7859      	ldrb	r1, [r3, #1]
   177e6:	f812 0025 	ldrb.w	r0, [r2, r5, lsl #2]
   177ea:	f015 f8a2 	bl	2c932 <pm_state_set>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   177ee:	4b15      	ldr	r3, [pc, #84]	; (17844 <pm_system_suspend+0x25c>)
   177f0:	f3bf 8f5b 	dmb	ish
   177f4:	e853 2f00 	ldrex	r2, [r3]
   177f8:	1c51      	adds	r1, r2, #1
   177fa:	e843 1000 	strex	r0, r1, [r3]
   177fe:	2800      	cmp	r0, #0
   17800:	d1f8      	bne.n	177f4 <pm_system_suspend+0x20c>
   17802:	f3bf 8f5b 	dmb	ish
	state_set(&z_cpus_pm_state[id]);
	pm_stats_stop();

	/* Wake up sequence starts here */
#if defined(CONFIG_PM_DEVICE) && !defined(CONFIG_PM_DEVICE_RUNTIME_EXCLUSIVE)
	if (atomic_add(&z_cpus_active, 1) == 0) {
   17806:	b182      	cbz	r2, 1782a <pm_system_suspend+0x242>
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
   17808:	f7ff fe66 	bl	174d8 <pm_system_resume>
	k_sched_unlock();
   1780c:	f011 f80e 	bl	2882c <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
   17810:	2001      	movs	r0, #1
}
   17812:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   17814:	4c0e      	ldr	r4, [pc, #56]	; (17850 <pm_system_suspend+0x268>)
   17816:	22b9      	movs	r2, #185	; 0xb9
   17818:	4621      	mov	r1, r4
   1781a:	480e      	ldr	r0, [pc, #56]	; (17854 <pm_system_suspend+0x26c>)
   1781c:	f014 fe87 	bl	2c52e <assert_print>
   17820:	21b9      	movs	r1, #185	; 0xb9
   17822:	4620      	mov	r0, r4
   17824:	f014 fe7c 	bl	2c520 <assert_post_action>
   17828:	e7bc      	b.n	177a4 <pm_system_suspend+0x1bc>
		pm_resume_devices();
   1782a:	f7ff fded 	bl	17408 <pm_resume_devices>
   1782e:	e7eb      	b.n	17808 <pm_system_suspend+0x220>
		return false;
   17830:	2000      	movs	r0, #0
   17832:	e7ee      	b.n	17812 <pm_system_suspend+0x22a>
   17834:	200046a4 	.word	0x200046a4
   17838:	200039d0 	.word	0x200039d0
   1783c:	200039e0 	.word	0x200039e0
   17840:	200039ec 	.word	0x200039ec
   17844:	20000af4 	.word	0x20000af4
   17848:	200039d4 	.word	0x200039d4
   1784c:	200039d8 	.word	0x200039d8
   17850:	000390f0 	.word	0x000390f0
   17854:	00031600 	.word	0x00031600
   17858:	000f423f 	.word	0x000f423f
   1785c:	000f4240 	.word	0x000f4240
   17860:	200039f8 	.word	0x200039f8
   17864:	0002c933 	.word	0x0002c933

00017868 <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
   17868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1786c:	b082      	sub	sp, #8
   1786e:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
   17870:	a901      	add	r1, sp, #4
   17872:	f000 f845 	bl	17900 <pm_state_cpu_get_all>

	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   17876:	1e44      	subs	r4, r0, #1
   17878:	b224      	sxth	r4, r4
   1787a:	e007      	b.n	1788c <pm_policy_next_state+0x24>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
		    (exit_latency >= max_latency_ticks)) {
			continue;
		}

		if ((ticks == K_TICKS_FOREVER) ||
   1787c:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
   17880:	d033      	beq.n	178ea <pm_policy_next_state+0x82>
		    (ticks >= (min_residency + exit_latency))) {
   17882:	4440      	add	r0, r8
		if ((ticks == K_TICKS_FOREVER) ||
   17884:	42b0      	cmp	r0, r6
   17886:	d930      	bls.n	178ea <pm_policy_next_state+0x82>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   17888:	3c01      	subs	r4, #1
   1788a:	b224      	sxth	r4, r4
   1788c:	2c00      	cmp	r4, #0
   1788e:	db2b      	blt.n	178e8 <pm_policy_next_state+0x80>
		const struct pm_state_info *state = &cpu_states[i];
   17890:	9b01      	ldr	r3, [sp, #4]
   17892:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   17896:	eb03 0582 	add.w	r5, r3, r2, lsl #2
		if (pm_policy_state_lock_is_active(state->state, state->substate_id)) {
   1789a:	7869      	ldrb	r1, [r5, #1]
   1789c:	f813 0022 	ldrb.w	r0, [r3, r2, lsl #2]
   178a0:	f014 fe62 	bl	2c568 <pm_policy_state_lock_is_active>
   178a4:	2800      	cmp	r0, #0
   178a6:	d1ef      	bne.n	17888 <pm_policy_next_state+0x20>
		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
   178a8:	6868      	ldr	r0, [r5, #4]
   178aa:	0c41      	lsrs	r1, r0, #17
   178ac:	03c0      	lsls	r0, r0, #15
   178ae:	4f11      	ldr	r7, [pc, #68]	; (178f4 <pm_policy_next_state+0x8c>)
   178b0:	19c0      	adds	r0, r0, r7
   178b2:	4a11      	ldr	r2, [pc, #68]	; (178f8 <pm_policy_next_state+0x90>)
   178b4:	f04f 0300 	mov.w	r3, #0
   178b8:	f141 0100 	adc.w	r1, r1, #0
   178bc:	f7e9 f98c 	bl	bd8 <__aeabi_uldivmod>
   178c0:	4680      	mov	r8, r0
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);
   178c2:	68ab      	ldr	r3, [r5, #8]
   178c4:	0c59      	lsrs	r1, r3, #17
   178c6:	03db      	lsls	r3, r3, #15
   178c8:	19d8      	adds	r0, r3, r7
   178ca:	4a0b      	ldr	r2, [pc, #44]	; (178f8 <pm_policy_next_state+0x90>)
   178cc:	f04f 0300 	mov.w	r3, #0
   178d0:	f141 0100 	adc.w	r1, r1, #0
   178d4:	f7e9 f980 	bl	bd8 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   178d8:	4b08      	ldr	r3, [pc, #32]	; (178fc <pm_policy_next_state+0x94>)
   178da:	681b      	ldr	r3, [r3, #0]
   178dc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   178e0:	d0cc      	beq.n	1787c <pm_policy_next_state+0x14>
   178e2:	4283      	cmp	r3, r0
   178e4:	d8ca      	bhi.n	1787c <pm_policy_next_state+0x14>
   178e6:	e7cf      	b.n	17888 <pm_policy_next_state+0x20>
			return state;
		}
	}

	return NULL;
   178e8:	2500      	movs	r5, #0
}
   178ea:	4628      	mov	r0, r5
   178ec:	b002      	add	sp, #8
   178ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   178f2:	bf00      	nop
   178f4:	000f423f 	.word	0x000f423f
   178f8:	000f4240 	.word	0x000f4240
   178fc:	20000af8 	.word	0x20000af8

00017900 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD(DT_PATH(cpus), NUM_CPU_STATES)
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
   17900:	b908      	cbnz	r0, 17906 <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
   17902:	4b02      	ldr	r3, [pc, #8]	; (1790c <pm_state_cpu_get_all+0xc>)
   17904:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
   17906:	2000      	movs	r0, #0
   17908:	4770      	bx	lr
   1790a:	bf00      	nop
   1790c:	000391c0 	.word	0x000391c0

00017910 <pm_device_state_str>:
	[PM_DEVICE_ACTION_TURN_ON] = PM_DEVICE_STATE_OFF,
};

const char *pm_device_state_str(enum pm_device_state state)
{
	switch (state) {
   17910:	2801      	cmp	r0, #1
   17912:	d006      	beq.n	17922 <pm_device_state_str+0x12>
   17914:	2803      	cmp	r0, #3
   17916:	d006      	beq.n	17926 <pm_device_state_str+0x16>
   17918:	b108      	cbz	r0, 1791e <pm_device_state_str+0xe>
	case PM_DEVICE_STATE_SUSPENDED:
		return "suspended";
	case PM_DEVICE_STATE_OFF:
		return "off";
	default:
		return "";
   1791a:	4804      	ldr	r0, [pc, #16]	; (1792c <pm_device_state_str+0x1c>)
	}
}
   1791c:	4770      	bx	lr
	switch (state) {
   1791e:	4804      	ldr	r0, [pc, #16]	; (17930 <pm_device_state_str+0x20>)
   17920:	4770      	bx	lr
		return "suspended";
   17922:	4804      	ldr	r0, [pc, #16]	; (17934 <pm_device_state_str+0x24>)
   17924:	4770      	bx	lr
		return "off";
   17926:	4804      	ldr	r0, [pc, #16]	; (17938 <pm_device_state_str+0x28>)
   17928:	4770      	bx	lr
   1792a:	bf00      	nop
   1792c:	00039828 	.word	0x00039828
   17930:	000391d0 	.word	0x000391d0
   17934:	000391c4 	.word	0x000391c4
   17938:	000391c0 	.word	0x000391c0

0001793c <pm_device_action_run>:

int pm_device_action_run(const struct device *dev,
			 enum pm_device_action action)
{
   1793c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct pm_device *pm = dev->pm;
   1793e:	6987      	ldr	r7, [r0, #24]
	int ret;

	if (pm == NULL) {
   17940:	2f00      	cmp	r7, #0
   17942:	d03e      	beq.n	179c2 <pm_device_action_run+0x86>
   17944:	4605      	mov	r5, r0
   17946:	460c      	mov	r4, r1
		return -ENOSYS;
	}

	if (pm_device_state_is_locked(dev)) {
   17948:	f014 fe31 	bl	2c5ae <pm_device_state_is_locked>
   1794c:	2800      	cmp	r0, #0
   1794e:	d13b      	bne.n	179c8 <pm_device_action_run+0x8c>
		return -EPERM;
	}

	/* Validate action against current state */
	if (pm->state == action_target_state[action]) {
   17950:	7a3b      	ldrb	r3, [r7, #8]
   17952:	4a22      	ldr	r2, [pc, #136]	; (179dc <pm_device_action_run+0xa0>)
   17954:	5d16      	ldrb	r6, [r2, r4]
   17956:	42b3      	cmp	r3, r6
   17958:	d039      	beq.n	179ce <pm_device_action_run+0x92>
		return -EALREADY;
	}
	if (pm->state != action_expected_state[action]) {
   1795a:	4a21      	ldr	r2, [pc, #132]	; (179e0 <pm_device_action_run+0xa4>)
   1795c:	5d12      	ldrb	r2, [r2, r4]
   1795e:	4293      	cmp	r3, r2
   17960:	d138      	bne.n	179d4 <pm_device_action_run+0x98>
		return -ENOTSUP;
	}

	ret = pm->action_cb(dev, action);
   17962:	68fb      	ldr	r3, [r7, #12]
   17964:	4621      	mov	r1, r4
   17966:	4628      	mov	r0, r5
   17968:	4798      	blx	r3
	if (ret < 0) {
   1796a:	2800      	cmp	r0, #0
   1796c:	db04      	blt.n	17978 <pm_device_action_run+0x3c>
			break;
		}
		return ret;
	}

	pm->state = action_target_state[action];
   1796e:	723e      	strb	r6, [r7, #8]
	/* Power up failure flag is no longer relevant */
	if (action == PM_DEVICE_ACTION_TURN_OFF) {
   17970:	2c02      	cmp	r4, #2
   17972:	d017      	beq.n	179a4 <pm_device_action_run+0x68>
		atomic_clear_bit(&pm->flags, PM_DEVICE_FLAG_TURN_ON_FAILED);
	}

	return 0;
   17974:	2000      	movs	r0, #0
}
   17976:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (action) {
   17978:	2c02      	cmp	r4, #2
   1797a:	d011      	beq.n	179a0 <pm_device_action_run+0x64>
   1797c:	2c03      	cmp	r4, #3
   1797e:	d1fa      	bne.n	17976 <pm_device_action_run+0x3a>
			if (ret != -ENOTSUP) {
   17980:	f110 0f86 	cmn.w	r0, #134	; 0x86
   17984:	d00c      	beq.n	179a0 <pm_device_action_run+0x64>
				atomic_set_bit(&pm->flags, PM_DEVICE_FLAG_TURN_ON_FAILED);
   17986:	1d3b      	adds	r3, r7, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   17988:	f3bf 8f5b 	dmb	ish
   1798c:	e853 2f00 	ldrex	r2, [r3]
   17990:	f042 0202 	orr.w	r2, r2, #2
   17994:	e843 2100 	strex	r1, r2, [r3]
   17998:	2900      	cmp	r1, #0
   1799a:	d1f7      	bne.n	1798c <pm_device_action_run+0x50>
   1799c:	f3bf 8f5b 	dmb	ish
			pm->state = action_target_state[action];
   179a0:	723e      	strb	r6, [r7, #8]
		return ret;
   179a2:	e7e8      	b.n	17976 <pm_device_action_run+0x3a>
		atomic_clear_bit(&pm->flags, PM_DEVICE_FLAG_TURN_ON_FAILED);
   179a4:	1d3b      	adds	r3, r7, #4
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   179a6:	f3bf 8f5b 	dmb	ish
   179aa:	e853 2f00 	ldrex	r2, [r3]
   179ae:	f022 0202 	bic.w	r2, r2, #2
   179b2:	e843 2100 	strex	r1, r2, [r3]
   179b6:	2900      	cmp	r1, #0
   179b8:	d1f7      	bne.n	179aa <pm_device_action_run+0x6e>
   179ba:	f3bf 8f5b 	dmb	ish
	return 0;
   179be:	2000      	movs	r0, #0
}
   179c0:	e7d9      	b.n	17976 <pm_device_action_run+0x3a>
		return -ENOSYS;
   179c2:	f06f 0057 	mvn.w	r0, #87	; 0x57
   179c6:	e7d6      	b.n	17976 <pm_device_action_run+0x3a>
		return -EPERM;
   179c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   179cc:	e7d3      	b.n	17976 <pm_device_action_run+0x3a>
		return -EALREADY;
   179ce:	f06f 0077 	mvn.w	r0, #119	; 0x77
   179d2:	e7d0      	b.n	17976 <pm_device_action_run+0x3a>
		return -ENOTSUP;
   179d4:	f06f 0085 	mvn.w	r0, #133	; 0x85
   179d8:	e7cd      	b.n	17976 <pm_device_action_run+0x3a>
   179da:	bf00      	nop
   179dc:	000391e8 	.word	0x000391e8
   179e0:	000391e4 	.word	0x000391e4

000179e4 <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
   179e4:	b470      	push	{r4, r5, r6}
   179e6:	b08d      	sub	sp, #52	; 0x34
   179e8:	4606      	mov	r6, r0
   179ea:	460d      	mov	r5, r1
	const unsigned int rconst[11] = {
   179ec:	f10d 0c04 	add.w	ip, sp, #4
   179f0:	4c2b      	ldr	r4, [pc, #172]	; (17aa0 <tc_aes128_set_encrypt_key+0xbc>)
   179f2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   179f4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   179f8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   179fa:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   179fe:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   17a02:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
   17a06:	2e00      	cmp	r6, #0
   17a08:	d045      	beq.n	17a96 <tc_aes128_set_encrypt_key+0xb2>
   17a0a:	4630      	mov	r0, r6
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
   17a0c:	2d00      	cmp	r5, #0
   17a0e:	d044      	beq.n	17a9a <tc_aes128_set_encrypt_key+0xb6>
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
   17a10:	2300      	movs	r3, #0
   17a12:	e00f      	b.n	17a34 <tc_aes128_set_encrypt_key+0x50>
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   17a14:	f815 4023 	ldrb.w	r4, [r5, r3, lsl #2]
   17a18:	eb05 0183 	add.w	r1, r5, r3, lsl #2
   17a1c:	784a      	ldrb	r2, [r1, #1]
   17a1e:	0412      	lsls	r2, r2, #16
   17a20:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   17a24:	788c      	ldrb	r4, [r1, #2]
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   17a26:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   17a2a:	78c9      	ldrb	r1, [r1, #3]
   17a2c:	430a      	orrs	r2, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   17a2e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	for (i = 0; i < Nk; ++i) {
   17a32:	3301      	adds	r3, #1
   17a34:	2b03      	cmp	r3, #3
   17a36:	d9ed      	bls.n	17a14 <tc_aes128_set_encrypt_key+0x30>
   17a38:	e006      	b.n	17a48 <tc_aes128_set_encrypt_key+0x64>
	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
		}
		s->words[i] = s->words[i-Nk] ^ t;
   17a3a:	1f19      	subs	r1, r3, #4
   17a3c:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
   17a40:	404a      	eors	r2, r1
   17a42:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	for (; i < (Nb * (Nr + 1)); ++i) {
   17a46:	3301      	adds	r3, #1
   17a48:	2b2b      	cmp	r3, #43	; 0x2b
   17a4a:	d820      	bhi.n	17a8e <tc_aes128_set_encrypt_key+0xaa>
		t = s->words[i-1];
   17a4c:	1e5a      	subs	r2, r3, #1
   17a4e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
		if ((i % Nk) == 0) {
   17a52:	f013 0f03 	tst.w	r3, #3
   17a56:	d1f0      	bne.n	17a3a <tc_aes128_set_encrypt_key+0x56>
	return (((a) >> 24)|((a) << 8));
   17a58:	ea4f 6232 	mov.w	r2, r2, ror #24
			t = subword(rotword(t)) ^ rconst[i/Nk];
   17a5c:	0e11      	lsrs	r1, r2, #24
   17a5e:	4c11      	ldr	r4, [pc, #68]	; (17aa4 <tc_aes128_set_encrypt_key+0xc0>)
   17a60:	5c65      	ldrb	r5, [r4, r1]
   17a62:	f3c2 4107 	ubfx	r1, r2, #16, #8
   17a66:	5c61      	ldrb	r1, [r4, r1]
   17a68:	0409      	lsls	r1, r1, #16
   17a6a:	ea41 6105 	orr.w	r1, r1, r5, lsl #24
   17a6e:	f3c2 2507 	ubfx	r5, r2, #8, #8
   17a72:	5d65      	ldrb	r5, [r4, r5]
   17a74:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
   17a78:	b2d2      	uxtb	r2, r2
   17a7a:	5ca2      	ldrb	r2, [r4, r2]
   17a7c:	4311      	orrs	r1, r2
   17a7e:	f023 0203 	bic.w	r2, r3, #3
   17a82:	ac0c      	add	r4, sp, #48	; 0x30
   17a84:	4422      	add	r2, r4
   17a86:	f852 2c2c 	ldr.w	r2, [r2, #-44]
   17a8a:	404a      	eors	r2, r1
   17a8c:	e7d5      	b.n	17a3a <tc_aes128_set_encrypt_key+0x56>
	}

	return TC_CRYPTO_SUCCESS;
   17a8e:	2001      	movs	r0, #1
}
   17a90:	b00d      	add	sp, #52	; 0x34
   17a92:	bc70      	pop	{r4, r5, r6}
   17a94:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   17a96:	2000      	movs	r0, #0
   17a98:	e7fa      	b.n	17a90 <tc_aes128_set_encrypt_key+0xac>
		return TC_CRYPTO_FAIL;
   17a9a:	2000      	movs	r0, #0
   17a9c:	e7f8      	b.n	17a90 <tc_aes128_set_encrypt_key+0xac>
   17a9e:	bf00      	nop
   17aa0:	000313fc 	.word	0x000313fc
   17aa4:	000391ec 	.word	0x000391ec

00017aa8 <tc_aes_encrypt>:
int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
   17aa8:	2800      	cmp	r0, #0
   17aaa:	f000 8366 	beq.w	1817a <tc_aes_encrypt+0x6d2>
{
   17aae:	b5f0      	push	{r4, r5, r6, r7, lr}
   17ab0:	b089      	sub	sp, #36	; 0x24
   17ab2:	4615      	mov	r5, r2
   17ab4:	4606      	mov	r6, r0
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
   17ab6:	2900      	cmp	r1, #0
   17ab8:	f000 8361 	beq.w	1817e <tc_aes_encrypt+0x6d6>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
   17abc:	2a00      	cmp	r2, #0
   17abe:	f000 8360 	beq.w	18182 <tc_aes_encrypt+0x6da>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
   17ac2:	2310      	movs	r3, #16
   17ac4:	460a      	mov	r2, r1
   17ac6:	4619      	mov	r1, r3
   17ac8:	eb0d 0003 	add.w	r0, sp, r3
   17acc:	f014 fd7b 	bl	2c5c6 <_copy>
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   17ad0:	682b      	ldr	r3, [r5, #0]
   17ad2:	f89d 2010 	ldrb.w	r2, [sp, #16]
   17ad6:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
   17ada:	f88d 2010 	strb.w	r2, [sp, #16]
   17ade:	f3c3 4207 	ubfx	r2, r3, #16, #8
   17ae2:	f89d 1011 	ldrb.w	r1, [sp, #17]
   17ae6:	404a      	eors	r2, r1
   17ae8:	f88d 2011 	strb.w	r2, [sp, #17]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   17aec:	f3c3 2207 	ubfx	r2, r3, #8, #8
   17af0:	f89d 1012 	ldrb.w	r1, [sp, #18]
   17af4:	404a      	eors	r2, r1
   17af6:	f88d 2012 	strb.w	r2, [sp, #18]
   17afa:	b2db      	uxtb	r3, r3
   17afc:	f89d 2013 	ldrb.w	r2, [sp, #19]
   17b00:	4053      	eors	r3, r2
   17b02:	f88d 3013 	strb.w	r3, [sp, #19]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   17b06:	686b      	ldr	r3, [r5, #4]
   17b08:	f89d 2014 	ldrb.w	r2, [sp, #20]
   17b0c:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
   17b10:	f88d 2014 	strb.w	r2, [sp, #20]
   17b14:	f3c3 4207 	ubfx	r2, r3, #16, #8
   17b18:	f89d 1015 	ldrb.w	r1, [sp, #21]
   17b1c:	404a      	eors	r2, r1
   17b1e:	f88d 2015 	strb.w	r2, [sp, #21]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   17b22:	f3c3 2207 	ubfx	r2, r3, #8, #8
   17b26:	f89d 1016 	ldrb.w	r1, [sp, #22]
   17b2a:	404a      	eors	r2, r1
   17b2c:	f88d 2016 	strb.w	r2, [sp, #22]
   17b30:	b2db      	uxtb	r3, r3
   17b32:	f89d 2017 	ldrb.w	r2, [sp, #23]
   17b36:	4053      	eors	r3, r2
   17b38:	f88d 3017 	strb.w	r3, [sp, #23]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   17b3c:	68ab      	ldr	r3, [r5, #8]
   17b3e:	f89d 2018 	ldrb.w	r2, [sp, #24]
   17b42:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
   17b46:	f88d 2018 	strb.w	r2, [sp, #24]
   17b4a:	f3c3 4207 	ubfx	r2, r3, #16, #8
   17b4e:	f89d 1019 	ldrb.w	r1, [sp, #25]
   17b52:	404a      	eors	r2, r1
   17b54:	f88d 2019 	strb.w	r2, [sp, #25]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   17b58:	f3c3 2207 	ubfx	r2, r3, #8, #8
   17b5c:	f89d 101a 	ldrb.w	r1, [sp, #26]
   17b60:	404a      	eors	r2, r1
   17b62:	f88d 201a 	strb.w	r2, [sp, #26]
   17b66:	b2db      	uxtb	r3, r3
   17b68:	f89d 201b 	ldrb.w	r2, [sp, #27]
   17b6c:	4053      	eors	r3, r2
   17b6e:	f88d 301b 	strb.w	r3, [sp, #27]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   17b72:	68eb      	ldr	r3, [r5, #12]
   17b74:	f89d 201c 	ldrb.w	r2, [sp, #28]
   17b78:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
   17b7c:	f88d 201c 	strb.w	r2, [sp, #28]
   17b80:	f3c3 4207 	ubfx	r2, r3, #16, #8
   17b84:	f89d 101d 	ldrb.w	r1, [sp, #29]
   17b88:	404a      	eors	r2, r1
   17b8a:	f88d 201d 	strb.w	r2, [sp, #29]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   17b8e:	f3c3 2207 	ubfx	r2, r3, #8, #8
   17b92:	f89d 101e 	ldrb.w	r1, [sp, #30]
   17b96:	404a      	eors	r2, r1
   17b98:	f88d 201e 	strb.w	r2, [sp, #30]
   17b9c:	b2db      	uxtb	r3, r3
   17b9e:	f89d 201f 	ldrb.w	r2, [sp, #31]
   17ba2:	4053      	eors	r3, r2
   17ba4:	f88d 301f 	strb.w	r3, [sp, #31]
	add_round_key(state, s->words);

	for (i = 0; i < (Nr - 1); ++i) {
   17ba8:	2400      	movs	r4, #0
}
   17baa:	e211      	b.n	17fd0 <tc_aes_encrypt+0x528>
		s[i] = sbox[s[i]];
   17bac:	a904      	add	r1, sp, #16
   17bae:	5cc8      	ldrb	r0, [r1, r3]
   17bb0:	4a02      	ldr	r2, [pc, #8]	; (17bbc <tc_aes_encrypt+0x114>)
   17bb2:	5c10      	ldrb	r0, [r2, r0]
   17bb4:	54c8      	strb	r0, [r1, r3]
	for (i = 0; i < (Nb * Nk); ++i) {
   17bb6:	3301      	adds	r3, #1
   17bb8:	e002      	b.n	17bc0 <tc_aes_encrypt+0x118>
   17bba:	bf00      	nop
   17bbc:	000391ec 	.word	0x000391ec
   17bc0:	2b0f      	cmp	r3, #15
   17bc2:	d9f3      	bls.n	17bac <tc_aes_encrypt+0x104>
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   17bc4:	f89d 3010 	ldrb.w	r3, [sp, #16]
   17bc8:	f88d 3000 	strb.w	r3, [sp]
   17bcc:	f89d 3015 	ldrb.w	r3, [sp, #21]
   17bd0:	f88d 3001 	strb.w	r3, [sp, #1]
   17bd4:	f89d 301a 	ldrb.w	r3, [sp, #26]
   17bd8:	f88d 3002 	strb.w	r3, [sp, #2]
   17bdc:	f89d 301f 	ldrb.w	r3, [sp, #31]
   17be0:	f88d 3003 	strb.w	r3, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   17be4:	f89d 3014 	ldrb.w	r3, [sp, #20]
   17be8:	f88d 3004 	strb.w	r3, [sp, #4]
   17bec:	f89d 3019 	ldrb.w	r3, [sp, #25]
   17bf0:	f88d 3005 	strb.w	r3, [sp, #5]
   17bf4:	f89d 301e 	ldrb.w	r3, [sp, #30]
   17bf8:	f88d 3006 	strb.w	r3, [sp, #6]
   17bfc:	f89d 3013 	ldrb.w	r3, [sp, #19]
   17c00:	f88d 3007 	strb.w	r3, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   17c04:	f89d 3018 	ldrb.w	r3, [sp, #24]
   17c08:	f88d 3008 	strb.w	r3, [sp, #8]
   17c0c:	f89d 301d 	ldrb.w	r3, [sp, #29]
   17c10:	f88d 3009 	strb.w	r3, [sp, #9]
   17c14:	f89d 3012 	ldrb.w	r3, [sp, #18]
   17c18:	f88d 300a 	strb.w	r3, [sp, #10]
   17c1c:	f89d 3017 	ldrb.w	r3, [sp, #23]
   17c20:	f88d 300b 	strb.w	r3, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   17c24:	f89d 301c 	ldrb.w	r3, [sp, #28]
   17c28:	f88d 300c 	strb.w	r3, [sp, #12]
   17c2c:	f89d 3011 	ldrb.w	r3, [sp, #17]
   17c30:	f88d 300d 	strb.w	r3, [sp, #13]
   17c34:	f89d 3016 	ldrb.w	r3, [sp, #22]
   17c38:	f88d 300e 	strb.w	r3, [sp, #14]
   17c3c:	f89d 301b 	ldrb.w	r3, [sp, #27]
   17c40:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   17c44:	2310      	movs	r3, #16
   17c46:	466a      	mov	r2, sp
   17c48:	4619      	mov	r1, r3
   17c4a:	eb0d 0003 	add.w	r0, sp, r3
   17c4e:	f014 fcba 	bl	2c5c6 <_copy>
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   17c52:	f89d 0010 	ldrb.w	r0, [sp, #16]
   17c56:	f014 fcc7 	bl	2c5e8 <_double_byte>
   17c5a:	4607      	mov	r7, r0
   17c5c:	f89d 0011 	ldrb.w	r0, [sp, #17]
   17c60:	f014 fcc2 	bl	2c5e8 <_double_byte>
   17c64:	4601      	mov	r1, r0
   17c66:	f89d 0011 	ldrb.w	r0, [sp, #17]
   17c6a:	f89d 2012 	ldrb.w	r2, [sp, #18]
   17c6e:	f89d 3013 	ldrb.w	r3, [sp, #19]
   17c72:	4041      	eors	r1, r0
   17c74:	404f      	eors	r7, r1
   17c76:	407a      	eors	r2, r7
   17c78:	4053      	eors	r3, r2
   17c7a:	f88d 3000 	strb.w	r3, [sp]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   17c7e:	f89d 7010 	ldrb.w	r7, [sp, #16]
   17c82:	f014 fcb1 	bl	2c5e8 <_double_byte>
   17c86:	4047      	eors	r7, r0
   17c88:	b2ff      	uxtb	r7, r7
   17c8a:	f89d 0012 	ldrb.w	r0, [sp, #18]
   17c8e:	f014 fcab 	bl	2c5e8 <_double_byte>
   17c92:	4602      	mov	r2, r0
   17c94:	f89d 0012 	ldrb.w	r0, [sp, #18]
   17c98:	f89d 3013 	ldrb.w	r3, [sp, #19]
   17c9c:	4042      	eors	r2, r0
   17c9e:	4057      	eors	r7, r2
   17ca0:	405f      	eors	r7, r3
   17ca2:	f88d 7001 	strb.w	r7, [sp, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   17ca6:	f89d 7010 	ldrb.w	r7, [sp, #16]
   17caa:	f89d 3011 	ldrb.w	r3, [sp, #17]
   17cae:	405f      	eors	r7, r3
   17cb0:	f014 fc9a 	bl	2c5e8 <_double_byte>
   17cb4:	4047      	eors	r7, r0
   17cb6:	b2ff      	uxtb	r7, r7
   17cb8:	f89d 0013 	ldrb.w	r0, [sp, #19]
   17cbc:	f014 fc94 	bl	2c5e8 <_double_byte>
   17cc0:	f89d 3013 	ldrb.w	r3, [sp, #19]
   17cc4:	4058      	eors	r0, r3
   17cc6:	4047      	eors	r7, r0
   17cc8:	f88d 7002 	strb.w	r7, [sp, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   17ccc:	f89d 0010 	ldrb.w	r0, [sp, #16]
   17cd0:	f014 fc8a 	bl	2c5e8 <_double_byte>
   17cd4:	f89d 2010 	ldrb.w	r2, [sp, #16]
   17cd8:	f89d 3011 	ldrb.w	r3, [sp, #17]
   17cdc:	f89d 7012 	ldrb.w	r7, [sp, #18]
   17ce0:	4050      	eors	r0, r2
   17ce2:	4043      	eors	r3, r0
   17ce4:	405f      	eors	r7, r3
   17ce6:	b2ff      	uxtb	r7, r7
   17ce8:	f89d 0013 	ldrb.w	r0, [sp, #19]
   17cec:	f014 fc7c 	bl	2c5e8 <_double_byte>
   17cf0:	4047      	eors	r7, r0
   17cf2:	f88d 7003 	strb.w	r7, [sp, #3]
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   17cf6:	f89d 0014 	ldrb.w	r0, [sp, #20]
   17cfa:	f014 fc75 	bl	2c5e8 <_double_byte>
   17cfe:	4607      	mov	r7, r0
   17d00:	f89d 0015 	ldrb.w	r0, [sp, #21]
   17d04:	f014 fc70 	bl	2c5e8 <_double_byte>
   17d08:	4601      	mov	r1, r0
   17d0a:	f89d 0015 	ldrb.w	r0, [sp, #21]
   17d0e:	f89d 2016 	ldrb.w	r2, [sp, #22]
   17d12:	f89d 3017 	ldrb.w	r3, [sp, #23]
   17d16:	4041      	eors	r1, r0
   17d18:	404f      	eors	r7, r1
   17d1a:	407a      	eors	r2, r7
   17d1c:	4053      	eors	r3, r2
   17d1e:	f88d 3004 	strb.w	r3, [sp, #4]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   17d22:	f89d 7014 	ldrb.w	r7, [sp, #20]
   17d26:	f014 fc5f 	bl	2c5e8 <_double_byte>
   17d2a:	4047      	eors	r7, r0
   17d2c:	b2ff      	uxtb	r7, r7
   17d2e:	f89d 0016 	ldrb.w	r0, [sp, #22]
   17d32:	f014 fc59 	bl	2c5e8 <_double_byte>
   17d36:	4602      	mov	r2, r0
   17d38:	f89d 0016 	ldrb.w	r0, [sp, #22]
   17d3c:	f89d 3017 	ldrb.w	r3, [sp, #23]
   17d40:	4042      	eors	r2, r0
   17d42:	4057      	eors	r7, r2
   17d44:	405f      	eors	r7, r3
   17d46:	f88d 7005 	strb.w	r7, [sp, #5]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   17d4a:	f89d 7014 	ldrb.w	r7, [sp, #20]
   17d4e:	f89d 3015 	ldrb.w	r3, [sp, #21]
   17d52:	405f      	eors	r7, r3
   17d54:	f014 fc48 	bl	2c5e8 <_double_byte>
   17d58:	4047      	eors	r7, r0
   17d5a:	b2ff      	uxtb	r7, r7
   17d5c:	f89d 0017 	ldrb.w	r0, [sp, #23]
   17d60:	f014 fc42 	bl	2c5e8 <_double_byte>
   17d64:	f89d 3017 	ldrb.w	r3, [sp, #23]
   17d68:	4058      	eors	r0, r3
   17d6a:	4047      	eors	r7, r0
   17d6c:	f88d 7006 	strb.w	r7, [sp, #6]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   17d70:	f89d 0014 	ldrb.w	r0, [sp, #20]
   17d74:	f014 fc38 	bl	2c5e8 <_double_byte>
   17d78:	f89d 2014 	ldrb.w	r2, [sp, #20]
   17d7c:	f89d 3015 	ldrb.w	r3, [sp, #21]
   17d80:	f89d 7016 	ldrb.w	r7, [sp, #22]
   17d84:	4050      	eors	r0, r2
   17d86:	4043      	eors	r3, r0
   17d88:	405f      	eors	r7, r3
   17d8a:	b2ff      	uxtb	r7, r7
   17d8c:	f89d 0017 	ldrb.w	r0, [sp, #23]
   17d90:	f014 fc2a 	bl	2c5e8 <_double_byte>
   17d94:	4047      	eors	r7, r0
   17d96:	f88d 7007 	strb.w	r7, [sp, #7]
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   17d9a:	f89d 0018 	ldrb.w	r0, [sp, #24]
   17d9e:	f014 fc23 	bl	2c5e8 <_double_byte>
   17da2:	4607      	mov	r7, r0
   17da4:	f89d 0019 	ldrb.w	r0, [sp, #25]
   17da8:	f014 fc1e 	bl	2c5e8 <_double_byte>
   17dac:	4601      	mov	r1, r0
   17dae:	f89d 0019 	ldrb.w	r0, [sp, #25]
   17db2:	f89d 201a 	ldrb.w	r2, [sp, #26]
   17db6:	f89d 301b 	ldrb.w	r3, [sp, #27]
   17dba:	4041      	eors	r1, r0
   17dbc:	404f      	eors	r7, r1
   17dbe:	407a      	eors	r2, r7
   17dc0:	4053      	eors	r3, r2
   17dc2:	f88d 3008 	strb.w	r3, [sp, #8]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   17dc6:	f89d 7018 	ldrb.w	r7, [sp, #24]
   17dca:	f014 fc0d 	bl	2c5e8 <_double_byte>
   17dce:	4047      	eors	r7, r0
   17dd0:	b2ff      	uxtb	r7, r7
   17dd2:	f89d 001a 	ldrb.w	r0, [sp, #26]
   17dd6:	f014 fc07 	bl	2c5e8 <_double_byte>
   17dda:	4602      	mov	r2, r0
   17ddc:	f89d 001a 	ldrb.w	r0, [sp, #26]
   17de0:	f89d 301b 	ldrb.w	r3, [sp, #27]
   17de4:	4042      	eors	r2, r0
   17de6:	4057      	eors	r7, r2
   17de8:	405f      	eors	r7, r3
   17dea:	f88d 7009 	strb.w	r7, [sp, #9]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   17dee:	f89d 7018 	ldrb.w	r7, [sp, #24]
   17df2:	f89d 3019 	ldrb.w	r3, [sp, #25]
   17df6:	405f      	eors	r7, r3
   17df8:	f014 fbf6 	bl	2c5e8 <_double_byte>
   17dfc:	4047      	eors	r7, r0
   17dfe:	b2ff      	uxtb	r7, r7
   17e00:	f89d 001b 	ldrb.w	r0, [sp, #27]
   17e04:	f014 fbf0 	bl	2c5e8 <_double_byte>
   17e08:	f89d 301b 	ldrb.w	r3, [sp, #27]
   17e0c:	4058      	eors	r0, r3
   17e0e:	4047      	eors	r7, r0
   17e10:	f88d 700a 	strb.w	r7, [sp, #10]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   17e14:	f89d 0018 	ldrb.w	r0, [sp, #24]
   17e18:	f014 fbe6 	bl	2c5e8 <_double_byte>
   17e1c:	f89d 2018 	ldrb.w	r2, [sp, #24]
   17e20:	f89d 3019 	ldrb.w	r3, [sp, #25]
   17e24:	f89d 701a 	ldrb.w	r7, [sp, #26]
   17e28:	4050      	eors	r0, r2
   17e2a:	4043      	eors	r3, r0
   17e2c:	405f      	eors	r7, r3
   17e2e:	b2ff      	uxtb	r7, r7
   17e30:	f89d 001b 	ldrb.w	r0, [sp, #27]
   17e34:	f014 fbd8 	bl	2c5e8 <_double_byte>
   17e38:	4047      	eors	r7, r0
   17e3a:	f88d 700b 	strb.w	r7, [sp, #11]
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   17e3e:	f89d 001c 	ldrb.w	r0, [sp, #28]
   17e42:	f014 fbd1 	bl	2c5e8 <_double_byte>
   17e46:	4607      	mov	r7, r0
   17e48:	f89d 001d 	ldrb.w	r0, [sp, #29]
   17e4c:	f014 fbcc 	bl	2c5e8 <_double_byte>
   17e50:	4601      	mov	r1, r0
   17e52:	f89d 001d 	ldrb.w	r0, [sp, #29]
   17e56:	f89d 201e 	ldrb.w	r2, [sp, #30]
   17e5a:	f89d 301f 	ldrb.w	r3, [sp, #31]
   17e5e:	4041      	eors	r1, r0
   17e60:	404f      	eors	r7, r1
   17e62:	407a      	eors	r2, r7
   17e64:	4053      	eors	r3, r2
   17e66:	f88d 300c 	strb.w	r3, [sp, #12]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   17e6a:	f89d 701c 	ldrb.w	r7, [sp, #28]
   17e6e:	f014 fbbb 	bl	2c5e8 <_double_byte>
   17e72:	4047      	eors	r7, r0
   17e74:	b2ff      	uxtb	r7, r7
   17e76:	f89d 001e 	ldrb.w	r0, [sp, #30]
   17e7a:	f014 fbb5 	bl	2c5e8 <_double_byte>
   17e7e:	4602      	mov	r2, r0
   17e80:	f89d 001e 	ldrb.w	r0, [sp, #30]
   17e84:	f89d 301f 	ldrb.w	r3, [sp, #31]
   17e88:	4042      	eors	r2, r0
   17e8a:	4057      	eors	r7, r2
   17e8c:	405f      	eors	r7, r3
   17e8e:	f88d 700d 	strb.w	r7, [sp, #13]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   17e92:	f89d 701c 	ldrb.w	r7, [sp, #28]
   17e96:	f89d 301d 	ldrb.w	r3, [sp, #29]
   17e9a:	405f      	eors	r7, r3
   17e9c:	f014 fba4 	bl	2c5e8 <_double_byte>
   17ea0:	4047      	eors	r7, r0
   17ea2:	b2ff      	uxtb	r7, r7
   17ea4:	f89d 001f 	ldrb.w	r0, [sp, #31]
   17ea8:	f014 fb9e 	bl	2c5e8 <_double_byte>
   17eac:	f89d 301f 	ldrb.w	r3, [sp, #31]
   17eb0:	4058      	eors	r0, r3
   17eb2:	4047      	eors	r7, r0
   17eb4:	f88d 700e 	strb.w	r7, [sp, #14]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   17eb8:	f89d 001c 	ldrb.w	r0, [sp, #28]
   17ebc:	f014 fb94 	bl	2c5e8 <_double_byte>
   17ec0:	f89d 201c 	ldrb.w	r2, [sp, #28]
   17ec4:	f89d 301d 	ldrb.w	r3, [sp, #29]
   17ec8:	f89d 701e 	ldrb.w	r7, [sp, #30]
   17ecc:	4050      	eors	r0, r2
   17ece:	4043      	eors	r3, r0
   17ed0:	405f      	eors	r7, r3
   17ed2:	b2ff      	uxtb	r7, r7
   17ed4:	f89d 001f 	ldrb.w	r0, [sp, #31]
   17ed8:	f014 fb86 	bl	2c5e8 <_double_byte>
   17edc:	4047      	eors	r7, r0
   17ede:	f88d 700f 	strb.w	r7, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   17ee2:	2310      	movs	r3, #16
   17ee4:	466a      	mov	r2, sp
   17ee6:	4619      	mov	r1, r3
   17ee8:	eb0d 0003 	add.w	r0, sp, r3
   17eec:	f014 fb6b 	bl	2c5c6 <_copy>
		sub_bytes(state);
		shift_rows(state);
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
   17ef0:	3401      	adds	r4, #1
   17ef2:	0123      	lsls	r3, r4, #4
   17ef4:	eb05 1204 	add.w	r2, r5, r4, lsl #4
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   17ef8:	58eb      	ldr	r3, [r5, r3]
   17efa:	f89d 1010 	ldrb.w	r1, [sp, #16]
   17efe:	ea81 6113 	eor.w	r1, r1, r3, lsr #24
   17f02:	f88d 1010 	strb.w	r1, [sp, #16]
   17f06:	f3c3 4107 	ubfx	r1, r3, #16, #8
   17f0a:	f89d 0011 	ldrb.w	r0, [sp, #17]
   17f0e:	4041      	eors	r1, r0
   17f10:	f88d 1011 	strb.w	r1, [sp, #17]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   17f14:	f3c3 2107 	ubfx	r1, r3, #8, #8
   17f18:	f89d 0012 	ldrb.w	r0, [sp, #18]
   17f1c:	4041      	eors	r1, r0
   17f1e:	f88d 1012 	strb.w	r1, [sp, #18]
   17f22:	b2db      	uxtb	r3, r3
   17f24:	f89d 1013 	ldrb.w	r1, [sp, #19]
   17f28:	404b      	eors	r3, r1
   17f2a:	f88d 3013 	strb.w	r3, [sp, #19]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   17f2e:	6853      	ldr	r3, [r2, #4]
   17f30:	f89d 1014 	ldrb.w	r1, [sp, #20]
   17f34:	ea81 6113 	eor.w	r1, r1, r3, lsr #24
   17f38:	f88d 1014 	strb.w	r1, [sp, #20]
   17f3c:	f3c3 4107 	ubfx	r1, r3, #16, #8
   17f40:	f89d 0015 	ldrb.w	r0, [sp, #21]
   17f44:	4041      	eors	r1, r0
   17f46:	f88d 1015 	strb.w	r1, [sp, #21]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   17f4a:	f3c3 2107 	ubfx	r1, r3, #8, #8
   17f4e:	f89d 0016 	ldrb.w	r0, [sp, #22]
   17f52:	4041      	eors	r1, r0
   17f54:	f88d 1016 	strb.w	r1, [sp, #22]
   17f58:	b2db      	uxtb	r3, r3
   17f5a:	f89d 1017 	ldrb.w	r1, [sp, #23]
   17f5e:	404b      	eors	r3, r1
   17f60:	f88d 3017 	strb.w	r3, [sp, #23]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   17f64:	6893      	ldr	r3, [r2, #8]
   17f66:	f89d 1018 	ldrb.w	r1, [sp, #24]
   17f6a:	ea81 6113 	eor.w	r1, r1, r3, lsr #24
   17f6e:	f88d 1018 	strb.w	r1, [sp, #24]
   17f72:	f3c3 4107 	ubfx	r1, r3, #16, #8
   17f76:	f89d 0019 	ldrb.w	r0, [sp, #25]
   17f7a:	4041      	eors	r1, r0
   17f7c:	f88d 1019 	strb.w	r1, [sp, #25]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   17f80:	f3c3 2107 	ubfx	r1, r3, #8, #8
   17f84:	f89d 001a 	ldrb.w	r0, [sp, #26]
   17f88:	4041      	eors	r1, r0
   17f8a:	f88d 101a 	strb.w	r1, [sp, #26]
   17f8e:	b2db      	uxtb	r3, r3
   17f90:	f89d 101b 	ldrb.w	r1, [sp, #27]
   17f94:	404b      	eors	r3, r1
   17f96:	f88d 301b 	strb.w	r3, [sp, #27]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   17f9a:	68d3      	ldr	r3, [r2, #12]
   17f9c:	f89d 201c 	ldrb.w	r2, [sp, #28]
   17fa0:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
   17fa4:	f88d 201c 	strb.w	r2, [sp, #28]
   17fa8:	f3c3 4207 	ubfx	r2, r3, #16, #8
   17fac:	f89d 101d 	ldrb.w	r1, [sp, #29]
   17fb0:	404a      	eors	r2, r1
   17fb2:	f88d 201d 	strb.w	r2, [sp, #29]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   17fb6:	f3c3 2207 	ubfx	r2, r3, #8, #8
   17fba:	f89d 101e 	ldrb.w	r1, [sp, #30]
   17fbe:	404a      	eors	r2, r1
   17fc0:	f88d 201e 	strb.w	r2, [sp, #30]
   17fc4:	b2db      	uxtb	r3, r3
   17fc6:	f89d 201f 	ldrb.w	r2, [sp, #31]
   17fca:	4053      	eors	r3, r2
   17fcc:	f88d 301f 	strb.w	r3, [sp, #31]
	for (i = 0; i < (Nr - 1); ++i) {
   17fd0:	2c08      	cmp	r4, #8
   17fd2:	d801      	bhi.n	17fd8 <tc_aes_encrypt+0x530>
	for (i = 0; i < (Nb * Nk); ++i) {
   17fd4:	2300      	movs	r3, #0
   17fd6:	e5f3      	b.n	17bc0 <tc_aes_encrypt+0x118>
   17fd8:	2300      	movs	r3, #0
   17fda:	e005      	b.n	17fe8 <tc_aes_encrypt+0x540>
		s[i] = sbox[s[i]];
   17fdc:	aa04      	add	r2, sp, #16
   17fde:	5cd1      	ldrb	r1, [r2, r3]
   17fe0:	4869      	ldr	r0, [pc, #420]	; (18188 <tc_aes_encrypt+0x6e0>)
   17fe2:	5c41      	ldrb	r1, [r0, r1]
   17fe4:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < (Nb * Nk); ++i) {
   17fe6:	3301      	adds	r3, #1
   17fe8:	2b0f      	cmp	r3, #15
   17fea:	d9f7      	bls.n	17fdc <tc_aes_encrypt+0x534>
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   17fec:	f89d 3010 	ldrb.w	r3, [sp, #16]
   17ff0:	f88d 3000 	strb.w	r3, [sp]
   17ff4:	f89d 3015 	ldrb.w	r3, [sp, #21]
   17ff8:	f88d 3001 	strb.w	r3, [sp, #1]
   17ffc:	f89d 301a 	ldrb.w	r3, [sp, #26]
   18000:	f88d 3002 	strb.w	r3, [sp, #2]
   18004:	f89d 301f 	ldrb.w	r3, [sp, #31]
   18008:	f88d 3003 	strb.w	r3, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   1800c:	f89d 3014 	ldrb.w	r3, [sp, #20]
   18010:	f88d 3004 	strb.w	r3, [sp, #4]
   18014:	f89d 3019 	ldrb.w	r3, [sp, #25]
   18018:	f88d 3005 	strb.w	r3, [sp, #5]
   1801c:	f89d 301e 	ldrb.w	r3, [sp, #30]
   18020:	f88d 3006 	strb.w	r3, [sp, #6]
   18024:	f89d 3013 	ldrb.w	r3, [sp, #19]
   18028:	f88d 3007 	strb.w	r3, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   1802c:	f89d 3018 	ldrb.w	r3, [sp, #24]
   18030:	f88d 3008 	strb.w	r3, [sp, #8]
   18034:	f89d 301d 	ldrb.w	r3, [sp, #29]
   18038:	f88d 3009 	strb.w	r3, [sp, #9]
   1803c:	f89d 3012 	ldrb.w	r3, [sp, #18]
   18040:	f88d 300a 	strb.w	r3, [sp, #10]
   18044:	f89d 3017 	ldrb.w	r3, [sp, #23]
   18048:	f88d 300b 	strb.w	r3, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   1804c:	f89d 301c 	ldrb.w	r3, [sp, #28]
   18050:	f88d 300c 	strb.w	r3, [sp, #12]
   18054:	f89d 3011 	ldrb.w	r3, [sp, #17]
   18058:	f88d 300d 	strb.w	r3, [sp, #13]
   1805c:	f89d 3016 	ldrb.w	r3, [sp, #22]
   18060:	f88d 300e 	strb.w	r3, [sp, #14]
   18064:	f89d 301b 	ldrb.w	r3, [sp, #27]
   18068:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   1806c:	2310      	movs	r3, #16
   1806e:	466a      	mov	r2, sp
   18070:	4619      	mov	r1, r3
   18072:	eb0d 0003 	add.w	r0, sp, r3
   18076:	f014 faa6 	bl	2c5c6 <_copy>
	}

	sub_bytes(state);
	shift_rows(state);
	add_round_key(state, s->words + Nb*(i+1));
   1807a:	1c63      	adds	r3, r4, #1
   1807c:	011a      	lsls	r2, r3, #4
   1807e:	eb05 1303 	add.w	r3, r5, r3, lsl #4
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   18082:	58aa      	ldr	r2, [r5, r2]
   18084:	f89d 1010 	ldrb.w	r1, [sp, #16]
   18088:	ea81 6112 	eor.w	r1, r1, r2, lsr #24
   1808c:	f88d 1010 	strb.w	r1, [sp, #16]
   18090:	f3c2 4107 	ubfx	r1, r2, #16, #8
   18094:	f89d 0011 	ldrb.w	r0, [sp, #17]
   18098:	4041      	eors	r1, r0
   1809a:	f88d 1011 	strb.w	r1, [sp, #17]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   1809e:	f3c2 2107 	ubfx	r1, r2, #8, #8
   180a2:	f89d 0012 	ldrb.w	r0, [sp, #18]
   180a6:	4041      	eors	r1, r0
   180a8:	f88d 1012 	strb.w	r1, [sp, #18]
   180ac:	b2d2      	uxtb	r2, r2
   180ae:	f89d 1013 	ldrb.w	r1, [sp, #19]
   180b2:	404a      	eors	r2, r1
   180b4:	f88d 2013 	strb.w	r2, [sp, #19]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   180b8:	685a      	ldr	r2, [r3, #4]
   180ba:	f89d 1014 	ldrb.w	r1, [sp, #20]
   180be:	ea81 6112 	eor.w	r1, r1, r2, lsr #24
   180c2:	f88d 1014 	strb.w	r1, [sp, #20]
   180c6:	f3c2 4107 	ubfx	r1, r2, #16, #8
   180ca:	f89d 0015 	ldrb.w	r0, [sp, #21]
   180ce:	4041      	eors	r1, r0
   180d0:	f88d 1015 	strb.w	r1, [sp, #21]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   180d4:	f3c2 2107 	ubfx	r1, r2, #8, #8
   180d8:	f89d 0016 	ldrb.w	r0, [sp, #22]
   180dc:	4041      	eors	r1, r0
   180de:	f88d 1016 	strb.w	r1, [sp, #22]
   180e2:	b2d2      	uxtb	r2, r2
   180e4:	f89d 1017 	ldrb.w	r1, [sp, #23]
   180e8:	404a      	eors	r2, r1
   180ea:	f88d 2017 	strb.w	r2, [sp, #23]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   180ee:	689a      	ldr	r2, [r3, #8]
   180f0:	f89d 1018 	ldrb.w	r1, [sp, #24]
   180f4:	ea81 6112 	eor.w	r1, r1, r2, lsr #24
   180f8:	f88d 1018 	strb.w	r1, [sp, #24]
   180fc:	f3c2 4107 	ubfx	r1, r2, #16, #8
   18100:	f89d 0019 	ldrb.w	r0, [sp, #25]
   18104:	4041      	eors	r1, r0
   18106:	f88d 1019 	strb.w	r1, [sp, #25]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   1810a:	f3c2 2107 	ubfx	r1, r2, #8, #8
   1810e:	f89d 001a 	ldrb.w	r0, [sp, #26]
   18112:	4041      	eors	r1, r0
   18114:	f88d 101a 	strb.w	r1, [sp, #26]
   18118:	b2d2      	uxtb	r2, r2
   1811a:	f89d 101b 	ldrb.w	r1, [sp, #27]
   1811e:	404a      	eors	r2, r1
   18120:	f88d 201b 	strb.w	r2, [sp, #27]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   18124:	68db      	ldr	r3, [r3, #12]
   18126:	f89d 201c 	ldrb.w	r2, [sp, #28]
   1812a:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
   1812e:	f88d 201c 	strb.w	r2, [sp, #28]
   18132:	f3c3 4207 	ubfx	r2, r3, #16, #8
   18136:	f89d 101d 	ldrb.w	r1, [sp, #29]
   1813a:	404a      	eors	r2, r1
   1813c:	f88d 201d 	strb.w	r2, [sp, #29]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   18140:	f3c3 2207 	ubfx	r2, r3, #8, #8
   18144:	f89d 101e 	ldrb.w	r1, [sp, #30]
   18148:	404a      	eors	r2, r1
   1814a:	f88d 201e 	strb.w	r2, [sp, #30]
   1814e:	b2db      	uxtb	r3, r3
   18150:	f89d 201f 	ldrb.w	r2, [sp, #31]
   18154:	4053      	eors	r3, r2
   18156:	f88d 301f 	strb.w	r3, [sp, #31]

	(void)_copy(out, sizeof(state), state, sizeof(state));
   1815a:	2310      	movs	r3, #16
   1815c:	eb0d 0203 	add.w	r2, sp, r3
   18160:	4619      	mov	r1, r3
   18162:	4630      	mov	r0, r6
   18164:	f014 fa2f 	bl	2c5c6 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
   18168:	2210      	movs	r2, #16
   1816a:	2100      	movs	r1, #0
   1816c:	eb0d 0002 	add.w	r0, sp, r2
   18170:	f014 fa36 	bl	2c5e0 <_set>

	return TC_CRYPTO_SUCCESS;
   18174:	2001      	movs	r0, #1
}
   18176:	b009      	add	sp, #36	; 0x24
   18178:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   1817a:	2000      	movs	r0, #0
}
   1817c:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   1817e:	2000      	movs	r0, #0
   18180:	e7f9      	b.n	18176 <tc_aes_encrypt+0x6ce>
		return TC_CRYPTO_FAIL;
   18182:	2000      	movs	r0, #0
   18184:	e7f7      	b.n	18176 <tc_aes_encrypt+0x6ce>
   18186:	bf00      	nop
   18188:	000391ec 	.word	0x000391ec

0001818c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   1818c:	4901      	ldr	r1, [pc, #4]	; (18194 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   1818e:	2210      	movs	r2, #16
	str	r2, [r1]
   18190:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   18192:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   18194:	e000ed10 	.word	0xe000ed10

00018198 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   18198:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   1819a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   1819c:	f380 8811 	msr	BASEPRI, r0
	isb
   181a0:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   181a4:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   181a8:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
pp	 */cpsie	i
   181aa:	b662      	cpsie	i
	isb
   181ac:	f3bf 8f6f 	isb	sy

	bx	lr
   181b0:	4770      	bx	lr
   181b2:	bf00      	nop

000181b4 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   181b4:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   181b6:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   181b8:	f381 8811 	msr	BASEPRI, r1

	wfe
   181bc:	bf20      	wfe

	msr	BASEPRI, r0
   181be:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   181c2:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   181c4:	4770      	bx	lr
   181c6:	bf00      	nop

000181c8 <esf_dump>:
#include <kernel_arch_data.h>
#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

static void esf_dump(const z_arch_esf_t *esf)
{
   181c8:	b530      	push	{r4, r5, lr}
   181ca:	b087      	sub	sp, #28
   181cc:	4605      	mov	r5, r0
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   181ce:	6883      	ldr	r3, [r0, #8]
   181d0:	9300      	str	r3, [sp, #0]
   181d2:	6843      	ldr	r3, [r0, #4]
   181d4:	6802      	ldr	r2, [r0, #0]
   181d6:	2145      	movs	r1, #69	; 0x45
   181d8:	4829      	ldr	r0, [pc, #164]	; (18280 <esf_dump+0xb8>)
   181da:	f014 f9b7 	bl	2c54c <z_log_minimal_printk>
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   181de:	696b      	ldr	r3, [r5, #20]
   181e0:	9300      	str	r3, [sp, #0]
   181e2:	692b      	ldr	r3, [r5, #16]
   181e4:	68ea      	ldr	r2, [r5, #12]
   181e6:	2145      	movs	r1, #69	; 0x45
   181e8:	4826      	ldr	r0, [pc, #152]	; (18284 <esf_dump+0xbc>)
   181ea:	f014 f9af 	bl	2c54c <z_log_minimal_printk>
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   181ee:	69ea      	ldr	r2, [r5, #28]
   181f0:	2145      	movs	r1, #69	; 0x45
   181f2:	4825      	ldr	r0, [pc, #148]	; (18288 <esf_dump+0xc0>)
   181f4:	f014 f9aa 	bl	2c54c <z_log_minimal_printk>
#if defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)
	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
   181f8:	2400      	movs	r4, #0
   181fa:	e033      	b.n	18264 <esf_dump+0x9c>
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   181fc:	f104 0308 	add.w	r3, r4, #8
   18200:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   18204:	ed93 6a00 	vldr	s12, [r3]
   18208:	1c62      	adds	r2, r4, #1
   1820a:	f104 0309 	add.w	r3, r4, #9
   1820e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   18212:	edd3 7a00 	vldr	s15, [r3]
   18216:	1ca1      	adds	r1, r4, #2
   18218:	f104 030a 	add.w	r3, r4, #10
   1821c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   18220:	ed93 7a00 	vldr	s14, [r3]
   18224:	1ce0      	adds	r0, r4, #3
   18226:	f104 030b 	add.w	r3, r4, #11
   1822a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
   1822e:	edd3 6a00 	vldr	s13, [r3]
   18232:	eefc 6ae6 	vcvt.u32.f32	s13, s13
   18236:	edcd 6a05 	vstr	s13, [sp, #20]
   1823a:	9004      	str	r0, [sp, #16]
   1823c:	eebc 7ac7 	vcvt.u32.f32	s14, s14
   18240:	ed8d 7a03 	vstr	s14, [sp, #12]
   18244:	9102      	str	r1, [sp, #8]
   18246:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1824a:	edcd 7a01 	vstr	s15, [sp, #4]
   1824e:	9200      	str	r2, [sp, #0]
   18250:	eefc 7ac6 	vcvt.u32.f32	s15, s12
   18254:	ee17 3a90 	vmov	r3, s15
   18258:	4622      	mov	r2, r4
   1825a:	2145      	movs	r1, #69	; 0x45
   1825c:	480b      	ldr	r0, [pc, #44]	; (1828c <esf_dump+0xc4>)
   1825e:	f014 f975 	bl	2c54c <z_log_minimal_printk>
	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
   18262:	3404      	adds	r4, #4
   18264:	2c0f      	cmp	r4, #15
   18266:	d9c9      	bls.n	181fc <esf_dump+0x34>
			i, (uint32_t)esf->fpu.s[i],
			i + 1, (uint32_t)esf->fpu.s[i + 1],
			i + 2, (uint32_t)esf->fpu.s[i + 2],
			i + 3, (uint32_t)esf->fpu.s[i + 3]);
	}
	LOG_ERR("fpscr:  0x%08x", esf->fpu.fpscr);
   18268:	6e2a      	ldr	r2, [r5, #96]	; 0x60
   1826a:	2145      	movs	r1, #69	; 0x45
   1826c:	4808      	ldr	r0, [pc, #32]	; (18290 <esf_dump+0xc8>)
   1826e:	f014 f96d 	bl	2c54c <z_log_minimal_printk>
	}

	LOG_ERR("EXC_RETURN: 0x%0x", esf->extra_info.exc_return);

#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   18272:	69aa      	ldr	r2, [r5, #24]
   18274:	2145      	movs	r1, #69	; 0x45
   18276:	4807      	ldr	r0, [pc, #28]	; (18294 <esf_dump+0xcc>)
   18278:	f014 f968 	bl	2c54c <z_log_minimal_printk>
		esf->basic.pc);
}
   1827c:	b007      	add	sp, #28
   1827e:	bd30      	pop	{r4, r5, pc}
   18280:	000392ec 	.word	0x000392ec
   18284:	00039320 	.word	0x00039320
   18288:	00039354 	.word	0x00039354
   1828c:	00039368 	.word	0x00039368
   18290:	000393b0 	.word	0x000393b0
   18294:	000393c4 	.word	0x000393c4

00018298 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   18298:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1829a:	2800      	cmp	r0, #0
   1829c:	db07      	blt.n	182ae <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1829e:	f000 021f 	and.w	r2, r0, #31
   182a2:	0940      	lsrs	r0, r0, #5
   182a4:	2301      	movs	r3, #1
   182a6:	4093      	lsls	r3, r2
   182a8:	4a01      	ldr	r2, [pc, #4]	; (182b0 <arch_irq_enable+0x18>)
   182aa:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
}
   182ae:	4770      	bx	lr
   182b0:	e000e100 	.word	0xe000e100

000182b4 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
   182b4:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   182b6:	2800      	cmp	r0, #0
   182b8:	db0c      	blt.n	182d4 <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   182ba:	f000 021f 	and.w	r2, r0, #31
   182be:	0940      	lsrs	r0, r0, #5
   182c0:	2301      	movs	r3, #1
   182c2:	4093      	lsls	r3, r2
   182c4:	3020      	adds	r0, #32
   182c6:	4a04      	ldr	r2, [pc, #16]	; (182d8 <arch_irq_disable+0x24>)
   182c8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   182cc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   182d0:	f3bf 8f6f 	isb	sy
}
   182d4:	4770      	bx	lr
   182d6:	bf00      	nop
   182d8:	e000e100 	.word	0xe000e100

000182dc <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   182dc:	0942      	lsrs	r2, r0, #5
   182de:	4b05      	ldr	r3, [pc, #20]	; (182f4 <arch_irq_is_enabled+0x18>)
   182e0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   182e4:	f000 001f 	and.w	r0, r0, #31
   182e8:	2301      	movs	r3, #1
   182ea:	fa03 f000 	lsl.w	r0, r3, r0
}
   182ee:	4010      	ands	r0, r2
   182f0:	4770      	bx	lr
   182f2:	bf00      	nop
   182f4:	e000e100 	.word	0xe000e100

000182f8 <z_arm_irq_priority_set>:
 * The priority is verified if ASSERT_ON is enabled. The maximum number
 * of priority levels is a little complex, as there are some hardware
 * priority levels which are reserved.
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
   182f8:	b570      	push	{r4, r5, r6, lr}
   182fa:	4604      	mov	r4, r0
	/* If we have zero latency interrupts, those interrupts will
	 * run at a priority level which is not masked by irq_lock().
	 * Our policy is to express priority levels with special properties
	 * via flags
	 */
	if (IS_ENABLED(CONFIG_ZERO_LATENCY_IRQS) && (flags & IRQ_ZERO_LATENCY)) {
   182fc:	f012 0f01 	tst.w	r2, #1
   18300:	d10d      	bne.n	1831e <z_arm_irq_priority_set+0x26>
			prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
		} else {
			/* Use caller supplied prio level as-is */
		}
	} else {
		prio += _IRQ_PRIO_OFFSET;
   18302:	1c8d      	adds	r5, r1, #2
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
   18304:	2d07      	cmp	r5, #7
   18306:	d90b      	bls.n	18320 <z_arm_irq_priority_set+0x28>
   18308:	4e0f      	ldr	r6, [pc, #60]	; (18348 <z_arm_irq_priority_set+0x50>)
   1830a:	225b      	movs	r2, #91	; 0x5b
   1830c:	4631      	mov	r1, r6
   1830e:	480f      	ldr	r0, [pc, #60]	; (1834c <z_arm_irq_priority_set+0x54>)
   18310:	f014 f90d 	bl	2c52e <assert_print>
   18314:	215b      	movs	r1, #91	; 0x5b
   18316:	4630      	mov	r0, r6
   18318:	f014 f902 	bl	2c520 <assert_post_action>
   1831c:	e000      	b.n	18320 <z_arm_irq_priority_set+0x28>
			prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
   1831e:	2500      	movs	r5, #0
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   18320:	b260      	sxtb	r0, r4
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   18322:	2800      	cmp	r0, #0
   18324:	db08      	blt.n	18338 <z_arm_irq_priority_set+0x40>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18326:	016d      	lsls	r5, r5, #5
   18328:	b2ed      	uxtb	r5, r5
   1832a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
   1832e:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
   18332:	f880 5300 	strb.w	r5, [r0, #768]	; 0x300
}
   18336:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18338:	f000 000f 	and.w	r0, r0, #15
   1833c:	016d      	lsls	r5, r5, #5
   1833e:	b2ed      	uxtb	r5, r5
   18340:	4b03      	ldr	r3, [pc, #12]	; (18350 <z_arm_irq_priority_set+0x58>)
   18342:	541d      	strb	r5, [r3, r0]
   18344:	e7f7      	b.n	18336 <z_arm_irq_priority_set+0x3e>
   18346:	bf00      	nop
   18348:	000393f8 	.word	0x000393f8
   1834c:	00031600 	.word	0x00031600
   18350:	e000ed14 	.word	0xe000ed14

00018354 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   18354:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   18356:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   18358:	4b05      	ldr	r3, [pc, #20]	; (18370 <_arch_isr_direct_pm+0x1c>)
   1835a:	69db      	ldr	r3, [r3, #28]
   1835c:	b90b      	cbnz	r3, 18362 <_arch_isr_direct_pm+0xe>
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_AARCH32_ARMV8_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   1835e:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   18360:	bd08      	pop	{r3, pc}
		_kernel.idle = 0;
   18362:	4b03      	ldr	r3, [pc, #12]	; (18370 <_arch_isr_direct_pm+0x1c>)
   18364:	2200      	movs	r2, #0
   18366:	61da      	str	r2, [r3, #28]
		z_pm_save_idle_exit();
   18368:	f018 faeb 	bl	30942 <z_pm_save_idle_exit>
   1836c:	e7f7      	b.n	1835e <_arch_isr_direct_pm+0xa>
   1836e:	bf00      	nop
   18370:	200046a4 	.word	0x200046a4

00018374 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   18374:	bf30      	wfi
    b z_SysNmiOnReset
   18376:	f7ff bffd 	b.w	18374 <z_SysNmiOnReset>
   1837a:	bf00      	nop

0001837c <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
   1837c:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1837e:	4b14      	ldr	r3, [pc, #80]	; (183d0 <z_arm_prep_c+0x54>)
   18380:	4a14      	ldr	r2, [pc, #80]	; (183d4 <z_arm_prep_c+0x58>)
   18382:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   18386:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
   18388:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1838c:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   18390:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   18394:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   18398:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
   1839c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   183a0:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
   183a4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
   183a8:	f503 7300 	add.w	r3, r3, #512	; 0x200
   183ac:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
   183b0:	635a      	str	r2, [r3, #52]	; 0x34
  __ASM volatile ("dsb 0xF":::"memory");
   183b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   183b6:	f3bf 8f6f 	isb	sy
     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
#if __has_builtin(__builtin_arm_set_fpscr)
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
   183ba:	2300      	movs	r3, #0
   183bc:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   183c0:	f00d fdd8 	bl	25f74 <z_bss_zero>
	z_data_copy();
   183c4:	f010 fe30 	bl	29028 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   183c8:	f000 fbfc 	bl	18bc4 <z_arm_interrupt_init>
	z_cstart();
   183cc:	f00d fe30 	bl	26030 <z_cstart>
   183d0:	e000ed00 	.word	0xe000ed00
   183d4:	00000000 	.word	0x00000000

000183d8 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   183d8:	4a0a      	ldr	r2, [pc, #40]	; (18404 <arch_swap+0x2c>)
   183da:	6893      	ldr	r3, [r2, #8]
   183dc:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
	_current->arch.swap_return_value = _k_neg_eagain;
   183e0:	4909      	ldr	r1, [pc, #36]	; (18408 <arch_swap+0x30>)
   183e2:	6809      	ldr	r1, [r1, #0]
   183e4:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   183e8:	4908      	ldr	r1, [pc, #32]	; (1840c <arch_swap+0x34>)
   183ea:	684b      	ldr	r3, [r1, #4]
   183ec:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   183f0:	604b      	str	r3, [r1, #4]
   183f2:	2300      	movs	r3, #0
   183f4:	f383 8811 	msr	BASEPRI, r3
   183f8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   183fc:	6893      	ldr	r3, [r2, #8]
}
   183fe:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
   18402:	4770      	bx	lr
   18404:	200046a4 	.word	0x200046a4
   18408:	0003bc84 	.word	0x0003bc84
   1840c:	e000ed00 	.word	0xe000ed00

00018410 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   18410:	4922      	ldr	r1, [pc, #136]	; (1849c <in_fp_endif+0x2a>)
    ldr r2, [r1, #_kernel_offset_to_current]
   18412:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   18414:	f882 e0cd 	strb.w	lr, [r2, #205]	; 0xcd
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   18418:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   1841c:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   1841e:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   18422:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#ifdef CONFIG_FPU_SHARING
    /* Assess whether switched-out thread had been using the FP registers. */
    tst lr, #_EXC_RETURN_FTYPE_Msk
   18426:	f01e 0f10 	tst.w	lr, #16
    bne out_fp_endif
   1842a:	d103      	bne.n	18434 <out_fp_endif>
    /* FP context active: set FP state and store callee-saved registers.
     * Note: if Lazy FP stacking is enabled, storing the callee-saved
     * registers will automatically trigger FP state preservation in
     * the thread's stack. This will also clear the FPCCR.LSPACT flag.
     */
    add r0, r2, #_thread_offset_to_preempt_float
   1842c:	f102 008c 	add.w	r0, r2, #140	; 0x8c
    vstmia r0, {s16-s31}
   18430:	ec80 8a10 	vstmia	r0, {s16-s31}

00018434 <out_fp_endif>:

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   18434:	2040      	movs	r0, #64	; 0x40
    msr BASEPRI_MAX, r0
   18436:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   1843a:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   1843e:	4f18      	ldr	r7, [pc, #96]	; (184a0 <in_fp_endif+0x2e>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   18440:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   18444:	6a0a      	ldr	r2, [r1, #32]

    str r2, [r1, #_kernel_offset_to_current]
   18446:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   18448:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   1844a:	f992 e0cd 	ldrsb.w	lr, [r2, #205]	; 0xcd

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   1844e:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
    movs r3, #0
   18452:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   18454:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   18458:	f380 8811 	msr	BASEPRI, r0

#ifdef CONFIG_FPU_SHARING
    /* Assess whether switched-in thread had been using the FP registers. */
    tst lr, #_EXC_RETURN_FTYPE_Msk
   1845c:	f01e 0f10 	tst.w	lr, #16
    beq in_fp_active
   18460:	d003      	beq.n	1846a <in_fp_active>
    /* FP context inactive for swapped-in thread:
     * - reset FPSCR to 0
     * - set EXC_RETURN.F_Type (prevents FP frame un-stacking when returning
     *   from pendSV)
     */
    movs.n r3, #0
   18462:	2300      	movs	r3, #0
    vmsr fpscr, r3
   18464:	eee1 3a10 	vmsr	fpscr, r3
    b in_fp_endif
   18468:	e003      	b.n	18472 <in_fp_endif>

0001846a <in_fp_active>:
    /* FP context active:
     * - clear EXC_RETURN.F_Type
     * - FPSCR and caller-saved registers will be restored automatically
     * - restore callee-saved FP registers
     */
    add r0, r2, #_thread_offset_to_preempt_float
   1846a:	f102 008c 	add.w	r0, r2, #140	; 0x8c
    vldmia r0, {s16-s31}
   1846e:	ec90 8a10 	vldmia	r0, {s16-s31}

00018472 <in_fp_endif>:
in_fp_endif:
    /* Clear CONTROL.FPCA that may have been set by FP instructions */
    mrs r3, CONTROL
   18472:	f3ef 8314 	mrs	r3, CONTROL
    bic r3, #_CONTROL_FPCA_Msk
   18476:	f023 0304 	bic.w	r3, r3, #4
    msr CONTROL, r3
   1847a:	f383 8814 	msr	CONTROL, r3
    isb
   1847e:	f3bf 8f6f 	isb	sy
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
   18482:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
   18484:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
   18486:	f000 fc47 	bl	18d18 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
   1848a:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   1848e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   18492:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   18496:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   1849a:	4770      	bx	lr
    ldr r1, =_kernel
   1849c:	200046a4 	.word	0x200046a4
    ldr v4, =_SCS_ICSR
   184a0:	e000ed04 	.word	0xe000ed04

000184a4 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   184a4:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   184a8:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   184aa:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   184ae:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   184b2:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   184b4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   184b8:	2902      	cmp	r1, #2
    beq _oops
   184ba:	d0ff      	beq.n	184bc <_oops>

000184bc <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   184bc:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
   184be:	f014 f9b4 	bl	2c82a <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
   184c2:	bd01      	pop	{r0, pc}

000184c4 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
   184c4:	b410      	push	{r4}
		thread->stack_info.start += MPU_GUARD_ALIGN_AND_SIZE;
		thread->stack_info.size -= MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif /* CONFIG_USERSPACE */
#if FP_GUARD_EXTRA_SIZE > 0
	if ((thread->base.user_options & K_FP_REGS) != 0) {
   184c6:	7b01      	ldrb	r1, [r0, #12]
   184c8:	f011 0f02 	tst.w	r1, #2
   184cc:	d005      	beq.n	184da <arch_new_thread+0x16>
		/* Larger guard needed due to lazy stacking of FP regs may
		 * overshoot the guard area without writing anything. We
		 * carve it out of the stack buffer as-needed instead of
		 * unconditionally reserving it.
		 */
		thread->stack_info.start += FP_GUARD_EXTRA_SIZE;
   184ce:	6f41      	ldr	r1, [r0, #116]	; 0x74
   184d0:	3140      	adds	r1, #64	; 0x40
   184d2:	6741      	str	r1, [r0, #116]	; 0x74
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
   184d4:	6f81      	ldr	r1, [r0, #120]	; 0x78
   184d6:	3940      	subs	r1, #64	; 0x40
   184d8:	6781      	str	r1, [r0, #120]	; 0x78
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   184da:	f1a2 0420 	sub.w	r4, r2, #32
		iframe->pc = (uint32_t)arch_user_mode_enter;
	} else {
		iframe->pc = (uint32_t)z_thread_entry;
	}
#else
	iframe->pc = (uint32_t)z_thread_entry;
   184de:	4915      	ldr	r1, [pc, #84]	; (18534 <arch_new_thread+0x70>)
   184e0:	f842 1c08 	str.w	r1, [r2, #-8]
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
   184e4:	f021 0101 	bic.w	r1, r1, #1
   184e8:	f842 1c08 	str.w	r1, [r2, #-8]
#endif
	iframe->a1 = (uint32_t)entry;
   184ec:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   184f0:	9b01      	ldr	r3, [sp, #4]
   184f2:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   184f6:	9b02      	ldr	r3, [sp, #8]
   184f8:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   184fc:	9b03      	ldr	r3, [sp, #12]
   184fe:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   18502:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   18506:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe = (struct __basic_sf *)
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
   1850a:	6504      	str	r4, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
   1850c:	2300      	movs	r3, #0
   1850e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   18512:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
#if defined(CONFIG_ARM_STORE_EXC_RETURN)
	thread->arch.mode_exc_return = DEFAULT_EXC_RETURN;
   18516:	23fd      	movs	r3, #253	; 0xfd
   18518:	f880 30cd 	strb.w	r3, [r0, #205]	; 0xcd
#endif
#if FP_GUARD_EXTRA_SIZE > 0
	if ((thread->base.user_options & K_FP_REGS) != 0) {
   1851c:	7b03      	ldrb	r3, [r0, #12]
   1851e:	f013 0f02 	tst.w	r3, #2
   18522:	d003      	beq.n	1852c <arch_new_thread+0x68>
		thread->arch.mode |= Z_ARM_MODE_MPU_GUARD_FLOAT_Msk;
   18524:	f64f 5308 	movw	r3, #64776	; 0xfd08
   18528:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   1852c:	f85d 4b04 	ldr.w	r4, [sp], #4
   18530:	4770      	bx	lr
   18532:	bf00      	nop
   18534:	0002c159 	.word	0x0002c159

00018538 <z_arm_mpu_stack_guard_and_fpu_adjust>:
 * policy and the stack_info values for the thread that is
 * being switched in.
 */
uint32_t z_arm_mpu_stack_guard_and_fpu_adjust(struct k_thread *thread)
{
	if (((thread->base.user_options & K_FP_REGS) != 0) ||
   18538:	7b03      	ldrb	r3, [r0, #12]
   1853a:	f013 0f02 	tst.w	r3, #2
   1853e:	d11a      	bne.n	18576 <z_arm_mpu_stack_guard_and_fpu_adjust+0x3e>
		((thread->arch.mode_exc_return & EXC_RETURN_FTYPE) == 0)) {
   18540:	f890 30cd 	ldrb.w	r3, [r0, #205]	; 0xcd
	if (((thread->base.user_options & K_FP_REGS) != 0) ||
   18544:	f013 0f10 	tst.w	r3, #16
   18548:	d015      	beq.n	18576 <z_arm_mpu_stack_guard_and_fpu_adjust+0x3e>
	/* Thread is not pre-tagged with K_FP_REGS, and it has
	 * not been using the FPU. Since there is no active FPU
	 * context, de-activate lazy stacking and program the
	 * default MPU guard size.
	 */
	FPU->FPCCR &= (~FPU_FPCCR_LSPEN_Msk);
   1854a:	4a19      	ldr	r2, [pc, #100]	; (185b0 <z_arm_mpu_stack_guard_and_fpu_adjust+0x78>)
   1854c:	6b53      	ldr	r3, [r2, #52]	; 0x34
   1854e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   18552:	6353      	str	r3, [r2, #52]	; 0x34
		if ((thread->arch.mode &
   18554:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
   18558:	f013 0f08 	tst.w	r3, #8
   1855c:	d025      	beq.n	185aa <z_arm_mpu_stack_guard_and_fpu_adjust+0x72>
			thread->arch.mode &= ~Z_ARM_MODE_MPU_GUARD_FLOAT_Msk;
   1855e:	f023 0308 	bic.w	r3, r3, #8
   18562:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
				thread->stack_info.start -=
   18566:	6f43      	ldr	r3, [r0, #116]	; 0x74
   18568:	3b40      	subs	r3, #64	; 0x40
   1856a:	6743      	str	r3, [r0, #116]	; 0x74
				thread->stack_info.size +=
   1856c:	6f83      	ldr	r3, [r0, #120]	; 0x78
   1856e:	3340      	adds	r3, #64	; 0x40
   18570:	6783      	str	r3, [r0, #120]	; 0x78

	z_arm_thread_stack_info_adjust(thread, false);

	return MPU_GUARD_ALIGN_AND_SIZE;
   18572:	2040      	movs	r0, #64	; 0x40
   18574:	4770      	bx	lr
		FPU->FPCCR |= FPU_FPCCR_LSPEN_Msk;
   18576:	4a0e      	ldr	r2, [pc, #56]	; (185b0 <z_arm_mpu_stack_guard_and_fpu_adjust+0x78>)
   18578:	6b53      	ldr	r3, [r2, #52]	; 0x34
   1857a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   1857e:	6353      	str	r3, [r2, #52]	; 0x34
		if ((thread->arch.mode &
   18580:	f8d0 30cc 	ldr.w	r3, [r0, #204]	; 0xcc
   18584:	f013 0f08 	tst.w	r3, #8
   18588:	d109      	bne.n	1859e <z_arm_mpu_stack_guard_and_fpu_adjust+0x66>
			thread->arch.mode |= Z_ARM_MODE_MPU_GUARD_FLOAT_Msk;
   1858a:	f043 0308 	orr.w	r3, r3, #8
   1858e:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
				thread->stack_info.start +=
   18592:	6f43      	ldr	r3, [r0, #116]	; 0x74
   18594:	3340      	adds	r3, #64	; 0x40
   18596:	6743      	str	r3, [r0, #116]	; 0x74
				thread->stack_info.size -=
   18598:	6f83      	ldr	r3, [r0, #120]	; 0x78
   1859a:	3b40      	subs	r3, #64	; 0x40
   1859c:	6783      	str	r3, [r0, #120]	; 0x78
		thread->base.user_options |= K_FP_REGS;
   1859e:	7b03      	ldrb	r3, [r0, #12]
   185a0:	f043 0302 	orr.w	r3, r3, #2
   185a4:	7303      	strb	r3, [r0, #12]
		return MPU_GUARD_ALIGN_AND_SIZE_FLOAT;
   185a6:	2080      	movs	r0, #128	; 0x80
   185a8:	4770      	bx	lr
	return MPU_GUARD_ALIGN_AND_SIZE;
   185aa:	2040      	movs	r0, #64	; 0x40
}
   185ac:	4770      	bx	lr
   185ae:	bf00      	nop
   185b0:	e000ef00 	.word	0xe000ef00

000185b4 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
   185b4:	4b18      	ldr	r3, [pc, #96]	; (18618 <z_check_thread_stack_fail+0x64>)
   185b6:	689b      	ldr	r3, [r3, #8]

	if (thread == NULL) {
   185b8:	b30b      	cbz	r3, 185fe <z_check_thread_stack_fail+0x4a>
#endif

#if (defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)) && \
	defined(CONFIG_MPU_STACK_GUARD)
	uint32_t guard_len =
		((_current->arch.mode & Z_ARM_MODE_MPU_GUARD_FLOAT_Msk) != 0) ?
   185ba:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
		MPU_GUARD_ALIGN_AND_SIZE_FLOAT : MPU_GUARD_ALIGN_AND_SIZE;
   185be:	f012 0f08 	tst.w	r2, #8
   185c2:	d00e      	beq.n	185e2 <z_check_thread_stack_fail+0x2e>
   185c4:	2280      	movs	r2, #128	; 0x80
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
   185c6:	f110 0f16 	cmn.w	r0, #22
   185ca:	d01a      	beq.n	18602 <z_check_thread_stack_fail+0x4e>
{
   185cc:	b410      	push	{r4}
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
   185ce:	6f5c      	ldr	r4, [r3, #116]	; 0x74
   185d0:	1aa2      	subs	r2, r4, r2
   185d2:	4282      	cmp	r2, r0
   185d4:	d807      	bhi.n	185e6 <z_check_thread_stack_fail+0x32>
   185d6:	4284      	cmp	r4, r0
   185d8:	d90b      	bls.n	185f2 <z_check_thread_stack_fail+0x3e>
   185da:	428c      	cmp	r4, r1
   185dc:	d80b      	bhi.n	185f6 <z_check_thread_stack_fail+0x42>
   185de:	2100      	movs	r1, #0
   185e0:	e002      	b.n	185e8 <z_check_thread_stack_fail+0x34>
		MPU_GUARD_ALIGN_AND_SIZE_FLOAT : MPU_GUARD_ALIGN_AND_SIZE;
   185e2:	2240      	movs	r2, #64	; 0x40
   185e4:	e7ef      	b.n	185c6 <z_check_thread_stack_fail+0x12>
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
   185e6:	2100      	movs	r1, #0
   185e8:	b939      	cbnz	r1, 185fa <z_check_thread_stack_fail+0x46>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
   185ea:	2000      	movs	r0, #0
}
   185ec:	f85d 4b04 	ldr.w	r4, [sp], #4
   185f0:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
   185f2:	2100      	movs	r1, #0
   185f4:	e7f8      	b.n	185e8 <z_check_thread_stack_fail+0x34>
   185f6:	2101      	movs	r1, #1
   185f8:	e7f6      	b.n	185e8 <z_check_thread_stack_fail+0x34>
		return thread->stack_info.start;
   185fa:	6f58      	ldr	r0, [r3, #116]	; 0x74
   185fc:	e7f6      	b.n	185ec <z_check_thread_stack_fail+0x38>
		return 0;
   185fe:	2000      	movs	r0, #0
   18600:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
   18602:	6f5a      	ldr	r2, [r3, #116]	; 0x74
   18604:	428a      	cmp	r2, r1
   18606:	bf94      	ite	ls
   18608:	2100      	movls	r1, #0
   1860a:	2101      	movhi	r1, #1
   1860c:	b909      	cbnz	r1, 18612 <z_check_thread_stack_fail+0x5e>
	return 0;
   1860e:	2000      	movs	r0, #0
}
   18610:	4770      	bx	lr
		return thread->stack_info.start;
   18612:	6f58      	ldr	r0, [r3, #116]	; 0x74
   18614:	4770      	bx	lr
   18616:	bf00      	nop
   18618:	200046a4 	.word	0x200046a4

0001861c <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
   1861c:	b508      	push	{r3, lr}
   1861e:	4604      	mov	r4, r0
   18620:	460e      	mov	r6, r1
   18622:	4615      	mov	r5, r2
	z_arm_prepare_switch_to_main();
   18624:	f014 f913 	bl	2c84e <z_arm_prepare_switch_to_main>

	_current = main_thread;
   18628:	4b08      	ldr	r3, [pc, #32]	; (1864c <arch_switch_to_main_thread+0x30>)
   1862a:	609c      	str	r4, [r3, #8]
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
   1862c:	4620      	mov	r0, r4
   1862e:	f000 fb73 	bl	18d18 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   18632:	4628      	mov	r0, r5
   18634:	f386 8809 	msr	PSP, r6
   18638:	2100      	movs	r1, #0
   1863a:	b663      	cpsie	if
   1863c:	f381 8811 	msr	BASEPRI, r1
   18640:	f3bf 8f6f 	isb	sy
   18644:	2200      	movs	r2, #0
   18646:	2300      	movs	r3, #0
   18648:	f013 fd86 	bl	2c158 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   1864c:	200046a4 	.word	0x200046a4

00018650 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   18650:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   18652:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   18654:	4a0b      	ldr	r2, [pc, #44]	; (18684 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   18656:	69d0      	ldr	r0, [r2, #28]
	cmp r0, #0
   18658:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   1865a:	bf1e      	ittt	ne
	movne	r1, #0
   1865c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   1865e:	61d1      	strne	r1, [r2, #28]
		blne	z_pm_save_idle_exit
   18660:	f018 f96f 	blne	30942 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   18664:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   18666:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   1866a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   1866e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   18672:	4905      	ldr	r1, [pc, #20]	; (18688 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   18674:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   18676:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   18678:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   1867a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   1867e:	4903      	ldr	r1, [pc, #12]	; (1868c <_isr_wrapper+0x3c>)
	bx r1
   18680:	4708      	bx	r1
   18682:	0000      	.short	0x0000
	ldr r2, =_kernel
   18684:	200046a4 	.word	0x200046a4
	ldr r1, =_sw_isr_table
   18688:	000310ec 	.word	0x000310ec
	ldr r1, =z_arm_int_exit
   1868c:	00018691 	.word	0x00018691

00018690 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   18690:	4b04      	ldr	r3, [pc, #16]	; (186a4 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   18692:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   18694:	6a18      	ldr	r0, [r3, #32]
	cmp r0, r1
   18696:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   18698:	d003      	beq.n	186a2 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   1869a:	4903      	ldr	r1, [pc, #12]	; (186a8 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   1869c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   186a0:	600a      	str	r2, [r1, #0]

000186a2 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   186a2:	4770      	bx	lr
	ldr r3, =_kernel
   186a4:	200046a4 	.word	0x200046a4
	ldr r1, =_SCS_ICSR
   186a8:	e000ed04 	.word	0xe000ed04

000186ac <bus_fault>:
 *
 * @return error code to identify the fatal error reason.
 *
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
{
   186ac:	b570      	push	{r4, r5, r6, lr}
   186ae:	4605      	mov	r5, r0
   186b0:	460e      	mov	r6, r1
   186b2:	4614      	mov	r4, r2
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
   186b4:	2145      	movs	r1, #69	; 0x45
   186b6:	482e      	ldr	r0, [pc, #184]	; (18770 <bus_fault+0xc4>)
   186b8:	f013 ff48 	bl	2c54c <z_log_minimal_printk>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   186bc:	4b2d      	ldr	r3, [pc, #180]	; (18774 <bus_fault+0xc8>)
   186be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   186c0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   186c4:	d124      	bne.n	18710 <bus_fault+0x64>
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   186c6:	4b2b      	ldr	r3, [pc, #172]	; (18774 <bus_fault+0xc8>)
   186c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   186ca:	f413 6f00 	tst.w	r3, #2048	; 0x800
   186ce:	d124      	bne.n	1871a <bus_fault+0x6e>
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   186d0:	4b28      	ldr	r3, [pc, #160]	; (18774 <bus_fault+0xc8>)
   186d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   186d4:	f413 7f00 	tst.w	r3, #512	; 0x200
   186d8:	d124      	bne.n	18724 <bus_fault+0x78>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   186da:	4b26      	ldr	r3, [pc, #152]	; (18774 <bus_fault+0xc8>)
   186dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   186de:	f413 6f80 	tst.w	r3, #1024	; 0x400
   186e2:	d135      	bne.n	18750 <bus_fault+0xa4>
		PR_FAULT_INFO("  Imprecise data bus error");
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   186e4:	4b23      	ldr	r3, [pc, #140]	; (18774 <bus_fault+0xc8>)
   186e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   186e8:	f413 7f80 	tst.w	r3, #256	; 0x100
   186ec:	d135      	bne.n	1875a <bus_fault+0xae>
		PR_FAULT_INFO("  Instruction bus error");
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   186ee:	4b21      	ldr	r3, [pc, #132]	; (18774 <bus_fault+0xc8>)
   186f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   186f2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   186f6:	d135      	bne.n	18764 <bus_fault+0xb8>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   186f8:	4a1e      	ldr	r2, [pc, #120]	; (18774 <bus_fault+0xc8>)
   186fa:	6a93      	ldr	r3, [r2, #40]	; 0x28
   186fc:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   18700:	6293      	str	r3, [r2, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
   18702:	2101      	movs	r1, #1
   18704:	4628      	mov	r0, r5
   18706:	f014 f8b0 	bl	2c86a <memory_fault_recoverable>
   1870a:	7020      	strb	r0, [r4, #0]

	return reason;
}
   1870c:	2000      	movs	r0, #0
   1870e:	bd70      	pop	{r4, r5, r6, pc}
		PR_FAULT_INFO("  Stacking error");
   18710:	2145      	movs	r1, #69	; 0x45
   18712:	4819      	ldr	r0, [pc, #100]	; (18778 <bus_fault+0xcc>)
   18714:	f013 ff1a 	bl	2c54c <z_log_minimal_printk>
   18718:	e7d5      	b.n	186c6 <bus_fault+0x1a>
		PR_FAULT_INFO("  Unstacking error");
   1871a:	2145      	movs	r1, #69	; 0x45
   1871c:	4817      	ldr	r0, [pc, #92]	; (1877c <bus_fault+0xd0>)
   1871e:	f013 ff15 	bl	2c54c <z_log_minimal_printk>
   18722:	e7d5      	b.n	186d0 <bus_fault+0x24>
		PR_FAULT_INFO("  Precise data bus error");
   18724:	2145      	movs	r1, #69	; 0x45
   18726:	4816      	ldr	r0, [pc, #88]	; (18780 <bus_fault+0xd4>)
   18728:	f013 ff10 	bl	2c54c <z_log_minimal_printk>
		STORE_xFAR(bfar, SCB->BFAR);
   1872c:	4b11      	ldr	r3, [pc, #68]	; (18774 <bus_fault+0xc8>)
   1872e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   18730:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   18732:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   18736:	d0d0      	beq.n	186da <bus_fault+0x2e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   18738:	2145      	movs	r1, #69	; 0x45
   1873a:	4812      	ldr	r0, [pc, #72]	; (18784 <bus_fault+0xd8>)
   1873c:	f013 ff06 	bl	2c54c <z_log_minimal_printk>
			if (from_hard_fault != 0) {
   18740:	2e00      	cmp	r6, #0
   18742:	d0ca      	beq.n	186da <bus_fault+0x2e>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   18744:	4a0b      	ldr	r2, [pc, #44]	; (18774 <bus_fault+0xc8>)
   18746:	6a93      	ldr	r3, [r2, #40]	; 0x28
   18748:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   1874c:	6293      	str	r3, [r2, #40]	; 0x28
   1874e:	e7c4      	b.n	186da <bus_fault+0x2e>
		PR_FAULT_INFO("  Imprecise data bus error");
   18750:	2145      	movs	r1, #69	; 0x45
   18752:	480d      	ldr	r0, [pc, #52]	; (18788 <bus_fault+0xdc>)
   18754:	f013 fefa 	bl	2c54c <z_log_minimal_printk>
   18758:	e7c4      	b.n	186e4 <bus_fault+0x38>
		PR_FAULT_INFO("  Instruction bus error");
   1875a:	2145      	movs	r1, #69	; 0x45
   1875c:	480b      	ldr	r0, [pc, #44]	; (1878c <bus_fault+0xe0>)
   1875e:	f013 fef5 	bl	2c54c <z_log_minimal_printk>
   18762:	e7c9      	b.n	186f8 <bus_fault+0x4c>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   18764:	2145      	movs	r1, #69	; 0x45
   18766:	480a      	ldr	r0, [pc, #40]	; (18790 <bus_fault+0xe4>)
   18768:	f013 fef0 	bl	2c54c <z_log_minimal_printk>
   1876c:	e7c4      	b.n	186f8 <bus_fault+0x4c>
   1876e:	bf00      	nop
   18770:	00039430 	.word	0x00039430
   18774:	e000ed00 	.word	0xe000ed00
   18778:	0003944c 	.word	0x0003944c
   1877c:	00039464 	.word	0x00039464
   18780:	0003947c 	.word	0x0003947c
   18784:	0003949c 	.word	0x0003949c
   18788:	000394b8 	.word	0x000394b8
   1878c:	000394d8 	.word	0x000394d8
   18790:	000394f8 	.word	0x000394f8

00018794 <usage_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
{
   18794:	b508      	push	{r3, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
   18796:	2145      	movs	r1, #69	; 0x45
   18798:	4823      	ldr	r0, [pc, #140]	; (18828 <usage_fault+0x94>)
   1879a:	f013 fed7 	bl	2c54c <z_log_minimal_printk>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   1879e:	4b23      	ldr	r3, [pc, #140]	; (1882c <usage_fault+0x98>)
   187a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   187a2:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
   187a6:	d121      	bne.n	187ec <usage_fault+0x58>
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   187a8:	4b20      	ldr	r3, [pc, #128]	; (1882c <usage_fault+0x98>)
   187aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   187ac:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   187b0:	d121      	bne.n	187f6 <usage_fault+0x62>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   187b2:	4b1e      	ldr	r3, [pc, #120]	; (1882c <usage_fault+0x98>)
   187b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   187b6:	f413 2f00 	tst.w	r3, #524288	; 0x80000
   187ba:	d121      	bne.n	18800 <usage_fault+0x6c>
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   187bc:	4b1b      	ldr	r3, [pc, #108]	; (1882c <usage_fault+0x98>)
   187be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   187c0:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   187c4:	d121      	bne.n	1880a <usage_fault+0x76>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   187c6:	4b19      	ldr	r3, [pc, #100]	; (1882c <usage_fault+0x98>)
   187c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   187ca:	f413 3f00 	tst.w	r3, #131072	; 0x20000
   187ce:	d121      	bne.n	18814 <usage_fault+0x80>
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   187d0:	4b16      	ldr	r3, [pc, #88]	; (1882c <usage_fault+0x98>)
   187d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   187d4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   187d8:	d121      	bne.n	1881e <usage_fault+0x8a>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   187da:	4a14      	ldr	r2, [pc, #80]	; (1882c <usage_fault+0x98>)
   187dc:	6a93      	ldr	r3, [r2, #40]	; 0x28
   187de:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   187e2:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   187e6:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
   187e8:	2000      	movs	r0, #0
   187ea:	bd08      	pop	{r3, pc}
		PR_FAULT_INFO("  Division by zero");
   187ec:	2145      	movs	r1, #69	; 0x45
   187ee:	4810      	ldr	r0, [pc, #64]	; (18830 <usage_fault+0x9c>)
   187f0:	f013 feac 	bl	2c54c <z_log_minimal_printk>
   187f4:	e7d8      	b.n	187a8 <usage_fault+0x14>
		PR_FAULT_INFO("  Unaligned memory access");
   187f6:	2145      	movs	r1, #69	; 0x45
   187f8:	480e      	ldr	r0, [pc, #56]	; (18834 <usage_fault+0xa0>)
   187fa:	f013 fea7 	bl	2c54c <z_log_minimal_printk>
   187fe:	e7d8      	b.n	187b2 <usage_fault+0x1e>
		PR_FAULT_INFO("  No coprocessor instructions");
   18800:	2145      	movs	r1, #69	; 0x45
   18802:	480d      	ldr	r0, [pc, #52]	; (18838 <usage_fault+0xa4>)
   18804:	f013 fea2 	bl	2c54c <z_log_minimal_printk>
   18808:	e7d8      	b.n	187bc <usage_fault+0x28>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   1880a:	2145      	movs	r1, #69	; 0x45
   1880c:	480b      	ldr	r0, [pc, #44]	; (1883c <usage_fault+0xa8>)
   1880e:	f013 fe9d 	bl	2c54c <z_log_minimal_printk>
   18812:	e7d8      	b.n	187c6 <usage_fault+0x32>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   18814:	2145      	movs	r1, #69	; 0x45
   18816:	480a      	ldr	r0, [pc, #40]	; (18840 <usage_fault+0xac>)
   18818:	f013 fe98 	bl	2c54c <z_log_minimal_printk>
   1881c:	e7d8      	b.n	187d0 <usage_fault+0x3c>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   1881e:	2145      	movs	r1, #69	; 0x45
   18820:	4808      	ldr	r0, [pc, #32]	; (18844 <usage_fault+0xb0>)
   18822:	f013 fe93 	bl	2c54c <z_log_minimal_printk>
   18826:	e7d8      	b.n	187da <usage_fault+0x46>
   18828:	0003952c 	.word	0x0003952c
   1882c:	e000ed00 	.word	0xe000ed00
   18830:	0003954c 	.word	0x0003954c
   18834:	00039564 	.word	0x00039564
   18838:	00039584 	.word	0x00039584
   1883c:	000395a8 	.word	0x000395a8
   18840:	000395d4 	.word	0x000395d4
   18844:	000395f4 	.word	0x000395f4

00018848 <debug_monitor>:
 *
 * See z_arm_fault_dump() for example.
 *
 */
static void debug_monitor(z_arch_esf_t *esf, bool *recoverable)
{
   18848:	b508      	push	{r3, lr}
	*recoverable = false;
   1884a:	2300      	movs	r3, #0
   1884c:	700b      	strb	r3, [r1, #0]

	PR_FAULT_INFO(
   1884e:	2145      	movs	r1, #69	; 0x45
   18850:	4801      	ldr	r0, [pc, #4]	; (18858 <debug_monitor+0x10>)
   18852:	f013 fe7b 	bl	2c54c <z_log_minimal_printk>

		*recoverable = memory_fault_recoverable(esf, false);
	}

#endif
}
   18856:	bd08      	pop	{r3, pc}
   18858:	00039624 	.word	0x00039624

0001885c <reserved_exception>:
 *
 * See z_arm_fault_dump() for example.
 *
 */
static void reserved_exception(const z_arch_esf_t *esf, int fault)
{
   1885c:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	PR_FAULT_INFO("***** %s %d) *****",
   1885e:	290f      	cmp	r1, #15
   18860:	dc07      	bgt.n	18872 <reserved_exception+0x16>
   18862:	4a05      	ldr	r2, [pc, #20]	; (18878 <reserved_exception+0x1c>)
   18864:	f1a1 0310 	sub.w	r3, r1, #16
   18868:	2145      	movs	r1, #69	; 0x45
   1886a:	4804      	ldr	r0, [pc, #16]	; (1887c <reserved_exception+0x20>)
   1886c:	f013 fe6e 	bl	2c54c <z_log_minimal_printk>
	       fault < 16 ? "Reserved Exception (" : "Spurious interrupt (IRQ ",
	       fault - 16);
}
   18870:	bd08      	pop	{r3, pc}
	PR_FAULT_INFO("***** %s %d) *****",
   18872:	4a03      	ldr	r2, [pc, #12]	; (18880 <reserved_exception+0x24>)
   18874:	e7f6      	b.n	18864 <reserved_exception+0x8>
   18876:	bf00      	nop
   18878:	0003966c 	.word	0x0003966c
   1887c:	00039684 	.word	0x00039684
   18880:	00039650 	.word	0x00039650

00018884 <mem_manage_fault>:
{
   18884:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18886:	4605      	mov	r5, r0
   18888:	460c      	mov	r4, r1
   1888a:	4616      	mov	r6, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
   1888c:	2145      	movs	r1, #69	; 0x45
   1888e:	4847      	ldr	r0, [pc, #284]	; (189ac <mem_manage_fault+0x128>)
   18890:	f013 fe5c 	bl	2c54c <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   18894:	4b46      	ldr	r3, [pc, #280]	; (189b0 <mem_manage_fault+0x12c>)
   18896:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   18898:	f013 0f10 	tst.w	r3, #16
   1889c:	d13a      	bne.n	18914 <mem_manage_fault+0x90>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   1889e:	4b44      	ldr	r3, [pc, #272]	; (189b0 <mem_manage_fault+0x12c>)
   188a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   188a2:	f013 0f08 	tst.w	r3, #8
   188a6:	d13a      	bne.n	1891e <mem_manage_fault+0x9a>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   188a8:	4b41      	ldr	r3, [pc, #260]	; (189b0 <mem_manage_fault+0x12c>)
   188aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   188ac:	f013 0f02 	tst.w	r3, #2
   188b0:	d13a      	bne.n	18928 <mem_manage_fault+0xa4>
	uint32_t mmfar = -EINVAL;
   188b2:	f06f 0715 	mvn.w	r7, #21
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   188b6:	4b3e      	ldr	r3, [pc, #248]	; (189b0 <mem_manage_fault+0x12c>)
   188b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   188ba:	f013 0f01 	tst.w	r3, #1
   188be:	d14d      	bne.n	1895c <mem_manage_fault+0xd8>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   188c0:	4b3b      	ldr	r3, [pc, #236]	; (189b0 <mem_manage_fault+0x12c>)
   188c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   188c4:	f013 0f20 	tst.w	r3, #32
   188c8:	d14d      	bne.n	18966 <mem_manage_fault+0xe2>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   188ca:	4b39      	ldr	r3, [pc, #228]	; (189b0 <mem_manage_fault+0x12c>)
   188cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   188ce:	f013 0f10 	tst.w	r3, #16
   188d2:	d104      	bne.n	188de <mem_manage_fault+0x5a>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   188d4:	4b36      	ldr	r3, [pc, #216]	; (189b0 <mem_manage_fault+0x12c>)
   188d6:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   188d8:	f014 0402 	ands.w	r4, r4, #2
   188dc:	d004      	beq.n	188e8 <mem_manage_fault+0x64>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
   188de:	4b34      	ldr	r3, [pc, #208]	; (189b0 <mem_manage_fault+0x12c>)
   188e0:	685c      	ldr	r4, [r3, #4]
   188e2:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
   188e6:	d143      	bne.n	18970 <mem_manage_fault+0xec>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   188e8:	4b31      	ldr	r3, [pc, #196]	; (189b0 <mem_manage_fault+0x12c>)
   188ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   188ec:	f013 0f20 	tst.w	r3, #32
   188f0:	d004      	beq.n	188fc <mem_manage_fault+0x78>
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
   188f2:	4a2f      	ldr	r2, [pc, #188]	; (189b0 <mem_manage_fault+0x12c>)
   188f4:	6a53      	ldr	r3, [r2, #36]	; 0x24
   188f6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   188fa:	6253      	str	r3, [r2, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   188fc:	492c      	ldr	r1, [pc, #176]	; (189b0 <mem_manage_fault+0x12c>)
   188fe:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   18900:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
   18904:	628b      	str	r3, [r1, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   18906:	2101      	movs	r1, #1
   18908:	4628      	mov	r0, r5
   1890a:	f013 ffae 	bl	2c86a <memory_fault_recoverable>
   1890e:	7030      	strb	r0, [r6, #0]
}
   18910:	4620      	mov	r0, r4
   18912:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		PR_FAULT_INFO("  Stacking error (context area might be"
   18914:	2145      	movs	r1, #69	; 0x45
   18916:	4827      	ldr	r0, [pc, #156]	; (189b4 <mem_manage_fault+0x130>)
   18918:	f013 fe18 	bl	2c54c <z_log_minimal_printk>
   1891c:	e7bf      	b.n	1889e <mem_manage_fault+0x1a>
		PR_FAULT_INFO("  Unstacking error");
   1891e:	2145      	movs	r1, #69	; 0x45
   18920:	4825      	ldr	r0, [pc, #148]	; (189b8 <mem_manage_fault+0x134>)
   18922:	f013 fe13 	bl	2c54c <z_log_minimal_printk>
   18926:	e7bf      	b.n	188a8 <mem_manage_fault+0x24>
		PR_FAULT_INFO("  Data Access Violation");
   18928:	2145      	movs	r1, #69	; 0x45
   1892a:	4824      	ldr	r0, [pc, #144]	; (189bc <mem_manage_fault+0x138>)
   1892c:	f013 fe0e 	bl	2c54c <z_log_minimal_printk>
		uint32_t temp = SCB->MMFAR;
   18930:	4b1f      	ldr	r3, [pc, #124]	; (189b0 <mem_manage_fault+0x12c>)
   18932:	6b5f      	ldr	r7, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   18934:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   18936:	f013 0f80 	tst.w	r3, #128	; 0x80
   1893a:	d102      	bne.n	18942 <mem_manage_fault+0xbe>
	uint32_t mmfar = -EINVAL;
   1893c:	f06f 0715 	mvn.w	r7, #21
   18940:	e7b9      	b.n	188b6 <mem_manage_fault+0x32>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   18942:	463a      	mov	r2, r7
   18944:	2145      	movs	r1, #69	; 0x45
   18946:	481e      	ldr	r0, [pc, #120]	; (189c0 <mem_manage_fault+0x13c>)
   18948:	f013 fe00 	bl	2c54c <z_log_minimal_printk>
			if (from_hard_fault != 0) {
   1894c:	2c00      	cmp	r4, #0
   1894e:	d0b2      	beq.n	188b6 <mem_manage_fault+0x32>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   18950:	4a17      	ldr	r2, [pc, #92]	; (189b0 <mem_manage_fault+0x12c>)
   18952:	6a93      	ldr	r3, [r2, #40]	; 0x28
   18954:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   18958:	6293      	str	r3, [r2, #40]	; 0x28
   1895a:	e7ac      	b.n	188b6 <mem_manage_fault+0x32>
		PR_FAULT_INFO("  Instruction Access Violation");
   1895c:	2145      	movs	r1, #69	; 0x45
   1895e:	4819      	ldr	r0, [pc, #100]	; (189c4 <mem_manage_fault+0x140>)
   18960:	f013 fdf4 	bl	2c54c <z_log_minimal_printk>
   18964:	e7ac      	b.n	188c0 <mem_manage_fault+0x3c>
		PR_FAULT_INFO(
   18966:	2145      	movs	r1, #69	; 0x45
   18968:	4817      	ldr	r0, [pc, #92]	; (189c8 <mem_manage_fault+0x144>)
   1896a:	f013 fdef 	bl	2c54c <z_log_minimal_printk>
   1896e:	e7ac      	b.n	188ca <mem_manage_fault+0x46>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
   18970:	4629      	mov	r1, r5
   18972:	4638      	mov	r0, r7
   18974:	f7ff fe1e 	bl	185b4 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
   18978:	4607      	mov	r7, r0
   1897a:	b990      	cbnz	r0, 189a2 <mem_manage_fault+0x11e>
				__ASSERT(!(SCB->CFSR & SCB_CFSR_MSTKERR_Msk),
   1897c:	4b0c      	ldr	r3, [pc, #48]	; (189b0 <mem_manage_fault+0x12c>)
   1897e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   18980:	f014 0410 	ands.w	r4, r4, #16
   18984:	d0b0      	beq.n	188e8 <mem_manage_fault+0x64>
   18986:	4c11      	ldr	r4, [pc, #68]	; (189cc <mem_manage_fault+0x148>)
   18988:	f240 1253 	movw	r2, #339	; 0x153
   1898c:	4621      	mov	r1, r4
   1898e:	4810      	ldr	r0, [pc, #64]	; (189d0 <mem_manage_fault+0x14c>)
   18990:	f013 fdcd 	bl	2c52e <assert_print>
   18994:	f240 1153 	movw	r1, #339	; 0x153
   18998:	4620      	mov	r0, r4
   1899a:	f013 fdc1 	bl	2c520 <assert_post_action>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   1899e:	463c      	mov	r4, r7
   189a0:	e7a2      	b.n	188e8 <mem_manage_fault+0x64>
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
   189a2:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
   189a6:	2402      	movs	r4, #2
   189a8:	e79e      	b.n	188e8 <mem_manage_fault+0x64>
   189aa:	bf00      	nop
   189ac:	0003969c 	.word	0x0003969c
   189b0:	e000ed00 	.word	0xe000ed00
   189b4:	000396b8 	.word	0x000396b8
   189b8:	00039464 	.word	0x00039464
   189bc:	000396f0 	.word	0x000396f0
   189c0:	00039710 	.word	0x00039710
   189c4:	0003972c 	.word	0x0003972c
   189c8:	000394f8 	.word	0x000394f8
   189cc:	00039750 	.word	0x00039750
   189d0:	00031600 	.word	0x00031600

000189d4 <hard_fault>:
{
   189d4:	b570      	push	{r4, r5, r6, lr}
   189d6:	4606      	mov	r6, r0
   189d8:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** HARD FAULT *****");
   189da:	2145      	movs	r1, #69	; 0x45
   189dc:	4836      	ldr	r0, [pc, #216]	; (18ab8 <hard_fault+0xe4>)
   189de:	f013 fdb5 	bl	2c54c <z_log_minimal_printk>
	*recoverable = false;
   189e2:	2300      	movs	r3, #0
   189e4:	702b      	strb	r3, [r5, #0]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   189e6:	4b35      	ldr	r3, [pc, #212]	; (18abc <hard_fault+0xe8>)
   189e8:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   189ea:	f014 0402 	ands.w	r4, r4, #2
   189ee:	d127      	bne.n	18a40 <hard_fault+0x6c>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   189f0:	4b32      	ldr	r3, [pc, #200]	; (18abc <hard_fault+0xe8>)
   189f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   189f4:	2b00      	cmp	r3, #0
   189f6:	db2a      	blt.n	18a4e <hard_fault+0x7a>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   189f8:	4b30      	ldr	r3, [pc, #192]	; (18abc <hard_fault+0xe8>)
   189fa:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   189fc:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
   18a00:	d04c      	beq.n	18a9c <hard_fault+0xc8>
		PR_EXC("  Fault escalation (see below)");
   18a02:	2145      	movs	r1, #69	; 0x45
   18a04:	482e      	ldr	r0, [pc, #184]	; (18ac0 <hard_fault+0xec>)
   18a06:	f013 fda1 	bl	2c54c <z_log_minimal_printk>
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
   18a0a:	69b3      	ldr	r3, [r6, #24]
	uint16_t fault_insn = *(ret_addr - 1);
   18a0c:	f833 2c02 	ldrh.w	r2, [r3, #-2]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   18a10:	f64d 7302 	movw	r3, #57090	; 0xdf02
   18a14:	429a      	cmp	r2, r3
   18a16:	d01f      	beq.n	18a58 <hard_fault+0x84>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
   18a18:	4b28      	ldr	r3, [pc, #160]	; (18abc <hard_fault+0xe8>)
   18a1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   18a1c:	f013 0fff 	tst.w	r3, #255	; 0xff
   18a20:	d121      	bne.n	18a66 <hard_fault+0x92>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
   18a22:	4b26      	ldr	r3, [pc, #152]	; (18abc <hard_fault+0xe8>)
   18a24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   18a26:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
   18a2a:	d123      	bne.n	18a74 <hard_fault+0xa0>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
   18a2c:	4b23      	ldr	r3, [pc, #140]	; (18abc <hard_fault+0xe8>)
   18a2e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   18a30:	0c24      	lsrs	r4, r4, #16
   18a32:	0424      	lsls	r4, r4, #16
   18a34:	b32c      	cbz	r4, 18a82 <hard_fault+0xae>
			reason = usage_fault(esf);
   18a36:	4630      	mov	r0, r6
   18a38:	f7ff feac 	bl	18794 <usage_fault>
   18a3c:	4604      	mov	r4, r0
   18a3e:	e004      	b.n	18a4a <hard_fault+0x76>
		PR_EXC("  Bus fault on vector table read");
   18a40:	2145      	movs	r1, #69	; 0x45
   18a42:	4820      	ldr	r0, [pc, #128]	; (18ac4 <hard_fault+0xf0>)
   18a44:	f013 fd82 	bl	2c54c <z_log_minimal_printk>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   18a48:	2400      	movs	r4, #0
}
   18a4a:	4620      	mov	r0, r4
   18a4c:	bd70      	pop	{r4, r5, r6, pc}
		PR_EXC("  Debug event");
   18a4e:	2145      	movs	r1, #69	; 0x45
   18a50:	481d      	ldr	r0, [pc, #116]	; (18ac8 <hard_fault+0xf4>)
   18a52:	f013 fd7b 	bl	2c54c <z_log_minimal_printk>
   18a56:	e7f8      	b.n	18a4a <hard_fault+0x76>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
   18a58:	6832      	ldr	r2, [r6, #0]
   18a5a:	2145      	movs	r1, #69	; 0x45
   18a5c:	481b      	ldr	r0, [pc, #108]	; (18acc <hard_fault+0xf8>)
   18a5e:	f013 fd75 	bl	2c54c <z_log_minimal_printk>
			reason = esf->basic.r0;
   18a62:	6834      	ldr	r4, [r6, #0]
   18a64:	e7f1      	b.n	18a4a <hard_fault+0x76>
			reason = mem_manage_fault(esf, 1, recoverable);
   18a66:	462a      	mov	r2, r5
   18a68:	2101      	movs	r1, #1
   18a6a:	4630      	mov	r0, r6
   18a6c:	f7ff ff0a 	bl	18884 <mem_manage_fault>
   18a70:	4604      	mov	r4, r0
   18a72:	e7ea      	b.n	18a4a <hard_fault+0x76>
			reason = bus_fault(esf, 1, recoverable);
   18a74:	462a      	mov	r2, r5
   18a76:	2101      	movs	r1, #1
   18a78:	4630      	mov	r0, r6
   18a7a:	f7ff fe17 	bl	186ac <bus_fault>
   18a7e:	4604      	mov	r4, r0
   18a80:	e7e3      	b.n	18a4a <hard_fault+0x76>
			__ASSERT(0,
   18a82:	4d13      	ldr	r5, [pc, #76]	; (18ad0 <hard_fault+0xfc>)
   18a84:	f240 22d7 	movw	r2, #727	; 0x2d7
   18a88:	4629      	mov	r1, r5
   18a8a:	4812      	ldr	r0, [pc, #72]	; (18ad4 <hard_fault+0x100>)
   18a8c:	f013 fd4f 	bl	2c52e <assert_print>
   18a90:	f240 21d7 	movw	r1, #727	; 0x2d7
   18a94:	4628      	mov	r0, r5
   18a96:	f013 fd43 	bl	2c520 <assert_post_action>
   18a9a:	e7d6      	b.n	18a4a <hard_fault+0x76>
		__ASSERT(0,
   18a9c:	4d0c      	ldr	r5, [pc, #48]	; (18ad0 <hard_fault+0xfc>)
   18a9e:	f240 22db 	movw	r2, #731	; 0x2db
   18aa2:	4629      	mov	r1, r5
   18aa4:	480b      	ldr	r0, [pc, #44]	; (18ad4 <hard_fault+0x100>)
   18aa6:	f013 fd42 	bl	2c52e <assert_print>
   18aaa:	f240 21db 	movw	r1, #731	; 0x2db
   18aae:	4628      	mov	r0, r5
   18ab0:	f013 fd36 	bl	2c520 <assert_post_action>
	return reason;
   18ab4:	e7c9      	b.n	18a4a <hard_fault+0x76>
   18ab6:	bf00      	nop
   18ab8:	0003978c 	.word	0x0003978c
   18abc:	e000ed00 	.word	0xe000ed00
   18ac0:	000397e4 	.word	0x000397e4
   18ac4:	000397a8 	.word	0x000397a8
   18ac8:	000397d0 	.word	0x000397d0
   18acc:	00039808 	.word	0x00039808
   18ad0:	00039750 	.word	0x00039750
   18ad4:	00031600 	.word	0x00031600

00018ad8 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   18ad8:	b5f0      	push	{r4, r5, r6, r7, lr}
   18ada:	b09d      	sub	sp, #116	; 0x74
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   18adc:	4b2c      	ldr	r3, [pc, #176]	; (18b90 <z_arm_fault+0xb8>)
   18ade:	685d      	ldr	r5, [r3, #4]
   18ae0:	f3c5 0508 	ubfx	r5, r5, #0, #9
   18ae4:	2300      	movs	r3, #0
   18ae6:	f383 8811 	msr	BASEPRI, r3
   18aea:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   18aee:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   18af2:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   18af6:	d11f      	bne.n	18b38 <z_arm_fault+0x60>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
   18af8:	f002 030c 	and.w	r3, r2, #12
   18afc:	2b08      	cmp	r3, #8
   18afe:	d011      	beq.n	18b24 <z_arm_fault+0x4c>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   18b00:	f012 0f08 	tst.w	r2, #8
   18b04:	d015      	beq.n	18b32 <z_arm_fault+0x5a>
			ptr_esf =  (z_arch_esf_t *)psp;
   18b06:	460c      	mov	r4, r1
	*nested_exc = false;
   18b08:	2600      	movs	r6, #0

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
   18b0a:	b1c4      	cbz	r4, 18b3e <z_arm_fault+0x66>

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
   18b0c:	f10d 026f 	add.w	r2, sp, #111	; 0x6f
   18b10:	4629      	mov	r1, r5
   18b12:	4620      	mov	r0, r4
   18b14:	f013 feab 	bl	2c86e <fault_handle>
   18b18:	4605      	mov	r5, r0
	if (recoverable) {
   18b1a:	f89d 306f 	ldrb.w	r3, [sp, #111]	; 0x6f
   18b1e:	b1db      	cbz	r3, 18b58 <z_arm_fault+0x80>
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
	}

	z_arm_fatal_error(reason, &esf_copy);
}
   18b20:	b01d      	add	sp, #116	; 0x74
   18b22:	bdf0      	pop	{r4, r5, r6, r7, pc}
		PR_EXC("SPSEL in thread mode does not indicate PSP");
   18b24:	2145      	movs	r1, #69	; 0x45
   18b26:	481b      	ldr	r0, [pc, #108]	; (18b94 <z_arm_fault+0xbc>)
   18b28:	f013 fd10 	bl	2c54c <z_log_minimal_printk>
	*nested_exc = false;
   18b2c:	2600      	movs	r6, #0
		return NULL;
   18b2e:	4634      	mov	r4, r6
   18b30:	e7eb      	b.n	18b0a <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
   18b32:	4604      	mov	r4, r0
			*nested_exc = true;
   18b34:	2601      	movs	r6, #1
   18b36:	e7e8      	b.n	18b0a <z_arm_fault+0x32>
	*nested_exc = false;
   18b38:	2600      	movs	r6, #0
		return NULL;
   18b3a:	4634      	mov	r4, r6
   18b3c:	e7e5      	b.n	18b0a <z_arm_fault+0x32>
	__ASSERT(esf != NULL,
   18b3e:	4f16      	ldr	r7, [pc, #88]	; (18b98 <z_arm_fault+0xc0>)
   18b40:	f240 4205 	movw	r2, #1029	; 0x405
   18b44:	4639      	mov	r1, r7
   18b46:	4815      	ldr	r0, [pc, #84]	; (18b9c <z_arm_fault+0xc4>)
   18b48:	f013 fcf1 	bl	2c52e <assert_print>
   18b4c:	f240 4105 	movw	r1, #1029	; 0x405
   18b50:	4638      	mov	r0, r7
   18b52:	f013 fce5 	bl	2c520 <assert_post_action>
   18b56:	e7d9      	b.n	18b0c <z_arm_fault+0x34>
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   18b58:	2268      	movs	r2, #104	; 0x68
   18b5a:	4621      	mov	r1, r4
   18b5c:	a801      	add	r0, sp, #4
   18b5e:	f018 f982 	bl	30e66 <memcpy>
	if (nested_exc) {
   18b62:	b14e      	cbz	r6, 18b78 <z_arm_fault+0xa0>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   18b64:	9b08      	ldr	r3, [sp, #32]
   18b66:	f3c3 0208 	ubfx	r2, r3, #0, #9
   18b6a:	b95a      	cbnz	r2, 18b84 <z_arm_fault+0xac>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   18b6c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   18b70:	ea6f 2343 	mvn.w	r3, r3, lsl #9
   18b74:	9308      	str	r3, [sp, #32]
   18b76:	e005      	b.n	18b84 <z_arm_fault+0xac>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   18b78:	9b08      	ldr	r3, [sp, #32]
   18b7a:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   18b7e:	f023 0301 	bic.w	r3, r3, #1
   18b82:	9308      	str	r3, [sp, #32]
	z_arm_fatal_error(reason, &esf_copy);
   18b84:	a901      	add	r1, sp, #4
   18b86:	4628      	mov	r0, r5
   18b88:	f013 fe43 	bl	2c812 <z_arm_fatal_error>
   18b8c:	e7c8      	b.n	18b20 <z_arm_fault+0x48>
   18b8e:	bf00      	nop
   18b90:	e000ed00 	.word	0xe000ed00
   18b94:	0003982c 	.word	0x0003982c
   18b98:	00039750 	.word	0x00039750
   18b9c:	00031600 	.word	0x00031600

00018ba0 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   18ba0:	4a02      	ldr	r2, [pc, #8]	; (18bac <z_arm_fault_init+0xc>)
   18ba2:	6953      	ldr	r3, [r2, #20]
   18ba4:	f043 0310 	orr.w	r3, r3, #16
   18ba8:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
   18baa:	4770      	bx	lr
   18bac:	e000ed00 	.word	0xe000ed00

00018bb0 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   18bb0:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   18bb4:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   18bb8:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   18bba:	4672      	mov	r2, lr
	bl z_arm_fault
   18bbc:	f7ff ff8c 	bl	18ad8 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   18bc0:	bd01      	pop	{r0, pc}
   18bc2:	bf00      	nop

00018bc4 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   18bc4:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   18bc6:	e006      	b.n	18bd6 <z_arm_interrupt_init+0x12>
   18bc8:	f002 010f 	and.w	r1, r2, #15
   18bcc:	4b09      	ldr	r3, [pc, #36]	; (18bf4 <z_arm_interrupt_init+0x30>)
   18bce:	440b      	add	r3, r1
   18bd0:	2140      	movs	r1, #64	; 0x40
   18bd2:	7619      	strb	r1, [r3, #24]
   18bd4:	3201      	adds	r2, #1
   18bd6:	2a26      	cmp	r2, #38	; 0x26
   18bd8:	dc0a      	bgt.n	18bf0 <z_arm_interrupt_init+0x2c>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
   18bda:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
   18bdc:	2b00      	cmp	r3, #0
   18bde:	dbf3      	blt.n	18bc8 <z_arm_interrupt_init+0x4>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   18be0:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   18be4:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   18be8:	2140      	movs	r1, #64	; 0x40
   18bea:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
   18bee:	e7f1      	b.n	18bd4 <z_arm_interrupt_init+0x10>
	}
}
   18bf0:	4770      	bx	lr
   18bf2:	bf00      	nop
   18bf4:	e000ecfc 	.word	0xe000ecfc

00018bf8 <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   18bf8:	2000      	movs	r0, #0
    msr CONTROL, r0
   18bfa:	f380 8814 	msr	CONTROL, r0
    isb
   18bfe:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   18c02:	f7fe fb95 	bl	17330 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   18c06:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   18c08:	490d      	ldr	r1, [pc, #52]	; (18c40 <__start+0x48>)
    str r0, [r1]
   18c0a:	6008      	str	r0, [r1, #0]
    dsb
   18c0c:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   18c10:	480c      	ldr	r0, [pc, #48]	; (18c44 <__start+0x4c>)
    msr msp, r0
   18c12:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   18c16:	f000 f82d 	bl	18c74 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   18c1a:	2040      	movs	r0, #64	; 0x40
    msr BASEPRI, r0
   18c1c:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   18c20:	4809      	ldr	r0, [pc, #36]	; (18c48 <__start+0x50>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   18c22:	f44f 6104 	mov.w	r1, #2112	; 0x840
    adds r0, r0, r1
   18c26:	1840      	adds	r0, r0, r1
    msr PSP, r0
   18c28:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   18c2c:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   18c30:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   18c32:	4308      	orrs	r0, r1
    msr CONTROL, r0
   18c34:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   18c38:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   18c3c:	f7ff fb9e 	bl	1837c <z_arm_prep_c>
    ldr r1, =_SCS_MPU_CTRL
   18c40:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   18c44:	20006980 	.word	0x20006980
    ldr r0, =z_interrupt_stacks
   18c48:	20006b80 	.word	0x20006b80

00018c4c <z_arm_clear_arm_mpu_config>:
void z_arm_clear_arm_mpu_config(void)
{
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   18c4c:	4b08      	ldr	r3, [pc, #32]	; (18c70 <z_arm_clear_arm_mpu_config+0x24>)
   18c4e:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
	int num_regions =
   18c52:	f3c0 2007 	ubfx	r0, r0, #8, #8

	for (i = 0; i < num_regions; i++) {
   18c56:	2300      	movs	r3, #0
   18c58:	e006      	b.n	18c68 <z_arm_clear_arm_mpu_config+0x1c>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
   18c5a:	4a05      	ldr	r2, [pc, #20]	; (18c70 <z_arm_clear_arm_mpu_config+0x24>)
   18c5c:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
  MPU->RASR = 0U;
   18c60:	2100      	movs	r1, #0
   18c62:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
   18c66:	3301      	adds	r3, #1
   18c68:	4283      	cmp	r3, r0
   18c6a:	dbf6      	blt.n	18c5a <z_arm_clear_arm_mpu_config+0xe>
		ARM_MPU_ClrRegion(i);
	}
}
   18c6c:	4770      	bx	lr
   18c6e:	bf00      	nop
   18c70:	e000ed00 	.word	0xe000ed00

00018c74 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
   18c74:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   18c76:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   18c78:	2400      	movs	r4, #0
   18c7a:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   18c7e:	f7ff ffe5 	bl	18c4c <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   18c82:	4623      	mov	r3, r4
   18c84:	e008      	b.n	18c98 <z_arm_init_arch_hw_at_boot+0x24>
		NVIC->ICER[i] = 0xFFFFFFFF;
   18c86:	f103 0120 	add.w	r1, r3, #32
   18c8a:	4a0e      	ldr	r2, [pc, #56]	; (18cc4 <z_arm_init_arch_hw_at_boot+0x50>)
   18c8c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   18c90:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   18c94:	3301      	adds	r3, #1
   18c96:	b2db      	uxtb	r3, r3
   18c98:	2b07      	cmp	r3, #7
   18c9a:	d9f4      	bls.n	18c86 <z_arm_init_arch_hw_at_boot+0x12>
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   18c9c:	2300      	movs	r3, #0
   18c9e:	e008      	b.n	18cb2 <z_arm_init_arch_hw_at_boot+0x3e>
		NVIC->ICPR[i] = 0xFFFFFFFF;
   18ca0:	f103 0160 	add.w	r1, r3, #96	; 0x60
   18ca4:	4a07      	ldr	r2, [pc, #28]	; (18cc4 <z_arm_init_arch_hw_at_boot+0x50>)
   18ca6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   18caa:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   18cae:	3301      	adds	r3, #1
   18cb0:	b2db      	uxtb	r3, r3
   18cb2:	2b07      	cmp	r3, #7
   18cb4:	d9f4      	bls.n	18ca0 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   18cb6:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   18cb8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   18cbc:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   18cc0:	bd10      	pop	{r4, pc}
   18cc2:	bf00      	nop
   18cc4:	e000e100 	.word	0xe000e100

00018cc8 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
   18cc8:	b508      	push	{r3, lr}
	if (_current == thread) {
   18cca:	4b0a      	ldr	r3, [pc, #40]	; (18cf4 <z_impl_k_thread_abort+0x2c>)
   18ccc:	689b      	ldr	r3, [r3, #8]
   18cce:	4283      	cmp	r3, r0
   18cd0:	d002      	beq.n	18cd8 <z_impl_k_thread_abort+0x10>
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
		}
	}

	z_thread_abort(thread);
   18cd2:	f010 f88d 	bl	28df0 <z_thread_abort>
}
   18cd6:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   18cd8:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   18cdc:	2b00      	cmp	r3, #0
   18cde:	d0f8      	beq.n	18cd2 <z_impl_k_thread_abort+0xa>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   18ce0:	4b05      	ldr	r3, [pc, #20]	; (18cf8 <z_impl_k_thread_abort+0x30>)
   18ce2:	685a      	ldr	r2, [r3, #4]
   18ce4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   18ce8:	605a      	str	r2, [r3, #4]
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
   18cea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   18cec:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   18cf0:	625a      	str	r2, [r3, #36]	; 0x24
   18cf2:	e7ee      	b.n	18cd2 <z_impl_k_thread_abort+0xa>
   18cf4:	200046a4 	.word	0x200046a4
   18cf8:	e000ed00 	.word	0xe000ed00

00018cfc <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   18cfc:	b508      	push	{r3, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   18cfe:	4b03      	ldr	r3, [pc, #12]	; (18d0c <z_arm_configure_static_mpu_regions+0x10>)
   18d00:	4a03      	ldr	r2, [pc, #12]	; (18d10 <z_arm_configure_static_mpu_regions+0x14>)
   18d02:	2101      	movs	r1, #1
   18d04:	4803      	ldr	r0, [pc, #12]	; (18d14 <z_arm_configure_static_mpu_regions+0x18>)
   18d06:	f000 f8ab 	bl	18e60 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   18d0a:	bd08      	pop	{r3, pc}
   18d0c:	20010000 	.word	0x20010000
   18d10:	20000000 	.word	0x20000000
   18d14:	00039860 	.word	0x00039860

00018d18 <z_arm_configure_dynamic_mpu_regions>:
 *
 * This function is not inherently thread-safe, but the memory domain
 * spinlock needs to be held anyway.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   18d18:	b510      	push	{r4, lr}
   18d1a:	4604      	mov	r4, r0
	/* Privileged stack guard */
	uintptr_t guard_start;
	size_t guard_size = MPU_GUARD_ALIGN_AND_SIZE;

#if defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)
	guard_size = z_arm_mpu_stack_guard_and_fpu_adjust(thread);
   18d1c:	f7ff fc0c 	bl	18538 <z_arm_mpu_stack_guard_and_fpu_adjust>
   18d20:	4603      	mov	r3, r0
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
   18d22:	6f62      	ldr	r2, [r4, #116]	; 0x74
   18d24:	1a12      	subs	r2, r2, r0
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
   18d26:	4804      	ldr	r0, [pc, #16]	; (18d38 <z_arm_configure_dynamic_mpu_regions+0x20>)
   18d28:	6002      	str	r2, [r0, #0]
	dynamic_regions[region_num].size = guard_size;
   18d2a:	6043      	str	r3, [r0, #4]
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
   18d2c:	4b03      	ldr	r3, [pc, #12]	; (18d3c <z_arm_configure_dynamic_mpu_regions+0x24>)
   18d2e:	6083      	str	r3, [r0, #8]

	/* Configure the dynamic MPU regions */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
   18d30:	2101      	movs	r1, #1
   18d32:	f000 f8ad 	bl	18e90 <arm_core_mpu_configure_dynamic_mpu_regions>
						   region_num);
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_enable();
#endif
}
   18d36:	bd10      	pop	{r4, pc}
   18d38:	200039fc 	.word	0x200039fc
   18d3c:	150b0000 	.word	0x150b0000

00018d40 <region_init>:
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
   18d40:	4a08      	ldr	r2, [pc, #32]	; (18d64 <region_init+0x24>)
   18d42:	f8c2 0098 	str.w	r0, [r2, #152]	; 0x98

	set_region_base_address(region_conf->base & MPU_RBAR_ADDR_Msk);
	set_region_attributes(region_conf->attr.rasr);
	set_region_size(region_conf->size | MPU_RASR_ENABLE_Msk);
#else
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   18d46:	680b      	ldr	r3, [r1, #0]
   18d48:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
   18d4c:	4303      	orrs	r3, r0
   18d4e:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   18d52:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
   18d56:	688b      	ldr	r3, [r1, #8]
   18d58:	f043 0301 	orr.w	r3, r3, #1
   18d5c:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	LOG_DBG("[%d] 0x%08x 0x%08x",
		index, region_conf->base, region_conf->attr.rasr);
#endif
}
   18d60:	4770      	bx	lr
   18d62:	bf00      	nop
   18d64:	e000ed00 	.word	0xe000ed00

00018d68 <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
   18d68:	b510      	push	{r4, lr}
   18d6a:	4604      	mov	r4, r0
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   18d6c:	2807      	cmp	r0, #7
   18d6e:	d803      	bhi.n	18d78 <region_allocate_and_init+0x10>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
   18d70:	f7ff ffe6 	bl	18d40 <region_init>

	return index;
   18d74:	4620      	mov	r0, r4
}
   18d76:	bd10      	pop	{r4, pc}
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   18d78:	4602      	mov	r2, r0
   18d7a:	2145      	movs	r1, #69	; 0x45
   18d7c:	4802      	ldr	r0, [pc, #8]	; (18d88 <region_allocate_and_init+0x20>)
   18d7e:	f013 fbe5 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   18d82:	f06f 0015 	mvn.w	r0, #21
   18d86:	e7f6      	b.n	18d76 <region_allocate_and_init+0xe>
   18d88:	0003986c 	.word	0x0003986c

00018d8c <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
   18d8c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   18d90:	4680      	mov	r8, r0
   18d92:	460f      	mov	r7, r1
   18d94:	4699      	mov	r9, r3
	int i;
	int reg_index = start_reg_index;
   18d96:	4616      	mov	r6, r2

	for (i = 0; i < regions_num; i++) {
   18d98:	2500      	movs	r5, #0
   18d9a:	e009      	b.n	18db0 <mpu_configure_regions+0x24>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
   18d9c:	4621      	mov	r1, r4
   18d9e:	b2f0      	uxtb	r0, r6
   18da0:	f013 fd9b 	bl	2c8da <mpu_configure_region>
   18da4:	4606      	mov	r6, r0

		if (reg_index == -EINVAL) {
   18da6:	f110 0f16 	cmn.w	r0, #22
   18daa:	d019      	beq.n	18de0 <mpu_configure_regions+0x54>
			return reg_index;
		}

		/* Increment number of programmed MPU indices. */
		reg_index++;
   18dac:	3601      	adds	r6, #1
	for (i = 0; i < regions_num; i++) {
   18dae:	3501      	adds	r5, #1
   18db0:	42bd      	cmp	r5, r7
   18db2:	da15      	bge.n	18de0 <mpu_configure_regions+0x54>
		if (regions[i].size == 0U) {
   18db4:	eb05 0445 	add.w	r4, r5, r5, lsl #1
   18db8:	eb08 0484 	add.w	r4, r8, r4, lsl #2
   18dbc:	6862      	ldr	r2, [r4, #4]
   18dbe:	2a00      	cmp	r2, #0
   18dc0:	d0f5      	beq.n	18dae <mpu_configure_regions+0x22>
		if (do_sanity_check &&
   18dc2:	f1b9 0f00 	cmp.w	r9, #0
   18dc6:	d0e9      	beq.n	18d9c <mpu_configure_regions+0x10>
				(!mpu_partition_is_valid(&regions[i]))) {
   18dc8:	4620      	mov	r0, r4
   18dca:	f013 fd75 	bl	2c8b8 <mpu_partition_is_valid>
		if (do_sanity_check &&
   18dce:	2800      	cmp	r0, #0
   18dd0:	d1e4      	bne.n	18d9c <mpu_configure_regions+0x10>
			LOG_ERR("Partition %u: sanity check failed.", i);
   18dd2:	462a      	mov	r2, r5
   18dd4:	2145      	movs	r1, #69	; 0x45
   18dd6:	4804      	ldr	r0, [pc, #16]	; (18de8 <mpu_configure_regions+0x5c>)
   18dd8:	f013 fbb8 	bl	2c54c <z_log_minimal_printk>
			return -EINVAL;
   18ddc:	f06f 0615 	mvn.w	r6, #21
	}

	return reg_index;
}
   18de0:	4630      	mov	r0, r6
   18de2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   18de6:	bf00      	nop
   18de8:	00039898 	.word	0x00039898

00018dec <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
   18dec:	b510      	push	{r4, lr}
	int mpu_reg_index = static_regions_num;
   18dee:	4c03      	ldr	r4, [pc, #12]	; (18dfc <mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
   18df0:	2301      	movs	r3, #1
   18df2:	7822      	ldrb	r2, [r4, #0]
   18df4:	f7ff ffca 	bl	18d8c <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   18df8:	7020      	strb	r0, [r4, #0]

	return mpu_reg_index;
}
   18dfa:	bd10      	pop	{r4, pc}
   18dfc:	2000470e 	.word	0x2000470e

00018e00 <mpu_configure_dynamic_mpu_regions>:
 * If the dynamic MPU regions configuration has not been successfully
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
   18e00:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
   18e02:	2300      	movs	r3, #0
   18e04:	4a09      	ldr	r2, [pc, #36]	; (18e2c <mpu_configure_dynamic_mpu_regions+0x2c>)
   18e06:	7812      	ldrb	r2, [r2, #0]
   18e08:	f7ff ffc0 	bl	18d8c <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
   18e0c:	f110 0f16 	cmn.w	r0, #22
   18e10:	d00a      	beq.n	18e28 <mpu_configure_dynamic_mpu_regions+0x28>

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   18e12:	4603      	mov	r3, r0
   18e14:	e006      	b.n	18e24 <mpu_configure_dynamic_mpu_regions+0x24>
  MPU->RNR = rnr;
   18e16:	4a06      	ldr	r2, [pc, #24]	; (18e30 <mpu_configure_dynamic_mpu_regions+0x30>)
   18e18:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
  MPU->RASR = 0U;
   18e1c:	2100      	movs	r1, #0
   18e1e:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
   18e22:	3301      	adds	r3, #1
   18e24:	2b07      	cmp	r3, #7
   18e26:	ddf6      	ble.n	18e16 <mpu_configure_dynamic_mpu_regions+0x16>
			ARM_MPU_ClrRegion(i);
		}
	}

	return mpu_reg_index;
}
   18e28:	bd08      	pop	{r3, pc}
   18e2a:	bf00      	nop
   18e2c:	2000470e 	.word	0x2000470e
   18e30:	e000ed00 	.word	0xe000ed00

00018e34 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   18e34:	4b04      	ldr	r3, [pc, #16]	; (18e48 <arm_core_mpu_enable+0x14>)
   18e36:	2205      	movs	r2, #5
   18e38:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
   18e3c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   18e40:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   18e44:	4770      	bx	lr
   18e46:	bf00      	nop
   18e48:	e000ed00 	.word	0xe000ed00

00018e4c <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   18e4c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   18e50:	4b02      	ldr	r3, [pc, #8]	; (18e5c <arm_core_mpu_disable+0x10>)
   18e52:	2200      	movs	r2, #0
   18e54:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
   18e58:	4770      	bx	lr
   18e5a:	bf00      	nop
   18e5c:	e000ed00 	.word	0xe000ed00

00018e60 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   18e60:	b510      	push	{r4, lr}
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
   18e62:	f7ff ffc3 	bl	18dec <mpu_configure_static_mpu_regions>
   18e66:	f110 0f16 	cmn.w	r0, #22
   18e6a:	d000      	beq.n	18e6e <arm_core_mpu_configure_static_mpu_regions+0xe>
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   18e6c:	bd10      	pop	{r4, pc}
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   18e6e:	4c06      	ldr	r4, [pc, #24]	; (18e88 <arm_core_mpu_configure_static_mpu_regions+0x28>)
   18e70:	f44f 728b 	mov.w	r2, #278	; 0x116
   18e74:	4621      	mov	r1, r4
   18e76:	4805      	ldr	r0, [pc, #20]	; (18e8c <arm_core_mpu_configure_static_mpu_regions+0x2c>)
   18e78:	f013 fb59 	bl	2c52e <assert_print>
   18e7c:	f44f 718b 	mov.w	r1, #278	; 0x116
   18e80:	4620      	mov	r0, r4
   18e82:	f013 fb4d 	bl	2c520 <assert_post_action>
}
   18e86:	e7f1      	b.n	18e6c <arm_core_mpu_configure_static_mpu_regions+0xc>
   18e88:	000398c0 	.word	0x000398c0
   18e8c:	00031600 	.word	0x00031600

00018e90 <arm_core_mpu_configure_dynamic_mpu_regions>:
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
   18e90:	b510      	push	{r4, lr}
	if (mpu_configure_dynamic_mpu_regions(dynamic_regions, regions_num)
   18e92:	f7ff ffb5 	bl	18e00 <mpu_configure_dynamic_mpu_regions>
   18e96:	f110 0f16 	cmn.w	r0, #22
   18e9a:	d000      	beq.n	18e9e <arm_core_mpu_configure_dynamic_mpu_regions+0xe>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
   18e9c:	bd10      	pop	{r4, pc}
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   18e9e:	4c06      	ldr	r4, [pc, #24]	; (18eb8 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
   18ea0:	f240 1235 	movw	r2, #309	; 0x135
   18ea4:	4621      	mov	r1, r4
   18ea6:	4805      	ldr	r0, [pc, #20]	; (18ebc <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)
   18ea8:	f013 fb41 	bl	2c52e <assert_print>
   18eac:	f240 1135 	movw	r1, #309	; 0x135
   18eb0:	4620      	mov	r0, r4
   18eb2:	f013 fb35 	bl	2c520 <assert_post_action>
}
   18eb6:	e7f1      	b.n	18e9c <arm_core_mpu_configure_dynamic_mpu_regions+0xc>
   18eb8:	000398c0 	.word	0x000398c0
   18ebc:	00031600 	.word	0x00031600

00018ec0 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   18ec0:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   18ec2:	4b1f      	ldr	r3, [pc, #124]	; (18f40 <z_arm_mpu_init+0x80>)
   18ec4:	681d      	ldr	r5, [r3, #0]
   18ec6:	2d08      	cmp	r5, #8
   18ec8:	d803      	bhi.n	18ed2 <z_arm_mpu_init+0x12>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   18eca:	f7ff ffbf 	bl	18e4c <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   18ece:	2400      	movs	r4, #0
   18ed0:	e018      	b.n	18f04 <z_arm_mpu_init+0x44>
		__ASSERT(0,
   18ed2:	4c1c      	ldr	r4, [pc, #112]	; (18f44 <z_arm_mpu_init+0x84>)
   18ed4:	f240 124d 	movw	r2, #333	; 0x14d
   18ed8:	4621      	mov	r1, r4
   18eda:	481b      	ldr	r0, [pc, #108]	; (18f48 <z_arm_mpu_init+0x88>)
   18edc:	f013 fb27 	bl	2c52e <assert_print>
   18ee0:	f240 114d 	movw	r1, #333	; 0x14d
   18ee4:	4620      	mov	r0, r4
   18ee6:	f013 fb1b 	bl	2c520 <assert_post_action>
		return -1;
   18eea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   18eee:	e017      	b.n	18f20 <z_arm_mpu_init+0x60>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   18ef0:	4b13      	ldr	r3, [pc, #76]	; (18f40 <z_arm_mpu_init+0x80>)
   18ef2:	6859      	ldr	r1, [r3, #4]
   18ef4:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   18ef8:	0093      	lsls	r3, r2, #2
   18efa:	4419      	add	r1, r3
   18efc:	4620      	mov	r0, r4
   18efe:	f7ff ff1f 	bl	18d40 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   18f02:	3401      	adds	r4, #1
   18f04:	42a5      	cmp	r5, r4
   18f06:	d8f3      	bhi.n	18ef0 <z_arm_mpu_init+0x30>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   18f08:	4b10      	ldr	r3, [pc, #64]	; (18f4c <z_arm_mpu_init+0x8c>)
   18f0a:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   18f0c:	f7ff ff92 	bl	18e34 <arm_core_mpu_enable>

	/* Sanity check for number of regions in Cortex-M0+, M3, and M4. */
#if defined(CONFIG_CPU_CORTEX_M0PLUS) || \
	defined(CONFIG_CPU_CORTEX_M3) || \
	defined(CONFIG_CPU_CORTEX_M4)
	__ASSERT(
   18f10:	4b0f      	ldr	r3, [pc, #60]	; (18f50 <z_arm_mpu_init+0x90>)
   18f12:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   18f16:	f3c3 2307 	ubfx	r3, r3, #8, #8
   18f1a:	2b08      	cmp	r3, #8
   18f1c:	d101      	bne.n	18f22 <z_arm_mpu_init+0x62>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   18f1e:	2000      	movs	r0, #0
}
   18f20:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT(
   18f22:	4c08      	ldr	r4, [pc, #32]	; (18f44 <z_arm_mpu_init+0x84>)
   18f24:	f240 12ad 	movw	r2, #429	; 0x1ad
   18f28:	4621      	mov	r1, r4
   18f2a:	4807      	ldr	r0, [pc, #28]	; (18f48 <z_arm_mpu_init+0x88>)
   18f2c:	f013 faff 	bl	2c52e <assert_print>
   18f30:	f240 11ad 	movw	r1, #429	; 0x1ad
   18f34:	4620      	mov	r0, r4
   18f36:	f013 faf3 	bl	2c520 <assert_post_action>
	return 0;
   18f3a:	2000      	movs	r0, #0
   18f3c:	e7f0      	b.n	18f20 <z_arm_mpu_init+0x60>
   18f3e:	bf00      	nop
   18f40:	00039958 	.word	0x00039958
   18f44:	000398c0 	.word	0x000398c0
   18f48:	00031600 	.word	0x00031600
   18f4c:	2000470e 	.word	0x2000470e
   18f50:	e000ed00 	.word	0xe000ed00

00018f54 <malloc_prepare>:

	/*
	 * Validate that the memory space available for the newlib heap is
	 * greater than the minimum required size.
	 */
	__ASSERT(MAX_HEAP_SIZE >= CONFIG_NEWLIB_LIBC_MIN_REQUIRED_HEAP_SIZE,
   18f54:	4b0b      	ldr	r3, [pc, #44]	; (18f84 <malloc_prepare+0x30>)
   18f56:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
   18f5a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   18f5e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
   18f62:	d301      	bcc.n	18f68 <malloc_prepare+0x14>
		 "memory space available for newlib heap is less than the "
		 "minimum required size specified by "
		 "CONFIG_NEWLIB_LIBC_MIN_REQUIRED_HEAP_SIZE");

	return 0;
}
   18f64:	2000      	movs	r0, #0
   18f66:	4770      	bx	lr
{
   18f68:	b510      	push	{r4, lr}
	__ASSERT(MAX_HEAP_SIZE >= CONFIG_NEWLIB_LIBC_MIN_REQUIRED_HEAP_SIZE,
   18f6a:	4c07      	ldr	r4, [pc, #28]	; (18f88 <malloc_prepare+0x34>)
   18f6c:	2281      	movs	r2, #129	; 0x81
   18f6e:	4621      	mov	r1, r4
   18f70:	4806      	ldr	r0, [pc, #24]	; (18f8c <malloc_prepare+0x38>)
   18f72:	f013 fadc 	bl	2c52e <assert_print>
   18f76:	2181      	movs	r1, #129	; 0x81
   18f78:	4620      	mov	r0, r4
   18f7a:	f013 fad1 	bl	2c520 <assert_post_action>
}
   18f7e:	2000      	movs	r0, #0
   18f80:	bd10      	pop	{r4, pc}
   18f82:	bf00      	nop
   18f84:	2000d270 	.word	0x2000d270
   18f88:	000398f8 	.word	0x000398f8
   18f8c:	00031600 	.word	0x00031600

00018f90 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   18f90:	4b01      	ldr	r3, [pc, #4]	; (18f98 <__stdout_hook_install+0x8>)
   18f92:	6018      	str	r0, [r3, #0]
}
   18f94:	4770      	bx	lr
   18f96:	bf00      	nop
   18f98:	20000afc 	.word	0x20000afc

00018f9c <z_impl_zephyr_write_stdout>:
}
#include <syscalls/zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
   18f9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18f9e:	4605      	mov	r5, r0
   18fa0:	460f      	mov	r7, r1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
   18fa2:	2400      	movs	r4, #0
   18fa4:	e004      	b.n	18fb0 <z_impl_zephyr_write_stdout+0x14>
		if (*(buf + i) == '\n') {
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
   18fa6:	4b09      	ldr	r3, [pc, #36]	; (18fcc <z_impl_zephyr_write_stdout+0x30>)
   18fa8:	681b      	ldr	r3, [r3, #0]
   18faa:	7830      	ldrb	r0, [r6, #0]
   18fac:	4798      	blx	r3
	for (i = 0; i < nbytes; i++) {
   18fae:	3401      	adds	r4, #1
   18fb0:	42bc      	cmp	r4, r7
   18fb2:	da08      	bge.n	18fc6 <z_impl_zephyr_write_stdout+0x2a>
		if (*(buf + i) == '\n') {
   18fb4:	192e      	adds	r6, r5, r4
   18fb6:	5d2b      	ldrb	r3, [r5, r4]
   18fb8:	2b0a      	cmp	r3, #10
   18fba:	d1f4      	bne.n	18fa6 <z_impl_zephyr_write_stdout+0xa>
			_stdout_hook('\r');
   18fbc:	4b03      	ldr	r3, [pc, #12]	; (18fcc <z_impl_zephyr_write_stdout+0x30>)
   18fbe:	681b      	ldr	r3, [r3, #0]
   18fc0:	200d      	movs	r0, #13
   18fc2:	4798      	blx	r3
   18fc4:	e7ef      	b.n	18fa6 <z_impl_zephyr_write_stdout+0xa>
	}
	return nbytes;
}
   18fc6:	4638      	mov	r0, r7
   18fc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18fca:	bf00      	nop
   18fcc:	20000afc 	.word	0x20000afc

00018fd0 <__chk_fail>:
/* This function gets called if static buffer overflow detection is enabled
 * on stdlib side (Newlib here), in case such an overflow is detected. Newlib
 * provides an implementation not suitable for us, so we override it here.
 */
__weak FUNC_NORETURN void __chk_fail(void)
{
   18fd0:	b508      	push	{r3, lr}
	static const char chk_fail_msg[] = "* buffer overflow detected *\n";
	_write(2, chk_fail_msg, sizeof(chk_fail_msg) - 1);
   18fd2:	221d      	movs	r2, #29
   18fd4:	4904      	ldr	r1, [pc, #16]	; (18fe8 <__chk_fail+0x18>)
   18fd6:	2002      	movs	r0, #2
   18fd8:	f013 fca1 	bl	2c91e <_write>
	k_oops();
   18fdc:	4040      	eors	r0, r0
   18fde:	f380 8811 	msr	BASEPRI, r0
   18fe2:	f04f 0003 	mov.w	r0, #3
   18fe6:	df02      	svc	2
	CODE_UNREACHABLE;
   18fe8:	00039928 	.word	0x00039928

00018fec <nordicsemi_nrf52_init>:
	__asm__ volatile(
   18fec:	f04f 0340 	mov.w	r3, #64	; 0x40
   18ff0:	f3ef 8211 	mrs	r2, BASEPRI
   18ff4:	f383 8812 	msr	BASEPRI_MAX, r3
   18ff8:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   18ffc:	2301      	movs	r3, #1
   18ffe:	4906      	ldr	r1, [pc, #24]	; (19018 <nordicsemi_nrf52_init+0x2c>)
   19000:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
   19004:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   19008:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
   1900c:	f382 8811 	msr	BASEPRI, r2
   19010:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   19014:	2000      	movs	r0, #0
   19016:	4770      	bx	lr
   19018:	4001e000 	.word	0x4001e000

0001901c <sys_arch_reboot>:
    *p_gpregret = val;
   1901c:	b2c0      	uxtb	r0, r0
   1901e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   19022:	f8c2 051c 	str.w	r0, [r2, #1308]	; 0x51c
  __ASM volatile ("dsb 0xF":::"memory");
   19026:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1902a:	4905      	ldr	r1, [pc, #20]	; (19040 <sys_arch_reboot+0x24>)
   1902c:	68ca      	ldr	r2, [r1, #12]
   1902e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   19032:	4b04      	ldr	r3, [pc, #16]	; (19044 <sys_arch_reboot+0x28>)
   19034:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   19036:	60cb      	str	r3, [r1, #12]
   19038:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1903c:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   1903e:	e7fd      	b.n	1903c <sys_arch_reboot+0x20>
   19040:	e000ed00 	.word	0xe000ed00
   19044:	05fa0004 	.word	0x05fa0004

00019048 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   19048:	b130      	cbz	r0, 19058 <arch_busy_wait+0x10>

void arch_busy_wait(uint32_t time_us)
{
   1904a:	b508      	push	{r3, lr}
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   1904c:	0180      	lsls	r0, r0, #6
   1904e:	4b03      	ldr	r3, [pc, #12]	; (1905c <arch_busy_wait+0x14>)
   19050:	f043 0301 	orr.w	r3, r3, #1
   19054:	4798      	blx	r3
	nrfx_coredep_delay_us(time_us);
}
   19056:	bd08      	pop	{r3, pc}
   19058:	4770      	bx	lr
   1905a:	bf00      	nop
   1905c:	00031460 	.word	0x00031460

00019060 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const uint8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
   19060:	2940      	cmp	r1, #64	; 0x40
   19062:	bf28      	it	cs
   19064:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
   19066:	2300      	movs	r3, #0
   19068:	428b      	cmp	r3, r1
   1906a:	d21c      	bcs.n	190a6 <bt_hex_real+0x46>
{
   1906c:	b430      	push	{r4, r5}
		str[i * 2]     = hex[b[i] >> 4];
   1906e:	f810 c003 	ldrb.w	ip, [r0, r3]
   19072:	ea4f 1c1c 	mov.w	ip, ip, lsr #4
   19076:	005a      	lsls	r2, r3, #1
   19078:	4d0d      	ldr	r5, [pc, #52]	; (190b0 <bt_hex_real+0x50>)
   1907a:	f815 c00c 	ldrb.w	ip, [r5, ip]
   1907e:	4c0d      	ldr	r4, [pc, #52]	; (190b4 <bt_hex_real+0x54>)
   19080:	f804 c013 	strb.w	ip, [r4, r3, lsl #1]
		str[i * 2 + 1] = hex[b[i] & 0xf];
   19084:	f810 c003 	ldrb.w	ip, [r0, r3]
   19088:	f00c 0c0f 	and.w	ip, ip, #15
   1908c:	3201      	adds	r2, #1
   1908e:	f815 500c 	ldrb.w	r5, [r5, ip]
   19092:	54a5      	strb	r5, [r4, r2]
	for (i = 0; i < len; i++) {
   19094:	3301      	adds	r3, #1
   19096:	428b      	cmp	r3, r1
   19098:	d3e9      	bcc.n	1906e <bt_hex_real+0xe>
	}

	str[i * 2] = '\0';
   1909a:	4806      	ldr	r0, [pc, #24]	; (190b4 <bt_hex_real+0x54>)
   1909c:	2200      	movs	r2, #0
   1909e:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]

	return str;
}
   190a2:	bc30      	pop	{r4, r5}
   190a4:	4770      	bx	lr
	str[i * 2] = '\0';
   190a6:	4803      	ldr	r0, [pc, #12]	; (190b4 <bt_hex_real+0x54>)
   190a8:	2200      	movs	r2, #0
   190aa:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]
}
   190ae:	4770      	bx	lr
   190b0:	0003997c 	.word	0x0003997c
   190b4:	20003a28 	.word	0x20003a28

000190b8 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
   190b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   190ba:	b08b      	sub	sp, #44	; 0x2c
   190bc:	4604      	mov	r4, r0
	switch (addr->type) {
   190be:	7803      	ldrb	r3, [r0, #0]
   190c0:	2b03      	cmp	r3, #3
   190c2:	d838      	bhi.n	19136 <bt_addr_le_str_real+0x7e>
   190c4:	e8df f003 	tbb	[pc, r3]
   190c8:	312b2102 	.word	0x312b2102
		strcpy(type, "public");
   190cc:	4b1d      	ldr	r3, [pc, #116]	; (19144 <bt_addr_le_str_real+0x8c>)
   190ce:	e893 0003 	ldmia.w	r3, {r0, r1}
   190d2:	9007      	str	r0, [sp, #28]
   190d4:	f8ad 1020 	strh.w	r1, [sp, #32]
   190d8:	0c09      	lsrs	r1, r1, #16
   190da:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
   190de:	7963      	ldrb	r3, [r4, #5]
   190e0:	7922      	ldrb	r2, [r4, #4]
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
   190e2:	78e1      	ldrb	r1, [r4, #3]
   190e4:	78a0      	ldrb	r0, [r4, #2]
   190e6:	7866      	ldrb	r6, [r4, #1]
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
   190e8:	4d17      	ldr	r5, [pc, #92]	; (19148 <bt_addr_le_str_real+0x90>)
   190ea:	af07      	add	r7, sp, #28
   190ec:	9705      	str	r7, [sp, #20]
   190ee:	9604      	str	r6, [sp, #16]
   190f0:	9003      	str	r0, [sp, #12]
   190f2:	9102      	str	r1, [sp, #8]
   190f4:	9201      	str	r2, [sp, #4]
   190f6:	9300      	str	r3, [sp, #0]
   190f8:	79a3      	ldrb	r3, [r4, #6]
   190fa:	4a14      	ldr	r2, [pc, #80]	; (1914c <bt_addr_le_str_real+0x94>)
   190fc:	211e      	movs	r1, #30
   190fe:	4628      	mov	r0, r5
   19100:	f012 ff80 	bl	2c004 <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
   19104:	4628      	mov	r0, r5
   19106:	b00b      	add	sp, #44	; 0x2c
   19108:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strcpy(type, "random");
   1910a:	4b11      	ldr	r3, [pc, #68]	; (19150 <bt_addr_le_str_real+0x98>)
   1910c:	e893 0003 	ldmia.w	r3, {r0, r1}
   19110:	9007      	str	r0, [sp, #28]
   19112:	f8ad 1020 	strh.w	r1, [sp, #32]
   19116:	0c09      	lsrs	r1, r1, #16
   19118:	f88d 1022 	strb.w	r1, [sp, #34]	; 0x22
		break;
   1911c:	e7df      	b.n	190de <bt_addr_le_str_real+0x26>
		strcpy(type, "public-id");
   1911e:	4a0d      	ldr	r2, [pc, #52]	; (19154 <bt_addr_le_str_real+0x9c>)
   19120:	ab07      	add	r3, sp, #28
   19122:	ca07      	ldmia	r2, {r0, r1, r2}
   19124:	c303      	stmia	r3!, {r0, r1}
   19126:	801a      	strh	r2, [r3, #0]
		break;
   19128:	e7d9      	b.n	190de <bt_addr_le_str_real+0x26>
		strcpy(type, "random-id");
   1912a:	4a0b      	ldr	r2, [pc, #44]	; (19158 <bt_addr_le_str_real+0xa0>)
   1912c:	ab07      	add	r3, sp, #28
   1912e:	ca07      	ldmia	r2, {r0, r1, r2}
   19130:	c303      	stmia	r3!, {r0, r1}
   19132:	801a      	strh	r2, [r3, #0]
		break;
   19134:	e7d3      	b.n	190de <bt_addr_le_str_real+0x26>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
   19136:	4a09      	ldr	r2, [pc, #36]	; (1915c <bt_addr_le_str_real+0xa4>)
   19138:	210a      	movs	r1, #10
   1913a:	a807      	add	r0, sp, #28
   1913c:	f012 ff62 	bl	2c004 <snprintk>
		break;
   19140:	e7cd      	b.n	190de <bt_addr_le_str_real+0x26>
   19142:	bf00      	nop
   19144:	00038e3c 	.word	0x00038e3c
   19148:	20003a08 	.word	0x20003a08
   1914c:	00038e54 	.word	0x00038e54
   19150:	00038e44 	.word	0x00038e44
   19154:	00038eb0 	.word	0x00038eb0
   19158:	00038ebc 	.word	0x00038ebc
   1915c:	00038e4c 	.word	0x00038e4c

00019160 <long_wq_init>:
{
	return k_work_submit_to_queue(&bt_long_wq, work);
}

static int long_wq_init(const struct device *d)
{
   19160:	b570      	push	{r4, r5, r6, lr}
   19162:	b084      	sub	sp, #16
	ARG_UNUSED(d);

	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
   19164:	ae02      	add	r6, sp, #8
   19166:	2400      	movs	r4, #0
   19168:	9402      	str	r4, [sp, #8]
   1916a:	9403      	str	r4, [sp, #12]
   1916c:	4b08      	ldr	r3, [pc, #32]	; (19190 <long_wq_init+0x30>)
   1916e:	9302      	str	r3, [sp, #8]

	k_work_queue_init(&bt_long_wq);
   19170:	4d08      	ldr	r5, [pc, #32]	; (19194 <long_wq_init+0x34>)
   19172:	4628      	mov	r0, r5
   19174:	f00e fa7a 	bl	2766c <k_work_queue_init>

	k_work_queue_start(&bt_long_wq, bt_lw_stack_area,
   19178:	9600      	str	r6, [sp, #0]
   1917a:	230a      	movs	r3, #10
   1917c:	f44f 62a3 	mov.w	r2, #1304	; 0x518
   19180:	4905      	ldr	r1, [pc, #20]	; (19198 <long_wq_init+0x38>)
   19182:	4628      	mov	r0, r5
   19184:	f00e fa8c 	bl	276a0 <k_work_queue_start>
			   K_THREAD_STACK_SIZEOF(bt_lw_stack_area),
			   CONFIG_BT_LONG_WQ_PRIO, &cfg);

	return 0;
}
   19188:	4620      	mov	r0, r4
   1918a:	b004      	add	sp, #16
   1918c:	bd70      	pop	{r4, r5, r6, pc}
   1918e:	bf00      	nop
   19190:	00039990 	.word	0x00039990
   19194:	20002088 	.word	0x20002088
   19198:	20005780 	.word	0x20005780

0001919c <bt_long_wq_schedule>:
{
   1919c:	b508      	push	{r3, lr}
   1919e:	4601      	mov	r1, r0
	return k_work_schedule_for_queue(&bt_long_wq, dwork, timeout);
   191a0:	4801      	ldr	r0, [pc, #4]	; (191a8 <bt_long_wq_schedule+0xc>)
   191a2:	f00e fb65 	bl	27870 <k_work_schedule_for_queue>
}
   191a6:	bd08      	pop	{r3, pc}
   191a8:	20002088 	.word	0x20002088

000191ac <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
   191ac:	b510      	push	{r4, lr}
   191ae:	4686      	mov	lr, r0
   191b0:	468c      	mov	ip, r1
	switch (src->type) {
   191b2:	7803      	ldrb	r3, [r0, #0]
   191b4:	2b01      	cmp	r3, #1
   191b6:	d018      	beq.n	191ea <uuid_to_uuid128+0x3e>
   191b8:	2b02      	cmp	r3, #2
   191ba:	d032      	beq.n	19222 <uuid_to_uuid128+0x76>
   191bc:	b103      	cbz	r3, 191c0 <uuid_to_uuid128+0x14>
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
   191be:	bd10      	pop	{r4, pc}
		*dst = uuid128_base;
   191c0:	4c22      	ldr	r4, [pc, #136]	; (1924c <uuid_to_uuid128+0xa0>)
   191c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   191c4:	f8cc 0000 	str.w	r0, [ip]
   191c8:	f8cc 1004 	str.w	r1, [ip, #4]
   191cc:	f8cc 2008 	str.w	r2, [ip, #8]
   191d0:	f8cc 300c 	str.w	r3, [ip, #12]
   191d4:	7823      	ldrb	r3, [r4, #0]
   191d6:	f88c 3010 	strb.w	r3, [ip, #16]
		sys_put_le16(BT_UUID_16(src)->val,
   191da:	f8be 3002 	ldrh.w	r3, [lr, #2]
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
   191de:	f88c 300d 	strb.w	r3, [ip, #13]
	dst[1] = val >> 8;
   191e2:	0a1b      	lsrs	r3, r3, #8
   191e4:	f88c 300e 	strb.w	r3, [ip, #14]
}
   191e8:	e7e9      	b.n	191be <uuid_to_uuid128+0x12>
		*dst = uuid128_base;
   191ea:	4c18      	ldr	r4, [pc, #96]	; (1924c <uuid_to_uuid128+0xa0>)
   191ec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   191ee:	f8cc 0000 	str.w	r0, [ip]
   191f2:	f8cc 1004 	str.w	r1, [ip, #4]
   191f6:	f8cc 2008 	str.w	r2, [ip, #8]
   191fa:	f8cc 300c 	str.w	r3, [ip, #12]
   191fe:	7823      	ldrb	r3, [r4, #0]
   19200:	f88c 3010 	strb.w	r3, [ip, #16]
		sys_put_le32(BT_UUID_32(src)->val,
   19204:	f8de 3004 	ldr.w	r3, [lr, #4]
	dst[0] = val;
   19208:	f88c 300d 	strb.w	r3, [ip, #13]
	dst[1] = val >> 8;
   1920c:	f3c3 2207 	ubfx	r2, r3, #8, #8
   19210:	f88c 200e 	strb.w	r2, [ip, #14]
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le32(uint32_t val, uint8_t dst[4])
{
	sys_put_le16(val, dst);
	sys_put_le16(val >> 16, &dst[2]);
   19214:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
   19216:	f88c 200f 	strb.w	r2, [ip, #15]
	dst[1] = val >> 8;
   1921a:	0e1b      	lsrs	r3, r3, #24
   1921c:	f88c 3010 	strb.w	r3, [ip, #16]
}
   19220:	e7cd      	b.n	191be <uuid_to_uuid128+0x12>
   19222:	6800      	ldr	r0, [r0, #0]
   19224:	f8de 1004 	ldr.w	r1, [lr, #4]
   19228:	f8de 2008 	ldr.w	r2, [lr, #8]
   1922c:	f8de 300c 	ldr.w	r3, [lr, #12]
   19230:	f8cc 0000 	str.w	r0, [ip]
   19234:	f8cc 1004 	str.w	r1, [ip, #4]
   19238:	f8cc 2008 	str.w	r2, [ip, #8]
   1923c:	f8cc 300c 	str.w	r3, [ip, #12]
   19240:	f89e 3010 	ldrb.w	r3, [lr, #16]
   19244:	f88c 3010 	strb.w	r3, [ip, #16]
   19248:	e7b9      	b.n	191be <uuid_to_uuid128+0x12>
   1924a:	bf00      	nop
   1924c:	0003999c 	.word	0x0003999c

00019250 <bt_buf_get_rx>:
			  BT_BUF_RX_SIZE, 8,
			  NULL);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
   19250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19252:	4604      	mov	r4, r0
   19254:	4616      	mov	r6, r2
   19256:	461d      	mov	r5, r3
	struct net_buf *buf;

	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN ||
   19258:	2801      	cmp	r0, #1
   1925a:	d003      	beq.n	19264 <bt_buf_get_rx+0x14>
   1925c:	2803      	cmp	r0, #3
   1925e:	d001      	beq.n	19264 <bt_buf_get_rx+0x14>
   19260:	2805      	cmp	r0, #5
   19262:	d10d      	bne.n	19280 <bt_buf_get_rx+0x30>
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
   19264:	4632      	mov	r2, r6
   19266:	462b      	mov	r3, r5
   19268:	480b      	ldr	r0, [pc, #44]	; (19298 <bt_buf_get_rx+0x48>)
   1926a:	f015 fe1f 	bl	2eeac <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
   1926e:	4605      	mov	r5, r0
   19270:	b120      	cbz	r0, 1927c <bt_buf_get_rx+0x2c>
 * @param buf Buffer to initialize.
 * @param reserve How much headroom to reserve.
 */
static inline void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
	net_buf_simple_reserve(&buf->b, reserve);
   19272:	2100      	movs	r1, #0
   19274:	3008      	adds	r0, #8
   19276:	f005 fd0d 	bl	1ec94 <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   1927a:	752c      	strb	r4, [r5, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
   1927c:	4628      	mov	r0, r5
   1927e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT(type == BT_BUF_EVT || type == BT_BUF_ACL_IN ||
   19280:	4f06      	ldr	r7, [pc, #24]	; (1929c <bt_buf_get_rx+0x4c>)
   19282:	2241      	movs	r2, #65	; 0x41
   19284:	4639      	mov	r1, r7
   19286:	4806      	ldr	r0, [pc, #24]	; (192a0 <bt_buf_get_rx+0x50>)
   19288:	f013 f951 	bl	2c52e <assert_print>
   1928c:	2141      	movs	r1, #65	; 0x41
   1928e:	4638      	mov	r0, r7
   19290:	f013 f946 	bl	2c520 <assert_post_action>
   19294:	e7e6      	b.n	19264 <bt_buf_get_rx+0x14>
   19296:	bf00      	nop
   19298:	20000fd4 	.word	0x20000fd4
   1929c:	000399b0 	.word	0x000399b0
   192a0:	00031600 	.word	0x00031600

000192a4 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
   192a4:	b510      	push	{r4, lr}
   192a6:	4602      	mov	r2, r0
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
   192a8:	4b0a      	ldr	r3, [pc, #40]	; (192d4 <bt_buf_get_cmd_complete+0x30>)
   192aa:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
   192ae:	b158      	cbz	r0, 192c8 <bt_buf_get_cmd_complete+0x24>
		buf = net_buf_ref(bt_dev.sent_cmd);
   192b0:	f005 fe68 	bl	1ef84 <net_buf_ref>
   192b4:	4604      	mov	r4, r0
   192b6:	2301      	movs	r3, #1
   192b8:	7503      	strb	r3, [r0, #20]

		bt_buf_set_type(buf, BT_BUF_EVT);
		buf->len = 0U;
   192ba:	2100      	movs	r1, #0
   192bc:	8181      	strh	r1, [r0, #12]
   192be:	3008      	adds	r0, #8
   192c0:	f005 fce8 	bl	1ec94 <net_buf_simple_reserve>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
   192c4:	4620      	mov	r0, r4
   192c6:	bd10      	pop	{r4, pc}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
   192c8:	460b      	mov	r3, r1
   192ca:	2001      	movs	r0, #1
   192cc:	f7ff ffc0 	bl	19250 <bt_buf_get_rx>
   192d0:	4604      	mov	r4, r0
   192d2:	e7f7      	b.n	192c4 <bt_buf_get_cmd_complete+0x20>
   192d4:	20000420 	.word	0x20000420

000192d8 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
   192d8:	b510      	push	{r4, lr}
	switch (evt) {
   192da:	280f      	cmp	r0, #15
   192dc:	d90d      	bls.n	192fa <bt_buf_get_evt+0x22>
   192de:	2813      	cmp	r0, #19
   192e0:	d10d      	bne.n	192fe <bt_buf_get_evt+0x26>
	return net_buf_alloc_fixed(pool, timeout);
   192e2:	4814      	ldr	r0, [pc, #80]	; (19334 <bt_buf_get_evt+0x5c>)
   192e4:	f015 fde2 	bl	2eeac <net_buf_alloc_fixed>
	case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
		{
			struct net_buf *buf;

			buf = net_buf_alloc(&num_complete_pool, timeout);
			if (buf) {
   192e8:	4604      	mov	r4, r0
   192ea:	b198      	cbz	r0, 19314 <bt_buf_get_evt+0x3c>
	net_buf_simple_reserve(&buf->b, reserve);
   192ec:	2100      	movs	r1, #0
   192ee:	3008      	adds	r0, #8
   192f0:	f005 fcd0 	bl	1ec94 <net_buf_simple_reserve>
   192f4:	2301      	movs	r3, #1
   192f6:	7523      	strb	r3, [r4, #20]
}
   192f8:	e00c      	b.n	19314 <bt_buf_get_evt+0x3c>
	switch (evt) {
   192fa:	280e      	cmp	r0, #14
   192fc:	d205      	bcs.n	1930a <bt_buf_get_evt+0x32>
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return bt_buf_get_cmd_complete(timeout);
	default:
#if defined(CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT)
		if (discardable) {
   192fe:	b959      	cbnz	r1, 19318 <bt_buf_get_evt+0x40>

			return buf;
		}
#endif /* CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
   19300:	2001      	movs	r0, #1
   19302:	f7ff ffa5 	bl	19250 <bt_buf_get_rx>
   19306:	4604      	mov	r4, r0
   19308:	e004      	b.n	19314 <bt_buf_get_evt+0x3c>
		return bt_buf_get_cmd_complete(timeout);
   1930a:	4610      	mov	r0, r2
   1930c:	4619      	mov	r1, r3
   1930e:	f7ff ffc9 	bl	192a4 <bt_buf_get_cmd_complete>
   19312:	4604      	mov	r4, r0
	}
}
   19314:	4620      	mov	r0, r4
   19316:	bd10      	pop	{r4, pc}
	return net_buf_alloc_fixed(pool, timeout);
   19318:	4807      	ldr	r0, [pc, #28]	; (19338 <bt_buf_get_evt+0x60>)
   1931a:	f015 fdc7 	bl	2eeac <net_buf_alloc_fixed>
			if (buf) {
   1931e:	4604      	mov	r4, r0
   19320:	2800      	cmp	r0, #0
   19322:	d0f7      	beq.n	19314 <bt_buf_get_evt+0x3c>
	net_buf_simple_reserve(&buf->b, reserve);
   19324:	2100      	movs	r1, #0
   19326:	3008      	adds	r0, #8
   19328:	f005 fcb4 	bl	1ec94 <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   1932c:	2301      	movs	r3, #1
   1932e:	7523      	strb	r3, [r4, #20]
			return buf;
   19330:	e7f0      	b.n	19314 <bt_buf_get_evt+0x3c>
   19332:	bf00      	nop
   19334:	20001008 	.word	0x20001008
   19338:	20000f38 	.word	0x20000f38

0001933c <conn_handle_disconnected>:
}

static uint16_t disconnected_handles[CONFIG_BT_MAX_CONN];
static void conn_handle_disconnected(uint16_t handle)
{
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   1933c:	2300      	movs	r3, #0
   1933e:	b103      	cbz	r3, 19342 <conn_handle_disconnected+0x6>
			 * handle 0 can be used as a valid non-zero handle.
			 */
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
		}
	}
}
   19340:	4770      	bx	lr
		if (!disconnected_handles[i]) {
   19342:	4a05      	ldr	r2, [pc, #20]	; (19358 <conn_handle_disconnected+0x1c>)
   19344:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
   19348:	b922      	cbnz	r2, 19354 <conn_handle_disconnected+0x18>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
   1934a:	f440 4270 	orr.w	r2, r0, #61440	; 0xf000
   1934e:	4902      	ldr	r1, [pc, #8]	; (19358 <conn_handle_disconnected+0x1c>)
   19350:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   19354:	3301      	adds	r3, #1
   19356:	e7f2      	b.n	1933e <conn_handle_disconnected+0x2>
   19358:	20003ac4 	.word	0x20003ac4

0001935c <conn_handle_is_disconnected>:

static bool conn_handle_is_disconnected(uint16_t handle)
{
	handle |= ~BT_ACL_HANDLE_MASK;
   1935c:	f440 4070 	orr.w	r0, r0, #61440	; 0xf000

	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   19360:	2300      	movs	r3, #0
   19362:	b10b      	cbz	r3, 19368 <conn_handle_is_disconnected+0xc>
			disconnected_handles[i] = 0;
			return true;
		}
	}

	return false;
   19364:	2000      	movs	r0, #0
}
   19366:	4770      	bx	lr
		if (disconnected_handles[i] == handle) {
   19368:	4a06      	ldr	r2, [pc, #24]	; (19384 <conn_handle_is_disconnected+0x28>)
   1936a:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
   1936e:	4282      	cmp	r2, r0
   19370:	d001      	beq.n	19376 <conn_handle_is_disconnected+0x1a>
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
   19372:	3301      	adds	r3, #1
   19374:	e7f5      	b.n	19362 <conn_handle_is_disconnected+0x6>
			disconnected_handles[i] = 0;
   19376:	4a03      	ldr	r2, [pc, #12]	; (19384 <conn_handle_is_disconnected+0x28>)
   19378:	2100      	movs	r1, #0
   1937a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
			return true;
   1937e:	2001      	movs	r0, #1
   19380:	4770      	bx	lr
   19382:	bf00      	nop
   19384:	20003ac4 	.word	0x20003ac4

00019388 <read_local_ver_complete>:
}


static void read_local_ver_complete(struct net_buf *buf)
{
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
   19388:	6882      	ldr	r2, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	bt_dev.hci_version = rp->hci_version;
   1938a:	7851      	ldrb	r1, [r2, #1]
   1938c:	4b08      	ldr	r3, [pc, #32]	; (193b0 <read_local_ver_complete+0x28>)
   1938e:	f883 1068 	strb.w	r1, [r3, #104]	; 0x68
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
   19392:	8851      	ldrh	r1, [r2, #2]
   19394:	f8a3 106a 	strh.w	r1, [r3, #106]	; 0x6a
	bt_dev.lmp_version = rp->lmp_version;
   19398:	7911      	ldrb	r1, [r2, #4]
   1939a:	f883 1069 	strb.w	r1, [r3, #105]	; 0x69
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
   1939e:	f8b2 1007 	ldrh.w	r1, [r2, #7]
   193a2:	f8a3 106c 	strh.w	r1, [r3, #108]	; 0x6c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
   193a6:	f8b2 2005 	ldrh.w	r2, [r2, #5]
   193aa:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
}
   193ae:	4770      	bx	lr
   193b0:	20000420 	.word	0x20000420

000193b4 <read_le_features_complete>:

static void read_le_features_complete(struct net_buf *buf)
{
	struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
   193b4:	6882      	ldr	r2, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
   193b6:	4b03      	ldr	r3, [pc, #12]	; (193c4 <read_le_features_complete+0x10>)
   193b8:	f8d2 0001 	ldr.w	r0, [r2, #1]
   193bc:	f8d2 1005 	ldr.w	r1, [r2, #5]
   193c0:	c303      	stmia	r3!, {r0, r1}
}
   193c2:	4770      	bx	lr
   193c4:	200004f0 	.word	0x200004f0

000193c8 <read_supported_commands_complete>:

	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_FEATURE, buf, NULL);
}

static void read_supported_commands_complete(struct net_buf *buf)
{
   193c8:	b530      	push	{r4, r5, lr}
	struct bt_hci_rp_read_supported_commands *rp = (void *)buf->data;
   193ca:	6884      	ldr	r4, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	memcpy(bt_dev.supported_commands, rp->commands,
   193cc:	f104 0c01 	add.w	ip, r4, #1
   193d0:	4d09      	ldr	r5, [pc, #36]	; (193f8 <read_supported_commands_complete+0x30>)
   193d2:	3441      	adds	r4, #65	; 0x41
   193d4:	46ae      	mov	lr, r5
   193d6:	f8dc 0000 	ldr.w	r0, [ip]
   193da:	f8dc 1004 	ldr.w	r1, [ip, #4]
   193de:	f8dc 2008 	ldr.w	r2, [ip, #8]
   193e2:	f8dc 300c 	ldr.w	r3, [ip, #12]
   193e6:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   193ea:	f10c 0c10 	add.w	ip, ip, #16
   193ee:	4675      	mov	r5, lr
   193f0:	45a4      	cmp	ip, r4
   193f2:	d1ef      	bne.n	193d4 <read_supported_commands_complete+0xc>
	 * supported if TinyCrypt ECC is used for emulation.
	 */
	if (IS_ENABLED(CONFIG_BT_TINYCRYPT_ECC)) {
		bt_hci_ecc_supported_commands(bt_dev.supported_commands);
	}
}
   193f4:	bd30      	pop	{r4, r5, pc}
   193f6:	bf00      	nop
   193f8:	20000498 	.word	0x20000498

000193fc <read_local_features_complete>:

static void read_local_features_complete(struct net_buf *buf)
{
	struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
   193fc:	6882      	ldr	r2, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
   193fe:	4b03      	ldr	r3, [pc, #12]	; (1940c <read_local_features_complete+0x10>)
   19400:	f8d2 0001 	ldr.w	r0, [r2, #1]
   19404:	f8d2 1005 	ldr.w	r1, [r2, #5]
   19408:	c303      	stmia	r3!, {r0, r1}
}
   1940a:	4770      	bx	lr
   1940c:	20000490 	.word	0x20000490

00019410 <le_read_supp_states_complete>:

static void le_read_supp_states_complete(struct net_buf *buf)
{
	struct bt_hci_rp_le_read_supp_states *rp = (void *)buf->data;
   19410:	6883      	ldr	r3, [r0, #8]
 *
 *  @return 16-bit integer in host endianness.
 */
static inline uint16_t sys_get_le16(const uint8_t src[2])
{
	return ((uint16_t)src[1] << 8) | src[0];
   19412:	7a19      	ldrb	r1, [r3, #8]
   19414:	79da      	ldrb	r2, [r3, #7]
   19416:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
   1941a:	7998      	ldrb	r0, [r3, #6]
   1941c:	795a      	ldrb	r2, [r3, #5]
   1941e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 *
 *  @return 32-bit integer in host endianness.
 */
static inline uint32_t sys_get_le32(const uint8_t src[4])
{
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   19422:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
	return ((uint16_t)src[1] << 8) | src[0];
   19426:	7918      	ldrb	r0, [r3, #4]
   19428:	78d9      	ldrb	r1, [r3, #3]
   1942a:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
   1942e:	7898      	ldrb	r0, [r3, #2]
   19430:	785b      	ldrb	r3, [r3, #1]
   19432:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   19436:	ea43 4301 	orr.w	r3, r3, r1, lsl #16

	BT_DBG("status 0x%02x", rp->status);

	bt_dev.le.states = sys_get_le64(rp->le_states);
   1943a:	4903      	ldr	r1, [pc, #12]	; (19448 <le_read_supp_states_complete+0x38>)
   1943c:	f8c1 30d8 	str.w	r3, [r1, #216]	; 0xd8
   19440:	f8c1 20dc 	str.w	r2, [r1, #220]	; 0xdc
}
   19444:	4770      	bx	lr
   19446:	bf00      	nop
   19448:	20000420 	.word	0x20000420

0001944c <hci_data_buf_overflow>:
{
   1944c:	b508      	push	{r3, lr}
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
   1944e:	6883      	ldr	r3, [r0, #8]
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
   19450:	781a      	ldrb	r2, [r3, #0]
   19452:	2157      	movs	r1, #87	; 0x57
   19454:	4801      	ldr	r0, [pc, #4]	; (1945c <hci_data_buf_overflow+0x10>)
   19456:	f013 f879 	bl	2c54c <z_log_minimal_printk>
}
   1945a:	bd08      	pop	{r3, pc}
   1945c:	00039a18 	.word	0x00039a18

00019460 <handle_event_common>:
{
   19460:	b510      	push	{r4, lr}
   19462:	4686      	mov	lr, r0
   19464:	4608      	mov	r0, r1
	for (i = 0; i < num_handlers; i++) {
   19466:	f04f 0c00 	mov.w	ip, #0
   1946a:	4563      	cmp	r3, ip
   1946c:	d918      	bls.n	194a0 <handle_event_common+0x40>
		const struct event_handler *handler = &handlers[i];
   1946e:	eb02 01cc 	add.w	r1, r2, ip, lsl #3
		if (handler->event != event) {
   19472:	f812 403c 	ldrb.w	r4, [r2, ip, lsl #3]
   19476:	4574      	cmp	r4, lr
   19478:	d107      	bne.n	1948a <handle_event_common+0x2a>
		if (buf->len < handler->min_len) {
   1947a:	8982      	ldrh	r2, [r0, #12]
   1947c:	784b      	ldrb	r3, [r1, #1]
   1947e:	429a      	cmp	r2, r3
   19480:	d306      	bcc.n	19490 <handle_event_common+0x30>
		handler->handler(buf);
   19482:	684b      	ldr	r3, [r1, #4]
   19484:	4798      	blx	r3
		return 0;
   19486:	2000      	movs	r0, #0
}
   19488:	bd10      	pop	{r4, pc}
	for (i = 0; i < num_handlers; i++) {
   1948a:	f10c 0c01 	add.w	ip, ip, #1
   1948e:	e7ec      	b.n	1946a <handle_event_common+0xa>
			BT_ERR("Too small (%u bytes) event 0x%02x",
   19490:	4673      	mov	r3, lr
   19492:	2145      	movs	r1, #69	; 0x45
   19494:	4804      	ldr	r0, [pc, #16]	; (194a8 <handle_event_common+0x48>)
   19496:	f013 f859 	bl	2c54c <z_log_minimal_printk>
			return -EINVAL;
   1949a:	f06f 0015 	mvn.w	r0, #21
   1949e:	e7f3      	b.n	19488 <handle_event_common+0x28>
	return -EOPNOTSUPP;
   194a0:	f06f 005e 	mvn.w	r0, #94	; 0x5e
   194a4:	e7f0      	b.n	19488 <handle_event_common+0x28>
   194a6:	bf00      	nop
   194a8:	00039a48 	.word	0x00039a48

000194ac <hci_reset_complete>:
	uint8_t status = buf->data[0];
   194ac:	6883      	ldr	r3, [r0, #8]
   194ae:	781b      	ldrb	r3, [r3, #0]
	if (status) {
   194b0:	b993      	cbnz	r3, 194d8 <hci_reset_complete+0x2c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   194b2:	f3bf 8f5b 	dmb	ish
   194b6:	4b09      	ldr	r3, [pc, #36]	; (194dc <hci_reset_complete+0x30>)
   194b8:	f853 2fcc 	ldr.w	r2, [r3, #204]!
   194bc:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
   194c0:	f002 0209 	and.w	r2, r2, #9
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   194c4:	f3bf 8f5b 	dmb	ish
   194c8:	e853 1f00 	ldrex	r1, [r3]
   194cc:	e843 2000 	strex	r0, r2, [r3]
   194d0:	2800      	cmp	r0, #0
   194d2:	d1f9      	bne.n	194c8 <hci_reset_complete+0x1c>
   194d4:	f3bf 8f5b 	dmb	ish
}
   194d8:	4770      	bx	lr
   194da:	bf00      	nop
   194dc:	20000420 	.word	0x20000420

000194e0 <le_read_buffer_size_complete>:
{
   194e0:	b508      	push	{r3, lr}
	struct bt_hci_rp_le_read_buffer_size *rp = (void *)buf->data;
   194e2:	6882      	ldr	r2, [r0, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
   194e4:	f8b2 3001 	ldrh.w	r3, [r2, #1]
   194e8:	b299      	uxth	r1, r3
   194ea:	4806      	ldr	r0, [pc, #24]	; (19504 <le_read_buffer_size_complete+0x24>)
   194ec:	f8a0 30fc 	strh.w	r3, [r0, #252]	; 0xfc
	if (!bt_dev.le.acl_mtu) {
   194f0:	b901      	cbnz	r1, 194f4 <le_read_buffer_size_complete+0x14>
}
   194f2:	bd08      	pop	{r3, pc}
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
   194f4:	78d1      	ldrb	r1, [r2, #3]
	return z_impl_k_sem_init(sem, initial_count, limit);
   194f6:	460a      	mov	r2, r1
   194f8:	f500 7080 	add.w	r0, r0, #256	; 0x100
   194fc:	f017 fa93 	bl	30a26 <z_impl_k_sem_init>
   19500:	e7f7      	b.n	194f2 <le_read_buffer_size_complete+0x12>
   19502:	bf00      	nop
   19504:	20000420 	.word	0x20000420

00019508 <read_buffer_size_complete>:
{
   19508:	b508      	push	{r3, lr}
	struct bt_hci_rp_read_buffer_size *rp = (void *)buf->data;
   1950a:	6882      	ldr	r2, [r0, #8]
	if (bt_dev.le.acl_mtu) {
   1950c:	4b08      	ldr	r3, [pc, #32]	; (19530 <read_buffer_size_complete+0x28>)
   1950e:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
   19512:	b103      	cbz	r3, 19516 <read_buffer_size_complete+0xe>
}
   19514:	bd08      	pop	{r3, pc}
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
   19516:	f8b2 3001 	ldrh.w	r3, [r2, #1]
   1951a:	4805      	ldr	r0, [pc, #20]	; (19530 <read_buffer_size_complete+0x28>)
   1951c:	f8a0 30fc 	strh.w	r3, [r0, #252]	; 0xfc
	pkts = sys_le16_to_cpu(rp->acl_max_num);
   19520:	8891      	ldrh	r1, [r2, #4]
   19522:	460a      	mov	r2, r1
   19524:	f500 7080 	add.w	r0, r0, #256	; 0x100
   19528:	f017 fa7d 	bl	30a26 <z_impl_k_sem_init>
   1952c:	e7f2      	b.n	19514 <read_buffer_size_complete+0xc>
   1952e:	bf00      	nop
   19530:	20000420 	.word	0x20000420

00019534 <find_pending_connect>:
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
   19534:	2801      	cmp	r0, #1
   19536:	d001      	beq.n	1953c <find_pending_connect+0x8>
	return NULL;
   19538:	2000      	movs	r0, #0
}
   1953a:	4770      	bx	lr
{
   1953c:	b500      	push	{lr}
   1953e:	b083      	sub	sp, #12
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
   19540:	2205      	movs	r2, #5
   19542:	4b0d      	ldr	r3, [pc, #52]	; (19578 <find_pending_connect+0x44>)
   19544:	f893 0067 	ldrb.w	r0, [r3, #103]	; 0x67
   19548:	f002 faf8 	bl	1bb3c <bt_conn_lookup_state_le>
		if (!conn) {
   1954c:	b110      	cbz	r0, 19554 <find_pending_connect+0x20>
}
   1954e:	b003      	add	sp, #12
   19550:	f85d fb04 	ldr.w	pc, [sp], #4
						       BT_ADDR_LE_NONE,
   19554:	4b09      	ldr	r3, [pc, #36]	; (1957c <find_pending_connect+0x48>)
   19556:	e893 0003 	ldmia.w	r3, {r0, r1}
   1955a:	9000      	str	r0, [sp, #0]
   1955c:	f8ad 1004 	strh.w	r1, [sp, #4]
   19560:	0c09      	lsrs	r1, r1, #16
   19562:	f88d 1006 	strb.w	r1, [sp, #6]
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
   19566:	2204      	movs	r2, #4
   19568:	4669      	mov	r1, sp
   1956a:	4b03      	ldr	r3, [pc, #12]	; (19578 <find_pending_connect+0x44>)
   1956c:	f893 0067 	ldrb.w	r0, [r3, #103]	; 0x67
   19570:	f002 fae4 	bl	1bb3c <bt_conn_lookup_state_le>
		return conn;
   19574:	e7eb      	b.n	1954e <find_pending_connect+0x1a>
   19576:	bf00      	nop
   19578:	20000420 	.word	0x20000420
   1957c:	00031428 	.word	0x00031428

00019580 <le_conn_complete_adv_timeout>:
{
   19580:	b510      	push	{r4, lr}
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   19582:	f001 fc5b 	bl	1ae3c <bt_le_adv_lookup_legacy>
		atomic_clear_bit(adv->flags, BT_ADV_ENABLED);
   19586:	3010      	adds	r0, #16
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   19588:	f3bf 8f5b 	dmb	ish
   1958c:	e850 3f00 	ldrex	r3, [r0]
   19590:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   19594:	e840 3200 	strex	r2, r3, [r0]
   19598:	2a00      	cmp	r2, #0
   1959a:	d1f7      	bne.n	1958c <le_conn_complete_adv_timeout+0xc>
   1959c:	f3bf 8f5b 	dmb	ish
		conn = find_pending_connect(BT_HCI_ROLE_PERIPHERAL, NULL);
   195a0:	2100      	movs	r1, #0
   195a2:	2001      	movs	r0, #1
   195a4:	f7ff ffc6 	bl	19534 <find_pending_connect>
		if (!conn) {
   195a8:	4604      	mov	r4, r0
   195aa:	b140      	cbz	r0, 195be <le_conn_complete_adv_timeout+0x3e>
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
   195ac:	233c      	movs	r3, #60	; 0x3c
   195ae:	7243      	strb	r3, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   195b0:	2100      	movs	r1, #0
   195b2:	f002 f875 	bl	1b6a0 <bt_conn_set_state>
		bt_conn_unref(conn);
   195b6:	4620      	mov	r0, r4
   195b8:	f002 f836 	bl	1b628 <bt_conn_unref>
}
   195bc:	bd10      	pop	{r4, pc}
			BT_ERR("No pending peripheral connection");
   195be:	2145      	movs	r1, #69	; 0x45
   195c0:	4801      	ldr	r0, [pc, #4]	; (195c8 <le_conn_complete_adv_timeout+0x48>)
   195c2:	f012 ffc3 	bl	2c54c <z_log_minimal_printk>
			return;
   195c6:	e7f9      	b.n	195bc <le_conn_complete_adv_timeout+0x3c>
   195c8:	00039a70 	.word	0x00039a70

000195cc <hci_disconn_complete>:
{
   195cc:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   195ce:	6884      	ldr	r4, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   195d0:	f8b4 6001 	ldrh.w	r6, [r4, #1]
	if (evt->status) {
   195d4:	7823      	ldrb	r3, [r4, #0]
   195d6:	b103      	cbz	r3, 195da <hci_disconn_complete+0xe>
}
   195d8:	bd70      	pop	{r4, r5, r6, pc}
	conn = bt_conn_lookup_handle(handle);
   195da:	4630      	mov	r0, r6
   195dc:	f002 f856 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   195e0:	4605      	mov	r5, r0
   195e2:	b158      	cbz	r0, 195fc <hci_disconn_complete+0x30>
	conn->err = evt->reason;
   195e4:	78e3      	ldrb	r3, [r4, #3]
   195e6:	7243      	strb	r3, [r0, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   195e8:	2100      	movs	r1, #0
   195ea:	f002 f859 	bl	1b6a0 <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
   195ee:	78ab      	ldrb	r3, [r5, #2]
   195f0:	2b01      	cmp	r3, #1
   195f2:	d009      	beq.n	19608 <hci_disconn_complete+0x3c>
		bt_conn_unref(conn);
   195f4:	4628      	mov	r0, r5
   195f6:	f002 f817 	bl	1b628 <bt_conn_unref>
		return;
   195fa:	e7ed      	b.n	195d8 <hci_disconn_complete+0xc>
		BT_ERR("Unable to look up conn with handle %u", handle);
   195fc:	4632      	mov	r2, r6
   195fe:	2145      	movs	r1, #69	; 0x45
   19600:	4803      	ldr	r0, [pc, #12]	; (19610 <hci_disconn_complete+0x44>)
   19602:	f012 ffa3 	bl	2c54c <z_log_minimal_printk>
		return;
   19606:	e7e7      	b.n	195d8 <hci_disconn_complete+0xc>
	bt_conn_unref(conn);
   19608:	4628      	mov	r0, r5
   1960a:	f002 f80d 	bl	1b628 <bt_conn_unref>
   1960e:	e7e3      	b.n	195d8 <hci_disconn_complete+0xc>
   19610:	00039a98 	.word	0x00039a98

00019614 <le_phy_update_complete>:
{
   19614:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_phy_update_complete *evt = (void *)buf->data;
   19616:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   19618:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
   1961c:	4620      	mov	r0, r4
   1961e:	f002 f835 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   19622:	b110      	cbz	r0, 1962a <le_phy_update_complete+0x16>
	bt_conn_unref(conn);
   19624:	f002 f800 	bl	1b628 <bt_conn_unref>
}
   19628:	bd10      	pop	{r4, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   1962a:	4622      	mov	r2, r4
   1962c:	2145      	movs	r1, #69	; 0x45
   1962e:	4802      	ldr	r0, [pc, #8]	; (19638 <le_phy_update_complete+0x24>)
   19630:	f012 ff8c 	bl	2c54c <z_log_minimal_printk>
		return;
   19634:	e7f8      	b.n	19628 <le_phy_update_complete+0x14>
   19636:	bf00      	nop
   19638:	00039ac4 	.word	0x00039ac4

0001963c <le_data_len_change>:
{
   1963c:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_data_len_change *evt = (void *)buf->data;
   1963e:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   19640:	881c      	ldrh	r4, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
   19642:	4620      	mov	r0, r4
   19644:	f002 f822 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   19648:	b110      	cbz	r0, 19650 <le_data_len_change+0x14>
	bt_conn_unref(conn);
   1964a:	f001 ffed 	bl	1b628 <bt_conn_unref>
}
   1964e:	bd10      	pop	{r4, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   19650:	4622      	mov	r2, r4
   19652:	2145      	movs	r1, #69	; 0x45
   19654:	4801      	ldr	r0, [pc, #4]	; (1965c <le_data_len_change+0x20>)
   19656:	f012 ff79 	bl	2c54c <z_log_minimal_printk>
		return;
   1965a:	e7f8      	b.n	1964e <le_data_len_change+0x12>
   1965c:	00039ac4 	.word	0x00039ac4

00019660 <hci_num_completed_packets>:
{
   19660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
   19664:	f8d0 8008 	ldr.w	r8, [r0, #8]
	for (i = 0; i < evt->num_handles; i++) {
   19668:	2700      	movs	r7, #0
   1966a:	e051      	b.n	19710 <hci_num_completed_packets+0xb0>
				conn->pending_no_cb--;
   1966c:	3b01      	subs	r3, #1
   1966e:	61e3      	str	r3, [r4, #28]
   19670:	f382 8811 	msr	BASEPRI, r2
   19674:	f3bf 8f6f 	isb	sy
				k_sem_give(bt_conn_get_pkts(conn));
   19678:	4620      	mov	r0, r4
   1967a:	f001 fee1 	bl	1b440 <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
   1967e:	f00d fc89 	bl	26f94 <z_impl_k_sem_give>
				continue;
   19682:	e024      	b.n	196ce <hci_num_completed_packets+0x6e>
   19684:	f382 8811 	msr	BASEPRI, r2
   19688:	f3bf 8f6f 	isb	sy
			if (!node) {
   1968c:	2b00      	cmp	r3, #0
   1968e:	d037      	beq.n	19700 <hci_num_completed_packets+0xa0>
	__asm__ volatile(
   19690:	f04f 0240 	mov.w	r2, #64	; 0x40
   19694:	f3ef 8111 	mrs	r1, BASEPRI
   19698:	f382 8812 	msr	BASEPRI_MAX, r2
   1969c:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
   196a0:	68da      	ldr	r2, [r3, #12]
   196a2:	61e2      	str	r2, [r4, #28]
			tx->pending_no_cb = 0U;
   196a4:	2200      	movs	r2, #0
   196a6:	60da      	str	r2, [r3, #12]
	parent->next = child;
   196a8:	601a      	str	r2, [r3, #0]
	return list->tail;
   196aa:	6a62      	ldr	r2, [r4, #36]	; 0x24
Z_GENLIST_APPEND(slist, snode)
   196ac:	2a00      	cmp	r2, #0
   196ae:	d045      	beq.n	1973c <hci_num_completed_packets+0xdc>
	parent->next = child;
   196b0:	6013      	str	r3, [r2, #0]
	list->tail = node;
   196b2:	6263      	str	r3, [r4, #36]	; 0x24
	__asm__ volatile(
   196b4:	f381 8811 	msr	BASEPRI, r1
   196b8:	f3bf 8f6f 	isb	sy
			k_work_submit(&conn->tx_complete_work);
   196bc:	f104 0028 	add.w	r0, r4, #40	; 0x28
   196c0:	f00d ffcc 	bl	2765c <k_work_submit>
			k_sem_give(bt_conn_get_pkts(conn));
   196c4:	4620      	mov	r0, r4
   196c6:	f001 febb 	bl	1b440 <bt_conn_get_pkts>
   196ca:	f00d fc63 	bl	26f94 <z_impl_k_sem_give>
{
   196ce:	462e      	mov	r6, r5
		while (count--) {
   196d0:	1e75      	subs	r5, r6, #1
   196d2:	b2ad      	uxth	r5, r5
   196d4:	b1c6      	cbz	r6, 19708 <hci_num_completed_packets+0xa8>
	__asm__ volatile(
   196d6:	f04f 0340 	mov.w	r3, #64	; 0x40
   196da:	f3ef 8211 	mrs	r2, BASEPRI
   196de:	f383 8812 	msr	BASEPRI_MAX, r3
   196e2:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
   196e6:	69e3      	ldr	r3, [r4, #28]
   196e8:	2b00      	cmp	r3, #0
   196ea:	d1bf      	bne.n	1966c <hci_num_completed_packets+0xc>
	return list->head;
   196ec:	6963      	ldr	r3, [r4, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   196ee:	2b00      	cmp	r3, #0
   196f0:	d0c8      	beq.n	19684 <hci_num_completed_packets+0x24>
	return node->next;
   196f2:	6819      	ldr	r1, [r3, #0]
	list->head = node;
   196f4:	6161      	str	r1, [r4, #20]
	return list->tail;
   196f6:	69a0      	ldr	r0, [r4, #24]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   196f8:	4298      	cmp	r0, r3
   196fa:	d1c3      	bne.n	19684 <hci_num_completed_packets+0x24>
	list->tail = node;
   196fc:	61a1      	str	r1, [r4, #24]
}
   196fe:	e7c1      	b.n	19684 <hci_num_completed_packets+0x24>
				BT_ERR("packets count mismatch");
   19700:	2145      	movs	r1, #69	; 0x45
   19702:	4811      	ldr	r0, [pc, #68]	; (19748 <hci_num_completed_packets+0xe8>)
   19704:	f012 ff22 	bl	2c54c <z_log_minimal_printk>
		bt_conn_unref(conn);
   19708:	4620      	mov	r0, r4
   1970a:	f001 ff8d 	bl	1b628 <bt_conn_unref>
	for (i = 0; i < evt->num_handles; i++) {
   1970e:	3701      	adds	r7, #1
   19710:	f898 3000 	ldrb.w	r3, [r8]
   19714:	429f      	cmp	r7, r3
   19716:	da14      	bge.n	19742 <hci_num_completed_packets+0xe2>
		handle = sys_le16_to_cpu(evt->h[i].handle);
   19718:	eb08 0387 	add.w	r3, r8, r7, lsl #2
   1971c:	f8b3 5001 	ldrh.w	r5, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
   19720:	f8b3 6003 	ldrh.w	r6, [r3, #3]
		conn = bt_conn_lookup_handle(handle);
   19724:	4628      	mov	r0, r5
   19726:	f001 ffb1 	bl	1b68c <bt_conn_lookup_handle>
		if (!conn) {
   1972a:	4604      	mov	r4, r0
   1972c:	2800      	cmp	r0, #0
   1972e:	d1cf      	bne.n	196d0 <hci_num_completed_packets+0x70>
			BT_ERR("No connection for handle %u", handle);
   19730:	462a      	mov	r2, r5
   19732:	2145      	movs	r1, #69	; 0x45
   19734:	4805      	ldr	r0, [pc, #20]	; (1974c <hci_num_completed_packets+0xec>)
   19736:	f012 ff09 	bl	2c54c <z_log_minimal_printk>
			continue;
   1973a:	e7e8      	b.n	1970e <hci_num_completed_packets+0xae>
	list->tail = node;
   1973c:	6263      	str	r3, [r4, #36]	; 0x24
	list->head = node;
   1973e:	6223      	str	r3, [r4, #32]
}
   19740:	e7b8      	b.n	196b4 <hci_num_completed_packets+0x54>
}
   19742:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19746:	bf00      	nop
   19748:	00039b14 	.word	0x00039b14
   1974c:	00039af0 	.word	0x00039af0

00019750 <hci_cmd_done>:
{
   19750:	b570      	push	{r4, r5, r6, lr}
   19752:	b082      	sub	sp, #8
   19754:	4605      	mov	r5, r0
   19756:	460e      	mov	r6, r1
   19758:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
   1975a:	7990      	ldrb	r0, [r2, #6]
   1975c:	f005 f950 	bl	1ea00 <net_buf_pool_get>
   19760:	4b47      	ldr	r3, [pc, #284]	; (19880 <hci_cmd_done+0x130>)
   19762:	4283      	cmp	r3, r0
   19764:	d00e      	beq.n	19784 <hci_cmd_done+0x34>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
   19766:	79a4      	ldrb	r4, [r4, #6]
   19768:	4620      	mov	r0, r4
   1976a:	f005 f949 	bl	1ea00 <net_buf_pool_get>
   1976e:	4b44      	ldr	r3, [pc, #272]	; (19880 <hci_cmd_done+0x130>)
   19770:	9301      	str	r3, [sp, #4]
   19772:	9000      	str	r0, [sp, #0]
   19774:	4623      	mov	r3, r4
   19776:	462a      	mov	r2, r5
   19778:	2157      	movs	r1, #87	; 0x57
   1977a:	4842      	ldr	r0, [pc, #264]	; (19884 <hci_cmd_done+0x134>)
   1977c:	f012 fee6 	bl	2c54c <z_log_minimal_printk>
}
   19780:	b002      	add	sp, #8
   19782:	bd70      	pop	{r4, r5, r6, pc}
	if (cmd(buf)->opcode != opcode) {
   19784:	4620      	mov	r0, r4
   19786:	f015 fb6c 	bl	2ee62 <net_buf_id>
   1978a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1978e:	483e      	ldr	r0, [pc, #248]	; (19888 <hci_cmd_done+0x138>)
   19790:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   19794:	8843      	ldrh	r3, [r0, #2]
   19796:	42ab      	cmp	r3, r5
   19798:	d132      	bne.n	19800 <hci_cmd_done+0xb0>
	if (bt_dev.sent_cmd) {
   1979a:	4b3c      	ldr	r3, [pc, #240]	; (1988c <hci_cmd_done+0x13c>)
   1979c:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
   197a0:	b128      	cbz	r0, 197ae <hci_cmd_done+0x5e>
		net_buf_unref(bt_dev.sent_cmd);
   197a2:	f005 fbb7 	bl	1ef14 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
   197a6:	4b39      	ldr	r3, [pc, #228]	; (1988c <hci_cmd_done+0x13c>)
   197a8:	2200      	movs	r2, #0
   197aa:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
	if (cmd(buf)->state && !status) {
   197ae:	4620      	mov	r0, r4
   197b0:	f015 fb57 	bl	2ee62 <net_buf_id>
   197b4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   197b8:	4b33      	ldr	r3, [pc, #204]	; (19888 <hci_cmd_done+0x138>)
   197ba:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   197be:	6843      	ldr	r3, [r0, #4]
   197c0:	b103      	cbz	r3, 197c4 <hci_cmd_done+0x74>
   197c2:	b366      	cbz	r6, 1981e <hci_cmd_done+0xce>
	if (cmd(buf)->sync) {
   197c4:	4620      	mov	r0, r4
   197c6:	f015 fb4c 	bl	2ee62 <net_buf_id>
   197ca:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   197ce:	4b2e      	ldr	r3, [pc, #184]	; (19888 <hci_cmd_done+0x138>)
   197d0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   197d4:	6883      	ldr	r3, [r0, #8]
   197d6:	2b00      	cmp	r3, #0
   197d8:	d0d2      	beq.n	19780 <hci_cmd_done+0x30>
		cmd(buf)->status = status;
   197da:	4620      	mov	r0, r4
   197dc:	f015 fb41 	bl	2ee62 <net_buf_id>
   197e0:	4d29      	ldr	r5, [pc, #164]	; (19888 <hci_cmd_done+0x138>)
   197e2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   197e6:	f805 6020 	strb.w	r6, [r5, r0, lsl #2]
		k_sem_give(cmd(buf)->sync);
   197ea:	4620      	mov	r0, r4
   197ec:	f015 fb39 	bl	2ee62 <net_buf_id>
   197f0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   197f4:	eb05 0580 	add.w	r5, r5, r0, lsl #2
   197f8:	68a8      	ldr	r0, [r5, #8]
   197fa:	f00d fbcb 	bl	26f94 <z_impl_k_sem_give>
}
   197fe:	e7bf      	b.n	19780 <hci_cmd_done+0x30>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
   19800:	4620      	mov	r0, r4
   19802:	f015 fb2e 	bl	2ee62 <net_buf_id>
   19806:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   1980a:	4b1f      	ldr	r3, [pc, #124]	; (19888 <hci_cmd_done+0x138>)
   1980c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19810:	8843      	ldrh	r3, [r0, #2]
   19812:	462a      	mov	r2, r5
   19814:	2157      	movs	r1, #87	; 0x57
   19816:	481e      	ldr	r0, [pc, #120]	; (19890 <hci_cmd_done+0x140>)
   19818:	f012 fe98 	bl	2c54c <z_log_minimal_printk>
		return;
   1981c:	e7b0      	b.n	19780 <hci_cmd_done+0x30>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
   1981e:	4620      	mov	r0, r4
   19820:	f015 fb1f 	bl	2ee62 <net_buf_id>
   19824:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19828:	4b17      	ldr	r3, [pc, #92]	; (19888 <hci_cmd_done+0x138>)
   1982a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1982e:	6842      	ldr	r2, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
   19830:	6813      	ldr	r3, [r2, #0]
   19832:	6851      	ldr	r1, [r2, #4]
   19834:	7a10      	ldrb	r0, [r2, #8]
 * @param bit Bit number (starting from 0).
 * @param val true for 1, false for 0.
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   19836:	f001 051f 	and.w	r5, r1, #31
   1983a:	2201      	movs	r2, #1
   1983c:	40aa      	lsls	r2, r5

	if (val) {
   1983e:	b170      	cbz	r0, 1985e <hci_cmd_done+0x10e>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   19840:	0949      	lsrs	r1, r1, #5
   19842:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   19846:	f3bf 8f5b 	dmb	ish
   1984a:	e853 1f00 	ldrex	r1, [r3]
   1984e:	4311      	orrs	r1, r2
   19850:	e843 1000 	strex	r0, r1, [r3]
   19854:	2800      	cmp	r0, #0
   19856:	d1f8      	bne.n	1984a <hci_cmd_done+0xfa>
   19858:	f3bf 8f5b 	dmb	ish
   1985c:	e7b2      	b.n	197c4 <hci_cmd_done+0x74>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1985e:	0949      	lsrs	r1, r1, #5
   19860:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   19864:	43d2      	mvns	r2, r2
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   19866:	f3bf 8f5b 	dmb	ish
   1986a:	e853 1f00 	ldrex	r1, [r3]
   1986e:	4011      	ands	r1, r2
   19870:	e843 1000 	strex	r0, r1, [r3]
   19874:	2800      	cmp	r0, #0
   19876:	d1f8      	bne.n	1986a <hci_cmd_done+0x11a>
   19878:	f3bf 8f5b 	dmb	ish
	}
}
   1987c:	e7a2      	b.n	197c4 <hci_cmd_done+0x74>
   1987e:	bf00      	nop
   19880:	20000fa0 	.word	0x20000fa0
   19884:	00039b30 	.word	0x00039b30
   19888:	20003aac 	.word	0x20003aac
   1988c:	20000420 	.word	0x20000420
   19890:	00039b6c 	.word	0x00039b6c

00019894 <le_remote_feat_complete>:
{
   19894:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
   19896:	6884      	ldr	r4, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   19898:	f8b4 5001 	ldrh.w	r5, [r4, #1]
	conn = bt_conn_lookup_handle(handle);
   1989c:	4628      	mov	r0, r5
   1989e:	f001 fef5 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   198a2:	b1d8      	cbz	r0, 198dc <le_remote_feat_complete+0x48>
   198a4:	4603      	mov	r3, r0
	if (!evt->status) {
   198a6:	7822      	ldrb	r2, [r4, #0]
   198a8:	b93a      	cbnz	r2, 198ba <le_remote_feat_complete+0x26>
   198aa:	f8d4 1003 	ldr.w	r1, [r4, #3]
   198ae:	f8d4 2007 	ldr.w	r2, [r4, #7]
   198b2:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
   198b6:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
	atomic_set_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH);
   198ba:	1d1a      	adds	r2, r3, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   198bc:	f3bf 8f5b 	dmb	ish
   198c0:	e852 1f00 	ldrex	r1, [r2]
   198c4:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
   198c8:	e842 1000 	strex	r0, r1, [r2]
   198cc:	2800      	cmp	r0, #0
   198ce:	d1f7      	bne.n	198c0 <le_remote_feat_complete+0x2c>
   198d0:	f3bf 8f5b 	dmb	ish
	bt_conn_unref(conn);
   198d4:	4618      	mov	r0, r3
   198d6:	f001 fea7 	bl	1b628 <bt_conn_unref>
}
   198da:	bd38      	pop	{r3, r4, r5, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   198dc:	462a      	mov	r2, r5
   198de:	2145      	movs	r1, #69	; 0x45
   198e0:	4801      	ldr	r0, [pc, #4]	; (198e8 <le_remote_feat_complete+0x54>)
   198e2:	f012 fe33 	bl	2c54c <z_log_minimal_printk>
		return;
   198e6:	e7f8      	b.n	198da <le_remote_feat_complete+0x46>
   198e8:	00039ac4 	.word	0x00039ac4

000198ec <hci_cmd_status>:
{
   198ec:	b538      	push	{r3, r4, r5, lr}
   198ee:	4604      	mov	r4, r0
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
   198f0:	2104      	movs	r1, #4
   198f2:	3008      	adds	r0, #8
   198f4:	f005 fbe6 	bl	1f0c4 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
   198f8:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
   198fa:	4622      	mov	r2, r4
   198fc:	7801      	ldrb	r1, [r0, #0]
   198fe:	8840      	ldrh	r0, [r0, #2]
   19900:	f7ff ff26 	bl	19750 <hci_cmd_done>
	if (ncmd) {
   19904:	b905      	cbnz	r5, 19908 <hci_cmd_status+0x1c>
}
   19906:	bd38      	pop	{r3, r4, r5, pc}
	z_impl_k_sem_give(sem);
   19908:	4801      	ldr	r0, [pc, #4]	; (19910 <hci_cmd_status+0x24>)
   1990a:	f00d fb43 	bl	26f94 <z_impl_k_sem_give>
   1990e:	e7fa      	b.n	19906 <hci_cmd_status+0x1a>
   19910:	20000538 	.word	0x20000538

00019914 <hci_cmd_complete>:
{
   19914:	b538      	push	{r3, r4, r5, lr}
   19916:	4604      	mov	r4, r0
   19918:	2103      	movs	r1, #3
   1991a:	3008      	adds	r0, #8
   1991c:	f005 fbd2 	bl	1f0c4 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
   19920:	7805      	ldrb	r5, [r0, #0]
	status = buf->data[0];
   19922:	68a3      	ldr	r3, [r4, #8]
	hci_cmd_done(opcode, status, buf);
   19924:	4622      	mov	r2, r4
   19926:	7819      	ldrb	r1, [r3, #0]
   19928:	f8b0 0001 	ldrh.w	r0, [r0, #1]
   1992c:	f7ff ff10 	bl	19750 <hci_cmd_done>
	if (ncmd) {
   19930:	b905      	cbnz	r5, 19934 <hci_cmd_complete+0x20>
}
   19932:	bd38      	pop	{r3, r4, r5, pc}
   19934:	4801      	ldr	r0, [pc, #4]	; (1993c <hci_cmd_complete+0x28>)
   19936:	f00d fb2d 	bl	26f94 <z_impl_k_sem_give>
   1993a:	e7fa      	b.n	19932 <hci_cmd_complete+0x1e>
   1993c:	20000538 	.word	0x20000538

00019940 <hci_hardware_error>:
{
   19940:	b508      	push	{r3, lr}
   19942:	2101      	movs	r1, #1
   19944:	3008      	adds	r0, #8
   19946:	f005 fbbd 	bl	1f0c4 <net_buf_simple_pull_mem>
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
   1994a:	7802      	ldrb	r2, [r0, #0]
   1994c:	2145      	movs	r1, #69	; 0x45
   1994e:	4802      	ldr	r0, [pc, #8]	; (19958 <hci_hardware_error+0x18>)
   19950:	f012 fdfc 	bl	2c54c <z_log_minimal_printk>
}
   19954:	bd08      	pop	{r3, pc}
   19956:	bf00      	nop
   19958:	00039ba4 	.word	0x00039ba4

0001995c <handle_event>:
{
   1995c:	b570      	push	{r4, r5, r6, lr}
   1995e:	b082      	sub	sp, #8
   19960:	4605      	mov	r5, r0
   19962:	460c      	mov	r4, r1
	err = handle_event_common(event, buf, handlers, num_handlers);
   19964:	f7ff fd7c 	bl	19460 <handle_event_common>
	if (err == -EOPNOTSUPP) {
   19968:	f110 0f5f 	cmn.w	r0, #95	; 0x5f
   1996c:	d001      	beq.n	19972 <handle_event+0x16>
}
   1996e:	b002      	add	sp, #8
   19970:	bd70      	pop	{r4, r5, r6, pc}
		BT_WARN("Unhandled event 0x%02x len %u: %s", event, buf->len,
   19972:	89a6      	ldrh	r6, [r4, #12]
   19974:	4631      	mov	r1, r6
   19976:	68a0      	ldr	r0, [r4, #8]
   19978:	f7ff fb72 	bl	19060 <bt_hex_real>
   1997c:	9000      	str	r0, [sp, #0]
   1997e:	4633      	mov	r3, r6
   19980:	462a      	mov	r2, r5
   19982:	2157      	movs	r1, #87	; 0x57
   19984:	4801      	ldr	r0, [pc, #4]	; (1998c <handle_event+0x30>)
   19986:	f012 fde1 	bl	2c54c <z_log_minimal_printk>
}
   1998a:	e7f0      	b.n	1996e <handle_event+0x12>
   1998c:	00039bcc 	.word	0x00039bcc

00019990 <hci_le_meta_event>:
{
   19990:	b510      	push	{r4, lr}
   19992:	4604      	mov	r4, r0
   19994:	2101      	movs	r1, #1
   19996:	3008      	adds	r0, #8
   19998:	f005 fb94 	bl	1f0c4 <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
   1999c:	2307      	movs	r3, #7
   1999e:	4a03      	ldr	r2, [pc, #12]	; (199ac <hci_le_meta_event+0x1c>)
   199a0:	4621      	mov	r1, r4
   199a2:	7800      	ldrb	r0, [r0, #0]
   199a4:	f7ff ffda 	bl	1995c <handle_event>
}
   199a8:	bd10      	pop	{r4, pc}
   199aa:	bf00      	nop
   199ac:	00039f04 	.word	0x00039f04

000199b0 <rx_queue_put>:
	}
}

#if !defined(CONFIG_BT_RECV_BLOCKING)
static void rx_queue_put(struct net_buf *buf)
{
   199b0:	b508      	push	{r3, lr}
   199b2:	4601      	mov	r1, r0
	net_buf_slist_put(&bt_dev.rx_queue, buf);
   199b4:	4807      	ldr	r0, [pc, #28]	; (199d4 <rx_queue_put+0x24>)
   199b6:	f005 f995 	bl	1ece4 <net_buf_slist_put>

#if defined(CONFIG_BT_RECV_WORKQ_SYS)
	const int err = k_work_submit(&rx_work);
#elif defined(CONFIG_BT_RECV_WORKQ_BT)
	const int err = k_work_submit_to_queue(&bt_workq, &rx_work);
   199ba:	4907      	ldr	r1, [pc, #28]	; (199d8 <rx_queue_put+0x28>)
   199bc:	4807      	ldr	r0, [pc, #28]	; (199dc <rx_queue_put+0x2c>)
   199be:	f017 f88f 	bl	30ae0 <k_work_submit_to_queue>
#endif /* CONFIG_BT_RECV_WORKQ_SYS */
	if (err < 0) {
   199c2:	1e02      	subs	r2, r0, #0
   199c4:	db00      	blt.n	199c8 <rx_queue_put+0x18>
		BT_ERR("Could not submit rx_work: %d", err);
	}
}
   199c6:	bd08      	pop	{r3, pc}
		BT_ERR("Could not submit rx_work: %d", err);
   199c8:	2145      	movs	r1, #69	; 0x45
   199ca:	4805      	ldr	r0, [pc, #20]	; (199e0 <rx_queue_put+0x30>)
   199cc:	f012 fdbe 	bl	2c54c <z_log_minimal_printk>
}
   199d0:	e7f9      	b.n	199c6 <rx_queue_put+0x16>
   199d2:	bf00      	nop
   199d4:	20000554 	.word	0x20000554
   199d8:	20000b00 	.word	0x20000b00
   199dc:	20002178 	.word	0x20002178
   199e0:	00039bf4 	.word	0x00039bf4

000199e4 <hci_acl>:
{
   199e4:	b570      	push	{r4, r5, r6, lr}
   199e6:	4604      	mov	r4, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
   199e8:	8983      	ldrh	r3, [r0, #12]
   199ea:	2b03      	cmp	r3, #3
   199ec:	d917      	bls.n	19a1e <hci_acl+0x3a>
   199ee:	2104      	movs	r1, #4
   199f0:	f104 0008 	add.w	r0, r4, #8
   199f4:	f005 fb66 	bl	1f0c4 <net_buf_simple_pull_mem>
	len = sys_le16_to_cpu(hdr->len);
   199f8:	8843      	ldrh	r3, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
   199fa:	8800      	ldrh	r0, [r0, #0]
	flags = bt_acl_flags(handle);
   199fc:	0b06      	lsrs	r6, r0, #12
	acl(buf)->handle = bt_acl_handle(handle);
   199fe:	f3c0 000b 	ubfx	r0, r0, #0, #12
   19a02:	82e0      	strh	r0, [r4, #22]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
   19a04:	22ff      	movs	r2, #255	; 0xff
   19a06:	7562      	strb	r2, [r4, #21]
	if (buf->len != len) {
   19a08:	89a2      	ldrh	r2, [r4, #12]
   19a0a:	429a      	cmp	r2, r3
   19a0c:	d014      	beq.n	19a38 <hci_acl+0x54>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
   19a0e:	2145      	movs	r1, #69	; 0x45
   19a10:	4816      	ldr	r0, [pc, #88]	; (19a6c <hci_acl+0x88>)
   19a12:	f012 fd9b 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   19a16:	4620      	mov	r0, r4
   19a18:	f005 fa7c 	bl	1ef14 <net_buf_unref>
}
   19a1c:	bd70      	pop	{r4, r5, r6, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
   19a1e:	f240 12eb 	movw	r2, #491	; 0x1eb
   19a22:	4913      	ldr	r1, [pc, #76]	; (19a70 <hci_acl+0x8c>)
   19a24:	4813      	ldr	r0, [pc, #76]	; (19a74 <hci_acl+0x90>)
   19a26:	f012 fd82 	bl	2c52e <assert_print>
   19a2a:	4040      	eors	r0, r0
   19a2c:	f380 8811 	msr	BASEPRI, r0
   19a30:	f04f 0003 	mov.w	r0, #3
   19a34:	df02      	svc	2
   19a36:	e7da      	b.n	199ee <hci_acl+0xa>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
   19a38:	f001 fe28 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   19a3c:	4605      	mov	r5, r0
   19a3e:	b158      	cbz	r0, 19a58 <hci_acl+0x74>
	acl(buf)->index = bt_conn_index(conn);
   19a40:	f001 ff08 	bl	1b854 <bt_conn_index>
   19a44:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
   19a46:	4632      	mov	r2, r6
   19a48:	4621      	mov	r1, r4
   19a4a:	4628      	mov	r0, r5
   19a4c:	f013 fb7d 	bl	2d14a <bt_conn_recv>
	bt_conn_unref(conn);
   19a50:	4628      	mov	r0, r5
   19a52:	f001 fde9 	bl	1b628 <bt_conn_unref>
   19a56:	e7e1      	b.n	19a1c <hci_acl+0x38>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
   19a58:	8ae2      	ldrh	r2, [r4, #22]
   19a5a:	2145      	movs	r1, #69	; 0x45
   19a5c:	4806      	ldr	r0, [pc, #24]	; (19a78 <hci_acl+0x94>)
   19a5e:	f012 fd75 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   19a62:	4620      	mov	r0, r4
   19a64:	f005 fa56 	bl	1ef14 <net_buf_unref>
		return;
   19a68:	e7d8      	b.n	19a1c <hci_acl+0x38>
   19a6a:	bf00      	nop
   19a6c:	00039c4c 	.word	0x00039c4c
   19a70:	00039c18 	.word	0x00039c18
   19a74:	00031600 	.word	0x00031600
   19a78:	00039c78 	.word	0x00039c78

00019a7c <le_conn_update_complete>:
{
   19a7c:	b570      	push	{r4, r5, r6, lr}
   19a7e:	b082      	sub	sp, #8
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
   19a80:	6884      	ldr	r4, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
   19a82:	f8b4 6001 	ldrh.w	r6, [r4, #1]
	conn = bt_conn_lookup_handle(handle);
   19a86:	4630      	mov	r0, r6
   19a88:	f001 fe00 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   19a8c:	b148      	cbz	r0, 19aa2 <le_conn_update_complete+0x26>
   19a8e:	4605      	mov	r5, r0
	if (!evt->status) {
   19a90:	7823      	ldrb	r3, [r4, #0]
   19a92:	b163      	cbz	r3, 19aae <le_conn_update_complete+0x32>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
   19a94:	2b1a      	cmp	r3, #26
   19a96:	d019      	beq.n	19acc <le_conn_update_complete+0x50>
	bt_conn_unref(conn);
   19a98:	4628      	mov	r0, r5
   19a9a:	f001 fdc5 	bl	1b628 <bt_conn_unref>
}
   19a9e:	b002      	add	sp, #8
   19aa0:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   19aa2:	4632      	mov	r2, r6
   19aa4:	2145      	movs	r1, #69	; 0x45
   19aa6:	481d      	ldr	r0, [pc, #116]	; (19b1c <le_conn_update_complete+0xa0>)
   19aa8:	f012 fd50 	bl	2c54c <z_log_minimal_printk>
		return;
   19aac:	e7f7      	b.n	19a9e <le_conn_update_complete+0x22>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
   19aae:	f8b4 3003 	ldrh.w	r3, [r4, #3]
   19ab2:	f8a0 30a6 	strh.w	r3, [r0, #166]	; 0xa6
		conn->le.latency = sys_le16_to_cpu(evt->latency);
   19ab6:	f8b4 3005 	ldrh.w	r3, [r4, #5]
   19aba:	f8a0 30ac 	strh.w	r3, [r0, #172]	; 0xac
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   19abe:	f8b4 3007 	ldrh.w	r3, [r4, #7]
   19ac2:	f8a0 30ae 	strh.w	r3, [r0, #174]	; 0xae
		notify_le_param_updated(conn);
   19ac6:	f001 ff1b 	bl	1b900 <notify_le_param_updated>
   19aca:	e7e5      	b.n	19a98 <le_conn_update_complete+0x1c>
		   conn->role == BT_HCI_ROLE_PERIPHERAL &&
   19acc:	78c3      	ldrb	r3, [r0, #3]
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
   19ace:	2b01      	cmp	r3, #1
   19ad0:	d1e2      	bne.n	19a98 <le_conn_update_complete+0x1c>
		   !atomic_test_and_set_bit(conn->flags,
   19ad2:	1d03      	adds	r3, r0, #4
   19ad4:	f3bf 8f5b 	dmb	ish
   19ad8:	e853 2f00 	ldrex	r2, [r3]
   19adc:	f442 7100 	orr.w	r1, r2, #512	; 0x200
   19ae0:	e843 1000 	strex	r0, r1, [r3]
   19ae4:	2800      	cmp	r0, #0
   19ae6:	d1f7      	bne.n	19ad8 <le_conn_update_complete+0x5c>
   19ae8:	f3bf 8f5b 	dmb	ish
		   conn->role == BT_HCI_ROLE_PERIPHERAL &&
   19aec:	f412 7f00 	tst.w	r2, #512	; 0x200
   19af0:	d1d2      	bne.n	19a98 <le_conn_update_complete+0x1c>
		param.interval_min = conn->le.interval_min;
   19af2:	f8b5 30a8 	ldrh.w	r3, [r5, #168]	; 0xa8
   19af6:	f8ad 3000 	strh.w	r3, [sp]
		param.interval_max = conn->le.interval_max;
   19afa:	f8b5 30aa 	ldrh.w	r3, [r5, #170]	; 0xaa
   19afe:	f8ad 3002 	strh.w	r3, [sp, #2]
		param.latency = conn->le.pending_latency;
   19b02:	f8b5 30b0 	ldrh.w	r3, [r5, #176]	; 0xb0
   19b06:	f8ad 3004 	strh.w	r3, [sp, #4]
		param.timeout = conn->le.pending_timeout;
   19b0a:	f8b5 30b2 	ldrh.w	r3, [r5, #178]	; 0xb2
   19b0e:	f8ad 3006 	strh.w	r3, [sp, #6]
		bt_l2cap_update_conn_param(conn, &param);
   19b12:	4669      	mov	r1, sp
   19b14:	4628      	mov	r0, r5
   19b16:	f013 fc92 	bl	2d43e <bt_l2cap_update_conn_param>
   19b1a:	e7bd      	b.n	19a98 <le_conn_update_complete+0x1c>
   19b1c:	00039ac4 	.word	0x00039ac4

00019b20 <hci_event>:
{
   19b20:	b538      	push	{r3, r4, r5, lr}
   19b22:	4604      	mov	r4, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
   19b24:	8983      	ldrh	r3, [r0, #12]
   19b26:	2b01      	cmp	r3, #1
   19b28:	d916      	bls.n	19b58 <hci_event+0x38>
   19b2a:	2102      	movs	r1, #2
   19b2c:	f104 0008 	add.w	r0, r4, #8
   19b30:	f005 fac8 	bl	1f0c4 <net_buf_simple_pull_mem>
   19b34:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
   19b36:	7803      	ldrb	r3, [r0, #0]
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
   19b38:	3b05      	subs	r3, #5
   19b3a:	2b15      	cmp	r3, #21
   19b3c:	d81b      	bhi.n	19b76 <hci_event+0x56>
   19b3e:	e8df f003 	tbb	[pc, r3]
   19b42:	1a18      	.short	0x1a18
   19b44:	1a1a1a1a 	.word	0x1a1a1a1a
   19b48:	281a1a1a 	.word	0x281a1a1a
   19b4c:	1a1a1a28 	.word	0x1a1a1a28
   19b50:	1a1a1a28 	.word	0x1a1a1a28
   19b54:	281a1a1a 	.word	0x281a1a1a
	BT_ASSERT(buf->len >= sizeof(*hdr));
   19b58:	f640 1259 	movw	r2, #2393	; 0x959
   19b5c:	4914      	ldr	r1, [pc, #80]	; (19bb0 <hci_event+0x90>)
   19b5e:	4815      	ldr	r0, [pc, #84]	; (19bb4 <hci_event+0x94>)
   19b60:	f012 fce5 	bl	2c52e <assert_print>
   19b64:	4040      	eors	r0, r0
   19b66:	f380 8811 	msr	BASEPRI, r0
   19b6a:	f04f 0003 	mov.w	r0, #3
   19b6e:	df02      	svc	2
   19b70:	e7db      	b.n	19b2a <hci_event+0xa>
   19b72:	2303      	movs	r3, #3
   19b74:	e000      	b.n	19b78 <hci_event+0x58>
#endif /* CONFIG_BT_CONN ||  CONFIG_BT_ISO */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
   19b76:	2302      	movs	r3, #2
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
   19b78:	f013 0f02 	tst.w	r3, #2
   19b7c:	d00b      	beq.n	19b96 <hci_event+0x76>
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
   19b7e:	2304      	movs	r3, #4
   19b80:	4a0d      	ldr	r2, [pc, #52]	; (19bb8 <hci_event+0x98>)
   19b82:	4621      	mov	r1, r4
   19b84:	7828      	ldrb	r0, [r5, #0]
   19b86:	f7ff fee9 	bl	1995c <handle_event>
	net_buf_unref(buf);
   19b8a:	4620      	mov	r0, r4
   19b8c:	f005 f9c2 	bl	1ef14 <net_buf_unref>
}
   19b90:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_EVT_FLAG_RECV_PRIO;
   19b92:	2301      	movs	r3, #1
   19b94:	e7f0      	b.n	19b78 <hci_event+0x58>
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
   19b96:	f640 125d 	movw	r2, #2397	; 0x95d
   19b9a:	4905      	ldr	r1, [pc, #20]	; (19bb0 <hci_event+0x90>)
   19b9c:	4805      	ldr	r0, [pc, #20]	; (19bb4 <hci_event+0x94>)
   19b9e:	f012 fcc6 	bl	2c52e <assert_print>
   19ba2:	4040      	eors	r0, r0
   19ba4:	f380 8811 	msr	BASEPRI, r0
   19ba8:	f04f 0003 	mov.w	r0, #3
   19bac:	df02      	svc	2
   19bae:	e7e6      	b.n	19b7e <hci_event+0x5e>
   19bb0:	00039c18 	.word	0x00039c18
   19bb4:	00031600 	.word	0x00031600
   19bb8:	00039f4c 	.word	0x00039f4c

00019bbc <rx_work_handler>:
	}
}

#if !defined(CONFIG_BT_RECV_BLOCKING)
static void rx_work_handler(struct k_work *work)
{
   19bbc:	b510      	push	{r4, lr}
	int err;

	struct net_buf *buf;

	BT_DBG("Getting net_buf from queue");
	buf = net_buf_slist_get(&bt_dev.rx_queue);
   19bbe:	4813      	ldr	r0, [pc, #76]	; (19c0c <rx_work_handler+0x50>)
   19bc0:	f005 f8fc 	bl	1edbc <net_buf_slist_get>
	if (!buf) {
   19bc4:	b188      	cbz	r0, 19bea <rx_work_handler+0x2e>
   19bc6:	4604      	mov	r4, r0
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   19bc8:	7d02      	ldrb	r2, [r0, #20]
	}

	BT_DBG("buf %p type %u len %u", buf, bt_buf_get_type(buf),
	       buf->len);

	switch (bt_buf_get_type(buf)) {
   19bca:	2a01      	cmp	r2, #1
   19bcc:	d00e      	beq.n	19bec <rx_work_handler+0x30>
   19bce:	2a03      	cmp	r2, #3
   19bd0:	d10f      	bne.n	19bf2 <rx_work_handler+0x36>
#if defined(CONFIG_BT_CONN)
	case BT_BUF_ACL_IN:
		hci_acl(buf);
   19bd2:	f7ff ff07 	bl	199e4 <hci_acl>
	return list->head;
   19bd6:	4b0e      	ldr	r3, [pc, #56]	; (19c10 <rx_work_handler+0x54>)
   19bd8:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
	/* Schedule the work handler to be executed again if there are
	 * additional items in the queue. This allows for other users of the
	 * work queue to get a chance at running, which wouldn't be possible if
	 * we used a while() loop with a k_yield() statement.
	 */
	if (!sys_slist_is_empty(&bt_dev.rx_queue)) {
   19bdc:	b12b      	cbz	r3, 19bea <rx_work_handler+0x2e>

#if defined(CONFIG_BT_RECV_WORKQ_SYS)
		err = k_work_submit(&rx_work);
#elif defined(CONFIG_BT_RECV_WORKQ_BT)
		err = k_work_submit_to_queue(&bt_workq, &rx_work);
   19bde:	490d      	ldr	r1, [pc, #52]	; (19c14 <rx_work_handler+0x58>)
   19be0:	480d      	ldr	r0, [pc, #52]	; (19c18 <rx_work_handler+0x5c>)
   19be2:	f016 ff7d 	bl	30ae0 <k_work_submit_to_queue>
#endif
		if (err < 0) {
   19be6:	1e02      	subs	r2, r0, #0
   19be8:	db0b      	blt.n	19c02 <rx_work_handler+0x46>
			BT_ERR("Could not submit rx_work: %d", err);
		}
	}
}
   19bea:	bd10      	pop	{r4, pc}
		hci_event(buf);
   19bec:	f7ff ff98 	bl	19b20 <hci_event>
		break;
   19bf0:	e7f1      	b.n	19bd6 <rx_work_handler+0x1a>
		BT_ERR("Unknown buf type %u", bt_buf_get_type(buf));
   19bf2:	2145      	movs	r1, #69	; 0x45
   19bf4:	4809      	ldr	r0, [pc, #36]	; (19c1c <rx_work_handler+0x60>)
   19bf6:	f012 fca9 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   19bfa:	4620      	mov	r0, r4
   19bfc:	f005 f98a 	bl	1ef14 <net_buf_unref>
		break;
   19c00:	e7e9      	b.n	19bd6 <rx_work_handler+0x1a>
			BT_ERR("Could not submit rx_work: %d", err);
   19c02:	2145      	movs	r1, #69	; 0x45
   19c04:	4806      	ldr	r0, [pc, #24]	; (19c20 <rx_work_handler+0x64>)
   19c06:	f012 fca1 	bl	2c54c <z_log_minimal_printk>
   19c0a:	e7ee      	b.n	19bea <rx_work_handler+0x2e>
   19c0c:	20000554 	.word	0x20000554
   19c10:	20000420 	.word	0x20000420
   19c14:	20000b00 	.word	0x20000b00
   19c18:	20002178 	.word	0x20002178
   19c1c:	00039ca0 	.word	0x00039ca0
   19c20:	00039bf4 	.word	0x00039bf4

00019c24 <bt_hci_cmd_state_set_init>:
{
   19c24:	b510      	push	{r4, lr}
   19c26:	460c      	mov	r4, r1
	state->target = target;
   19c28:	600a      	str	r2, [r1, #0]
	state->bit = bit;
   19c2a:	604b      	str	r3, [r1, #4]
	state->val = val;
   19c2c:	f89d 3008 	ldrb.w	r3, [sp, #8]
   19c30:	720b      	strb	r3, [r1, #8]
	cmd(buf)->state = state;
   19c32:	f015 f916 	bl	2ee62 <net_buf_id>
   19c36:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19c3a:	4b02      	ldr	r3, [pc, #8]	; (19c44 <bt_hci_cmd_state_set_init+0x20>)
   19c3c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19c40:	6044      	str	r4, [r0, #4]
}
   19c42:	bd10      	pop	{r4, pc}
   19c44:	20003aac 	.word	0x20003aac

00019c48 <bt_hci_cmd_create>:
{
   19c48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   19c4c:	4606      	mov	r6, r0
   19c4e:	460f      	mov	r7, r1
	return net_buf_alloc_fixed(pool, timeout);
   19c50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   19c54:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   19c58:	481e      	ldr	r0, [pc, #120]	; (19cd4 <bt_hci_cmd_create+0x8c>)
   19c5a:	f015 f927 	bl	2eeac <net_buf_alloc_fixed>
	__ASSERT_NO_MSG(buf);
   19c5e:	4604      	mov	r4, r0
   19c60:	b368      	cbz	r0, 19cbe <bt_hci_cmd_create+0x76>
	net_buf_simple_reserve(&buf->b, reserve);
   19c62:	f104 0908 	add.w	r9, r4, #8
   19c66:	2100      	movs	r1, #0
   19c68:	4648      	mov	r0, r9
   19c6a:	f005 f813 	bl	1ec94 <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   19c6e:	f04f 0800 	mov.w	r8, #0
   19c72:	f884 8014 	strb.w	r8, [r4, #20]
	cmd(buf)->opcode = opcode;
   19c76:	4620      	mov	r0, r4
   19c78:	f015 f8f3 	bl	2ee62 <net_buf_id>
   19c7c:	4d16      	ldr	r5, [pc, #88]	; (19cd8 <bt_hci_cmd_create+0x90>)
   19c7e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19c82:	eb05 0080 	add.w	r0, r5, r0, lsl #2
   19c86:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
   19c88:	4620      	mov	r0, r4
   19c8a:	f015 f8ea 	bl	2ee62 <net_buf_id>
   19c8e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19c92:	eb05 0380 	add.w	r3, r5, r0, lsl #2
   19c96:	f8c3 8008 	str.w	r8, [r3, #8]
	cmd(buf)->state = NULL;
   19c9a:	4620      	mov	r0, r4
   19c9c:	f015 f8e1 	bl	2ee62 <net_buf_id>
   19ca0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19ca4:	eb05 0580 	add.w	r5, r5, r0, lsl #2
   19ca8:	f8c5 8004 	str.w	r8, [r5, #4]
	return net_buf_simple_add(&buf->b, len);
   19cac:	2103      	movs	r1, #3
   19cae:	4648      	mov	r0, r9
   19cb0:	f005 fa48 	bl	1f144 <net_buf_simple_add>
	hdr->opcode = sys_cpu_to_le16(opcode);
   19cb4:	8006      	strh	r6, [r0, #0]
	hdr->param_len = param_len;
   19cb6:	7087      	strb	r7, [r0, #2]
}
   19cb8:	4620      	mov	r0, r4
   19cba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__ASSERT_NO_MSG(buf);
   19cbe:	4d07      	ldr	r5, [pc, #28]	; (19cdc <bt_hci_cmd_create+0x94>)
   19cc0:	22ff      	movs	r2, #255	; 0xff
   19cc2:	4629      	mov	r1, r5
   19cc4:	4806      	ldr	r0, [pc, #24]	; (19ce0 <bt_hci_cmd_create+0x98>)
   19cc6:	f012 fc32 	bl	2c52e <assert_print>
   19cca:	21ff      	movs	r1, #255	; 0xff
   19ccc:	4628      	mov	r0, r5
   19cce:	f012 fc27 	bl	2c520 <assert_post_action>
   19cd2:	e7c6      	b.n	19c62 <bt_hci_cmd_create+0x1a>
   19cd4:	20000fa0 	.word	0x20000fa0
   19cd8:	20003aac 	.word	0x20003aac
   19cdc:	00039c18 	.word	0x00039c18
   19ce0:	00031600 	.word	0x00031600

00019ce4 <bt_hci_cmd_send_sync>:
{
   19ce4:	b5f0      	push	{r4, r5, r6, r7, lr}
   19ce6:	b087      	sub	sp, #28
   19ce8:	4606      	mov	r6, r0
   19cea:	4615      	mov	r5, r2
	if (!buf) {
   19cec:	460c      	mov	r4, r1
   19cee:	b351      	cbz	r1, 19d46 <bt_hci_cmd_send_sync+0x62>
	return z_impl_k_sem_init(sem, initial_count, limit);
   19cf0:	2201      	movs	r2, #1
   19cf2:	2100      	movs	r1, #0
   19cf4:	4668      	mov	r0, sp
   19cf6:	f016 fe96 	bl	30a26 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
   19cfa:	4620      	mov	r0, r4
   19cfc:	f015 f8b1 	bl	2ee62 <net_buf_id>
   19d00:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19d04:	4b25      	ldr	r3, [pc, #148]	; (19d9c <bt_hci_cmd_send_sync+0xb8>)
   19d06:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   19d0a:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
   19d0e:	4620      	mov	r0, r4
   19d10:	f005 f938 	bl	1ef84 <net_buf_ref>
   19d14:	4601      	mov	r1, r0
   19d16:	4822      	ldr	r0, [pc, #136]	; (19da0 <bt_hci_cmd_send_sync+0xbc>)
   19d18:	f005 f8ca 	bl	1eeb0 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
   19d1c:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
   19d20:	2300      	movs	r3, #0
   19d22:	4668      	mov	r0, sp
   19d24:	f00d f976 	bl	27014 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
   19d28:	b9a8      	cbnz	r0, 19d56 <bt_hci_cmd_send_sync+0x72>
	status = cmd(buf)->status;
   19d2a:	4620      	mov	r0, r4
   19d2c:	f015 f899 	bl	2ee62 <net_buf_id>
   19d30:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   19d34:	4b19      	ldr	r3, [pc, #100]	; (19d9c <bt_hci_cmd_send_sync+0xb8>)
   19d36:	f813 7020 	ldrb.w	r7, [r3, r0, lsl #2]
	if (status) {
   19d3a:	b9cf      	cbnz	r7, 19d70 <bt_hci_cmd_send_sync+0x8c>
	if (rsp) {
   19d3c:	b34d      	cbz	r5, 19d92 <bt_hci_cmd_send_sync+0xae>
		*rsp = buf;
   19d3e:	602c      	str	r4, [r5, #0]
	return 0;
   19d40:	2000      	movs	r0, #0
}
   19d42:	b007      	add	sp, #28
   19d44:	bdf0      	pop	{r4, r5, r6, r7, pc}
		buf = bt_hci_cmd_create(opcode, 0);
   19d46:	f7ff ff7f 	bl	19c48 <bt_hci_cmd_create>
		if (!buf) {
   19d4a:	4604      	mov	r4, r0
   19d4c:	2800      	cmp	r0, #0
   19d4e:	d1cf      	bne.n	19cf0 <bt_hci_cmd_send_sync+0xc>
			return -ENOBUFS;
   19d50:	f06f 0068 	mvn.w	r0, #104	; 0x68
   19d54:	e7f5      	b.n	19d42 <bt_hci_cmd_send_sync+0x5e>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
   19d56:	f240 1247 	movw	r2, #327	; 0x147
   19d5a:	4912      	ldr	r1, [pc, #72]	; (19da4 <bt_hci_cmd_send_sync+0xc0>)
   19d5c:	4812      	ldr	r0, [pc, #72]	; (19da8 <bt_hci_cmd_send_sync+0xc4>)
   19d5e:	f012 fbe6 	bl	2c52e <assert_print>
   19d62:	4040      	eors	r0, r0
   19d64:	f380 8811 	msr	BASEPRI, r0
   19d68:	f04f 0003 	mov.w	r0, #3
   19d6c:	df02      	svc	2
   19d6e:	e7dc      	b.n	19d2a <bt_hci_cmd_send_sync+0x46>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
   19d70:	463b      	mov	r3, r7
   19d72:	4632      	mov	r2, r6
   19d74:	2157      	movs	r1, #87	; 0x57
   19d76:	480d      	ldr	r0, [pc, #52]	; (19dac <bt_hci_cmd_send_sync+0xc8>)
   19d78:	f012 fbe8 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   19d7c:	4620      	mov	r0, r4
   19d7e:	f005 f8c9 	bl	1ef14 <net_buf_unref>
		switch (status) {
   19d82:	2f09      	cmp	r7, #9
   19d84:	d002      	beq.n	19d8c <bt_hci_cmd_send_sync+0xa8>
			return -EIO;
   19d86:	f06f 0004 	mvn.w	r0, #4
   19d8a:	e7da      	b.n	19d42 <bt_hci_cmd_send_sync+0x5e>
			return -ECONNREFUSED;
   19d8c:	f06f 006e 	mvn.w	r0, #110	; 0x6e
   19d90:	e7d7      	b.n	19d42 <bt_hci_cmd_send_sync+0x5e>
		net_buf_unref(buf);
   19d92:	4620      	mov	r0, r4
   19d94:	f005 f8be 	bl	1ef14 <net_buf_unref>
	return 0;
   19d98:	2000      	movs	r0, #0
   19d9a:	e7d2      	b.n	19d42 <bt_hci_cmd_send_sync+0x5e>
   19d9c:	20003aac 	.word	0x20003aac
   19da0:	2000055c 	.word	0x2000055c
   19da4:	00039c18 	.word	0x00039c18
   19da8:	00031600 	.word	0x00031600
   19dac:	00039cbc 	.word	0x00039cbc

00019db0 <common_init>:
{
   19db0:	b510      	push	{r4, lr}
   19db2:	b082      	sub	sp, #8
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
   19db4:	4b22      	ldr	r3, [pc, #136]	; (19e40 <common_init+0x90>)
   19db6:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
   19dba:	689b      	ldr	r3, [r3, #8]
   19dbc:	f013 0f01 	tst.w	r3, #1
   19dc0:	d10d      	bne.n	19dde <common_init+0x2e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
   19dc2:	aa01      	add	r2, sp, #4
   19dc4:	2100      	movs	r1, #0
   19dc6:	f640 4003 	movw	r0, #3075	; 0xc03
   19dca:	f7ff ff8b 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   19dce:	4604      	mov	r4, r0
   19dd0:	b968      	cbnz	r0, 19dee <common_init+0x3e>
		hci_reset_complete(rsp);
   19dd2:	9801      	ldr	r0, [sp, #4]
   19dd4:	f7ff fb6a 	bl	194ac <hci_reset_complete>
		net_buf_unref(rsp);
   19dd8:	9801      	ldr	r0, [sp, #4]
   19dda:	f005 f89b 	bl	1ef14 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
   19dde:	aa01      	add	r2, sp, #4
   19de0:	2100      	movs	r1, #0
   19de2:	f241 0003 	movw	r0, #4099	; 0x1003
   19de6:	f7ff ff7d 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   19dea:	4604      	mov	r4, r0
   19dec:	b110      	cbz	r0, 19df4 <common_init+0x44>
}
   19dee:	4620      	mov	r0, r4
   19df0:	b002      	add	sp, #8
   19df2:	bd10      	pop	{r4, pc}
	read_local_features_complete(rsp);
   19df4:	9801      	ldr	r0, [sp, #4]
   19df6:	f7ff fb01 	bl	193fc <read_local_features_complete>
	net_buf_unref(rsp);
   19dfa:	9801      	ldr	r0, [sp, #4]
   19dfc:	f005 f88a 	bl	1ef14 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
   19e00:	aa01      	add	r2, sp, #4
   19e02:	2100      	movs	r1, #0
   19e04:	f241 0001 	movw	r0, #4097	; 0x1001
   19e08:	f7ff ff6c 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   19e0c:	4604      	mov	r4, r0
   19e0e:	2800      	cmp	r0, #0
   19e10:	d1ed      	bne.n	19dee <common_init+0x3e>
	read_local_ver_complete(rsp);
   19e12:	9801      	ldr	r0, [sp, #4]
   19e14:	f7ff fab8 	bl	19388 <read_local_ver_complete>
	net_buf_unref(rsp);
   19e18:	9801      	ldr	r0, [sp, #4]
   19e1a:	f005 f87b 	bl	1ef14 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
   19e1e:	aa01      	add	r2, sp, #4
   19e20:	2100      	movs	r1, #0
   19e22:	f241 0002 	movw	r0, #4098	; 0x1002
   19e26:	f7ff ff5d 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   19e2a:	4604      	mov	r4, r0
   19e2c:	2800      	cmp	r0, #0
   19e2e:	d1de      	bne.n	19dee <common_init+0x3e>
	read_supported_commands_complete(rsp);
   19e30:	9801      	ldr	r0, [sp, #4]
   19e32:	f7ff fac9 	bl	193c8 <read_supported_commands_complete>
	net_buf_unref(rsp);
   19e36:	9801      	ldr	r0, [sp, #4]
   19e38:	f005 f86c 	bl	1ef14 <net_buf_unref>
	return 0;
   19e3c:	e7d7      	b.n	19dee <common_init+0x3e>
   19e3e:	bf00      	nop
   19e40:	20000420 	.word	0x20000420

00019e44 <hci_le_read_max_data_len>:
{
   19e44:	b570      	push	{r4, r5, r6, lr}
   19e46:	b082      	sub	sp, #8
   19e48:	4605      	mov	r5, r0
   19e4a:	460c      	mov	r4, r1
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
   19e4c:	aa01      	add	r2, sp, #4
   19e4e:	2100      	movs	r1, #0
   19e50:	f242 002f 	movw	r0, #8239	; 0x202f
   19e54:	f7ff ff46 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   19e58:	4606      	mov	r6, r0
   19e5a:	b960      	cbnz	r0, 19e76 <hci_le_read_max_data_len+0x32>
	rp = (void *)rsp->data;
   19e5c:	9801      	ldr	r0, [sp, #4]
   19e5e:	6883      	ldr	r3, [r0, #8]
	*tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
   19e60:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   19e64:	802a      	strh	r2, [r5, #0]
	*tx_time = sys_le16_to_cpu(rp->max_tx_time);
   19e66:	f8b3 3003 	ldrh.w	r3, [r3, #3]
   19e6a:	8023      	strh	r3, [r4, #0]
	net_buf_unref(rsp);
   19e6c:	f005 f852 	bl	1ef14 <net_buf_unref>
}
   19e70:	4630      	mov	r0, r6
   19e72:	b002      	add	sp, #8
   19e74:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("Failed to read DLE max data len");
   19e76:	2145      	movs	r1, #69	; 0x45
   19e78:	4801      	ldr	r0, [pc, #4]	; (19e80 <hci_le_read_max_data_len+0x3c>)
   19e7a:	f012 fb67 	bl	2c54c <z_log_minimal_printk>
		return err;
   19e7e:	e7f7      	b.n	19e70 <hci_le_read_max_data_len+0x2c>
   19e80:	00039ce0 	.word	0x00039ce0

00019e84 <le_set_event_mask>:
{
   19e84:	b510      	push	{r4, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
   19e86:	2108      	movs	r1, #8
   19e88:	f242 0001 	movw	r0, #8193	; 0x2001
   19e8c:	f7ff fedc 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   19e90:	b390      	cbz	r0, 19ef8 <le_set_event_mask+0x74>
   19e92:	4604      	mov	r4, r0
   19e94:	2108      	movs	r1, #8
   19e96:	4408      	add	r0, r1
   19e98:	f005 f954 	bl	1f144 <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
   19e9c:	4b18      	ldr	r3, [pc, #96]	; (19f00 <le_set_event_mask+0x7c>)
   19e9e:	f893 10d0 	ldrb.w	r1, [r3, #208]	; 0xd0
   19ea2:	f011 0f02 	tst.w	r1, #2
   19ea6:	d124      	bne.n	19ef2 <le_set_event_mask+0x6e>
		mask |= BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE;
   19ea8:	230f      	movs	r3, #15
   19eaa:	2200      	movs	r2, #0
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
   19eac:	f011 0f20 	tst.w	r1, #32
   19eb0:	d001      	beq.n	19eb6 <le_set_event_mask+0x32>
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
   19eb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
		    (BT_FEAT_LE_PHY_2M(bt_dev.le.features) ||
   19eb6:	4912      	ldr	r1, [pc, #72]	; (19f00 <le_set_event_mask+0x7c>)
   19eb8:	f891 10d1 	ldrb.w	r1, [r1, #209]	; 0xd1
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
   19ebc:	f011 0f09 	tst.w	r1, #9
   19ec0:	d001      	beq.n	19ec6 <le_set_event_mask+0x42>
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
   19ec2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
	dst[0] = val;
   19ec6:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
   19ec8:	f3c3 2107 	ubfx	r1, r3, #8, #8
   19ecc:	7041      	strb	r1, [r0, #1]
	sys_put_le16(val >> 16, &dst[2]);
   19ece:	0c19      	lsrs	r1, r3, #16
	dst[0] = val;
   19ed0:	7081      	strb	r1, [r0, #2]
	dst[1] = val >> 8;
   19ed2:	0e1b      	lsrs	r3, r3, #24
   19ed4:	70c3      	strb	r3, [r0, #3]
	dst[0] = val;
   19ed6:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
   19ed8:	0e13      	lsrs	r3, r2, #24
   19eda:	7143      	strb	r3, [r0, #5]
	sys_put_le16(val >> 16, &dst[2]);
   19edc:	0c13      	lsrs	r3, r2, #16
	dst[0] = val;
   19ede:	7183      	strb	r3, [r0, #6]
	dst[1] = val >> 8;
   19ee0:	0e12      	lsrs	r2, r2, #24
   19ee2:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
   19ee4:	2200      	movs	r2, #0
   19ee6:	4621      	mov	r1, r4
   19ee8:	f242 0001 	movw	r0, #8193	; 0x2001
   19eec:	f7ff fefa 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   19ef0:	bd10      	pop	{r4, pc}
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
   19ef2:	232f      	movs	r3, #47	; 0x2f
   19ef4:	2200      	movs	r2, #0
   19ef6:	e7d9      	b.n	19eac <le_set_event_mask+0x28>
		return -ENOBUFS;
   19ef8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   19efc:	e7f8      	b.n	19ef0 <le_set_event_mask+0x6c>
   19efe:	bf00      	nop
   19f00:	20000420 	.word	0x20000420

00019f04 <le_init>:
{
   19f04:	b510      	push	{r4, lr}
   19f06:	b082      	sub	sp, #8
	if (!BT_FEAT_LE(bt_dev.features)) {
   19f08:	4b49      	ldr	r3, [pc, #292]	; (1a030 <le_init+0x12c>)
   19f0a:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
   19f0e:	f013 0f40 	tst.w	r3, #64	; 0x40
   19f12:	d00a      	beq.n	19f2a <le_init+0x26>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
   19f14:	aa01      	add	r2, sp, #4
   19f16:	2100      	movs	r1, #0
   19f18:	f242 0003 	movw	r0, #8195	; 0x2003
   19f1c:	f7ff fee2 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   19f20:	4603      	mov	r3, r0
   19f22:	b148      	cbz	r0, 19f38 <le_init+0x34>
}
   19f24:	4618      	mov	r0, r3
   19f26:	b002      	add	sp, #8
   19f28:	bd10      	pop	{r4, pc}
		BT_ERR("Non-LE capable controller detected!");
   19f2a:	2145      	movs	r1, #69	; 0x45
   19f2c:	4841      	ldr	r0, [pc, #260]	; (1a034 <le_init+0x130>)
   19f2e:	f012 fb0d 	bl	2c54c <z_log_minimal_printk>
		return -ENODEV;
   19f32:	f06f 0312 	mvn.w	r3, #18
   19f36:	e7f5      	b.n	19f24 <le_init+0x20>
	read_le_features_complete(rsp);
   19f38:	9801      	ldr	r0, [sp, #4]
   19f3a:	f7ff fa3b 	bl	193b4 <read_le_features_complete>
	net_buf_unref(rsp);
   19f3e:	9801      	ldr	r0, [sp, #4]
   19f40:	f004 ffe8 	bl	1ef14 <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
   19f44:	aa01      	add	r2, sp, #4
   19f46:	2100      	movs	r1, #0
   19f48:	f242 0002 	movw	r0, #8194	; 0x2002
   19f4c:	f7ff feca 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   19f50:	4603      	mov	r3, r0
   19f52:	2800      	cmp	r0, #0
   19f54:	d1e6      	bne.n	19f24 <le_init+0x20>
		le_read_buffer_size_complete(rsp);
   19f56:	9801      	ldr	r0, [sp, #4]
   19f58:	f7ff fac2 	bl	194e0 <le_read_buffer_size_complete>
		net_buf_unref(rsp);
   19f5c:	9801      	ldr	r0, [sp, #4]
   19f5e:	f004 ffd9 	bl	1ef14 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
   19f62:	4b33      	ldr	r3, [pc, #204]	; (1a030 <le_init+0x12c>)
   19f64:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
   19f68:	f013 0f20 	tst.w	r3, #32
   19f6c:	d032      	beq.n	19fd4 <le_init+0xd0>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
   19f6e:	4b30      	ldr	r3, [pc, #192]	; (1a030 <le_init+0x12c>)
   19f70:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
   19f74:	f013 0f08 	tst.w	r3, #8
   19f78:	d144      	bne.n	1a004 <le_init+0x100>
	    BT_FEAT_LE_DLE(bt_dev.le.features)) {
   19f7a:	4b2d      	ldr	r3, [pc, #180]	; (1a030 <le_init+0x12c>)
   19f7c:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
	if (IS_ENABLED(CONFIG_BT_CONN) &&
   19f80:	f013 0f20 	tst.w	r3, #32
   19f84:	d022      	beq.n	19fcc <le_init+0xc8>
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
   19f86:	f10d 0102 	add.w	r1, sp, #2
   19f8a:	4668      	mov	r0, sp
   19f8c:	f7ff ff5a 	bl	19e44 <hci_le_read_max_data_len>
		if (err) {
   19f90:	4603      	mov	r3, r0
   19f92:	2800      	cmp	r0, #0
   19f94:	d1c6      	bne.n	19f24 <le_init+0x20>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   19f96:	2104      	movs	r1, #4
   19f98:	f242 0024 	movw	r0, #8228	; 0x2024
   19f9c:	f7ff fe54 	bl	19c48 <bt_hci_cmd_create>
		if (!buf) {
   19fa0:	4604      	mov	r4, r0
   19fa2:	2800      	cmp	r0, #0
   19fa4:	d03e      	beq.n	1a024 <le_init+0x120>
   19fa6:	2104      	movs	r1, #4
   19fa8:	3008      	adds	r0, #8
   19faa:	f005 f8cb 	bl	1f144 <net_buf_simple_add>
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
   19fae:	f8bd 3000 	ldrh.w	r3, [sp]
   19fb2:	8003      	strh	r3, [r0, #0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
   19fb4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   19fb8:	8043      	strh	r3, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   19fba:	2200      	movs	r2, #0
   19fbc:	4621      	mov	r1, r4
   19fbe:	f242 0024 	movw	r0, #8228	; 0x2024
   19fc2:	f7ff fe8f 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   19fc6:	4603      	mov	r3, r0
   19fc8:	2800      	cmp	r0, #0
   19fca:	d1ab      	bne.n	19f24 <le_init+0x20>
	return  le_set_event_mask();
   19fcc:	f7ff ff5a 	bl	19e84 <le_set_event_mask>
   19fd0:	4603      	mov	r3, r0
   19fd2:	e7a7      	b.n	19f24 <le_init+0x20>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
   19fd4:	2102      	movs	r1, #2
   19fd6:	f640 406d 	movw	r0, #3181	; 0xc6d
   19fda:	f7ff fe35 	bl	19c48 <bt_hci_cmd_create>
		if (!buf) {
   19fde:	4604      	mov	r4, r0
   19fe0:	b318      	cbz	r0, 1a02a <le_init+0x126>
   19fe2:	2102      	movs	r1, #2
   19fe4:	3008      	adds	r0, #8
   19fe6:	f005 f8ad 	bl	1f144 <net_buf_simple_add>
		cp_le->le = 0x01;
   19fea:	2301      	movs	r3, #1
   19fec:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
   19fee:	2200      	movs	r2, #0
   19ff0:	7042      	strb	r2, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
   19ff2:	4621      	mov	r1, r4
   19ff4:	f640 406d 	movw	r0, #3181	; 0xc6d
   19ff8:	f7ff fe74 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   19ffc:	4603      	mov	r3, r0
   19ffe:	2800      	cmp	r0, #0
   1a000:	d0b5      	beq.n	19f6e <le_init+0x6a>
   1a002:	e78f      	b.n	19f24 <le_init+0x20>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
   1a004:	aa01      	add	r2, sp, #4
   1a006:	2100      	movs	r1, #0
   1a008:	f242 001c 	movw	r0, #8220	; 0x201c
   1a00c:	f7ff fe6a 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   1a010:	4603      	mov	r3, r0
   1a012:	2800      	cmp	r0, #0
   1a014:	d186      	bne.n	19f24 <le_init+0x20>
		le_read_supp_states_complete(rsp);
   1a016:	9801      	ldr	r0, [sp, #4]
   1a018:	f7ff f9fa 	bl	19410 <le_read_supp_states_complete>
		net_buf_unref(rsp);
   1a01c:	9801      	ldr	r0, [sp, #4]
   1a01e:	f004 ff79 	bl	1ef14 <net_buf_unref>
   1a022:	e7aa      	b.n	19f7a <le_init+0x76>
			return -ENOBUFS;
   1a024:	f06f 0368 	mvn.w	r3, #104	; 0x68
   1a028:	e77c      	b.n	19f24 <le_init+0x20>
			return -ENOBUFS;
   1a02a:	f06f 0368 	mvn.w	r3, #104	; 0x68
   1a02e:	e779      	b.n	19f24 <le_init+0x20>
   1a030:	20000420 	.word	0x20000420
   1a034:	00039d08 	.word	0x00039d08

0001a038 <bt_br_init>:
{
   1a038:	b510      	push	{r4, lr}
   1a03a:	b082      	sub	sp, #8
	if (bt_dev.le.acl_mtu) {
   1a03c:	4b0b      	ldr	r3, [pc, #44]	; (1a06c <bt_br_init+0x34>)
   1a03e:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
   1a042:	b11b      	cbz	r3, 1a04c <bt_br_init+0x14>
		return 0;
   1a044:	2400      	movs	r4, #0
}
   1a046:	4620      	mov	r0, r4
   1a048:	b002      	add	sp, #8
   1a04a:	bd10      	pop	{r4, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
   1a04c:	aa01      	add	r2, sp, #4
   1a04e:	2100      	movs	r1, #0
   1a050:	f241 0005 	movw	r0, #4101	; 0x1005
   1a054:	f7ff fe46 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1a058:	4604      	mov	r4, r0
   1a05a:	2800      	cmp	r0, #0
   1a05c:	d1f3      	bne.n	1a046 <bt_br_init+0xe>
	read_buffer_size_complete(rsp);
   1a05e:	9801      	ldr	r0, [sp, #4]
   1a060:	f7ff fa52 	bl	19508 <read_buffer_size_complete>
	net_buf_unref(rsp);
   1a064:	9801      	ldr	r0, [sp, #4]
   1a066:	f004 ff55 	bl	1ef14 <net_buf_unref>
	return 0;
   1a06a:	e7ec      	b.n	1a046 <bt_br_init+0xe>
   1a06c:	20000420 	.word	0x20000420

0001a070 <hci_vs_init>:
{
   1a070:	b510      	push	{r4, lr}
   1a072:	b082      	sub	sp, #8
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
   1a074:	aa01      	add	r2, sp, #4
   1a076:	2100      	movs	r1, #0
   1a078:	f64f 4001 	movw	r0, #64513	; 0xfc01
   1a07c:	f7ff fe32 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1a080:	bb38      	cbnz	r0, 1a0d2 <hci_vs_init+0x62>
	net_buf_unref(rsp);
   1a082:	9801      	ldr	r0, [sp, #4]
   1a084:	f004 ff46 	bl	1ef14 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
   1a088:	aa01      	add	r2, sp, #4
   1a08a:	2100      	movs	r1, #0
   1a08c:	f64f 4002 	movw	r0, #64514	; 0xfc02
   1a090:	f7ff fe28 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1a094:	bb18      	cbnz	r0, 1a0de <hci_vs_init+0x6e>
	rp.cmds = (void *)rsp->data;
   1a096:	9801      	ldr	r0, [sp, #4]
   1a098:	6883      	ldr	r3, [r0, #8]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
   1a09a:	f8b3 3001 	ldrh.w	r3, [r3, #1]
   1a09e:	4c15      	ldr	r4, [pc, #84]	; (1a0f4 <hci_vs_init+0x84>)
   1a0a0:	f8a4 30b9 	strh.w	r3, [r4, #185]	; 0xb9
	net_buf_unref(rsp);
   1a0a4:	f004 ff36 	bl	1ef14 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
   1a0a8:	f894 30b9 	ldrb.w	r3, [r4, #185]	; 0xb9
   1a0ac:	f013 0f04 	tst.w	r3, #4
   1a0b0:	d013      	beq.n	1a0da <hci_vs_init+0x6a>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
   1a0b2:	aa01      	add	r2, sp, #4
   1a0b4:	2100      	movs	r1, #0
   1a0b6:	f64f 4003 	movw	r0, #64515	; 0xfc03
   1a0ba:	f7ff fe13 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   1a0be:	b998      	cbnz	r0, 1a0e8 <hci_vs_init+0x78>
		rp.feat = (void *)rsp->data;
   1a0c0:	9801      	ldr	r0, [sp, #4]
   1a0c2:	6883      	ldr	r3, [r0, #8]
		memcpy(bt_dev.vs_features, rp.feat->features,
   1a0c4:	785a      	ldrb	r2, [r3, #1]
   1a0c6:	4b0b      	ldr	r3, [pc, #44]	; (1a0f4 <hci_vs_init+0x84>)
   1a0c8:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
		net_buf_unref(rsp);
   1a0cc:	f004 ff22 	bl	1ef14 <net_buf_unref>
   1a0d0:	e003      	b.n	1a0da <hci_vs_init+0x6a>
		BT_WARN("Vendor HCI extensions not available");
   1a0d2:	2157      	movs	r1, #87	; 0x57
   1a0d4:	4808      	ldr	r0, [pc, #32]	; (1a0f8 <hci_vs_init+0x88>)
   1a0d6:	f012 fa39 	bl	2c54c <z_log_minimal_printk>
}
   1a0da:	b002      	add	sp, #8
   1a0dc:	bd10      	pop	{r4, pc}
		BT_WARN("Failed to read supported vendor commands");
   1a0de:	2157      	movs	r1, #87	; 0x57
   1a0e0:	4806      	ldr	r0, [pc, #24]	; (1a0fc <hci_vs_init+0x8c>)
   1a0e2:	f012 fa33 	bl	2c54c <z_log_minimal_printk>
		return;
   1a0e6:	e7f8      	b.n	1a0da <hci_vs_init+0x6a>
			BT_WARN("Failed to read supported vendor features");
   1a0e8:	2157      	movs	r1, #87	; 0x57
   1a0ea:	4805      	ldr	r0, [pc, #20]	; (1a100 <hci_vs_init+0x90>)
   1a0ec:	f012 fa2e 	bl	2c54c <z_log_minimal_printk>
			return;
   1a0f0:	e7f3      	b.n	1a0da <hci_vs_init+0x6a>
   1a0f2:	bf00      	nop
   1a0f4:	20000420 	.word	0x20000420
   1a0f8:	00039d34 	.word	0x00039d34
   1a0fc:	00039d60 	.word	0x00039d60
   1a100:	00039d90 	.word	0x00039d90

0001a104 <hci_init>:
{
   1a104:	b508      	push	{r3, lr}
	err = common_init();
   1a106:	f7ff fe53 	bl	19db0 <common_init>
	if (err) {
   1a10a:	4603      	mov	r3, r0
   1a10c:	b108      	cbz	r0, 1a112 <hci_init+0xe>
}
   1a10e:	4618      	mov	r0, r3
   1a110:	bd08      	pop	{r3, pc}
	err = le_init();
   1a112:	f7ff fef7 	bl	19f04 <le_init>
	if (err) {
   1a116:	4603      	mov	r3, r0
   1a118:	2800      	cmp	r0, #0
   1a11a:	d1f8      	bne.n	1a10e <hci_init+0xa>
	if (BT_FEAT_BREDR(bt_dev.features)) {
   1a11c:	4b10      	ldr	r3, [pc, #64]	; (1a160 <hci_init+0x5c>)
   1a11e:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
   1a122:	f013 0f20 	tst.w	r3, #32
   1a126:	d00e      	beq.n	1a146 <hci_init+0x42>
	else if (!bt_dev.le.acl_mtu) {
   1a128:	4b0d      	ldr	r3, [pc, #52]	; (1a160 <hci_init+0x5c>)
   1a12a:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
   1a12e:	b183      	cbz	r3, 1a152 <hci_init+0x4e>
	err = set_event_mask();
   1a130:	f012 fca0 	bl	2ca74 <set_event_mask>
	if (err) {
   1a134:	4603      	mov	r3, r0
   1a136:	2800      	cmp	r0, #0
   1a138:	d1e9      	bne.n	1a10e <hci_init+0xa>
	hci_vs_init();
   1a13a:	f7ff ff99 	bl	1a070 <hci_vs_init>
	err = bt_id_init();
   1a13e:	f000 fd29 	bl	1ab94 <bt_id_init>
   1a142:	4603      	mov	r3, r0
	if (err) {
   1a144:	e7e3      	b.n	1a10e <hci_init+0xa>
		err = bt_br_init();
   1a146:	f7ff ff77 	bl	1a038 <bt_br_init>
		if (err) {
   1a14a:	4603      	mov	r3, r0
   1a14c:	2800      	cmp	r0, #0
   1a14e:	d0ef      	beq.n	1a130 <hci_init+0x2c>
   1a150:	e7dd      	b.n	1a10e <hci_init+0xa>
		BT_ERR("ACL BR/EDR buffers not initialized");
   1a152:	2145      	movs	r1, #69	; 0x45
   1a154:	4803      	ldr	r0, [pc, #12]	; (1a164 <hci_init+0x60>)
   1a156:	f012 f9f9 	bl	2c54c <z_log_minimal_printk>
		return -EIO;
   1a15a:	f06f 0304 	mvn.w	r3, #4
   1a15e:	e7d6      	b.n	1a10e <hci_init+0xa>
   1a160:	20000420 	.word	0x20000420
   1a164:	00039dc0 	.word	0x00039dc0

0001a168 <bt_hci_le_rand>:
{
   1a168:	b570      	push	{r4, r5, r6, lr}
   1a16a:	b082      	sub	sp, #8
   1a16c:	4606      	mov	r6, r0
   1a16e:	460c      	mov	r4, r1
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
   1a170:	4b12      	ldr	r3, [pc, #72]	; (1a1bc <bt_hci_le_rand+0x54>)
   1a172:	f993 3093 	ldrsb.w	r3, [r3, #147]	; 0x93
   1a176:	2b00      	cmp	r3, #0
   1a178:	da1d      	bge.n	1a1b6 <bt_hci_le_rand+0x4e>
	while (len > 0) {
   1a17a:	b1c4      	cbz	r4, 1a1ae <bt_hci_le_rand+0x46>
		count = MIN(len, sizeof(rp->rand));
   1a17c:	4625      	mov	r5, r4
   1a17e:	2c08      	cmp	r4, #8
   1a180:	bf28      	it	cs
   1a182:	2508      	movcs	r5, #8
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
   1a184:	aa01      	add	r2, sp, #4
   1a186:	2100      	movs	r1, #0
   1a188:	f242 0018 	movw	r0, #8216	; 0x2018
   1a18c:	f7ff fdaa 	bl	19ce4 <bt_hci_cmd_send_sync>
		if (err) {
   1a190:	4603      	mov	r3, r0
   1a192:	b968      	cbnz	r0, 1a1b0 <bt_hci_le_rand+0x48>
		rp = (void *)rsp->data;
   1a194:	9b01      	ldr	r3, [sp, #4]
   1a196:	6899      	ldr	r1, [r3, #8]
   1a198:	462a      	mov	r2, r5
   1a19a:	3101      	adds	r1, #1
   1a19c:	4630      	mov	r0, r6
   1a19e:	f016 fe62 	bl	30e66 <memcpy>
		net_buf_unref(rsp);
   1a1a2:	9801      	ldr	r0, [sp, #4]
   1a1a4:	f004 feb6 	bl	1ef14 <net_buf_unref>
		buffer = (uint8_t *)buffer + count;
   1a1a8:	442e      	add	r6, r5
		len -= count;
   1a1aa:	1b64      	subs	r4, r4, r5
   1a1ac:	e7e5      	b.n	1a17a <bt_hci_le_rand+0x12>
	return 0;
   1a1ae:	2300      	movs	r3, #0
}
   1a1b0:	4618      	mov	r0, r3
   1a1b2:	b002      	add	sp, #8
   1a1b4:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOTSUP;
   1a1b6:	f06f 0385 	mvn.w	r3, #133	; 0x85
   1a1ba:	e7f9      	b.n	1a1b0 <bt_hci_le_rand+0x48>
   1a1bc:	20000420 	.word	0x20000420

0001a1c0 <conn_auto_initiate>:
	if (conn->state != BT_CONN_CONNECTED) {
   1a1c0:	7a83      	ldrb	r3, [r0, #10]
   1a1c2:	2b07      	cmp	r3, #7
   1a1c4:	d000      	beq.n	1a1c8 <conn_auto_initiate+0x8>
   1a1c6:	4770      	bx	lr
{
   1a1c8:	b510      	push	{r4, lr}
   1a1ca:	b084      	sub	sp, #16
   1a1cc:	4604      	mov	r4, r0
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1a1ce:	f3bf 8f5b 	dmb	ish
   1a1d2:	6843      	ldr	r3, [r0, #4]
   1a1d4:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
   1a1d8:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   1a1dc:	d10c      	bne.n	1a1f8 <conn_auto_initiate+0x38>
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
   1a1de:	78c3      	ldrb	r3, [r0, #3]
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
   1a1e0:	b12b      	cbz	r3, 1a1ee <conn_auto_initiate+0x2e>
	     BT_FEAT_LE_PER_INIT_FEAT_XCHG(bt_dev.le.features))) {
   1a1e2:	4b27      	ldr	r3, [pc, #156]	; (1a280 <conn_auto_initiate+0xc0>)
   1a1e4:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
   1a1e8:	f013 0f08 	tst.w	r3, #8
   1a1ec:	d004      	beq.n	1a1f8 <conn_auto_initiate+0x38>
		err = hci_le_read_remote_features(conn);
   1a1ee:	4620      	mov	r0, r4
   1a1f0:	f012 fc62 	bl	2cab8 <hci_le_read_remote_features>
		if (err) {
   1a1f4:	4602      	mov	r2, r0
   1a1f6:	b9c0      	cbnz	r0, 1a22a <conn_auto_initiate+0x6a>
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&
   1a1f8:	4b21      	ldr	r3, [pc, #132]	; (1a280 <conn_auto_initiate+0xc0>)
   1a1fa:	f893 30d1 	ldrb.w	r3, [r3, #209]	; 0xd1
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
   1a1fe:	f013 0f01 	tst.w	r3, #1
   1a202:	d003      	beq.n	1a20c <conn_auto_initiate+0x4c>
	    !skip_auto_phy_update_on_conn_establishment(conn)) {
   1a204:	4620      	mov	r0, r4
   1a206:	f012 fc1b 	bl	2ca40 <skip_auto_phy_update_on_conn_establishment>
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&
   1a20a:	b198      	cbz	r0, 1a234 <conn_auto_initiate+0x74>
	    BT_FEAT_LE_DLE(bt_dev.le.features)) {
   1a20c:	4b1c      	ldr	r3, [pc, #112]	; (1a280 <conn_auto_initiate+0xc0>)
   1a20e:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
	if (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
   1a212:	f013 0f20 	tst.w	r3, #32
   1a216:	d006      	beq.n	1a226 <conn_auto_initiate+0x66>
		if (IS_BT_QUIRK_NO_AUTO_DLE(&bt_dev)) {
   1a218:	4b19      	ldr	r3, [pc, #100]	; (1a280 <conn_auto_initiate+0xc0>)
   1a21a:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
   1a21e:	689b      	ldr	r3, [r3, #8]
   1a220:	f013 0f02 	tst.w	r3, #2
   1a224:	d115      	bne.n	1a252 <conn_auto_initiate+0x92>
}
   1a226:	b004      	add	sp, #16
   1a228:	bd10      	pop	{r4, pc}
			BT_ERR("Failed read remote features (%d)", err);
   1a22a:	2145      	movs	r1, #69	; 0x45
   1a22c:	4815      	ldr	r0, [pc, #84]	; (1a284 <conn_auto_initiate+0xc4>)
   1a22e:	f012 f98d 	bl	2c54c <z_log_minimal_printk>
   1a232:	e7e1      	b.n	1a1f8 <conn_auto_initiate+0x38>
		err = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,
   1a234:	2100      	movs	r1, #0
   1a236:	9100      	str	r1, [sp, #0]
   1a238:	2302      	movs	r3, #2
   1a23a:	461a      	mov	r2, r3
   1a23c:	4620      	mov	r0, r4
   1a23e:	f012 fc8b 	bl	2cb58 <bt_le_set_phy>
		if (err) {
   1a242:	4602      	mov	r2, r0
   1a244:	2800      	cmp	r0, #0
   1a246:	d0e1      	beq.n	1a20c <conn_auto_initiate+0x4c>
			BT_ERR("Failed LE Set PHY (%d)", err);
   1a248:	2145      	movs	r1, #69	; 0x45
   1a24a:	480f      	ldr	r0, [pc, #60]	; (1a288 <conn_auto_initiate+0xc8>)
   1a24c:	f012 f97e 	bl	2c54c <z_log_minimal_printk>
   1a250:	e7dc      	b.n	1a20c <conn_auto_initiate+0x4c>
			err = hci_le_read_max_data_len(&tx_octets, &tx_time);
   1a252:	f10d 010e 	add.w	r1, sp, #14
   1a256:	a803      	add	r0, sp, #12
   1a258:	f7ff fdf4 	bl	19e44 <hci_le_read_max_data_len>
			if (!err) {
   1a25c:	2800      	cmp	r0, #0
   1a25e:	d1e2      	bne.n	1a226 <conn_auto_initiate+0x66>
				err = bt_le_set_data_len(conn,
   1a260:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   1a264:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   1a268:	4620      	mov	r0, r4
   1a26a:	f012 fc58 	bl	2cb1e <bt_le_set_data_len>
				if (err) {
   1a26e:	4602      	mov	r2, r0
   1a270:	2800      	cmp	r0, #0
   1a272:	d0d8      	beq.n	1a226 <conn_auto_initiate+0x66>
					BT_ERR("Failed to set data len (%d)", err);
   1a274:	2145      	movs	r1, #69	; 0x45
   1a276:	4805      	ldr	r0, [pc, #20]	; (1a28c <conn_auto_initiate+0xcc>)
   1a278:	f012 f968 	bl	2c54c <z_log_minimal_printk>
		}
   1a27c:	e7d3      	b.n	1a226 <conn_auto_initiate+0x66>
   1a27e:	bf00      	nop
   1a280:	20000420 	.word	0x20000420
   1a284:	00039de8 	.word	0x00039de8
   1a288:	00039e10 	.word	0x00039e10
   1a28c:	00039e2c 	.word	0x00039e2c

0001a290 <bt_hci_le_enh_conn_complete>:
{
   1a290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a294:	b084      	sub	sp, #16
   1a296:	4604      	mov	r4, r0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   1a298:	f8b0 7001 	ldrh.w	r7, [r0, #1]
   1a29c:	fa1f f887 	uxth.w	r8, r7
	bool is_disconnected = conn_handle_is_disconnected(handle);
   1a2a0:	4640      	mov	r0, r8
   1a2a2:	f7ff f85b 	bl	1935c <conn_handle_is_disconnected>
   1a2a6:	4606      	mov	r6, r0
	if (evt->status) {
   1a2a8:	7820      	ldrb	r0, [r4, #0]
   1a2aa:	b150      	cbz	r0, 1a2c2 <bt_hci_le_enh_conn_complete+0x32>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1a2ac:	283c      	cmp	r0, #60	; 0x3c
   1a2ae:	d005      	beq.n	1a2bc <bt_hci_le_enh_conn_complete+0x2c>
		BT_WARN("Unexpected status 0x%02x", evt->status);
   1a2b0:	4602      	mov	r2, r0
   1a2b2:	2157      	movs	r1, #87	; 0x57
   1a2b4:	4861      	ldr	r0, [pc, #388]	; (1a43c <bt_hci_le_enh_conn_complete+0x1ac>)
   1a2b6:	f012 f949 	bl	2c54c <z_log_minimal_printk>
		return;
   1a2ba:	e056      	b.n	1a36a <bt_hci_le_enh_conn_complete+0xda>
			le_conn_complete_adv_timeout();
   1a2bc:	f7ff f960 	bl	19580 <le_conn_complete_adv_timeout>
			return;
   1a2c0:	e053      	b.n	1a36a <bt_hci_le_enh_conn_complete+0xda>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   1a2c2:	7923      	ldrb	r3, [r4, #4]
   1a2c4:	3b02      	subs	r3, #2
   1a2c6:	b2db      	uxtb	r3, r3
   1a2c8:	2b01      	cmp	r3, #1
   1a2ca:	d951      	bls.n	1a370 <bt_hci_le_enh_conn_complete+0xe0>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
   1a2cc:	78e3      	ldrb	r3, [r4, #3]
   1a2ce:	2b01      	cmp	r3, #1
   1a2d0:	d067      	beq.n	1a3a2 <bt_hci_le_enh_conn_complete+0x112>
				bt_lookup_id_addr(id, &evt->peer_addr));
   1a2d2:	1d25      	adds	r5, r4, #4
		bt_addr_le_copy(&id_addr,
   1a2d4:	4629      	mov	r1, r5
   1a2d6:	f012 fd07 	bl	2cce8 <bt_lookup_id_addr>
   1a2da:	4603      	mov	r3, r0
	memcpy(dst, src, sizeof(*dst));
   1a2dc:	6800      	ldr	r0, [r0, #0]
   1a2de:	9000      	str	r0, [sp, #0]
   1a2e0:	889a      	ldrh	r2, [r3, #4]
   1a2e2:	799b      	ldrb	r3, [r3, #6]
   1a2e4:	f8ad 2004 	strh.w	r2, [sp, #4]
   1a2e8:	f88d 3006 	strb.w	r3, [sp, #6]
   1a2ec:	6860      	ldr	r0, [r4, #4]
   1a2ee:	9002      	str	r0, [sp, #8]
   1a2f0:	8922      	ldrh	r2, [r4, #8]
   1a2f2:	7aa3      	ldrb	r3, [r4, #10]
   1a2f4:	f8ad 200c 	strh.w	r2, [sp, #12]
   1a2f8:	f88d 300e 	strb.w	r3, [sp, #14]
	conn = find_pending_connect(evt->role, &id_addr);
   1a2fc:	4669      	mov	r1, sp
   1a2fe:	78e0      	ldrb	r0, [r4, #3]
   1a300:	f7ff f918 	bl	19534 <find_pending_connect>
   1a304:	4605      	mov	r5, r0
	    evt->role == BT_HCI_ROLE_PERIPHERAL &&
   1a306:	78e3      	ldrb	r3, [r4, #3]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1a308:	2b01      	cmp	r3, #1
   1a30a:	d04e      	beq.n	1a3aa <bt_hci_le_enh_conn_complete+0x11a>
	if (!conn) {
   1a30c:	2d00      	cmp	r5, #0
   1a30e:	d05f      	beq.n	1a3d0 <bt_hci_le_enh_conn_complete+0x140>
	conn->handle = handle;
   1a310:	462b      	mov	r3, r5
   1a312:	f823 7b90 	strh.w	r7, [r3], #144
   1a316:	9800      	ldr	r0, [sp, #0]
   1a318:	f8c5 0090 	str.w	r0, [r5, #144]	; 0x90
   1a31c:	f8bd 1004 	ldrh.w	r1, [sp, #4]
   1a320:	f89d 2006 	ldrb.w	r2, [sp, #6]
   1a324:	8099      	strh	r1, [r3, #4]
   1a326:	719a      	strb	r2, [r3, #6]
	conn->le.interval = sys_le16_to_cpu(evt->interval);
   1a328:	f8b4 3017 	ldrh.w	r3, [r4, #23]
   1a32c:	f8a5 30a6 	strh.w	r3, [r5, #166]	; 0xa6
	conn->le.latency = sys_le16_to_cpu(evt->latency);
   1a330:	f8b4 3019 	ldrh.w	r3, [r4, #25]
   1a334:	f8a5 30ac 	strh.w	r3, [r5, #172]	; 0xac
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   1a338:	f8b4 301b 	ldrh.w	r3, [r4, #27]
   1a33c:	f8a5 30ae 	strh.w	r3, [r5, #174]	; 0xae
	conn->role = evt->role;
   1a340:	78e3      	ldrb	r3, [r4, #3]
   1a342:	70eb      	strb	r3, [r5, #3]
	conn->err = 0U;
   1a344:	2200      	movs	r2, #0
   1a346:	726a      	strb	r2, [r5, #9]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1a348:	2b01      	cmp	r3, #1
   1a34a:	d04e      	beq.n	1a3ea <bt_hci_le_enh_conn_complete+0x15a>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
   1a34c:	2107      	movs	r1, #7
   1a34e:	4628      	mov	r0, r5
   1a350:	f001 f9a6 	bl	1b6a0 <bt_conn_set_state>
	if (is_disconnected) {
   1a354:	2e00      	cmp	r6, #0
   1a356:	d16b      	bne.n	1a430 <bt_hci_le_enh_conn_complete+0x1a0>
	bt_conn_connected(conn);
   1a358:	4628      	mov	r0, r5
   1a35a:	f012 ff54 	bl	2d206 <bt_conn_connected>
	conn_auto_initiate(conn);
   1a35e:	4628      	mov	r0, r5
   1a360:	f7ff ff2e 	bl	1a1c0 <conn_auto_initiate>
	bt_conn_unref(conn);
   1a364:	4628      	mov	r0, r5
   1a366:	f001 f95f 	bl	1b628 <bt_conn_unref>
}
   1a36a:	b004      	add	sp, #16
   1a36c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a370:	6860      	ldr	r0, [r4, #4]
   1a372:	9000      	str	r0, [sp, #0]
   1a374:	8922      	ldrh	r2, [r4, #8]
   1a376:	7aa3      	ldrb	r3, [r4, #10]
   1a378:	f8ad 2004 	strh.w	r2, [sp, #4]
   1a37c:	f88d 3006 	strb.w	r3, [sp, #6]
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
   1a380:	f89d 3000 	ldrb.w	r3, [sp]
   1a384:	3b02      	subs	r3, #2
   1a386:	f88d 3000 	strb.w	r3, [sp]
	memcpy(dst, src, sizeof(*dst));
   1a38a:	f8d4 3011 	ldr.w	r3, [r4, #17]
   1a38e:	f8cd 3009 	str.w	r3, [sp, #9]
   1a392:	f8b4 3015 	ldrh.w	r3, [r4, #21]
   1a396:	f8ad 300d 	strh.w	r3, [sp, #13]
		peer_addr.type = BT_ADDR_LE_RANDOM;
   1a39a:	2301      	movs	r3, #1
   1a39c:	f88d 3008 	strb.w	r3, [sp, #8]
   1a3a0:	e7ac      	b.n	1a2fc <bt_hci_le_enh_conn_complete+0x6c>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
   1a3a2:	4b27      	ldr	r3, [pc, #156]	; (1a440 <bt_hci_le_enh_conn_complete+0x1b0>)
   1a3a4:	f893 0067 	ldrb.w	r0, [r3, #103]	; 0x67
   1a3a8:	e793      	b.n	1a2d2 <bt_hci_le_enh_conn_complete+0x42>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   1a3aa:	f000 fd47 	bl	1ae3c <bt_le_adv_lookup_legacy>
		atomic_clear_bit(adv->flags, BT_ADV_ENABLED);
   1a3ae:	f100 0310 	add.w	r3, r0, #16
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1a3b2:	f3bf 8f5b 	dmb	ish
   1a3b6:	e853 2f00 	ldrex	r2, [r3]
   1a3ba:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   1a3be:	e843 2100 	strex	r1, r2, [r3]
   1a3c2:	2900      	cmp	r1, #0
   1a3c4:	d1f7      	bne.n	1a3b6 <bt_hci_le_enh_conn_complete+0x126>
   1a3c6:	f3bf 8f5b 	dmb	ish
		(void)bt_le_lim_adv_cancel_timeout(adv);
   1a3ca:	f012 fdf4 	bl	2cfb6 <bt_le_lim_adv_cancel_timeout>
   1a3ce:	e79d      	b.n	1a30c <bt_hci_le_enh_conn_complete+0x7c>
		BT_ERR("No pending conn for peer %s",
   1a3d0:	1d20      	adds	r0, r4, #4
   1a3d2:	f7fe fe71 	bl	190b8 <bt_addr_le_str_real>
   1a3d6:	4602      	mov	r2, r0
   1a3d8:	2145      	movs	r1, #69	; 0x45
   1a3da:	481a      	ldr	r0, [pc, #104]	; (1a444 <bt_hci_le_enh_conn_complete+0x1b4>)
   1a3dc:	f012 f8b6 	bl	2c54c <z_log_minimal_printk>
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
   1a3e0:	211f      	movs	r1, #31
   1a3e2:	4640      	mov	r0, r8
   1a3e4:	f012 fb81 	bl	2caea <bt_hci_disconnect>
		return;
   1a3e8:	e7bf      	b.n	1a36a <bt_hci_le_enh_conn_complete+0xda>
   1a3ea:	9802      	ldr	r0, [sp, #8]
   1a3ec:	f8c5 0097 	str.w	r0, [r5, #151]	; 0x97
   1a3f0:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   1a3f4:	f89d 300e 	ldrb.w	r3, [sp, #14]
   1a3f8:	f8a5 209b 	strh.w	r2, [r5, #155]	; 0x9b
   1a3fc:	f885 309d 	strb.w	r3, [r5, #157]	; 0x9d
			struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   1a400:	f000 fd1c 	bl	1ae3c <bt_le_adv_lookup_legacy>
						&bt_dev.id_addr[conn->id]);
   1a404:	7a2b      	ldrb	r3, [r5, #8]
   1a406:	4a0e      	ldr	r2, [pc, #56]	; (1a440 <bt_hci_le_enh_conn_complete+0x1b0>)
   1a408:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   1a40c:	18d1      	adds	r1, r2, r3
   1a40e:	58d3      	ldr	r3, [r2, r3]
   1a410:	f8c5 309e 	str.w	r3, [r5, #158]	; 0x9e
   1a414:	8888      	ldrh	r0, [r1, #4]
   1a416:	798b      	ldrb	r3, [r1, #6]
   1a418:	f8a5 00a2 	strh.w	r0, [r5, #162]	; 0xa2
   1a41c:	f885 30a4 	strb.w	r3, [r5, #164]	; 0xa4
		if (BT_LE_STATES_PER_CONN_ADV(bt_dev.le.states)) {
   1a420:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
   1a424:	f013 0f40 	tst.w	r3, #64	; 0x40
   1a428:	d090      	beq.n	1a34c <bt_hci_le_enh_conn_complete+0xbc>
			bt_le_adv_resume();
   1a42a:	f012 fdc9 	bl	2cfc0 <bt_le_adv_resume>
   1a42e:	e78d      	b.n	1a34c <bt_hci_le_enh_conn_complete+0xbc>
		bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
   1a430:	2101      	movs	r1, #1
   1a432:	4628      	mov	r0, r5
   1a434:	f001 f934 	bl	1b6a0 <bt_conn_set_state>
   1a438:	e78e      	b.n	1a358 <bt_hci_le_enh_conn_complete+0xc8>
   1a43a:	bf00      	nop
   1a43c:	00039e50 	.word	0x00039e50
   1a440:	20000420 	.word	0x20000420
   1a444:	00039e70 	.word	0x00039e70

0001a448 <bt_send>:
{
   1a448:	b508      	push	{r3, lr}
	return bt_dev.drv->send(buf);
   1a44a:	4b03      	ldr	r3, [pc, #12]	; (1a458 <bt_send+0x10>)
   1a44c:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
   1a450:	695b      	ldr	r3, [r3, #20]
   1a452:	4798      	blx	r3
}
   1a454:	bd08      	pop	{r3, pc}
   1a456:	bf00      	nop
   1a458:	20000420 	.word	0x20000420

0001a45c <bt_hci_cmd_send>:
{
   1a45c:	b538      	push	{r3, r4, r5, lr}
   1a45e:	4604      	mov	r4, r0
	if (!buf) {
   1a460:	460d      	mov	r5, r1
   1a462:	b151      	cbz	r1, 1a47a <bt_hci_cmd_send+0x1e>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
   1a464:	f640 4335 	movw	r3, #3125	; 0xc35
   1a468:	429c      	cmp	r4, r3
   1a46a:	d00e      	beq.n	1a48a <bt_hci_cmd_send+0x2e>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
   1a46c:	4629      	mov	r1, r5
   1a46e:	480e      	ldr	r0, [pc, #56]	; (1a4a8 <bt_hci_cmd_send+0x4c>)
   1a470:	f004 fd1e 	bl	1eeb0 <net_buf_put>
	return 0;
   1a474:	2400      	movs	r4, #0
}
   1a476:	4620      	mov	r0, r4
   1a478:	bd38      	pop	{r3, r4, r5, pc}
		buf = bt_hci_cmd_create(opcode, 0);
   1a47a:	f7ff fbe5 	bl	19c48 <bt_hci_cmd_create>
		if (!buf) {
   1a47e:	4605      	mov	r5, r0
   1a480:	2800      	cmp	r0, #0
   1a482:	d1ef      	bne.n	1a464 <bt_hci_cmd_send+0x8>
			return -ENOBUFS;
   1a484:	f06f 0468 	mvn.w	r4, #104	; 0x68
   1a488:	e7f5      	b.n	1a476 <bt_hci_cmd_send+0x1a>
		err = bt_send(buf);
   1a48a:	4628      	mov	r0, r5
   1a48c:	f7ff ffdc 	bl	1a448 <bt_send>
		if (err) {
   1a490:	4604      	mov	r4, r0
   1a492:	2800      	cmp	r0, #0
   1a494:	d0ef      	beq.n	1a476 <bt_hci_cmd_send+0x1a>
			BT_ERR("Unable to send to driver (err %d)", err);
   1a496:	4602      	mov	r2, r0
   1a498:	2145      	movs	r1, #69	; 0x45
   1a49a:	4804      	ldr	r0, [pc, #16]	; (1a4ac <bt_hci_cmd_send+0x50>)
   1a49c:	f012 f856 	bl	2c54c <z_log_minimal_printk>
			net_buf_unref(buf);
   1a4a0:	4628      	mov	r0, r5
   1a4a2:	f004 fd37 	bl	1ef14 <net_buf_unref>
		return err;
   1a4a6:	e7e6      	b.n	1a476 <bt_hci_cmd_send+0x1a>
   1a4a8:	2000055c 	.word	0x2000055c
   1a4ac:	00039e94 	.word	0x00039e94

0001a4b0 <le_conn_param_neg_reply>:
{
   1a4b0:	b570      	push	{r4, r5, r6, lr}
   1a4b2:	4605      	mov	r5, r0
   1a4b4:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
   1a4b6:	2103      	movs	r1, #3
   1a4b8:	f242 0021 	movw	r0, #8225	; 0x2021
   1a4bc:	f7ff fbc4 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   1a4c0:	b160      	cbz	r0, 1a4dc <le_conn_param_neg_reply+0x2c>
   1a4c2:	4606      	mov	r6, r0
   1a4c4:	2103      	movs	r1, #3
   1a4c6:	3008      	adds	r0, #8
   1a4c8:	f004 fe3c 	bl	1f144 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(handle);
   1a4cc:	8005      	strh	r5, [r0, #0]
	cp->reason = sys_cpu_to_le16(reason);
   1a4ce:	7084      	strb	r4, [r0, #2]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   1a4d0:	4631      	mov	r1, r6
   1a4d2:	f242 0021 	movw	r0, #8225	; 0x2021
   1a4d6:	f7ff ffc1 	bl	1a45c <bt_hci_cmd_send>
}
   1a4da:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("Unable to allocate buffer");
   1a4dc:	2145      	movs	r1, #69	; 0x45
   1a4de:	4802      	ldr	r0, [pc, #8]	; (1a4e8 <le_conn_param_neg_reply+0x38>)
   1a4e0:	f012 f834 	bl	2c54c <z_log_minimal_printk>
		return;
   1a4e4:	e7f9      	b.n	1a4da <le_conn_param_neg_reply+0x2a>
   1a4e6:	bf00      	nop
   1a4e8:	00039ebc 	.word	0x00039ebc

0001a4ec <le_conn_param_req>:
{
   1a4ec:	b530      	push	{r4, r5, lr}
   1a4ee:	b083      	sub	sp, #12
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
   1a4f0:	6883      	ldr	r3, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
   1a4f2:	881c      	ldrh	r4, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   1a4f4:	885a      	ldrh	r2, [r3, #2]
   1a4f6:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
   1a4fa:	889a      	ldrh	r2, [r3, #4]
   1a4fc:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
   1a500:	88da      	ldrh	r2, [r3, #6]
   1a502:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
   1a506:	891b      	ldrh	r3, [r3, #8]
   1a508:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
   1a50c:	4620      	mov	r0, r4
   1a50e:	f001 f8bd 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   1a512:	b168      	cbz	r0, 1a530 <le_conn_param_req+0x44>
   1a514:	4605      	mov	r5, r0
	if (!le_param_req(conn, &param)) {
   1a516:	4669      	mov	r1, sp
   1a518:	f001 fa58 	bl	1b9cc <le_param_req>
   1a51c:	b990      	cbnz	r0, 1a544 <le_conn_param_req+0x58>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
   1a51e:	211e      	movs	r1, #30
   1a520:	4620      	mov	r0, r4
   1a522:	f7ff ffc5 	bl	1a4b0 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
   1a526:	4628      	mov	r0, r5
   1a528:	f001 f87e 	bl	1b628 <bt_conn_unref>
}
   1a52c:	b003      	add	sp, #12
   1a52e:	bd30      	pop	{r4, r5, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   1a530:	4622      	mov	r2, r4
   1a532:	2145      	movs	r1, #69	; 0x45
   1a534:	4806      	ldr	r0, [pc, #24]	; (1a550 <le_conn_param_req+0x64>)
   1a536:	f012 f809 	bl	2c54c <z_log_minimal_printk>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
   1a53a:	2102      	movs	r1, #2
   1a53c:	4620      	mov	r0, r4
   1a53e:	f7ff ffb7 	bl	1a4b0 <le_conn_param_neg_reply>
		return;
   1a542:	e7f3      	b.n	1a52c <le_conn_param_req+0x40>
		le_conn_param_req_reply(handle, &param);
   1a544:	4669      	mov	r1, sp
   1a546:	4620      	mov	r0, r4
   1a548:	f012 fb95 	bl	2cc76 <le_conn_param_req_reply>
   1a54c:	e7eb      	b.n	1a526 <le_conn_param_req+0x3a>
   1a54e:	bf00      	nop
   1a550:	00039ac4 	.word	0x00039ac4

0001a554 <hci_event_prio>:
{
   1a554:	b570      	push	{r4, r5, r6, lr}
   1a556:	b082      	sub	sp, #8
   1a558:	4604      	mov	r4, r0
	net_buf_simple_save(&buf->b, &state);
   1a55a:	f100 0508 	add.w	r5, r0, #8
	state->offset = net_buf_simple_headroom(buf);
   1a55e:	4628      	mov	r0, r5
   1a560:	f014 fcb9 	bl	2eed6 <net_buf_simple_headroom>
   1a564:	f8ad 0004 	strh.w	r0, [sp, #4]
	state->len = buf->len;
   1a568:	89a3      	ldrh	r3, [r4, #12]
   1a56a:	f8ad 3006 	strh.w	r3, [sp, #6]
	BT_ASSERT(buf->len >= sizeof(*hdr));
   1a56e:	2b01      	cmp	r3, #1
   1a570:	d915      	bls.n	1a59e <hci_event_prio+0x4a>
	return net_buf_simple_pull_mem(&buf->b, len);
   1a572:	2102      	movs	r1, #2
   1a574:	4628      	mov	r0, r5
   1a576:	f004 fda5 	bl	1f0c4 <net_buf_simple_pull_mem>
   1a57a:	4605      	mov	r5, r0
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
   1a57c:	7803      	ldrb	r3, [r0, #0]
	switch (evt) {
   1a57e:	3b05      	subs	r3, #5
   1a580:	2b15      	cmp	r3, #21
   1a582:	d81b      	bhi.n	1a5bc <hci_event_prio+0x68>
   1a584:	e8df f003 	tbb	[pc, r3]
   1a588:	1a1a1a18 	.word	0x1a1a1a18
   1a58c:	1a1a1a1a 	.word	0x1a1a1a1a
   1a590:	1a31311a 	.word	0x1a31311a
   1a594:	1a311a1a 	.word	0x1a311a1a
   1a598:	1a1a1a1a 	.word	0x1a1a1a1a
   1a59c:	311a      	.short	0x311a
	BT_ASSERT(buf->len >= sizeof(*hdr));
   1a59e:	f640 526f 	movw	r2, #3439	; 0xd6f
   1a5a2:	491b      	ldr	r1, [pc, #108]	; (1a610 <hci_event_prio+0xbc>)
   1a5a4:	481b      	ldr	r0, [pc, #108]	; (1a614 <hci_event_prio+0xc0>)
   1a5a6:	f011 ffc2 	bl	2c52e <assert_print>
   1a5aa:	4040      	eors	r0, r0
   1a5ac:	f380 8811 	msr	BASEPRI, r0
   1a5b0:	f04f 0003 	mov.w	r0, #3
   1a5b4:	df02      	svc	2
   1a5b6:	e7dc      	b.n	1a572 <hci_event_prio+0x1e>
   1a5b8:	2603      	movs	r6, #3
   1a5ba:	e000      	b.n	1a5be <hci_event_prio+0x6a>
		return BT_HCI_EVT_FLAG_RECV;
   1a5bc:	2602      	movs	r6, #2
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
   1a5be:	f016 0f01 	tst.w	r6, #1
   1a5c2:	d014      	beq.n	1a5ee <hci_event_prio+0x9a>
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
   1a5c4:	2305      	movs	r3, #5
   1a5c6:	4a14      	ldr	r2, [pc, #80]	; (1a618 <hci_event_prio+0xc4>)
   1a5c8:	4621      	mov	r1, r4
   1a5ca:	7828      	ldrb	r0, [r5, #0]
   1a5cc:	f7ff f9c6 	bl	1995c <handle_event>
	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
   1a5d0:	f016 0f02 	tst.w	r6, #2
   1a5d4:	d018      	beq.n	1a608 <hci_event_prio+0xb4>
	buf->data = buf->__buf + state->offset;
   1a5d6:	6923      	ldr	r3, [r4, #16]
   1a5d8:	f8bd 2004 	ldrh.w	r2, [sp, #4]
   1a5dc:	4413      	add	r3, r2
   1a5de:	60a3      	str	r3, [r4, #8]
	buf->len = state->len;
   1a5e0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1a5e4:	81a3      	strh	r3, [r4, #12]
}
   1a5e6:	b002      	add	sp, #8
   1a5e8:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_EVT_FLAG_RECV_PRIO;
   1a5ea:	2601      	movs	r6, #1
   1a5ec:	e7e7      	b.n	1a5be <hci_event_prio+0x6a>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
   1a5ee:	f640 5273 	movw	r2, #3443	; 0xd73
   1a5f2:	4907      	ldr	r1, [pc, #28]	; (1a610 <hci_event_prio+0xbc>)
   1a5f4:	4807      	ldr	r0, [pc, #28]	; (1a614 <hci_event_prio+0xc0>)
   1a5f6:	f011 ff9a 	bl	2c52e <assert_print>
   1a5fa:	4040      	eors	r0, r0
   1a5fc:	f380 8811 	msr	BASEPRI, r0
   1a600:	f04f 0003 	mov.w	r0, #3
   1a604:	df02      	svc	2
   1a606:	e7dd      	b.n	1a5c4 <hci_event_prio+0x70>
		net_buf_unref(buf);
   1a608:	4620      	mov	r0, r4
   1a60a:	f004 fc83 	bl	1ef14 <net_buf_unref>
}
   1a60e:	e7ea      	b.n	1a5e6 <hci_event_prio+0x92>
   1a610:	00039c18 	.word	0x00039c18
   1a614:	00031600 	.word	0x00031600
   1a618:	00039f6c 	.word	0x00039f6c

0001a61c <bt_recv>:
{
   1a61c:	b538      	push	{r3, r4, r5, lr}
   1a61e:	4604      	mov	r4, r0
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   1a620:	7d05      	ldrb	r5, [r0, #20]
	switch (bt_buf_get_type(buf)) {
   1a622:	2d01      	cmp	r5, #1
   1a624:	d006      	beq.n	1a634 <bt_recv+0x18>
   1a626:	462a      	mov	r2, r5
   1a628:	2d03      	cmp	r5, #3
   1a62a:	d129      	bne.n	1a680 <bt_recv+0x64>
		rx_queue_put(buf);
   1a62c:	f7ff f9c0 	bl	199b0 <rx_queue_put>
		return 0;
   1a630:	2000      	movs	r0, #0
}
   1a632:	bd38      	pop	{r3, r4, r5, pc}
		struct bt_hci_evt_hdr *hdr = (void *)buf->data;
   1a634:	6883      	ldr	r3, [r0, #8]
		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
   1a636:	781b      	ldrb	r3, [r3, #0]
	switch (evt) {
   1a638:	3b05      	subs	r3, #5
   1a63a:	2b15      	cmp	r3, #21
   1a63c:	d80e      	bhi.n	1a65c <bt_recv+0x40>
   1a63e:	e8df f003 	tbb	[pc, r3]
   1a642:	0d0b      	.short	0x0d0b
   1a644:	0d0d0d0d 	.word	0x0d0d0d0d
   1a648:	0e0d0d0d 	.word	0x0e0d0d0d
   1a64c:	0d0d0d0e 	.word	0x0d0d0d0e
   1a650:	0d0d0d0e 	.word	0x0d0d0d0e
   1a654:	0e0d0d0d 	.word	0x0e0d0d0d
   1a658:	2503      	movs	r5, #3
   1a65a:	e000      	b.n	1a65e <bt_recv+0x42>
		return BT_HCI_EVT_FLAG_RECV;
   1a65c:	2502      	movs	r5, #2
		if (evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO) {
   1a65e:	f015 0f01 	tst.w	r5, #1
   1a662:	d104      	bne.n	1a66e <bt_recv+0x52>
		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
   1a664:	f015 0f02 	tst.w	r5, #2
   1a668:	d105      	bne.n	1a676 <bt_recv+0x5a>
		return 0;
   1a66a:	2000      	movs	r0, #0
   1a66c:	e7e1      	b.n	1a632 <bt_recv+0x16>
			hci_event_prio(buf);
   1a66e:	4620      	mov	r0, r4
   1a670:	f7ff ff70 	bl	1a554 <hci_event_prio>
   1a674:	e7f6      	b.n	1a664 <bt_recv+0x48>
			rx_queue_put(buf);
   1a676:	4620      	mov	r0, r4
   1a678:	f7ff f99a 	bl	199b0 <rx_queue_put>
		return 0;
   1a67c:	2000      	movs	r0, #0
   1a67e:	e7d8      	b.n	1a632 <bt_recv+0x16>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
   1a680:	2145      	movs	r1, #69	; 0x45
   1a682:	4804      	ldr	r0, [pc, #16]	; (1a694 <bt_recv+0x78>)
   1a684:	f011 ff62 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   1a688:	4620      	mov	r0, r4
   1a68a:	f004 fc43 	bl	1ef14 <net_buf_unref>
		return -EINVAL;
   1a68e:	f06f 0015 	mvn.w	r0, #21
   1a692:	e7ce      	b.n	1a632 <bt_recv+0x16>
   1a694:	00039edc 	.word	0x00039edc

0001a698 <bt_hci_driver_register>:
	if (bt_dev.drv) {
   1a698:	4b0a      	ldr	r3, [pc, #40]	; (1a6c4 <bt_hci_driver_register+0x2c>)
   1a69a:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
   1a69e:	b943      	cbnz	r3, 1a6b2 <bt_hci_driver_register+0x1a>
	if (!drv->open || !drv->send) {
   1a6a0:	68c3      	ldr	r3, [r0, #12]
   1a6a2:	b14b      	cbz	r3, 1a6b8 <bt_hci_driver_register+0x20>
   1a6a4:	6943      	ldr	r3, [r0, #20]
   1a6a6:	b153      	cbz	r3, 1a6be <bt_hci_driver_register+0x26>
	bt_dev.drv = drv;
   1a6a8:	4b06      	ldr	r3, [pc, #24]	; (1a6c4 <bt_hci_driver_register+0x2c>)
   1a6aa:	f8c3 0158 	str.w	r0, [r3, #344]	; 0x158
	return 0;
   1a6ae:	2000      	movs	r0, #0
   1a6b0:	4770      	bx	lr
		return -EALREADY;
   1a6b2:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1a6b6:	4770      	bx	lr
		return -EINVAL;
   1a6b8:	f06f 0015 	mvn.w	r0, #21
   1a6bc:	4770      	bx	lr
   1a6be:	f06f 0015 	mvn.w	r0, #21
}
   1a6c2:	4770      	bx	lr
   1a6c4:	20000420 	.word	0x20000420

0001a6c8 <bt_finalize_init>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1a6c8:	4b06      	ldr	r3, [pc, #24]	; (1a6e4 <bt_finalize_init+0x1c>)
   1a6ca:	f3bf 8f5b 	dmb	ish
   1a6ce:	e853 2f00 	ldrex	r2, [r3]
   1a6d2:	f042 0204 	orr.w	r2, r2, #4
   1a6d6:	e843 2100 	strex	r1, r2, [r3]
   1a6da:	2900      	cmp	r1, #0
   1a6dc:	d1f7      	bne.n	1a6ce <bt_finalize_init+0x6>
   1a6de:	f3bf 8f5b 	dmb	ish
}
   1a6e2:	4770      	bx	lr
   1a6e4:	200004ec 	.word	0x200004ec

0001a6e8 <init_work>:
{
   1a6e8:	b508      	push	{r3, lr}
	err = bt_init();
   1a6ea:	f012 fae9 	bl	2ccc0 <bt_init>
	if (ready_cb) {
   1a6ee:	4b02      	ldr	r3, [pc, #8]	; (1a6f8 <init_work+0x10>)
   1a6f0:	681b      	ldr	r3, [r3, #0]
   1a6f2:	b103      	cbz	r3, 1a6f6 <init_work+0xe>
		ready_cb(err);
   1a6f4:	4798      	blx	r3
}
   1a6f6:	bd08      	pop	{r3, pc}
   1a6f8:	20003ac8 	.word	0x20003ac8

0001a6fc <bt_is_ready>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1a6fc:	f3bf 8f5b 	dmb	ish
   1a700:	4b03      	ldr	r3, [pc, #12]	; (1a710 <bt_is_ready+0x14>)
   1a702:	f8d3 00cc 	ldr.w	r0, [r3, #204]	; 0xcc
   1a706:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   1a70a:	f3c0 0080 	ubfx	r0, r0, #2, #1
}

bool bt_is_ready(void)
{
	return atomic_test_bit(bt_dev.flags, BT_DEV_READY);
}
   1a70e:	4770      	bx	lr
   1a710:	20000420 	.word	0x20000420

0001a714 <bt_set_name>:
#else
BUILD_ASSERT(DEVICE_NAME_LEN < 248);
#endif

int bt_set_name(const char *name)
{
   1a714:	b570      	push	{r4, r5, r6, lr}
   1a716:	4605      	mov	r5, r0
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	size_t len = strlen(name);
   1a718:	f7f2 fac7 	bl	ccaa <strlen>
	int err;

	if (len > CONFIG_BT_DEVICE_NAME_MAX) {
   1a71c:	281c      	cmp	r0, #28
   1a71e:	d813      	bhi.n	1a748 <bt_set_name+0x34>
   1a720:	4604      	mov	r4, r0
		return -ENOMEM;
	}

	if (!strcmp(bt_dev.name, name)) {
   1a722:	4629      	mov	r1, r5
   1a724:	480a      	ldr	r0, [pc, #40]	; (1a750 <bt_set_name+0x3c>)
   1a726:	f7f2 fab6 	bl	cc96 <strcmp>
   1a72a:	b900      	cbnz	r0, 1a72e <bt_set_name+0x1a>

	return 0;
#else
	return -ENOMEM;
#endif
}
   1a72c:	bd70      	pop	{r4, r5, r6, pc}
	strncpy(bt_dev.name, name, len);
   1a72e:	4e09      	ldr	r6, [pc, #36]	; (1a754 <bt_set_name+0x40>)
   1a730:	2324      	movs	r3, #36	; 0x24
   1a732:	4622      	mov	r2, r4
   1a734:	4629      	mov	r1, r5
   1a736:	f506 70ae 	add.w	r0, r6, #348	; 0x15c
   1a73a:	f016 fbbd 	bl	30eb8 <__strncpy_chk>
	bt_dev.name[len] = '\0';
   1a73e:	4434      	add	r4, r6
   1a740:	2000      	movs	r0, #0
   1a742:	f884 015c 	strb.w	r0, [r4, #348]	; 0x15c
	return 0;
   1a746:	e7f1      	b.n	1a72c <bt_set_name+0x18>
		return -ENOMEM;
   1a748:	f06f 000b 	mvn.w	r0, #11
   1a74c:	e7ee      	b.n	1a72c <bt_set_name+0x18>
   1a74e:	bf00      	nop
   1a750:	2000057c 	.word	0x2000057c
   1a754:	20000420 	.word	0x20000420

0001a758 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
   1a758:	4800      	ldr	r0, [pc, #0]	; (1a75c <bt_get_name+0x4>)
   1a75a:	4770      	bx	lr
   1a75c:	2000057c 	.word	0x2000057c

0001a760 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
   1a760:	b570      	push	{r4, r5, r6, lr}
   1a762:	4605      	mov	r5, r0
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
   1a764:	2400      	movs	r4, #0
   1a766:	e001      	b.n	1a76c <id_find+0xc>
   1a768:	3401      	adds	r4, #1
   1a76a:	b2e4      	uxtb	r4, r4
   1a76c:	4b09      	ldr	r3, [pc, #36]	; (1a794 <id_find+0x34>)
   1a76e:	79db      	ldrb	r3, [r3, #7]
   1a770:	42a3      	cmp	r3, r4
   1a772:	d90b      	bls.n	1a78c <id_find+0x2c>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
   1a774:	4626      	mov	r6, r4
   1a776:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
   1a77a:	2207      	movs	r2, #7
   1a77c:	4905      	ldr	r1, [pc, #20]	; (1a794 <id_find+0x34>)
   1a77e:	4419      	add	r1, r3
   1a780:	4628      	mov	r0, r5
   1a782:	f016 fb60 	bl	30e46 <memcmp>
   1a786:	2800      	cmp	r0, #0
   1a788:	d1ee      	bne.n	1a768 <id_find+0x8>
   1a78a:	e001      	b.n	1a790 <id_find+0x30>
			return id;
		}
	}

	return -ENOENT;
   1a78c:	f06f 0601 	mvn.w	r6, #1
}
   1a790:	4630      	mov	r0, r6
   1a792:	bd70      	pop	{r4, r5, r6, pc}
   1a794:	20000420 	.word	0x20000420

0001a798 <set_random_address>:
{
   1a798:	b538      	push	{r3, r4, r5, lr}
   1a79a:	4604      	mov	r4, r0
	return memcmp(a, b, sizeof(*a));
   1a79c:	2206      	movs	r2, #6
   1a79e:	4913      	ldr	r1, [pc, #76]	; (1a7ec <set_random_address+0x54>)
   1a7a0:	f016 fb51 	bl	30e46 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
   1a7a4:	b900      	cbnz	r0, 1a7a8 <set_random_address+0x10>
}
   1a7a6:	bd38      	pop	{r3, r4, r5, pc}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
   1a7a8:	2106      	movs	r1, #6
   1a7aa:	f242 0005 	movw	r0, #8197	; 0x2005
   1a7ae:	f7ff fa4b 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   1a7b2:	4605      	mov	r5, r0
   1a7b4:	b1b8      	cbz	r0, 1a7e6 <set_random_address+0x4e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1a7b6:	2206      	movs	r2, #6
   1a7b8:	4621      	mov	r1, r4
   1a7ba:	3008      	adds	r0, #8
   1a7bc:	f014 fb98 	bl	2eef0 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
   1a7c0:	2200      	movs	r2, #0
   1a7c2:	4629      	mov	r1, r5
   1a7c4:	f242 0005 	movw	r0, #8197	; 0x2005
   1a7c8:	f7ff fa8c 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1a7cc:	2800      	cmp	r0, #0
   1a7ce:	d1ea      	bne.n	1a7a6 <set_random_address+0xe>
	memcpy(dst, src, sizeof(*dst));
   1a7d0:	4b07      	ldr	r3, [pc, #28]	; (1a7f0 <set_random_address+0x58>)
   1a7d2:	6822      	ldr	r2, [r4, #0]
   1a7d4:	f8c3 2061 	str.w	r2, [r3, #97]	; 0x61
   1a7d8:	88a2      	ldrh	r2, [r4, #4]
   1a7da:	f8a3 2065 	strh.w	r2, [r3, #101]	; 0x65
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
   1a7de:	2201      	movs	r2, #1
   1a7e0:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
	return 0;
   1a7e4:	e7df      	b.n	1a7a6 <set_random_address+0xe>
		return -ENOBUFS;
   1a7e6:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1a7ea:	e7dc      	b.n	1a7a6 <set_random_address+0xe>
   1a7ec:	20000481 	.word	0x20000481
   1a7f0:	20000420 	.word	0x20000420

0001a7f4 <id_create>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
{
   1a7f4:	b530      	push	{r4, r5, lr}
   1a7f6:	b085      	sub	sp, #20
   1a7f8:	4604      	mov	r4, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   1a7fa:	460d      	mov	r5, r1
   1a7fc:	b149      	cbz	r1, 1a812 <id_create+0x1e>
   1a7fe:	2300      	movs	r3, #0
   1a800:	9302      	str	r3, [sp, #8]
   1a802:	f8cd 300b 	str.w	r3, [sp, #11]
	return memcmp(a, b, sizeof(*a));
   1a806:	2207      	movs	r2, #7
   1a808:	a902      	add	r1, sp, #8
   1a80a:	4628      	mov	r0, r5
   1a80c:	f016 fb1b 	bl	30e46 <memcmp>
   1a810:	bb00      	cbnz	r0, 1a854 <id_create+0x60>
		bt_addr_le_t new_addr;

		do {
			int err;

			err = bt_addr_le_create_static(&new_addr);
   1a812:	4668      	mov	r0, sp
   1a814:	f012 f906 	bl	2ca24 <bt_addr_le_create_static>
			if (err) {
   1a818:	4603      	mov	r3, r0
   1a81a:	b9c0      	cbnz	r0, 1a84e <id_create+0x5a>
				return err;
			}
			/* Make sure we didn't generate a duplicate */
		} while (id_find(&new_addr) >= 0);
   1a81c:	4668      	mov	r0, sp
   1a81e:	f7ff ff9f 	bl	1a760 <id_find>
   1a822:	2800      	cmp	r0, #0
   1a824:	daf5      	bge.n	1a812 <id_create+0x1e>

		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
   1a826:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   1a82a:	4a10      	ldr	r2, [pc, #64]	; (1a86c <id_create+0x78>)
   1a82c:	18a3      	adds	r3, r4, r2
   1a82e:	9800      	ldr	r0, [sp, #0]
   1a830:	50a0      	str	r0, [r4, r2]
   1a832:	f8bd 0004 	ldrh.w	r0, [sp, #4]
   1a836:	f89d 1006 	ldrb.w	r1, [sp, #6]
   1a83a:	8098      	strh	r0, [r3, #4]
   1a83c:	7199      	strb	r1, [r3, #6]

		if (addr) {
   1a83e:	b12d      	cbz	r5, 1a84c <id_create+0x58>
   1a840:	58a2      	ldr	r2, [r4, r2]
   1a842:	602a      	str	r2, [r5, #0]
   1a844:	889a      	ldrh	r2, [r3, #4]
   1a846:	799b      	ldrb	r3, [r3, #6]
   1a848:	80aa      	strh	r2, [r5, #4]
   1a84a:	71ab      	strb	r3, [r5, #6]
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
	}

	return 0;
   1a84c:	2300      	movs	r3, #0
}
   1a84e:	4618      	mov	r0, r3
   1a850:	b005      	add	sp, #20
   1a852:	bd30      	pop	{r4, r5, pc}
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
   1a854:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   1a858:	4a04      	ldr	r2, [pc, #16]	; (1a86c <id_create+0x78>)
   1a85a:	18a3      	adds	r3, r4, r2
   1a85c:	6829      	ldr	r1, [r5, #0]
   1a85e:	50a1      	str	r1, [r4, r2]
   1a860:	88a9      	ldrh	r1, [r5, #4]
   1a862:	79aa      	ldrb	r2, [r5, #6]
   1a864:	8099      	strh	r1, [r3, #4]
   1a866:	719a      	strb	r2, [r3, #6]
}
   1a868:	e7f0      	b.n	1a84c <id_create+0x58>
   1a86a:	bf00      	nop
   1a86c:	20000420 	.word	0x20000420

0001a870 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
   1a870:	b570      	push	{r4, r5, r6, lr}
   1a872:	b088      	sub	sp, #32
   1a874:	460c      	mov	r4, r1
	int new_id, err;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   1a876:	4605      	mov	r5, r0
   1a878:	b1e0      	cbz	r0, 1a8b4 <bt_id_create+0x44>
   1a87a:	2300      	movs	r3, #0
   1a87c:	9304      	str	r3, [sp, #16]
   1a87e:	f8cd 3013 	str.w	r3, [sp, #19]
	return memcmp(a, b, sizeof(*a));
   1a882:	2207      	movs	r2, #7
   1a884:	a904      	add	r1, sp, #16
   1a886:	f016 fade 	bl	30e46 <memcmp>
   1a88a:	b198      	cbz	r0, 1a8b4 <bt_id_create+0x44>
		if (addr->type != BT_ADDR_LE_RANDOM ||
   1a88c:	782b      	ldrb	r3, [r5, #0]
   1a88e:	2b01      	cmp	r3, #1
   1a890:	d104      	bne.n	1a89c <bt_id_create+0x2c>
		    !BT_ADDR_IS_STATIC(&addr->a)) {
   1a892:	79ab      	ldrb	r3, [r5, #6]
		if (addr->type != BT_ADDR_LE_RANDOM ||
   1a894:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1a898:	2bc0      	cmp	r3, #192	; 0xc0
   1a89a:	d006      	beq.n	1a8aa <bt_id_create+0x3a>
			BT_ERR("Only static random identity address supported");
   1a89c:	2145      	movs	r1, #69	; 0x45
   1a89e:	4820      	ldr	r0, [pc, #128]	; (1a920 <bt_id_create+0xb0>)
   1a8a0:	f011 fe54 	bl	2c54c <z_log_minimal_printk>
			return -EINVAL;
   1a8a4:	f06f 0015 	mvn.w	r0, #21
   1a8a8:	e02c      	b.n	1a904 <bt_id_create+0x94>
		}

		if (id_find(addr) >= 0) {
   1a8aa:	4628      	mov	r0, r5
   1a8ac:	f7ff ff58 	bl	1a760 <id_find>
   1a8b0:	2800      	cmp	r0, #0
   1a8b2:	da29      	bge.n	1a908 <bt_id_create+0x98>
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
   1a8b4:	bb74      	cbnz	r4, 1a914 <bt_id_create+0xa4>
		return -EINVAL;
	}

	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
   1a8b6:	4b1b      	ldr	r3, [pc, #108]	; (1a924 <bt_id_create+0xb4>)
   1a8b8:	79db      	ldrb	r3, [r3, #7]
   1a8ba:	2b01      	cmp	r3, #1
   1a8bc:	d02d      	beq.n	1a91a <bt_id_create+0xaa>
   1a8be:	f3bf 8f5b 	dmb	ish
   1a8c2:	4b19      	ldr	r3, [pc, #100]	; (1a928 <bt_id_create+0xb8>)
   1a8c4:	681b      	ldr	r3, [r3, #0]
   1a8c6:	f3bf 8f5b 	dmb	ish
		return -ENOMEM;
	}

	/* bt_rand is not available before Bluetooth enable has been called */
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   1a8ca:	f013 0f01 	tst.w	r3, #1
   1a8ce:	d10e      	bne.n	1a8ee <bt_id_create+0x7e>
		uint8_t zero_irk[16] = { 0 };
   1a8d0:	2300      	movs	r3, #0
   1a8d2:	9300      	str	r3, [sp, #0]
   1a8d4:	9301      	str	r3, [sp, #4]
   1a8d6:	9302      	str	r3, [sp, #8]
   1a8d8:	9303      	str	r3, [sp, #12]

		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
   1a8da:	b1c5      	cbz	r5, 1a90e <bt_id_create+0x9e>
   1a8dc:	9306      	str	r3, [sp, #24]
   1a8de:	f8cd 301b 	str.w	r3, [sp, #27]
   1a8e2:	2207      	movs	r2, #7
   1a8e4:	a906      	add	r1, sp, #24
   1a8e6:	4628      	mov	r0, r5
   1a8e8:	f016 faad 	bl	30e46 <memcmp>
   1a8ec:	b178      	cbz	r0, 1a90e <bt_id_create+0x9e>
		    !(irk && memcmp(irk, zero_irk, 16))) {
			return -EINVAL;
		}
	}

	new_id = bt_dev.id_count++;
   1a8ee:	4b0d      	ldr	r3, [pc, #52]	; (1a924 <bt_id_create+0xb4>)
   1a8f0:	79de      	ldrb	r6, [r3, #7]
   1a8f2:	1c72      	adds	r2, r6, #1
   1a8f4:	71da      	strb	r2, [r3, #7]
	err = id_create(new_id, addr, irk);
   1a8f6:	4622      	mov	r2, r4
   1a8f8:	4629      	mov	r1, r5
   1a8fa:	4630      	mov	r0, r6
   1a8fc:	f7ff ff7a 	bl	1a7f4 <id_create>
	if (err) {
   1a900:	b900      	cbnz	r0, 1a904 <bt_id_create+0x94>
		return err;
	}

	return new_id;
   1a902:	4630      	mov	r0, r6
}
   1a904:	b008      	add	sp, #32
   1a906:	bd70      	pop	{r4, r5, r6, pc}
			return -EALREADY;
   1a908:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1a90c:	e7fa      	b.n	1a904 <bt_id_create+0x94>
			return -EINVAL;
   1a90e:	f06f 0015 	mvn.w	r0, #21
   1a912:	e7f7      	b.n	1a904 <bt_id_create+0x94>
		return -EINVAL;
   1a914:	f06f 0015 	mvn.w	r0, #21
   1a918:	e7f4      	b.n	1a904 <bt_id_create+0x94>
		return -ENOMEM;
   1a91a:	f06f 000b 	mvn.w	r0, #11
   1a91e:	e7f1      	b.n	1a904 <bt_id_create+0x94>
   1a920:	00039f94 	.word	0x00039f94
   1a924:	20000420 	.word	0x20000420
   1a928:	200004ec 	.word	0x200004ec

0001a92c <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
   1a92c:	b570      	push	{r4, r5, r6, lr}
   1a92e:	b086      	sub	sp, #24
   1a930:	4604      	mov	r4, r0
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   1a932:	aa01      	add	r2, sp, #4
   1a934:	2100      	movs	r1, #0
   1a936:	f241 0009 	movw	r0, #4105	; 0x1009
   1a93a:	f7ff f9d3 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1a93e:	b9f0      	cbnz	r0, 1a97e <bt_id_read_public_addr+0x52>
		BT_WARN("Failed to read public address");
		return 0U;
	}

	rp = (void *)rsp->data;
   1a940:	9b01      	ldr	r3, [sp, #4]
   1a942:	689e      	ldr	r6, [r3, #8]

	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   1a944:	1c75      	adds	r5, r6, #1
   1a946:	2300      	movs	r3, #0
   1a948:	9302      	str	r3, [sp, #8]
   1a94a:	f8ad 300c 	strh.w	r3, [sp, #12]
	return memcmp(a, b, sizeof(*a));
   1a94e:	2206      	movs	r2, #6
   1a950:	a902      	add	r1, sp, #8
   1a952:	4628      	mov	r0, r5
   1a954:	f016 fa77 	bl	30e46 <memcmp>
   1a958:	b158      	cbz	r0, 1a972 <bt_id_read_public_addr+0x46>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
   1a95a:	4b13      	ldr	r3, [pc, #76]	; (1a9a8 <bt_id_read_public_addr+0x7c>)
   1a95c:	e893 0003 	ldmia.w	r3, {r0, r1}
   1a960:	9004      	str	r0, [sp, #16]
   1a962:	f8ad 1014 	strh.w	r1, [sp, #20]
   1a966:	2206      	movs	r2, #6
   1a968:	a904      	add	r1, sp, #16
   1a96a:	4628      	mov	r0, r5
   1a96c:	f016 fa6b 	bl	30e46 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   1a970:	b958      	cbnz	r0, 1a98a <bt_id_read_public_addr+0x5e>
		BT_DBG("Controller has no public address");
		net_buf_unref(rsp);
   1a972:	9801      	ldr	r0, [sp, #4]
   1a974:	f004 face 	bl	1ef14 <net_buf_unref>
		return 0U;
   1a978:	2000      	movs	r0, #0
	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
	return 1U;
}
   1a97a:	b006      	add	sp, #24
   1a97c:	bd70      	pop	{r4, r5, r6, pc}
		BT_WARN("Failed to read public address");
   1a97e:	2157      	movs	r1, #87	; 0x57
   1a980:	480a      	ldr	r0, [pc, #40]	; (1a9ac <bt_id_read_public_addr+0x80>)
   1a982:	f011 fde3 	bl	2c54c <z_log_minimal_printk>
		return 0U;
   1a986:	2000      	movs	r0, #0
   1a988:	e7f7      	b.n	1a97a <bt_id_read_public_addr+0x4e>
   1a98a:	f8d6 3001 	ldr.w	r3, [r6, #1]
   1a98e:	f8c4 3001 	str.w	r3, [r4, #1]
   1a992:	88ab      	ldrh	r3, [r5, #4]
   1a994:	f8a4 3005 	strh.w	r3, [r4, #5]
	addr->type = BT_ADDR_LE_PUBLIC;
   1a998:	2300      	movs	r3, #0
   1a99a:	7023      	strb	r3, [r4, #0]
	net_buf_unref(rsp);
   1a99c:	9801      	ldr	r0, [sp, #4]
   1a99e:	f004 fab9 	bl	1ef14 <net_buf_unref>
	return 1U;
   1a9a2:	2001      	movs	r0, #1
   1a9a4:	e7e9      	b.n	1a97a <bt_id_read_public_addr+0x4e>
   1a9a6:	bf00      	nop
   1a9a8:	00031430 	.word	0x00031430
   1a9ac:	00039fc8 	.word	0x00039fc8

0001a9b0 <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
   1a9b0:	b500      	push	{lr}
   1a9b2:	b083      	sub	sp, #12
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
   1a9b4:	4668      	mov	r0, sp
   1a9b6:	f7ff ffb9 	bl	1a92c <bt_id_read_public_addr>
   1a9ba:	4b06      	ldr	r3, [pc, #24]	; (1a9d4 <bt_setup_public_id_addr+0x24>)
   1a9bc:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
   1a9be:	b918      	cbnz	r0, 1a9c8 <bt_setup_public_id_addr+0x18>
		return 0;
   1a9c0:	2000      	movs	r0, #0
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}
#endif /* defined(CONFIG_BT_PRIVACY) */

	return id_create(BT_ID_DEFAULT, &addr, irk);
}
   1a9c2:	b003      	add	sp, #12
   1a9c4:	f85d fb04 	ldr.w	pc, [sp], #4
	return id_create(BT_ID_DEFAULT, &addr, irk);
   1a9c8:	2200      	movs	r2, #0
   1a9ca:	4669      	mov	r1, sp
   1a9cc:	4610      	mov	r0, r2
   1a9ce:	f7ff ff11 	bl	1a7f4 <id_create>
   1a9d2:	e7f6      	b.n	1a9c2 <bt_setup_public_id_addr+0x12>
   1a9d4:	20000420 	.word	0x20000420

0001a9d8 <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
   1a9d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a9da:	b083      	sub	sp, #12
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
   1a9dc:	4b24      	ldr	r3, [pc, #144]	; (1aa70 <bt_read_static_addr+0x98>)
   1a9de:	f893 40ba 	ldrb.w	r4, [r3, #186]	; 0xba
   1a9e2:	f014 0401 	ands.w	r4, r4, #1
   1a9e6:	d010      	beq.n	1aa0a <bt_read_static_addr+0x32>
   1a9e8:	4605      	mov	r5, r0
   1a9ea:	460e      	mov	r6, r1
		BT_WARN("Read Static Addresses command not available");
		return 0;
	}

	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
   1a9ec:	aa01      	add	r2, sp, #4
   1a9ee:	2100      	movs	r1, #0
   1a9f0:	f64f 4009 	movw	r0, #64521	; 0xfc09
   1a9f4:	f7ff f976 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1a9f8:	4684      	mov	ip, r0
   1a9fa:	b958      	cbnz	r0, 1aa14 <bt_read_static_addr+0x3c>
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	rp = (void *)rsp->data;
   1a9fc:	9b01      	ldr	r3, [sp, #4]
   1a9fe:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
   1aa00:	785c      	ldrb	r4, [r3, #1]
   1aa02:	42b4      	cmp	r4, r6
   1aa04:	bf28      	it	cs
   1aa06:	4634      	movcs	r4, r6
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	for (i = 0; i < cnt; i++) {
   1aa08:	e023      	b.n	1aa52 <bt_read_static_addr+0x7a>
		BT_WARN("Read Static Addresses command not available");
   1aa0a:	2157      	movs	r1, #87	; 0x57
   1aa0c:	4819      	ldr	r0, [pc, #100]	; (1aa74 <bt_read_static_addr+0x9c>)
   1aa0e:	f011 fd9d 	bl	2c54c <z_log_minimal_printk>
		return 0;
   1aa12:	e024      	b.n	1aa5e <bt_read_static_addr+0x86>
		BT_WARN("Failed to read static addresses");
   1aa14:	2157      	movs	r1, #87	; 0x57
   1aa16:	4818      	ldr	r0, [pc, #96]	; (1aa78 <bt_read_static_addr+0xa0>)
   1aa18:	f011 fd98 	bl	2c54c <z_log_minimal_printk>
		return 0;
   1aa1c:	2400      	movs	r4, #0
   1aa1e:	e01e      	b.n	1aa5e <bt_read_static_addr+0x86>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
   1aa20:	2116      	movs	r1, #22
   1aa22:	fb01 f10c 	mul.w	r1, r1, ip
   1aa26:	186a      	adds	r2, r5, r1
   1aa28:	f8d3 e002 	ldr.w	lr, [r3, #2]
   1aa2c:	f8d3 7006 	ldr.w	r7, [r3, #6]
   1aa30:	f8d3 600a 	ldr.w	r6, [r3, #10]
   1aa34:	f8d3 000e 	ldr.w	r0, [r3, #14]
   1aa38:	f845 e001 	str.w	lr, [r5, r1]
   1aa3c:	6057      	str	r7, [r2, #4]
   1aa3e:	6096      	str	r6, [r2, #8]
   1aa40:	60d0      	str	r0, [r2, #12]
   1aa42:	f8d3 e012 	ldr.w	lr, [r3, #18]
   1aa46:	f8c2 e010 	str.w	lr, [r2, #16]
   1aa4a:	8ad9      	ldrh	r1, [r3, #22]
   1aa4c:	8291      	strh	r1, [r2, #20]
	for (i = 0; i < cnt; i++) {
   1aa4e:	f10c 0c01 	add.w	ip, ip, #1
   1aa52:	4564      	cmp	r4, ip
   1aa54:	dce4      	bgt.n	1aa20 <bt_read_static_addr+0x48>
	}

	net_buf_unref(rsp);
   1aa56:	9801      	ldr	r0, [sp, #4]
   1aa58:	f004 fa5c 	bl	1ef14 <net_buf_unref>
	if (!cnt) {
   1aa5c:	b114      	cbz	r4, 1aa64 <bt_read_static_addr+0x8c>
		BT_WARN("No static addresses stored in controller");
	}

	return cnt;
}
   1aa5e:	4620      	mov	r0, r4
   1aa60:	b003      	add	sp, #12
   1aa62:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_WARN("No static addresses stored in controller");
   1aa64:	2157      	movs	r1, #87	; 0x57
   1aa66:	4805      	ldr	r0, [pc, #20]	; (1aa7c <bt_read_static_addr+0xa4>)
   1aa68:	f011 fd70 	bl	2c54c <z_log_minimal_printk>
   1aa6c:	e7f7      	b.n	1aa5e <bt_read_static_addr+0x86>
   1aa6e:	bf00      	nop
   1aa70:	20000420 	.word	0x20000420
   1aa74:	00039fec 	.word	0x00039fec
   1aa78:	0003a020 	.word	0x0003a020
   1aa7c:	0003a048 	.word	0x0003a048

0001aa80 <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
   1aa80:	b510      	push	{r4, lr}
   1aa82:	b088      	sub	sp, #32
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
   1aa84:	4b18      	ldr	r3, [pc, #96]	; (1aae8 <bt_setup_random_id_addr+0x68>)
   1aa86:	79dc      	ldrb	r4, [r3, #7]
   1aa88:	b934      	cbnz	r4, 1aa98 <bt_setup_random_id_addr+0x18>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
   1aa8a:	2101      	movs	r1, #1
   1aa8c:	a802      	add	r0, sp, #8
   1aa8e:	f7ff ffa3 	bl	1a9d8 <bt_read_static_addr>
   1aa92:	4b15      	ldr	r3, [pc, #84]	; (1aae8 <bt_setup_random_id_addr+0x68>)
   1aa94:	71d8      	strb	r0, [r3, #7]

		if (bt_dev.id_count) {
   1aa96:	b948      	cbnz	r0, 1aaac <bt_setup_random_id_addr+0x2c>

	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
   1aa98:	2100      	movs	r1, #0
   1aa9a:	4608      	mov	r0, r1
   1aa9c:	f7ff fee8 	bl	1a870 <bt_id_create>
   1aaa0:	4603      	mov	r3, r0
}
   1aaa2:	4618      	mov	r0, r3
   1aaa4:	b008      	add	sp, #32
   1aaa6:	bd10      	pop	{r4, pc}
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
   1aaa8:	3401      	adds	r4, #1
   1aaaa:	b2e4      	uxtb	r4, r4
   1aaac:	4b0e      	ldr	r3, [pc, #56]	; (1aae8 <bt_setup_random_id_addr+0x68>)
   1aaae:	79db      	ldrb	r3, [r3, #7]
   1aab0:	42a3      	cmp	r3, r4
   1aab2:	d916      	bls.n	1aae2 <bt_setup_random_id_addr+0x62>
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
   1aab4:	aa02      	add	r2, sp, #8
   1aab6:	2316      	movs	r3, #22
   1aab8:	fb04 f303 	mul.w	r3, r4, r3
   1aabc:	18d1      	adds	r1, r2, r3
	memcpy(dst, src, sizeof(*dst));
   1aabe:	58d3      	ldr	r3, [r2, r3]
   1aac0:	f8cd 3001 	str.w	r3, [sp, #1]
   1aac4:	888b      	ldrh	r3, [r1, #4]
   1aac6:	f8ad 3005 	strh.w	r3, [sp, #5]
				addr.type = BT_ADDR_LE_RANDOM;
   1aaca:	2301      	movs	r3, #1
   1aacc:	f88d 3000 	strb.w	r3, [sp]
				err = id_create(i, &addr, irk);
   1aad0:	2200      	movs	r2, #0
   1aad2:	4669      	mov	r1, sp
   1aad4:	4620      	mov	r0, r4
   1aad6:	f7ff fe8d 	bl	1a7f4 <id_create>
				if (err) {
   1aada:	4603      	mov	r3, r0
   1aadc:	2800      	cmp	r0, #0
   1aade:	d0e3      	beq.n	1aaa8 <bt_setup_random_id_addr+0x28>
   1aae0:	e7df      	b.n	1aaa2 <bt_setup_random_id_addr+0x22>
			return 0;
   1aae2:	2300      	movs	r3, #0
   1aae4:	e7dd      	b.n	1aaa2 <bt_setup_random_id_addr+0x22>
   1aae6:	bf00      	nop
   1aae8:	20000420 	.word	0x20000420

0001aaec <bt_id_set_adv_own_addr>:
}
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
   1aaec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1aaee:	460d      	mov	r5, r1
   1aaf0:	461e      	mov	r6, r3
	const bt_addr_le_t *id_addr;
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];
   1aaf2:	7804      	ldrb	r4, [r0, #0]

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
   1aaf4:	f011 0f01 	tst.w	r1, #1
   1aaf8:	d027      	beq.n	1ab4a <bt_id_set_adv_own_addr+0x5e>
   1aafa:	4617      	mov	r7, r2
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
   1aafc:	b142      	cbz	r2, 1ab10 <bt_id_set_adv_own_addr+0x24>
   1aafe:	f011 0f20 	tst.w	r1, #32
   1ab02:	d005      	beq.n	1ab10 <bt_id_set_adv_own_addr+0x24>
		    !BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
   1ab04:	4b22      	ldr	r3, [pc, #136]	; (1ab90 <bt_id_set_adv_own_addr+0xa4>)
   1ab06:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
   1ab0a:	f013 0f40 	tst.w	r3, #64	; 0x40
   1ab0e:	d038      	beq.n	1ab82 <bt_id_set_adv_own_addr+0x96>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   1ab10:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   1ab14:	4a1e      	ldr	r2, [pc, #120]	; (1ab90 <bt_id_set_adv_own_addr+0xa4>)
   1ab16:	5cd3      	ldrb	r3, [r2, r3]
   1ab18:	2b01      	cmp	r3, #1
   1ab1a:	d00d      	beq.n	1ab38 <bt_id_set_adv_own_addr+0x4c>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
   1ab1c:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   1ab20:	4b1b      	ldr	r3, [pc, #108]	; (1ab90 <bt_id_set_adv_own_addr+0xa4>)
   1ab22:	5d1b      	ldrb	r3, [r3, r4]
   1ab24:	7033      	strb	r3, [r6, #0]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
   1ab26:	b37f      	cbz	r7, 1ab88 <bt_id_set_adv_own_addr+0x9c>
   1ab28:	f015 0f20 	tst.w	r5, #32
   1ab2c:	d02e      	beq.n	1ab8c <bt_id_set_adv_own_addr+0xa0>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
   1ab2e:	f043 0302 	orr.w	r3, r3, #2
   1ab32:	7033      	strb	r3, [r6, #0]
		if (err) {
			return err;
		}
	}

	return 0;
   1ab34:	2000      	movs	r0, #0
   1ab36:	e017      	b.n	1ab68 <bt_id_set_adv_own_addr+0x7c>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
   1ab38:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
   1ab3c:	4411      	add	r1, r2
   1ab3e:	3101      	adds	r1, #1
   1ab40:	f012 f8d4 	bl	2ccec <bt_id_set_adv_random_addr>
				if (err) {
   1ab44:	2800      	cmp	r0, #0
   1ab46:	d0e9      	beq.n	1ab1c <bt_id_set_adv_own_addr+0x30>
   1ab48:	e00e      	b.n	1ab68 <bt_id_set_adv_own_addr+0x7c>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
   1ab4a:	f011 0f04 	tst.w	r1, #4
   1ab4e:	d013      	beq.n	1ab78 <bt_id_set_adv_own_addr+0x8c>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   1ab50:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   1ab54:	4a0e      	ldr	r2, [pc, #56]	; (1ab90 <bt_id_set_adv_own_addr+0xa4>)
   1ab56:	5cd3      	ldrb	r3, [r2, r3]
   1ab58:	2b01      	cmp	r3, #1
   1ab5a:	d006      	beq.n	1ab6a <bt_id_set_adv_own_addr+0x7e>
	int err = 0;
   1ab5c:	2000      	movs	r0, #0
			*own_addr_type = id_addr->type;
   1ab5e:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   1ab62:	4b0b      	ldr	r3, [pc, #44]	; (1ab90 <bt_id_set_adv_own_addr+0xa4>)
   1ab64:	5d1b      	ldrb	r3, [r3, r4]
   1ab66:	7033      	strb	r3, [r6, #0]
}
   1ab68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
   1ab6a:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
   1ab6e:	4411      	add	r1, r2
   1ab70:	3101      	adds	r1, #1
   1ab72:	f012 f8bb 	bl	2ccec <bt_id_set_adv_random_addr>
   1ab76:	e7f2      	b.n	1ab5e <bt_id_set_adv_own_addr+0x72>
			err = bt_id_set_adv_private_addr(adv);
   1ab78:	f012 f8bd 	bl	2ccf6 <bt_id_set_adv_private_addr>
			*own_addr_type = BT_ADDR_LE_RANDOM;
   1ab7c:	2301      	movs	r3, #1
   1ab7e:	7033      	strb	r3, [r6, #0]
		if (err) {
   1ab80:	e7f2      	b.n	1ab68 <bt_id_set_adv_own_addr+0x7c>
			return -ENOTSUP;
   1ab82:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1ab86:	e7ef      	b.n	1ab68 <bt_id_set_adv_own_addr+0x7c>
	return 0;
   1ab88:	2000      	movs	r0, #0
   1ab8a:	e7ed      	b.n	1ab68 <bt_id_set_adv_own_addr+0x7c>
   1ab8c:	2000      	movs	r0, #0
   1ab8e:	e7eb      	b.n	1ab68 <bt_id_set_adv_own_addr+0x7c>
   1ab90:	20000420 	.word	0x20000420

0001ab94 <bt_id_init>:
}
#endif /* !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) */
#endif /* defined(CONFIG_BT_SMP) */

int bt_id_init(void)
{
   1ab94:	b510      	push	{r4, lr}
	int err;

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
   1ab96:	4b13      	ldr	r3, [pc, #76]	; (1abe4 <bt_id_init+0x50>)
   1ab98:	79db      	ldrb	r3, [r3, #7]
   1ab9a:	b12b      	cbz	r3, 1aba8 <bt_id_init+0x14>
			BT_ERR("Unable to set identity address");
			return err;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
   1ab9c:	4b11      	ldr	r3, [pc, #68]	; (1abe4 <bt_id_init+0x50>)
   1ab9e:	79db      	ldrb	r3, [r3, #7]
   1aba0:	b163      	cbz	r3, 1abbc <bt_id_init+0x28>

#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
   1aba2:	2400      	movs	r4, #0
}
   1aba4:	4620      	mov	r0, r4
   1aba6:	bd10      	pop	{r4, pc}
		err = bt_setup_public_id_addr();
   1aba8:	f7ff ff02 	bl	1a9b0 <bt_setup_public_id_addr>
		if (err) {
   1abac:	4604      	mov	r4, r0
   1abae:	2800      	cmp	r0, #0
   1abb0:	d0f4      	beq.n	1ab9c <bt_id_init+0x8>
			BT_ERR("Unable to set identity address");
   1abb2:	2145      	movs	r1, #69	; 0x45
   1abb4:	480c      	ldr	r0, [pc, #48]	; (1abe8 <bt_id_init+0x54>)
   1abb6:	f011 fcc9 	bl	2c54c <z_log_minimal_printk>
			return err;
   1abba:	e7f3      	b.n	1aba4 <bt_id_init+0x10>
		err = bt_setup_random_id_addr();
   1abbc:	f7ff ff60 	bl	1aa80 <bt_setup_random_id_addr>
		if (err) {
   1abc0:	4604      	mov	r4, r0
   1abc2:	b950      	cbnz	r0, 1abda <bt_id_init+0x46>
		err = set_random_address(&bt_dev.id_addr[0].a);
   1abc4:	4809      	ldr	r0, [pc, #36]	; (1abec <bt_id_init+0x58>)
   1abc6:	f7ff fde7 	bl	1a798 <set_random_address>
		if (err) {
   1abca:	4604      	mov	r4, r0
   1abcc:	2800      	cmp	r0, #0
   1abce:	d0e9      	beq.n	1aba4 <bt_id_init+0x10>
			BT_ERR("Unable to set random address");
   1abd0:	2145      	movs	r1, #69	; 0x45
   1abd2:	4807      	ldr	r0, [pc, #28]	; (1abf0 <bt_id_init+0x5c>)
   1abd4:	f011 fcba 	bl	2c54c <z_log_minimal_printk>
			return err;
   1abd8:	e7e4      	b.n	1aba4 <bt_id_init+0x10>
			BT_ERR("Unable to set identity address");
   1abda:	2145      	movs	r1, #69	; 0x45
   1abdc:	4802      	ldr	r0, [pc, #8]	; (1abe8 <bt_id_init+0x54>)
   1abde:	f011 fcb5 	bl	2c54c <z_log_minimal_printk>
			return err;
   1abe2:	e7df      	b.n	1aba4 <bt_id_init+0x10>
   1abe4:	20000420 	.word	0x20000420
   1abe8:	0003a078 	.word	0x0003a078
   1abec:	20000421 	.word	0x20000421
   1abf0:	0003a09c 	.word	0x0003a09c

0001abf4 <adv_new_legacy>:
	bt_dev.adv = adv_new();
	return bt_dev.adv;
#else
	return &bt_dev.adv;
#endif
}
   1abf4:	4800      	ldr	r0, [pc, #0]	; (1abf8 <adv_new_legacy+0x4>)
   1abf6:	4770      	bx	lr
   1abf8:	20000438 	.word	0x20000438

0001abfc <set_data_add_complete>:
	return valid_adv_ext_param(param);
}

static int set_data_add_complete(uint8_t *set_data, uint8_t set_data_len_max,
			const struct bt_ad *ad, size_t ad_len, uint8_t *data_len)
{
   1abfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ac00:	b083      	sub	sp, #12
   1ac02:	4605      	mov	r5, r0
   1ac04:	4688      	mov	r8, r1
   1ac06:	9201      	str	r2, [sp, #4]
   1ac08:	9300      	str	r3, [sp, #0]
	uint8_t set_data_len = 0;

	for (size_t i = 0; i < ad_len; i++) {
   1ac0a:	f04f 0a00 	mov.w	sl, #0
	uint8_t set_data_len = 0;
   1ac0e:	4653      	mov	r3, sl
	for (size_t i = 0; i < ad_len; i++) {
   1ac10:	9a00      	ldr	r2, [sp, #0]
   1ac12:	4552      	cmp	r2, sl
   1ac14:	d940      	bls.n	1ac98 <set_data_add_complete+0x9c>
		const struct bt_data *data = ad[i].data;
   1ac16:	9a01      	ldr	r2, [sp, #4]
   1ac18:	eb02 09ca 	add.w	r9, r2, sl, lsl #3
   1ac1c:	f852 703a 	ldr.w	r7, [r2, sl, lsl #3]

		for (size_t j = 0; j < ad[i].len; j++) {
   1ac20:	2400      	movs	r4, #0
   1ac22:	e01d      	b.n	1ac60 <set_data_add_complete+0x64>
				ssize_t shortened_len = set_data_len_max -
							(set_data_len + 2);

				if (!(type == BT_DATA_NAME_COMPLETE &&
				      shortened_len > 0)) {
					BT_ERR("Too big advertising data");
   1ac24:	2145      	movs	r1, #69	; 0x45
   1ac26:	481e      	ldr	r0, [pc, #120]	; (1aca0 <set_data_add_complete+0xa4>)
   1ac28:	f011 fc90 	bl	2c54c <z_log_minimal_printk>
					return -EINVAL;
   1ac2c:	f06f 0015 	mvn.w	r0, #21
		}
	}

	*data_len = set_data_len;
	return 0;
}
   1ac30:	b003      	add	sp, #12
   1ac32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			set_data[set_data_len++] = len + 1;
   1ac36:	b2d6      	uxtb	r6, r2
   1ac38:	1c59      	adds	r1, r3, #1
   1ac3a:	b2c9      	uxtb	r1, r1
   1ac3c:	f106 0b01 	add.w	fp, r6, #1
   1ac40:	f805 b00e 	strb.w	fp, [r5, lr]
			set_data[set_data_len++] = type;
   1ac44:	3302      	adds	r3, #2
   1ac46:	fa5f fb83 	uxtb.w	fp, r3
   1ac4a:	f805 c001 	strb.w	ip, [r5, r1]
   1ac4e:	6841      	ldr	r1, [r0, #4]
   1ac50:	eb05 000b 	add.w	r0, r5, fp
   1ac54:	f016 f907 	bl	30e66 <memcpy>
			set_data_len += len;
   1ac58:	eb0b 0306 	add.w	r3, fp, r6
   1ac5c:	b2db      	uxtb	r3, r3
		for (size_t j = 0; j < ad[i].len; j++) {
   1ac5e:	3401      	adds	r4, #1
   1ac60:	f8d9 2004 	ldr.w	r2, [r9, #4]
   1ac64:	4294      	cmp	r4, r2
   1ac66:	d214      	bcs.n	1ac92 <set_data_add_complete+0x96>
			size_t len = data[j].data_len;
   1ac68:	eb07 00c4 	add.w	r0, r7, r4, lsl #3
   1ac6c:	7842      	ldrb	r2, [r0, #1]
			uint8_t type = data[j].type;
   1ac6e:	f817 c034 	ldrb.w	ip, [r7, r4, lsl #3]
			if ((set_data_len + len + 2) > set_data_len_max) {
   1ac72:	469e      	mov	lr, r3
   1ac74:	1899      	adds	r1, r3, r2
   1ac76:	3102      	adds	r1, #2
   1ac78:	4541      	cmp	r1, r8
   1ac7a:	d9dc      	bls.n	1ac36 <set_data_add_complete+0x3a>
							(set_data_len + 2);
   1ac7c:	1c9a      	adds	r2, r3, #2
				ssize_t shortened_len = set_data_len_max -
   1ac7e:	eba8 0202 	sub.w	r2, r8, r2
				if (!(type == BT_DATA_NAME_COMPLETE &&
   1ac82:	f1bc 0f09 	cmp.w	ip, #9
   1ac86:	d1cd      	bne.n	1ac24 <set_data_add_complete+0x28>
   1ac88:	2a00      	cmp	r2, #0
   1ac8a:	ddcb      	ble.n	1ac24 <set_data_add_complete+0x28>
				type = BT_DATA_NAME_SHORTENED;
   1ac8c:	f04f 0c08 	mov.w	ip, #8
   1ac90:	e7d1      	b.n	1ac36 <set_data_add_complete+0x3a>
	for (size_t i = 0; i < ad_len; i++) {
   1ac92:	f10a 0a01 	add.w	sl, sl, #1
   1ac96:	e7bb      	b.n	1ac10 <set_data_add_complete+0x14>
	*data_len = set_data_len;
   1ac98:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1ac9a:	7013      	strb	r3, [r2, #0]
	return 0;
   1ac9c:	2000      	movs	r0, #0
   1ac9e:	e7c7      	b.n	1ac30 <set_data_add_complete+0x34>
   1aca0:	0003a0c8 	.word	0x0003a0c8

0001aca4 <valid_adv_ext_param>:
{
   1aca4:	b510      	push	{r4, lr}
   1aca6:	b082      	sub	sp, #8
   1aca8:	4604      	mov	r4, r0
	if (param->id >= bt_dev.id_count ||
   1acaa:	7800      	ldrb	r0, [r0, #0]
   1acac:	4b23      	ldr	r3, [pc, #140]	; (1ad3c <valid_adv_ext_param+0x98>)
   1acae:	79db      	ldrb	r3, [r3, #7]
   1acb0:	4298      	cmp	r0, r3
   1acb2:	d302      	bcc.n	1acba <valid_adv_ext_param+0x16>
		return false;
   1acb4:	2000      	movs	r0, #0
}
   1acb6:	b002      	add	sp, #8
   1acb8:	bd10      	pop	{r4, pc}
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
   1acba:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   1acbe:	2300      	movs	r3, #0
   1acc0:	9300      	str	r3, [sp, #0]
   1acc2:	f8cd 3003 	str.w	r3, [sp, #3]
	return memcmp(a, b, sizeof(*a));
   1acc6:	2207      	movs	r2, #7
   1acc8:	4669      	mov	r1, sp
   1acca:	4b1c      	ldr	r3, [pc, #112]	; (1ad3c <valid_adv_ext_param+0x98>)
   1accc:	4418      	add	r0, r3
   1acce:	f016 f8ba 	bl	30e46 <memcmp>
	if (param->id >= bt_dev.id_count ||
   1acd2:	2800      	cmp	r0, #0
   1acd4:	d0ee      	beq.n	1acb4 <valid_adv_ext_param+0x10>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   1acd6:	6863      	ldr	r3, [r4, #4]
   1acd8:	f013 0f01 	tst.w	r3, #1
   1acdc:	d107      	bne.n	1acee <valid_adv_ext_param+0x4a>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
   1acde:	4a17      	ldr	r2, [pc, #92]	; (1ad3c <valid_adv_ext_param+0x98>)
   1ace0:	f892 2068 	ldrb.w	r2, [r2, #104]	; 0x68
   1ace4:	2a08      	cmp	r2, #8
   1ace6:	d802      	bhi.n	1acee <valid_adv_ext_param+0x4a>
		    param->interval_min < 0x00a0) {
   1ace8:	68a2      	ldr	r2, [r4, #8]
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
   1acea:	2a9f      	cmp	r2, #159	; 0x9f
   1acec:	d91b      	bls.n	1ad26 <valid_adv_ext_param+0x82>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
   1acee:	f013 0f30 	tst.w	r3, #48	; 0x30
   1acf2:	d001      	beq.n	1acf8 <valid_adv_ext_param+0x54>
	    !param->peer) {
   1acf4:	6922      	ldr	r2, [r4, #16]
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
   1acf6:	b1c2      	cbz	r2, 1ad2a <valid_adv_ext_param+0x86>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
   1acf8:	f013 0f10 	tst.w	r3, #16
   1acfc:	d108      	bne.n	1ad10 <valid_adv_ext_param+0x6c>
	    !param->peer) {
   1acfe:	6922      	ldr	r2, [r4, #16]
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
   1ad00:	b132      	cbz	r2, 1ad10 <valid_adv_ext_param+0x6c>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
   1ad02:	f403 3360 	and.w	r3, r3, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
   1ad06:	f5b3 3f60 	cmp.w	r3, #229376	; 0x38000
   1ad0a:	d014      	beq.n	1ad36 <valid_adv_ext_param+0x92>
	return true;
   1ad0c:	2001      	movs	r0, #1
   1ad0e:	e7d2      	b.n	1acb6 <valid_adv_ext_param+0x12>
		if (param->interval_min > param->interval_max ||
   1ad10:	68a2      	ldr	r2, [r4, #8]
   1ad12:	68e1      	ldr	r1, [r4, #12]
   1ad14:	428a      	cmp	r2, r1
   1ad16:	d80a      	bhi.n	1ad2e <valid_adv_ext_param+0x8a>
   1ad18:	2a1f      	cmp	r2, #31
   1ad1a:	d90a      	bls.n	1ad32 <valid_adv_ext_param+0x8e>
		    param->interval_min < 0x0020 ||
   1ad1c:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   1ad20:	d9ef      	bls.n	1ad02 <valid_adv_ext_param+0x5e>
			return false;
   1ad22:	2000      	movs	r0, #0
   1ad24:	e7c7      	b.n	1acb6 <valid_adv_ext_param+0x12>
			return false;
   1ad26:	2000      	movs	r0, #0
   1ad28:	e7c5      	b.n	1acb6 <valid_adv_ext_param+0x12>
		return false;
   1ad2a:	2000      	movs	r0, #0
   1ad2c:	e7c3      	b.n	1acb6 <valid_adv_ext_param+0x12>
			return false;
   1ad2e:	2000      	movs	r0, #0
   1ad30:	e7c1      	b.n	1acb6 <valid_adv_ext_param+0x12>
   1ad32:	2000      	movs	r0, #0
   1ad34:	e7bf      	b.n	1acb6 <valid_adv_ext_param+0x12>
		return false;
   1ad36:	2000      	movs	r0, #0
   1ad38:	e7bd      	b.n	1acb6 <valid_adv_ext_param+0x12>
   1ad3a:	bf00      	nop
   1ad3c:	20000420 	.word	0x20000420

0001ad40 <le_adv_start_add_conn>:
	return channel_map;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
   1ad40:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ad42:	b085      	sub	sp, #20
   1ad44:	4604      	mov	r4, r0
   1ad46:	460f      	mov	r7, r1
	struct bt_conn *conn;

	bt_dev.adv_conn_id = adv->id;
   1ad48:	4605      	mov	r5, r0
   1ad4a:	f815 2b09 	ldrb.w	r2, [r5], #9
   1ad4e:	4b1f      	ldr	r3, [pc, #124]	; (1adcc <le_adv_start_add_conn+0x8c>)
   1ad50:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
   1ad54:	2300      	movs	r3, #0
   1ad56:	9300      	str	r3, [sp, #0]
   1ad58:	f8cd 3003 	str.w	r3, [sp, #3]
   1ad5c:	2207      	movs	r2, #7
   1ad5e:	4669      	mov	r1, sp
   1ad60:	4628      	mov	r0, r5
   1ad62:	f016 f870 	bl	30e46 <memcmp>
   1ad66:	b9b8      	cbnz	r0, 1ad98 <le_adv_start_add_conn+0x58>
   1ad68:	4606      	mov	r6, r0
		/* Undirected advertising */
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
   1ad6a:	4b19      	ldr	r3, [pc, #100]	; (1add0 <le_adv_start_add_conn+0x90>)
   1ad6c:	e893 0003 	ldmia.w	r3, {r0, r1}
   1ad70:	9002      	str	r0, [sp, #8]
   1ad72:	f8ad 100c 	strh.w	r1, [sp, #12]
   1ad76:	0c09      	lsrs	r1, r1, #16
   1ad78:	f88d 100e 	strb.w	r1, [sp, #14]
   1ad7c:	a902      	add	r1, sp, #8
   1ad7e:	7820      	ldrb	r0, [r4, #0]
   1ad80:	f012 fa4b 	bl	2d21a <bt_conn_add_le>
		if (!conn) {
   1ad84:	4604      	mov	r4, r0
   1ad86:	b120      	cbz	r0, 1ad92 <le_adv_start_add_conn+0x52>
			return -ENOMEM;
		}

		bt_conn_set_state(conn, BT_CONN_CONNECTING_ADV);
   1ad88:	2104      	movs	r1, #4
   1ad8a:	f000 fc89 	bl	1b6a0 <bt_conn_set_state>
		*out_conn = conn;
   1ad8e:	603c      	str	r4, [r7, #0]
		return 0;
   1ad90:	e012      	b.n	1adb8 <le_adv_start_add_conn+0x78>
			return -ENOMEM;
   1ad92:	f06f 060b 	mvn.w	r6, #11
   1ad96:	e00f      	b.n	1adb8 <le_adv_start_add_conn+0x78>
	}

	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
   1ad98:	4629      	mov	r1, r5
   1ad9a:	7820      	ldrb	r0, [r4, #0]
   1ad9c:	f000 fe8a 	bl	1bab4 <bt_conn_exists_le>
   1ada0:	b968      	cbnz	r0, 1adbe <le_adv_start_add_conn+0x7e>
		return -EINVAL;
	}

	conn = bt_conn_add_le(adv->id, &adv->target_addr);
   1ada2:	4629      	mov	r1, r5
   1ada4:	7820      	ldrb	r0, [r4, #0]
   1ada6:	f012 fa38 	bl	2d21a <bt_conn_add_le>
	if (!conn) {
   1adaa:	4604      	mov	r4, r0
   1adac:	b150      	cbz	r0, 1adc4 <le_adv_start_add_conn+0x84>
		return -ENOMEM;
	}

	bt_conn_set_state(conn, BT_CONN_CONNECTING_DIR_ADV);
   1adae:	2105      	movs	r1, #5
   1adb0:	f000 fc76 	bl	1b6a0 <bt_conn_set_state>
	*out_conn = conn;
   1adb4:	603c      	str	r4, [r7, #0]
	return 0;
   1adb6:	2600      	movs	r6, #0
}
   1adb8:	4630      	mov	r0, r6
   1adba:	b005      	add	sp, #20
   1adbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
   1adbe:	f06f 0615 	mvn.w	r6, #21
   1adc2:	e7f9      	b.n	1adb8 <le_adv_start_add_conn+0x78>
		return -ENOMEM;
   1adc4:	f06f 060b 	mvn.w	r6, #11
   1adc8:	e7f6      	b.n	1adb8 <le_adv_start_add_conn+0x78>
   1adca:	bf00      	nop
   1adcc:	20000420 	.word	0x20000420
   1add0:	00031438 	.word	0x00031438

0001add4 <le_adv_stop_free_conn>:

static void le_adv_stop_free_conn(const struct bt_le_ext_adv *adv, uint8_t status)
{
   1add4:	b570      	push	{r4, r5, r6, lr}
   1add6:	b084      	sub	sp, #16
   1add8:	4604      	mov	r4, r0
   1adda:	460e      	mov	r6, r1
	struct bt_conn *conn;

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
   1addc:	f100 0509 	add.w	r5, r0, #9
   1ade0:	2300      	movs	r3, #0
   1ade2:	9300      	str	r3, [sp, #0]
   1ade4:	f8cd 3003 	str.w	r3, [sp, #3]
   1ade8:	2207      	movs	r2, #7
   1adea:	4669      	mov	r1, sp
   1adec:	4628      	mov	r0, r5
   1adee:	f016 f82a 	bl	30e46 <memcmp>
   1adf2:	b9c8      	cbnz	r0, 1ae28 <le_adv_stop_free_conn+0x54>
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
   1adf4:	4b10      	ldr	r3, [pc, #64]	; (1ae38 <le_adv_stop_free_conn+0x64>)
   1adf6:	e893 0003 	ldmia.w	r3, {r0, r1}
   1adfa:	9002      	str	r0, [sp, #8]
   1adfc:	f8ad 100c 	strh.w	r1, [sp, #12]
   1ae00:	0c09      	lsrs	r1, r1, #16
   1ae02:	f88d 100e 	strb.w	r1, [sp, #14]
   1ae06:	2204      	movs	r2, #4
   1ae08:	a902      	add	r1, sp, #8
   1ae0a:	7820      	ldrb	r0, [r4, #0]
   1ae0c:	f000 fe96 	bl	1bb3c <bt_conn_lookup_state_le>
   1ae10:	4604      	mov	r4, r0
	} else {
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
					       BT_CONN_CONNECTING_DIR_ADV);
	}

	if (conn) {
   1ae12:	b13c      	cbz	r4, 1ae24 <le_adv_stop_free_conn+0x50>
		conn->err = status;
   1ae14:	7266      	strb	r6, [r4, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1ae16:	2100      	movs	r1, #0
   1ae18:	4620      	mov	r0, r4
   1ae1a:	f000 fc41 	bl	1b6a0 <bt_conn_set_state>
		bt_conn_unref(conn);
   1ae1e:	4620      	mov	r0, r4
   1ae20:	f000 fc02 	bl	1b628 <bt_conn_unref>
	}
}
   1ae24:	b004      	add	sp, #16
   1ae26:	bd70      	pop	{r4, r5, r6, pc}
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
   1ae28:	2205      	movs	r2, #5
   1ae2a:	4629      	mov	r1, r5
   1ae2c:	7820      	ldrb	r0, [r4, #0]
   1ae2e:	f000 fe85 	bl	1bb3c <bt_conn_lookup_state_le>
   1ae32:	4604      	mov	r4, r0
   1ae34:	e7ed      	b.n	1ae12 <le_adv_stop_free_conn+0x3e>
   1ae36:	bf00      	nop
   1ae38:	00031438 	.word	0x00031438

0001ae3c <bt_le_adv_lookup_legacy>:
}
   1ae3c:	4800      	ldr	r0, [pc, #0]	; (1ae40 <bt_le_adv_lookup_legacy+0x4>)
   1ae3e:	4770      	bx	lr
   1ae40:	20000438 	.word	0x20000438

0001ae44 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
   1ae44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ae48:	b08f      	sub	sp, #60	; 0x3c
   1ae4a:	9204      	str	r2, [sp, #16]
   1ae4c:	9305      	str	r3, [sp, #20]
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
   1ae4e:	2300      	movs	r3, #0
   1ae50:	9307      	str	r3, [sp, #28]
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable = false;
   1ae52:	690f      	ldr	r7, [r1, #16]
   1ae54:	ebb7 0b03 	subs.w	fp, r7, r3
   1ae58:	bf18      	it	ne
   1ae5a:	f04f 0b01 	movne.w	fp, #1
   1ae5e:	f3bf 8f5b 	dmb	ish
   1ae62:	4bb9      	ldr	r3, [pc, #740]	; (1b148 <bt_le_adv_start_legacy+0x304>)
   1ae64:	681b      	ldr	r3, [r3, #0]
   1ae66:	f3bf 8f5b 	dmb	ish
	enum adv_name_type name_type;

	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   1ae6a:	f013 0f04 	tst.w	r3, #4
   1ae6e:	f000 81b2 	beq.w	1b1d6 <bt_le_adv_start_legacy+0x392>
   1ae72:	4605      	mov	r5, r0
   1ae74:	460c      	mov	r4, r1
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
   1ae76:	4608      	mov	r0, r1
   1ae78:	f012 f84c 	bl	2cf14 <valid_adv_param>
   1ae7c:	2800      	cmp	r0, #0
   1ae7e:	f000 81ad 	beq.w	1b1dc <bt_le_adv_start_legacy+0x398>
		return -EINVAL;
	}

	if (!bt_id_adv_random_addr_check(param)) {
   1ae82:	4620      	mov	r0, r4
   1ae84:	f011 ff4c 	bl	2cd20 <bt_id_adv_random_addr_check>
   1ae88:	4681      	mov	r9, r0
   1ae8a:	2800      	cmp	r0, #0
   1ae8c:	f000 81a9 	beq.w	1b1e2 <bt_le_adv_start_legacy+0x39e>
		return -EINVAL;
	}

	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   1ae90:	f105 0610 	add.w	r6, r5, #16
   1ae94:	f3bf 8f5b 	dmb	ish
   1ae98:	692b      	ldr	r3, [r5, #16]
   1ae9a:	f3bf 8f5b 	dmb	ish
   1ae9e:	f3c3 1a80 	ubfx	sl, r3, #6, #1
   1aea2:	f013 0f40 	tst.w	r3, #64	; 0x40
   1aea6:	f040 819f 	bne.w	1b1e8 <bt_le_adv_start_legacy+0x3a4>
		return -EALREADY;
	}

	(void)memset(&set_param, 0, sizeof(set_param));
   1aeaa:	2300      	movs	r3, #0
   1aeac:	9308      	str	r3, [sp, #32]
   1aeae:	9309      	str	r3, [sp, #36]	; 0x24
   1aeb0:	930a      	str	r3, [sp, #40]	; 0x28
   1aeb2:	f8cd 302b 	str.w	r3, [sp, #43]	; 0x2b

	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
   1aeb6:	68a3      	ldr	r3, [r4, #8]
   1aeb8:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
   1aebc:	68e3      	ldr	r3, [r4, #12]
   1aebe:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = get_adv_channel_map(param->options);
   1aec2:	f8d4 8004 	ldr.w	r8, [r4, #4]
   1aec6:	4640      	mov	r0, r8
   1aec8:	f011 ff4d 	bl	2cd66 <get_adv_channel_map>
   1aecc:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	set_param.filter_policy = get_filter_policy(param->options);
   1aed0:	4640      	mov	r0, r8
   1aed2:	f011 ff46 	bl	2cd62 <get_filter_policy>
   1aed6:	f88d 002e 	strb.w	r0, [sp, #46]	; 0x2e

	if (adv->id != param->id) {
   1aeda:	782a      	ldrb	r2, [r5, #0]
   1aedc:	7823      	ldrb	r3, [r4, #0]
   1aede:	429a      	cmp	r2, r3
   1aee0:	d00c      	beq.n	1aefc <bt_le_adv_start_legacy+0xb8>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1aee2:	4b99      	ldr	r3, [pc, #612]	; (1b148 <bt_le_adv_start_legacy+0x304>)
   1aee4:	f3bf 8f5b 	dmb	ish
   1aee8:	e853 2f00 	ldrex	r2, [r3]
   1aeec:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
   1aef0:	e843 2100 	strex	r1, r2, [r3]
   1aef4:	2900      	cmp	r1, #0
   1aef6:	d1f7      	bne.n	1aee8 <bt_le_adv_start_legacy+0xa4>
   1aef8:	f3bf 8f5b 	dmb	ish
		atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
	}

	adv->id = param->id;
   1aefc:	7823      	ldrb	r3, [r4, #0]
   1aefe:	702b      	strb	r3, [r5, #0]
	bt_dev.adv_conn_id = adv->id;
   1af00:	4a92      	ldr	r2, [pc, #584]	; (1b14c <bt_le_adv_start_legacy+0x308>)
   1af02:	f882 3067 	strb.w	r3, [r2, #103]	; 0x67

	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
   1af06:	f10d 0325 	add.w	r3, sp, #37	; 0x25
   1af0a:	465a      	mov	r2, fp
   1af0c:	6861      	ldr	r1, [r4, #4]
   1af0e:	4628      	mov	r0, r5
   1af10:	f7ff fdec 	bl	1aaec <bt_id_set_adv_own_addr>
				     &set_param.own_addr_type);
	if (err) {
   1af14:	4680      	mov	r8, r0
   1af16:	2800      	cmp	r0, #0
   1af18:	f040 80ef 	bne.w	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return err;
	}

	if (dir_adv) {
   1af1c:	b31f      	cbz	r7, 1af66 <bt_le_adv_start_legacy+0x122>
		bt_addr_le_copy(&adv->target_addr, param->peer);
   1af1e:	6923      	ldr	r3, [r4, #16]
   1af20:	681a      	ldr	r2, [r3, #0]
   1af22:	f8c5 2009 	str.w	r2, [r5, #9]
   1af26:	889a      	ldrh	r2, [r3, #4]
   1af28:	799b      	ldrb	r3, [r3, #6]
   1af2a:	f8a5 200d 	strh.w	r2, [r5, #13]
   1af2e:	73eb      	strb	r3, [r5, #15]
	} else {
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
	}

	name_type = get_adv_name_type_param(param);
   1af30:	4620      	mov	r0, r4
   1af32:	f012 f800 	bl	2cf36 <get_adv_name_type_param>
   1af36:	4683      	mov	fp, r0

	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   1af38:	6863      	ldr	r3, [r4, #4]
   1af3a:	f013 0f01 	tst.w	r3, #1
   1af3e:	d022      	beq.n	1af86 <bt_le_adv_start_legacy+0x142>
		if (dir_adv) {
   1af40:	b1ef      	cbz	r7, 1af7e <bt_le_adv_start_legacy+0x13a>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   1af42:	f013 0f10 	tst.w	r3, #16
   1af46:	d016      	beq.n	1af76 <bt_le_adv_start_legacy+0x132>
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
   1af48:	2304      	movs	r3, #4
   1af4a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
			} else {
				set_param.type = BT_HCI_ADV_DIRECT_IND;
			}

			bt_addr_le_copy(&set_param.direct_addr, param->peer);
   1af4e:	6923      	ldr	r3, [r4, #16]
	memcpy(dst, src, sizeof(*dst));
   1af50:	681a      	ldr	r2, [r3, #0]
   1af52:	f8cd 2026 	str.w	r2, [sp, #38]	; 0x26
   1af56:	889a      	ldrh	r2, [r3, #4]
   1af58:	799b      	ldrb	r3, [r3, #6]
   1af5a:	f8ad 202a 	strh.w	r2, [sp, #42]	; 0x2a
   1af5e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	bool dir_adv = (param->peer != NULL), scannable = false;
   1af62:	46d1      	mov	r9, sl
}
   1af64:	e017      	b.n	1af96 <bt_le_adv_start_legacy+0x152>
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
   1af66:	2300      	movs	r3, #0
   1af68:	930c      	str	r3, [sp, #48]	; 0x30
   1af6a:	f8cd 3033 	str.w	r3, [sp, #51]	; 0x33
   1af6e:	f8c5 3009 	str.w	r3, [r5, #9]
   1af72:	60eb      	str	r3, [r5, #12]
   1af74:	e7dc      	b.n	1af30 <bt_le_adv_start_legacy+0xec>
				set_param.type = BT_HCI_ADV_DIRECT_IND;
   1af76:	2301      	movs	r3, #1
   1af78:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   1af7c:	e7e7      	b.n	1af4e <bt_le_adv_start_legacy+0x10a>
		} else {
			scannable = true;
			set_param.type = BT_HCI_ADV_IND;
   1af7e:	2300      	movs	r3, #0
   1af80:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   1af84:	e007      	b.n	1af96 <bt_le_adv_start_legacy+0x152>
		}
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
   1af86:	f413 7f00 	tst.w	r3, #512	; 0x200
   1af8a:	d101      	bne.n	1af90 <bt_le_adv_start_legacy+0x14c>
   1af8c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1af8e:	b35b      	cbz	r3, 1afe8 <bt_le_adv_start_legacy+0x1a4>
		   (name_type == ADV_NAME_TYPE_SD)) {
		scannable = true;
		set_param.type = BT_HCI_ADV_SCAN_IND;
   1af90:	2302      	movs	r3, #2
   1af92:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	} else {
		set_param.type = BT_HCI_ADV_NONCONN_IND;
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
   1af96:	210f      	movs	r1, #15
   1af98:	f242 0006 	movw	r0, #8198	; 0x2006
   1af9c:	f7fe fe54 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   1afa0:	4680      	mov	r8, r0
   1afa2:	2800      	cmp	r0, #0
   1afa4:	f000 8123 	beq.w	1b1ee <bt_le_adv_start_legacy+0x3aa>
   1afa8:	220f      	movs	r2, #15
   1afaa:	a908      	add	r1, sp, #32
   1afac:	3008      	adds	r0, #8
   1afae:	f013 ff9f 	bl	2eef0 <net_buf_simple_add_mem>
		return -ENOBUFS;
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
   1afb2:	2200      	movs	r2, #0
   1afb4:	4641      	mov	r1, r8
   1afb6:	f242 0006 	movw	r0, #8198	; 0x2006
   1afba:	f7fe fe93 	bl	19ce4 <bt_hci_cmd_send_sync>
	if (err) {
   1afbe:	4680      	mov	r8, r0
   1afc0:	2800      	cmp	r0, #0
   1afc2:	f040 809a 	bne.w	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return err;
	}

	if (!dir_adv) {
   1afc6:	b1b7      	cbz	r7, 1aff6 <bt_le_adv_start_legacy+0x1b2>
			return err;
		}
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   1afc8:	6863      	ldr	r3, [r4, #4]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1afca:	f013 0f01 	tst.w	r3, #1
   1afce:	d02a      	beq.n	1b026 <bt_le_adv_start_legacy+0x1e2>
		err = le_adv_start_add_conn(adv, &conn);
   1afd0:	a907      	add	r1, sp, #28
   1afd2:	4628      	mov	r0, r5
   1afd4:	f7ff feb4 	bl	1ad40 <le_adv_start_add_conn>
		if (err) {
   1afd8:	b328      	cbz	r0, 1b026 <bt_le_adv_start_legacy+0x1e2>
			if (err == -ENOMEM && !dir_adv &&
   1afda:	f110 0f0c 	cmn.w	r0, #12
   1afde:	f040 8109 	bne.w	1b1f4 <bt_le_adv_start_legacy+0x3b0>
   1afe2:	b1d7      	cbz	r7, 1b01a <bt_le_adv_start_legacy+0x1d6>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
				goto set_adv_state;
			}

			return err;
   1afe4:	4680      	mov	r8, r0
   1afe6:	e088      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
   1afe8:	2802      	cmp	r0, #2
   1afea:	d0d1      	beq.n	1af90 <bt_le_adv_start_legacy+0x14c>
		set_param.type = BT_HCI_ADV_NONCONN_IND;
   1afec:	2303      	movs	r3, #3
   1afee:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	bool dir_adv = (param->peer != NULL), scannable = false;
   1aff2:	46d1      	mov	r9, sl
   1aff4:	e7cf      	b.n	1af96 <bt_le_adv_start_legacy+0x152>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
   1aff6:	f8cd b00c 	str.w	fp, [sp, #12]
   1affa:	f8cd 9008 	str.w	r9, [sp, #8]
   1affe:	2300      	movs	r3, #0
   1b000:	9301      	str	r3, [sp, #4]
   1b002:	9b19      	ldr	r3, [sp, #100]	; 0x64
   1b004:	9300      	str	r3, [sp, #0]
   1b006:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1b008:	9a05      	ldr	r2, [sp, #20]
   1b00a:	9904      	ldr	r1, [sp, #16]
   1b00c:	4628      	mov	r0, r5
   1b00e:	f011 fef6 	bl	2cdfe <le_adv_update>
		if (err) {
   1b012:	2800      	cmp	r0, #0
   1b014:	d0d8      	beq.n	1afc8 <bt_le_adv_start_legacy+0x184>
			return err;
   1b016:	4680      	mov	r8, r0
   1b018:	e06f      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
   1b01a:	6862      	ldr	r2, [r4, #4]
			if (err == -ENOMEM && !dir_adv &&
   1b01c:	f012 0f02 	tst.w	r2, #2
   1b020:	d00c      	beq.n	1b03c <bt_le_adv_start_legacy+0x1f8>
			return err;
   1b022:	4680      	mov	r8, r0
   1b024:	e069      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
		}
	}

	err = bt_le_adv_set_enable(adv, true);
   1b026:	2101      	movs	r1, #1
   1b028:	4628      	mov	r0, r5
   1b02a:	f011 ffc0 	bl	2cfae <bt_le_adv_set_enable>
	if (err) {
   1b02e:	4605      	mov	r5, r0
   1b030:	2800      	cmp	r0, #0
   1b032:	d166      	bne.n	1b102 <bt_le_adv_start_legacy+0x2be>
		}

		return err;
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   1b034:	9807      	ldr	r0, [sp, #28]
   1b036:	b108      	cbz	r0, 1b03c <bt_le_adv_start_legacy+0x1f8>
		/* If undirected connectable advertiser we have created a
		 * connection object that we don't yet give to the application.
		 * Since we don't give the application a reference to manage in
		 * this case, we need to release this reference here
		 */
		bt_conn_unref(conn);
   1b038:	f000 faf6 	bl	1b628 <bt_conn_unref>
	}

set_adv_state:
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
   1b03c:	2f00      	cmp	r7, #0
   1b03e:	d06e      	beq.n	1b11e <bt_le_adv_start_legacy+0x2da>
   1b040:	4643      	mov	r3, r8
	if (val) {
   1b042:	f013 0f01 	tst.w	r3, #1
   1b046:	d072      	beq.n	1b12e <bt_le_adv_start_legacy+0x2ea>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1b048:	f3bf 8f5b 	dmb	ish
   1b04c:	e856 3f00 	ldrex	r3, [r6]
   1b050:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   1b054:	e846 3200 	strex	r2, r3, [r6]
   1b058:	2a00      	cmp	r2, #0
   1b05a:	d1f7      	bne.n	1b04c <bt_le_adv_start_legacy+0x208>
   1b05c:	f3bf 8f5b 	dmb	ish
   1b060:	f1bb 0f01 	cmp.w	fp, #1
   1b064:	d176      	bne.n	1b154 <bt_le_adv_start_legacy+0x310>
   1b066:	f3bf 8f5b 	dmb	ish
   1b06a:	e856 3f00 	ldrex	r3, [r6]
   1b06e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1b072:	e846 3200 	strex	r2, r3, [r6]
   1b076:	2a00      	cmp	r2, #0
   1b078:	d1f7      	bne.n	1b06a <bt_le_adv_start_legacy+0x226>
   1b07a:	f3bf 8f5b 	dmb	ish
   1b07e:	f1bb 0f02 	cmp.w	fp, #2
   1b082:	d174      	bne.n	1b16e <bt_le_adv_start_legacy+0x32a>
   1b084:	f3bf 8f5b 	dmb	ish
   1b088:	e856 3f00 	ldrex	r3, [r6]
   1b08c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1b090:	e846 3200 	strex	r2, r3, [r6]
   1b094:	2a00      	cmp	r2, #0
   1b096:	d1f7      	bne.n	1b088 <bt_le_adv_start_legacy+0x244>
   1b098:	f3bf 8f5b 	dmb	ish

	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
			  name_type == ADV_NAME_TYPE_SD);

	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
			  param->options & BT_LE_ADV_OPT_CONNECTABLE);
   1b09c:	6863      	ldr	r3, [r4, #4]
   1b09e:	f013 0f01 	tst.w	r3, #1
   1b0a2:	d071      	beq.n	1b188 <bt_le_adv_start_legacy+0x344>
   1b0a4:	f3bf 8f5b 	dmb	ish
   1b0a8:	e856 3f00 	ldrex	r3, [r6]
   1b0ac:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1b0b0:	e846 3200 	strex	r2, r3, [r6]
   1b0b4:	2a00      	cmp	r2, #0
   1b0b6:	d1f7      	bne.n	1b0a8 <bt_le_adv_start_legacy+0x264>
   1b0b8:	f3bf 8f5b 	dmb	ish
   1b0bc:	f1b9 0f00 	cmp.w	r9, #0
   1b0c0:	d06f      	beq.n	1b1a2 <bt_le_adv_start_legacy+0x35e>
   1b0c2:	f3bf 8f5b 	dmb	ish
   1b0c6:	e856 3f00 	ldrex	r3, [r6]
   1b0ca:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   1b0ce:	e846 3200 	strex	r2, r3, [r6]
   1b0d2:	2a00      	cmp	r2, #0
   1b0d4:	d1f7      	bne.n	1b0c6 <bt_le_adv_start_legacy+0x282>
   1b0d6:	f3bf 8f5b 	dmb	ish

	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);
   1b0da:	6863      	ldr	r3, [r4, #4]
   1b0dc:	f013 0f04 	tst.w	r3, #4
   1b0e0:	d06c      	beq.n	1b1bc <bt_le_adv_start_legacy+0x378>
   1b0e2:	f3bf 8f5b 	dmb	ish
   1b0e6:	e856 3f00 	ldrex	r3, [r6]
   1b0ea:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   1b0ee:	e846 3200 	strex	r2, r3, [r6]
   1b0f2:	2a00      	cmp	r2, #0
   1b0f4:	d1f7      	bne.n	1b0e6 <bt_le_adv_start_legacy+0x2a2>
   1b0f6:	f3bf 8f5b 	dmb	ish

	return 0;
}
   1b0fa:	4640      	mov	r0, r8
   1b0fc:	b00f      	add	sp, #60	; 0x3c
   1b0fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		BT_ERR("Failed to start advertiser");
   1b102:	2145      	movs	r1, #69	; 0x45
   1b104:	4812      	ldr	r0, [pc, #72]	; (1b150 <bt_le_adv_start_legacy+0x30c>)
   1b106:	f011 fa21 	bl	2c54c <z_log_minimal_printk>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
   1b10a:	9807      	ldr	r0, [sp, #28]
   1b10c:	b128      	cbz	r0, 1b11a <bt_le_adv_start_legacy+0x2d6>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1b10e:	2100      	movs	r1, #0
   1b110:	f000 fac6 	bl	1b6a0 <bt_conn_set_state>
			bt_conn_unref(conn);
   1b114:	9807      	ldr	r0, [sp, #28]
   1b116:	f000 fa87 	bl	1b628 <bt_conn_unref>
		return err;
   1b11a:	46a8      	mov	r8, r5
   1b11c:	e7ed      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
			  !(param->options & BT_LE_ADV_OPT_ONE_TIME));
   1b11e:	6863      	ldr	r3, [r4, #4]
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
   1b120:	f013 0f02 	tst.w	r3, #2
   1b124:	d001      	beq.n	1b12a <bt_le_adv_start_legacy+0x2e6>
   1b126:	4643      	mov	r3, r8
   1b128:	e78b      	b.n	1b042 <bt_le_adv_start_legacy+0x1fe>
   1b12a:	2301      	movs	r3, #1
   1b12c:	e789      	b.n	1b042 <bt_le_adv_start_legacy+0x1fe>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1b12e:	f3bf 8f5b 	dmb	ish
   1b132:	e856 3f00 	ldrex	r3, [r6]
   1b136:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   1b13a:	e846 3200 	strex	r2, r3, [r6]
   1b13e:	2a00      	cmp	r2, #0
   1b140:	d1f7      	bne.n	1b132 <bt_le_adv_start_legacy+0x2ee>
   1b142:	f3bf 8f5b 	dmb	ish
   1b146:	e78b      	b.n	1b060 <bt_le_adv_start_legacy+0x21c>
   1b148:	200004ec 	.word	0x200004ec
   1b14c:	20000420 	.word	0x20000420
   1b150:	0003a0e8 	.word	0x0003a0e8
   1b154:	f3bf 8f5b 	dmb	ish
   1b158:	e856 3f00 	ldrex	r3, [r6]
   1b15c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1b160:	e846 3200 	strex	r2, r3, [r6]
   1b164:	2a00      	cmp	r2, #0
   1b166:	d1f7      	bne.n	1b158 <bt_le_adv_start_legacy+0x314>
   1b168:	f3bf 8f5b 	dmb	ish
   1b16c:	e787      	b.n	1b07e <bt_le_adv_start_legacy+0x23a>
   1b16e:	f3bf 8f5b 	dmb	ish
   1b172:	e856 3f00 	ldrex	r3, [r6]
   1b176:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1b17a:	e846 3200 	strex	r2, r3, [r6]
   1b17e:	2a00      	cmp	r2, #0
   1b180:	d1f7      	bne.n	1b172 <bt_le_adv_start_legacy+0x32e>
   1b182:	f3bf 8f5b 	dmb	ish
   1b186:	e789      	b.n	1b09c <bt_le_adv_start_legacy+0x258>
   1b188:	f3bf 8f5b 	dmb	ish
   1b18c:	e856 3f00 	ldrex	r3, [r6]
   1b190:	f423 7300 	bic.w	r3, r3, #512	; 0x200
   1b194:	e846 3200 	strex	r2, r3, [r6]
   1b198:	2a00      	cmp	r2, #0
   1b19a:	d1f7      	bne.n	1b18c <bt_le_adv_start_legacy+0x348>
   1b19c:	f3bf 8f5b 	dmb	ish
   1b1a0:	e78c      	b.n	1b0bc <bt_le_adv_start_legacy+0x278>
   1b1a2:	f3bf 8f5b 	dmb	ish
   1b1a6:	e856 3f00 	ldrex	r3, [r6]
   1b1aa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   1b1ae:	e846 3200 	strex	r2, r3, [r6]
   1b1b2:	2a00      	cmp	r2, #0
   1b1b4:	d1f7      	bne.n	1b1a6 <bt_le_adv_start_legacy+0x362>
   1b1b6:	f3bf 8f5b 	dmb	ish
   1b1ba:	e78e      	b.n	1b0da <bt_le_adv_start_legacy+0x296>
   1b1bc:	f3bf 8f5b 	dmb	ish
   1b1c0:	e856 3f00 	ldrex	r3, [r6]
   1b1c4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   1b1c8:	e846 3200 	strex	r2, r3, [r6]
   1b1cc:	2a00      	cmp	r2, #0
   1b1ce:	d1f7      	bne.n	1b1c0 <bt_le_adv_start_legacy+0x37c>
   1b1d0:	f3bf 8f5b 	dmb	ish
}
   1b1d4:	e791      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return -EAGAIN;
   1b1d6:	f06f 080a 	mvn.w	r8, #10
   1b1da:	e78e      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return -EINVAL;
   1b1dc:	f06f 0815 	mvn.w	r8, #21
   1b1e0:	e78b      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return -EINVAL;
   1b1e2:	f06f 0815 	mvn.w	r8, #21
   1b1e6:	e788      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return -EALREADY;
   1b1e8:	f06f 0877 	mvn.w	r8, #119	; 0x77
   1b1ec:	e785      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
		return -ENOBUFS;
   1b1ee:	f06f 0868 	mvn.w	r8, #104	; 0x68
   1b1f2:	e782      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>
			return err;
   1b1f4:	4680      	mov	r8, r0
   1b1f6:	e780      	b.n	1b0fa <bt_le_adv_start_legacy+0x2b6>

0001b1f8 <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
   1b1f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b1fc:	b082      	sub	sp, #8
   1b1fe:	4606      	mov	r6, r0
   1b200:	460c      	mov	r4, r1
   1b202:	4615      	mov	r5, r2
   1b204:	461f      	mov	r7, r3
	struct bt_le_ext_adv *adv = adv_new_legacy();
   1b206:	f7ff fcf5 	bl	1abf4 <adv_new_legacy>
	int err;

	if (!adv) {
   1b20a:	b1f8      	cbz	r0, 1b24c <bt_le_adv_start+0x54>
   1b20c:	4680      	mov	r8, r0

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
   1b20e:	9b08      	ldr	r3, [sp, #32]
   1b210:	9301      	str	r3, [sp, #4]
   1b212:	9700      	str	r7, [sp, #0]
   1b214:	462b      	mov	r3, r5
   1b216:	4622      	mov	r2, r4
   1b218:	4631      	mov	r1, r6
   1b21a:	f7ff fe13 	bl	1ae44 <bt_le_adv_start_legacy>
   1b21e:	4606      	mov	r6, r0

	if (err) {
		bt_le_adv_delete_legacy();
	}

	if (ad_is_limited(ad, ad_len)) {
   1b220:	4629      	mov	r1, r5
   1b222:	4620      	mov	r0, r4
   1b224:	f011 fd7e 	bl	2cd24 <ad_is_limited>
   1b228:	b918      	cbnz	r0, 1b232 <bt_le_adv_start+0x3a>
		k_work_reschedule(&adv->lim_adv_timeout_work,
				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
	}

	return err;
}
   1b22a:	4630      	mov	r0, r6
   1b22c:	b002      	add	sp, #8
   1b22e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
   1b232:	f108 0818 	add.w	r8, r8, #24
   1b236:	4907      	ldr	r1, [pc, #28]	; (1b254 <bt_le_adv_start+0x5c>)
   1b238:	4640      	mov	r0, r8
   1b23a:	f00c faaf 	bl	2779c <k_work_init_delayable>
		k_work_reschedule(&adv->lim_adv_timeout_work,
   1b23e:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   1b242:	2300      	movs	r3, #0
   1b244:	4640      	mov	r0, r8
   1b246:	f00c fbd9 	bl	279fc <k_work_reschedule>
   1b24a:	e7ee      	b.n	1b22a <bt_le_adv_start+0x32>
		return -ENOMEM;
   1b24c:	f06f 060b 	mvn.w	r6, #11
   1b250:	e7eb      	b.n	1b22a <bt_le_adv_start+0x32>
   1b252:	bf00      	nop
   1b254:	0001b2cd 	.word	0x0001b2cd

0001b258 <bt_le_adv_stop>:

int bt_le_adv_stop(void)
{
   1b258:	b510      	push	{r4, lr}
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   1b25a:	f7ff fdef 	bl	1ae3c <bt_le_adv_lookup_legacy>
	int err;

	if (!adv) {
   1b25e:	b1d0      	cbz	r0, 1b296 <bt_le_adv_stop+0x3e>
   1b260:	4604      	mov	r4, r0
		BT_ERR("No valid legacy adv");
		return 0;
	}

	(void)bt_le_lim_adv_cancel_timeout(adv);
   1b262:	f011 fea8 	bl	2cfb6 <bt_le_lim_adv_cancel_timeout>

	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);
   1b266:	f104 0310 	add.w	r3, r4, #16
   1b26a:	f3bf 8f5b 	dmb	ish
   1b26e:	e853 2f00 	ldrex	r2, [r3]
   1b272:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
   1b276:	e843 2100 	strex	r1, r2, [r3]
   1b27a:	2900      	cmp	r1, #0
   1b27c:	d1f7      	bne.n	1b26e <bt_le_adv_stop+0x16>
   1b27e:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1b282:	f3bf 8f5b 	dmb	ish
   1b286:	6923      	ldr	r3, [r4, #16]
   1b288:	f3bf 8f5b 	dmb	ish

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   1b28c:	f013 0f40 	tst.w	r3, #64	; 0x40
   1b290:	d107      	bne.n	1b2a2 <bt_le_adv_stop+0x4a>
		/* Legacy advertiser exists, but is not currently advertising.
		 * This happens when keep advertising behavior is active but
		 * no conn object is available to do connectable advertising.
		 */
		bt_le_adv_delete_legacy();
		return 0;
   1b292:	2000      	movs	r0, #0
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
   1b294:	bd10      	pop	{r4, pc}
		BT_ERR("No valid legacy adv");
   1b296:	2145      	movs	r1, #69	; 0x45
   1b298:	480b      	ldr	r0, [pc, #44]	; (1b2c8 <bt_le_adv_stop+0x70>)
   1b29a:	f011 f957 	bl	2c54c <z_log_minimal_printk>
		return 0;
   1b29e:	2000      	movs	r0, #0
   1b2a0:	e7f8      	b.n	1b294 <bt_le_adv_stop+0x3c>
   1b2a2:	f3bf 8f5b 	dmb	ish
   1b2a6:	6923      	ldr	r3, [r4, #16]
   1b2a8:	f3bf 8f5b 	dmb	ish
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1b2ac:	f413 7f00 	tst.w	r3, #512	; 0x200
   1b2b0:	d104      	bne.n	1b2bc <bt_le_adv_stop+0x64>
		err = bt_le_adv_set_enable_legacy(adv, false);
   1b2b2:	2100      	movs	r1, #0
   1b2b4:	4620      	mov	r0, r4
   1b2b6:	f011 fe52 	bl	2cf5e <bt_le_adv_set_enable_legacy>
		if (err) {
   1b2ba:	e7eb      	b.n	1b294 <bt_le_adv_stop+0x3c>
		le_adv_stop_free_conn(adv, 0);
   1b2bc:	2100      	movs	r1, #0
   1b2be:	4620      	mov	r0, r4
   1b2c0:	f7ff fd88 	bl	1add4 <le_adv_stop_free_conn>
   1b2c4:	e7f5      	b.n	1b2b2 <bt_le_adv_stop+0x5a>
   1b2c6:	bf00      	nop
   1b2c8:	0003a108 	.word	0x0003a108

0001b2cc <adv_timeout>:
}
#endif /* defined(CONFIG_BT_EXT_ADV) */


static void adv_timeout(struct k_work *work)
{
   1b2cc:	b508      	push	{r3, lr}
		err = bt_le_adv_stop();
	} else {
		err = bt_le_ext_adv_stop(adv);
	}
#else
	err = bt_le_adv_stop();
   1b2ce:	f7ff ffc3 	bl	1b258 <bt_le_adv_stop>
   1b2d2:	4602      	mov	r2, r0
#endif
	BT_WARN("Failed to stop advertising: %d", err);
   1b2d4:	2157      	movs	r1, #87	; 0x57
   1b2d6:	4802      	ldr	r0, [pc, #8]	; (1b2e0 <adv_timeout+0x14>)
   1b2d8:	f011 f938 	bl	2c54c <z_log_minimal_printk>
}
   1b2dc:	bd08      	pop	{r3, pc}
   1b2de:	bf00      	nop
   1b2e0:	0003a124 	.word	0x0003a124

0001b2e4 <tx_free>:
		return "(unknown)";
	}
}

static void tx_free(struct bt_conn_tx *tx)
{
   1b2e4:	b508      	push	{r3, lr}
   1b2e6:	4601      	mov	r1, r0
	tx->cb = NULL;
   1b2e8:	2300      	movs	r3, #0
   1b2ea:	6043      	str	r3, [r0, #4]
	tx->user_data = NULL;
   1b2ec:	6083      	str	r3, [r0, #8]
	tx->pending_no_cb = 0U;
   1b2ee:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
   1b2f0:	4801      	ldr	r0, [pc, #4]	; (1b2f8 <tx_free+0x14>)
   1b2f2:	f015 fb81 	bl	309f8 <k_queue_append>
}
   1b2f6:	bd08      	pop	{r3, pc}
   1b2f8:	20000ee8 	.word	0x20000ee8

0001b2fc <notify_disconnected>:
		}
	}
}

static void notify_disconnected(struct bt_conn *conn)
{
   1b2fc:	b570      	push	{r4, r5, r6, lr}
   1b2fe:	4605      	mov	r5, r0
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
   1b300:	4b14      	ldr	r3, [pc, #80]	; (1b354 <notify_disconnected+0x58>)
   1b302:	681c      	ldr	r4, [r3, #0]
   1b304:	e003      	b.n	1b30e <notify_disconnected+0x12>
		if (cb->disconnected) {
			cb->disconnected(conn, conn->err);
   1b306:	7a69      	ldrb	r1, [r5, #9]
   1b308:	4628      	mov	r0, r5
   1b30a:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   1b30c:	6924      	ldr	r4, [r4, #16]
   1b30e:	b11c      	cbz	r4, 1b318 <notify_disconnected+0x1c>
		if (cb->disconnected) {
   1b310:	6863      	ldr	r3, [r4, #4]
   1b312:	2b00      	cmp	r3, #0
   1b314:	d1f7      	bne.n	1b306 <notify_disconnected+0xa>
   1b316:	e7f9      	b.n	1b30c <notify_disconnected+0x10>
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1b318:	4c0f      	ldr	r4, [pc, #60]	; (1b358 <notify_disconnected+0x5c>)
   1b31a:	e000      	b.n	1b31e <notify_disconnected+0x22>
   1b31c:	3414      	adds	r4, #20
   1b31e:	4b0f      	ldr	r3, [pc, #60]	; (1b35c <notify_disconnected+0x60>)
   1b320:	429c      	cmp	r4, r3
   1b322:	d809      	bhi.n	1b338 <notify_disconnected+0x3c>
   1b324:	4b0d      	ldr	r3, [pc, #52]	; (1b35c <notify_disconnected+0x60>)
   1b326:	429c      	cmp	r4, r3
   1b328:	d213      	bcs.n	1b352 <notify_disconnected+0x56>
		if (cb->disconnected) {
   1b32a:	6863      	ldr	r3, [r4, #4]
   1b32c:	2b00      	cmp	r3, #0
   1b32e:	d0f5      	beq.n	1b31c <notify_disconnected+0x20>
			cb->disconnected(conn, conn->err);
   1b330:	7a69      	ldrb	r1, [r5, #9]
   1b332:	4628      	mov	r0, r5
   1b334:	4798      	blx	r3
   1b336:	e7f1      	b.n	1b31c <notify_disconnected+0x20>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1b338:	4e09      	ldr	r6, [pc, #36]	; (1b360 <notify_disconnected+0x64>)
   1b33a:	f240 5252 	movw	r2, #1362	; 0x552
   1b33e:	4631      	mov	r1, r6
   1b340:	4808      	ldr	r0, [pc, #32]	; (1b364 <notify_disconnected+0x68>)
   1b342:	f011 f8f4 	bl	2c52e <assert_print>
   1b346:	f240 5152 	movw	r1, #1362	; 0x552
   1b34a:	4630      	mov	r0, r6
   1b34c:	f011 f8e8 	bl	2c520 <assert_post_action>
   1b350:	e7e8      	b.n	1b324 <notify_disconnected+0x28>
		}
	}
}
   1b352:	bd70      	pop	{r4, r5, r6, pc}
   1b354:	20003acc 	.word	0x20003acc
   1b358:	00031294 	.word	0x00031294
   1b35c:	000312a8 	.word	0x000312a8
   1b360:	0003a150 	.word	0x0003a150
   1b364:	00031600 	.word	0x00031600

0001b368 <conn_tx_destroy>:
{
   1b368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b36a:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(tx);
   1b36c:	460d      	mov	r5, r1
   1b36e:	b151      	cbz	r1, 1b386 <conn_tx_destroy+0x1e>
	bt_conn_tx_cb_t cb = tx->cb;
   1b370:	686e      	ldr	r6, [r5, #4]
	void *user_data = tx->user_data;
   1b372:	68af      	ldr	r7, [r5, #8]
	tx_free(tx);
   1b374:	4628      	mov	r0, r5
   1b376:	f7ff ffb5 	bl	1b2e4 <tx_free>
	cb(conn, user_data, -ESHUTDOWN);
   1b37a:	f06f 026d 	mvn.w	r2, #109	; 0x6d
   1b37e:	4639      	mov	r1, r7
   1b380:	4620      	mov	r0, r4
   1b382:	47b0      	blx	r6
}
   1b384:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT_NO_MSG(tx);
   1b386:	4e05      	ldr	r6, [pc, #20]	; (1b39c <conn_tx_destroy+0x34>)
   1b388:	2237      	movs	r2, #55	; 0x37
   1b38a:	4631      	mov	r1, r6
   1b38c:	4804      	ldr	r0, [pc, #16]	; (1b3a0 <conn_tx_destroy+0x38>)
   1b38e:	f011 f8ce 	bl	2c52e <assert_print>
   1b392:	2137      	movs	r1, #55	; 0x37
   1b394:	4630      	mov	r0, r6
   1b396:	f011 f8c3 	bl	2c520 <assert_post_action>
   1b39a:	e7e9      	b.n	1b370 <conn_tx_destroy+0x8>
   1b39c:	0003a150 	.word	0x0003a150
   1b3a0:	00031600 	.word	0x00031600

0001b3a4 <notify_connected>:
{
   1b3a4:	b570      	push	{r4, r5, r6, lr}
   1b3a6:	4605      	mov	r5, r0
	for (cb = callback_list; cb; cb = cb->_next) {
   1b3a8:	4b14      	ldr	r3, [pc, #80]	; (1b3fc <notify_connected+0x58>)
   1b3aa:	681c      	ldr	r4, [r3, #0]
   1b3ac:	e003      	b.n	1b3b6 <notify_connected+0x12>
			cb->connected(conn, conn->err);
   1b3ae:	7a69      	ldrb	r1, [r5, #9]
   1b3b0:	4628      	mov	r0, r5
   1b3b2:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   1b3b4:	6924      	ldr	r4, [r4, #16]
   1b3b6:	b11c      	cbz	r4, 1b3c0 <notify_connected+0x1c>
		if (cb->connected) {
   1b3b8:	6823      	ldr	r3, [r4, #0]
   1b3ba:	2b00      	cmp	r3, #0
   1b3bc:	d1f7      	bne.n	1b3ae <notify_connected+0xa>
   1b3be:	e7f9      	b.n	1b3b4 <notify_connected+0x10>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1b3c0:	4c0f      	ldr	r4, [pc, #60]	; (1b400 <notify_connected+0x5c>)
   1b3c2:	e000      	b.n	1b3c6 <notify_connected+0x22>
   1b3c4:	3414      	adds	r4, #20
   1b3c6:	4b0f      	ldr	r3, [pc, #60]	; (1b404 <notify_connected+0x60>)
   1b3c8:	429c      	cmp	r4, r3
   1b3ca:	d809      	bhi.n	1b3e0 <notify_connected+0x3c>
   1b3cc:	4b0d      	ldr	r3, [pc, #52]	; (1b404 <notify_connected+0x60>)
   1b3ce:	429c      	cmp	r4, r3
   1b3d0:	d213      	bcs.n	1b3fa <notify_connected+0x56>
		if (cb->connected) {
   1b3d2:	6823      	ldr	r3, [r4, #0]
   1b3d4:	2b00      	cmp	r3, #0
   1b3d6:	d0f5      	beq.n	1b3c4 <notify_connected+0x20>
			cb->connected(conn, conn->err);
   1b3d8:	7a69      	ldrb	r1, [r5, #9]
   1b3da:	4628      	mov	r0, r5
   1b3dc:	4798      	blx	r3
   1b3de:	e7f1      	b.n	1b3c4 <notify_connected+0x20>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1b3e0:	4e09      	ldr	r6, [pc, #36]	; (1b408 <notify_connected+0x64>)
   1b3e2:	f240 5241 	movw	r2, #1345	; 0x541
   1b3e6:	4631      	mov	r1, r6
   1b3e8:	4808      	ldr	r0, [pc, #32]	; (1b40c <notify_connected+0x68>)
   1b3ea:	f011 f8a0 	bl	2c52e <assert_print>
   1b3ee:	f240 5141 	movw	r1, #1345	; 0x541
   1b3f2:	4630      	mov	r0, r6
   1b3f4:	f011 f894 	bl	2c520 <assert_post_action>
   1b3f8:	e7e8      	b.n	1b3cc <notify_connected+0x28>
}
   1b3fa:	bd70      	pop	{r4, r5, r6, pc}
   1b3fc:	20003acc 	.word	0x20003acc
   1b400:	00031294 	.word	0x00031294
   1b404:	000312a8 	.word	0x000312a8
   1b408:	0003a150 	.word	0x0003a150
   1b40c:	00031600 	.word	0x00031600

0001b410 <conn_tx_alloc>:
{
   1b410:	b508      	push	{r3, lr}
	return z_impl_z_current_get();
   1b412:	f00d fce7 	bl	28de4 <z_impl_z_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
   1b416:	4b08      	ldr	r3, [pc, #32]	; (1b438 <conn_tx_alloc+0x28>)
   1b418:	4283      	cmp	r3, r0
   1b41a:	d007      	beq.n	1b42c <conn_tx_alloc+0x1c>
	return z_impl_k_queue_get(queue, timeout);
   1b41c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1b420:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1b424:	4805      	ldr	r0, [pc, #20]	; (1b43c <conn_tx_alloc+0x2c>)
   1b426:	f00b fd3d 	bl	26ea4 <z_impl_k_queue_get>
}
   1b42a:	bd08      	pop	{r3, pc}
   1b42c:	2200      	movs	r2, #0
   1b42e:	2300      	movs	r3, #0
   1b430:	4802      	ldr	r0, [pc, #8]	; (1b43c <conn_tx_alloc+0x2c>)
   1b432:	f00b fd37 	bl	26ea4 <z_impl_k_queue_get>
		return k_fifo_get(&free_tx, K_NO_WAIT);
   1b436:	e7f8      	b.n	1b42a <conn_tx_alloc+0x1a>
   1b438:	20002770 	.word	0x20002770
   1b43c:	20000ee8 	.word	0x20000ee8

0001b440 <bt_conn_get_pkts>:
}
   1b440:	4800      	ldr	r0, [pc, #0]	; (1b444 <bt_conn_get_pkts+0x4>)
   1b442:	4770      	bx	lr
   1b444:	20000520 	.word	0x20000520

0001b448 <bt_conn_new>:
{
   1b448:	b538      	push	{r3, r4, r5, lr}
	for (i = 0; i < size; i++) {
   1b44a:	2300      	movs	r3, #0
   1b44c:	428b      	cmp	r3, r1
   1b44e:	d228      	bcs.n	1b4a2 <bt_conn_new+0x5a>
		if (atomic_cas(&conns[i].ref, 0, 1)) {
   1b450:	24c8      	movs	r4, #200	; 0xc8
   1b452:	fb04 0403 	mla	r4, r4, r3, r0
   1b456:	f104 02c0 	add.w	r2, r4, #192	; 0xc0
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1b45a:	f04f 0c01 	mov.w	ip, #1
   1b45e:	f3bf 8f5b 	dmb	ish
   1b462:	e852 ef00 	ldrex	lr, [r2]
   1b466:	f1be 0f00 	cmp.w	lr, #0
   1b46a:	d103      	bne.n	1b474 <bt_conn_new+0x2c>
   1b46c:	e842 c500 	strex	r5, ip, [r2]
   1b470:	2d00      	cmp	r5, #0
   1b472:	d1f6      	bne.n	1b462 <bt_conn_new+0x1a>
   1b474:	f3bf 8f5b 	dmb	ish
   1b478:	d111      	bne.n	1b49e <bt_conn_new+0x56>
	if (!conn) {
   1b47a:	b174      	cbz	r4, 1b49a <bt_conn_new+0x52>
__ssp_bos_icheck3(memset, void *, int)
   1b47c:	22c0      	movs	r2, #192	; 0xc0
   1b47e:	2100      	movs	r1, #0
   1b480:	4620      	mov	r0, r4
   1b482:	f015 fd11 	bl	30ea8 <memset>
	k_work_init_delayable(&conn->deferred_work, deferred_work);
   1b486:	4908      	ldr	r1, [pc, #32]	; (1b4a8 <bt_conn_new+0x60>)
   1b488:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1b48c:	f00c f986 	bl	2779c <k_work_init_delayable>
	k_work_init(&conn->tx_complete_work, tx_complete_work);
   1b490:	4906      	ldr	r1, [pc, #24]	; (1b4ac <bt_conn_new+0x64>)
   1b492:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1b496:	f00c f86b 	bl	27570 <k_work_init>
}
   1b49a:	4620      	mov	r0, r4
   1b49c:	bd38      	pop	{r3, r4, r5, pc}
	for (i = 0; i < size; i++) {
   1b49e:	4463      	add	r3, ip
   1b4a0:	e7d4      	b.n	1b44c <bt_conn_new+0x4>
	struct bt_conn *conn = NULL;
   1b4a2:	2400      	movs	r4, #0
   1b4a4:	e7e9      	b.n	1b47a <bt_conn_new+0x32>
   1b4a6:	bf00      	nop
   1b4a8:	0001bc11 	.word	0x0001bc11
   1b4ac:	0002d0ab 	.word	0x0002d0ab

0001b4b0 <acl_conn_new>:

	atomic_set_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_UPDATE);
}

static struct bt_conn *acl_conn_new(void)
{
   1b4b0:	b508      	push	{r3, lr}
	return bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
   1b4b2:	2101      	movs	r1, #1
   1b4b4:	4801      	ldr	r0, [pc, #4]	; (1b4bc <acl_conn_new+0xc>)
   1b4b6:	f7ff ffc7 	bl	1b448 <bt_conn_new>
}
   1b4ba:	bd08      	pop	{r3, pc}
   1b4bc:	20002268 	.word	0x20002268

0001b4c0 <bt_acl_recv>:
{
   1b4c0:	b570      	push	{r4, r5, r6, lr}
   1b4c2:	4604      	mov	r4, r0
   1b4c4:	460d      	mov	r5, r1
	switch (flags) {
   1b4c6:	2a01      	cmp	r2, #1
   1b4c8:	d020      	beq.n	1b50c <bt_acl_recv+0x4c>
   1b4ca:	2a02      	cmp	r2, #2
   1b4cc:	d14f      	bne.n	1b56e <bt_acl_recv+0xae>
		if (conn->rx) {
   1b4ce:	6903      	ldr	r3, [r0, #16]
   1b4d0:	b133      	cbz	r3, 1b4e0 <bt_acl_recv+0x20>
			BT_ERR("Unexpected first L2CAP frame");
   1b4d2:	2145      	movs	r1, #69	; 0x45
   1b4d4:	482f      	ldr	r0, [pc, #188]	; (1b594 <bt_acl_recv+0xd4>)
   1b4d6:	f011 f839 	bl	2c54c <z_log_minimal_printk>
			bt_conn_reset_rx_state(conn);
   1b4da:	4620      	mov	r0, r4
   1b4dc:	f011 fe2c 	bl	2d138 <bt_conn_reset_rx_state>
		conn->rx = buf;
   1b4e0:	6125      	str	r5, [r4, #16]
	if (conn->rx->len < sizeof(uint16_t)) {
   1b4e2:	6921      	ldr	r1, [r4, #16]
   1b4e4:	898a      	ldrh	r2, [r1, #12]
   1b4e6:	2a01      	cmp	r2, #1
   1b4e8:	d94b      	bls.n	1b582 <bt_acl_recv+0xc2>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
   1b4ea:	6888      	ldr	r0, [r1, #8]
	return ((uint16_t)src[1] << 8) | src[0];
   1b4ec:	7845      	ldrb	r5, [r0, #1]
   1b4ee:	7803      	ldrb	r3, [r0, #0]
   1b4f0:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
   1b4f4:	3304      	adds	r3, #4
   1b4f6:	b29b      	uxth	r3, r3
	if (conn->rx->len < acl_total_len) {
   1b4f8:	429a      	cmp	r2, r3
   1b4fa:	d342      	bcc.n	1b582 <bt_acl_recv+0xc2>
	if (conn->rx->len > acl_total_len) {
   1b4fc:	d842      	bhi.n	1b584 <bt_acl_recv+0xc4>
	conn->rx = NULL;
   1b4fe:	2300      	movs	r3, #0
   1b500:	6123      	str	r3, [r4, #16]
	bt_l2cap_recv(conn, buf, true);
   1b502:	2201      	movs	r2, #1
   1b504:	4620      	mov	r0, r4
   1b506:	f000 fcfd 	bl	1bf04 <bt_l2cap_recv>
   1b50a:	e03a      	b.n	1b582 <bt_acl_recv+0xc2>
		if (!conn->rx) {
   1b50c:	6900      	ldr	r0, [r0, #16]
   1b50e:	b180      	cbz	r0, 1b532 <bt_acl_recv+0x72>
		if (!buf->len) {
   1b510:	898e      	ldrh	r6, [r1, #12]
   1b512:	b1ce      	cbz	r6, 1b548 <bt_acl_recv+0x88>
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
   1b514:	3008      	adds	r0, #8
   1b516:	f013 fce2 	bl	2eede <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
   1b51a:	4286      	cmp	r6, r0
   1b51c:	d818      	bhi.n	1b550 <bt_acl_recv+0x90>
		net_buf_add_mem(conn->rx, buf->data, buf->len);
   1b51e:	6920      	ldr	r0, [r4, #16]
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1b520:	89aa      	ldrh	r2, [r5, #12]
   1b522:	68a9      	ldr	r1, [r5, #8]
   1b524:	3008      	adds	r0, #8
   1b526:	f013 fce3 	bl	2eef0 <net_buf_simple_add_mem>
		net_buf_unref(buf);
   1b52a:	4628      	mov	r0, r5
   1b52c:	f003 fcf2 	bl	1ef14 <net_buf_unref>
		break;
   1b530:	e7d7      	b.n	1b4e2 <bt_acl_recv+0x22>
			BT_ERR("Unexpected L2CAP continuation");
   1b532:	2145      	movs	r1, #69	; 0x45
   1b534:	4818      	ldr	r0, [pc, #96]	; (1b598 <bt_acl_recv+0xd8>)
   1b536:	f011 f809 	bl	2c54c <z_log_minimal_printk>
			bt_conn_reset_rx_state(conn);
   1b53a:	4620      	mov	r0, r4
   1b53c:	f011 fdfc 	bl	2d138 <bt_conn_reset_rx_state>
			net_buf_unref(buf);
   1b540:	4628      	mov	r0, r5
   1b542:	f003 fce7 	bl	1ef14 <net_buf_unref>
			return;
   1b546:	e01c      	b.n	1b582 <bt_acl_recv+0xc2>
			net_buf_unref(buf);
   1b548:	4608      	mov	r0, r1
   1b54a:	f003 fce3 	bl	1ef14 <net_buf_unref>
			return;
   1b54e:	e018      	b.n	1b582 <bt_acl_recv+0xc2>
			BT_ERR("Not enough buffer space for L2CAP data");
   1b550:	2145      	movs	r1, #69	; 0x45
   1b552:	4812      	ldr	r0, [pc, #72]	; (1b59c <bt_acl_recv+0xdc>)
   1b554:	f010 fffa 	bl	2c54c <z_log_minimal_printk>
			bt_l2cap_recv(conn, conn->rx, false);
   1b558:	2200      	movs	r2, #0
   1b55a:	6921      	ldr	r1, [r4, #16]
   1b55c:	4620      	mov	r0, r4
   1b55e:	f000 fcd1 	bl	1bf04 <bt_l2cap_recv>
			conn->rx = NULL;
   1b562:	2300      	movs	r3, #0
   1b564:	6123      	str	r3, [r4, #16]
			net_buf_unref(buf);
   1b566:	4628      	mov	r0, r5
   1b568:	f003 fcd4 	bl	1ef14 <net_buf_unref>
			return;
   1b56c:	e009      	b.n	1b582 <bt_acl_recv+0xc2>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
   1b56e:	2145      	movs	r1, #69	; 0x45
   1b570:	480b      	ldr	r0, [pc, #44]	; (1b5a0 <bt_acl_recv+0xe0>)
   1b572:	f010 ffeb 	bl	2c54c <z_log_minimal_printk>
		bt_conn_reset_rx_state(conn);
   1b576:	4620      	mov	r0, r4
   1b578:	f011 fdde 	bl	2d138 <bt_conn_reset_rx_state>
		net_buf_unref(buf);
   1b57c:	4628      	mov	r0, r5
   1b57e:	f003 fcc9 	bl	1ef14 <net_buf_unref>
}
   1b582:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("ACL len mismatch (%u > %u)",
   1b584:	2145      	movs	r1, #69	; 0x45
   1b586:	4807      	ldr	r0, [pc, #28]	; (1b5a4 <bt_acl_recv+0xe4>)
   1b588:	f010 ffe0 	bl	2c54c <z_log_minimal_printk>
		bt_conn_reset_rx_state(conn);
   1b58c:	4620      	mov	r0, r4
   1b58e:	f011 fdd3 	bl	2d138 <bt_conn_reset_rx_state>
		return;
   1b592:	e7f6      	b.n	1b582 <bt_acl_recv+0xc2>
   1b594:	0003a180 	.word	0x0003a180
   1b598:	0003a1a4 	.word	0x0003a1a4
   1b59c:	0003a1c8 	.word	0x0003a1c8
   1b5a0:	0003a1f4 	.word	0x0003a1f4
   1b5a4:	0003a218 	.word	0x0003a218

0001b5a8 <bt_conn_send_cb>:
{
   1b5a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b5ac:	461f      	mov	r7, r3
	if (conn->state != BT_CONN_CONNECTED) {
   1b5ae:	7a83      	ldrb	r3, [r0, #10]
   1b5b0:	2b07      	cmp	r3, #7
   1b5b2:	d117      	bne.n	1b5e4 <bt_conn_send_cb+0x3c>
   1b5b4:	4604      	mov	r4, r0
   1b5b6:	460d      	mov	r5, r1
   1b5b8:	4616      	mov	r6, r2
	if (cb) {
   1b5ba:	b35a      	cbz	r2, 1b614 <bt_conn_send_cb+0x6c>
		tx = conn_tx_alloc();
   1b5bc:	f7ff ff28 	bl	1b410 <conn_tx_alloc>
		if (!tx) {
   1b5c0:	4680      	mov	r8, r0
   1b5c2:	b1b0      	cbz	r0, 1b5f2 <bt_conn_send_cb+0x4a>
		if (conn->state != BT_CONN_CONNECTED) {
   1b5c4:	7aa3      	ldrb	r3, [r4, #10]
   1b5c6:	2b07      	cmp	r3, #7
   1b5c8:	d11a      	bne.n	1b600 <bt_conn_send_cb+0x58>
		tx->cb = cb;
   1b5ca:	6046      	str	r6, [r0, #4]
		tx->user_data = user_data;
   1b5cc:	6087      	str	r7, [r0, #8]
		tx->pending_no_cb = 0U;
   1b5ce:	2300      	movs	r3, #0
   1b5d0:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
   1b5d2:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
   1b5d4:	4629      	mov	r1, r5
   1b5d6:	f104 0038 	add.w	r0, r4, #56	; 0x38
   1b5da:	f003 fc69 	bl	1eeb0 <net_buf_put>
	return 0;
   1b5de:	2000      	movs	r0, #0
}
   1b5e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("not connected!");
   1b5e4:	2145      	movs	r1, #69	; 0x45
   1b5e6:	480d      	ldr	r0, [pc, #52]	; (1b61c <bt_conn_send_cb+0x74>)
   1b5e8:	f010 ffb0 	bl	2c54c <z_log_minimal_printk>
		return -ENOTCONN;
   1b5ec:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1b5f0:	e7f6      	b.n	1b5e0 <bt_conn_send_cb+0x38>
			BT_ERR("Unable to allocate TX context");
   1b5f2:	2145      	movs	r1, #69	; 0x45
   1b5f4:	480a      	ldr	r0, [pc, #40]	; (1b620 <bt_conn_send_cb+0x78>)
   1b5f6:	f010 ffa9 	bl	2c54c <z_log_minimal_printk>
			return -ENOBUFS;
   1b5fa:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1b5fe:	e7ef      	b.n	1b5e0 <bt_conn_send_cb+0x38>
			BT_WARN("Disconnected while allocating context");
   1b600:	2157      	movs	r1, #87	; 0x57
   1b602:	4808      	ldr	r0, [pc, #32]	; (1b624 <bt_conn_send_cb+0x7c>)
   1b604:	f010 ffa2 	bl	2c54c <z_log_minimal_printk>
			tx_free(tx);
   1b608:	4640      	mov	r0, r8
   1b60a:	f7ff fe6b 	bl	1b2e4 <tx_free>
			return -ENOTCONN;
   1b60e:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1b612:	e7e5      	b.n	1b5e0 <bt_conn_send_cb+0x38>
		tx_data(buf)->tx = NULL;
   1b614:	2300      	movs	r3, #0
   1b616:	614b      	str	r3, [r1, #20]
   1b618:	e7dc      	b.n	1b5d4 <bt_conn_send_cb+0x2c>
   1b61a:	bf00      	nop
   1b61c:	0003a238 	.word	0x0003a238
   1b620:	0003a24c 	.word	0x0003a24c
   1b624:	0003a270 	.word	0x0003a270

0001b628 <bt_conn_unref>:
{
   1b628:	b538      	push	{r3, r4, r5, lr}
   1b62a:	4604      	mov	r4, r0
	old = atomic_dec(&conn->ref);
   1b62c:	f100 03c0 	add.w	r3, r0, #192	; 0xc0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   1b630:	f3bf 8f5b 	dmb	ish
   1b634:	e853 2f00 	ldrex	r2, [r3]
   1b638:	1e51      	subs	r1, r2, #1
   1b63a:	e843 1000 	strex	r0, r1, [r3]
   1b63e:	2800      	cmp	r0, #0
   1b640:	d1f8      	bne.n	1b634 <bt_conn_unref+0xc>
   1b642:	f3bf 8f5b 	dmb	ish
	__ASSERT(old > 0, "Conn reference counter is 0");
   1b646:	2a00      	cmp	r2, #0
   1b648:	dd03      	ble.n	1b652 <bt_conn_unref+0x2a>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   1b64a:	78a3      	ldrb	r3, [r4, #2]
   1b64c:	2b01      	cmp	r3, #1
   1b64e:	d00d      	beq.n	1b66c <bt_conn_unref+0x44>
}
   1b650:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT(old > 0, "Conn reference counter is 0");
   1b652:	4d0c      	ldr	r5, [pc, #48]	; (1b684 <bt_conn_unref+0x5c>)
   1b654:	f240 427e 	movw	r2, #1150	; 0x47e
   1b658:	4629      	mov	r1, r5
   1b65a:	480b      	ldr	r0, [pc, #44]	; (1b688 <bt_conn_unref+0x60>)
   1b65c:	f010 ff67 	bl	2c52e <assert_print>
   1b660:	f240 417e 	movw	r1, #1150	; 0x47e
   1b664:	4628      	mov	r0, r5
   1b666:	f010 ff5b 	bl	2c520 <assert_post_action>
   1b66a:	e7ee      	b.n	1b64a <bt_conn_unref+0x22>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1b66c:	f3bf 8f5b 	dmb	ish
   1b670:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
   1b674:	f3bf 8f5b 	dmb	ish
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   1b678:	2b00      	cmp	r3, #0
   1b67a:	d1e9      	bne.n	1b650 <bt_conn_unref+0x28>
		bt_le_adv_resume();
   1b67c:	f011 fca0 	bl	2cfc0 <bt_le_adv_resume>
}
   1b680:	e7e6      	b.n	1b650 <bt_conn_unref+0x28>
   1b682:	bf00      	nop
   1b684:	0003a150 	.word	0x0003a150
   1b688:	00031600 	.word	0x00031600

0001b68c <bt_conn_lookup_handle>:
{
   1b68c:	b508      	push	{r3, lr}
   1b68e:	4602      	mov	r2, r0
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
   1b690:	2101      	movs	r1, #1
   1b692:	4802      	ldr	r0, [pc, #8]	; (1b69c <bt_conn_lookup_handle+0x10>)
   1b694:	f011 fd8c 	bl	2d1b0 <conn_lookup_handle>
}
   1b698:	bd08      	pop	{r3, pc}
   1b69a:	bf00      	nop
   1b69c:	20002268 	.word	0x20002268

0001b6a0 <bt_conn_set_state>:
{
   1b6a0:	b570      	push	{r4, r5, r6, lr}
   1b6a2:	460d      	mov	r5, r1
	if (conn->state == state) {
   1b6a4:	7a86      	ldrb	r6, [r0, #10]
   1b6a6:	428e      	cmp	r6, r1
   1b6a8:	d010      	beq.n	1b6cc <bt_conn_set_state+0x2c>
   1b6aa:	4604      	mov	r4, r0
	conn->state = state;
   1b6ac:	7281      	strb	r1, [r0, #10]
	switch (old_state) {
   1b6ae:	b916      	cbnz	r6, 1b6b6 <bt_conn_set_state+0x16>
		if (conn->type != BT_CONN_TYPE_ISO) {
   1b6b0:	7883      	ldrb	r3, [r0, #2]
   1b6b2:	2b08      	cmp	r3, #8
   1b6b4:	d12b      	bne.n	1b70e <bt_conn_set_state+0x6e>
	switch (conn->state) {
   1b6b6:	7aa3      	ldrb	r3, [r4, #10]
   1b6b8:	2b08      	cmp	r3, #8
   1b6ba:	f200 80a8 	bhi.w	1b80e <bt_conn_set_state+0x16e>
   1b6be:	e8df f003 	tbb	[pc, r3]
   1b6c2:	a242      	.short	0xa242
   1b6c4:	a5a5a5a5 	.word	0xa5a5a5a5
   1b6c8:	29a5      	.short	0x29a5
   1b6ca:	a5          	.byte	0xa5
   1b6cb:	00          	.byte	0x00
	switch (state) {
   1b6cc:	2908      	cmp	r1, #8
   1b6ce:	d81a      	bhi.n	1b706 <bt_conn_set_state+0x66>
   1b6d0:	e8df f001 	tbb	[pc, r1]
   1b6d4:	110b1b05 	.word	0x110b1b05
   1b6d8:	15130d0f 	.word	0x15130d0f
   1b6dc:	17          	.byte	0x17
   1b6dd:	00          	.byte	0x00
   1b6de:	4a4f      	ldr	r2, [pc, #316]	; (1b81c <bt_conn_set_state+0x17c>)
		BT_WARN("no transition %s", state2str(state));
   1b6e0:	2157      	movs	r1, #87	; 0x57
   1b6e2:	484f      	ldr	r0, [pc, #316]	; (1b820 <bt_conn_set_state+0x180>)
   1b6e4:	f010 ff32 	bl	2c54c <z_log_minimal_printk>
		return;
   1b6e8:	e090      	b.n	1b80c <bt_conn_set_state+0x16c>
		return "connecting-scan";
   1b6ea:	4a4e      	ldr	r2, [pc, #312]	; (1b824 <bt_conn_set_state+0x184>)
   1b6ec:	e7f8      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "connecting-dir-adv";
   1b6ee:	4a4e      	ldr	r2, [pc, #312]	; (1b828 <bt_conn_set_state+0x188>)
   1b6f0:	e7f6      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "connecting-adv";
   1b6f2:	4a4e      	ldr	r2, [pc, #312]	; (1b82c <bt_conn_set_state+0x18c>)
   1b6f4:	e7f4      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "connecting-auto";
   1b6f6:	4a4e      	ldr	r2, [pc, #312]	; (1b830 <bt_conn_set_state+0x190>)
   1b6f8:	e7f2      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "connecting";
   1b6fa:	4a4e      	ldr	r2, [pc, #312]	; (1b834 <bt_conn_set_state+0x194>)
   1b6fc:	e7f0      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "connected";
   1b6fe:	4a4e      	ldr	r2, [pc, #312]	; (1b838 <bt_conn_set_state+0x198>)
   1b700:	e7ee      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "disconnecting";
   1b702:	4a4e      	ldr	r2, [pc, #312]	; (1b83c <bt_conn_set_state+0x19c>)
   1b704:	e7ec      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "(unknown)";
   1b706:	4a4e      	ldr	r2, [pc, #312]	; (1b840 <bt_conn_set_state+0x1a0>)
   1b708:	e7ea      	b.n	1b6e0 <bt_conn_set_state+0x40>
		return "disconnect-complete";
   1b70a:	4a4e      	ldr	r2, [pc, #312]	; (1b844 <bt_conn_set_state+0x1a4>)
   1b70c:	e7e8      	b.n	1b6e0 <bt_conn_set_state+0x40>
			bt_conn_ref(conn);
   1b70e:	f011 fd28 	bl	2d162 <bt_conn_ref>
   1b712:	e7d0      	b.n	1b6b6 <bt_conn_set_state+0x16>
		if (conn->type == BT_CONN_TYPE_SCO) {
   1b714:	78a3      	ldrb	r3, [r4, #2]
   1b716:	2b04      	cmp	r3, #4
   1b718:	d078      	beq.n	1b80c <bt_conn_set_state+0x16c>
		k_fifo_init(&conn->tx_queue);
   1b71a:	f104 0038 	add.w	r0, r4, #56	; 0x38
	z_impl_k_queue_init(queue);
   1b71e:	f015 f95e 	bl	309de <z_impl_k_queue_init>
	return z_impl_k_poll_signal_raise(sig, result);
   1b722:	2100      	movs	r1, #0
   1b724:	4848      	ldr	r0, [pc, #288]	; (1b848 <bt_conn_set_state+0x1a8>)
   1b726:	f00e fc91 	bl	2a04c <z_impl_k_poll_signal_raise>
	list->head = NULL;
   1b72a:	2300      	movs	r3, #0
   1b72c:	6563      	str	r3, [r4, #84]	; 0x54
	list->tail = NULL;
   1b72e:	65a3      	str	r3, [r4, #88]	; 0x58
		    conn->role == BT_CONN_ROLE_PERIPHERAL) {
   1b730:	78e3      	ldrb	r3, [r4, #3]
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1b732:	2b01      	cmp	r3, #1
   1b734:	d16a      	bne.n	1b80c <bt_conn_set_state+0x16c>
			k_work_schedule(&conn->deferred_work,
   1b736:	f44f 3220 	mov.w	r2, #163840	; 0x28000
   1b73a:	2300      	movs	r3, #0
   1b73c:	f104 0060 	add.w	r0, r4, #96	; 0x60
   1b740:	f00c f8f2 	bl	27928 <k_work_schedule>
   1b744:	e062      	b.n	1b80c <bt_conn_set_state+0x16c>
		if (conn->type == BT_CONN_TYPE_SCO) {
   1b746:	78a3      	ldrb	r3, [r4, #2]
   1b748:	2b04      	cmp	r3, #4
   1b74a:	d008      	beq.n	1b75e <bt_conn_set_state+0xbe>
		switch (old_state) {
   1b74c:	2e08      	cmp	r6, #8
   1b74e:	d85d      	bhi.n	1b80c <bt_conn_set_state+0x16c>
   1b750:	e8df f006 	tbb	[pc, r6]
   1b754:	4b370953 	.word	0x4b370953
   1b758:	532d414f 	.word	0x532d414f
   1b75c:	53          	.byte	0x53
   1b75d:	00          	.byte	0x00
			bt_conn_unref(conn);
   1b75e:	4620      	mov	r0, r4
   1b760:	f7ff ff62 	bl	1b628 <bt_conn_unref>
			break;
   1b764:	e052      	b.n	1b80c <bt_conn_set_state+0x16c>
			tx_notify(conn);
   1b766:	4620      	mov	r0, r4
   1b768:	f011 fc7c 	bl	2d064 <tx_notify>
			if ((conn->type == BT_CONN_TYPE_LE) &&
   1b76c:	78a3      	ldrb	r3, [r4, #2]
   1b76e:	2b01      	cmp	r3, #1
   1b770:	d011      	beq.n	1b796 <bt_conn_set_state+0xf6>
			atomic_set_bit(conn->flags, BT_CONN_CLEANUP);
   1b772:	3404      	adds	r4, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1b774:	f3bf 8f5b 	dmb	ish
   1b778:	e854 3f00 	ldrex	r3, [r4]
   1b77c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1b780:	e844 3200 	strex	r2, r3, [r4]
   1b784:	2a00      	cmp	r2, #0
   1b786:	d1f7      	bne.n	1b778 <bt_conn_set_state+0xd8>
   1b788:	f3bf 8f5b 	dmb	ish
   1b78c:	2100      	movs	r1, #0
   1b78e:	482e      	ldr	r0, [pc, #184]	; (1b848 <bt_conn_set_state+0x1a8>)
   1b790:	f00e fc5c 	bl	2a04c <z_impl_k_poll_signal_raise>
   1b794:	e03a      	b.n	1b80c <bt_conn_set_state+0x16c>
			    (k_work_delayable_busy_get(&conn->deferred_work) &
   1b796:	f104 0560 	add.w	r5, r4, #96	; 0x60
   1b79a:	4628      	mov	r0, r5
   1b79c:	f00c f82c 	bl	277f8 <k_work_delayable_busy_get>
			if ((conn->type == BT_CONN_TYPE_LE) &&
   1b7a0:	f010 0f0c 	tst.w	r0, #12
   1b7a4:	d0e5      	beq.n	1b772 <bt_conn_set_state+0xd2>
				k_work_cancel_delayable(&conn->deferred_work);
   1b7a6:	4628      	mov	r0, r5
   1b7a8:	f00c f930 	bl	27a0c <k_work_cancel_delayable>
   1b7ac:	e7e1      	b.n	1b772 <bt_conn_set_state+0xd2>
			if (conn->err) {
   1b7ae:	7a63      	ldrb	r3, [r4, #9]
   1b7b0:	b91b      	cbnz	r3, 1b7ba <bt_conn_set_state+0x11a>
			bt_conn_unref(conn);
   1b7b2:	4620      	mov	r0, r4
   1b7b4:	f7ff ff38 	bl	1b628 <bt_conn_unref>
			break;
   1b7b8:	e028      	b.n	1b80c <bt_conn_set_state+0x16c>
				notify_connected(conn);
   1b7ba:	4620      	mov	r0, r4
   1b7bc:	f7ff fdf2 	bl	1b3a4 <notify_connected>
   1b7c0:	e7f7      	b.n	1b7b2 <bt_conn_set_state+0x112>
			if (conn->err) {
   1b7c2:	7a63      	ldrb	r3, [r4, #9]
   1b7c4:	b91b      	cbnz	r3, 1b7ce <bt_conn_set_state+0x12e>
			bt_conn_unref(conn);
   1b7c6:	4620      	mov	r0, r4
   1b7c8:	f7ff ff2e 	bl	1b628 <bt_conn_unref>
			break;
   1b7cc:	e01e      	b.n	1b80c <bt_conn_set_state+0x16c>
				notify_connected(conn);
   1b7ce:	4620      	mov	r0, r4
   1b7d0:	f7ff fde8 	bl	1b3a4 <notify_connected>
   1b7d4:	e7f7      	b.n	1b7c6 <bt_conn_set_state+0x126>
			if (conn->err) {
   1b7d6:	7a63      	ldrb	r3, [r4, #9]
   1b7d8:	b91b      	cbnz	r3, 1b7e2 <bt_conn_set_state+0x142>
			bt_conn_unref(conn);
   1b7da:	4620      	mov	r0, r4
   1b7dc:	f7ff ff24 	bl	1b628 <bt_conn_unref>
			break;
   1b7e0:	e014      	b.n	1b80c <bt_conn_set_state+0x16c>
				notify_connected(conn);
   1b7e2:	4620      	mov	r0, r4
   1b7e4:	f7ff fdde 	bl	1b3a4 <notify_connected>
   1b7e8:	e7f7      	b.n	1b7da <bt_conn_set_state+0x13a>
			bt_conn_unref(conn);
   1b7ea:	4620      	mov	r0, r4
   1b7ec:	f7ff ff1c 	bl	1b628 <bt_conn_unref>
			break;
   1b7f0:	e00c      	b.n	1b80c <bt_conn_set_state+0x16c>
			bt_conn_unref(conn);
   1b7f2:	4620      	mov	r0, r4
   1b7f4:	f7ff ff18 	bl	1b628 <bt_conn_unref>
			break;
   1b7f8:	e008      	b.n	1b80c <bt_conn_set_state+0x16c>
			BT_WARN("Invalid (%u) old state", state);
   1b7fa:	462a      	mov	r2, r5
   1b7fc:	2157      	movs	r1, #87	; 0x57
   1b7fe:	4813      	ldr	r0, [pc, #76]	; (1b84c <bt_conn_set_state+0x1ac>)
   1b800:	f010 fea4 	bl	2c54c <z_log_minimal_printk>
   1b804:	e002      	b.n	1b80c <bt_conn_set_state+0x16c>
		process_unack_tx(conn);
   1b806:	4620      	mov	r0, r4
   1b808:	f011 fc54 	bl	2d0b4 <process_unack_tx>
}
   1b80c:	bd70      	pop	{r4, r5, r6, pc}
		BT_WARN("no valid (%u) state was set", state);
   1b80e:	462a      	mov	r2, r5
   1b810:	2157      	movs	r1, #87	; 0x57
   1b812:	480f      	ldr	r0, [pc, #60]	; (1b850 <bt_conn_set_state+0x1b0>)
   1b814:	f010 fe9a 	bl	2c54c <z_log_minimal_printk>
   1b818:	e7f8      	b.n	1b80c <bt_conn_set_state+0x16c>
   1b81a:	bf00      	nop
   1b81c:	0003a328 	.word	0x0003a328
   1b820:	0003a338 	.word	0x0003a338
   1b824:	0003a2bc 	.word	0x0003a2bc
   1b828:	0003a2cc 	.word	0x0003a2cc
   1b82c:	0003a2e0 	.word	0x0003a2e0
   1b830:	0003a2f0 	.word	0x0003a2f0
   1b834:	0003a300 	.word	0x0003a300
   1b838:	0003a30c 	.word	0x0003a30c
   1b83c:	0003a318 	.word	0x0003a318
   1b840:	0003a29c 	.word	0x0003a29c
   1b844:	0003a2a8 	.word	0x0003a2a8
   1b848:	20000b10 	.word	0x20000b10
   1b84c:	0003a350 	.word	0x0003a350
   1b850:	0003a36c 	.word	0x0003a36c

0001b854 <bt_conn_index>:
{
   1b854:	b538      	push	{r3, r4, r5, lr}
		index = conn - acl_conns;
   1b856:	4b0b      	ldr	r3, [pc, #44]	; (1b884 <bt_conn_index+0x30>)
   1b858:	1ac4      	subs	r4, r0, r3
   1b85a:	10e4      	asrs	r4, r4, #3
   1b85c:	4a0a      	ldr	r2, [pc, #40]	; (1b888 <bt_conn_index+0x34>)
   1b85e:	fb02 f404 	mul.w	r4, r2, r4
		__ASSERT(index >= 0 && index < ARRAY_SIZE(acl_conns),
   1b862:	4298      	cmp	r0, r3
   1b864:	d00b      	beq.n	1b87e <bt_conn_index+0x2a>
   1b866:	4d09      	ldr	r5, [pc, #36]	; (1b88c <bt_conn_index+0x38>)
   1b868:	f240 429c 	movw	r2, #1180	; 0x49c
   1b86c:	4629      	mov	r1, r5
   1b86e:	4808      	ldr	r0, [pc, #32]	; (1b890 <bt_conn_index+0x3c>)
   1b870:	f010 fe5d 	bl	2c52e <assert_print>
   1b874:	f240 419c 	movw	r1, #1180	; 0x49c
   1b878:	4628      	mov	r0, r5
   1b87a:	f010 fe51 	bl	2c520 <assert_post_action>
}
   1b87e:	b2e0      	uxtb	r0, r4
   1b880:	bd38      	pop	{r3, r4, r5, pc}
   1b882:	bf00      	nop
   1b884:	20002268 	.word	0x20002268
   1b888:	c28f5c29 	.word	0xc28f5c29
   1b88c:	0003a150 	.word	0x0003a150
   1b890:	00031600 	.word	0x00031600

0001b894 <bt_conn_create_pdu_timeout>:
{
   1b894:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b898:	4604      	mov	r4, r0
   1b89a:	460f      	mov	r7, r1
   1b89c:	4616      	mov	r6, r2
   1b89e:	461d      	mov	r5, r3
	__ASSERT_NO_MSG(!k_is_in_isr());
   1b8a0:	f015 f834 	bl	3090c <k_is_in_isr>
   1b8a4:	b970      	cbnz	r0, 1b8c4 <bt_conn_create_pdu_timeout+0x30>
	if (!pool) {
   1b8a6:	b1dc      	cbz	r4, 1b8e0 <bt_conn_create_pdu_timeout+0x4c>
	return net_buf_alloc_fixed(pool, timeout);
   1b8a8:	4632      	mov	r2, r6
   1b8aa:	462b      	mov	r3, r5
   1b8ac:	4620      	mov	r0, r4
   1b8ae:	f013 fafd 	bl	2eeac <net_buf_alloc_fixed>
	if (!buf) {
   1b8b2:	4604      	mov	r4, r0
   1b8b4:	b1b0      	cbz	r0, 1b8e4 <bt_conn_create_pdu_timeout+0x50>
	net_buf_simple_reserve(&buf->b, reserve);
   1b8b6:	1d39      	adds	r1, r7, #4
   1b8b8:	3008      	adds	r0, #8
   1b8ba:	f003 f9eb 	bl	1ec94 <net_buf_simple_reserve>
}
   1b8be:	4620      	mov	r0, r4
   1b8c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(!k_is_in_isr());
   1b8c4:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1b8fc <bt_conn_create_pdu_timeout+0x68>
   1b8c8:	f44f 6297 	mov.w	r2, #1208	; 0x4b8
   1b8cc:	4641      	mov	r1, r8
   1b8ce:	4808      	ldr	r0, [pc, #32]	; (1b8f0 <bt_conn_create_pdu_timeout+0x5c>)
   1b8d0:	f010 fe2d 	bl	2c52e <assert_print>
   1b8d4:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
   1b8d8:	4640      	mov	r0, r8
   1b8da:	f010 fe21 	bl	2c520 <assert_post_action>
   1b8de:	e7e2      	b.n	1b8a6 <bt_conn_create_pdu_timeout+0x12>
		pool = &acl_tx_pool;
   1b8e0:	4c04      	ldr	r4, [pc, #16]	; (1b8f4 <bt_conn_create_pdu_timeout+0x60>)
   1b8e2:	e7e1      	b.n	1b8a8 <bt_conn_create_pdu_timeout+0x14>
		BT_WARN("Unable to allocate buffer within timeout");
   1b8e4:	2157      	movs	r1, #87	; 0x57
   1b8e6:	4804      	ldr	r0, [pc, #16]	; (1b8f8 <bt_conn_create_pdu_timeout+0x64>)
   1b8e8:	f010 fe30 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1b8ec:	e7e7      	b.n	1b8be <bt_conn_create_pdu_timeout+0x2a>
   1b8ee:	bf00      	nop
   1b8f0:	00031600 	.word	0x00031600
   1b8f4:	20000f04 	.word	0x20000f04
   1b8f8:	0003a390 	.word	0x0003a390
   1b8fc:	0003a150 	.word	0x0003a150

0001b900 <notify_le_param_updated>:
{
   1b900:	b570      	push	{r4, r5, r6, lr}
   1b902:	4604      	mov	r4, r0
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1b904:	f3bf 8f5b 	dmb	ish
   1b908:	6843      	ldr	r3, [r0, #4]
   1b90a:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
   1b90e:	f413 7f80 	tst.w	r3, #256	; 0x100
   1b912:	d010      	beq.n	1b936 <notify_le_param_updated+0x36>
   1b914:	1d02      	adds	r2, r0, #4
	    conn->le.interval >= conn->le.interval_min &&
   1b916:	f8b0 30a6 	ldrh.w	r3, [r0, #166]	; 0xa6
   1b91a:	f8b0 10a8 	ldrh.w	r1, [r0, #168]	; 0xa8
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
   1b91e:	428b      	cmp	r3, r1
   1b920:	d309      	bcc.n	1b936 <notify_le_param_updated+0x36>
	    conn->le.interval <= conn->le.interval_max &&
   1b922:	f8b0 10aa 	ldrh.w	r1, [r0, #170]	; 0xaa
	    conn->le.interval >= conn->le.interval_min &&
   1b926:	428b      	cmp	r3, r1
   1b928:	d805      	bhi.n	1b936 <notify_le_param_updated+0x36>
	    conn->le.latency == conn->le.pending_latency &&
   1b92a:	f8d0 10ac 	ldr.w	r1, [r0, #172]	; 0xac
   1b92e:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
   1b932:	4299      	cmp	r1, r3
   1b934:	d002      	beq.n	1b93c <notify_le_param_updated+0x3c>
	for (cb = callback_list; cb; cb = cb->_next) {
   1b936:	4b20      	ldr	r3, [pc, #128]	; (1b9b8 <notify_le_param_updated+0xb8>)
   1b938:	681d      	ldr	r5, [r3, #0]
   1b93a:	e015      	b.n	1b968 <notify_le_param_updated+0x68>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1b93c:	f3bf 8f5b 	dmb	ish
   1b940:	e852 3f00 	ldrex	r3, [r2]
   1b944:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1b948:	e842 3100 	strex	r1, r3, [r2]
   1b94c:	2900      	cmp	r1, #0
   1b94e:	d1f7      	bne.n	1b940 <notify_le_param_updated+0x40>
   1b950:	f3bf 8f5b 	dmb	ish
}
   1b954:	e7ef      	b.n	1b936 <notify_le_param_updated+0x36>
			cb->le_param_updated(conn, conn->le.interval,
   1b956:	f8b4 30ae 	ldrh.w	r3, [r4, #174]	; 0xae
   1b95a:	f8b4 20ac 	ldrh.w	r2, [r4, #172]	; 0xac
   1b95e:	f8b4 10a6 	ldrh.w	r1, [r4, #166]	; 0xa6
   1b962:	4620      	mov	r0, r4
   1b964:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
   1b966:	692d      	ldr	r5, [r5, #16]
   1b968:	b11d      	cbz	r5, 1b972 <notify_le_param_updated+0x72>
		if (cb->le_param_updated) {
   1b96a:	68ee      	ldr	r6, [r5, #12]
   1b96c:	2e00      	cmp	r6, #0
   1b96e:	d1f2      	bne.n	1b956 <notify_le_param_updated+0x56>
   1b970:	e7f9      	b.n	1b966 <notify_le_param_updated+0x66>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1b972:	4d12      	ldr	r5, [pc, #72]	; (1b9bc <notify_le_param_updated+0xbc>)
   1b974:	e000      	b.n	1b978 <notify_le_param_updated+0x78>
   1b976:	3514      	adds	r5, #20
   1b978:	4b11      	ldr	r3, [pc, #68]	; (1b9c0 <notify_le_param_updated+0xc0>)
   1b97a:	429d      	cmp	r5, r3
   1b97c:	d80e      	bhi.n	1b99c <notify_le_param_updated+0x9c>
   1b97e:	4b10      	ldr	r3, [pc, #64]	; (1b9c0 <notify_le_param_updated+0xc0>)
   1b980:	429d      	cmp	r5, r3
   1b982:	d218      	bcs.n	1b9b6 <notify_le_param_updated+0xb6>
		if (cb->le_param_updated) {
   1b984:	68ee      	ldr	r6, [r5, #12]
   1b986:	2e00      	cmp	r6, #0
   1b988:	d0f5      	beq.n	1b976 <notify_le_param_updated+0x76>
			cb->le_param_updated(conn, conn->le.interval,
   1b98a:	f8b4 30ae 	ldrh.w	r3, [r4, #174]	; 0xae
   1b98e:	f8b4 20ac 	ldrh.w	r2, [r4, #172]	; 0xac
   1b992:	f8b4 10a6 	ldrh.w	r1, [r4, #166]	; 0xa6
   1b996:	4620      	mov	r0, r4
   1b998:	47b0      	blx	r6
   1b99a:	e7ec      	b.n	1b976 <notify_le_param_updated+0x76>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1b99c:	4e09      	ldr	r6, [pc, #36]	; (1b9c4 <notify_le_param_updated+0xc4>)
   1b99e:	f240 528b 	movw	r2, #1419	; 0x58b
   1b9a2:	4631      	mov	r1, r6
   1b9a4:	4808      	ldr	r0, [pc, #32]	; (1b9c8 <notify_le_param_updated+0xc8>)
   1b9a6:	f010 fdc2 	bl	2c52e <assert_print>
   1b9aa:	f240 518b 	movw	r1, #1419	; 0x58b
   1b9ae:	4630      	mov	r0, r6
   1b9b0:	f010 fdb6 	bl	2c520 <assert_post_action>
   1b9b4:	e7e3      	b.n	1b97e <notify_le_param_updated+0x7e>
}
   1b9b6:	bd70      	pop	{r4, r5, r6, pc}
   1b9b8:	20003acc 	.word	0x20003acc
   1b9bc:	00031294 	.word	0x00031294
   1b9c0:	000312a8 	.word	0x000312a8
   1b9c4:	0003a150 	.word	0x0003a150
   1b9c8:	00031600 	.word	0x00031600

0001b9cc <le_param_req>:
{
   1b9cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b9d0:	4606      	mov	r6, r0
   1b9d2:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
   1b9d4:	4608      	mov	r0, r1
   1b9d6:	f011 f926 	bl	2cc26 <bt_le_conn_params_valid>
   1b9da:	4607      	mov	r7, r0
   1b9dc:	2800      	cmp	r0, #0
   1b9de:	d034      	beq.n	1ba4a <le_param_req+0x7e>
	for (cb = callback_list; cb; cb = cb->_next) {
   1b9e0:	4b1d      	ldr	r3, [pc, #116]	; (1ba58 <le_param_req+0x8c>)
   1b9e2:	681c      	ldr	r4, [r3, #0]
   1b9e4:	e000      	b.n	1b9e8 <le_param_req+0x1c>
   1b9e6:	6924      	ldr	r4, [r4, #16]
   1b9e8:	b16c      	cbz	r4, 1ba06 <le_param_req+0x3a>
		if (!cb->le_param_req) {
   1b9ea:	68a3      	ldr	r3, [r4, #8]
   1b9ec:	2b00      	cmp	r3, #0
   1b9ee:	d0fa      	beq.n	1b9e6 <le_param_req+0x1a>
		if (!cb->le_param_req(conn, param)) {
   1b9f0:	4629      	mov	r1, r5
   1b9f2:	4630      	mov	r0, r6
   1b9f4:	4798      	blx	r3
   1b9f6:	b338      	cbz	r0, 1ba48 <le_param_req+0x7c>
		if (!bt_le_conn_params_valid(param)) {
   1b9f8:	4628      	mov	r0, r5
   1b9fa:	f011 f914 	bl	2cc26 <bt_le_conn_params_valid>
   1b9fe:	2800      	cmp	r0, #0
   1ba00:	d1f1      	bne.n	1b9e6 <le_param_req+0x1a>
			return false;
   1ba02:	4607      	mov	r7, r0
   1ba04:	e021      	b.n	1ba4a <le_param_req+0x7e>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1ba06:	4c15      	ldr	r4, [pc, #84]	; (1ba5c <le_param_req+0x90>)
   1ba08:	e00d      	b.n	1ba26 <le_param_req+0x5a>
   1ba0a:	4b15      	ldr	r3, [pc, #84]	; (1ba60 <le_param_req+0x94>)
   1ba0c:	429c      	cmp	r4, r3
   1ba0e:	d21c      	bcs.n	1ba4a <le_param_req+0x7e>
		if (!cb->le_param_req) {
   1ba10:	68a3      	ldr	r3, [r4, #8]
   1ba12:	b13b      	cbz	r3, 1ba24 <le_param_req+0x58>
		if (!cb->le_param_req(conn, param)) {
   1ba14:	4629      	mov	r1, r5
   1ba16:	4630      	mov	r0, r6
   1ba18:	4798      	blx	r3
   1ba1a:	b1c8      	cbz	r0, 1ba50 <le_param_req+0x84>
		if (!bt_le_conn_params_valid(param)) {
   1ba1c:	4628      	mov	r0, r5
   1ba1e:	f011 f902 	bl	2cc26 <bt_le_conn_params_valid>
   1ba22:	b1b8      	cbz	r0, 1ba54 <le_param_req+0x88>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
   1ba24:	3414      	adds	r4, #20
   1ba26:	4b0e      	ldr	r3, [pc, #56]	; (1ba60 <le_param_req+0x94>)
   1ba28:	429c      	cmp	r4, r3
   1ba2a:	d9ee      	bls.n	1ba0a <le_param_req+0x3e>
   1ba2c:	f8df 8038 	ldr.w	r8, [pc, #56]	; 1ba68 <le_param_req+0x9c>
   1ba30:	f240 52d3 	movw	r2, #1491	; 0x5d3
   1ba34:	4641      	mov	r1, r8
   1ba36:	480b      	ldr	r0, [pc, #44]	; (1ba64 <le_param_req+0x98>)
   1ba38:	f010 fd79 	bl	2c52e <assert_print>
   1ba3c:	f240 51d3 	movw	r1, #1491	; 0x5d3
   1ba40:	4640      	mov	r0, r8
   1ba42:	f010 fd6d 	bl	2c520 <assert_post_action>
   1ba46:	e7e0      	b.n	1ba0a <le_param_req+0x3e>
			return false;
   1ba48:	4607      	mov	r7, r0
}
   1ba4a:	4638      	mov	r0, r7
   1ba4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return false;
   1ba50:	4607      	mov	r7, r0
   1ba52:	e7fa      	b.n	1ba4a <le_param_req+0x7e>
			return false;
   1ba54:	4607      	mov	r7, r0
   1ba56:	e7f8      	b.n	1ba4a <le_param_req+0x7e>
   1ba58:	20003acc 	.word	0x20003acc
   1ba5c:	00031294 	.word	0x00031294
   1ba60:	000312a8 	.word	0x000312a8
   1ba64:	00031600 	.word	0x00031600
   1ba68:	0003a150 	.word	0x0003a150

0001ba6c <bt_conn_lookup_addr_le>:

	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
}

struct bt_conn *bt_conn_lookup_addr_le(uint8_t id, const bt_addr_le_t *peer)
{
   1ba6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ba6e:	4607      	mov	r7, r0
   1ba70:	460e      	mov	r6, r1
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   1ba72:	2400      	movs	r4, #0
   1ba74:	b114      	cbz	r4, 1ba7c <bt_conn_lookup_addr_le+0x10>
		}

		return conn;
	}

	return NULL;
   1ba76:	2500      	movs	r5, #0
}
   1ba78:	4628      	mov	r0, r5
   1ba7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   1ba7c:	4b0c      	ldr	r3, [pc, #48]	; (1bab0 <bt_conn_lookup_addr_le+0x44>)
   1ba7e:	20c8      	movs	r0, #200	; 0xc8
   1ba80:	fb00 3004 	mla	r0, r0, r4, r3
   1ba84:	f011 fb6d 	bl	2d162 <bt_conn_ref>
		if (!conn) {
   1ba88:	4605      	mov	r5, r0
   1ba8a:	b170      	cbz	r0, 1baaa <bt_conn_lookup_addr_le+0x3e>
		if (conn->type != BT_CONN_TYPE_LE) {
   1ba8c:	7883      	ldrb	r3, [r0, #2]
   1ba8e:	2b01      	cmp	r3, #1
   1ba90:	d109      	bne.n	1baa6 <bt_conn_lookup_addr_le+0x3a>
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
   1ba92:	4632      	mov	r2, r6
   1ba94:	4639      	mov	r1, r7
   1ba96:	f011 fbdb 	bl	2d250 <bt_conn_is_peer_addr_le>
   1ba9a:	2800      	cmp	r0, #0
   1ba9c:	d1ec      	bne.n	1ba78 <bt_conn_lookup_addr_le+0xc>
			bt_conn_unref(conn);
   1ba9e:	4628      	mov	r0, r5
   1baa0:	f7ff fdc2 	bl	1b628 <bt_conn_unref>
			continue;
   1baa4:	e001      	b.n	1baaa <bt_conn_lookup_addr_le+0x3e>
			bt_conn_unref(conn);
   1baa6:	f7ff fdbf 	bl	1b628 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   1baaa:	3401      	adds	r4, #1
   1baac:	e7e2      	b.n	1ba74 <bt_conn_lookup_addr_le+0x8>
   1baae:	bf00      	nop
   1bab0:	20002268 	.word	0x20002268

0001bab4 <bt_conn_exists_le>:
{
   1bab4:	b510      	push	{r4, lr}
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
   1bab6:	f7ff ffd9 	bl	1ba6c <bt_conn_lookup_addr_le>
	if (conn) {
   1baba:	b908      	cbnz	r0, 1bac0 <bt_conn_exists_le+0xc>
	return false;
   1babc:	2000      	movs	r0, #0
}
   1babe:	bd10      	pop	{r4, pc}
   1bac0:	4604      	mov	r4, r0
		BT_WARN("Found valid connection in %s state",
   1bac2:	7a83      	ldrb	r3, [r0, #10]
	switch (state) {
   1bac4:	2b08      	cmp	r3, #8
   1bac6:	d81e      	bhi.n	1bb06 <bt_conn_exists_le+0x52>
   1bac8:	e8df f003 	tbb	[pc, r3]
   1bacc:	150f1f05 	.word	0x150f1f05
   1bad0:	19171113 	.word	0x19171113
   1bad4:	1b          	.byte	0x1b
   1bad5:	00          	.byte	0x00
   1bad6:	4a0e      	ldr	r2, [pc, #56]	; (1bb10 <bt_conn_exists_le+0x5c>)
		BT_WARN("Found valid connection in %s state",
   1bad8:	2157      	movs	r1, #87	; 0x57
   1bada:	480e      	ldr	r0, [pc, #56]	; (1bb14 <bt_conn_exists_le+0x60>)
   1badc:	f010 fd36 	bl	2c54c <z_log_minimal_printk>
		bt_conn_unref(conn);
   1bae0:	4620      	mov	r0, r4
   1bae2:	f7ff fda1 	bl	1b628 <bt_conn_unref>
		return true;
   1bae6:	2001      	movs	r0, #1
   1bae8:	e7e9      	b.n	1babe <bt_conn_exists_le+0xa>
		return "connecting-scan";
   1baea:	4a0b      	ldr	r2, [pc, #44]	; (1bb18 <bt_conn_exists_le+0x64>)
   1baec:	e7f4      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "connecting-dir-adv";
   1baee:	4a0b      	ldr	r2, [pc, #44]	; (1bb1c <bt_conn_exists_le+0x68>)
   1baf0:	e7f2      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "connecting-adv";
   1baf2:	4a0b      	ldr	r2, [pc, #44]	; (1bb20 <bt_conn_exists_le+0x6c>)
   1baf4:	e7f0      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "connecting-auto";
   1baf6:	4a0b      	ldr	r2, [pc, #44]	; (1bb24 <bt_conn_exists_le+0x70>)
   1baf8:	e7ee      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "connecting";
   1bafa:	4a0b      	ldr	r2, [pc, #44]	; (1bb28 <bt_conn_exists_le+0x74>)
   1bafc:	e7ec      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "connected";
   1bafe:	4a0b      	ldr	r2, [pc, #44]	; (1bb2c <bt_conn_exists_le+0x78>)
   1bb00:	e7ea      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "disconnecting";
   1bb02:	4a0b      	ldr	r2, [pc, #44]	; (1bb30 <bt_conn_exists_le+0x7c>)
   1bb04:	e7e8      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "(unknown)";
   1bb06:	4a0b      	ldr	r2, [pc, #44]	; (1bb34 <bt_conn_exists_le+0x80>)
   1bb08:	e7e6      	b.n	1bad8 <bt_conn_exists_le+0x24>
		return "disconnect-complete";
   1bb0a:	4a0b      	ldr	r2, [pc, #44]	; (1bb38 <bt_conn_exists_le+0x84>)
   1bb0c:	e7e4      	b.n	1bad8 <bt_conn_exists_le+0x24>
   1bb0e:	bf00      	nop
   1bb10:	0003a328 	.word	0x0003a328
   1bb14:	0003a3c0 	.word	0x0003a3c0
   1bb18:	0003a2bc 	.word	0x0003a2bc
   1bb1c:	0003a2cc 	.word	0x0003a2cc
   1bb20:	0003a2e0 	.word	0x0003a2e0
   1bb24:	0003a2f0 	.word	0x0003a2f0
   1bb28:	0003a300 	.word	0x0003a300
   1bb2c:	0003a30c 	.word	0x0003a30c
   1bb30:	0003a318 	.word	0x0003a318
   1bb34:	0003a29c 	.word	0x0003a29c
   1bb38:	0003a2a8 	.word	0x0003a2a8

0001bb3c <bt_conn_lookup_state_le>:

struct bt_conn *bt_conn_lookup_state_le(uint8_t id, const bt_addr_le_t *peer,
					const bt_conn_state_t state)
{
   1bb3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bb40:	4680      	mov	r8, r0
   1bb42:	460f      	mov	r7, r1
   1bb44:	4616      	mov	r6, r2
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   1bb46:	2400      	movs	r4, #0
   1bb48:	b11c      	cbz	r4, 1bb52 <bt_conn_lookup_state_le+0x16>
		}

		return conn;
	}

	return NULL;
   1bb4a:	2500      	movs	r5, #0
}
   1bb4c:	4628      	mov	r0, r5
   1bb4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
   1bb52:	4b11      	ldr	r3, [pc, #68]	; (1bb98 <bt_conn_lookup_state_le+0x5c>)
   1bb54:	20c8      	movs	r0, #200	; 0xc8
   1bb56:	fb00 3004 	mla	r0, r0, r4, r3
   1bb5a:	f011 fb02 	bl	2d162 <bt_conn_ref>
		if (!conn) {
   1bb5e:	4605      	mov	r5, r0
   1bb60:	b188      	cbz	r0, 1bb86 <bt_conn_lookup_state_le+0x4a>
		if (conn->type != BT_CONN_TYPE_LE) {
   1bb62:	7883      	ldrb	r3, [r0, #2]
   1bb64:	2b01      	cmp	r3, #1
   1bb66:	d110      	bne.n	1bb8a <bt_conn_lookup_state_le+0x4e>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
   1bb68:	b127      	cbz	r7, 1bb74 <bt_conn_lookup_state_le+0x38>
   1bb6a:	463a      	mov	r2, r7
   1bb6c:	4641      	mov	r1, r8
   1bb6e:	f011 fb6f 	bl	2d250 <bt_conn_is_peer_addr_le>
   1bb72:	b168      	cbz	r0, 1bb90 <bt_conn_lookup_state_le+0x54>
		if (!(conn->state == state && conn->id == id)) {
   1bb74:	7aab      	ldrb	r3, [r5, #10]
   1bb76:	42b3      	cmp	r3, r6
   1bb78:	d102      	bne.n	1bb80 <bt_conn_lookup_state_le+0x44>
   1bb7a:	7a2b      	ldrb	r3, [r5, #8]
   1bb7c:	4543      	cmp	r3, r8
   1bb7e:	d0e5      	beq.n	1bb4c <bt_conn_lookup_state_le+0x10>
			bt_conn_unref(conn);
   1bb80:	4628      	mov	r0, r5
   1bb82:	f7ff fd51 	bl	1b628 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
   1bb86:	3401      	adds	r4, #1
   1bb88:	e7de      	b.n	1bb48 <bt_conn_lookup_state_le+0xc>
			bt_conn_unref(conn);
   1bb8a:	f7ff fd4d 	bl	1b628 <bt_conn_unref>
			continue;
   1bb8e:	e7fa      	b.n	1bb86 <bt_conn_lookup_state_le+0x4a>
			bt_conn_unref(conn);
   1bb90:	4628      	mov	r0, r5
   1bb92:	f7ff fd49 	bl	1b628 <bt_conn_unref>
			continue;
   1bb96:	e7f6      	b.n	1bb86 <bt_conn_lookup_state_le+0x4a>
   1bb98:	20002268 	.word	0x20002268

0001bb9c <send_conn_le_param_update>:
{
   1bb9c:	b538      	push	{r3, r4, r5, lr}
   1bb9e:	4604      	mov	r4, r0
   1bba0:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
   1bba2:	4608      	mov	r0, r1
   1bba4:	f011 f83f 	bl	2cc26 <bt_le_conn_params_valid>
   1bba8:	b360      	cbz	r0, 1bc04 <send_conn_le_param_update+0x68>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   1bbaa:	4b18      	ldr	r3, [pc, #96]	; (1bc0c <send_conn_le_param_update+0x70>)
   1bbac:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
   1bbb0:	f013 0f02 	tst.w	r3, #2
   1bbb4:	d004      	beq.n	1bbc0 <send_conn_le_param_update+0x24>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
   1bbb6:	f894 30b4 	ldrb.w	r3, [r4, #180]	; 0xb4
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   1bbba:	f013 0f02 	tst.w	r3, #2
   1bbbe:	d113      	bne.n	1bbe8 <send_conn_le_param_update+0x4c>
	     (conn->role == BT_HCI_ROLE_CENTRAL)) {
   1bbc0:	78e3      	ldrb	r3, [r4, #3]
	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
   1bbc2:	b9d3      	cbnz	r3, 1bbfa <send_conn_le_param_update+0x5e>
		rc = bt_conn_le_conn_update(conn, param);
   1bbc4:	4629      	mov	r1, r5
   1bbc6:	4620      	mov	r0, r4
   1bbc8:	f011 fb6b 	bl	2d2a2 <bt_conn_le_conn_update>
		if (rc == 0) {
   1bbcc:	b9c8      	cbnz	r0, 1bc02 <send_conn_le_param_update+0x66>
			conn->le.interval_min = param->interval_min;
   1bbce:	882b      	ldrh	r3, [r5, #0]
   1bbd0:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
			conn->le.interval_max = param->interval_max;
   1bbd4:	886b      	ldrh	r3, [r5, #2]
   1bbd6:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
			conn->le.pending_latency = param->latency;
   1bbda:	88ab      	ldrh	r3, [r5, #4]
   1bbdc:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0
			conn->le.pending_timeout = param->timeout;
   1bbe0:	88eb      	ldrh	r3, [r5, #6]
   1bbe2:	f8a4 30b2 	strh.w	r3, [r4, #178]	; 0xb2
		return rc;
   1bbe6:	e00c      	b.n	1bc02 <send_conn_le_param_update+0x66>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1bbe8:	f3bf 8f5b 	dmb	ish
   1bbec:	6863      	ldr	r3, [r4, #4]
   1bbee:	f3bf 8f5b 	dmb	ish
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
   1bbf2:	f413 7f00 	tst.w	r3, #512	; 0x200
   1bbf6:	d1e3      	bne.n	1bbc0 <send_conn_le_param_update+0x24>
   1bbf8:	e7e4      	b.n	1bbc4 <send_conn_le_param_update+0x28>
	return bt_l2cap_update_conn_param(conn, param);
   1bbfa:	4629      	mov	r1, r5
   1bbfc:	4620      	mov	r0, r4
   1bbfe:	f011 fc1e 	bl	2d43e <bt_l2cap_update_conn_param>
}
   1bc02:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   1bc04:	f06f 0015 	mvn.w	r0, #21
   1bc08:	e7fb      	b.n	1bc02 <send_conn_le_param_update+0x66>
   1bc0a:	bf00      	nop
   1bc0c:	20000420 	.word	0x20000420

0001bc10 <deferred_work>:
{
   1bc10:	b530      	push	{r4, r5, lr}
   1bc12:	b085      	sub	sp, #20
	struct bt_conn *conn = CONTAINER_OF(dwork, struct bt_conn, deferred_work);
   1bc14:	f1a0 0460 	sub.w	r4, r0, #96	; 0x60
	if (conn->state == BT_CONN_DISCONNECTED) {
   1bc18:	f810 3c56 	ldrb.w	r3, [r0, #-86]
   1bc1c:	b3b3      	cbz	r3, 1bc8c <deferred_work+0x7c>
	if (conn->type != BT_CONN_TYPE_LE) {
   1bc1e:	f810 3c5e 	ldrb.w	r3, [r0, #-94]
   1bc22:	2b01      	cmp	r3, #1
   1bc24:	d130      	bne.n	1bc88 <deferred_work+0x78>
	if (atomic_test_and_clear_bit(conn->flags,
   1bc26:	f1a0 055c 	sub.w	r5, r0, #92	; 0x5c
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1bc2a:	f3bf 8f5b 	dmb	ish
   1bc2e:	e855 3f00 	ldrex	r3, [r5]
   1bc32:	f423 7280 	bic.w	r2, r3, #256	; 0x100
   1bc36:	e845 2100 	strex	r1, r2, [r5]
   1bc3a:	2900      	cmp	r1, #0
   1bc3c:	d1f7      	bne.n	1bc2e <deferred_work+0x1e>
   1bc3e:	f3bf 8f5b 	dmb	ish
   1bc42:	f413 7f80 	tst.w	r3, #256	; 0x100
   1bc46:	d02b      	beq.n	1bca0 <deferred_work+0x90>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
   1bc48:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
   1bc4c:	f8ad 3000 	strh.w	r3, [sp]
   1bc50:	f8b0 304a 	ldrh.w	r3, [r0, #74]	; 0x4a
   1bc54:	f8ad 3002 	strh.w	r3, [sp, #2]
   1bc58:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
   1bc5c:	f8ad 3004 	strh.w	r3, [sp, #4]
   1bc60:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
   1bc64:	f8ad 3006 	strh.w	r3, [sp, #6]
		send_conn_le_param_update(conn, param);
   1bc68:	4669      	mov	r1, sp
   1bc6a:	4620      	mov	r0, r4
   1bc6c:	f7ff ff96 	bl	1bb9c <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1bc70:	f3bf 8f5b 	dmb	ish
   1bc74:	e855 3f00 	ldrex	r3, [r5]
   1bc78:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1bc7c:	e845 3200 	strex	r2, r3, [r5]
   1bc80:	2a00      	cmp	r2, #0
   1bc82:	d1f7      	bne.n	1bc74 <deferred_work+0x64>
   1bc84:	f3bf 8f5b 	dmb	ish
}
   1bc88:	b005      	add	sp, #20
   1bc8a:	bd30      	pop	{r4, r5, pc}
		bt_l2cap_disconnected(conn);
   1bc8c:	4620      	mov	r0, r4
   1bc8e:	f011 fb5d 	bl	2d34c <bt_l2cap_disconnected>
		notify_disconnected(conn);
   1bc92:	4620      	mov	r0, r4
   1bc94:	f7ff fb32 	bl	1b2fc <notify_disconnected>
		bt_conn_unref(conn);
   1bc98:	4620      	mov	r0, r4
   1bc9a:	f7ff fcc5 	bl	1b628 <bt_conn_unref>
		return;
   1bc9e:	e7f3      	b.n	1bc88 <deferred_work+0x78>
		param = BT_LE_CONN_PARAM(
   1bca0:	4a05      	ldr	r2, [pc, #20]	; (1bcb8 <deferred_work+0xa8>)
   1bca2:	ab02      	add	r3, sp, #8
   1bca4:	e892 0003 	ldmia.w	r2, {r0, r1}
   1bca8:	e883 0003 	stmia.w	r3, {r0, r1}
		send_conn_le_param_update(conn, param);
   1bcac:	4619      	mov	r1, r3
   1bcae:	4620      	mov	r0, r4
   1bcb0:	f7ff ff74 	bl	1bb9c <send_conn_le_param_update>
   1bcb4:	e7dc      	b.n	1bc70 <deferred_work+0x60>
   1bcb6:	bf00      	nop
   1bcb8:	00031440 	.word	0x00031440

0001bcbc <bt_conn_init>:

	return bt_conn_ref(&acl_conns[index]);
}

int bt_conn_init(void)
{
   1bcbc:	b510      	push	{r4, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
   1bcbe:	2400      	movs	r4, #0
   1bcc0:	e006      	b.n	1bcd0 <bt_conn_init+0x14>
		k_fifo_put(&free_tx, &conn_tx[i]);
   1bcc2:	490a      	ldr	r1, [pc, #40]	; (1bcec <bt_conn_init+0x30>)
   1bcc4:	eb01 1104 	add.w	r1, r1, r4, lsl #4
   1bcc8:	4809      	ldr	r0, [pc, #36]	; (1bcf0 <bt_conn_init+0x34>)
   1bcca:	f014 fe95 	bl	309f8 <k_queue_append>
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
   1bcce:	3401      	adds	r4, #1
   1bcd0:	2c02      	cmp	r4, #2
   1bcd2:	d9f6      	bls.n	1bcc2 <bt_conn_init+0x6>
	}

	bt_att_init();
   1bcd4:	f001 fa1a 	bl	1d10c <bt_att_init>

	err = bt_smp_init();
   1bcd8:	f013 f89b 	bl	2ee12 <bt_smp_init>
	if (err) {
   1bcdc:	4604      	mov	r4, r0
   1bcde:	b108      	cbz	r0, 1bce4 <bt_conn_init+0x28>
			bt_conn_unref(conn);
		}
	}

	return 0;
}
   1bce0:	4620      	mov	r0, r4
   1bce2:	bd10      	pop	{r4, pc}
	bt_l2cap_init();
   1bce4:	f011 fbd8 	bl	2d498 <bt_l2cap_init>
	return 0;
   1bce8:	e7fa      	b.n	1bce0 <bt_conn_init+0x24>
   1bcea:	bf00      	nop
   1bcec:	20003ad0 	.word	0x20003ad0
   1bcf0:	20000ee8 	.word	0x20000ee8

0001bcf4 <get_ident>:

static uint8_t get_ident(void)
{
	static uint8_t ident;

	ident++;
   1bcf4:	4a05      	ldr	r2, [pc, #20]	; (1bd0c <get_ident+0x18>)
   1bcf6:	7813      	ldrb	r3, [r2, #0]
   1bcf8:	3301      	adds	r3, #1
   1bcfa:	b2db      	uxtb	r3, r3
   1bcfc:	7013      	strb	r3, [r2, #0]
	/* handle integer overflow (0 is not valid) */
	if (!ident) {
   1bcfe:	b90b      	cbnz	r3, 1bd04 <get_ident+0x10>
		ident++;
   1bd00:	3301      	adds	r3, #1
   1bd02:	7013      	strb	r3, [r2, #0]
	}

	return ident;
}
   1bd04:	4b01      	ldr	r3, [pc, #4]	; (1bd0c <get_ident+0x18>)
   1bd06:	7818      	ldrb	r0, [r3, #0]
   1bd08:	4770      	bx	lr
   1bd0a:	bf00      	nop
   1bd0c:	2000470f 	.word	0x2000470f

0001bd10 <l2cap_accept>:
	(void)k_work_cancel_delayable(&le_chan->rtx_work);
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}

static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
   1bd10:	b510      	push	{r4, lr}
   1bd12:	4602      	mov	r2, r0
		.recv = l2cap_recv,
	};

	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
   1bd14:	2000      	movs	r0, #0
   1bd16:	b130      	cbz	r0, 1bd26 <l2cap_accept+0x16>
		*chan = &l2cap->chan.chan;

		return 0;
	}

	BT_ERR("No available L2CAP context for conn %p", conn);
   1bd18:	2145      	movs	r1, #69	; 0x45
   1bd1a:	480b      	ldr	r0, [pc, #44]	; (1bd48 <l2cap_accept+0x38>)
   1bd1c:	f010 fc16 	bl	2c54c <z_log_minimal_printk>

	return -ENOMEM;
   1bd20:	f06f 000b 	mvn.w	r0, #11
}
   1bd24:	bd10      	pop	{r4, pc}
		if (l2cap->chan.chan.conn) {
   1bd26:	2394      	movs	r3, #148	; 0x94
   1bd28:	fb00 f303 	mul.w	r3, r0, r3
   1bd2c:	4c07      	ldr	r4, [pc, #28]	; (1bd4c <l2cap_accept+0x3c>)
   1bd2e:	58e3      	ldr	r3, [r4, r3]
   1bd30:	b10b      	cbz	r3, 1bd36 <l2cap_accept+0x26>
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
   1bd32:	3001      	adds	r0, #1
   1bd34:	e7ef      	b.n	1bd16 <l2cap_accept+0x6>
		l2cap->chan.chan.ops = &ops;
   1bd36:	4b05      	ldr	r3, [pc, #20]	; (1bd4c <l2cap_accept+0x3c>)
   1bd38:	2294      	movs	r2, #148	; 0x94
   1bd3a:	fb02 3300 	mla	r3, r2, r0, r3
   1bd3e:	4a04      	ldr	r2, [pc, #16]	; (1bd50 <l2cap_accept+0x40>)
   1bd40:	605a      	str	r2, [r3, #4]
		*chan = &l2cap->chan.chan;
   1bd42:	600b      	str	r3, [r1, #0]
		return 0;
   1bd44:	e7ee      	b.n	1bd24 <l2cap_accept+0x14>
   1bd46:	bf00      	nop
   1bd48:	0003a410 	.word	0x0003a410
   1bd4c:	20003b00 	.word	0x20003b00
   1bd50:	0003a5ec 	.word	0x0003a5ec

0001bd54 <le_conn_param_rsp>:
{
   1bd54:	b508      	push	{r3, lr}
	if (buf->len < sizeof(*rsp)) {
   1bd56:	898b      	ldrh	r3, [r1, #12]
   1bd58:	2b01      	cmp	r3, #1
   1bd5a:	d900      	bls.n	1bd5e <le_conn_param_rsp+0xa>
}
   1bd5c:	bd08      	pop	{r3, pc}
		BT_ERR("Too small LE conn param rsp");
   1bd5e:	2145      	movs	r1, #69	; 0x45
   1bd60:	4801      	ldr	r0, [pc, #4]	; (1bd68 <le_conn_param_rsp+0x14>)
   1bd62:	f010 fbf3 	bl	2c54c <z_log_minimal_printk>
		return;
   1bd66:	e7f9      	b.n	1bd5c <le_conn_param_rsp+0x8>
   1bd68:	0003a43c 	.word	0x0003a43c

0001bd6c <l2cap_chan_add>:
{
   1bd6c:	b510      	push	{r4, lr}
	if (!le_chan) {
   1bd6e:	b191      	cbz	r1, 1bd96 <l2cap_chan_add+0x2a>
   1bd70:	460b      	mov	r3, r1
	atomic_clear(chan->status);
   1bd72:	3110      	adds	r1, #16
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1bd74:	f04f 0c00 	mov.w	ip, #0
   1bd78:	f3bf 8f5b 	dmb	ish
   1bd7c:	e851 ef00 	ldrex	lr, [r1]
   1bd80:	e841 c400 	strex	r4, ip, [r1]
   1bd84:	2c00      	cmp	r4, #0
   1bd86:	d1f9      	bne.n	1bd7c <l2cap_chan_add+0x10>
   1bd88:	f3bf 8f5b 	dmb	ish
	bt_l2cap_chan_add(conn, chan, destroy);
   1bd8c:	4619      	mov	r1, r3
   1bd8e:	f011 facc 	bl	2d32a <bt_l2cap_chan_add>
	return true;
   1bd92:	2001      	movs	r0, #1
}
   1bd94:	bd10      	pop	{r4, pc}
		BT_ERR("Unable to allocate L2CAP channel ID");
   1bd96:	2145      	movs	r1, #69	; 0x45
   1bd98:	4802      	ldr	r0, [pc, #8]	; (1bda4 <l2cap_chan_add+0x38>)
   1bd9a:	f010 fbd7 	bl	2c54c <z_log_minimal_printk>
		return false;
   1bd9e:	2000      	movs	r0, #0
   1bda0:	e7f8      	b.n	1bd94 <l2cap_chan_add+0x28>
   1bda2:	bf00      	nop
   1bda4:	0003a460 	.word	0x0003a460

0001bda8 <bt_l2cap_connected>:
{
   1bda8:	b570      	push	{r4, r5, r6, lr}
   1bdaa:	b082      	sub	sp, #8
   1bdac:	4605      	mov	r5, r0
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   1bdae:	4c21      	ldr	r4, [pc, #132]	; (1be34 <bt_l2cap_connected+0x8c>)
   1bdb0:	e000      	b.n	1bdb4 <bt_l2cap_connected+0xc>
   1bdb2:	340c      	adds	r4, #12
   1bdb4:	4b20      	ldr	r3, [pc, #128]	; (1be38 <bt_l2cap_connected+0x90>)
   1bdb6:	429c      	cmp	r4, r3
   1bdb8:	d82d      	bhi.n	1be16 <bt_l2cap_connected+0x6e>
   1bdba:	4b1f      	ldr	r3, [pc, #124]	; (1be38 <bt_l2cap_connected+0x90>)
   1bdbc:	429c      	cmp	r4, r3
   1bdbe:	d237      	bcs.n	1be30 <bt_l2cap_connected+0x88>
		if (fchan->accept(conn, &chan) < 0) {
   1bdc0:	6863      	ldr	r3, [r4, #4]
   1bdc2:	a901      	add	r1, sp, #4
   1bdc4:	4628      	mov	r0, r5
   1bdc6:	4798      	blx	r3
   1bdc8:	2800      	cmp	r0, #0
   1bdca:	dbf2      	blt.n	1bdb2 <bt_l2cap_connected+0xa>
		le_chan = BT_L2CAP_LE_CHAN(chan);
   1bdcc:	9901      	ldr	r1, [sp, #4]
		le_chan->rx.cid = fchan->cid;
   1bdce:	8823      	ldrh	r3, [r4, #0]
   1bdd0:	828b      	strh	r3, [r1, #20]
		le_chan->tx.cid = fchan->cid;
   1bdd2:	848b      	strh	r3, [r1, #36]	; 0x24
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
   1bdd4:	68a2      	ldr	r2, [r4, #8]
   1bdd6:	4628      	mov	r0, r5
   1bdd8:	f7ff ffc8 	bl	1bd6c <l2cap_chan_add>
   1bddc:	b340      	cbz	r0, 1be30 <bt_l2cap_connected+0x88>
		if (chan->ops->connected) {
   1bdde:	9801      	ldr	r0, [sp, #4]
   1bde0:	6843      	ldr	r3, [r0, #4]
   1bde2:	681b      	ldr	r3, [r3, #0]
   1bde4:	b103      	cbz	r3, 1bde8 <bt_l2cap_connected+0x40>
			chan->ops->connected(chan);
   1bde6:	4798      	blx	r3
		atomic_set_bit(chan->status, BT_L2CAP_STATUS_OUT);
   1bde8:	9b01      	ldr	r3, [sp, #4]
   1bdea:	3310      	adds	r3, #16
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1bdec:	f3bf 8f5b 	dmb	ish
   1bdf0:	e853 2f00 	ldrex	r2, [r3]
   1bdf4:	f042 0201 	orr.w	r2, r2, #1
   1bdf8:	e843 2100 	strex	r1, r2, [r3]
   1bdfc:	2900      	cmp	r1, #0
   1bdfe:	d1f7      	bne.n	1bdf0 <bt_l2cap_connected+0x48>
   1be00:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
   1be04:	9801      	ldr	r0, [sp, #4]
   1be06:	6843      	ldr	r3, [r0, #4]
   1be08:	699b      	ldr	r3, [r3, #24]
   1be0a:	2b00      	cmp	r3, #0
   1be0c:	d0d1      	beq.n	1bdb2 <bt_l2cap_connected+0xa>
			chan->ops->status(chan, chan->status);
   1be0e:	f100 0110 	add.w	r1, r0, #16
   1be12:	4798      	blx	r3
   1be14:	e7cd      	b.n	1bdb2 <bt_l2cap_connected+0xa>
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   1be16:	4e09      	ldr	r6, [pc, #36]	; (1be3c <bt_l2cap_connected+0x94>)
   1be18:	f240 1281 	movw	r2, #385	; 0x181
   1be1c:	4631      	mov	r1, r6
   1be1e:	4808      	ldr	r0, [pc, #32]	; (1be40 <bt_l2cap_connected+0x98>)
   1be20:	f010 fb85 	bl	2c52e <assert_print>
   1be24:	f240 1181 	movw	r1, #385	; 0x181
   1be28:	4630      	mov	r0, r6
   1be2a:	f010 fb79 	bl	2c520 <assert_post_action>
   1be2e:	e7c4      	b.n	1bdba <bt_l2cap_connected+0x12>
}
   1be30:	b002      	add	sp, #8
   1be32:	bd70      	pop	{r4, r5, r6, pc}
   1be34:	00031270 	.word	0x00031270
   1be38:	00031294 	.word	0x00031294
   1be3c:	0003a48c 	.word	0x0003a48c
   1be40:	00031600 	.word	0x00031600

0001be44 <l2cap_create_le_sig_pdu>:
{
   1be44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1be46:	460c      	mov	r4, r1
   1be48:	4616      	mov	r6, r2
   1be4a:	461d      	mov	r5, r3
	buf = bt_l2cap_create_pdu_timeout(pool, 0, L2CAP_RTX_TIMEOUT);
   1be4c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1be50:	2300      	movs	r3, #0
   1be52:	2100      	movs	r1, #0
   1be54:	4608      	mov	r0, r1
   1be56:	f011 fa9a 	bl	2d38e <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   1be5a:	4607      	mov	r7, r0
   1be5c:	b140      	cbz	r0, 1be70 <l2cap_create_le_sig_pdu+0x2c>
	return net_buf_simple_add(&buf->b, len);
   1be5e:	2104      	movs	r1, #4
   1be60:	3008      	adds	r0, #8
   1be62:	f003 f96f 	bl	1f144 <net_buf_simple_add>
	hdr->code = code;
   1be66:	7004      	strb	r4, [r0, #0]
	hdr->ident = ident;
   1be68:	7046      	strb	r6, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
   1be6a:	8045      	strh	r5, [r0, #2]
}
   1be6c:	4638      	mov	r0, r7
   1be6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
   1be70:	4622      	mov	r2, r4
   1be72:	2145      	movs	r1, #69	; 0x45
   1be74:	4801      	ldr	r0, [pc, #4]	; (1be7c <l2cap_create_le_sig_pdu+0x38>)
   1be76:	f010 fb69 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1be7a:	e7f7      	b.n	1be6c <l2cap_create_le_sig_pdu+0x28>
   1be7c:	0003a4c0 	.word	0x0003a4c0

0001be80 <l2cap_recv>:
{
   1be80:	b570      	push	{r4, r5, r6, lr}
   1be82:	b082      	sub	sp, #8
	if (buf->len < sizeof(*hdr)) {
   1be84:	898b      	ldrh	r3, [r1, #12]
   1be86:	2b03      	cmp	r3, #3
   1be88:	d917      	bls.n	1beba <l2cap_recv+0x3a>
   1be8a:	4606      	mov	r6, r0
   1be8c:	460c      	mov	r4, r1
	return net_buf_simple_pull_mem(&buf->b, len);
   1be8e:	2104      	movs	r1, #4
   1be90:	f104 0008 	add.w	r0, r4, #8
   1be94:	f003 f916 	bl	1f0c4 <net_buf_simple_pull_mem>
   1be98:	4605      	mov	r5, r0
	len = sys_le16_to_cpu(hdr->len);
   1be9a:	8843      	ldrh	r3, [r0, #2]
	if (buf->len != len) {
   1be9c:	89a2      	ldrh	r2, [r4, #12]
   1be9e:	429a      	cmp	r2, r3
   1bea0:	d112      	bne.n	1bec8 <l2cap_recv+0x48>
	if (!hdr->ident) {
   1bea2:	7843      	ldrb	r3, [r0, #1]
   1bea4:	b1ab      	cbz	r3, 1bed2 <l2cap_recv+0x52>
	switch (hdr->code) {
   1bea6:	7802      	ldrb	r2, [r0, #0]
   1bea8:	2a01      	cmp	r2, #1
   1beaa:	d00a      	beq.n	1bec2 <l2cap_recv+0x42>
   1beac:	2a13      	cmp	r2, #19
   1beae:	d115      	bne.n	1bedc <l2cap_recv+0x5c>
		le_conn_param_rsp(l2cap, buf);
   1beb0:	4621      	mov	r1, r4
   1beb2:	4630      	mov	r0, r6
   1beb4:	f7ff ff4e 	bl	1bd54 <le_conn_param_rsp>
		break;
   1beb8:	e003      	b.n	1bec2 <l2cap_recv+0x42>
		BT_ERR("Too small L2CAP signaling PDU");
   1beba:	2145      	movs	r1, #69	; 0x45
   1bebc:	480d      	ldr	r0, [pc, #52]	; (1bef4 <l2cap_recv+0x74>)
   1bebe:	f010 fb45 	bl	2c54c <z_log_minimal_printk>
}
   1bec2:	2000      	movs	r0, #0
   1bec4:	b002      	add	sp, #8
   1bec6:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
   1bec8:	2145      	movs	r1, #69	; 0x45
   1beca:	480b      	ldr	r0, [pc, #44]	; (1bef8 <l2cap_recv+0x78>)
   1becc:	f010 fb3e 	bl	2c54c <z_log_minimal_printk>
		return 0;
   1bed0:	e7f7      	b.n	1bec2 <l2cap_recv+0x42>
		BT_ERR("Invalid ident value in L2CAP PDU");
   1bed2:	2145      	movs	r1, #69	; 0x45
   1bed4:	4809      	ldr	r0, [pc, #36]	; (1befc <l2cap_recv+0x7c>)
   1bed6:	f010 fb39 	bl	2c54c <z_log_minimal_printk>
		return 0;
   1beda:	e7f2      	b.n	1bec2 <l2cap_recv+0x42>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
   1bedc:	2157      	movs	r1, #87	; 0x57
   1bede:	4808      	ldr	r0, [pc, #32]	; (1bf00 <l2cap_recv+0x80>)
   1bee0:	f010 fb34 	bl	2c54c <z_log_minimal_printk>
		l2cap_send_reject(chan->conn, hdr->ident,
   1bee4:	7869      	ldrb	r1, [r5, #1]
   1bee6:	2200      	movs	r2, #0
   1bee8:	9200      	str	r2, [sp, #0]
   1beea:	4613      	mov	r3, r2
   1beec:	6830      	ldr	r0, [r6, #0]
   1beee:	f011 fa68 	bl	2d3c2 <l2cap_send_reject>
		break;
   1bef2:	e7e6      	b.n	1bec2 <l2cap_recv+0x42>
   1bef4:	0003a4f0 	.word	0x0003a4f0
   1bef8:	0003a514 	.word	0x0003a514
   1befc:	0003a53c 	.word	0x0003a53c
   1bf00:	0003a564 	.word	0x0003a564

0001bf04 <bt_l2cap_recv>:
{
   1bf04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bf06:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
   1bf08:	898b      	ldrh	r3, [r1, #12]
   1bf0a:	2b03      	cmp	r3, #3
   1bf0c:	d911      	bls.n	1bf32 <bt_l2cap_recv+0x2e>
   1bf0e:	4605      	mov	r5, r0
   1bf10:	4616      	mov	r6, r2
   1bf12:	2104      	movs	r1, #4
   1bf14:	f104 0008 	add.w	r0, r4, #8
   1bf18:	f003 f8d4 	bl	1f0c4 <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
   1bf1c:	8847      	ldrh	r7, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
   1bf1e:	4639      	mov	r1, r7
   1bf20:	4628      	mov	r0, r5
   1bf22:	f011 fa7b 	bl	2d41c <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   1bf26:	b160      	cbz	r0, 1bf42 <bt_l2cap_recv+0x3e>
	l2cap_chan_recv(chan, buf, complete);
   1bf28:	4632      	mov	r2, r6
   1bf2a:	4621      	mov	r1, r4
   1bf2c:	f011 f9e1 	bl	2d2f2 <l2cap_chan_recv>
}
   1bf30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		BT_ERR("Too small L2CAP PDU received");
   1bf32:	2145      	movs	r1, #69	; 0x45
   1bf34:	4807      	ldr	r0, [pc, #28]	; (1bf54 <bt_l2cap_recv+0x50>)
   1bf36:	f010 fb09 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   1bf3a:	4620      	mov	r0, r4
   1bf3c:	f002 ffea 	bl	1ef14 <net_buf_unref>
		return;
   1bf40:	e7f6      	b.n	1bf30 <bt_l2cap_recv+0x2c>
		BT_WARN("Ignoring data for unknown channel ID 0x%04x", cid);
   1bf42:	463a      	mov	r2, r7
   1bf44:	2157      	movs	r1, #87	; 0x57
   1bf46:	4804      	ldr	r0, [pc, #16]	; (1bf58 <bt_l2cap_recv+0x54>)
   1bf48:	f010 fb00 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   1bf4c:	4620      	mov	r0, r4
   1bf4e:	f002 ffe1 	bl	1ef14 <net_buf_unref>
		return;
   1bf52:	e7ed      	b.n	1bf30 <bt_l2cap_recv+0x2c>
   1bf54:	0003a588 	.word	0x0003a588
   1bf58:	0003a5ac 	.word	0x0003a5ac

0001bf5c <tx_meta_data_alloc>:

static struct bt_att_tx_meta_data tx_meta_data[CONFIG_BT_CONN_TX_MAX];
K_FIFO_DEFINE(free_att_tx_meta_data);

static struct bt_att_tx_meta_data *tx_meta_data_alloc(k_timeout_t timeout)
{
   1bf5c:	b508      	push	{r3, lr}
   1bf5e:	4602      	mov	r2, r0
   1bf60:	460b      	mov	r3, r1
	return z_impl_k_queue_get(queue, timeout);
   1bf62:	4802      	ldr	r0, [pc, #8]	; (1bf6c <tx_meta_data_alloc+0x10>)
   1bf64:	f00a ff9e 	bl	26ea4 <z_impl_k_queue_get>
	return k_fifo_get(&free_att_tx_meta_data, timeout);
}
   1bf68:	bd08      	pop	{r3, pc}
   1bf6a:	bf00      	nop
   1bf6c:	20000ecc 	.word	0x20000ecc

0001bf70 <att_cb>:

	chan_unknown(conn, user_data, err);
}

static bt_conn_tx_cb_t att_cb(const struct net_buf *buf)
{
   1bf70:	b510      	push	{r4, lr}
	const att_type_t op_type = att_op_get_type(buf->data[0]);
   1bf72:	6883      	ldr	r3, [r0, #8]
   1bf74:	7818      	ldrb	r0, [r3, #0]
   1bf76:	f011 fade 	bl	2d536 <att_op_get_type>

	switch (op_type) {
   1bf7a:	2805      	cmp	r0, #5
   1bf7c:	d80a      	bhi.n	1bf94 <att_cb+0x24>
   1bf7e:	e8df f000 	tbb	[pc, r0]
   1bf82:	0507      	.short	0x0507
   1bf84:	05170703 	.word	0x05170703
   1bf88:	480a      	ldr	r0, [pc, #40]	; (1bfb4 <att_cb+0x44>)
   1bf8a:	e000      	b.n	1bf8e <att_cb+0x1e>
		return att_rsp_sent;
	case ATT_CONFIRMATION:
		return att_cfm_sent;
	case ATT_REQUEST:
	case ATT_INDICATION:
		return att_req_sent;
   1bf8c:	480a      	ldr	r0, [pc, #40]	; (1bfb8 <att_cb+0x48>)
	default:
		__ASSERT(false, "Unknown op type 0x%02X", op_type);
	}

	return att_unknown;
}
   1bf8e:	bd10      	pop	{r4, pc}
		return att_tx_complete;
   1bf90:	480a      	ldr	r0, [pc, #40]	; (1bfbc <att_cb+0x4c>)
   1bf92:	e7fc      	b.n	1bf8e <att_cb+0x1e>
		__ASSERT(false, "Unknown op type 0x%02X", op_type);
   1bf94:	4c0a      	ldr	r4, [pc, #40]	; (1bfc0 <att_cb+0x50>)
   1bf96:	f240 2256 	movw	r2, #598	; 0x256
   1bf9a:	4621      	mov	r1, r4
   1bf9c:	4809      	ldr	r0, [pc, #36]	; (1bfc4 <att_cb+0x54>)
   1bf9e:	f010 fac6 	bl	2c52e <assert_print>
   1bfa2:	f240 2156 	movw	r1, #598	; 0x256
   1bfa6:	4620      	mov	r0, r4
   1bfa8:	f010 faba 	bl	2c520 <assert_post_action>
	return att_unknown;
   1bfac:	4806      	ldr	r0, [pc, #24]	; (1bfc8 <att_cb+0x58>)
   1bfae:	e7ee      	b.n	1bf8e <att_cb+0x1e>
		return att_cfm_sent;
   1bfb0:	4806      	ldr	r0, [pc, #24]	; (1bfcc <att_cb+0x5c>)
   1bfb2:	e7ec      	b.n	1bf8e <att_cb+0x1e>
   1bfb4:	0002dd5f 	.word	0x0002dd5f
   1bfb8:	0002dd27 	.word	0x0002dd27
   1bfbc:	0002dd0b 	.word	0x0002dd0b
   1bfc0:	0003a610 	.word	0x0003a610
   1bfc4:	00031600 	.word	0x00031600
   1bfc8:	0002dcef 	.word	0x0002dcef
   1bfcc:	0002dd43 	.word	0x0002dd43

0001bfd0 <att_chan_new>:
	att_chan_mtu_updated(att_chan);
}
#endif /* CONFIG_BT_EATT */

static struct bt_att_chan *att_chan_new(struct bt_att *att, atomic_val_t flags)
{
   1bfd0:	b570      	push	{r4, r5, r6, lr}
   1bfd2:	b082      	sub	sp, #8
   1bfd4:	4605      	mov	r5, r0
   1bfd6:	460e      	mov	r6, r1
	return list->head;
   1bfd8:	6a83      	ldr	r3, [r0, #40]	; 0x28
		.reconfigured = bt_att_reconfigured,
	#endif /* CONFIG_BT_EATT */
	};
	struct bt_att_chan *chan;

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   1bfda:	b103      	cbz	r3, 1bfde <att_chan_new+0xe>
   1bfdc:	3bf0      	subs	r3, #240	; 0xf0
   1bfde:	9301      	str	r3, [sp, #4]
	int quota = 0;
   1bfe0:	2200      	movs	r2, #0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   1bfe2:	e008      	b.n	1bff6 <att_chan_new+0x26>
		if (chan->att == att) {
			quota++;
   1bfe4:	3201      	adds	r2, #1
   1bfe6:	e00b      	b.n	1c000 <att_chan_new+0x30>
		}

		if (quota == ATT_CHAN_MAX) {
			BT_WARN("Maximum number of channels reached: %d", quota);
   1bfe8:	2157      	movs	r1, #87	; 0x57
   1bfea:	4822      	ldr	r0, [pc, #136]	; (1c074 <att_chan_new+0xa4>)
   1bfec:	f010 faae 	bl	2c54c <z_log_minimal_printk>
			return NULL;
   1bff0:	2400      	movs	r4, #0
   1bff2:	e035      	b.n	1c060 <att_chan_new+0x90>
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   1bff4:	9301      	str	r3, [sp, #4]
   1bff6:	9c01      	ldr	r4, [sp, #4]
   1bff8:	b16c      	cbz	r4, 1c016 <att_chan_new+0x46>
		if (chan->att == att) {
   1bffa:	6823      	ldr	r3, [r4, #0]
   1bffc:	42ab      	cmp	r3, r5
   1bffe:	d0f1      	beq.n	1bfe4 <att_chan_new+0x14>
		if (quota == ATT_CHAN_MAX) {
   1c000:	2a01      	cmp	r2, #1
   1c002:	d0f1      	beq.n	1bfe8 <att_chan_new+0x18>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1c004:	f114 03f0 	adds.w	r3, r4, #240	; 0xf0
   1c008:	d0f4      	beq.n	1bff4 <att_chan_new+0x24>
	return node->next;
   1c00a:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   1c00e:	2b00      	cmp	r3, #0
   1c010:	d0f0      	beq.n	1bff4 <att_chan_new+0x24>
   1c012:	3bf0      	subs	r3, #240	; 0xf0
   1c014:	e7ee      	b.n	1bff4 <att_chan_new+0x24>
		}
	}

	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
   1c016:	2200      	movs	r2, #0
   1c018:	2300      	movs	r3, #0
   1c01a:	a901      	add	r1, sp, #4
   1c01c:	4816      	ldr	r0, [pc, #88]	; (1c078 <att_chan_new+0xa8>)
   1c01e:	f00a f973 	bl	26308 <k_mem_slab_alloc>
   1c022:	bb00      	cbnz	r0, 1c066 <att_chan_new+0x96>
   1c024:	22f8      	movs	r2, #248	; 0xf8
   1c026:	2100      	movs	r1, #0
   1c028:	9801      	ldr	r0, [sp, #4]
   1c02a:	f014 ff3d 	bl	30ea8 <memset>
		BT_WARN("No available ATT channel for conn %p", att->conn);
		return NULL;
	}

	(void)memset(chan, 0, sizeof(*chan));
	chan->chan.chan.ops = &ops;
   1c02e:	9801      	ldr	r0, [sp, #4]
   1c030:	4b12      	ldr	r3, [pc, #72]	; (1c07c <att_chan_new+0xac>)
   1c032:	6083      	str	r3, [r0, #8]
	k_fifo_init(&chan->tx_queue);
   1c034:	30a0      	adds	r0, #160	; 0xa0
	z_impl_k_queue_init(queue);
   1c036:	f014 fcd2 	bl	309de <z_impl_k_queue_init>
	atomic_set(chan->flags, flags);
   1c03a:	9b01      	ldr	r3, [sp, #4]
   1c03c:	3398      	adds	r3, #152	; 0x98
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1c03e:	f3bf 8f5b 	dmb	ish
   1c042:	e853 2f00 	ldrex	r2, [r3]
   1c046:	e843 6100 	strex	r1, r6, [r3]
   1c04a:	2900      	cmp	r1, #0
   1c04c:	d1f9      	bne.n	1c042 <att_chan_new+0x72>
   1c04e:	f3bf 8f5b 	dmb	ish
	chan->att = att;
   1c052:	9b01      	ldr	r3, [sp, #4]
   1c054:	601d      	str	r5, [r3, #0]
	att_chan_attach(att, chan);
   1c056:	9901      	ldr	r1, [sp, #4]
   1c058:	4628      	mov	r0, r5
   1c05a:	f011 faed 	bl	2d638 <att_chan_attach>

	return chan;
   1c05e:	9c01      	ldr	r4, [sp, #4]
}
   1c060:	4620      	mov	r0, r4
   1c062:	b002      	add	sp, #8
   1c064:	bd70      	pop	{r4, r5, r6, pc}
		BT_WARN("No available ATT channel for conn %p", att->conn);
   1c066:	682a      	ldr	r2, [r5, #0]
   1c068:	2157      	movs	r1, #87	; 0x57
   1c06a:	4805      	ldr	r0, [pc, #20]	; (1c080 <att_chan_new+0xb0>)
   1c06c:	f010 fa6e 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1c070:	e7f6      	b.n	1c060 <att_chan_new+0x90>
   1c072:	bf00      	nop
   1c074:	0003a640 	.word	0x0003a640
   1c078:	20000e60 	.word	0x20000e60
   1c07c:	20000b20 	.word	0x20000b20
   1c080:	0003a66c 	.word	0x0003a66c

0001c084 <bt_att_accept>:

}
#endif /* CONFIG_BT_EATT */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
   1c084:	b570      	push	{r4, r5, r6, lr}
   1c086:	b082      	sub	sp, #8
   1c088:	4604      	mov	r4, r0
   1c08a:	460d      	mov	r5, r1
	struct bt_att *att;
	struct bt_att_chan *chan;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
   1c08c:	2200      	movs	r2, #0
   1c08e:	2300      	movs	r3, #0
   1c090:	a901      	add	r1, sp, #4
   1c092:	4815      	ldr	r0, [pc, #84]	; (1c0e8 <bt_att_accept+0x64>)
   1c094:	f00a f938 	bl	26308 <k_mem_slab_alloc>
   1c098:	b9d0      	cbnz	r0, 1c0d0 <bt_att_accept+0x4c>
   1c09a:	4606      	mov	r6, r0
	return z_impl_z_current_get();
   1c09c:	f00c fea2 	bl	28de4 <z_impl_z_current_get>
		BT_ERR("No available ATT context for conn %p", conn);
		return -ENOMEM;
	}

	att_handle_rsp_thread = k_current_get();
   1c0a0:	4b12      	ldr	r3, [pc, #72]	; (1c0ec <bt_att_accept+0x68>)
   1c0a2:	6018      	str	r0, [r3, #0]
   1c0a4:	2230      	movs	r2, #48	; 0x30
   1c0a6:	2100      	movs	r1, #0
   1c0a8:	9801      	ldr	r0, [sp, #4]
   1c0aa:	f014 fefd 	bl	30ea8 <memset>

	(void)memset(att, 0, sizeof(*att));
	att->conn = conn;
   1c0ae:	9b01      	ldr	r3, [sp, #4]
   1c0b0:	601c      	str	r4, [r3, #0]
	sys_slist_init(&att->reqs);
   1c0b2:	9801      	ldr	r0, [sp, #4]
	list->head = NULL;
   1c0b4:	2100      	movs	r1, #0
   1c0b6:	6041      	str	r1, [r0, #4]
	list->tail = NULL;
   1c0b8:	6081      	str	r1, [r0, #8]
	list->head = NULL;
   1c0ba:	6281      	str	r1, [r0, #40]	; 0x28
	list->tail = NULL;
   1c0bc:	62c1      	str	r1, [r0, #44]	; 0x2c
#if defined(CONFIG_BT_EATT)
	k_work_init_delayable(&att->eatt.connection_work,
			      att_enhanced_connection_work_handler);
#endif /* CONFIG_BT_EATT */

	chan = att_chan_new(att, 0);
   1c0be:	f7ff ff87 	bl	1bfd0 <att_chan_new>
	if (!chan) {
   1c0c2:	4603      	mov	r3, r0
   1c0c4:	b160      	cbz	r0, 1c0e0 <bt_att_accept+0x5c>
		return -ENOMEM;
	}

	*ch = &chan->chan.chan;
   1c0c6:	3304      	adds	r3, #4
   1c0c8:	602b      	str	r3, [r5, #0]

	return 0;
}
   1c0ca:	4630      	mov	r0, r6
   1c0cc:	b002      	add	sp, #8
   1c0ce:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("No available ATT context for conn %p", conn);
   1c0d0:	4622      	mov	r2, r4
   1c0d2:	2145      	movs	r1, #69	; 0x45
   1c0d4:	4806      	ldr	r0, [pc, #24]	; (1c0f0 <bt_att_accept+0x6c>)
   1c0d6:	f010 fa39 	bl	2c54c <z_log_minimal_printk>
		return -ENOMEM;
   1c0da:	f06f 060b 	mvn.w	r6, #11
   1c0de:	e7f4      	b.n	1c0ca <bt_att_accept+0x46>
		return -ENOMEM;
   1c0e0:	f06f 060b 	mvn.w	r6, #11
   1c0e4:	e7f1      	b.n	1c0ca <bt_att_accept+0x46>
   1c0e6:	bf00      	nop
   1c0e8:	20000e40 	.word	0x20000e40
   1c0ec:	20003b94 	.word	0x20003b94
   1c0f0:	0003a698 	.word	0x0003a698

0001c0f4 <bt_att_released>:
{
   1c0f4:	b500      	push	{lr}
   1c0f6:	b083      	sub	sp, #12
	struct bt_att_chan *chan = ATT_CHAN(ch);
   1c0f8:	3804      	subs	r0, #4
   1c0fa:	9001      	str	r0, [sp, #4]
	k_mem_slab_free(&chan_slab, (void **)&chan);
   1c0fc:	a901      	add	r1, sp, #4
   1c0fe:	4803      	ldr	r0, [pc, #12]	; (1c10c <bt_att_released+0x18>)
   1c100:	f00a f966 	bl	263d0 <k_mem_slab_free>
}
   1c104:	b003      	add	sp, #12
   1c106:	f85d fb04 	ldr.w	pc, [sp], #4
   1c10a:	bf00      	nop
   1c10c:	20000e60 	.word	0x20000e60

0001c110 <read_group_cb>:
{
   1c110:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c112:	b085      	sub	sp, #20
   1c114:	4605      	mov	r5, r0
   1c116:	460e      	mov	r6, r1
   1c118:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   1c11a:	6817      	ldr	r7, [r2, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1c11c:	2300      	movs	r3, #0
   1c11e:	f88d 3008 	strb.w	r3, [sp, #8]
   1c122:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1c126:	f8ad 300a 	strh.w	r3, [sp, #10]
   1c12a:	a902      	add	r1, sp, #8
   1c12c:	6800      	ldr	r0, [r0, #0]
   1c12e:	f010 fc25 	bl	2c97c <bt_uuid_cmp>
   1c132:	b158      	cbz	r0, 1c14c <read_group_cb+0x3c>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   1c134:	2300      	movs	r3, #0
   1c136:	f88d 300c 	strb.w	r3, [sp, #12]
   1c13a:	f642 0301 	movw	r3, #10241	; 0x2801
   1c13e:	f8ad 300e 	strh.w	r3, [sp, #14]
   1c142:	a903      	add	r1, sp, #12
   1c144:	6828      	ldr	r0, [r5, #0]
   1c146:	f010 fc19 	bl	2c97c <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1c14a:	bb28      	cbnz	r0, 1c198 <read_group_cb+0x88>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   1c14c:	6861      	ldr	r1, [r4, #4]
   1c14e:	6828      	ldr	r0, [r5, #0]
   1c150:	f010 fc14 	bl	2c97c <bt_uuid_cmp>
   1c154:	bb40      	cbnz	r0, 1c1a8 <read_group_cb+0x98>
	if (data->rsp->len &&
   1c156:	68e3      	ldr	r3, [r4, #12]
   1c158:	781a      	ldrb	r2, [r3, #0]
   1c15a:	b12a      	cbz	r2, 1c168 <read_group_cb+0x58>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
   1c15c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   1c15e:	68a1      	ldr	r1, [r4, #8]
   1c160:	8989      	ldrh	r1, [r1, #12]
   1c162:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
   1c164:	4293      	cmp	r3, r2
   1c166:	db24      	blt.n	1c1b2 <read_group_cb+0xa2>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   1c168:	68a0      	ldr	r0, [r4, #8]
	return net_buf_simple_add(&buf->b, len);
   1c16a:	2104      	movs	r1, #4
   1c16c:	3008      	adds	r0, #8
   1c16e:	f002 ffe9 	bl	1f144 <net_buf_simple_add>
   1c172:	6120      	str	r0, [r4, #16]
	data->group->start_handle = sys_cpu_to_le16(handle);
   1c174:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
   1c176:	6923      	ldr	r3, [r4, #16]
   1c178:	805e      	strh	r6, [r3, #2]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
   1c17a:	9401      	str	r4, [sp, #4]
   1c17c:	4b10      	ldr	r3, [pc, #64]	; (1c1c0 <read_group_cb+0xb0>)
   1c17e:	9300      	str	r3, [sp, #0]
   1c180:	2300      	movs	r3, #0
   1c182:	68a2      	ldr	r2, [r4, #8]
   1c184:	4629      	mov	r1, r5
   1c186:	4638      	mov	r0, r7
   1c188:	f011 faf7 	bl	2d77a <att_chan_read>
	if (read < 0) {
   1c18c:	2800      	cmp	r0, #0
   1c18e:	db12      	blt.n	1c1b6 <read_group_cb+0xa6>
	if (!data->group) {
   1c190:	6923      	ldr	r3, [r4, #16]
   1c192:	b193      	cbz	r3, 1c1ba <read_group_cb+0xaa>
	return BT_GATT_ITER_CONTINUE;
   1c194:	2001      	movs	r0, #1
   1c196:	e00a      	b.n	1c1ae <read_group_cb+0x9e>
		if (data->group &&
   1c198:	6923      	ldr	r3, [r4, #16]
   1c19a:	b11b      	cbz	r3, 1c1a4 <read_group_cb+0x94>
		    handle > sys_le16_to_cpu(data->group->end_handle)) {
   1c19c:	885a      	ldrh	r2, [r3, #2]
		if (data->group &&
   1c19e:	42b2      	cmp	r2, r6
   1c1a0:	d200      	bcs.n	1c1a4 <read_group_cb+0x94>
			data->group->end_handle = sys_cpu_to_le16(handle);
   1c1a2:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   1c1a4:	2001      	movs	r0, #1
   1c1a6:	e002      	b.n	1c1ae <read_group_cb+0x9e>
		data->group = NULL;
   1c1a8:	2300      	movs	r3, #0
   1c1aa:	6123      	str	r3, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
   1c1ac:	2001      	movs	r0, #1
}
   1c1ae:	b005      	add	sp, #20
   1c1b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ITER_STOP;
   1c1b2:	2000      	movs	r0, #0
   1c1b4:	e7fb      	b.n	1c1ae <read_group_cb+0x9e>
		return BT_GATT_ITER_STOP;
   1c1b6:	2000      	movs	r0, #0
   1c1b8:	e7f9      	b.n	1c1ae <read_group_cb+0x9e>
		return BT_GATT_ITER_STOP;
   1c1ba:	2000      	movs	r0, #0
   1c1bc:	e7f7      	b.n	1c1ae <read_group_cb+0x9e>
   1c1be:	bf00      	nop
   1c1c0:	0002d509 	.word	0x0002d509

0001c1c4 <read_type_cb>:
{
   1c1c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1c1c8:	b083      	sub	sp, #12
   1c1ca:	4606      	mov	r6, r0
   1c1cc:	4688      	mov	r8, r1
   1c1ce:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   1c1d0:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   1c1d2:	687d      	ldr	r5, [r7, #4]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   1c1d4:	6851      	ldr	r1, [r2, #4]
   1c1d6:	6800      	ldr	r0, [r0, #0]
   1c1d8:	f010 fbd0 	bl	2c97c <bt_uuid_cmp>
   1c1dc:	b120      	cbz	r0, 1c1e8 <read_type_cb+0x24>
		return BT_GATT_ITER_CONTINUE;
   1c1de:	2501      	movs	r5, #1
}
   1c1e0:	4628      	mov	r0, r5
   1c1e2:	b003      	add	sp, #12
   1c1e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   1c1e8:	2295      	movs	r2, #149	; 0x95
   1c1ea:	4631      	mov	r1, r6
   1c1ec:	4628      	mov	r0, r5
   1c1ee:	f012 fcf3 	bl	2ebd8 <bt_gatt_check_perm>
   1c1f2:	4605      	mov	r5, r0
   1c1f4:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   1c1f6:	b130      	cbz	r0, 1c206 <read_type_cb+0x42>
		if (data->rsp->len) {
   1c1f8:	68e3      	ldr	r3, [r4, #12]
   1c1fa:	781b      	ldrb	r3, [r3, #0]
   1c1fc:	b10b      	cbz	r3, 1c202 <read_type_cb+0x3e>
			data->err = 0x00;
   1c1fe:	2300      	movs	r3, #0
   1c200:	7523      	strb	r3, [r4, #20]
		return BT_GATT_ITER_STOP;
   1c202:	2500      	movs	r5, #0
   1c204:	e7ec      	b.n	1c1e0 <read_type_cb+0x1c>
	data->err = 0x00;
   1c206:	f04f 0900 	mov.w	r9, #0
   1c20a:	f884 9014 	strb.w	r9, [r4, #20]
	data->item = net_buf_add(net_buf_frag_last(data->buf),
   1c20e:	68a0      	ldr	r0, [r4, #8]
   1c210:	f002 fed2 	bl	1efb8 <net_buf_frag_last>
   1c214:	2102      	movs	r1, #2
   1c216:	3008      	adds	r0, #8
   1c218:	f002 ff94 	bl	1f144 <net_buf_simple_add>
   1c21c:	6120      	str	r0, [r4, #16]
	data->item->handle = sys_cpu_to_le16(handle);
   1c21e:	f8a0 8000 	strh.w	r8, [r0]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
   1c222:	9401      	str	r4, [sp, #4]
   1c224:	4b10      	ldr	r3, [pc, #64]	; (1c268 <read_type_cb+0xa4>)
   1c226:	9300      	str	r3, [sp, #0]
   1c228:	464b      	mov	r3, r9
   1c22a:	68a2      	ldr	r2, [r4, #8]
   1c22c:	4631      	mov	r1, r6
   1c22e:	4638      	mov	r0, r7
   1c230:	f011 faa3 	bl	2d77a <att_chan_read>
	if (read < 0) {
   1c234:	2800      	cmp	r0, #0
   1c236:	db06      	blt.n	1c246 <read_type_cb+0x82>
	if (!data->item) {
   1c238:	6923      	ldr	r3, [r4, #16]
   1c23a:	2b00      	cmp	r3, #0
   1c23c:	d0d0      	beq.n	1c1e0 <read_type_cb+0x1c>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
   1c23e:	8d7d      	ldrh	r5, [r7, #42]	; 0x2a
   1c240:	68a3      	ldr	r3, [r4, #8]
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
   1c242:	2200      	movs	r2, #0

	while (buf) {
   1c244:	e006      	b.n	1c254 <read_type_cb+0x90>
		data->err = err_to_att(read);
   1c246:	f011 f942 	bl	2d4ce <err_to_att>
   1c24a:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
   1c24c:	e7c8      	b.n	1c1e0 <read_type_cb+0x1c>
		bytes += buf->len;
   1c24e:	8999      	ldrh	r1, [r3, #12]
   1c250:	440a      	add	r2, r1
		buf = buf->frags;
   1c252:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1c254:	2b00      	cmp	r3, #0
   1c256:	d1fa      	bne.n	1c24e <read_type_cb+0x8a>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
   1c258:	1aaa      	subs	r2, r5, r2
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   1c25a:	68e3      	ldr	r3, [r4, #12]
   1c25c:	781d      	ldrb	r5, [r3, #0]
   1c25e:	42aa      	cmp	r2, r5
   1c260:	bf94      	ite	ls
   1c262:	2500      	movls	r5, #0
   1c264:	2501      	movhi	r5, #1
   1c266:	e7bb      	b.n	1c1e0 <read_type_cb+0x1c>
   1c268:	0002d4df 	.word	0x0002d4df

0001c26c <find_type_cb>:
{
   1c26c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c270:	b093      	sub	sp, #76	; 0x4c
   1c272:	4605      	mov	r5, r0
   1c274:	460e      	mov	r6, r1
   1c276:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   1c278:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   1c27a:	f8d7 8004 	ldr.w	r8, [r7, #4]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   1c27e:	2300      	movs	r3, #0
   1c280:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c284:	f642 0301 	movw	r3, #10241	; 0x2801
   1c288:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
   1c28c:	a910      	add	r1, sp, #64	; 0x40
   1c28e:	6800      	ldr	r0, [r0, #0]
   1c290:	f010 fb74 	bl	2c97c <bt_uuid_cmp>
   1c294:	b928      	cbnz	r0, 1c2a2 <find_type_cb+0x36>
	data->group = NULL;
   1c296:	2300      	movs	r3, #0
   1c298:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
   1c29a:	2001      	movs	r0, #1
}
   1c29c:	b013      	add	sp, #76	; 0x4c
   1c29e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
   1c2a2:	2300      	movs	r3, #0
   1c2a4:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
   1c2a8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1c2ac:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
   1c2b0:	a911      	add	r1, sp, #68	; 0x44
   1c2b2:	6828      	ldr	r0, [r5, #0]
   1c2b4:	f010 fb62 	bl	2c97c <bt_uuid_cmp>
   1c2b8:	b928      	cbnz	r0, 1c2c6 <find_type_cb+0x5a>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
   1c2ba:	8d79      	ldrh	r1, [r7, #42]	; 0x2a
   1c2bc:	6860      	ldr	r0, [r4, #4]
   1c2be:	4603      	mov	r3, r0
	size_t bytes = 0;
   1c2c0:	f04f 0c00 	mov.w	ip, #0
	while (buf) {
   1c2c4:	e00a      	b.n	1c2dc <find_type_cb+0x70>
		if (data->group &&
   1c2c6:	68a3      	ldr	r3, [r4, #8]
   1c2c8:	b11b      	cbz	r3, 1c2d2 <find_type_cb+0x66>
		    handle > sys_le16_to_cpu(data->group->end_handle)) {
   1c2ca:	885a      	ldrh	r2, [r3, #2]
		if (data->group &&
   1c2cc:	42b2      	cmp	r2, r6
   1c2ce:	d200      	bcs.n	1c2d2 <find_type_cb+0x66>
			data->group->end_handle = sys_cpu_to_le16(handle);
   1c2d0:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   1c2d2:	2001      	movs	r0, #1
   1c2d4:	e7e2      	b.n	1c29c <find_type_cb+0x30>
		bytes += buf->len;
   1c2d6:	899a      	ldrh	r2, [r3, #12]
   1c2d8:	4494      	add	ip, r2
		buf = buf->frags;
   1c2da:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1c2dc:	2b00      	cmp	r3, #0
   1c2de:	d1fa      	bne.n	1c2d6 <find_type_cb+0x6a>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
   1c2e0:	eba1 0c0c 	sub.w	ip, r1, ip
   1c2e4:	f1bc 0f03 	cmp.w	ip, #3
   1c2e8:	d801      	bhi.n	1c2ee <find_type_cb+0x82>
		return BT_GATT_ITER_STOP;
   1c2ea:	2000      	movs	r0, #0
   1c2ec:	e7d6      	b.n	1c29c <find_type_cb+0x30>
	frag = net_buf_frag_last(data->buf);
   1c2ee:	f002 fe63 	bl	1efb8 <net_buf_frag_last>
   1c2f2:	4681      	mov	r9, r0
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
   1c2f4:	f8b7 a02a 	ldrh.w	sl, [r7, #42]	; 0x2a
   1c2f8:	6863      	ldr	r3, [r4, #4]
	size_t bytes = 0;
   1c2fa:	2200      	movs	r2, #0
	while (buf) {
   1c2fc:	e002      	b.n	1c304 <find_type_cb+0x98>
		bytes += buf->len;
   1c2fe:	8999      	ldrh	r1, [r3, #12]
   1c300:	440a      	add	r2, r1
		buf = buf->frags;
   1c302:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1c304:	2b00      	cmp	r3, #0
   1c306:	d1fa      	bne.n	1c2fe <find_type_cb+0x92>
   1c308:	ebaa 0a02 	sub.w	sl, sl, r2
	return net_buf_simple_tailroom(&buf->b);
   1c30c:	f109 0b08 	add.w	fp, r9, #8
   1c310:	4658      	mov	r0, fp
   1c312:	f012 fde4 	bl	2eede <net_buf_simple_tailroom>
   1c316:	4582      	cmp	sl, r0
   1c318:	d228      	bcs.n	1c36c <find_type_cb+0x100>
   1c31a:	8d78      	ldrh	r0, [r7, #42]	; 0x2a
   1c31c:	6863      	ldr	r3, [r4, #4]
	size_t bytes = 0;
   1c31e:	2200      	movs	r2, #0
	while (buf) {
   1c320:	e002      	b.n	1c328 <find_type_cb+0xbc>
		bytes += buf->len;
   1c322:	8999      	ldrh	r1, [r3, #12]
   1c324:	440a      	add	r2, r1
		buf = buf->frags;
   1c326:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1c328:	2b00      	cmp	r3, #0
   1c32a:	d1fa      	bne.n	1c322 <find_type_cb+0xb6>
   1c32c:	1a80      	subs	r0, r0, r2
	if (!len) {
   1c32e:	b308      	cbz	r0, 1c374 <find_type_cb+0x108>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
   1c330:	686f      	ldr	r7, [r5, #4]
   1c332:	2300      	movs	r3, #0
   1c334:	9300      	str	r3, [sp, #0]
   1c336:	2310      	movs	r3, #16
   1c338:	aa0c      	add	r2, sp, #48	; 0x30
   1c33a:	4629      	mov	r1, r5
   1c33c:	4640      	mov	r0, r8
   1c33e:	47b8      	blx	r7
	if (read < 0) {
   1c340:	1e05      	subs	r5, r0, #0
   1c342:	dba8      	blt.n	1c296 <find_type_cb+0x2a>
	if (read != data->value_len) {
   1c344:	7c22      	ldrb	r2, [r4, #16]
   1c346:	42aa      	cmp	r2, r5
   1c348:	d030      	beq.n	1c3ac <find_type_cb+0x140>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
   1c34a:	68e1      	ldr	r1, [r4, #12]
   1c34c:	a807      	add	r0, sp, #28
   1c34e:	f010 fb33 	bl	2c9b8 <bt_uuid_create>
   1c352:	b1f8      	cbz	r0, 1c394 <find_type_cb+0x128>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
   1c354:	b2ea      	uxtb	r2, r5
   1c356:	a90c      	add	r1, sp, #48	; 0x30
   1c358:	a802      	add	r0, sp, #8
   1c35a:	f010 fb2d 	bl	2c9b8 <bt_uuid_create>
   1c35e:	b1f8      	cbz	r0, 1c3a0 <find_type_cb+0x134>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
   1c360:	a902      	add	r1, sp, #8
   1c362:	a807      	add	r0, sp, #28
   1c364:	f010 fb0a 	bl	2c97c <bt_uuid_cmp>
   1c368:	b340      	cbz	r0, 1c3bc <find_type_cb+0x150>
   1c36a:	e794      	b.n	1c296 <find_type_cb+0x2a>
	return net_buf_simple_tailroom(&buf->b);
   1c36c:	4658      	mov	r0, fp
   1c36e:	f012 fdb6 	bl	2eede <net_buf_simple_tailroom>
   1c372:	e7dc      	b.n	1c32e <find_type_cb+0xc2>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
   1c374:	6863      	ldr	r3, [r4, #4]
   1c376:	7998      	ldrb	r0, [r3, #6]
   1c378:	f002 fb42 	bl	1ea00 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   1c37c:	2200      	movs	r2, #0
   1c37e:	2300      	movs	r3, #0
   1c380:	f012 fd94 	bl	2eeac <net_buf_alloc_fixed>
		if (!frag) {
   1c384:	4681      	mov	r9, r0
   1c386:	2800      	cmp	r0, #0
   1c388:	d088      	beq.n	1c29c <find_type_cb+0x30>
		net_buf_frag_add(data->buf, frag);
   1c38a:	4601      	mov	r1, r0
   1c38c:	6860      	ldr	r0, [r4, #4]
   1c38e:	f002 fe59 	bl	1f044 <net_buf_frag_add>
   1c392:	e7cd      	b.n	1c330 <find_type_cb+0xc4>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
   1c394:	7c22      	ldrb	r2, [r4, #16]
   1c396:	2157      	movs	r1, #87	; 0x57
   1c398:	480f      	ldr	r0, [pc, #60]	; (1c3d8 <find_type_cb+0x16c>)
   1c39a:	f010 f8d7 	bl	2c54c <z_log_minimal_printk>
			goto skip;
   1c39e:	e77a      	b.n	1c296 <find_type_cb+0x2a>
			BT_WARN("Unable to create UUID: size %d", read);
   1c3a0:	462a      	mov	r2, r5
   1c3a2:	2157      	movs	r1, #87	; 0x57
   1c3a4:	480d      	ldr	r0, [pc, #52]	; (1c3dc <find_type_cb+0x170>)
   1c3a6:	f010 f8d1 	bl	2c54c <z_log_minimal_printk>
			goto skip;
   1c3aa:	e774      	b.n	1c296 <find_type_cb+0x2a>
	} else if (memcmp(data->value, uuid, read)) {
   1c3ac:	462a      	mov	r2, r5
   1c3ae:	a90c      	add	r1, sp, #48	; 0x30
   1c3b0:	68e0      	ldr	r0, [r4, #12]
   1c3b2:	f014 fd48 	bl	30e46 <memcmp>
   1c3b6:	2800      	cmp	r0, #0
   1c3b8:	f47f af6d 	bne.w	1c296 <find_type_cb+0x2a>
	data->err = 0x00;
   1c3bc:	2300      	movs	r3, #0
   1c3be:	7463      	strb	r3, [r4, #17]
	return net_buf_simple_add(&buf->b, len);
   1c3c0:	2104      	movs	r1, #4
   1c3c2:	f109 0008 	add.w	r0, r9, #8
   1c3c6:	f002 febd 	bl	1f144 <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
   1c3ca:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
   1c3cc:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
   1c3ce:	68a3      	ldr	r3, [r4, #8]
   1c3d0:	805e      	strh	r6, [r3, #2]
	return BT_GATT_ITER_CONTINUE;
   1c3d2:	2001      	movs	r0, #1
   1c3d4:	e762      	b.n	1c29c <find_type_cb+0x30>
   1c3d6:	bf00      	nop
   1c3d8:	0003a6c4 	.word	0x0003a6c4
   1c3dc:	0003a6e8 	.word	0x0003a6e8

0001c3e0 <bt_att_connected>:
{
   1c3e0:	b510      	push	{r4, lr}
   1c3e2:	4604      	mov	r4, r0
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
   1c3e4:	3804      	subs	r0, #4
	atomic_set_bit(att_chan->flags, ATT_CONNECTED);
   1c3e6:	f104 0394 	add.w	r3, r4, #148	; 0x94
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c3ea:	f3bf 8f5b 	dmb	ish
   1c3ee:	e853 2f00 	ldrex	r2, [r3]
   1c3f2:	f042 0204 	orr.w	r2, r2, #4
   1c3f6:	e843 2100 	strex	r1, r2, [r3]
   1c3fa:	2900      	cmp	r1, #0
   1c3fc:	d1f7      	bne.n	1c3ee <bt_att_connected+0xe>
   1c3fe:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c402:	f3bf 8f5b 	dmb	ish
   1c406:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   1c40a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(att_chan->flags, ATT_ENHANCED)) {
   1c40e:	f013 0f08 	tst.w	r3, #8
   1c412:	d102      	bne.n	1c41a <bt_att_connected+0x3a>
		le_chan->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
   1c414:	2317      	movs	r3, #23
   1c416:	84e3      	strh	r3, [r4, #38]	; 0x26
		le_chan->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
   1c418:	82e3      	strh	r3, [r4, #22]
	att_chan_mtu_updated(att_chan);
   1c41a:	f011 f940 	bl	2d69e <att_chan_mtu_updated>
	k_work_init_delayable(&att_chan->timeout_work, att_timeout);
   1c41e:	4904      	ldr	r1, [pc, #16]	; (1c430 <bt_att_connected+0x50>)
   1c420:	f104 00bc 	add.w	r0, r4, #188	; 0xbc
   1c424:	f00b f9ba 	bl	2779c <k_work_init_delayable>
	bt_gatt_connected(le_chan->chan.conn);
   1c428:	6820      	ldr	r0, [r4, #0]
   1c42a:	f002 fa6d 	bl	1e908 <bt_gatt_connected>
}
   1c42e:	bd10      	pop	{r4, pc}
   1c430:	0001d3e1 	.word	0x0001d3e1

0001c434 <att_get>:
{
   1c434:	b538      	push	{r3, r4, r5, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   1c436:	7a83      	ldrb	r3, [r0, #10]
   1c438:	2b07      	cmp	r3, #7
   1c43a:	d111      	bne.n	1c460 <att_get+0x2c>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   1c43c:	2104      	movs	r1, #4
   1c43e:	f010 ffed 	bl	2d41c <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   1c442:	4604      	mov	r4, r0
   1c444:	b190      	cbz	r0, 1c46c <att_get+0x38>
   1c446:	f3bf 8f5b 	dmb	ish
   1c44a:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   1c44e:	f3bf 8f5b 	dmb	ish
	__ASSERT(atomic_test_bit(att_chan->flags, ATT_CONNECTED),
   1c452:	f013 0f04 	tst.w	r3, #4
   1c456:	d00e      	beq.n	1c476 <att_get+0x42>
	return att_chan->att;
   1c458:	f854 4c04 	ldr.w	r4, [r4, #-4]
}
   1c45c:	4620      	mov	r0, r4
   1c45e:	bd38      	pop	{r3, r4, r5, pc}
		BT_WARN("Not connected");
   1c460:	2157      	movs	r1, #87	; 0x57
   1c462:	480b      	ldr	r0, [pc, #44]	; (1c490 <att_get+0x5c>)
   1c464:	f010 f872 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1c468:	2400      	movs	r4, #0
   1c46a:	e7f7      	b.n	1c45c <att_get+0x28>
		BT_ERR("Unable to find ATT channel");
   1c46c:	2145      	movs	r1, #69	; 0x45
   1c46e:	4809      	ldr	r0, [pc, #36]	; (1c494 <att_get+0x60>)
   1c470:	f010 f86c 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1c474:	e7f2      	b.n	1c45c <att_get+0x28>
	__ASSERT(atomic_test_bit(att_chan->flags, ATT_CONNECTED),
   1c476:	4d08      	ldr	r5, [pc, #32]	; (1c498 <att_get+0x64>)
   1c478:	f640 322d 	movw	r2, #2861	; 0xb2d
   1c47c:	4629      	mov	r1, r5
   1c47e:	4807      	ldr	r0, [pc, #28]	; (1c49c <att_get+0x68>)
   1c480:	f010 f855 	bl	2c52e <assert_print>
   1c484:	f640 312d 	movw	r1, #2861	; 0xb2d
   1c488:	4628      	mov	r0, r5
   1c48a:	f010 f849 	bl	2c520 <assert_post_action>
   1c48e:	e7e3      	b.n	1c458 <att_get+0x24>
   1c490:	0003a70c 	.word	0x0003a70c
   1c494:	0003a720 	.word	0x0003a720
   1c498:	0003a610 	.word	0x0003a610
   1c49c:	00031600 	.word	0x00031600

0001c4a0 <chan_unknown>:
{
   1c4a0:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(data);
   1c4a2:	460c      	mov	r4, r1
   1c4a4:	b151      	cbz	r1, 1c4bc <chan_unknown+0x1c>
   1c4a6:	2300      	movs	r3, #0
   1c4a8:	6023      	str	r3, [r4, #0]
   1c4aa:	6063      	str	r3, [r4, #4]
   1c4ac:	60a3      	str	r3, [r4, #8]
   1c4ae:	60e3      	str	r3, [r4, #12]
   1c4b0:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1c4b2:	4621      	mov	r1, r4
   1c4b4:	4807      	ldr	r0, [pc, #28]	; (1c4d4 <chan_unknown+0x34>)
   1c4b6:	f014 fa9f 	bl	309f8 <k_queue_append>
}
   1c4ba:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(data);
   1c4bc:	4d06      	ldr	r5, [pc, #24]	; (1c4d8 <chan_unknown+0x38>)
   1c4be:	22a4      	movs	r2, #164	; 0xa4
   1c4c0:	4629      	mov	r1, r5
   1c4c2:	4806      	ldr	r0, [pc, #24]	; (1c4dc <chan_unknown+0x3c>)
   1c4c4:	f010 f833 	bl	2c52e <assert_print>
   1c4c8:	21a4      	movs	r1, #164	; 0xa4
   1c4ca:	4628      	mov	r0, r5
   1c4cc:	f010 f828 	bl	2c520 <assert_post_action>
   1c4d0:	e7e9      	b.n	1c4a6 <chan_unknown+0x6>
   1c4d2:	bf00      	nop
   1c4d4:	20000ecc 	.word	0x20000ecc
   1c4d8:	0003a610 	.word	0x0003a610
   1c4dc:	00031600 	.word	0x00031600

0001c4e0 <chan_cfm_sent>:
{
   1c4e0:	b538      	push	{r3, r4, r5, lr}
   1c4e2:	460c      	mov	r4, r1
	struct bt_att_chan *chan = data->att_chan;
   1c4e4:	680b      	ldr	r3, [r1, #0]
		atomic_clear_bit(chan->flags, ATT_PENDING_CFM);
   1c4e6:	3398      	adds	r3, #152	; 0x98
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1c4e8:	f3bf 8f5b 	dmb	ish
   1c4ec:	e853 2f00 	ldrex	r2, [r3]
   1c4f0:	f022 0202 	bic.w	r2, r2, #2
   1c4f4:	e843 2100 	strex	r1, r2, [r3]
   1c4f8:	2900      	cmp	r1, #0
   1c4fa:	d1f7      	bne.n	1c4ec <chan_cfm_sent+0xc>
   1c4fc:	f3bf 8f5b 	dmb	ish
	__ASSERT_NO_MSG(data);
   1c500:	b154      	cbz	r4, 1c518 <chan_cfm_sent+0x38>
   1c502:	2300      	movs	r3, #0
   1c504:	6023      	str	r3, [r4, #0]
   1c506:	6063      	str	r3, [r4, #4]
   1c508:	60a3      	str	r3, [r4, #8]
   1c50a:	60e3      	str	r3, [r4, #12]
   1c50c:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1c50e:	4621      	mov	r1, r4
   1c510:	4807      	ldr	r0, [pc, #28]	; (1c530 <chan_cfm_sent+0x50>)
   1c512:	f014 fa71 	bl	309f8 <k_queue_append>
}
   1c516:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(data);
   1c518:	4d06      	ldr	r5, [pc, #24]	; (1c534 <chan_cfm_sent+0x54>)
   1c51a:	22a4      	movs	r2, #164	; 0xa4
   1c51c:	4629      	mov	r1, r5
   1c51e:	4806      	ldr	r0, [pc, #24]	; (1c538 <chan_cfm_sent+0x58>)
   1c520:	f010 f805 	bl	2c52e <assert_print>
   1c524:	21a4      	movs	r1, #164	; 0xa4
   1c526:	4628      	mov	r0, r5
   1c528:	f00f fffa 	bl	2c520 <assert_post_action>
   1c52c:	e7e9      	b.n	1c502 <chan_cfm_sent+0x22>
   1c52e:	bf00      	nop
   1c530:	20000ecc 	.word	0x20000ecc
   1c534:	0003a610 	.word	0x0003a610
   1c538:	00031600 	.word	0x00031600

0001c53c <chan_rsp_sent>:
{
   1c53c:	b538      	push	{r3, r4, r5, lr}
   1c53e:	460c      	mov	r4, r1
	struct bt_att_chan *chan = data->att_chan;
   1c540:	680b      	ldr	r3, [r1, #0]
		atomic_clear_bit(chan->flags, ATT_PENDING_RSP);
   1c542:	3398      	adds	r3, #152	; 0x98
   1c544:	f3bf 8f5b 	dmb	ish
   1c548:	e853 2f00 	ldrex	r2, [r3]
   1c54c:	f022 0201 	bic.w	r2, r2, #1
   1c550:	e843 2100 	strex	r1, r2, [r3]
   1c554:	2900      	cmp	r1, #0
   1c556:	d1f7      	bne.n	1c548 <chan_rsp_sent+0xc>
   1c558:	f3bf 8f5b 	dmb	ish
	__ASSERT_NO_MSG(data);
   1c55c:	b154      	cbz	r4, 1c574 <chan_rsp_sent+0x38>
   1c55e:	2300      	movs	r3, #0
   1c560:	6023      	str	r3, [r4, #0]
   1c562:	6063      	str	r3, [r4, #4]
   1c564:	60a3      	str	r3, [r4, #8]
   1c566:	60e3      	str	r3, [r4, #12]
   1c568:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1c56a:	4621      	mov	r1, r4
   1c56c:	4807      	ldr	r0, [pc, #28]	; (1c58c <chan_rsp_sent+0x50>)
   1c56e:	f014 fa43 	bl	309f8 <k_queue_append>
}
   1c572:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(data);
   1c574:	4d06      	ldr	r5, [pc, #24]	; (1c590 <chan_rsp_sent+0x54>)
   1c576:	22a4      	movs	r2, #164	; 0xa4
   1c578:	4629      	mov	r1, r5
   1c57a:	4806      	ldr	r0, [pc, #24]	; (1c594 <chan_rsp_sent+0x58>)
   1c57c:	f00f ffd7 	bl	2c52e <assert_print>
   1c580:	21a4      	movs	r1, #164	; 0xa4
   1c582:	4628      	mov	r0, r5
   1c584:	f00f ffcc 	bl	2c520 <assert_post_action>
   1c588:	e7e9      	b.n	1c55e <chan_rsp_sent+0x22>
   1c58a:	bf00      	nop
   1c58c:	20000ecc 	.word	0x20000ecc
   1c590:	0003a610 	.word	0x0003a610
   1c594:	00031600 	.word	0x00031600

0001c598 <chan_req_sent>:
{
   1c598:	b538      	push	{r3, r4, r5, lr}
   1c59a:	460c      	mov	r4, r1
	struct bt_att_chan *chan = data->att_chan;
   1c59c:	6808      	ldr	r0, [r1, #0]
	if (chan->req) {
   1c59e:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
   1c5a2:	b12b      	cbz	r3, 1c5b0 <chan_req_sent+0x18>
		k_work_reschedule(&chan->timeout_work, BT_ATT_TIMEOUT);
   1c5a4:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   1c5a8:	2300      	movs	r3, #0
   1c5aa:	30c0      	adds	r0, #192	; 0xc0
   1c5ac:	f00b fa26 	bl	279fc <k_work_reschedule>
	__ASSERT_NO_MSG(data);
   1c5b0:	b154      	cbz	r4, 1c5c8 <chan_req_sent+0x30>
   1c5b2:	2300      	movs	r3, #0
   1c5b4:	6023      	str	r3, [r4, #0]
   1c5b6:	6063      	str	r3, [r4, #4]
   1c5b8:	60a3      	str	r3, [r4, #8]
   1c5ba:	60e3      	str	r3, [r4, #12]
   1c5bc:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1c5be:	4621      	mov	r1, r4
   1c5c0:	4807      	ldr	r0, [pc, #28]	; (1c5e0 <chan_req_sent+0x48>)
   1c5c2:	f014 fa19 	bl	309f8 <k_queue_append>
}
   1c5c6:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(data);
   1c5c8:	4d06      	ldr	r5, [pc, #24]	; (1c5e4 <chan_req_sent+0x4c>)
   1c5ca:	22a4      	movs	r2, #164	; 0xa4
   1c5cc:	4629      	mov	r1, r5
   1c5ce:	4806      	ldr	r0, [pc, #24]	; (1c5e8 <chan_req_sent+0x50>)
   1c5d0:	f00f ffad 	bl	2c52e <assert_print>
   1c5d4:	21a4      	movs	r1, #164	; 0xa4
   1c5d6:	4628      	mov	r0, r5
   1c5d8:	f00f ffa2 	bl	2c520 <assert_post_action>
   1c5dc:	e7e9      	b.n	1c5b2 <chan_req_sent+0x1a>
   1c5de:	bf00      	nop
   1c5e0:	20000ecc 	.word	0x20000ecc
   1c5e4:	0003a610 	.word	0x0003a610
   1c5e8:	00031600 	.word	0x00031600

0001c5ec <chan_tx_complete>:
{
   1c5ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c5f0:	4605      	mov	r5, r0
   1c5f2:	460c      	mov	r4, r1
   1c5f4:	4691      	mov	r9, r2
	bt_gatt_complete_func_t func = data->func;
   1c5f6:	688e      	ldr	r6, [r1, #8]
	uint16_t attr_count = data->attr_count;
   1c5f8:	888f      	ldrh	r7, [r1, #4]
	void *ud = data->user_data;
   1c5fa:	f8d1 800c 	ldr.w	r8, [r1, #12]
	__ASSERT_NO_MSG(data);
   1c5fe:	b179      	cbz	r1, 1c620 <chan_tx_complete+0x34>
   1c600:	2300      	movs	r3, #0
   1c602:	6023      	str	r3, [r4, #0]
   1c604:	6063      	str	r3, [r4, #4]
   1c606:	60a3      	str	r3, [r4, #8]
   1c608:	60e3      	str	r3, [r4, #12]
   1c60a:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1c60c:	4621      	mov	r1, r4
   1c60e:	480f      	ldr	r0, [pc, #60]	; (1c64c <chan_tx_complete+0x60>)
   1c610:	f014 f9f2 	bl	309f8 <k_queue_append>
	if (!err && func) {
   1c614:	f1b9 0f00 	cmp.w	r9, #0
   1c618:	d115      	bne.n	1c646 <chan_tx_complete+0x5a>
   1c61a:	b1a6      	cbz	r6, 1c646 <chan_tx_complete+0x5a>
		for (uint16_t i = 0; i < attr_count; i++) {
   1c61c:	2400      	movs	r4, #0
   1c61e:	e010      	b.n	1c642 <chan_tx_complete+0x56>
	__ASSERT_NO_MSG(data);
   1c620:	f8df a030 	ldr.w	sl, [pc, #48]	; 1c654 <chan_tx_complete+0x68>
   1c624:	22a4      	movs	r2, #164	; 0xa4
   1c626:	4651      	mov	r1, sl
   1c628:	4809      	ldr	r0, [pc, #36]	; (1c650 <chan_tx_complete+0x64>)
   1c62a:	f00f ff80 	bl	2c52e <assert_print>
   1c62e:	21a4      	movs	r1, #164	; 0xa4
   1c630:	4650      	mov	r0, sl
   1c632:	f00f ff75 	bl	2c520 <assert_post_action>
   1c636:	e7e3      	b.n	1c600 <chan_tx_complete+0x14>
			func(conn, ud);
   1c638:	4641      	mov	r1, r8
   1c63a:	4628      	mov	r0, r5
   1c63c:	47b0      	blx	r6
		for (uint16_t i = 0; i < attr_count; i++) {
   1c63e:	3401      	adds	r4, #1
   1c640:	b2a4      	uxth	r4, r4
   1c642:	42a7      	cmp	r7, r4
   1c644:	d8f8      	bhi.n	1c638 <chan_tx_complete+0x4c>
}
   1c646:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c64a:	bf00      	nop
   1c64c:	20000ecc 	.word	0x20000ecc
   1c650:	00031600 	.word	0x00031600
   1c654:	0003a610 	.word	0x0003a610

0001c658 <chan_send>:
{
   1c658:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1c65c:	b085      	sub	sp, #20
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
   1c65e:	694e      	ldr	r6, [r1, #20]
	hdr = (void *)buf->data;
   1c660:	688a      	ldr	r2, [r1, #8]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c662:	f3bf 8f5b 	dmb	ish
   1c666:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
   1c66a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(chan->flags, ATT_CONNECTED)) {
   1c66e:	f013 0f04 	tst.w	r3, #4
   1c672:	d04e      	beq.n	1c712 <chan_send+0xba>
   1c674:	4681      	mov	r9, r0
   1c676:	460c      	mov	r4, r1
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
   1c678:	7813      	ldrb	r3, [r2, #0]
   1c67a:	2bd2      	cmp	r3, #210	; 0xd2
   1c67c:	d023      	beq.n	1c6c6 <chan_send+0x6e>
	state->offset = net_buf_simple_headroom(buf);
   1c67e:	f104 0008 	add.w	r0, r4, #8
   1c682:	f012 fc28 	bl	2eed6 <net_buf_simple_headroom>
   1c686:	b285      	uxth	r5, r0
   1c688:	f8ad 500c 	strh.w	r5, [sp, #12]
	state->len = buf->len;
   1c68c:	89a7      	ldrh	r7, [r4, #12]
   1c68e:	f8ad 700e 	strh.w	r7, [sp, #14]
	data->att_chan = chan;
   1c692:	f8c6 9000 	str.w	r9, [r6]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
   1c696:	f8d9 3000 	ldr.w	r3, [r9]
   1c69a:	f8d3 8000 	ldr.w	r8, [r3]
   1c69e:	4620      	mov	r0, r4
   1c6a0:	f7ff fc66 	bl	1bf70 <att_cb>
   1c6a4:	4603      	mov	r3, r0
   1c6a6:	9600      	str	r6, [sp, #0]
   1c6a8:	4622      	mov	r2, r4
   1c6aa:	2104      	movs	r1, #4
   1c6ac:	4640      	mov	r0, r8
   1c6ae:	f010 fe73 	bl	2d398 <bt_l2cap_send_cb>
	if (err) {
   1c6b2:	4680      	mov	r8, r0
   1c6b4:	b118      	cbz	r0, 1c6be <chan_send+0x66>
	buf->data = buf->__buf + state->offset;
   1c6b6:	6920      	ldr	r0, [r4, #16]
   1c6b8:	4428      	add	r0, r5
   1c6ba:	60a0      	str	r0, [r4, #8]
	buf->len = state->len;
   1c6bc:	81a7      	strh	r7, [r4, #12]
}
   1c6be:	4640      	mov	r0, r8
   1c6c0:	b005      	add	sp, #20
   1c6c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = bt_smp_sign(chan->att->conn, buf);
   1c6c6:	6803      	ldr	r3, [r0, #0]
   1c6c8:	6818      	ldr	r0, [r3, #0]
   1c6ca:	f012 fb9f 	bl	2ee0c <bt_smp_sign>
		if (err) {
   1c6ce:	4680      	mov	r8, r0
   1c6d0:	2800      	cmp	r0, #0
   1c6d2:	d0d4      	beq.n	1c67e <chan_send+0x26>
			BT_ERR("Error signing data");
   1c6d4:	2145      	movs	r1, #69	; 0x45
   1c6d6:	4810      	ldr	r0, [pc, #64]	; (1c718 <chan_send+0xc0>)
   1c6d8:	f00f ff38 	bl	2c54c <z_log_minimal_printk>
			tx_meta_data_free(bt_att_tx_meta_data(buf));
   1c6dc:	6965      	ldr	r5, [r4, #20]
	__ASSERT_NO_MSG(data);
   1c6de:	b16d      	cbz	r5, 1c6fc <chan_send+0xa4>
   1c6e0:	2300      	movs	r3, #0
   1c6e2:	602b      	str	r3, [r5, #0]
   1c6e4:	606b      	str	r3, [r5, #4]
   1c6e6:	60ab      	str	r3, [r5, #8]
   1c6e8:	60eb      	str	r3, [r5, #12]
   1c6ea:	612b      	str	r3, [r5, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1c6ec:	4629      	mov	r1, r5
   1c6ee:	480b      	ldr	r0, [pc, #44]	; (1c71c <chan_send+0xc4>)
   1c6f0:	f014 f982 	bl	309f8 <k_queue_append>
			net_buf_unref(buf);
   1c6f4:	4620      	mov	r0, r4
   1c6f6:	f002 fc0d 	bl	1ef14 <net_buf_unref>
			return err;
   1c6fa:	e7e0      	b.n	1c6be <chan_send+0x66>
	__ASSERT_NO_MSG(data);
   1c6fc:	4e08      	ldr	r6, [pc, #32]	; (1c720 <chan_send+0xc8>)
   1c6fe:	22a4      	movs	r2, #164	; 0xa4
   1c700:	4631      	mov	r1, r6
   1c702:	4808      	ldr	r0, [pc, #32]	; (1c724 <chan_send+0xcc>)
   1c704:	f00f ff13 	bl	2c52e <assert_print>
   1c708:	21a4      	movs	r1, #164	; 0xa4
   1c70a:	4630      	mov	r0, r6
   1c70c:	f00f ff08 	bl	2c520 <assert_post_action>
   1c710:	e7e6      	b.n	1c6e0 <chan_send+0x88>
		return -EINVAL;
   1c712:	f06f 0815 	mvn.w	r8, #21
   1c716:	e7d2      	b.n	1c6be <chan_send+0x66>
   1c718:	0003a740 	.word	0x0003a740
   1c71c:	20000ecc 	.word	0x20000ecc
   1c720:	0003a610 	.word	0x0003a610
   1c724:	00031600 	.word	0x00031600

0001c728 <bt_att_chan_req_send>:
{
   1c728:	b570      	push	{r4, r5, r6, lr}
   1c72a:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(chan);
   1c72c:	4605      	mov	r5, r0
   1c72e:	b1b0      	cbz	r0, 1c75e <bt_att_chan_req_send+0x36>
	__ASSERT_NO_MSG(req);
   1c730:	b314      	cbz	r4, 1c778 <bt_att_chan_req_send+0x50>
	__ASSERT_NO_MSG(req->func);
   1c732:	6863      	ldr	r3, [r4, #4]
   1c734:	b36b      	cbz	r3, 1c792 <bt_att_chan_req_send+0x6a>
	__ASSERT_NO_MSG(!chan->req);
   1c736:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
   1c73a:	b15b      	cbz	r3, 1c754 <bt_att_chan_req_send+0x2c>
   1c73c:	4e1b      	ldr	r6, [pc, #108]	; (1c7ac <bt_att_chan_req_send+0x84>)
   1c73e:	f240 321a 	movw	r2, #794	; 0x31a
   1c742:	4631      	mov	r1, r6
   1c744:	481a      	ldr	r0, [pc, #104]	; (1c7b0 <bt_att_chan_req_send+0x88>)
   1c746:	f00f fef2 	bl	2c52e <assert_print>
   1c74a:	f240 311a 	movw	r1, #794	; 0x31a
   1c74e:	4630      	mov	r0, r6
   1c750:	f00f fee6 	bl	2c520 <assert_post_action>
	return chan_req_send(chan, req);
   1c754:	4621      	mov	r1, r4
   1c756:	4628      	mov	r0, r5
   1c758:	f011 f97b 	bl	2da52 <chan_req_send>
}
   1c75c:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(chan);
   1c75e:	4e13      	ldr	r6, [pc, #76]	; (1c7ac <bt_att_chan_req_send+0x84>)
   1c760:	f240 3217 	movw	r2, #791	; 0x317
   1c764:	4631      	mov	r1, r6
   1c766:	4812      	ldr	r0, [pc, #72]	; (1c7b0 <bt_att_chan_req_send+0x88>)
   1c768:	f00f fee1 	bl	2c52e <assert_print>
   1c76c:	f240 3117 	movw	r1, #791	; 0x317
   1c770:	4630      	mov	r0, r6
   1c772:	f00f fed5 	bl	2c520 <assert_post_action>
   1c776:	e7db      	b.n	1c730 <bt_att_chan_req_send+0x8>
	__ASSERT_NO_MSG(req);
   1c778:	4e0c      	ldr	r6, [pc, #48]	; (1c7ac <bt_att_chan_req_send+0x84>)
   1c77a:	f44f 7246 	mov.w	r2, #792	; 0x318
   1c77e:	4631      	mov	r1, r6
   1c780:	480b      	ldr	r0, [pc, #44]	; (1c7b0 <bt_att_chan_req_send+0x88>)
   1c782:	f00f fed4 	bl	2c52e <assert_print>
   1c786:	f44f 7146 	mov.w	r1, #792	; 0x318
   1c78a:	4630      	mov	r0, r6
   1c78c:	f00f fec8 	bl	2c520 <assert_post_action>
   1c790:	e7cf      	b.n	1c732 <bt_att_chan_req_send+0xa>
	__ASSERT_NO_MSG(req->func);
   1c792:	4e06      	ldr	r6, [pc, #24]	; (1c7ac <bt_att_chan_req_send+0x84>)
   1c794:	f240 3219 	movw	r2, #793	; 0x319
   1c798:	4631      	mov	r1, r6
   1c79a:	4805      	ldr	r0, [pc, #20]	; (1c7b0 <bt_att_chan_req_send+0x88>)
   1c79c:	f00f fec7 	bl	2c52e <assert_print>
   1c7a0:	f240 3119 	movw	r1, #793	; 0x319
   1c7a4:	4630      	mov	r0, r6
   1c7a6:	f00f febb 	bl	2c520 <assert_post_action>
   1c7aa:	e7c4      	b.n	1c736 <bt_att_chan_req_send+0xe>
   1c7ac:	0003a610 	.word	0x0003a610
   1c7b0:	00031600 	.word	0x00031600

0001c7b4 <bt_att_chan_create_pdu>:
{
   1c7b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (len + sizeof(op) > chan->chan.tx.mtu) {
   1c7b6:	1c53      	adds	r3, r2, #1
   1c7b8:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
   1c7ba:	4293      	cmp	r3, r2
   1c7bc:	d80c      	bhi.n	1c7d8 <bt_att_chan_create_pdu+0x24>
   1c7be:	460c      	mov	r4, r1
	switch (att_op_get_type(op)) {
   1c7c0:	4608      	mov	r0, r1
   1c7c2:	f010 feb8 	bl	2d536 <att_op_get_type>
   1c7c6:	2802      	cmp	r0, #2
   1c7c8:	d00c      	beq.n	1c7e4 <bt_att_chan_create_pdu+0x30>
   1c7ca:	2804      	cmp	r0, #4
   1c7cc:	d00a      	beq.n	1c7e4 <bt_att_chan_create_pdu+0x30>
		timeout = K_FOREVER;
   1c7ce:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   1c7d2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   1c7d6:	e008      	b.n	1c7ea <bt_att_chan_create_pdu+0x36>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
   1c7d8:	2157      	movs	r1, #87	; 0x57
   1c7da:	4817      	ldr	r0, [pc, #92]	; (1c838 <bt_att_chan_create_pdu+0x84>)
   1c7dc:	f00f feb6 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1c7e0:	2500      	movs	r5, #0
   1c7e2:	e017      	b.n	1c814 <bt_att_chan_create_pdu+0x60>
		timeout = BT_ATT_TIMEOUT;
   1c7e4:	f44f 2670 	mov.w	r6, #983040	; 0xf0000
   1c7e8:	2700      	movs	r7, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
   1c7ea:	4632      	mov	r2, r6
   1c7ec:	463b      	mov	r3, r7
   1c7ee:	2100      	movs	r1, #0
   1c7f0:	4608      	mov	r0, r1
   1c7f2:	f010 fdcc 	bl	2d38e <bt_l2cap_create_pdu_timeout>
	if (!buf) {
   1c7f6:	4605      	mov	r5, r0
   1c7f8:	b170      	cbz	r0, 1c818 <bt_att_chan_create_pdu+0x64>
	data = tx_meta_data_alloc(timeout);
   1c7fa:	4630      	mov	r0, r6
   1c7fc:	4639      	mov	r1, r7
   1c7fe:	f7ff fbad 	bl	1bf5c <tx_meta_data_alloc>
	if (!data) {
   1c802:	4606      	mov	r6, r0
   1c804:	b170      	cbz	r0, 1c824 <bt_att_chan_create_pdu+0x70>
	bt_att_tx_meta_data(buf) = data;
   1c806:	6168      	str	r0, [r5, #20]
	return net_buf_simple_add(&buf->b, len);
   1c808:	2101      	movs	r1, #1
   1c80a:	f105 0008 	add.w	r0, r5, #8
   1c80e:	f002 fc99 	bl	1f144 <net_buf_simple_add>
	hdr->code = op;
   1c812:	7004      	strb	r4, [r0, #0]
}
   1c814:	4628      	mov	r0, r5
   1c816:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
   1c818:	4622      	mov	r2, r4
   1c81a:	2145      	movs	r1, #69	; 0x45
   1c81c:	4807      	ldr	r0, [pc, #28]	; (1c83c <bt_att_chan_create_pdu+0x88>)
   1c81e:	f00f fe95 	bl	2c54c <z_log_minimal_printk>
		return NULL;
   1c822:	e7f7      	b.n	1c814 <bt_att_chan_create_pdu+0x60>
		BT_WARN("Unable to allocate ATT TX meta");
   1c824:	2157      	movs	r1, #87	; 0x57
   1c826:	4806      	ldr	r0, [pc, #24]	; (1c840 <bt_att_chan_create_pdu+0x8c>)
   1c828:	f00f fe90 	bl	2c54c <z_log_minimal_printk>
		net_buf_unref(buf);
   1c82c:	4628      	mov	r0, r5
   1c82e:	f002 fb71 	bl	1ef14 <net_buf_unref>
		return NULL;
   1c832:	4635      	mov	r5, r6
   1c834:	e7ee      	b.n	1c814 <bt_att_chan_create_pdu+0x60>
   1c836:	bf00      	nop
   1c838:	0003a758 	.word	0x0003a758
   1c83c:	0003a4c0 	.word	0x0003a4c0
   1c840:	0003a784 	.word	0x0003a784

0001c844 <bt_att_recv>:
{
   1c844:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buf->len < sizeof(*hdr)) {
   1c848:	898b      	ldrh	r3, [r1, #12]
   1c84a:	b16b      	cbz	r3, 1c868 <bt_att_recv+0x24>
   1c84c:	4606      	mov	r6, r0
   1c84e:	460d      	mov	r5, r1
   1c850:	1f07      	subs	r7, r0, #4
	return net_buf_simple_pull_mem(&buf->b, len);
   1c852:	2101      	movs	r1, #1
   1c854:	f105 0008 	add.w	r0, r5, #8
   1c858:	f002 fc34 	bl	1f0c4 <net_buf_simple_pull_mem>
   1c85c:	4604      	mov	r4, r0
	if (!att_chan->att) {
   1c85e:	f856 3c04 	ldr.w	r3, [r6, #-4]
   1c862:	b12b      	cbz	r3, 1c870 <bt_att_recv+0x2c>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   1c864:	2300      	movs	r3, #0
   1c866:	e007      	b.n	1c878 <bt_att_recv+0x34>
		BT_ERR("Too small ATT PDU received");
   1c868:	2145      	movs	r1, #69	; 0x45
   1c86a:	483f      	ldr	r0, [pc, #252]	; (1c968 <bt_att_recv+0x124>)
   1c86c:	f00f fe6e 	bl	2c54c <z_log_minimal_printk>
}
   1c870:	2000      	movs	r0, #0
   1c872:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   1c876:	3301      	adds	r3, #1
   1c878:	2b1d      	cmp	r3, #29
   1c87a:	d82b      	bhi.n	1c8d4 <bt_att_recv+0x90>
		if (hdr->code == handlers[i].op) {
   1c87c:	f894 c000 	ldrb.w	ip, [r4]
   1c880:	4a3a      	ldr	r2, [pc, #232]	; (1c96c <bt_att_recv+0x128>)
   1c882:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
   1c886:	4594      	cmp	ip, r2
   1c888:	d1f5      	bne.n	1c876 <bt_att_recv+0x32>
			handler = &handlers[i];
   1c88a:	4a38      	ldr	r2, [pc, #224]	; (1c96c <bt_att_recv+0x128>)
   1c88c:	eb02 08c3 	add.w	r8, r2, r3, lsl #3
	if (!handler) {
   1c890:	f1b8 0f00 	cmp.w	r8, #0
   1c894:	d021      	beq.n	1c8da <bt_att_recv+0x96>
		if (handler->type == ATT_REQUEST &&
   1c896:	f898 3002 	ldrb.w	r3, [r8, #2]
   1c89a:	2b01      	cmp	r3, #1
   1c89c:	d031      	beq.n	1c902 <bt_att_recv+0xbe>
		} else if (handler->type == ATT_INDICATION &&
   1c89e:	f898 3002 	ldrb.w	r3, [r8, #2]
   1c8a2:	2b05      	cmp	r3, #5
   1c8a4:	d043      	beq.n	1c92e <bt_att_recv+0xea>
	if (buf->len < handler->expect_len) {
   1c8a6:	89aa      	ldrh	r2, [r5, #12]
   1c8a8:	f898 3001 	ldrb.w	r3, [r8, #1]
   1c8ac:	429a      	cmp	r2, r3
   1c8ae:	d353      	bcc.n	1c958 <bt_att_recv+0x114>
		err = handler->func(att_chan, buf);
   1c8b0:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1c8b4:	4629      	mov	r1, r5
   1c8b6:	4638      	mov	r0, r7
   1c8b8:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
   1c8ba:	f898 3002 	ldrb.w	r3, [r8, #2]
   1c8be:	2b01      	cmp	r3, #1
   1c8c0:	d1d6      	bne.n	1c870 <bt_att_recv+0x2c>
   1c8c2:	2800      	cmp	r0, #0
   1c8c4:	d0d4      	beq.n	1c870 <bt_att_recv+0x2c>
		send_err_rsp(att_chan, hdr->code, 0, err);
   1c8c6:	4603      	mov	r3, r0
   1c8c8:	2200      	movs	r2, #0
   1c8ca:	7821      	ldrb	r1, [r4, #0]
   1c8cc:	4638      	mov	r0, r7
   1c8ce:	f011 fa6e 	bl	2ddae <send_err_rsp>
   1c8d2:	e7cd      	b.n	1c870 <bt_att_recv+0x2c>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   1c8d4:	f04f 0800 	mov.w	r8, #0
   1c8d8:	e7da      	b.n	1c890 <bt_att_recv+0x4c>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
   1c8da:	7822      	ldrb	r2, [r4, #0]
   1c8dc:	2157      	movs	r1, #87	; 0x57
   1c8de:	4824      	ldr	r0, [pc, #144]	; (1c970 <bt_att_recv+0x12c>)
   1c8e0:	f00f fe34 	bl	2c54c <z_log_minimal_printk>
		if (att_op_get_type(hdr->code) != ATT_COMMAND &&
   1c8e4:	7824      	ldrb	r4, [r4, #0]
   1c8e6:	4620      	mov	r0, r4
   1c8e8:	f010 fe25 	bl	2d536 <att_op_get_type>
   1c8ec:	2800      	cmp	r0, #0
   1c8ee:	d0bf      	beq.n	1c870 <bt_att_recv+0x2c>
   1c8f0:	2805      	cmp	r0, #5
   1c8f2:	d0bd      	beq.n	1c870 <bt_att_recv+0x2c>
			send_err_rsp(att_chan, hdr->code, 0,
   1c8f4:	2306      	movs	r3, #6
   1c8f6:	2200      	movs	r2, #0
   1c8f8:	4621      	mov	r1, r4
   1c8fa:	4638      	mov	r0, r7
   1c8fc:	f011 fa57 	bl	2ddae <send_err_rsp>
		return 0;
   1c900:	e7b6      	b.n	1c870 <bt_att_recv+0x2c>
		    atomic_test_and_set_bit(att_chan->flags, ATT_PENDING_RSP)) {
   1c902:	f106 0394 	add.w	r3, r6, #148	; 0x94
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c906:	f3bf 8f5b 	dmb	ish
   1c90a:	e853 2f00 	ldrex	r2, [r3]
   1c90e:	f042 0101 	orr.w	r1, r2, #1
   1c912:	e843 1000 	strex	r0, r1, [r3]
   1c916:	2800      	cmp	r0, #0
   1c918:	d1f7      	bne.n	1c90a <bt_att_recv+0xc6>
   1c91a:	f3bf 8f5b 	dmb	ish
		if (handler->type == ATT_REQUEST &&
   1c91e:	f012 0f01 	tst.w	r2, #1
   1c922:	d0bc      	beq.n	1c89e <bt_att_recv+0x5a>
			BT_WARN("Ignoring unexpected request");
   1c924:	2157      	movs	r1, #87	; 0x57
   1c926:	4813      	ldr	r0, [pc, #76]	; (1c974 <bt_att_recv+0x130>)
   1c928:	f00f fe10 	bl	2c54c <z_log_minimal_printk>
			return 0;
   1c92c:	e7a0      	b.n	1c870 <bt_att_recv+0x2c>
			   atomic_test_and_set_bit(att_chan->flags,
   1c92e:	3694      	adds	r6, #148	; 0x94
   1c930:	f3bf 8f5b 	dmb	ish
   1c934:	e856 3f00 	ldrex	r3, [r6]
   1c938:	f043 0202 	orr.w	r2, r3, #2
   1c93c:	e846 2100 	strex	r1, r2, [r6]
   1c940:	2900      	cmp	r1, #0
   1c942:	d1f7      	bne.n	1c934 <bt_att_recv+0xf0>
   1c944:	f3bf 8f5b 	dmb	ish
		} else if (handler->type == ATT_INDICATION &&
   1c948:	f013 0f02 	tst.w	r3, #2
   1c94c:	d0ab      	beq.n	1c8a6 <bt_att_recv+0x62>
			BT_WARN("Ignoring unexpected indication");
   1c94e:	2157      	movs	r1, #87	; 0x57
   1c950:	4809      	ldr	r0, [pc, #36]	; (1c978 <bt_att_recv+0x134>)
   1c952:	f00f fdfb 	bl	2c54c <z_log_minimal_printk>
			return 0;
   1c956:	e78b      	b.n	1c870 <bt_att_recv+0x2c>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
   1c958:	7823      	ldrb	r3, [r4, #0]
   1c95a:	2145      	movs	r1, #69	; 0x45
   1c95c:	4807      	ldr	r0, [pc, #28]	; (1c97c <bt_att_recv+0x138>)
   1c95e:	f00f fdf5 	bl	2c54c <z_log_minimal_printk>
		err = BT_ATT_ERR_INVALID_PDU;
   1c962:	2004      	movs	r0, #4
   1c964:	e7a9      	b.n	1c8ba <bt_att_recv+0x76>
   1c966:	bf00      	nop
   1c968:	0003a7a8 	.word	0x0003a7a8
   1c96c:	0003a8ac 	.word	0x0003a8ac
   1c970:	0003a7c8 	.word	0x0003a7c8
   1c974:	0003a7e8 	.word	0x0003a7e8
   1c978:	0003a80c 	.word	0x0003a80c
   1c97c:	0003a830 	.word	0x0003a830

0001c980 <att_write_rsp>:
{
   1c980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c984:	b08a      	sub	sp, #40	; 0x28
   1c986:	4604      	mov	r4, r0
   1c988:	4616      	mov	r6, r2
   1c98a:	461d      	mov	r5, r3
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
   1c98c:	6803      	ldr	r3, [r0, #0]
   1c98e:	4688      	mov	r8, r1
   1c990:	3900      	subs	r1, #0
   1c992:	bf18      	it	ne
   1c994:	2101      	movne	r1, #1
   1c996:	6818      	ldr	r0, [r3, #0]
   1c998:	f012 f9aa 	bl	2ecf0 <bt_gatt_change_aware>
   1c99c:	b128      	cbz	r0, 1c9aa <att_write_rsp+0x2a>
	if (!handle) {
   1c99e:	b9c5      	cbnz	r5, 1c9d2 <att_write_rsp+0x52>
		return BT_ATT_ERR_INVALID_HANDLE;
   1c9a0:	2701      	movs	r7, #1
}
   1c9a2:	4638      	mov	r0, r7
   1c9a4:	b00a      	add	sp, #40	; 0x28
   1c9a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   1c9aa:	3498      	adds	r4, #152	; 0x98
   1c9ac:	f3bf 8f5b 	dmb	ish
   1c9b0:	e854 3f00 	ldrex	r3, [r4]
   1c9b4:	f043 0220 	orr.w	r2, r3, #32
   1c9b8:	e844 2100 	strex	r1, r2, [r4]
   1c9bc:	2900      	cmp	r1, #0
   1c9be:	d1f7      	bne.n	1c9b0 <att_write_rsp+0x30>
   1c9c0:	f3bf 8f5b 	dmb	ish
   1c9c4:	f013 0f20 	tst.w	r3, #32
   1c9c8:	d001      	beq.n	1c9ce <att_write_rsp+0x4e>
			return 0;
   1c9ca:	2700      	movs	r7, #0
   1c9cc:	e7e9      	b.n	1c9a2 <att_write_rsp+0x22>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   1c9ce:	2712      	movs	r7, #18
   1c9d0:	e7e7      	b.n	1c9a2 <att_write_rsp+0x22>
	(void)memset(&data, 0, sizeof(data));
   1c9d2:	2300      	movs	r3, #0
   1c9d4:	9304      	str	r3, [sp, #16]
   1c9d6:	9305      	str	r3, [sp, #20]
   1c9d8:	9306      	str	r3, [sp, #24]
   1c9da:	9307      	str	r3, [sp, #28]
   1c9dc:	9308      	str	r3, [sp, #32]
   1c9de:	9309      	str	r3, [sp, #36]	; 0x24
	if (rsp) {
   1c9e0:	b13e      	cbz	r6, 1c9f2 <att_write_rsp+0x72>
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
   1c9e2:	461a      	mov	r2, r3
   1c9e4:	4631      	mov	r1, r6
   1c9e6:	4620      	mov	r0, r4
   1c9e8:	f7ff fee4 	bl	1c7b4 <bt_att_chan_create_pdu>
   1c9ec:	9005      	str	r0, [sp, #20]
		if (!data.buf) {
   1c9ee:	2800      	cmp	r0, #0
   1c9f0:	d052      	beq.n	1ca98 <att_write_rsp+0x118>
	data.conn = chan->att->conn;
   1c9f2:	6823      	ldr	r3, [r4, #0]
   1c9f4:	681b      	ldr	r3, [r3, #0]
   1c9f6:	9304      	str	r3, [sp, #16]
	data.req = req;
   1c9f8:	f88d 8018 	strb.w	r8, [sp, #24]
	data.offset = offset;
   1c9fc:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   1ca00:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	data.value = value;
   1ca04:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1ca06:	9307      	str	r3, [sp, #28]
	data.len = len;
   1ca08:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   1ca0c:	f8ad 3020 	strh.w	r3, [sp, #32]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   1ca10:	2301      	movs	r3, #1
   1ca12:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   1ca16:	ab04      	add	r3, sp, #16
   1ca18:	9302      	str	r3, [sp, #8]
   1ca1a:	4b20      	ldr	r3, [pc, #128]	; (1ca9c <att_write_rsp+0x11c>)
   1ca1c:	9301      	str	r3, [sp, #4]
   1ca1e:	2200      	movs	r2, #0
   1ca20:	9200      	str	r2, [sp, #0]
   1ca22:	4613      	mov	r3, r2
   1ca24:	4629      	mov	r1, r5
   1ca26:	4628      	mov	r0, r5
   1ca28:	f001 f8e6 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (data.err) {
   1ca2c:	f89d 7024 	ldrb.w	r7, [sp, #36]	; 0x24
   1ca30:	b937      	cbnz	r7, 1ca40 <att_write_rsp+0xc0>
	if (data.buf) {
   1ca32:	9905      	ldr	r1, [sp, #20]
   1ca34:	2900      	cmp	r1, #0
   1ca36:	d0b4      	beq.n	1c9a2 <att_write_rsp+0x22>
		bt_att_chan_send_rsp(chan, data.buf);
   1ca38:	4620      	mov	r0, r4
   1ca3a:	f011 f943 	bl	2dcc4 <bt_att_chan_send_rsp>
   1ca3e:	e7b0      	b.n	1c9a2 <att_write_rsp+0x22>
		if (rsp) {
   1ca40:	b926      	cbnz	r6, 1ca4c <att_write_rsp+0xcc>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
   1ca42:	f1b8 0f18 	cmp.w	r8, #24
   1ca46:	d024      	beq.n	1ca92 <att_write_rsp+0x112>
   1ca48:	2700      	movs	r7, #0
   1ca4a:	e7aa      	b.n	1c9a2 <att_write_rsp+0x22>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1ca4c:	9b05      	ldr	r3, [sp, #20]
   1ca4e:	695e      	ldr	r6, [r3, #20]
	__ASSERT_NO_MSG(data);
   1ca50:	b1a6      	cbz	r6, 1ca7c <att_write_rsp+0xfc>
   1ca52:	2300      	movs	r3, #0
   1ca54:	6033      	str	r3, [r6, #0]
   1ca56:	6073      	str	r3, [r6, #4]
   1ca58:	60b3      	str	r3, [r6, #8]
   1ca5a:	60f3      	str	r3, [r6, #12]
   1ca5c:	6133      	str	r3, [r6, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1ca5e:	4631      	mov	r1, r6
   1ca60:	480f      	ldr	r0, [pc, #60]	; (1caa0 <att_write_rsp+0x120>)
   1ca62:	f013 ffc9 	bl	309f8 <k_queue_append>
			net_buf_unref(data.buf);
   1ca66:	9805      	ldr	r0, [sp, #20]
   1ca68:	f002 fa54 	bl	1ef14 <net_buf_unref>
			send_err_rsp(chan, req, handle, data.err);
   1ca6c:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   1ca70:	462a      	mov	r2, r5
   1ca72:	4641      	mov	r1, r8
   1ca74:	4620      	mov	r0, r4
   1ca76:	f011 f99a 	bl	2ddae <send_err_rsp>
   1ca7a:	e7e2      	b.n	1ca42 <att_write_rsp+0xc2>
	__ASSERT_NO_MSG(data);
   1ca7c:	4f09      	ldr	r7, [pc, #36]	; (1caa4 <att_write_rsp+0x124>)
   1ca7e:	22a4      	movs	r2, #164	; 0xa4
   1ca80:	4639      	mov	r1, r7
   1ca82:	4809      	ldr	r0, [pc, #36]	; (1caa8 <att_write_rsp+0x128>)
   1ca84:	f00f fd53 	bl	2c52e <assert_print>
   1ca88:	21a4      	movs	r1, #164	; 0xa4
   1ca8a:	4638      	mov	r0, r7
   1ca8c:	f00f fd48 	bl	2c520 <assert_post_action>
   1ca90:	e7df      	b.n	1ca52 <att_write_rsp+0xd2>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
   1ca92:	f89d 7024 	ldrb.w	r7, [sp, #36]	; 0x24
   1ca96:	e784      	b.n	1c9a2 <att_write_rsp+0x22>
			return BT_ATT_ERR_UNLIKELY;
   1ca98:	270e      	movs	r7, #14
   1ca9a:	e782      	b.n	1c9a2 <att_write_rsp+0x22>
   1ca9c:	0002d71b 	.word	0x0002d71b
   1caa0:	20000ecc 	.word	0x20000ecc
   1caa4:	0003a610 	.word	0x0003a610
   1caa8:	00031600 	.word	0x00031600

0001caac <bt_att_create_pdu>:
{
   1caac:	b570      	push	{r4, r5, r6, lr}
   1caae:	460e      	mov	r6, r1
   1cab0:	4615      	mov	r5, r2
	att = att_get(conn);
   1cab2:	f7ff fcbf 	bl	1c434 <att_get>
	if (!att) {
   1cab6:	4604      	mov	r4, r0
   1cab8:	b340      	cbz	r0, 1cb0c <bt_att_create_pdu+0x60>
	return list->head;
   1caba:	6a84      	ldr	r4, [r0, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1cabc:	b14c      	cbz	r4, 1cad2 <bt_att_create_pdu+0x26>
   1cabe:	3cf0      	subs	r4, #240	; 0xf0
   1cac0:	d009      	beq.n	1cad6 <bt_att_create_pdu+0x2a>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1cac2:	f114 00f0 	adds.w	r0, r4, #240	; 0xf0
   1cac6:	d00b      	beq.n	1cae0 <bt_att_create_pdu+0x34>
	return node->next;
   1cac8:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
   1cacc:	b140      	cbz	r0, 1cae0 <bt_att_create_pdu+0x34>
   1cace:	38f0      	subs	r0, #240	; 0xf0
   1cad0:	e006      	b.n	1cae0 <bt_att_create_pdu+0x34>
   1cad2:	4620      	mov	r0, r4
   1cad4:	e004      	b.n	1cae0 <bt_att_create_pdu+0x34>
   1cad6:	4620      	mov	r0, r4
   1cad8:	e002      	b.n	1cae0 <bt_att_create_pdu+0x34>
   1cada:	4603      	mov	r3, r0
   1cadc:	4604      	mov	r4, r0
   1cade:	4618      	mov	r0, r3
   1cae0:	b1b4      	cbz	r4, 1cb10 <bt_att_create_pdu+0x64>
		if (len + sizeof(op) > chan->chan.tx.mtu) {
   1cae2:	1c6b      	adds	r3, r5, #1
   1cae4:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
   1cae6:	4293      	cmp	r3, r2
   1cae8:	d90a      	bls.n	1cb00 <bt_att_create_pdu+0x54>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1caea:	2800      	cmp	r0, #0
   1caec:	d0f5      	beq.n	1cada <bt_att_create_pdu+0x2e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1caee:	f110 03f0 	adds.w	r3, r0, #240	; 0xf0
   1caf2:	d0f3      	beq.n	1cadc <bt_att_create_pdu+0x30>
	return node->next;
   1caf4:	f8d0 30f0 	ldr.w	r3, [r0, #240]	; 0xf0
   1caf8:	2b00      	cmp	r3, #0
   1cafa:	d0ef      	beq.n	1cadc <bt_att_create_pdu+0x30>
   1cafc:	3bf0      	subs	r3, #240	; 0xf0
   1cafe:	e7ed      	b.n	1cadc <bt_att_create_pdu+0x30>
		return bt_att_chan_create_pdu(chan, op, len);
   1cb00:	462a      	mov	r2, r5
   1cb02:	4631      	mov	r1, r6
   1cb04:	4620      	mov	r0, r4
   1cb06:	f7ff fe55 	bl	1c7b4 <bt_att_chan_create_pdu>
   1cb0a:	4604      	mov	r4, r0
}
   1cb0c:	4620      	mov	r0, r4
   1cb0e:	bd70      	pop	{r4, r5, r6, pc}
	BT_WARN("No ATT channel for MTU %zu", len + sizeof(op));
   1cb10:	1c6a      	adds	r2, r5, #1
   1cb12:	2157      	movs	r1, #87	; 0x57
   1cb14:	4801      	ldr	r0, [pc, #4]	; (1cb1c <bt_att_create_pdu+0x70>)
   1cb16:	f00f fd19 	bl	2c54c <z_log_minimal_printk>
	return NULL;
   1cb1a:	e7f7      	b.n	1cb0c <bt_att_create_pdu+0x60>
   1cb1c:	0003a854 	.word	0x0003a854

0001cb20 <att_read_group_rsp>:
{
   1cb20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1cb24:	b08a      	sub	sp, #40	; 0x28
   1cb26:	4605      	mov	r5, r0
   1cb28:	4688      	mov	r8, r1
   1cb2a:	4616      	mov	r6, r2
   1cb2c:	461f      	mov	r7, r3
	(void)memset(&data, 0, sizeof(data));
   1cb2e:	2400      	movs	r4, #0
   1cb30:	9405      	str	r4, [sp, #20]
   1cb32:	9406      	str	r4, [sp, #24]
   1cb34:	9407      	str	r4, [sp, #28]
   1cb36:	9408      	str	r4, [sp, #32]
   1cb38:	9409      	str	r4, [sp, #36]	; 0x24
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
   1cb3a:	2201      	movs	r2, #1
   1cb3c:	2111      	movs	r1, #17
   1cb3e:	6840      	ldr	r0, [r0, #4]
   1cb40:	f7ff ffb4 	bl	1caac <bt_att_create_pdu>
   1cb44:	9007      	str	r0, [sp, #28]
	if (!data.buf) {
   1cb46:	2800      	cmp	r0, #0
   1cb48:	d043      	beq.n	1cbd2 <att_read_group_rsp+0xb2>
	data.chan = chan;
   1cb4a:	9505      	str	r5, [sp, #20]
	data.uuid = uuid;
   1cb4c:	f8cd 8018 	str.w	r8, [sp, #24]
	return net_buf_simple_add(&buf->b, len);
   1cb50:	2101      	movs	r1, #1
   1cb52:	3008      	adds	r0, #8
   1cb54:	f002 faf6 	bl	1f144 <net_buf_simple_add>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   1cb58:	9008      	str	r0, [sp, #32]
	data.rsp->len = 0U;
   1cb5a:	4622      	mov	r2, r4
   1cb5c:	7004      	strb	r4, [r0, #0]
	data.group = NULL;
   1cb5e:	9409      	str	r4, [sp, #36]	; 0x24
   1cb60:	ab05      	add	r3, sp, #20
   1cb62:	9302      	str	r3, [sp, #8]
   1cb64:	4b1c      	ldr	r3, [pc, #112]	; (1cbd8 <att_read_group_rsp+0xb8>)
   1cb66:	9301      	str	r3, [sp, #4]
   1cb68:	9400      	str	r4, [sp, #0]
   1cb6a:	4623      	mov	r3, r4
   1cb6c:	4639      	mov	r1, r7
   1cb6e:	4630      	mov	r0, r6
   1cb70:	f001 f842 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (!data.rsp->len) {
   1cb74:	9b08      	ldr	r3, [sp, #32]
   1cb76:	781c      	ldrb	r4, [r3, #0]
   1cb78:	b144      	cbz	r4, 1cb8c <att_read_group_rsp+0x6c>
	bt_att_chan_send_rsp(chan, data.buf);
   1cb7a:	9907      	ldr	r1, [sp, #28]
   1cb7c:	4628      	mov	r0, r5
   1cb7e:	f011 f8a1 	bl	2dcc4 <bt_att_chan_send_rsp>
	return 0;
   1cb82:	2400      	movs	r4, #0
}
   1cb84:	4620      	mov	r0, r4
   1cb86:	b00a      	add	sp, #40	; 0x28
   1cb88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1cb8c:	9b07      	ldr	r3, [sp, #28]
   1cb8e:	695f      	ldr	r7, [r3, #20]
	__ASSERT_NO_MSG(data);
   1cb90:	b19f      	cbz	r7, 1cbba <att_read_group_rsp+0x9a>
   1cb92:	2300      	movs	r3, #0
   1cb94:	603b      	str	r3, [r7, #0]
   1cb96:	607b      	str	r3, [r7, #4]
   1cb98:	60bb      	str	r3, [r7, #8]
   1cb9a:	60fb      	str	r3, [r7, #12]
   1cb9c:	613b      	str	r3, [r7, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1cb9e:	4639      	mov	r1, r7
   1cba0:	480e      	ldr	r0, [pc, #56]	; (1cbdc <att_read_group_rsp+0xbc>)
   1cba2:	f013 ff29 	bl	309f8 <k_queue_append>
		net_buf_unref(data.buf);
   1cba6:	9807      	ldr	r0, [sp, #28]
   1cba8:	f002 f9b4 	bl	1ef14 <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, start_handle,
   1cbac:	230a      	movs	r3, #10
   1cbae:	4632      	mov	r2, r6
   1cbb0:	2110      	movs	r1, #16
   1cbb2:	4628      	mov	r0, r5
   1cbb4:	f011 f8fb 	bl	2ddae <send_err_rsp>
		return 0;
   1cbb8:	e7e4      	b.n	1cb84 <att_read_group_rsp+0x64>
	__ASSERT_NO_MSG(data);
   1cbba:	f8df 8028 	ldr.w	r8, [pc, #40]	; 1cbe4 <att_read_group_rsp+0xc4>
   1cbbe:	22a4      	movs	r2, #164	; 0xa4
   1cbc0:	4641      	mov	r1, r8
   1cbc2:	4807      	ldr	r0, [pc, #28]	; (1cbe0 <att_read_group_rsp+0xc0>)
   1cbc4:	f00f fcb3 	bl	2c52e <assert_print>
   1cbc8:	21a4      	movs	r1, #164	; 0xa4
   1cbca:	4640      	mov	r0, r8
   1cbcc:	f00f fca8 	bl	2c520 <assert_post_action>
   1cbd0:	e7df      	b.n	1cb92 <att_read_group_rsp+0x72>
		return BT_ATT_ERR_UNLIKELY;
   1cbd2:	240e      	movs	r4, #14
   1cbd4:	e7d6      	b.n	1cb84 <att_read_group_rsp+0x64>
   1cbd6:	bf00      	nop
   1cbd8:	0001c111 	.word	0x0001c111
   1cbdc:	20000ecc 	.word	0x20000ecc
   1cbe0:	00031600 	.word	0x00031600
   1cbe4:	0003a610 	.word	0x0003a610

0001cbe8 <att_read_mult_vl_req>:
{
   1cbe8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cbea:	b089      	sub	sp, #36	; 0x24
   1cbec:	4606      	mov	r6, r0
   1cbee:	460d      	mov	r5, r1
	struct bt_conn *conn = chan->chan.chan.conn;
   1cbf0:	6844      	ldr	r4, [r0, #4]
	if (!bt_gatt_change_aware(conn, true)) {
   1cbf2:	2101      	movs	r1, #1
   1cbf4:	4620      	mov	r0, r4
   1cbf6:	f012 f87b 	bl	2ecf0 <bt_gatt_change_aware>
   1cbfa:	b9a0      	cbnz	r0, 1cc26 <att_read_mult_vl_req+0x3e>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   1cbfc:	3698      	adds	r6, #152	; 0x98
   1cbfe:	f3bf 8f5b 	dmb	ish
   1cc02:	e856 3f00 	ldrex	r3, [r6]
   1cc06:	f043 0220 	orr.w	r2, r3, #32
   1cc0a:	e846 2100 	strex	r1, r2, [r6]
   1cc0e:	2900      	cmp	r1, #0
   1cc10:	d1f7      	bne.n	1cc02 <att_read_mult_vl_req+0x1a>
   1cc12:	f3bf 8f5b 	dmb	ish
   1cc16:	f013 0f20 	tst.w	r3, #32
   1cc1a:	d002      	beq.n	1cc22 <att_read_mult_vl_req+0x3a>
			return 0;
   1cc1c:	2000      	movs	r0, #0
}
   1cc1e:	b009      	add	sp, #36	; 0x24
   1cc20:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   1cc22:	2012      	movs	r0, #18
   1cc24:	e7fb      	b.n	1cc1e <att_read_mult_vl_req+0x36>
	(void)memset(&data, 0, sizeof(data));
   1cc26:	2200      	movs	r2, #0
   1cc28:	9204      	str	r2, [sp, #16]
   1cc2a:	9205      	str	r2, [sp, #20]
   1cc2c:	9206      	str	r2, [sp, #24]
   1cc2e:	9207      	str	r2, [sp, #28]
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_VL_RSP, 0);
   1cc30:	2121      	movs	r1, #33	; 0x21
   1cc32:	4620      	mov	r0, r4
   1cc34:	f7ff ff3a 	bl	1caac <bt_att_create_pdu>
   1cc38:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
   1cc3a:	2800      	cmp	r0, #0
   1cc3c:	d043      	beq.n	1ccc6 <att_read_mult_vl_req+0xde>
	data.chan = chan;
   1cc3e:	9604      	str	r6, [sp, #16]
	while (buf->len >= sizeof(uint16_t)) {
   1cc40:	89ab      	ldrh	r3, [r5, #12]
   1cc42:	2b01      	cmp	r3, #1
   1cc44:	d939      	bls.n	1ccba <att_read_mult_vl_req+0xd2>
	return net_buf_simple_pull_le16(&buf->b);
   1cc46:	f105 0008 	add.w	r0, r5, #8
   1cc4a:	f012 f93c 	bl	2eec6 <net_buf_simple_pull_le16>
   1cc4e:	4604      	mov	r4, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   1cc50:	2301      	movs	r3, #1
   1cc52:	f88d 301c 	strb.w	r3, [sp, #28]
   1cc56:	ab04      	add	r3, sp, #16
   1cc58:	9302      	str	r3, [sp, #8]
   1cc5a:	4b1c      	ldr	r3, [pc, #112]	; (1cccc <att_read_mult_vl_req+0xe4>)
   1cc5c:	9301      	str	r3, [sp, #4]
   1cc5e:	2200      	movs	r2, #0
   1cc60:	9200      	str	r2, [sp, #0]
   1cc62:	4613      	mov	r3, r2
   1cc64:	4601      	mov	r1, r0
   1cc66:	f000 ffc7 	bl	1dbf8 <bt_gatt_foreach_attr_type>
		if (data.err) {
   1cc6a:	f89d 301c 	ldrb.w	r3, [sp, #28]
   1cc6e:	2b00      	cmp	r3, #0
   1cc70:	d0e6      	beq.n	1cc40 <att_read_mult_vl_req+0x58>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1cc72:	9b06      	ldr	r3, [sp, #24]
   1cc74:	695f      	ldr	r7, [r3, #20]
	__ASSERT_NO_MSG(data);
   1cc76:	b1af      	cbz	r7, 1cca4 <att_read_mult_vl_req+0xbc>
   1cc78:	2500      	movs	r5, #0
   1cc7a:	603d      	str	r5, [r7, #0]
   1cc7c:	607d      	str	r5, [r7, #4]
   1cc7e:	60bd      	str	r5, [r7, #8]
   1cc80:	60fd      	str	r5, [r7, #12]
   1cc82:	613d      	str	r5, [r7, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1cc84:	4639      	mov	r1, r7
   1cc86:	4812      	ldr	r0, [pc, #72]	; (1ccd0 <att_read_mult_vl_req+0xe8>)
   1cc88:	f013 feb6 	bl	309f8 <k_queue_append>
			net_buf_unref(data.buf);
   1cc8c:	9806      	ldr	r0, [sp, #24]
   1cc8e:	f002 f941 	bl	1ef14 <net_buf_unref>
			send_err_rsp(chan, BT_ATT_OP_READ_MULT_VL_REQ, handle,
   1cc92:	f89d 301c 	ldrb.w	r3, [sp, #28]
   1cc96:	4622      	mov	r2, r4
   1cc98:	2120      	movs	r1, #32
   1cc9a:	4630      	mov	r0, r6
   1cc9c:	f011 f887 	bl	2ddae <send_err_rsp>
			return 0;
   1cca0:	4628      	mov	r0, r5
   1cca2:	e7bc      	b.n	1cc1e <att_read_mult_vl_req+0x36>
	__ASSERT_NO_MSG(data);
   1cca4:	4d0b      	ldr	r5, [pc, #44]	; (1ccd4 <att_read_mult_vl_req+0xec>)
   1cca6:	22a4      	movs	r2, #164	; 0xa4
   1cca8:	4629      	mov	r1, r5
   1ccaa:	480b      	ldr	r0, [pc, #44]	; (1ccd8 <att_read_mult_vl_req+0xf0>)
   1ccac:	f00f fc3f 	bl	2c52e <assert_print>
   1ccb0:	21a4      	movs	r1, #164	; 0xa4
   1ccb2:	4628      	mov	r0, r5
   1ccb4:	f00f fc34 	bl	2c520 <assert_post_action>
   1ccb8:	e7de      	b.n	1cc78 <att_read_mult_vl_req+0x90>
	bt_att_chan_send_rsp(chan, data.buf);
   1ccba:	9906      	ldr	r1, [sp, #24]
   1ccbc:	4630      	mov	r0, r6
   1ccbe:	f011 f801 	bl	2dcc4 <bt_att_chan_send_rsp>
	return 0;
   1ccc2:	2000      	movs	r0, #0
   1ccc4:	e7ab      	b.n	1cc1e <att_read_mult_vl_req+0x36>
		return BT_ATT_ERR_UNLIKELY;
   1ccc6:	200e      	movs	r0, #14
   1ccc8:	e7a9      	b.n	1cc1e <att_read_mult_vl_req+0x36>
   1ccca:	bf00      	nop
   1cccc:	0002d8cf 	.word	0x0002d8cf
   1ccd0:	20000ecc 	.word	0x20000ecc
   1ccd4:	0003a610 	.word	0x0003a610
   1ccd8:	00031600 	.word	0x00031600

0001ccdc <att_read_mult_req>:
{
   1ccdc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ccde:	b089      	sub	sp, #36	; 0x24
   1cce0:	4606      	mov	r6, r0
   1cce2:	460d      	mov	r5, r1
	struct bt_conn *conn = chan->chan.chan.conn;
   1cce4:	6844      	ldr	r4, [r0, #4]
	if (!bt_gatt_change_aware(conn, true)) {
   1cce6:	2101      	movs	r1, #1
   1cce8:	4620      	mov	r0, r4
   1ccea:	f012 f801 	bl	2ecf0 <bt_gatt_change_aware>
   1ccee:	b9a0      	cbnz	r0, 1cd1a <att_read_mult_req+0x3e>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   1ccf0:	3698      	adds	r6, #152	; 0x98
   1ccf2:	f3bf 8f5b 	dmb	ish
   1ccf6:	e856 3f00 	ldrex	r3, [r6]
   1ccfa:	f043 0220 	orr.w	r2, r3, #32
   1ccfe:	e846 2100 	strex	r1, r2, [r6]
   1cd02:	2900      	cmp	r1, #0
   1cd04:	d1f7      	bne.n	1ccf6 <att_read_mult_req+0x1a>
   1cd06:	f3bf 8f5b 	dmb	ish
   1cd0a:	f013 0f20 	tst.w	r3, #32
   1cd0e:	d002      	beq.n	1cd16 <att_read_mult_req+0x3a>
			return 0;
   1cd10:	2000      	movs	r0, #0
}
   1cd12:	b009      	add	sp, #36	; 0x24
   1cd14:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   1cd16:	2012      	movs	r0, #18
   1cd18:	e7fb      	b.n	1cd12 <att_read_mult_req+0x36>
	(void)memset(&data, 0, sizeof(data));
   1cd1a:	2200      	movs	r2, #0
   1cd1c:	9204      	str	r2, [sp, #16]
   1cd1e:	9205      	str	r2, [sp, #20]
   1cd20:	9206      	str	r2, [sp, #24]
   1cd22:	9207      	str	r2, [sp, #28]
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   1cd24:	210f      	movs	r1, #15
   1cd26:	4620      	mov	r0, r4
   1cd28:	f7ff fec0 	bl	1caac <bt_att_create_pdu>
   1cd2c:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
   1cd2e:	2800      	cmp	r0, #0
   1cd30:	d043      	beq.n	1cdba <att_read_mult_req+0xde>
	data.chan = chan;
   1cd32:	9604      	str	r6, [sp, #16]
	while (buf->len >= sizeof(uint16_t)) {
   1cd34:	89ab      	ldrh	r3, [r5, #12]
   1cd36:	2b01      	cmp	r3, #1
   1cd38:	d939      	bls.n	1cdae <att_read_mult_req+0xd2>
   1cd3a:	f105 0008 	add.w	r0, r5, #8
   1cd3e:	f012 f8c2 	bl	2eec6 <net_buf_simple_pull_le16>
   1cd42:	4604      	mov	r4, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   1cd44:	2301      	movs	r3, #1
   1cd46:	f88d 301c 	strb.w	r3, [sp, #28]
   1cd4a:	ab04      	add	r3, sp, #16
   1cd4c:	9302      	str	r3, [sp, #8]
   1cd4e:	4b1c      	ldr	r3, [pc, #112]	; (1cdc0 <att_read_mult_req+0xe4>)
   1cd50:	9301      	str	r3, [sp, #4]
   1cd52:	2200      	movs	r2, #0
   1cd54:	9200      	str	r2, [sp, #0]
   1cd56:	4613      	mov	r3, r2
   1cd58:	4601      	mov	r1, r0
   1cd5a:	f000 ff4d 	bl	1dbf8 <bt_gatt_foreach_attr_type>
		if (data.err) {
   1cd5e:	f89d 301c 	ldrb.w	r3, [sp, #28]
   1cd62:	2b00      	cmp	r3, #0
   1cd64:	d0e6      	beq.n	1cd34 <att_read_mult_req+0x58>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1cd66:	9b06      	ldr	r3, [sp, #24]
   1cd68:	695f      	ldr	r7, [r3, #20]
	__ASSERT_NO_MSG(data);
   1cd6a:	b1af      	cbz	r7, 1cd98 <att_read_mult_req+0xbc>
   1cd6c:	2500      	movs	r5, #0
   1cd6e:	603d      	str	r5, [r7, #0]
   1cd70:	607d      	str	r5, [r7, #4]
   1cd72:	60bd      	str	r5, [r7, #8]
   1cd74:	60fd      	str	r5, [r7, #12]
   1cd76:	613d      	str	r5, [r7, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1cd78:	4639      	mov	r1, r7
   1cd7a:	4812      	ldr	r0, [pc, #72]	; (1cdc4 <att_read_mult_req+0xe8>)
   1cd7c:	f013 fe3c 	bl	309f8 <k_queue_append>
			net_buf_unref(data.buf);
   1cd80:	9806      	ldr	r0, [sp, #24]
   1cd82:	f002 f8c7 	bl	1ef14 <net_buf_unref>
			send_err_rsp(chan, BT_ATT_OP_READ_MULT_REQ, handle,
   1cd86:	f89d 301c 	ldrb.w	r3, [sp, #28]
   1cd8a:	4622      	mov	r2, r4
   1cd8c:	210e      	movs	r1, #14
   1cd8e:	4630      	mov	r0, r6
   1cd90:	f011 f80d 	bl	2ddae <send_err_rsp>
			return 0;
   1cd94:	4628      	mov	r0, r5
   1cd96:	e7bc      	b.n	1cd12 <att_read_mult_req+0x36>
	__ASSERT_NO_MSG(data);
   1cd98:	4d0b      	ldr	r5, [pc, #44]	; (1cdc8 <att_read_mult_req+0xec>)
   1cd9a:	22a4      	movs	r2, #164	; 0xa4
   1cd9c:	4629      	mov	r1, r5
   1cd9e:	480b      	ldr	r0, [pc, #44]	; (1cdcc <att_read_mult_req+0xf0>)
   1cda0:	f00f fbc5 	bl	2c52e <assert_print>
   1cda4:	21a4      	movs	r1, #164	; 0xa4
   1cda6:	4628      	mov	r0, r5
   1cda8:	f00f fbba 	bl	2c520 <assert_post_action>
   1cdac:	e7de      	b.n	1cd6c <att_read_mult_req+0x90>
	bt_att_chan_send_rsp(chan, data.buf);
   1cdae:	9906      	ldr	r1, [sp, #24]
   1cdb0:	4630      	mov	r0, r6
   1cdb2:	f010 ff87 	bl	2dcc4 <bt_att_chan_send_rsp>
	return 0;
   1cdb6:	2000      	movs	r0, #0
   1cdb8:	e7ab      	b.n	1cd12 <att_read_mult_req+0x36>
		return BT_ATT_ERR_UNLIKELY;
   1cdba:	200e      	movs	r0, #14
   1cdbc:	e7a9      	b.n	1cd12 <att_read_mult_req+0x36>
   1cdbe:	bf00      	nop
   1cdc0:	0002d935 	.word	0x0002d935
   1cdc4:	20000ecc 	.word	0x20000ecc
   1cdc8:	0003a610 	.word	0x0003a610
   1cdcc:	00031600 	.word	0x00031600

0001cdd0 <att_read_rsp>:
{
   1cdd0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1cdd4:	b089      	sub	sp, #36	; 0x24
   1cdd6:	4604      	mov	r4, r0
   1cdd8:	4689      	mov	r9, r1
   1cdda:	4616      	mov	r6, r2
   1cddc:	461d      	mov	r5, r3
	struct bt_conn *conn = chan->chan.chan.conn;
   1cdde:	6847      	ldr	r7, [r0, #4]
	if (!bt_gatt_change_aware(conn, true)) {
   1cde0:	2101      	movs	r1, #1
   1cde2:	4638      	mov	r0, r7
   1cde4:	f011 ff84 	bl	2ecf0 <bt_gatt_change_aware>
   1cde8:	b128      	cbz	r0, 1cdf6 <att_read_rsp+0x26>
	if (!handle) {
   1cdea:	b9c5      	cbnz	r5, 1ce1e <att_read_rsp+0x4e>
		return BT_ATT_ERR_INVALID_HANDLE;
   1cdec:	2601      	movs	r6, #1
}
   1cdee:	4630      	mov	r0, r6
   1cdf0:	b009      	add	sp, #36	; 0x24
   1cdf2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
   1cdf6:	3498      	adds	r4, #152	; 0x98
   1cdf8:	f3bf 8f5b 	dmb	ish
   1cdfc:	e854 3f00 	ldrex	r3, [r4]
   1ce00:	f043 0220 	orr.w	r2, r3, #32
   1ce04:	e844 2100 	strex	r1, r2, [r4]
   1ce08:	2900      	cmp	r1, #0
   1ce0a:	d1f7      	bne.n	1cdfc <att_read_rsp+0x2c>
   1ce0c:	f3bf 8f5b 	dmb	ish
   1ce10:	f013 0f20 	tst.w	r3, #32
   1ce14:	d001      	beq.n	1ce1a <att_read_rsp+0x4a>
			return 0;
   1ce16:	2600      	movs	r6, #0
   1ce18:	e7e9      	b.n	1cdee <att_read_rsp+0x1e>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
   1ce1a:	2612      	movs	r6, #18
   1ce1c:	e7e7      	b.n	1cdee <att_read_rsp+0x1e>
	(void)memset(&data, 0, sizeof(data));
   1ce1e:	2200      	movs	r2, #0
   1ce20:	9204      	str	r2, [sp, #16]
   1ce22:	9205      	str	r2, [sp, #20]
   1ce24:	9206      	str	r2, [sp, #24]
   1ce26:	9207      	str	r2, [sp, #28]
	data.buf = bt_att_create_pdu(conn, rsp, 0);
   1ce28:	4631      	mov	r1, r6
   1ce2a:	4638      	mov	r0, r7
   1ce2c:	f7ff fe3e 	bl	1caac <bt_att_create_pdu>
   1ce30:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
   1ce32:	2800      	cmp	r0, #0
   1ce34:	d045      	beq.n	1cec2 <att_read_rsp+0xf2>
	data.chan = chan;
   1ce36:	9404      	str	r4, [sp, #16]
	data.offset = offset;
   1ce38:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   1ce3c:	f8ad 3014 	strh.w	r3, [sp, #20]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   1ce40:	2301      	movs	r3, #1
   1ce42:	f88d 301c 	strb.w	r3, [sp, #28]
   1ce46:	ab04      	add	r3, sp, #16
   1ce48:	9302      	str	r3, [sp, #8]
   1ce4a:	4b1f      	ldr	r3, [pc, #124]	; (1cec8 <att_read_rsp+0xf8>)
   1ce4c:	9301      	str	r3, [sp, #4]
   1ce4e:	2200      	movs	r2, #0
   1ce50:	9200      	str	r2, [sp, #0]
   1ce52:	4613      	mov	r3, r2
   1ce54:	4629      	mov	r1, r5
   1ce56:	4628      	mov	r0, r5
   1ce58:	f000 fece 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (data.err) {
   1ce5c:	f89d 601c 	ldrb.w	r6, [sp, #28]
   1ce60:	b926      	cbnz	r6, 1ce6c <att_read_rsp+0x9c>
	bt_att_chan_send_rsp(chan, data.buf);
   1ce62:	9906      	ldr	r1, [sp, #24]
   1ce64:	4620      	mov	r0, r4
   1ce66:	f010 ff2d 	bl	2dcc4 <bt_att_chan_send_rsp>
	return 0;
   1ce6a:	e7c0      	b.n	1cdee <att_read_rsp+0x1e>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1ce6c:	9b06      	ldr	r3, [sp, #24]
   1ce6e:	f8d3 8014 	ldr.w	r8, [r3, #20]
	__ASSERT_NO_MSG(data);
   1ce72:	f1b8 0f00 	cmp.w	r8, #0
   1ce76:	d019      	beq.n	1ceac <att_read_rsp+0xdc>
   1ce78:	2600      	movs	r6, #0
   1ce7a:	f8c8 6000 	str.w	r6, [r8]
   1ce7e:	f8c8 6004 	str.w	r6, [r8, #4]
   1ce82:	f8c8 6008 	str.w	r6, [r8, #8]
   1ce86:	f8c8 600c 	str.w	r6, [r8, #12]
   1ce8a:	f8c8 6010 	str.w	r6, [r8, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1ce8e:	4641      	mov	r1, r8
   1ce90:	480e      	ldr	r0, [pc, #56]	; (1cecc <att_read_rsp+0xfc>)
   1ce92:	f013 fdb1 	bl	309f8 <k_queue_append>
		net_buf_unref(data.buf);
   1ce96:	9806      	ldr	r0, [sp, #24]
   1ce98:	f002 f83c 	bl	1ef14 <net_buf_unref>
		send_err_rsp(chan, op, handle, data.err);
   1ce9c:	f89d 301c 	ldrb.w	r3, [sp, #28]
   1cea0:	462a      	mov	r2, r5
   1cea2:	4649      	mov	r1, r9
   1cea4:	4620      	mov	r0, r4
   1cea6:	f010 ff82 	bl	2ddae <send_err_rsp>
		return 0;
   1ceaa:	e7a0      	b.n	1cdee <att_read_rsp+0x1e>
	__ASSERT_NO_MSG(data);
   1ceac:	4e08      	ldr	r6, [pc, #32]	; (1ced0 <att_read_rsp+0x100>)
   1ceae:	22a4      	movs	r2, #164	; 0xa4
   1ceb0:	4631      	mov	r1, r6
   1ceb2:	4808      	ldr	r0, [pc, #32]	; (1ced4 <att_read_rsp+0x104>)
   1ceb4:	f00f fb3b 	bl	2c52e <assert_print>
   1ceb8:	21a4      	movs	r1, #164	; 0xa4
   1ceba:	4630      	mov	r0, r6
   1cebc:	f00f fb30 	bl	2c520 <assert_post_action>
   1cec0:	e7da      	b.n	1ce78 <att_read_rsp+0xa8>
		return BT_ATT_ERR_UNLIKELY;
   1cec2:	260e      	movs	r6, #14
   1cec4:	e793      	b.n	1cdee <att_read_rsp+0x1e>
   1cec6:	bf00      	nop
   1cec8:	0002d935 	.word	0x0002d935
   1cecc:	20000ecc 	.word	0x20000ecc
   1ced0:	0003a610 	.word	0x0003a610
   1ced4:	00031600 	.word	0x00031600

0001ced8 <att_read_type_rsp>:
{
   1ced8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1cedc:	b08a      	sub	sp, #40	; 0x28
   1cede:	4605      	mov	r5, r0
   1cee0:	4688      	mov	r8, r1
   1cee2:	4616      	mov	r6, r2
   1cee4:	461f      	mov	r7, r3
	(void)memset(&data, 0, sizeof(data));
   1cee6:	2400      	movs	r4, #0
   1cee8:	9404      	str	r4, [sp, #16]
   1ceea:	9405      	str	r4, [sp, #20]
   1ceec:	9406      	str	r4, [sp, #24]
   1ceee:	9407      	str	r4, [sp, #28]
   1cef0:	9408      	str	r4, [sp, #32]
   1cef2:	9409      	str	r4, [sp, #36]	; 0x24
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
   1cef4:	2201      	movs	r2, #1
   1cef6:	2109      	movs	r1, #9
   1cef8:	6840      	ldr	r0, [r0, #4]
   1cefa:	f7ff fdd7 	bl	1caac <bt_att_create_pdu>
   1cefe:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
   1cf00:	2800      	cmp	r0, #0
   1cf02:	d044      	beq.n	1cf8e <att_read_type_rsp+0xb6>
	data.chan = chan;
   1cf04:	9504      	str	r5, [sp, #16]
	data.uuid = uuid;
   1cf06:	f8cd 8014 	str.w	r8, [sp, #20]
	return net_buf_simple_add(&buf->b, len);
   1cf0a:	2101      	movs	r1, #1
   1cf0c:	3008      	adds	r0, #8
   1cf0e:	f002 f919 	bl	1f144 <net_buf_simple_add>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   1cf12:	9007      	str	r0, [sp, #28]
	data.rsp->len = 0U;
   1cf14:	4622      	mov	r2, r4
   1cf16:	7004      	strb	r4, [r0, #0]
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   1cf18:	230a      	movs	r3, #10
   1cf1a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
   1cf1e:	ab04      	add	r3, sp, #16
   1cf20:	9302      	str	r3, [sp, #8]
   1cf22:	4b1c      	ldr	r3, [pc, #112]	; (1cf94 <att_read_type_rsp+0xbc>)
   1cf24:	9301      	str	r3, [sp, #4]
   1cf26:	9400      	str	r4, [sp, #0]
   1cf28:	4623      	mov	r3, r4
   1cf2a:	4639      	mov	r1, r7
   1cf2c:	4630      	mov	r0, r6
   1cf2e:	f000 fe63 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (data.err) {
   1cf32:	f89d 4024 	ldrb.w	r4, [sp, #36]	; 0x24
   1cf36:	b93c      	cbnz	r4, 1cf48 <att_read_type_rsp+0x70>
	bt_att_chan_send_rsp(chan, data.buf);
   1cf38:	9906      	ldr	r1, [sp, #24]
   1cf3a:	4628      	mov	r0, r5
   1cf3c:	f010 fec2 	bl	2dcc4 <bt_att_chan_send_rsp>
}
   1cf40:	4620      	mov	r0, r4
   1cf42:	b00a      	add	sp, #40	; 0x28
   1cf44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1cf48:	9b06      	ldr	r3, [sp, #24]
   1cf4a:	695f      	ldr	r7, [r3, #20]
	__ASSERT_NO_MSG(data);
   1cf4c:	b1a7      	cbz	r7, 1cf78 <att_read_type_rsp+0xa0>
   1cf4e:	2400      	movs	r4, #0
   1cf50:	603c      	str	r4, [r7, #0]
   1cf52:	607c      	str	r4, [r7, #4]
   1cf54:	60bc      	str	r4, [r7, #8]
   1cf56:	60fc      	str	r4, [r7, #12]
   1cf58:	613c      	str	r4, [r7, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1cf5a:	4639      	mov	r1, r7
   1cf5c:	480e      	ldr	r0, [pc, #56]	; (1cf98 <att_read_type_rsp+0xc0>)
   1cf5e:	f013 fd4b 	bl	309f8 <k_queue_append>
		net_buf_unref(data.buf);
   1cf62:	9806      	ldr	r0, [sp, #24]
   1cf64:	f001 ffd6 	bl	1ef14 <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, start_handle,
   1cf68:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   1cf6c:	4632      	mov	r2, r6
   1cf6e:	2108      	movs	r1, #8
   1cf70:	4628      	mov	r0, r5
   1cf72:	f010 ff1c 	bl	2ddae <send_err_rsp>
		return 0;
   1cf76:	e7e3      	b.n	1cf40 <att_read_type_rsp+0x68>
	__ASSERT_NO_MSG(data);
   1cf78:	4c08      	ldr	r4, [pc, #32]	; (1cf9c <att_read_type_rsp+0xc4>)
   1cf7a:	22a4      	movs	r2, #164	; 0xa4
   1cf7c:	4621      	mov	r1, r4
   1cf7e:	4808      	ldr	r0, [pc, #32]	; (1cfa0 <att_read_type_rsp+0xc8>)
   1cf80:	f00f fad5 	bl	2c52e <assert_print>
   1cf84:	21a4      	movs	r1, #164	; 0xa4
   1cf86:	4620      	mov	r0, r4
   1cf88:	f00f faca 	bl	2c520 <assert_post_action>
   1cf8c:	e7df      	b.n	1cf4e <att_read_type_rsp+0x76>
		return BT_ATT_ERR_UNLIKELY;
   1cf8e:	240e      	movs	r4, #14
   1cf90:	e7d6      	b.n	1cf40 <att_read_type_rsp+0x68>
   1cf92:	bf00      	nop
   1cf94:	0001c1c5 	.word	0x0001c1c5
   1cf98:	20000ecc 	.word	0x20000ecc
   1cf9c:	0003a610 	.word	0x0003a610
   1cfa0:	00031600 	.word	0x00031600

0001cfa4 <att_find_type_rsp>:
{
   1cfa4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cfa6:	b08b      	sub	sp, #44	; 0x2c
   1cfa8:	4604      	mov	r4, r0
   1cfaa:	460e      	mov	r6, r1
   1cfac:	4615      	mov	r5, r2
   1cfae:	461f      	mov	r7, r3
	(void)memset(&data, 0, sizeof(data));
   1cfb0:	2200      	movs	r2, #0
   1cfb2:	9205      	str	r2, [sp, #20]
   1cfb4:	9206      	str	r2, [sp, #24]
   1cfb6:	9207      	str	r2, [sp, #28]
   1cfb8:	9208      	str	r2, [sp, #32]
   1cfba:	9209      	str	r2, [sp, #36]	; 0x24
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
   1cfbc:	2107      	movs	r1, #7
   1cfbe:	6840      	ldr	r0, [r0, #4]
   1cfc0:	f7ff fd74 	bl	1caac <bt_att_create_pdu>
   1cfc4:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
   1cfc6:	2800      	cmp	r0, #0
   1cfc8:	d041      	beq.n	1d04e <att_find_type_rsp+0xaa>
	data.chan = chan;
   1cfca:	9405      	str	r4, [sp, #20]
	data.group = NULL;
   1cfcc:	2200      	movs	r2, #0
   1cfce:	9207      	str	r2, [sp, #28]
	data.value = value;
   1cfd0:	9708      	str	r7, [sp, #32]
	data.value_len = value_len;
   1cfd2:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1cfd6:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   1cfda:	230a      	movs	r3, #10
   1cfdc:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
   1cfe0:	ab05      	add	r3, sp, #20
   1cfe2:	9302      	str	r3, [sp, #8]
   1cfe4:	4b1b      	ldr	r3, [pc, #108]	; (1d054 <att_find_type_rsp+0xb0>)
   1cfe6:	9301      	str	r3, [sp, #4]
   1cfe8:	9200      	str	r2, [sp, #0]
   1cfea:	4613      	mov	r3, r2
   1cfec:	4629      	mov	r1, r5
   1cfee:	4630      	mov	r0, r6
   1cff0:	f000 fe02 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (data.err) {
   1cff4:	f89d 5025 	ldrb.w	r5, [sp, #37]	; 0x25
   1cff8:	b935      	cbnz	r5, 1d008 <att_find_type_rsp+0x64>
	bt_att_chan_send_rsp(chan, data.buf);
   1cffa:	9906      	ldr	r1, [sp, #24]
   1cffc:	4620      	mov	r0, r4
   1cffe:	f010 fe61 	bl	2dcc4 <bt_att_chan_send_rsp>
}
   1d002:	4628      	mov	r0, r5
   1d004:	b00b      	add	sp, #44	; 0x2c
   1d006:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1d008:	9b06      	ldr	r3, [sp, #24]
   1d00a:	695f      	ldr	r7, [r3, #20]
	__ASSERT_NO_MSG(data);
   1d00c:	b1a7      	cbz	r7, 1d038 <att_find_type_rsp+0x94>
   1d00e:	2500      	movs	r5, #0
   1d010:	603d      	str	r5, [r7, #0]
   1d012:	607d      	str	r5, [r7, #4]
   1d014:	60bd      	str	r5, [r7, #8]
   1d016:	60fd      	str	r5, [r7, #12]
   1d018:	613d      	str	r5, [r7, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1d01a:	4639      	mov	r1, r7
   1d01c:	480e      	ldr	r0, [pc, #56]	; (1d058 <att_find_type_rsp+0xb4>)
   1d01e:	f013 fceb 	bl	309f8 <k_queue_append>
		net_buf_unref(data.buf);
   1d022:	9806      	ldr	r0, [sp, #24]
   1d024:	f001 ff76 	bl	1ef14 <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle,
   1d028:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   1d02c:	4632      	mov	r2, r6
   1d02e:	2106      	movs	r1, #6
   1d030:	4620      	mov	r0, r4
   1d032:	f010 febc 	bl	2ddae <send_err_rsp>
		return 0;
   1d036:	e7e4      	b.n	1d002 <att_find_type_rsp+0x5e>
	__ASSERT_NO_MSG(data);
   1d038:	4d08      	ldr	r5, [pc, #32]	; (1d05c <att_find_type_rsp+0xb8>)
   1d03a:	22a4      	movs	r2, #164	; 0xa4
   1d03c:	4629      	mov	r1, r5
   1d03e:	4808      	ldr	r0, [pc, #32]	; (1d060 <att_find_type_rsp+0xbc>)
   1d040:	f00f fa75 	bl	2c52e <assert_print>
   1d044:	21a4      	movs	r1, #164	; 0xa4
   1d046:	4628      	mov	r0, r5
   1d048:	f00f fa6a 	bl	2c520 <assert_post_action>
   1d04c:	e7df      	b.n	1d00e <att_find_type_rsp+0x6a>
		return BT_ATT_ERR_UNLIKELY;
   1d04e:	250e      	movs	r5, #14
   1d050:	e7d7      	b.n	1d002 <att_find_type_rsp+0x5e>
   1d052:	bf00      	nop
   1d054:	0001c26d 	.word	0x0001c26d
   1d058:	20000ecc 	.word	0x20000ecc
   1d05c:	0003a610 	.word	0x0003a610
   1d060:	00031600 	.word	0x00031600

0001d064 <att_find_info_rsp>:
{
   1d064:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d066:	b089      	sub	sp, #36	; 0x24
   1d068:	4604      	mov	r4, r0
   1d06a:	460d      	mov	r5, r1
   1d06c:	4616      	mov	r6, r2
	(void)memset(&data, 0, sizeof(data));
   1d06e:	2200      	movs	r2, #0
   1d070:	9204      	str	r2, [sp, #16]
   1d072:	9205      	str	r2, [sp, #20]
   1d074:	9206      	str	r2, [sp, #24]
   1d076:	9207      	str	r2, [sp, #28]
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
   1d078:	2105      	movs	r1, #5
   1d07a:	6840      	ldr	r0, [r0, #4]
   1d07c:	f7ff fd16 	bl	1caac <bt_att_create_pdu>
   1d080:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
   1d082:	2800      	cmp	r0, #0
   1d084:	d037      	beq.n	1d0f6 <att_find_info_rsp+0x92>
	data.chan = chan;
   1d086:	9404      	str	r4, [sp, #16]
   1d088:	ab04      	add	r3, sp, #16
   1d08a:	9302      	str	r3, [sp, #8]
   1d08c:	4b1b      	ldr	r3, [pc, #108]	; (1d0fc <att_find_info_rsp+0x98>)
   1d08e:	9301      	str	r3, [sp, #4]
   1d090:	2200      	movs	r2, #0
   1d092:	9200      	str	r2, [sp, #0]
   1d094:	4613      	mov	r3, r2
   1d096:	4631      	mov	r1, r6
   1d098:	4628      	mov	r0, r5
   1d09a:	f000 fdad 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (!data.rsp) {
   1d09e:	9b06      	ldr	r3, [sp, #24]
   1d0a0:	b133      	cbz	r3, 1d0b0 <att_find_info_rsp+0x4c>
	bt_att_chan_send_rsp(chan, data.buf);
   1d0a2:	9905      	ldr	r1, [sp, #20]
   1d0a4:	4620      	mov	r0, r4
   1d0a6:	f010 fe0d 	bl	2dcc4 <bt_att_chan_send_rsp>
	return 0;
   1d0aa:	2000      	movs	r0, #0
}
   1d0ac:	b009      	add	sp, #36	; 0x24
   1d0ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
   1d0b0:	9b05      	ldr	r3, [sp, #20]
   1d0b2:	695f      	ldr	r7, [r3, #20]
	__ASSERT_NO_MSG(data);
   1d0b4:	b1a7      	cbz	r7, 1d0e0 <att_find_info_rsp+0x7c>
   1d0b6:	2600      	movs	r6, #0
   1d0b8:	603e      	str	r6, [r7, #0]
   1d0ba:	607e      	str	r6, [r7, #4]
   1d0bc:	60be      	str	r6, [r7, #8]
   1d0be:	60fe      	str	r6, [r7, #12]
   1d0c0:	613e      	str	r6, [r7, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1d0c2:	4639      	mov	r1, r7
   1d0c4:	480e      	ldr	r0, [pc, #56]	; (1d100 <att_find_info_rsp+0x9c>)
   1d0c6:	f013 fc97 	bl	309f8 <k_queue_append>
		net_buf_unref(data.buf);
   1d0ca:	9805      	ldr	r0, [sp, #20]
   1d0cc:	f001 ff22 	bl	1ef14 <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, start_handle,
   1d0d0:	230a      	movs	r3, #10
   1d0d2:	462a      	mov	r2, r5
   1d0d4:	2104      	movs	r1, #4
   1d0d6:	4620      	mov	r0, r4
   1d0d8:	f010 fe69 	bl	2ddae <send_err_rsp>
		return 0;
   1d0dc:	4630      	mov	r0, r6
   1d0de:	e7e5      	b.n	1d0ac <att_find_info_rsp+0x48>
	__ASSERT_NO_MSG(data);
   1d0e0:	4e08      	ldr	r6, [pc, #32]	; (1d104 <att_find_info_rsp+0xa0>)
   1d0e2:	22a4      	movs	r2, #164	; 0xa4
   1d0e4:	4631      	mov	r1, r6
   1d0e6:	4808      	ldr	r0, [pc, #32]	; (1d108 <att_find_info_rsp+0xa4>)
   1d0e8:	f00f fa21 	bl	2c52e <assert_print>
   1d0ec:	21a4      	movs	r1, #164	; 0xa4
   1d0ee:	4630      	mov	r0, r6
   1d0f0:	f00f fa16 	bl	2c520 <assert_post_action>
   1d0f4:	e7df      	b.n	1d0b6 <att_find_info_rsp+0x52>
		return BT_ATT_ERR_UNLIKELY;
   1d0f6:	200e      	movs	r0, #14
   1d0f8:	e7d8      	b.n	1d0ac <att_find_info_rsp+0x48>
   1d0fa:	bf00      	nop
   1d0fc:	0002d97d 	.word	0x0002d97d
   1d100:	20000ecc 	.word	0x20000ecc
   1d104:	0003a610 	.word	0x0003a610
   1d108:	00031600 	.word	0x00031600

0001d10c <bt_att_init>:
	bt_l2cap_register_ecred_cb(&cb);
#endif /* CONFIG_BT_EATT */
}

void bt_att_init(void)
{
   1d10c:	b510      	push	{r4, lr}
	for (size_t i = 0; i < ARRAY_SIZE(tx_meta_data); i++) {
   1d10e:	2400      	movs	r4, #0
   1d110:	e008      	b.n	1d124 <bt_att_init+0x18>
		k_fifo_put(&free_att_tx_meta_data, &tx_meta_data[i]);
   1d112:	eb04 0284 	add.w	r2, r4, r4, lsl #2
   1d116:	0093      	lsls	r3, r2, #2
   1d118:	4905      	ldr	r1, [pc, #20]	; (1d130 <bt_att_init+0x24>)
   1d11a:	4419      	add	r1, r3
   1d11c:	4805      	ldr	r0, [pc, #20]	; (1d134 <bt_att_init+0x28>)
   1d11e:	f013 fc6b 	bl	309f8 <k_queue_append>
	for (size_t i = 0; i < ARRAY_SIZE(tx_meta_data); i++) {
   1d122:	3401      	adds	r4, #1
   1d124:	2c02      	cmp	r4, #2
   1d126:	d9f4      	bls.n	1d112 <bt_att_init+0x6>
	}

	bt_gatt_init();
   1d128:	f000 fcea 	bl	1db00 <bt_gatt_init>

	if (IS_ENABLED(CONFIG_BT_EATT)) {
		bt_eatt_init();
	}
}
   1d12c:	bd10      	pop	{r4, pc}
   1d12e:	bf00      	nop
   1d130:	20003ba8 	.word	0x20003ba8
   1d134:	20000ecc 	.word	0x20000ecc

0001d138 <bt_att_req_alloc>:
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
	}
}

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
   1d138:	b530      	push	{r4, r5, lr}
   1d13a:	b083      	sub	sp, #12
   1d13c:	4605      	mov	r5, r0
   1d13e:	460c      	mov	r4, r1
	struct bt_att_req *req = NULL;
   1d140:	2300      	movs	r3, #0
   1d142:	9301      	str	r3, [sp, #4]
   1d144:	f00b fe4e 	bl	28de4 <z_impl_z_current_get>

	if (k_current_get() == att_handle_rsp_thread) {
   1d148:	4b0c      	ldr	r3, [pc, #48]	; (1d17c <bt_att_req_alloc+0x44>)
   1d14a:	681b      	ldr	r3, [r3, #0]
   1d14c:	4283      	cmp	r3, r0
   1d14e:	d00f      	beq.n	1d170 <bt_att_req_alloc+0x38>
		 */
		timeout = K_NO_WAIT;
	}

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
   1d150:	462a      	mov	r2, r5
   1d152:	4623      	mov	r3, r4
   1d154:	a901      	add	r1, sp, #4
   1d156:	480a      	ldr	r0, [pc, #40]	; (1d180 <bt_att_req_alloc+0x48>)
   1d158:	f009 f8d6 	bl	26308 <k_mem_slab_alloc>
   1d15c:	b958      	cbnz	r0, 1d176 <bt_att_req_alloc+0x3e>
		return NULL;
	}

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));
   1d15e:	9b01      	ldr	r3, [sp, #4]
   1d160:	2200      	movs	r2, #0
   1d162:	601a      	str	r2, [r3, #0]
   1d164:	605a      	str	r2, [r3, #4]
   1d166:	609a      	str	r2, [r3, #8]
   1d168:	60da      	str	r2, [r3, #12]

	return req;
   1d16a:	9801      	ldr	r0, [sp, #4]
}
   1d16c:	b003      	add	sp, #12
   1d16e:	bd30      	pop	{r4, r5, pc}
		timeout = K_NO_WAIT;
   1d170:	2500      	movs	r5, #0
   1d172:	462c      	mov	r4, r5
   1d174:	e7ec      	b.n	1d150 <bt_att_req_alloc+0x18>
		return NULL;
   1d176:	2000      	movs	r0, #0
   1d178:	e7f8      	b.n	1d16c <bt_att_req_alloc+0x34>
   1d17a:	bf00      	nop
   1d17c:	20003b94 	.word	0x20003b94
   1d180:	20000e80 	.word	0x20000e80

0001d184 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
   1d184:	b530      	push	{r4, r5, lr}
   1d186:	b083      	sub	sp, #12
   1d188:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	if (req->buf) {
   1d18a:	6883      	ldr	r3, [r0, #8]
   1d18c:	b18b      	cbz	r3, 1d1b2 <bt_att_req_free+0x2e>
		tx_meta_data_free(bt_att_tx_meta_data(req->buf));
   1d18e:	695c      	ldr	r4, [r3, #20]
	__ASSERT_NO_MSG(data);
   1d190:	b1ac      	cbz	r4, 1d1be <bt_att_req_free+0x3a>
   1d192:	2500      	movs	r5, #0
   1d194:	6025      	str	r5, [r4, #0]
   1d196:	6065      	str	r5, [r4, #4]
   1d198:	60a5      	str	r5, [r4, #8]
   1d19a:	60e5      	str	r5, [r4, #12]
   1d19c:	6125      	str	r5, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1d19e:	4621      	mov	r1, r4
   1d1a0:	480c      	ldr	r0, [pc, #48]	; (1d1d4 <bt_att_req_free+0x50>)
   1d1a2:	f013 fc29 	bl	309f8 <k_queue_append>
		net_buf_unref(req->buf);
   1d1a6:	9b01      	ldr	r3, [sp, #4]
   1d1a8:	6898      	ldr	r0, [r3, #8]
   1d1aa:	f001 feb3 	bl	1ef14 <net_buf_unref>
		req->buf = NULL;
   1d1ae:	9b01      	ldr	r3, [sp, #4]
   1d1b0:	609d      	str	r5, [r3, #8]
	}

	k_mem_slab_free(&req_slab, (void **)&req);
   1d1b2:	a901      	add	r1, sp, #4
   1d1b4:	4808      	ldr	r0, [pc, #32]	; (1d1d8 <bt_att_req_free+0x54>)
   1d1b6:	f009 f90b 	bl	263d0 <k_mem_slab_free>
}
   1d1ba:	b003      	add	sp, #12
   1d1bc:	bd30      	pop	{r4, r5, pc}
	__ASSERT_NO_MSG(data);
   1d1be:	4d07      	ldr	r5, [pc, #28]	; (1d1dc <bt_att_req_free+0x58>)
   1d1c0:	22a4      	movs	r2, #164	; 0xa4
   1d1c2:	4629      	mov	r1, r5
   1d1c4:	4806      	ldr	r0, [pc, #24]	; (1d1e0 <bt_att_req_free+0x5c>)
   1d1c6:	f00f f9b2 	bl	2c52e <assert_print>
   1d1ca:	21a4      	movs	r1, #164	; 0xa4
   1d1cc:	4628      	mov	r0, r5
   1d1ce:	f00f f9a7 	bl	2c520 <assert_post_action>
   1d1d2:	e7de      	b.n	1d192 <bt_att_req_free+0xe>
   1d1d4:	20000ecc 	.word	0x20000ecc
   1d1d8:	20000e80 	.word	0x20000e80
   1d1dc:	0003a610 	.word	0x0003a610
   1d1e0:	00031600 	.word	0x00031600

0001d1e4 <att_handle_rsp>:
{
   1d1e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d1e8:	b082      	sub	sp, #8
   1d1ea:	4604      	mov	r4, r0
   1d1ec:	460f      	mov	r7, r1
   1d1ee:	4691      	mov	r9, r2
   1d1f0:	461e      	mov	r6, r3
	k_work_cancel_delayable(&chan->timeout_work);
   1d1f2:	30c0      	adds	r0, #192	; 0xc0
   1d1f4:	f00a fc0a 	bl	27a0c <k_work_cancel_delayable>
	if (!chan->req) {
   1d1f8:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1d1fc:	b1f8      	cbz	r0, 1d23e <att_handle_rsp+0x5a>
	if (chan->req == &cancel) {
   1d1fe:	4b15      	ldr	r3, [pc, #84]	; (1d254 <att_handle_rsp+0x70>)
   1d200:	4298      	cmp	r0, r3
   1d202:	d022      	beq.n	1d24a <att_handle_rsp+0x66>
	func = chan->req->func;
   1d204:	6845      	ldr	r5, [r0, #4]
	chan->req->func = NULL;
   1d206:	f04f 0a00 	mov.w	sl, #0
   1d20a:	f8c0 a004 	str.w	sl, [r0, #4]
	params = chan->req->user_data;
   1d20e:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1d212:	f8d0 800c 	ldr.w	r8, [r0, #12]
	bt_att_req_free(chan->req);
   1d216:	f7ff ffb5 	bl	1d184 <bt_att_req_free>
	chan->req = NULL;
   1d21a:	f8c4 a09c 	str.w	sl, [r4, #156]	; 0x9c
	att_req_send_process(chan->att);
   1d21e:	6820      	ldr	r0, [r4, #0]
   1d220:	f010 fc62 	bl	2dae8 <att_req_send_process>
	if (func) {
   1d224:	b13d      	cbz	r5, 1d236 <att_handle_rsp+0x52>
		func(chan->att->conn, err, pdu, len, params);
   1d226:	6823      	ldr	r3, [r4, #0]
   1d228:	6818      	ldr	r0, [r3, #0]
   1d22a:	f8cd 8000 	str.w	r8, [sp]
   1d22e:	464b      	mov	r3, r9
   1d230:	463a      	mov	r2, r7
   1d232:	4631      	mov	r1, r6
   1d234:	47a8      	blx	r5
}
   1d236:	2000      	movs	r0, #0
   1d238:	b002      	add	sp, #8
   1d23a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		BT_WARN("No pending ATT request");
   1d23e:	2157      	movs	r1, #87	; 0x57
   1d240:	4805      	ldr	r0, [pc, #20]	; (1d258 <att_handle_rsp+0x74>)
   1d242:	f00f f983 	bl	2c54c <z_log_minimal_printk>
	bt_att_func_t func = NULL;
   1d246:	2500      	movs	r5, #0
		goto process;
   1d248:	e7e9      	b.n	1d21e <att_handle_rsp+0x3a>
		chan->req = NULL;
   1d24a:	2500      	movs	r5, #0
   1d24c:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
		goto process;
   1d250:	e7e5      	b.n	1d21e <att_handle_rsp+0x3a>
   1d252:	bf00      	nop
   1d254:	20003b98 	.word	0x20003b98
   1d258:	0003a874 	.word	0x0003a874

0001d25c <att_error_rsp>:
{
   1d25c:	b508      	push	{r3, lr}
	rsp = (void *)buf->data;
   1d25e:	688a      	ldr	r2, [r1, #8]
	if (!chan->req || chan->req == &cancel || !rsp->error) {
   1d260:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
   1d264:	b14b      	cbz	r3, 1d27a <att_error_rsp+0x1e>
   1d266:	4908      	ldr	r1, [pc, #32]	; (1d288 <att_error_rsp+0x2c>)
   1d268:	428b      	cmp	r3, r1
   1d26a:	d008      	beq.n	1d27e <att_error_rsp+0x22>
   1d26c:	78d3      	ldrb	r3, [r2, #3]
   1d26e:	b143      	cbz	r3, 1d282 <att_error_rsp+0x26>
	return att_handle_rsp(chan, NULL, 0, err);
   1d270:	2200      	movs	r2, #0
   1d272:	4611      	mov	r1, r2
   1d274:	f7ff ffb6 	bl	1d1e4 <att_handle_rsp>
}
   1d278:	bd08      	pop	{r3, pc}
		err = BT_ATT_ERR_UNLIKELY;
   1d27a:	230e      	movs	r3, #14
   1d27c:	e7f8      	b.n	1d270 <att_error_rsp+0x14>
   1d27e:	230e      	movs	r3, #14
   1d280:	e7f6      	b.n	1d270 <att_error_rsp+0x14>
   1d282:	230e      	movs	r3, #14
   1d284:	e7f4      	b.n	1d270 <att_error_rsp+0x14>
   1d286:	bf00      	nop
   1d288:	20003b98 	.word	0x20003b98

0001d28c <att_chan_detach>:
{
   1d28c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d28e:	4606      	mov	r6, r0
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
   1d290:	4602      	mov	r2, r0
   1d292:	f852 0bf0 	ldr.w	r0, [r2], #240
   1d296:	f100 0428 	add.w	r4, r0, #40	; 0x28
	return list->head;
   1d29a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1d29c:	2100      	movs	r1, #0
   1d29e:	e00b      	b.n	1d2b8 <att_chan_detach+0x2c>
	return node->next;
   1d2a0:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
	list->head = node;
   1d2a4:	6283      	str	r3, [r0, #40]	; 0x28
	return list->tail;
   1d2a6:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_REMOVE(slist, snode)
   1d2a8:	428a      	cmp	r2, r1
   1d2aa:	d110      	bne.n	1d2ce <att_chan_detach+0x42>
	list->tail = node;
   1d2ac:	6063      	str	r3, [r4, #4]
}
   1d2ae:	e00e      	b.n	1d2ce <att_chan_detach+0x42>
	list->tail = node;
   1d2b0:	6061      	str	r1, [r4, #4]
}
   1d2b2:	e00c      	b.n	1d2ce <att_chan_detach+0x42>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1d2b4:	4619      	mov	r1, r3
   1d2b6:	681b      	ldr	r3, [r3, #0]
   1d2b8:	b1d3      	cbz	r3, 1d2f0 <att_chan_detach+0x64>
   1d2ba:	429a      	cmp	r2, r3
   1d2bc:	d1fa      	bne.n	1d2b4 <att_chan_detach+0x28>
Z_GENLIST_REMOVE(slist, snode)
   1d2be:	2900      	cmp	r1, #0
   1d2c0:	d0ee      	beq.n	1d2a0 <att_chan_detach+0x14>
	return node->next;
   1d2c2:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
	parent->next = child;
   1d2c6:	600b      	str	r3, [r1, #0]
	return list->tail;
   1d2c8:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_REMOVE(slist, snode)
   1d2ca:	429a      	cmp	r2, r3
   1d2cc:	d0f0      	beq.n	1d2b0 <att_chan_detach+0x24>
	parent->next = child;
   1d2ce:	2300      	movs	r3, #0
   1d2d0:	f8c6 30f0 	str.w	r3, [r6, #240]	; 0xf0
Z_GENLIST_REMOVE(slist, snode)
   1d2d4:	e00c      	b.n	1d2f0 <att_chan_detach+0x64>
   1d2d6:	2300      	movs	r3, #0
   1d2d8:	6023      	str	r3, [r4, #0]
   1d2da:	6063      	str	r3, [r4, #4]
   1d2dc:	60a3      	str	r3, [r4, #8]
   1d2de:	60e3      	str	r3, [r4, #12]
   1d2e0:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1d2e2:	4621      	mov	r1, r4
   1d2e4:	4813      	ldr	r0, [pc, #76]	; (1d334 <att_chan_detach+0xa8>)
   1d2e6:	f013 fb87 	bl	309f8 <k_queue_append>
		net_buf_unref(buf);
   1d2ea:	4628      	mov	r0, r5
   1d2ec:	f001 fe12 	bl	1ef14 <net_buf_unref>
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
   1d2f0:	2200      	movs	r2, #0
   1d2f2:	2300      	movs	r3, #0
   1d2f4:	f106 00a0 	add.w	r0, r6, #160	; 0xa0
   1d2f8:	f001 fc9e 	bl	1ec38 <net_buf_get>
   1d2fc:	4605      	mov	r5, r0
   1d2fe:	b168      	cbz	r0, 1d31c <att_chan_detach+0x90>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   1d300:	696c      	ldr	r4, [r5, #20]
	__ASSERT_NO_MSG(data);
   1d302:	2c00      	cmp	r4, #0
   1d304:	d1e7      	bne.n	1d2d6 <att_chan_detach+0x4a>
   1d306:	4f0c      	ldr	r7, [pc, #48]	; (1d338 <att_chan_detach+0xac>)
   1d308:	22a4      	movs	r2, #164	; 0xa4
   1d30a:	4639      	mov	r1, r7
   1d30c:	480b      	ldr	r0, [pc, #44]	; (1d33c <att_chan_detach+0xb0>)
   1d30e:	f00f f90e 	bl	2c52e <assert_print>
   1d312:	21a4      	movs	r1, #164	; 0xa4
   1d314:	4638      	mov	r0, r7
   1d316:	f00f f903 	bl	2c520 <assert_post_action>
   1d31a:	e7dc      	b.n	1d2d6 <att_chan_detach+0x4a>
	if (chan->req) {
   1d31c:	f8d6 309c 	ldr.w	r3, [r6, #156]	; 0x9c
   1d320:	b12b      	cbz	r3, 1d32e <att_chan_detach+0xa2>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
   1d322:	230e      	movs	r3, #14
   1d324:	2200      	movs	r2, #0
   1d326:	4611      	mov	r1, r2
   1d328:	4630      	mov	r0, r6
   1d32a:	f7ff ff5b 	bl	1d1e4 <att_handle_rsp>
	chan->att = NULL;
   1d32e:	2300      	movs	r3, #0
   1d330:	6033      	str	r3, [r6, #0]
}
   1d332:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1d334:	20000ecc 	.word	0x20000ecc
   1d338:	0003a610 	.word	0x0003a610
   1d33c:	00031600 	.word	0x00031600

0001d340 <att_reset>:
{
   1d340:	b570      	push	{r4, r5, r6, lr}
   1d342:	b084      	sub	sp, #16
   1d344:	9003      	str	r0, [sp, #12]
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   1d346:	e00c      	b.n	1d362 <att_reset+0x22>
   1d348:	2300      	movs	r3, #0
   1d34a:	6023      	str	r3, [r4, #0]
   1d34c:	6063      	str	r3, [r4, #4]
   1d34e:	60a3      	str	r3, [r4, #8]
   1d350:	60e3      	str	r3, [r4, #12]
   1d352:	6123      	str	r3, [r4, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1d354:	4621      	mov	r1, r4
   1d356:	481e      	ldr	r0, [pc, #120]	; (1d3d0 <att_reset+0x90>)
   1d358:	f013 fb4e 	bl	309f8 <k_queue_append>
		net_buf_unref(buf);
   1d35c:	4628      	mov	r0, r5
   1d35e:	f001 fdd9 	bl	1ef14 <net_buf_unref>
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   1d362:	2200      	movs	r2, #0
   1d364:	2300      	movs	r3, #0
   1d366:	9803      	ldr	r0, [sp, #12]
   1d368:	300c      	adds	r0, #12
   1d36a:	f001 fc65 	bl	1ec38 <net_buf_get>
   1d36e:	4605      	mov	r5, r0
   1d370:	b1c8      	cbz	r0, 1d3a6 <att_reset+0x66>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   1d372:	696c      	ldr	r4, [r5, #20]
	__ASSERT_NO_MSG(data);
   1d374:	2c00      	cmp	r4, #0
   1d376:	d1e7      	bne.n	1d348 <att_reset+0x8>
   1d378:	4e16      	ldr	r6, [pc, #88]	; (1d3d4 <att_reset+0x94>)
   1d37a:	22a4      	movs	r2, #164	; 0xa4
   1d37c:	4631      	mov	r1, r6
   1d37e:	4816      	ldr	r0, [pc, #88]	; (1d3d8 <att_reset+0x98>)
   1d380:	f00f f8d5 	bl	2c52e <assert_print>
   1d384:	21a4      	movs	r1, #164	; 0xa4
   1d386:	4630      	mov	r0, r6
   1d388:	f00f f8ca 	bl	2c520 <assert_post_action>
   1d38c:	e7dc      	b.n	1d348 <att_reset+0x8>
	list->tail = node;
   1d38e:	609a      	str	r2, [r3, #8]
}
   1d390:	e011      	b.n	1d3b6 <att_reset+0x76>
			req->func(att->conn, BT_ATT_ERR_UNLIKELY, NULL, 0,
   1d392:	6818      	ldr	r0, [r3, #0]
   1d394:	68e3      	ldr	r3, [r4, #12]
   1d396:	9300      	str	r3, [sp, #0]
   1d398:	2300      	movs	r3, #0
   1d39a:	461a      	mov	r2, r3
   1d39c:	210e      	movs	r1, #14
   1d39e:	47a8      	blx	r5
		bt_att_req_free(req);
   1d3a0:	4620      	mov	r0, r4
   1d3a2:	f7ff feef 	bl	1d184 <bt_att_req_free>
	while (!sys_slist_is_empty(&att->reqs)) {
   1d3a6:	9b03      	ldr	r3, [sp, #12]
	return list->head;
   1d3a8:	685c      	ldr	r4, [r3, #4]
   1d3aa:	b144      	cbz	r4, 1d3be <att_reset+0x7e>
	return node->next;
   1d3ac:	6822      	ldr	r2, [r4, #0]
	list->head = node;
   1d3ae:	605a      	str	r2, [r3, #4]
	return list->tail;
   1d3b0:	6899      	ldr	r1, [r3, #8]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1d3b2:	42a1      	cmp	r1, r4
   1d3b4:	d0eb      	beq.n	1d38e <att_reset+0x4e>
		if (req->func) {
   1d3b6:	6865      	ldr	r5, [r4, #4]
   1d3b8:	2d00      	cmp	r5, #0
   1d3ba:	d1ea      	bne.n	1d392 <att_reset+0x52>
   1d3bc:	e7f0      	b.n	1d3a0 <att_reset+0x60>
	att->conn = NULL;
   1d3be:	2200      	movs	r2, #0
   1d3c0:	601a      	str	r2, [r3, #0]
	k_mem_slab_free(&att_slab, (void **)&att);
   1d3c2:	a903      	add	r1, sp, #12
   1d3c4:	4805      	ldr	r0, [pc, #20]	; (1d3dc <att_reset+0x9c>)
   1d3c6:	f009 f803 	bl	263d0 <k_mem_slab_free>
}
   1d3ca:	b004      	add	sp, #16
   1d3cc:	bd70      	pop	{r4, r5, r6, pc}
   1d3ce:	bf00      	nop
   1d3d0:	20000ecc 	.word	0x20000ecc
   1d3d4:	0003a610 	.word	0x0003a610
   1d3d8:	00031600 	.word	0x00031600
   1d3dc:	20000e40 	.word	0x20000e40

0001d3e0 <att_timeout>:
{
   1d3e0:	b510      	push	{r4, lr}
   1d3e2:	4604      	mov	r4, r0
	BT_ERR("ATT Timeout");
   1d3e4:	2145      	movs	r1, #69	; 0x45
   1d3e6:	4804      	ldr	r0, [pc, #16]	; (1d3f8 <att_timeout+0x18>)
   1d3e8:	f00f f8b0 	bl	2c54c <z_log_minimal_printk>
	bt_att_disconnected(&chan->chan.chan);
   1d3ec:	f1a4 00bc 	sub.w	r0, r4, #188	; 0xbc
   1d3f0:	f010 ff00 	bl	2e1f4 <bt_att_disconnected>
}
   1d3f4:	bd10      	pop	{r4, pc}
   1d3f6:	bf00      	nop
   1d3f8:	0003a890 	.word	0x0003a890

0001d3fc <bt_att_chan_req_cancel>:
	return 0;
}

static bool bt_att_chan_req_cancel(struct bt_att_chan *chan,
				   struct bt_att_req *req)
{
   1d3fc:	b508      	push	{r3, lr}
	if (chan->req != req) {
   1d3fe:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
   1d402:	428b      	cmp	r3, r1
   1d404:	d001      	beq.n	1d40a <bt_att_chan_req_cancel+0xe>
		return false;
   1d406:	2000      	movs	r0, #0
	chan->req = &cancel;

	bt_att_req_free(req);

	return true;
}
   1d408:	bd08      	pop	{r3, pc}
	chan->req = &cancel;
   1d40a:	4b04      	ldr	r3, [pc, #16]	; (1d41c <bt_att_chan_req_cancel+0x20>)
   1d40c:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
	bt_att_req_free(req);
   1d410:	4608      	mov	r0, r1
   1d412:	f7ff feb7 	bl	1d184 <bt_att_req_free>
	return true;
   1d416:	2001      	movs	r0, #1
   1d418:	e7f6      	b.n	1d408 <bt_att_chan_req_cancel+0xc>
   1d41a:	bf00      	nop
   1d41c:	20003b98 	.word	0x20003b98

0001d420 <bt_att_send>:
{
   1d420:	b570      	push	{r4, r5, r6, lr}
   1d422:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(conn);
   1d424:	4605      	mov	r5, r0
   1d426:	b170      	cbz	r0, 1d446 <bt_att_send+0x26>
	__ASSERT_NO_MSG(buf);
   1d428:	b1d4      	cbz	r4, 1d460 <bt_att_send+0x40>
	att = att_get(conn);
   1d42a:	4628      	mov	r0, r5
   1d42c:	f7ff f802 	bl	1c434 <att_get>
	if (!att) {
   1d430:	4605      	mov	r5, r0
   1d432:	b310      	cbz	r0, 1d47a <bt_att_send+0x5a>
	net_buf_put(&att->tx_queue, buf);
   1d434:	4621      	mov	r1, r4
   1d436:	300c      	adds	r0, #12
   1d438:	f001 fd3a 	bl	1eeb0 <net_buf_put>
	att_send_process(att);
   1d43c:	4628      	mov	r0, r5
   1d43e:	f010 fbfe 	bl	2dc3e <att_send_process>
	return 0;
   1d442:	2000      	movs	r0, #0
}
   1d444:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(conn);
   1d446:	4e1b      	ldr	r6, [pc, #108]	; (1d4b4 <bt_att_send+0x94>)
   1d448:	f640 6288 	movw	r2, #3720	; 0xe88
   1d44c:	4631      	mov	r1, r6
   1d44e:	481a      	ldr	r0, [pc, #104]	; (1d4b8 <bt_att_send+0x98>)
   1d450:	f00f f86d 	bl	2c52e <assert_print>
   1d454:	f640 6188 	movw	r1, #3720	; 0xe88
   1d458:	4630      	mov	r0, r6
   1d45a:	f00f f861 	bl	2c520 <assert_post_action>
   1d45e:	e7e3      	b.n	1d428 <bt_att_send+0x8>
	__ASSERT_NO_MSG(buf);
   1d460:	4e14      	ldr	r6, [pc, #80]	; (1d4b4 <bt_att_send+0x94>)
   1d462:	f640 6289 	movw	r2, #3721	; 0xe89
   1d466:	4631      	mov	r1, r6
   1d468:	4813      	ldr	r0, [pc, #76]	; (1d4b8 <bt_att_send+0x98>)
   1d46a:	f00f f860 	bl	2c52e <assert_print>
   1d46e:	f640 6189 	movw	r1, #3721	; 0xe89
   1d472:	4630      	mov	r0, r6
   1d474:	f00f f854 	bl	2c520 <assert_post_action>
   1d478:	e7d7      	b.n	1d42a <bt_att_send+0xa>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
   1d47a:	6965      	ldr	r5, [r4, #20]
	__ASSERT_NO_MSG(data);
   1d47c:	b17d      	cbz	r5, 1d49e <bt_att_send+0x7e>
   1d47e:	2300      	movs	r3, #0
   1d480:	602b      	str	r3, [r5, #0]
   1d482:	606b      	str	r3, [r5, #4]
   1d484:	60ab      	str	r3, [r5, #8]
   1d486:	60eb      	str	r3, [r5, #12]
   1d488:	612b      	str	r3, [r5, #16]
	k_fifo_put(&free_att_tx_meta_data, data);
   1d48a:	4629      	mov	r1, r5
   1d48c:	480b      	ldr	r0, [pc, #44]	; (1d4bc <bt_att_send+0x9c>)
   1d48e:	f013 fab3 	bl	309f8 <k_queue_append>
		net_buf_unref(buf);
   1d492:	4620      	mov	r0, r4
   1d494:	f001 fd3e 	bl	1ef14 <net_buf_unref>
		return -ENOTCONN;
   1d498:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1d49c:	e7d2      	b.n	1d444 <bt_att_send+0x24>
	__ASSERT_NO_MSG(data);
   1d49e:	4e05      	ldr	r6, [pc, #20]	; (1d4b4 <bt_att_send+0x94>)
   1d4a0:	22a4      	movs	r2, #164	; 0xa4
   1d4a2:	4631      	mov	r1, r6
   1d4a4:	4804      	ldr	r0, [pc, #16]	; (1d4b8 <bt_att_send+0x98>)
   1d4a6:	f00f f842 	bl	2c52e <assert_print>
   1d4aa:	21a4      	movs	r1, #164	; 0xa4
   1d4ac:	4630      	mov	r0, r6
   1d4ae:	f00f f837 	bl	2c520 <assert_post_action>
   1d4b2:	e7e4      	b.n	1d47e <bt_att_send+0x5e>
   1d4b4:	0003a610 	.word	0x0003a610
   1d4b8:	00031600 	.word	0x00031600
   1d4bc:	20000ecc 	.word	0x20000ecc

0001d4c0 <bt_att_req_send>:
{
   1d4c0:	b570      	push	{r4, r5, r6, lr}
   1d4c2:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(conn);
   1d4c4:	4605      	mov	r5, r0
   1d4c6:	b180      	cbz	r0, 1d4ea <bt_att_req_send+0x2a>
	__ASSERT_NO_MSG(req);
   1d4c8:	b1e4      	cbz	r4, 1d504 <bt_att_req_send+0x44>
	att = att_get(conn);
   1d4ca:	4628      	mov	r0, r5
   1d4cc:	f7fe ffb2 	bl	1c434 <att_get>
	if (!att) {
   1d4d0:	4603      	mov	r3, r0
   1d4d2:	b338      	cbz	r0, 1d524 <bt_att_req_send+0x64>
	parent->next = child;
   1d4d4:	2200      	movs	r2, #0
   1d4d6:	6022      	str	r2, [r4, #0]
	return list->tail;
   1d4d8:	6882      	ldr	r2, [r0, #8]
Z_GENLIST_APPEND(slist, snode)
   1d4da:	b302      	cbz	r2, 1d51e <bt_att_req_send+0x5e>
	parent->next = child;
   1d4dc:	6014      	str	r4, [r2, #0]
	list->tail = node;
   1d4de:	6084      	str	r4, [r0, #8]
	att_req_send_process(att);
   1d4e0:	4618      	mov	r0, r3
   1d4e2:	f010 fb01 	bl	2dae8 <att_req_send_process>
	return 0;
   1d4e6:	2000      	movs	r0, #0
}
   1d4e8:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(conn);
   1d4ea:	4e10      	ldr	r6, [pc, #64]	; (1d52c <bt_att_req_send+0x6c>)
   1d4ec:	f640 629e 	movw	r2, #3742	; 0xe9e
   1d4f0:	4631      	mov	r1, r6
   1d4f2:	480f      	ldr	r0, [pc, #60]	; (1d530 <bt_att_req_send+0x70>)
   1d4f4:	f00f f81b 	bl	2c52e <assert_print>
   1d4f8:	f640 619e 	movw	r1, #3742	; 0xe9e
   1d4fc:	4630      	mov	r0, r6
   1d4fe:	f00f f80f 	bl	2c520 <assert_post_action>
   1d502:	e7e1      	b.n	1d4c8 <bt_att_req_send+0x8>
	__ASSERT_NO_MSG(req);
   1d504:	4e09      	ldr	r6, [pc, #36]	; (1d52c <bt_att_req_send+0x6c>)
   1d506:	f640 629f 	movw	r2, #3743	; 0xe9f
   1d50a:	4631      	mov	r1, r6
   1d50c:	4808      	ldr	r0, [pc, #32]	; (1d530 <bt_att_req_send+0x70>)
   1d50e:	f00f f80e 	bl	2c52e <assert_print>
   1d512:	f640 619f 	movw	r1, #3743	; 0xe9f
   1d516:	4630      	mov	r0, r6
   1d518:	f00f f802 	bl	2c520 <assert_post_action>
   1d51c:	e7d5      	b.n	1d4ca <bt_att_req_send+0xa>
   1d51e:	6084      	str	r4, [r0, #8]
	list->head = node;
   1d520:	6044      	str	r4, [r0, #4]
}
   1d522:	e7dd      	b.n	1d4e0 <bt_att_req_send+0x20>
		return -ENOTCONN;
   1d524:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1d528:	e7de      	b.n	1d4e8 <bt_att_req_send+0x28>
   1d52a:	bf00      	nop
   1d52c:	0003a610 	.word	0x0003a610
   1d530:	00031600 	.word	0x00031600

0001d534 <find_cf_cfg>:
	atomic_set(cfg->flags, 0);
}

#if defined(CONFIG_BT_GATT_CACHING)
static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
{
   1d534:	b570      	push	{r4, r5, r6, lr}
   1d536:	b082      	sub	sp, #8
   1d538:	4606      	mov	r6, r0
	int i;

	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   1d53a:	2400      	movs	r4, #0
   1d53c:	b11c      	cbz	r4, 1d546 <find_cf_cfg+0x12>
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
			return cfg;
		}
	}

	return NULL;
   1d53e:	2500      	movs	r5, #0
}
   1d540:	4628      	mov	r0, r5
   1d542:	b002      	add	sp, #8
   1d544:	bd70      	pop	{r4, r5, r6, pc}
		struct gatt_cf_cfg *cfg = &cf_cfg[i];
   1d546:	4d0f      	ldr	r5, [pc, #60]	; (1d584 <find_cf_cfg+0x50>)
   1d548:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (!conn) {
   1d54c:	b166      	cbz	r6, 1d568 <find_cf_cfg+0x34>
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   1d54e:	490d      	ldr	r1, [pc, #52]	; (1d584 <find_cf_cfg+0x50>)
   1d550:	0123      	lsls	r3, r4, #4
   1d552:	eb01 1204 	add.w	r2, r1, r4, lsl #4
   1d556:	3201      	adds	r2, #1
   1d558:	5cc9      	ldrb	r1, [r1, r3]
   1d55a:	4630      	mov	r0, r6
   1d55c:	f00f fe78 	bl	2d250 <bt_conn_is_peer_addr_le>
   1d560:	2800      	cmp	r0, #0
   1d562:	d1ed      	bne.n	1d540 <find_cf_cfg+0xc>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   1d564:	3401      	adds	r4, #1
   1d566:	e7e9      	b.n	1d53c <find_cf_cfg+0x8>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   1d568:	4628      	mov	r0, r5
   1d56a:	2300      	movs	r3, #0
   1d56c:	9300      	str	r3, [sp, #0]
   1d56e:	f8cd 3003 	str.w	r3, [sp, #3]
	return memcmp(a, b, sizeof(*a));
   1d572:	2207      	movs	r2, #7
   1d574:	4669      	mov	r1, sp
   1d576:	3001      	adds	r0, #1
   1d578:	f013 fc65 	bl	30e46 <memcmp>
   1d57c:	2800      	cmp	r0, #0
   1d57e:	d1f1      	bne.n	1d564 <find_cf_cfg+0x30>
   1d580:	e7de      	b.n	1d540 <find_cf_cfg+0xc>
   1d582:	bf00      	nop
   1d584:	20003bec 	.word	0x20003bec

0001d588 <find_sc_cfg>:
{
   1d588:	b570      	push	{r4, r5, r6, lr}
   1d58a:	4606      	mov	r6, r0
   1d58c:	460d      	mov	r5, r1
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   1d58e:	2400      	movs	r4, #0
   1d590:	b10c      	cbz	r4, 1d596 <find_sc_cfg+0xe>
	return NULL;
   1d592:	2000      	movs	r0, #0
}
   1d594:	bd70      	pop	{r4, r5, r6, pc}
		if (id == sc_cfg[i].id &&
   1d596:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   1d59a:	4a0c      	ldr	r2, [pc, #48]	; (1d5cc <find_sc_cfg+0x44>)
   1d59c:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
   1d5a0:	429e      	cmp	r6, r3
   1d5a2:	d001      	beq.n	1d5a8 <find_sc_cfg+0x20>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   1d5a4:	3401      	adds	r4, #1
   1d5a6:	e7f3      	b.n	1d590 <find_sc_cfg+0x8>
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
   1d5a8:	eb04 0044 	add.w	r0, r4, r4, lsl #1
   1d5ac:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   1d5b0:	2207      	movs	r2, #7
   1d5b2:	4629      	mov	r1, r5
   1d5b4:	3001      	adds	r0, #1
   1d5b6:	f013 fc46 	bl	30e46 <memcmp>
		if (id == sc_cfg[i].id &&
   1d5ba:	2800      	cmp	r0, #0
   1d5bc:	d1f2      	bne.n	1d5a4 <find_sc_cfg+0x1c>
			return &sc_cfg[i];
   1d5be:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1d5c2:	4802      	ldr	r0, [pc, #8]	; (1d5cc <find_sc_cfg+0x44>)
   1d5c4:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   1d5c8:	e7e4      	b.n	1d594 <find_sc_cfg+0xc>
   1d5ca:	bf00      	nop
   1d5cc:	20003c00 	.word	0x20003c00

0001d5d0 <gatt_sub_find>:
	}
}

#if defined(CONFIG_BT_GATT_CLIENT)
static struct gatt_sub *gatt_sub_find(struct bt_conn *conn)
{
   1d5d0:	b570      	push	{r4, r5, r6, lr}
   1d5d2:	b082      	sub	sp, #8
   1d5d4:	4606      	mov	r6, r0
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
   1d5d6:	2400      	movs	r4, #0
   1d5d8:	b11c      	cbz	r4, 1d5e2 <gatt_sub_find+0x12>
		} else if (bt_conn_is_peer_addr_le(conn, sub->id, &sub->peer)) {
			return sub;
		}
	}

	return NULL;
   1d5da:	2500      	movs	r5, #0
}
   1d5dc:	4628      	mov	r0, r5
   1d5de:	b002      	add	sp, #8
   1d5e0:	bd70      	pop	{r4, r5, r6, pc}
		struct gatt_sub *sub = &subscriptions[i];
   1d5e2:	4d0f      	ldr	r5, [pc, #60]	; (1d620 <gatt_sub_find+0x50>)
   1d5e4:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (!conn) {
   1d5e8:	b166      	cbz	r6, 1d604 <gatt_sub_find+0x34>
		} else if (bt_conn_is_peer_addr_le(conn, sub->id, &sub->peer)) {
   1d5ea:	490d      	ldr	r1, [pc, #52]	; (1d620 <gatt_sub_find+0x50>)
   1d5ec:	0123      	lsls	r3, r4, #4
   1d5ee:	eb01 1204 	add.w	r2, r1, r4, lsl #4
   1d5f2:	3201      	adds	r2, #1
   1d5f4:	5cc9      	ldrb	r1, [r1, r3]
   1d5f6:	4630      	mov	r0, r6
   1d5f8:	f00f fe2a 	bl	2d250 <bt_conn_is_peer_addr_le>
   1d5fc:	2800      	cmp	r0, #0
   1d5fe:	d1ed      	bne.n	1d5dc <gatt_sub_find+0xc>
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
   1d600:	3401      	adds	r4, #1
   1d602:	e7e9      	b.n	1d5d8 <gatt_sub_find+0x8>
			if (!bt_addr_le_cmp(&sub->peer, BT_ADDR_LE_ANY)) {
   1d604:	4628      	mov	r0, r5
   1d606:	2300      	movs	r3, #0
   1d608:	9300      	str	r3, [sp, #0]
   1d60a:	f8cd 3003 	str.w	r3, [sp, #3]
   1d60e:	2207      	movs	r2, #7
   1d610:	4669      	mov	r1, sp
   1d612:	3001      	adds	r0, #1
   1d614:	f013 fc17 	bl	30e46 <memcmp>
   1d618:	2800      	cmp	r0, #0
   1d61a:	d1f1      	bne.n	1d600 <gatt_sub_find+0x30>
   1d61c:	e7de      	b.n	1d5dc <gatt_sub_find+0xc>
   1d61e:	bf00      	nop
   1d620:	20003c28 	.word	0x20003c28

0001d624 <sc_clear>:
{
   1d624:	b538      	push	{r3, r4, r5, lr}
   1d626:	4604      	mov	r4, r0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   1d628:	f100 0590 	add.w	r5, r0, #144	; 0x90
   1d62c:	4629      	mov	r1, r5
   1d62e:	7a00      	ldrb	r0, [r0, #8]
   1d630:	f00f fb58 	bl	2cce4 <bt_addr_le_is_bonded>
   1d634:	b158      	cbz	r0, 1d64e <sc_clear+0x2a>
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
   1d636:	4629      	mov	r1, r5
   1d638:	7a20      	ldrb	r0, [r4, #8]
   1d63a:	f010 fff1 	bl	2e620 <bt_gatt_clear_sc>
		if (err) {
   1d63e:	4602      	mov	r2, r0
   1d640:	b900      	cbnz	r0, 1d644 <sc_clear+0x20>
}
   1d642:	bd38      	pop	{r3, r4, r5, pc}
			BT_ERR("Failed to clear SC %d", err);
   1d644:	2145      	movs	r1, #69	; 0x45
   1d646:	4806      	ldr	r0, [pc, #24]	; (1d660 <sc_clear+0x3c>)
   1d648:	f00e ff80 	bl	2c54c <z_log_minimal_printk>
   1d64c:	e7f9      	b.n	1d642 <sc_clear+0x1e>
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
   1d64e:	4629      	mov	r1, r5
   1d650:	7a20      	ldrb	r0, [r4, #8]
   1d652:	f7ff ff99 	bl	1d588 <find_sc_cfg>
		if (cfg) {
   1d656:	2800      	cmp	r0, #0
   1d658:	d0f3      	beq.n	1d642 <sc_clear+0x1e>
			clear_sc_cfg(cfg);
   1d65a:	f010 ffdc 	bl	2e616 <clear_sc_cfg>
}
   1d65e:	e7f0      	b.n	1d642 <sc_clear+0x1e>
   1d660:	0003a99c 	.word	0x0003a99c

0001d664 <bt_gatt_service_init>:
{
   1d664:	b538      	push	{r3, r4, r5, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1d666:	4b15      	ldr	r3, [pc, #84]	; (1d6bc <bt_gatt_service_init+0x58>)
   1d668:	2201      	movs	r2, #1
   1d66a:	f3bf 8f5b 	dmb	ish
   1d66e:	e853 1f00 	ldrex	r1, [r3]
   1d672:	2900      	cmp	r1, #0
   1d674:	d103      	bne.n	1d67e <bt_gatt_service_init+0x1a>
   1d676:	e843 2000 	strex	r0, r2, [r3]
   1d67a:	2800      	cmp	r0, #0
   1d67c:	d1f7      	bne.n	1d66e <bt_gatt_service_init+0xa>
   1d67e:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&service_init, 0, 1)) {
   1d682:	d11a      	bne.n	1d6ba <bt_gatt_service_init+0x56>
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   1d684:	4c0e      	ldr	r4, [pc, #56]	; (1d6c0 <bt_gatt_service_init+0x5c>)
   1d686:	e008      	b.n	1d69a <bt_gatt_service_init+0x36>
   1d688:	4b0e      	ldr	r3, [pc, #56]	; (1d6c4 <bt_gatt_service_init+0x60>)
   1d68a:	429c      	cmp	r4, r3
   1d68c:	d215      	bcs.n	1d6ba <bt_gatt_service_init+0x56>
		last_static_handle += svc->attr_count;
   1d68e:	6863      	ldr	r3, [r4, #4]
   1d690:	4a0d      	ldr	r2, [pc, #52]	; (1d6c8 <bt_gatt_service_init+0x64>)
   1d692:	8811      	ldrh	r1, [r2, #0]
   1d694:	440b      	add	r3, r1
   1d696:	8013      	strh	r3, [r2, #0]
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   1d698:	3408      	adds	r4, #8
   1d69a:	4b0a      	ldr	r3, [pc, #40]	; (1d6c4 <bt_gatt_service_init+0x60>)
   1d69c:	429c      	cmp	r4, r3
   1d69e:	d9f3      	bls.n	1d688 <bt_gatt_service_init+0x24>
   1d6a0:	4d0a      	ldr	r5, [pc, #40]	; (1d6cc <bt_gatt_service_init+0x68>)
   1d6a2:	f240 520e 	movw	r2, #1294	; 0x50e
   1d6a6:	4629      	mov	r1, r5
   1d6a8:	4809      	ldr	r0, [pc, #36]	; (1d6d0 <bt_gatt_service_init+0x6c>)
   1d6aa:	f00e ff40 	bl	2c52e <assert_print>
   1d6ae:	f240 510e 	movw	r1, #1294	; 0x50e
   1d6b2:	4628      	mov	r0, r5
   1d6b4:	f00e ff34 	bl	2c520 <assert_post_action>
   1d6b8:	e7e6      	b.n	1d688 <bt_gatt_service_init+0x24>
}
   1d6ba:	bd38      	pop	{r3, r4, r5, pc}
   1d6bc:	20003c24 	.word	0x20003c24
   1d6c0:	000312a8 	.word	0x000312a8
   1d6c4:	000312c0 	.word	0x000312c0
   1d6c8:	2000470a 	.word	0x2000470a
   1d6cc:	0003a9b8 	.word	0x0003a9b8
   1d6d0:	00031600 	.word	0x00031600

0001d6d4 <sc_indicate_rsp>:
{
   1d6d4:	b510      	push	{r4, lr}
   1d6d6:	4604      	mov	r4, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1d6d8:	4b1c      	ldr	r3, [pc, #112]	; (1d74c <sc_indicate_rsp+0x78>)
   1d6da:	f103 0250 	add.w	r2, r3, #80	; 0x50
   1d6de:	f3bf 8f5b 	dmb	ish
   1d6e2:	e852 1f00 	ldrex	r1, [r2]
   1d6e6:	f021 0102 	bic.w	r1, r1, #2
   1d6ea:	e842 1000 	strex	r0, r1, [r2]
   1d6ee:	2800      	cmp	r0, #0
   1d6f0:	d1f7      	bne.n	1d6e2 <sc_indicate_rsp+0xe>
   1d6f2:	f3bf 8f5b 	dmb	ish
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1d6f6:	f3bf 8f5b 	dmb	ish
   1d6fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   1d6fc:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   1d700:	f013 0f01 	tst.w	r3, #1
   1d704:	d104      	bne.n	1d710 <sc_indicate_rsp+0x3c>
	if (bt_att_fixed_chan_only(conn)) {
   1d706:	4620      	mov	r0, r4
   1d708:	f010 fdfb 	bl	2e302 <bt_att_fixed_chan_only>
   1d70c:	b930      	cbnz	r0, 1d71c <sc_indicate_rsp+0x48>
}
   1d70e:	bd10      	pop	{r4, pc}
	k_work_reschedule(&gatt_sc.work, timeout);
   1d710:	2200      	movs	r2, #0
   1d712:	2300      	movs	r3, #0
   1d714:	480e      	ldr	r0, [pc, #56]	; (1d750 <sc_indicate_rsp+0x7c>)
   1d716:	f00a f971 	bl	279fc <k_work_reschedule>
   1d71a:	e7f4      	b.n	1d706 <sc_indicate_rsp+0x32>
		cfg = find_cf_cfg(conn);
   1d71c:	4620      	mov	r0, r4
   1d71e:	f7ff ff09 	bl	1d534 <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
   1d722:	4603      	mov	r3, r0
   1d724:	2800      	cmp	r0, #0
   1d726:	d0f2      	beq.n	1d70e <sc_indicate_rsp+0x3a>
   1d728:	7a02      	ldrb	r2, [r0, #8]
   1d72a:	f012 0f01 	tst.w	r2, #1
   1d72e:	d0ee      	beq.n	1d70e <sc_indicate_rsp+0x3a>
			atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   1d730:	330c      	adds	r3, #12
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d732:	f3bf 8f5b 	dmb	ish
   1d736:	e853 2f00 	ldrex	r2, [r3]
   1d73a:	f042 0201 	orr.w	r2, r2, #1
   1d73e:	e843 2100 	strex	r1, r2, [r3]
   1d742:	2900      	cmp	r1, #0
   1d744:	d1f7      	bne.n	1d736 <sc_indicate_rsp+0x62>
   1d746:	f3bf 8f5b 	dmb	ish
}
   1d74a:	e7e0      	b.n	1d70e <sc_indicate_rsp+0x3a>
   1d74c:	20002398 	.word	0x20002398
   1d750:	200023b8 	.word	0x200023b8

0001d754 <gatt_write_ccc>:
	return 0;
}

static int gatt_write_ccc(struct bt_conn *conn,
			  struct bt_gatt_subscribe_params *params)
{
   1d754:	b500      	push	{lr}
   1d756:	b085      	sub	sp, #20
   1d758:	460a      	mov	r2, r1
	size_t len = sizeof(struct bt_att_write_req) + sizeof(uint16_t);

	BT_DBG("handle 0x%04x value 0x%04x", params->ccc_handle, params->value);

	return gatt_req_send(conn, gatt_write_ccc_rsp, params,
   1d75a:	2301      	movs	r3, #1
   1d75c:	9302      	str	r3, [sp, #8]
   1d75e:	2304      	movs	r3, #4
   1d760:	9301      	str	r3, [sp, #4]
   1d762:	2312      	movs	r3, #18
   1d764:	9300      	str	r3, [sp, #0]
   1d766:	4b03      	ldr	r3, [pc, #12]	; (1d774 <gatt_write_ccc+0x20>)
   1d768:	4903      	ldr	r1, [pc, #12]	; (1d778 <gatt_write_ccc+0x24>)
   1d76a:	f010 ffc7 	bl	2e6fc <gatt_req_send>
			     gatt_write_ccc_buf, BT_ATT_OP_WRITE_REQ, len,
			     BT_ATT_CHAN_OPT(params));
}
   1d76e:	b005      	add	sp, #20
   1d770:	f85d fb04 	ldr.w	pc, [sp], #4
   1d774:	0002e781 	.word	0x0002e781
   1d778:	0001d891 	.word	0x0001d891

0001d77c <disconnected_cb>:
{
   1d77c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d780:	b083      	sub	sp, #12
   1d782:	4615      	mov	r5, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   1d784:	6882      	ldr	r2, [r0, #8]
   1d786:	4b30      	ldr	r3, [pc, #192]	; (1d848 <disconnected_cb+0xcc>)
   1d788:	429a      	cmp	r2, r3
   1d78a:	d003      	beq.n	1d794 <disconnected_cb+0x18>
}
   1d78c:	2001      	movs	r0, #1
   1d78e:	b003      	add	sp, #12
   1d790:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d794:	4604      	mov	r4, r0
	ccc = attr->user_data;
   1d796:	68c7      	ldr	r7, [r0, #12]
	if (!ccc->value) {
   1d798:	897b      	ldrh	r3, [r7, #10]
   1d79a:	2b00      	cmp	r3, #0
   1d79c:	d0f6      	beq.n	1d78c <disconnected_cb+0x10>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1d79e:	2600      	movs	r6, #0
	value_used = false;
   1d7a0:	46b1      	mov	r9, r6
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1d7a2:	b15e      	cbz	r6, 1d7bc <disconnected_cb+0x40>
	if (!value_used) {
   1d7a4:	f1b9 0f00 	cmp.w	r9, #0
   1d7a8:	d1f0      	bne.n	1d78c <disconnected_cb+0x10>
		ccc->value = 0U;
   1d7aa:	2300      	movs	r3, #0
   1d7ac:	817b      	strh	r3, [r7, #10]
		if (ccc->cfg_changed) {
   1d7ae:	68fb      	ldr	r3, [r7, #12]
   1d7b0:	2b00      	cmp	r3, #0
   1d7b2:	d0eb      	beq.n	1d78c <disconnected_cb+0x10>
			ccc->cfg_changed(attr, ccc->value);
   1d7b4:	2100      	movs	r1, #0
   1d7b6:	4620      	mov	r0, r4
   1d7b8:	4798      	blx	r3
   1d7ba:	e7e7      	b.n	1d78c <disconnected_cb+0x10>
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
   1d7bc:	eb06 0886 	add.w	r8, r6, r6, lsl #2
   1d7c0:	eb07 0848 	add.w	r8, r7, r8, lsl #1
		if (!cfg->value) {
   1d7c4:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   1d7c8:	b1cb      	cbz	r3, 1d7fe <disconnected_cb+0x82>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   1d7ca:	eb06 0386 	add.w	r3, r6, r6, lsl #2
   1d7ce:	f108 0a01 	add.w	sl, r8, #1
   1d7d2:	4652      	mov	r2, sl
   1d7d4:	f817 1013 	ldrb.w	r1, [r7, r3, lsl #1]
   1d7d8:	4628      	mov	r0, r5
   1d7da:	f00f fd39 	bl	2d250 <bt_conn_is_peer_addr_le>
   1d7de:	b998      	cbnz	r0, 1d808 <disconnected_cb+0x8c>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   1d7e0:	eb06 0386 	add.w	r3, r6, r6, lsl #2
   1d7e4:	4651      	mov	r1, sl
   1d7e6:	f817 0013 	ldrb.w	r0, [r7, r3, lsl #1]
   1d7ea:	f7fe f93f 	bl	1ba6c <bt_conn_lookup_addr_le>
			if (tmp) {
   1d7ee:	4603      	mov	r3, r0
   1d7f0:	b128      	cbz	r0, 1d7fe <disconnected_cb+0x82>
				if (tmp->state == BT_CONN_CONNECTED) {
   1d7f2:	7a82      	ldrb	r2, [r0, #10]
   1d7f4:	2a07      	cmp	r2, #7
   1d7f6:	d004      	beq.n	1d802 <disconnected_cb+0x86>
				bt_conn_unref(tmp);
   1d7f8:	4618      	mov	r0, r3
   1d7fa:	f7fd ff15 	bl	1b628 <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1d7fe:	3601      	adds	r6, #1
   1d800:	e7cf      	b.n	1d7a2 <disconnected_cb+0x26>
					value_used = true;
   1d802:	f04f 0901 	mov.w	r9, #1
   1d806:	e7f7      	b.n	1d7f8 <disconnected_cb+0x7c>
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   1d808:	f105 0390 	add.w	r3, r5, #144	; 0x90
   1d80c:	9301      	str	r3, [sp, #4]
   1d80e:	4619      	mov	r1, r3
   1d810:	7a28      	ldrb	r0, [r5, #8]
   1d812:	f00f fa67 	bl	2cce4 <bt_addr_le_is_bonded>
   1d816:	b950      	cbnz	r0, 1d82e <disconnected_cb+0xb2>
				if (ccc == &sc_ccc) {
   1d818:	4b0c      	ldr	r3, [pc, #48]	; (1d84c <disconnected_cb+0xd0>)
   1d81a:	429f      	cmp	r7, r3
   1d81c:	d003      	beq.n	1d826 <disconnected_cb+0xaa>
				clear_ccc_cfg(cfg);
   1d81e:	4640      	mov	r0, r8
   1d820:	f010 fff2 	bl	2e808 <clear_ccc_cfg>
   1d824:	e7eb      	b.n	1d7fe <disconnected_cb+0x82>
					sc_clear(conn);
   1d826:	4628      	mov	r0, r5
   1d828:	f7ff fefc 	bl	1d624 <sc_clear>
   1d82c:	e7f7      	b.n	1d81e <disconnected_cb+0xa2>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1d82e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   1d832:	f8c8 3001 	str.w	r3, [r8, #1]
   1d836:	9b01      	ldr	r3, [sp, #4]
   1d838:	889a      	ldrh	r2, [r3, #4]
   1d83a:	799b      	ldrb	r3, [r3, #6]
   1d83c:	f8aa 2004 	strh.w	r2, [sl, #4]
   1d840:	f88a 3006 	strb.w	r3, [sl, #6]
}
   1d844:	e7db      	b.n	1d7fe <disconnected_cb+0x82>
   1d846:	bf00      	nop
   1d848:	0001da39 	.word	0x0001da39
   1d84c:	20000bd0 	.word	0x20000bd0

0001d850 <gatt_sub_free>:
{
   1d850:	b530      	push	{r4, r5, lr}
   1d852:	b083      	sub	sp, #12
   1d854:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(gatt_sub_is_empty(sub));
   1d856:	f010 fe18 	bl	2e48a <gatt_sub_is_empty>
   1d85a:	b140      	cbz	r0, 1d86e <gatt_sub_free+0x1e>
	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   1d85c:	2300      	movs	r3, #0
   1d85e:	9300      	str	r3, [sp, #0]
   1d860:	f8cd 3003 	str.w	r3, [sp, #3]
   1d864:	f8c4 3001 	str.w	r3, [r4, #1]
   1d868:	6063      	str	r3, [r4, #4]
}
   1d86a:	b003      	add	sp, #12
   1d86c:	bd30      	pop	{r4, r5, pc}
	__ASSERT_NO_MSG(gatt_sub_is_empty(sub));
   1d86e:	4d06      	ldr	r5, [pc, #24]	; (1d888 <gatt_sub_free+0x38>)
   1d870:	f640 428e 	movw	r2, #3214	; 0xc8e
   1d874:	4629      	mov	r1, r5
   1d876:	4805      	ldr	r0, [pc, #20]	; (1d88c <gatt_sub_free+0x3c>)
   1d878:	f00e fe59 	bl	2c52e <assert_print>
   1d87c:	f640 418e 	movw	r1, #3214	; 0xc8e
   1d880:	4628      	mov	r0, r5
   1d882:	f00e fe4d 	bl	2c520 <assert_post_action>
   1d886:	e7e9      	b.n	1d85c <gatt_sub_free+0xc>
   1d888:	0003a9b8 	.word	0x0003a9b8
   1d88c:	00031600 	.word	0x00031600

0001d890 <gatt_write_ccc_rsp>:
{
   1d890:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d892:	4606      	mov	r6, r0
   1d894:	460d      	mov	r5, r1
   1d896:	9c06      	ldr	r4, [sp, #24]
	atomic_clear_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);
   1d898:	f104 0314 	add.w	r3, r4, #20
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1d89c:	f3bf 8f5b 	dmb	ish
   1d8a0:	e853 2f00 	ldrex	r2, [r3]
   1d8a4:	f022 0204 	bic.w	r2, r2, #4
   1d8a8:	e843 2100 	strex	r1, r2, [r3]
   1d8ac:	2900      	cmp	r1, #0
   1d8ae:	d1f7      	bne.n	1d8a0 <gatt_write_ccc_rsp+0x10>
   1d8b0:	f3bf 8f5b 	dmb	ish
	if (err) {
   1d8b4:	b96d      	cbnz	r5, 1d8d2 <gatt_write_ccc_rsp+0x42>
	} else if (!params->value) {
   1d8b6:	8a23      	ldrh	r3, [r4, #16]
   1d8b8:	b923      	cbnz	r3, 1d8c4 <gatt_write_ccc_rsp+0x34>
		params->notify(conn, params, NULL, 0);
   1d8ba:	461a      	mov	r2, r3
   1d8bc:	4621      	mov	r1, r4
   1d8be:	4630      	mov	r0, r6
   1d8c0:	6827      	ldr	r7, [r4, #0]
   1d8c2:	47b8      	blx	r7
	if (params->subscribe) {
   1d8c4:	6863      	ldr	r3, [r4, #4]
   1d8c6:	b313      	cbz	r3, 1d90e <gatt_write_ccc_rsp+0x7e>
		params->subscribe(conn, err, params);
   1d8c8:	4622      	mov	r2, r4
   1d8ca:	4629      	mov	r1, r5
   1d8cc:	4630      	mov	r0, r6
   1d8ce:	4798      	blx	r3
}
   1d8d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sub = gatt_sub_find(conn);
   1d8d2:	4630      	mov	r0, r6
   1d8d4:	f7ff fe7c 	bl	1d5d0 <gatt_sub_find>
		if (!sub) {
   1d8d8:	4601      	mov	r1, r0
   1d8da:	2800      	cmp	r0, #0
   1d8dc:	d0f8      	beq.n	1d8d0 <gatt_write_ccc_rsp+0x40>
	return list->head;
   1d8de:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
   1d8e0:	b10b      	cbz	r3, 1d8e6 <gatt_write_ccc_rsp+0x56>
	return node->next;
   1d8e2:	681a      	ldr	r2, [r3, #0]
   1d8e4:	e009      	b.n	1d8fa <gatt_write_ccc_rsp+0x6a>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1d8e6:	461a      	mov	r2, r3
   1d8e8:	e007      	b.n	1d8fa <gatt_write_ccc_rsp+0x6a>
				gatt_sub_remove(conn, sub, tmp, params);
   1d8ea:	4623      	mov	r3, r4
   1d8ec:	4630      	mov	r0, r6
   1d8ee:	f010 ff97 	bl	2e820 <gatt_sub_remove>
				break;
   1d8f2:	e7e7      	b.n	1d8c4 <gatt_write_ccc_rsp+0x34>
   1d8f4:	4610      	mov	r0, r2
   1d8f6:	4613      	mov	r3, r2
   1d8f8:	4602      	mov	r2, r0
		SYS_SLIST_FOR_EACH_NODE_SAFE(&sub->list, node, tmp) {
   1d8fa:	2b00      	cmp	r3, #0
   1d8fc:	d0e2      	beq.n	1d8c4 <gatt_write_ccc_rsp+0x34>
			if (node == &params->node) {
   1d8fe:	f104 0c18 	add.w	ip, r4, #24
   1d902:	459c      	cmp	ip, r3
   1d904:	d0f1      	beq.n	1d8ea <gatt_write_ccc_rsp+0x5a>
   1d906:	2a00      	cmp	r2, #0
   1d908:	d0f4      	beq.n	1d8f4 <gatt_write_ccc_rsp+0x64>
	return node->next;
   1d90a:	6810      	ldr	r0, [r2, #0]
   1d90c:	e7f3      	b.n	1d8f6 <gatt_write_ccc_rsp+0x66>
	} else if (params->write) {
   1d90e:	68a3      	ldr	r3, [r4, #8]
   1d910:	2b00      	cmp	r3, #0
   1d912:	d0dd      	beq.n	1d8d0 <gatt_write_ccc_rsp+0x40>
		BT_WARN("write callback is deprecated, use subscribe cb instead");
   1d914:	2157      	movs	r1, #87	; 0x57
   1d916:	4804      	ldr	r0, [pc, #16]	; (1d928 <gatt_write_ccc_rsp+0x98>)
   1d918:	f00e fe18 	bl	2c54c <z_log_minimal_printk>
		params->write(conn, err, NULL);
   1d91c:	68a3      	ldr	r3, [r4, #8]
   1d91e:	2200      	movs	r2, #0
   1d920:	4629      	mov	r1, r5
   1d922:	4630      	mov	r0, r6
   1d924:	4798      	blx	r3
   1d926:	e7d3      	b.n	1d8d0 <gatt_write_ccc_rsp+0x40>
   1d928:	0003a9e8 	.word	0x0003a9e8

0001d92c <cf_write>:
{
   1d92c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d930:	461e      	mov	r6, r3
   1d932:	f8bd 3018 	ldrh.w	r3, [sp, #24]
	if (offset > sizeof(cfg->data)) {
   1d936:	2b01      	cmp	r3, #1
   1d938:	d838      	bhi.n	1d9ac <cf_write+0x80>
   1d93a:	4605      	mov	r5, r0
   1d93c:	4617      	mov	r7, r2
	if (offset + len > sizeof(cfg->data)) {
   1d93e:	46b0      	mov	r8, r6
   1d940:	4433      	add	r3, r6
   1d942:	2b01      	cmp	r3, #1
   1d944:	d835      	bhi.n	1d9b2 <cf_write+0x86>
	cfg = find_cf_cfg(conn);
   1d946:	f7ff fdf5 	bl	1d534 <find_cf_cfg>
	if (!cfg) {
   1d94a:	4604      	mov	r4, r0
   1d94c:	b318      	cbz	r0, 1d996 <cf_write+0x6a>
	if (!cfg) {
   1d94e:	b334      	cbz	r4, 1d99e <cf_write+0x72>
	if (!cf_set_value(cfg, value, len)) {
   1d950:	4632      	mov	r2, r6
   1d952:	4639      	mov	r1, r7
   1d954:	4620      	mov	r0, r4
   1d956:	f010 fd30 	bl	2e3ba <cf_set_value>
   1d95a:	b368      	cbz	r0, 1d9b8 <cf_write+0x8c>
   1d95c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   1d960:	f8c4 3001 	str.w	r3, [r4, #1]
   1d964:	f8b5 2094 	ldrh.w	r2, [r5, #148]	; 0x94
   1d968:	f895 3096 	ldrb.w	r3, [r5, #150]	; 0x96
   1d96c:	f8a4 2005 	strh.w	r2, [r4, #5]
   1d970:	71e3      	strb	r3, [r4, #7]
	cfg->id = conn->id;
   1d972:	7a2b      	ldrb	r3, [r5, #8]
   1d974:	f804 3b0c 	strb.w	r3, [r4], #12
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d978:	f3bf 8f5b 	dmb	ish
   1d97c:	e854 3f00 	ldrex	r3, [r4]
   1d980:	f043 0301 	orr.w	r3, r3, #1
   1d984:	e844 3200 	strex	r2, r3, [r4]
   1d988:	2a00      	cmp	r2, #0
   1d98a:	d1f7      	bne.n	1d97c <cf_write+0x50>
   1d98c:	f3bf 8f5b 	dmb	ish
}
   1d990:	4640      	mov	r0, r8
   1d992:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg = find_cf_cfg(NULL);
   1d996:	f7ff fdcd 	bl	1d534 <find_cf_cfg>
   1d99a:	4604      	mov	r4, r0
   1d99c:	e7d7      	b.n	1d94e <cf_write+0x22>
		BT_WARN("No space to store Client Supported Features");
   1d99e:	2157      	movs	r1, #87	; 0x57
   1d9a0:	4807      	ldr	r0, [pc, #28]	; (1d9c0 <cf_write+0x94>)
   1d9a2:	f00e fdd3 	bl	2c54c <z_log_minimal_printk>
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   1d9a6:	f06f 0810 	mvn.w	r8, #16
   1d9aa:	e7f1      	b.n	1d990 <cf_write+0x64>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1d9ac:	f06f 0806 	mvn.w	r8, #6
   1d9b0:	e7ee      	b.n	1d990 <cf_write+0x64>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   1d9b2:	f06f 080c 	mvn.w	r8, #12
   1d9b6:	e7eb      	b.n	1d990 <cf_write+0x64>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   1d9b8:	f06f 0812 	mvn.w	r8, #18
   1d9bc:	e7e8      	b.n	1d990 <cf_write+0x64>
   1d9be:	bf00      	nop
   1d9c0:	0003aa24 	.word	0x0003aa24

0001d9c4 <sc_save>:
{
   1d9c4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d9c6:	b083      	sub	sp, #12
   1d9c8:	4606      	mov	r6, r0
   1d9ca:	460f      	mov	r7, r1
   1d9cc:	4615      	mov	r5, r2
   1d9ce:	461c      	mov	r4, r3
	cfg = find_sc_cfg(id, peer);
   1d9d0:	f7ff fdda 	bl	1d588 <find_sc_cfg>
	if (!cfg) {
   1d9d4:	4684      	mov	ip, r0
   1d9d6:	b178      	cbz	r0, 1d9f8 <sc_save+0x34>
	if (!(cfg->data.start || cfg->data.end)) {
   1d9d8:	f8bc 3008 	ldrh.w	r3, [ip, #8]
   1d9dc:	b913      	cbnz	r3, 1d9e4 <sc_save+0x20>
   1d9de:	f8bc 300a 	ldrh.w	r3, [ip, #10]
   1d9e2:	b30b      	cbz	r3, 1da28 <sc_save+0x64>
	modified = update_range(&cfg->data.start, &cfg->data.end, start, end);
   1d9e4:	4623      	mov	r3, r4
   1d9e6:	462a      	mov	r2, r5
   1d9e8:	f10c 010a 	add.w	r1, ip, #10
   1d9ec:	f10c 0008 	add.w	r0, ip, #8
   1d9f0:	f010 fcc1 	bl	2e376 <update_range>
}
   1d9f4:	b003      	add	sp, #12
   1d9f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   1d9f8:	9000      	str	r0, [sp, #0]
   1d9fa:	f8cd 0003 	str.w	r0, [sp, #3]
   1d9fe:	4669      	mov	r1, sp
   1da00:	f7ff fdc2 	bl	1d588 <find_sc_cfg>
		if (!cfg) {
   1da04:	4684      	mov	ip, r0
   1da06:	b150      	cbz	r0, 1da1e <sc_save+0x5a>
		cfg->id = id;
   1da08:	4603      	mov	r3, r0
   1da0a:	f803 6b01 	strb.w	r6, [r3], #1
   1da0e:	683a      	ldr	r2, [r7, #0]
   1da10:	f8c0 2001 	str.w	r2, [r0, #1]
   1da14:	88b9      	ldrh	r1, [r7, #4]
   1da16:	79ba      	ldrb	r2, [r7, #6]
   1da18:	8099      	strh	r1, [r3, #4]
   1da1a:	719a      	strb	r2, [r3, #6]
   1da1c:	e7dc      	b.n	1d9d8 <sc_save+0x14>
			BT_ERR("unable to save SC: no cfg left");
   1da1e:	2145      	movs	r1, #69	; 0x45
   1da20:	4804      	ldr	r0, [pc, #16]	; (1da34 <sc_save+0x70>)
   1da22:	f00e fd93 	bl	2c54c <z_log_minimal_printk>
			return;
   1da26:	e7e5      	b.n	1d9f4 <sc_save+0x30>
		cfg->data.start = start;
   1da28:	f8ac 5008 	strh.w	r5, [ip, #8]
		cfg->data.end = end;
   1da2c:	f8ac 400a 	strh.w	r4, [ip, #10]
		goto done;
   1da30:	e7e0      	b.n	1d9f4 <sc_save+0x30>
   1da32:	bf00      	nop
   1da34:	0003aa58 	.word	0x0003aa58

0001da38 <bt_gatt_attr_write_ccc>:
{
   1da38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1da3c:	461c      	mov	r4, r3
   1da3e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	struct _bt_gatt_ccc *ccc = attr->user_data;
   1da42:	68cf      	ldr	r7, [r1, #12]
	if (offset) {
   1da44:	2b00      	cmp	r3, #0
   1da46:	d14f      	bne.n	1dae8 <bt_gatt_attr_write_ccc+0xb0>
   1da48:	4681      	mov	r9, r0
   1da4a:	460e      	mov	r6, r1
	if (!len || len > sizeof(uint16_t)) {
   1da4c:	1e63      	subs	r3, r4, #1
   1da4e:	b29b      	uxth	r3, r3
   1da50:	2b01      	cmp	r3, #1
   1da52:	d84c      	bhi.n	1daee <bt_gatt_attr_write_ccc+0xb6>
	if (len < sizeof(uint16_t)) {
   1da54:	2c01      	cmp	r4, #1
   1da56:	d91d      	bls.n	1da94 <bt_gatt_attr_write_ccc+0x5c>
   1da58:	7853      	ldrb	r3, [r2, #1]
   1da5a:	7815      	ldrb	r5, [r2, #0]
   1da5c:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
   1da60:	4639      	mov	r1, r7
   1da62:	4648      	mov	r0, r9
   1da64:	f010 fdab 	bl	2e5be <find_ccc_cfg>
	if (!cfg) {
   1da68:	4680      	mov	r8, r0
   1da6a:	b1a8      	cbz	r0, 1da98 <bt_gatt_attr_write_ccc+0x60>
	if (ccc->cfg_write) {
   1da6c:	693b      	ldr	r3, [r7, #16]
   1da6e:	b143      	cbz	r3, 1da82 <bt_gatt_attr_write_ccc+0x4a>
		ssize_t write = ccc->cfg_write(conn, attr, value);
   1da70:	462a      	mov	r2, r5
   1da72:	4631      	mov	r1, r6
   1da74:	4648      	mov	r0, r9
   1da76:	4798      	blx	r3
		if (write < 0) {
   1da78:	2800      	cmp	r0, #0
   1da7a:	db09      	blt.n	1da90 <bt_gatt_attr_write_ccc+0x58>
		if (write != sizeof(value) && write != 1) {
   1da7c:	3801      	subs	r0, #1
   1da7e:	2801      	cmp	r0, #1
   1da80:	d838      	bhi.n	1daf4 <bt_gatt_attr_write_ccc+0xbc>
	cfg->value = value;
   1da82:	f8a8 5008 	strh.w	r5, [r8, #8]
	if (cfg->value != ccc->value) {
   1da86:	897b      	ldrh	r3, [r7, #10]
   1da88:	429d      	cmp	r5, r3
   1da8a:	d124      	bne.n	1dad6 <bt_gatt_attr_write_ccc+0x9e>
	if (!value) {
   1da8c:	b345      	cbz	r5, 1dae0 <bt_gatt_attr_write_ccc+0xa8>
	return len;
   1da8e:	4620      	mov	r0, r4
}
   1da90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		value = *(uint8_t *)buf;
   1da94:	7815      	ldrb	r5, [r2, #0]
   1da96:	e7e3      	b.n	1da60 <bt_gatt_attr_write_ccc+0x28>
		if (!value) {
   1da98:	b90d      	cbnz	r5, 1da9e <bt_gatt_attr_write_ccc+0x66>
			return len;
   1da9a:	4620      	mov	r0, r4
   1da9c:	e7f8      	b.n	1da90 <bt_gatt_attr_write_ccc+0x58>
		cfg = find_ccc_cfg(NULL, ccc);
   1da9e:	4639      	mov	r1, r7
   1daa0:	2000      	movs	r0, #0
   1daa2:	f010 fd8c 	bl	2e5be <find_ccc_cfg>
		if (!cfg) {
   1daa6:	4680      	mov	r8, r0
   1daa8:	b170      	cbz	r0, 1dac8 <bt_gatt_attr_write_ccc+0x90>
   1daaa:	f8d9 3090 	ldr.w	r3, [r9, #144]	; 0x90
   1daae:	f8c0 3001 	str.w	r3, [r0, #1]
   1dab2:	f8b9 2094 	ldrh.w	r2, [r9, #148]	; 0x94
   1dab6:	f899 3096 	ldrb.w	r3, [r9, #150]	; 0x96
   1daba:	f8a0 2005 	strh.w	r2, [r0, #5]
   1dabe:	71c3      	strb	r3, [r0, #7]
		cfg->id = conn->id;
   1dac0:	f899 3008 	ldrb.w	r3, [r9, #8]
   1dac4:	7003      	strb	r3, [r0, #0]
   1dac6:	e7d1      	b.n	1da6c <bt_gatt_attr_write_ccc+0x34>
			BT_WARN("No space to store CCC cfg");
   1dac8:	2157      	movs	r1, #87	; 0x57
   1daca:	480c      	ldr	r0, [pc, #48]	; (1dafc <bt_gatt_attr_write_ccc+0xc4>)
   1dacc:	f00e fd3e 	bl	2c54c <z_log_minimal_printk>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   1dad0:	f06f 0010 	mvn.w	r0, #16
   1dad4:	e7dc      	b.n	1da90 <bt_gatt_attr_write_ccc+0x58>
		gatt_ccc_changed(attr, ccc);
   1dad6:	4639      	mov	r1, r7
   1dad8:	4630      	mov	r0, r6
   1dada:	f010 fca9 	bl	2e430 <gatt_ccc_changed>
   1dade:	e7d5      	b.n	1da8c <bt_gatt_attr_write_ccc+0x54>
		clear_ccc_cfg(cfg);
   1dae0:	4640      	mov	r0, r8
   1dae2:	f010 fe91 	bl	2e808 <clear_ccc_cfg>
   1dae6:	e7d2      	b.n	1da8e <bt_gatt_attr_write_ccc+0x56>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1dae8:	f06f 0006 	mvn.w	r0, #6
   1daec:	e7d0      	b.n	1da90 <bt_gatt_attr_write_ccc+0x58>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   1daee:	f06f 000c 	mvn.w	r0, #12
   1daf2:	e7cd      	b.n	1da90 <bt_gatt_attr_write_ccc+0x58>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
   1daf4:	f06f 000d 	mvn.w	r0, #13
   1daf8:	e7ca      	b.n	1da90 <bt_gatt_attr_write_ccc+0x58>
   1dafa:	bf00      	nop
   1dafc:	0003aa7c 	.word	0x0003aa7c

0001db00 <bt_gatt_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1db00:	4b13      	ldr	r3, [pc, #76]	; (1db50 <bt_gatt_init+0x50>)
   1db02:	2201      	movs	r2, #1
   1db04:	f3bf 8f5b 	dmb	ish
   1db08:	e853 1f00 	ldrex	r1, [r3]
   1db0c:	2900      	cmp	r1, #0
   1db0e:	d103      	bne.n	1db18 <bt_gatt_init+0x18>
   1db10:	e843 2000 	strex	r0, r2, [r3]
   1db14:	2800      	cmp	r0, #0
   1db16:	d1f7      	bne.n	1db08 <bt_gatt_init+0x8>
   1db18:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
   1db1c:	d116      	bne.n	1db4c <bt_gatt_init+0x4c>
{
   1db1e:	b510      	push	{r4, lr}
	bt_gatt_service_init();
   1db20:	f7ff fda0 	bl	1d664 <bt_gatt_service_init>
	list->head = NULL;
   1db24:	4b0b      	ldr	r3, [pc, #44]	; (1db54 <bt_gatt_init+0x54>)
   1db26:	2200      	movs	r2, #0
   1db28:	601a      	str	r2, [r3, #0]
	list->tail = NULL;
   1db2a:	605a      	str	r2, [r3, #4]
	k_work_init_delayable(&db_hash.work, db_hash_process);
   1db2c:	4c0a      	ldr	r4, [pc, #40]	; (1db58 <bt_gatt_init+0x58>)
   1db2e:	490b      	ldr	r1, [pc, #44]	; (1db5c <bt_gatt_init+0x5c>)
   1db30:	4620      	mov	r0, r4
   1db32:	f009 fe33 	bl	2779c <k_work_init_delayable>
		bt_long_wq_schedule(&db_hash.work, DB_HASH_TIMEOUT);
   1db36:	f44f 72a4 	mov.w	r2, #328	; 0x148
   1db3a:	2300      	movs	r3, #0
   1db3c:	4620      	mov	r0, r4
   1db3e:	f7fb fb2d 	bl	1919c <bt_long_wq_schedule>
	k_work_init_delayable(&gatt_sc.work, sc_process);
   1db42:	4907      	ldr	r1, [pc, #28]	; (1db60 <bt_gatt_init+0x60>)
   1db44:	4807      	ldr	r0, [pc, #28]	; (1db64 <bt_gatt_init+0x64>)
   1db46:	f009 fe29 	bl	2779c <k_work_init_delayable>
}
   1db4a:	bd10      	pop	{r4, pc}
   1db4c:	4770      	bx	lr
   1db4e:	bf00      	nop
   1db50:	20003bfc 	.word	0x20003bfc
   1db54:	20003be4 	.word	0x20003be4
   1db58:	20002340 	.word	0x20002340
   1db5c:	0002ebc7 	.word	0x0002ebc7
   1db60:	0001e205 	.word	0x0001e205
   1db64:	200023b8 	.word	0x200023b8

0001db68 <bt_gatt_attr_get_handle>:
{
   1db68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!attr) {
   1db6c:	b3a8      	cbz	r0, 1dbda <bt_gatt_attr_get_handle+0x72>
   1db6e:	4606      	mov	r6, r0
	if (attr->handle) {
   1db70:	8a07      	ldrh	r7, [r0, #16]
   1db72:	bbaf      	cbnz	r7, 1dbe0 <bt_gatt_attr_get_handle+0x78>
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1db74:	4d1c      	ldr	r5, [pc, #112]	; (1dbe8 <bt_gatt_attr_get_handle+0x80>)
	uint16_t handle = 1;
   1db76:	2401      	movs	r4, #1
   1db78:	e003      	b.n	1db82 <bt_gatt_attr_get_handle+0x1a>
			handle += static_svc->attr_count;
   1db7a:	686b      	ldr	r3, [r5, #4]
   1db7c:	441c      	add	r4, r3
   1db7e:	b2a4      	uxth	r4, r4
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1db80:	3508      	adds	r5, #8
   1db82:	4b1a      	ldr	r3, [pc, #104]	; (1dbec <bt_gatt_attr_get_handle+0x84>)
   1db84:	429d      	cmp	r5, r3
   1db86:	d81a      	bhi.n	1dbbe <bt_gatt_attr_get_handle+0x56>
   1db88:	4b18      	ldr	r3, [pc, #96]	; (1dbec <bt_gatt_attr_get_handle+0x84>)
   1db8a:	429d      	cmp	r5, r3
   1db8c:	d228      	bcs.n	1dbe0 <bt_gatt_attr_get_handle+0x78>
		if ((attr < &static_svc->attrs[0]) ||
   1db8e:	6829      	ldr	r1, [r5, #0]
   1db90:	42b1      	cmp	r1, r6
   1db92:	d8f2      	bhi.n	1db7a <bt_gatt_attr_get_handle+0x12>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
   1db94:	6868      	ldr	r0, [r5, #4]
   1db96:	eb00 0380 	add.w	r3, r0, r0, lsl #2
   1db9a:	009b      	lsls	r3, r3, #2
   1db9c:	3b14      	subs	r3, #20
   1db9e:	440b      	add	r3, r1
		if ((attr < &static_svc->attrs[0]) ||
   1dba0:	42b3      	cmp	r3, r6
   1dba2:	d3ea      	bcc.n	1db7a <bt_gatt_attr_get_handle+0x12>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
   1dba4:	2300      	movs	r3, #0
   1dba6:	4298      	cmp	r0, r3
   1dba8:	d9ea      	bls.n	1db80 <bt_gatt_attr_get_handle+0x18>
			if (attr == &static_svc->attrs[i]) {
   1dbaa:	eb03 0283 	add.w	r2, r3, r3, lsl #2
   1dbae:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   1dbb2:	42b2      	cmp	r2, r6
   1dbb4:	d013      	beq.n	1dbde <bt_gatt_attr_get_handle+0x76>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
   1dbb6:	3301      	adds	r3, #1
   1dbb8:	3401      	adds	r4, #1
   1dbba:	b2a4      	uxth	r4, r4
   1dbbc:	e7f3      	b.n	1dba6 <bt_gatt_attr_get_handle+0x3e>
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1dbbe:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1dbf4 <bt_gatt_attr_get_handle+0x8c>
   1dbc2:	f240 6265 	movw	r2, #1637	; 0x665
   1dbc6:	4641      	mov	r1, r8
   1dbc8:	4809      	ldr	r0, [pc, #36]	; (1dbf0 <bt_gatt_attr_get_handle+0x88>)
   1dbca:	f00e fcb0 	bl	2c52e <assert_print>
   1dbce:	f240 6165 	movw	r1, #1637	; 0x665
   1dbd2:	4640      	mov	r0, r8
   1dbd4:	f00e fca4 	bl	2c520 <assert_post_action>
   1dbd8:	e7d6      	b.n	1db88 <bt_gatt_attr_get_handle+0x20>
		return 0;
   1dbda:	2700      	movs	r7, #0
   1dbdc:	e000      	b.n	1dbe0 <bt_gatt_attr_get_handle+0x78>
				return handle;
   1dbde:	4627      	mov	r7, r4
}
   1dbe0:	4638      	mov	r0, r7
   1dbe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1dbe6:	bf00      	nop
   1dbe8:	000312a8 	.word	0x000312a8
   1dbec:	000312c0 	.word	0x000312c0
   1dbf0:	00031600 	.word	0x00031600
   1dbf4:	0003a9b8 	.word	0x0003a9b8

0001dbf8 <bt_gatt_foreach_attr_type>:
{
   1dbf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dbfc:	b089      	sub	sp, #36	; 0x24
   1dbfe:	4607      	mov	r7, r0
   1dc00:	468a      	mov	sl, r1
   1dc02:	4690      	mov	r8, r2
   1dc04:	4699      	mov	r9, r3
   1dc06:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
	if (!num_matches) {
   1dc0a:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   1dc0e:	b91b      	cbnz	r3, 1dc18 <bt_gatt_foreach_attr_type+0x20>
		num_matches = UINT16_MAX;
   1dc10:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1dc14:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
	if (start_handle <= last_static_handle) {
   1dc18:	4b21      	ldr	r3, [pc, #132]	; (1dca0 <bt_gatt_foreach_attr_type+0xa8>)
   1dc1a:	881b      	ldrh	r3, [r3, #0]
   1dc1c:	42bb      	cmp	r3, r7
   1dc1e:	d22f      	bcs.n	1dc80 <bt_gatt_foreach_attr_type+0x88>
}
   1dc20:	b009      	add	sp, #36	; 0x24
   1dc22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				handle += static_svc->attr_count;
   1dc26:	b294      	uxth	r4, r2
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1dc28:	3608      	adds	r6, #8
   1dc2a:	4b1e      	ldr	r3, [pc, #120]	; (1dca4 <bt_gatt_foreach_attr_type+0xac>)
   1dc2c:	429e      	cmp	r6, r3
   1dc2e:	d82a      	bhi.n	1dc86 <bt_gatt_foreach_attr_type+0x8e>
   1dc30:	4b1c      	ldr	r3, [pc, #112]	; (1dca4 <bt_gatt_foreach_attr_type+0xac>)
   1dc32:	429e      	cmp	r6, r3
   1dc34:	d2f4      	bcs.n	1dc20 <bt_gatt_foreach_attr_type+0x28>
			if (handle + static_svc->attr_count < start_handle) {
   1dc36:	6873      	ldr	r3, [r6, #4]
   1dc38:	18e2      	adds	r2, r4, r3
   1dc3a:	42ba      	cmp	r2, r7
   1dc3c:	d3f3      	bcc.n	1dc26 <bt_gatt_foreach_attr_type+0x2e>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   1dc3e:	2500      	movs	r5, #0
   1dc40:	9707      	str	r7, [sp, #28]
   1dc42:	6873      	ldr	r3, [r6, #4]
   1dc44:	42ab      	cmp	r3, r5
   1dc46:	d919      	bls.n	1dc7c <bt_gatt_foreach_attr_type+0x84>
				if (gatt_foreach_iter(&static_svc->attrs[i],
   1dc48:	eb05 0085 	add.w	r0, r5, r5, lsl #2
   1dc4c:	f8cd b010 	str.w	fp, [sp, #16]
   1dc50:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1dc52:	9303      	str	r3, [sp, #12]
   1dc54:	ab12      	add	r3, sp, #72	; 0x48
   1dc56:	9302      	str	r3, [sp, #8]
   1dc58:	f8cd 9004 	str.w	r9, [sp, #4]
   1dc5c:	f8cd 8000 	str.w	r8, [sp]
   1dc60:	4653      	mov	r3, sl
   1dc62:	9a07      	ldr	r2, [sp, #28]
   1dc64:	4621      	mov	r1, r4
   1dc66:	6837      	ldr	r7, [r6, #0]
   1dc68:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   1dc6c:	f010 fd0d 	bl	2e68a <gatt_foreach_iter>
   1dc70:	2800      	cmp	r0, #0
   1dc72:	d0d5      	beq.n	1dc20 <bt_gatt_foreach_attr_type+0x28>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   1dc74:	3501      	adds	r5, #1
   1dc76:	3401      	adds	r4, #1
   1dc78:	b2a4      	uxth	r4, r4
   1dc7a:	e7e2      	b.n	1dc42 <bt_gatt_foreach_attr_type+0x4a>
   1dc7c:	9f07      	ldr	r7, [sp, #28]
   1dc7e:	e7d3      	b.n	1dc28 <bt_gatt_foreach_attr_type+0x30>
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1dc80:	4e09      	ldr	r6, [pc, #36]	; (1dca8 <bt_gatt_foreach_attr_type+0xb0>)
		uint16_t handle = 1;
   1dc82:	2401      	movs	r4, #1
   1dc84:	e7d1      	b.n	1dc2a <bt_gatt_foreach_attr_type+0x32>
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1dc86:	4d09      	ldr	r5, [pc, #36]	; (1dcac <bt_gatt_foreach_attr_type+0xb4>)
   1dc88:	f240 7229 	movw	r2, #1833	; 0x729
   1dc8c:	4629      	mov	r1, r5
   1dc8e:	4808      	ldr	r0, [pc, #32]	; (1dcb0 <bt_gatt_foreach_attr_type+0xb8>)
   1dc90:	f00e fc4d 	bl	2c52e <assert_print>
   1dc94:	f240 7129 	movw	r1, #1833	; 0x729
   1dc98:	4628      	mov	r0, r5
   1dc9a:	f00e fc41 	bl	2c520 <assert_post_action>
   1dc9e:	e7c7      	b.n	1dc30 <bt_gatt_foreach_attr_type+0x38>
   1dca0:	2000470a 	.word	0x2000470a
   1dca4:	000312c0 	.word	0x000312c0
   1dca8:	000312a8 	.word	0x000312a8
   1dcac:	0003a9b8 	.word	0x0003a9b8
   1dcb0:	00031600 	.word	0x00031600

0001dcb4 <db_hash_gen>:
{
   1dcb4:	b510      	push	{r4, lr}
   1dcb6:	b0cc      	sub	sp, #304	; 0x130
	uint8_t key[16] = {};
   1dcb8:	2300      	movs	r3, #0
   1dcba:	9348      	str	r3, [sp, #288]	; 0x120
   1dcbc:	9349      	str	r3, [sp, #292]	; 0x124
   1dcbe:	934a      	str	r3, [sp, #296]	; 0x128
   1dcc0:	934b      	str	r3, [sp, #300]	; 0x12c
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   1dcc2:	aa1c      	add	r2, sp, #112	; 0x70
   1dcc4:	a948      	add	r1, sp, #288	; 0x120
   1dcc6:	a804      	add	r0, sp, #16
   1dcc8:	f00e fcd2 	bl	2c670 <tc_cmac_setup>
   1dccc:	b190      	cbz	r0, 1dcf4 <db_hash_gen+0x40>
   1dcce:	ac04      	add	r4, sp, #16
   1dcd0:	9402      	str	r4, [sp, #8]
   1dcd2:	4b1b      	ldr	r3, [pc, #108]	; (1dd40 <db_hash_gen+0x8c>)
   1dcd4:	9301      	str	r3, [sp, #4]
   1dcd6:	2200      	movs	r2, #0
   1dcd8:	9200      	str	r2, [sp, #0]
   1dcda:	4613      	mov	r3, r2
   1dcdc:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1dce0:	2001      	movs	r0, #1
   1dce2:	f7ff ff89 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	if (tc_cmac_final(db_hash.hash, &state.state) == TC_CRYPTO_FAIL) {
   1dce6:	4621      	mov	r1, r4
   1dce8:	4816      	ldr	r0, [pc, #88]	; (1dd44 <db_hash_gen+0x90>)
   1dcea:	f00e fd5e 	bl	2c7aa <tc_cmac_final>
   1dcee:	b130      	cbz	r0, 1dcfe <db_hash_gen+0x4a>
 */
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
   1dcf0:	2300      	movs	r3, #0
   1dcf2:	e013      	b.n	1dd1c <db_hash_gen+0x68>
		BT_ERR("Unable to setup AES CMAC");
   1dcf4:	2145      	movs	r1, #69	; 0x45
   1dcf6:	4814      	ldr	r0, [pc, #80]	; (1dd48 <db_hash_gen+0x94>)
   1dcf8:	f00e fc28 	bl	2c54c <z_log_minimal_printk>
		return;
   1dcfc:	e01d      	b.n	1dd3a <db_hash_gen+0x86>
		BT_ERR("Unable to calculate hash");
   1dcfe:	2145      	movs	r1, #69	; 0x45
   1dd00:	4812      	ldr	r0, [pc, #72]	; (1dd4c <db_hash_gen+0x98>)
   1dd02:	f00e fc23 	bl	2c54c <z_log_minimal_printk>
		return;
   1dd06:	e018      	b.n	1dd3a <db_hash_gen+0x86>
		uint8_t tmp = ((uint8_t *)buf)[i];
   1dd08:	4a0e      	ldr	r2, [pc, #56]	; (1dd44 <db_hash_gen+0x90>)
   1dd0a:	5cd0      	ldrb	r0, [r2, r3]

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
   1dd0c:	f1c3 010f 	rsb	r1, r3, #15
   1dd10:	f812 c001 	ldrb.w	ip, [r2, r1]
   1dd14:	f802 c003 	strb.w	ip, [r2, r3]
		((uint8_t *)buf)[length - 1 - i] = tmp;
   1dd18:	5450      	strb	r0, [r2, r1]
	for (i = 0; i < (length/2); i++) {
   1dd1a:	3301      	adds	r3, #1
   1dd1c:	2b07      	cmp	r3, #7
   1dd1e:	d9f3      	bls.n	1dd08 <db_hash_gen+0x54>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1dd20:	4b0b      	ldr	r3, [pc, #44]	; (1dd50 <db_hash_gen+0x9c>)
   1dd22:	f3bf 8f5b 	dmb	ish
   1dd26:	e853 2f00 	ldrex	r2, [r3]
   1dd2a:	f042 0204 	orr.w	r2, r2, #4
   1dd2e:	e843 2100 	strex	r1, r2, [r3]
   1dd32:	2900      	cmp	r1, #0
   1dd34:	d1f7      	bne.n	1dd26 <db_hash_gen+0x72>
   1dd36:	f3bf 8f5b 	dmb	ish
}
   1dd3a:	b04c      	add	sp, #304	; 0x130
   1dd3c:	bd10      	pop	{r4, pc}
   1dd3e:	bf00      	nop
   1dd40:	0002e4e1 	.word	0x0002e4e1
   1dd44:	20002330 	.word	0x20002330
   1dd48:	0003aa9c 	.word	0x0003aa9c
   1dd4c:	0003aabc 	.word	0x0003aabc
   1dd50:	200023e8 	.word	0x200023e8

0001dd54 <db_hash_read>:
{
   1dd54:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dd56:	b085      	sub	sp, #20
   1dd58:	4604      	mov	r4, r0
   1dd5a:	460d      	mov	r5, r1
   1dd5c:	4616      	mov	r6, r2
   1dd5e:	461f      	mov	r7, r3
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
   1dd60:	4820      	ldr	r0, [pc, #128]	; (1dde4 <db_hash_read+0x90>)
   1dd62:	f100 0140 	add.w	r1, r0, #64	; 0x40
   1dd66:	3010      	adds	r0, #16
   1dd68:	f009 fe9c 	bl	27aa4 <k_work_cancel_delayable_sync>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1dd6c:	f3bf 8f5b 	dmb	ish
   1dd70:	4b1d      	ldr	r3, [pc, #116]	; (1dde8 <db_hash_read+0x94>)
   1dd72:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   1dd74:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
   1dd78:	f013 0f04 	tst.w	r3, #4
   1dd7c:	d016      	beq.n	1ddac <db_hash_read+0x58>
	cfg = find_cf_cfg(conn);
   1dd7e:	4620      	mov	r0, r4
   1dd80:	f7ff fbd8 	bl	1d534 <find_cf_cfg>
	if (cfg &&
   1dd84:	b118      	cbz	r0, 1dd8e <db_hash_read+0x3a>
	    CF_ROBUST_CACHING(cfg) &&
   1dd86:	7a02      	ldrb	r2, [r0, #8]
	if (cfg &&
   1dd88:	f012 0f01 	tst.w	r2, #1
   1dd8c:	d112      	bne.n	1ddb4 <db_hash_read+0x60>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash,
   1dd8e:	2310      	movs	r3, #16
   1dd90:	9302      	str	r3, [sp, #8]
   1dd92:	4b14      	ldr	r3, [pc, #80]	; (1dde4 <db_hash_read+0x90>)
   1dd94:	9301      	str	r3, [sp, #4]
   1dd96:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   1dd9a:	9300      	str	r3, [sp, #0]
   1dd9c:	463b      	mov	r3, r7
   1dd9e:	4632      	mov	r2, r6
   1dda0:	4629      	mov	r1, r5
   1dda2:	4620      	mov	r0, r4
   1dda4:	f010 fdf5 	bl	2e992 <bt_gatt_attr_read>
}
   1dda8:	b005      	add	sp, #20
   1ddaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		db_hash_gen(true);
   1ddac:	2001      	movs	r0, #1
   1ddae:	f7ff ff81 	bl	1dcb4 <db_hash_gen>
   1ddb2:	e7e4      	b.n	1dd7e <db_hash_read+0x2a>
	    !atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   1ddb4:	f100 020c 	add.w	r2, r0, #12
   1ddb8:	f3bf 8f5b 	dmb	ish
   1ddbc:	68c3      	ldr	r3, [r0, #12]
   1ddbe:	f3bf 8f5b 	dmb	ish
	    CF_ROBUST_CACHING(cfg) &&
   1ddc2:	f013 0f01 	tst.w	r3, #1
   1ddc6:	d1e2      	bne.n	1dd8e <db_hash_read+0x3a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1ddc8:	f3bf 8f5b 	dmb	ish
   1ddcc:	e852 3f00 	ldrex	r3, [r2]
   1ddd0:	f043 0302 	orr.w	r3, r3, #2
   1ddd4:	e842 3100 	strex	r1, r3, [r2]
   1ddd8:	2900      	cmp	r1, #0
   1ddda:	d1f7      	bne.n	1ddcc <db_hash_read+0x78>
   1dddc:	f3bf 8f5b 	dmb	ish
}
   1dde0:	e7d5      	b.n	1dd8e <db_hash_read+0x3a>
   1dde2:	bf00      	nop
   1dde4:	20002330 	.word	0x20002330
   1dde8:	20002398 	.word	0x20002398

0001ddec <gatt_find_by_uuid>:
{
   1ddec:	b510      	push	{r4, lr}
   1ddee:	b084      	sub	sp, #16
   1ddf0:	4604      	mov	r4, r0
   1ddf2:	460a      	mov	r2, r1
	found->attr = NULL;
   1ddf4:	2300      	movs	r3, #0
   1ddf6:	6003      	str	r3, [r0, #0]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
   1ddf8:	9002      	str	r0, [sp, #8]
   1ddfa:	4907      	ldr	r1, [pc, #28]	; (1de18 <gatt_find_by_uuid+0x2c>)
   1ddfc:	9101      	str	r1, [sp, #4]
   1ddfe:	2101      	movs	r1, #1
   1de00:	9100      	str	r1, [sp, #0]
   1de02:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1de06:	8880      	ldrh	r0, [r0, #4]
   1de08:	f7ff fef6 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
   1de0c:	6820      	ldr	r0, [r4, #0]
}
   1de0e:	3800      	subs	r0, #0
   1de10:	bf18      	it	ne
   1de12:	2001      	movne	r0, #1
   1de14:	b004      	add	sp, #16
   1de16:	bd10      	pop	{r4, pc}
   1de18:	0002e483 	.word	0x0002e483

0001de1c <bt_gatt_attr_next>:
{
   1de1c:	b510      	push	{r4, lr}
   1de1e:	b086      	sub	sp, #24
	struct bt_gatt_attr *next = NULL;
   1de20:	2400      	movs	r4, #0
   1de22:	9405      	str	r4, [sp, #20]
	uint16_t handle = bt_gatt_attr_get_handle(attr);
   1de24:	f7ff fea0 	bl	1db68 <bt_gatt_attr_get_handle>
	bt_gatt_foreach_attr(handle + 1, handle + 1, find_next, &next);
   1de28:	3001      	adds	r0, #1
   1de2a:	b280      	uxth	r0, r0
   1de2c:	ab05      	add	r3, sp, #20
   1de2e:	9302      	str	r3, [sp, #8]
   1de30:	4b05      	ldr	r3, [pc, #20]	; (1de48 <bt_gatt_attr_next+0x2c>)
   1de32:	9301      	str	r3, [sp, #4]
   1de34:	9400      	str	r4, [sp, #0]
   1de36:	4623      	mov	r3, r4
   1de38:	4622      	mov	r2, r4
   1de3a:	4601      	mov	r1, r0
   1de3c:	f7ff fedc 	bl	1dbf8 <bt_gatt_foreach_attr_type>
}
   1de40:	9805      	ldr	r0, [sp, #20]
   1de42:	b006      	add	sp, #24
   1de44:	bd10      	pop	{r4, pc}
   1de46:	bf00      	nop
   1de48:	0002e42b 	.word	0x0002e42b

0001de4c <bt_gatt_is_subscribed>:
{
   1de4c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1de4e:	b089      	sub	sp, #36	; 0x24
   1de50:	460c      	mov	r4, r1
   1de52:	4615      	mov	r5, r2
	__ASSERT(conn, "invalid parameter\n");
   1de54:	4606      	mov	r6, r0
   1de56:	b130      	cbz	r0, 1de66 <bt_gatt_is_subscribed+0x1a>
	__ASSERT(attr, "invalid parameter\n");
   1de58:	b194      	cbz	r4, 1de80 <bt_gatt_is_subscribed+0x34>
	if (conn->state != BT_CONN_CONNECTED) {
   1de5a:	7ab3      	ldrb	r3, [r6, #10]
   1de5c:	2b07      	cmp	r3, #7
   1de5e:	d01c      	beq.n	1de9a <bt_gatt_is_subscribed+0x4e>
		return false;
   1de60:	2000      	movs	r0, #0
}
   1de62:	b009      	add	sp, #36	; 0x24
   1de64:	bdf0      	pop	{r4, r5, r6, r7, pc}
	__ASSERT(conn, "invalid parameter\n");
   1de66:	4f5f      	ldr	r7, [pc, #380]	; (1dfe4 <bt_gatt_is_subscribed+0x198>)
   1de68:	f640 424b 	movw	r2, #3147	; 0xc4b
   1de6c:	4639      	mov	r1, r7
   1de6e:	485e      	ldr	r0, [pc, #376]	; (1dfe8 <bt_gatt_is_subscribed+0x19c>)
   1de70:	f00e fb5d 	bl	2c52e <assert_print>
   1de74:	f640 414b 	movw	r1, #3147	; 0xc4b
   1de78:	4638      	mov	r0, r7
   1de7a:	f00e fb51 	bl	2c520 <assert_post_action>
   1de7e:	e7eb      	b.n	1de58 <bt_gatt_is_subscribed+0xc>
	__ASSERT(attr, "invalid parameter\n");
   1de80:	4f58      	ldr	r7, [pc, #352]	; (1dfe4 <bt_gatt_is_subscribed+0x198>)
   1de82:	f640 424c 	movw	r2, #3148	; 0xc4c
   1de86:	4639      	mov	r1, r7
   1de88:	4857      	ldr	r0, [pc, #348]	; (1dfe8 <bt_gatt_is_subscribed+0x19c>)
   1de8a:	f00e fb50 	bl	2c52e <assert_print>
   1de8e:	f640 414c 	movw	r1, #3148	; 0xc4c
   1de92:	4638      	mov	r0, r7
   1de94:	f00e fb44 	bl	2c520 <assert_post_action>
   1de98:	e7df      	b.n	1de5a <bt_gatt_is_subscribed+0xe>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
   1de9a:	6820      	ldr	r0, [r4, #0]
   1de9c:	2300      	movs	r3, #0
   1de9e:	f88d 3004 	strb.w	r3, [sp, #4]
   1dea2:	f642 0303 	movw	r3, #10243	; 0x2803
   1dea6:	f8ad 3006 	strh.w	r3, [sp, #6]
   1deaa:	a901      	add	r1, sp, #4
   1deac:	f00e fd66 	bl	2c97c <bt_uuid_cmp>
   1deb0:	b950      	cbnz	r0, 1dec8 <bt_gatt_is_subscribed+0x7c>
		struct bt_gatt_chrc *chrc = attr->user_data;
   1deb2:	68e3      	ldr	r3, [r4, #12]
		if (!(chrc->properties &
   1deb4:	799b      	ldrb	r3, [r3, #6]
   1deb6:	f013 0f30 	tst.w	r3, #48	; 0x30
   1deba:	d0d2      	beq.n	1de62 <bt_gatt_is_subscribed+0x16>
		attr = bt_gatt_attr_next(attr);
   1debc:	4620      	mov	r0, r4
   1debe:	f7ff ffad 	bl	1de1c <bt_gatt_attr_next>
		__ASSERT(attr, "No more attributes\n");
   1dec2:	4604      	mov	r4, r0
   1dec4:	2800      	cmp	r0, #0
   1dec6:	d045      	beq.n	1df54 <bt_gatt_is_subscribed+0x108>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
   1dec8:	6820      	ldr	r0, [r4, #0]
   1deca:	2300      	movs	r3, #0
   1decc:	f88d 3008 	strb.w	r3, [sp, #8]
   1ded0:	f642 1302 	movw	r3, #10498	; 0x2902
   1ded4:	f8ad 300a 	strh.w	r3, [sp, #10]
   1ded8:	a902      	add	r1, sp, #8
   1deda:	f00e fd4f 	bl	2c97c <bt_uuid_cmp>
   1dede:	2800      	cmp	r0, #0
   1dee0:	d145      	bne.n	1df6e <bt_gatt_is_subscribed+0x122>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   1dee2:	6820      	ldr	r0, [r4, #0]
   1dee4:	2300      	movs	r3, #0
   1dee6:	f88d 300c 	strb.w	r3, [sp, #12]
   1deea:	f642 1302 	movw	r3, #10498	; 0x2902
   1deee:	f8ad 300e 	strh.w	r3, [sp, #14]
   1def2:	a903      	add	r1, sp, #12
   1def4:	f00e fd42 	bl	2c97c <bt_uuid_cmp>
   1def8:	2800      	cmp	r0, #0
   1defa:	d04b      	beq.n	1df94 <bt_gatt_is_subscribed+0x148>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
   1defc:	6820      	ldr	r0, [r4, #0]
   1defe:	2300      	movs	r3, #0
   1df00:	f88d 3010 	strb.w	r3, [sp, #16]
   1df04:	f642 0303 	movw	r3, #10243	; 0x2803
   1df08:	f8ad 3012 	strh.w	r3, [sp, #18]
   1df0c:	a904      	add	r1, sp, #16
   1df0e:	f00e fd35 	bl	2c97c <bt_uuid_cmp>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   1df12:	2800      	cmp	r0, #0
   1df14:	d03e      	beq.n	1df94 <bt_gatt_is_subscribed+0x148>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1df16:	6820      	ldr	r0, [r4, #0]
   1df18:	2300      	movs	r3, #0
   1df1a:	f88d 3014 	strb.w	r3, [sp, #20]
   1df1e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1df22:	f8ad 3016 	strh.w	r3, [sp, #22]
   1df26:	a905      	add	r1, sp, #20
   1df28:	f00e fd28 	bl	2c97c <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
   1df2c:	b390      	cbz	r0, 1df94 <bt_gatt_is_subscribed+0x148>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   1df2e:	6820      	ldr	r0, [r4, #0]
   1df30:	2300      	movs	r3, #0
   1df32:	f88d 3018 	strb.w	r3, [sp, #24]
   1df36:	f642 0301 	movw	r3, #10241	; 0x2801
   1df3a:	f8ad 301a 	strh.w	r3, [sp, #26]
   1df3e:	a906      	add	r1, sp, #24
   1df40:	f00e fd1c 	bl	2c97c <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   1df44:	b330      	cbz	r0, 1df94 <bt_gatt_is_subscribed+0x148>
		attr = bt_gatt_attr_next(attr);
   1df46:	4620      	mov	r0, r4
   1df48:	f7ff ff68 	bl	1de1c <bt_gatt_attr_next>
		if (!attr) {
   1df4c:	4604      	mov	r4, r0
   1df4e:	2800      	cmp	r0, #0
   1df50:	d1c7      	bne.n	1dee2 <bt_gatt_is_subscribed+0x96>
   1df52:	e786      	b.n	1de62 <bt_gatt_is_subscribed+0x16>
		__ASSERT(attr, "No more attributes\n");
   1df54:	4f23      	ldr	r7, [pc, #140]	; (1dfe4 <bt_gatt_is_subscribed+0x198>)
   1df56:	f640 425d 	movw	r2, #3165	; 0xc5d
   1df5a:	4639      	mov	r1, r7
   1df5c:	4822      	ldr	r0, [pc, #136]	; (1dfe8 <bt_gatt_is_subscribed+0x19c>)
   1df5e:	f00e fae6 	bl	2c52e <assert_print>
   1df62:	f640 415d 	movw	r1, #3165	; 0xc5d
   1df66:	4638      	mov	r0, r7
   1df68:	f00e fada 	bl	2c520 <assert_post_action>
   1df6c:	e7ac      	b.n	1dec8 <bt_gatt_is_subscribed+0x7c>
		attr = bt_gatt_attr_next(attr);
   1df6e:	4620      	mov	r0, r4
   1df70:	f7ff ff54 	bl	1de1c <bt_gatt_attr_next>
		__ASSERT(attr, "No more attributes\n");
   1df74:	4604      	mov	r4, r0
   1df76:	2800      	cmp	r0, #0
   1df78:	d1b3      	bne.n	1dee2 <bt_gatt_is_subscribed+0x96>
   1df7a:	4f1a      	ldr	r7, [pc, #104]	; (1dfe4 <bt_gatt_is_subscribed+0x198>)
   1df7c:	f640 4263 	movw	r2, #3171	; 0xc63
   1df80:	4639      	mov	r1, r7
   1df82:	4819      	ldr	r0, [pc, #100]	; (1dfe8 <bt_gatt_is_subscribed+0x19c>)
   1df84:	f00e fad3 	bl	2c52e <assert_print>
   1df88:	f640 4163 	movw	r1, #3171	; 0xc63
   1df8c:	4638      	mov	r0, r7
   1df8e:	f00e fac7 	bl	2c520 <assert_post_action>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   1df92:	e7a6      	b.n	1dee2 <bt_gatt_is_subscribed+0x96>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
   1df94:	6820      	ldr	r0, [r4, #0]
   1df96:	2300      	movs	r3, #0
   1df98:	f88d 301c 	strb.w	r3, [sp, #28]
   1df9c:	f642 1302 	movw	r3, #10498	; 0x2902
   1dfa0:	f8ad 301e 	strh.w	r3, [sp, #30]
   1dfa4:	a907      	add	r1, sp, #28
   1dfa6:	f00e fce9 	bl	2c97c <bt_uuid_cmp>
   1dfaa:	b920      	cbnz	r0, 1dfb6 <bt_gatt_is_subscribed+0x16a>
	ccc = attr->user_data;
   1dfac:	68e7      	ldr	r7, [r4, #12]
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
   1dfae:	2400      	movs	r4, #0
   1dfb0:	b11c      	cbz	r4, 1dfba <bt_gatt_is_subscribed+0x16e>
	return false;
   1dfb2:	2000      	movs	r0, #0
   1dfb4:	e755      	b.n	1de62 <bt_gatt_is_subscribed+0x16>
		return false;
   1dfb6:	2000      	movs	r0, #0
   1dfb8:	e753      	b.n	1de62 <bt_gatt_is_subscribed+0x16>
		if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer) &&
   1dfba:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   1dfbe:	eb07 0243 	add.w	r2, r7, r3, lsl #1
   1dfc2:	3201      	adds	r2, #1
   1dfc4:	f817 1013 	ldrb.w	r1, [r7, r3, lsl #1]
   1dfc8:	4630      	mov	r0, r6
   1dfca:	f00f f941 	bl	2d250 <bt_conn_is_peer_addr_le>
   1dfce:	b138      	cbz	r0, 1dfe0 <bt_gatt_is_subscribed+0x194>
		    (ccc_type & ccc->cfg[i].value)) {
   1dfd0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   1dfd4:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   1dfd8:	891b      	ldrh	r3, [r3, #8]
		if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer) &&
   1dfda:	422b      	tst	r3, r5
   1dfdc:	f47f af41 	bne.w	1de62 <bt_gatt_is_subscribed+0x16>
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
   1dfe0:	3401      	adds	r4, #1
   1dfe2:	e7e5      	b.n	1dfb0 <bt_gatt_is_subscribed+0x164>
   1dfe4:	0003a9b8 	.word	0x0003a9b8
   1dfe8:	00031600 	.word	0x00031600

0001dfec <gatt_indicate>:
{
   1dfec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1dff0:	b082      	sub	sp, #8
   1dff2:	4605      	mov	r5, r0
   1dff4:	460f      	mov	r7, r1
   1dff6:	4614      	mov	r4, r2
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   1dff8:	2294      	movs	r2, #148	; 0x94
   1dffa:	6861      	ldr	r1, [r4, #4]
   1dffc:	f010 fdec 	bl	2ebd8 <bt_gatt_check_perm>
   1e000:	2800      	cmp	r0, #0
   1e002:	d13c      	bne.n	1e07e <gatt_indicate+0x92>
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_INDICATE)) {
   1e004:	2202      	movs	r2, #2
   1e006:	6861      	ldr	r1, [r4, #4]
   1e008:	4628      	mov	r0, r5
   1e00a:	f7ff ff1f 	bl	1de4c <bt_gatt_is_subscribed>
   1e00e:	2800      	cmp	r0, #0
   1e010:	d03c      	beq.n	1e08c <gatt_indicate+0xa0>
	len = sizeof(*ind) + params->len;
   1e012:	8aa6      	ldrh	r6, [r4, #20]
   1e014:	3602      	adds	r6, #2
	req = gatt_req_alloc(gatt_indicate_rsp, params, NULL,
   1e016:	9600      	str	r6, [sp, #0]
   1e018:	231d      	movs	r3, #29
   1e01a:	2200      	movs	r2, #0
   1e01c:	4621      	mov	r1, r4
   1e01e:	4827      	ldr	r0, [pc, #156]	; (1e0bc <gatt_indicate+0xd0>)
   1e020:	f010 fb5e 	bl	2e6e0 <gatt_req_alloc>
	if (!req) {
   1e024:	4681      	mov	r9, r0
   1e026:	2800      	cmp	r0, #0
   1e028:	d045      	beq.n	1e0b6 <gatt_indicate+0xca>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE, len);
   1e02a:	4632      	mov	r2, r6
   1e02c:	211d      	movs	r1, #29
   1e02e:	4628      	mov	r0, r5
   1e030:	f7fe fd3c 	bl	1caac <bt_att_create_pdu>
	if (!buf) {
   1e034:	4680      	mov	r8, r0
   1e036:	b380      	cbz	r0, 1e09a <gatt_indicate+0xae>
	bt_att_set_tx_meta_data(buf, NULL, NULL, BT_ATT_CHAN_OPT(params));
   1e038:	2301      	movs	r3, #1
   1e03a:	2200      	movs	r2, #0
   1e03c:	4611      	mov	r1, r2
   1e03e:	f010 f993 	bl	2e368 <bt_att_set_tx_meta_data>
   1e042:	f108 0a08 	add.w	sl, r8, #8
   1e046:	2102      	movs	r1, #2
   1e048:	4650      	mov	r0, sl
   1e04a:	f001 f87b 	bl	1f144 <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
   1e04e:	4606      	mov	r6, r0
   1e050:	f826 7b02 	strh.w	r7, [r6], #2
   1e054:	8aa1      	ldrh	r1, [r4, #20]
   1e056:	4650      	mov	r0, sl
   1e058:	f001 f874 	bl	1f144 <net_buf_simple_add>
   1e05c:	8aa2      	ldrh	r2, [r4, #20]
   1e05e:	6921      	ldr	r1, [r4, #16]
   1e060:	4630      	mov	r0, r6
   1e062:	f012 ff00 	bl	30e66 <memcpy>
	req->buf = buf;
   1e066:	f8c9 8008 	str.w	r8, [r9, #8]
	err = bt_att_req_send(conn, req);
   1e06a:	4649      	mov	r1, r9
   1e06c:	4628      	mov	r0, r5
   1e06e:	f7ff fa27 	bl	1d4c0 <bt_att_req_send>
	if (err) {
   1e072:	4604      	mov	r4, r0
   1e074:	b9d8      	cbnz	r0, 1e0ae <gatt_indicate+0xc2>
}
   1e076:	4620      	mov	r0, r4
   1e078:	b002      	add	sp, #8
   1e07a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		BT_WARN("Link is not encrypted");
   1e07e:	2157      	movs	r1, #87	; 0x57
   1e080:	480f      	ldr	r0, [pc, #60]	; (1e0c0 <gatt_indicate+0xd4>)
   1e082:	f00e fa63 	bl	2c54c <z_log_minimal_printk>
		return -EPERM;
   1e086:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1e08a:	e7f4      	b.n	1e076 <gatt_indicate+0x8a>
			BT_WARN("Device is not subscribed to characteristic");
   1e08c:	2157      	movs	r1, #87	; 0x57
   1e08e:	480d      	ldr	r0, [pc, #52]	; (1e0c4 <gatt_indicate+0xd8>)
   1e090:	f00e fa5c 	bl	2c54c <z_log_minimal_printk>
			return -EINVAL;
   1e094:	f06f 0415 	mvn.w	r4, #21
   1e098:	e7ed      	b.n	1e076 <gatt_indicate+0x8a>
		BT_WARN("No buffer available to send indication");
   1e09a:	2157      	movs	r1, #87	; 0x57
   1e09c:	480a      	ldr	r0, [pc, #40]	; (1e0c8 <gatt_indicate+0xdc>)
   1e09e:	f00e fa55 	bl	2c54c <z_log_minimal_printk>
		bt_att_req_free(req);
   1e0a2:	4648      	mov	r0, r9
   1e0a4:	f7ff f86e 	bl	1d184 <bt_att_req_free>
		return -ENOMEM;
   1e0a8:	f06f 040b 	mvn.w	r4, #11
   1e0ac:	e7e3      	b.n	1e076 <gatt_indicate+0x8a>
		bt_att_req_free(req);
   1e0ae:	4648      	mov	r0, r9
   1e0b0:	f7ff f868 	bl	1d184 <bt_att_req_free>
   1e0b4:	e7df      	b.n	1e076 <gatt_indicate+0x8a>
		return -ENOMEM;
   1e0b6:	f06f 040b 	mvn.w	r4, #11
   1e0ba:	e7dc      	b.n	1e076 <gatt_indicate+0x8a>
   1e0bc:	0002e461 	.word	0x0002e461
   1e0c0:	0003aadc 	.word	0x0003aadc
   1e0c4:	0003aaf8 	.word	0x0003aaf8
   1e0c8:	0003ab28 	.word	0x0003ab28

0001e0cc <bt_gatt_indicate>:
{
   1e0cc:	b570      	push	{r4, r5, r6, lr}
   1e0ce:	b08c      	sub	sp, #48	; 0x30
   1e0d0:	4605      	mov	r5, r0
	__ASSERT(params, "invalid parameters\n");
   1e0d2:	460c      	mov	r4, r1
   1e0d4:	2900      	cmp	r1, #0
   1e0d6:	d041      	beq.n	1e15c <bt_gatt_indicate+0x90>
	__ASSERT(params->attr || params->uuid, "invalid parameters\n");
   1e0d8:	6863      	ldr	r3, [r4, #4]
   1e0da:	2b00      	cmp	r3, #0
   1e0dc:	d04b      	beq.n	1e176 <bt_gatt_indicate+0xaa>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1e0de:	f3bf 8f5b 	dmb	ish
   1e0e2:	4b44      	ldr	r3, [pc, #272]	; (1e1f4 <bt_gatt_indicate+0x128>)
   1e0e4:	681b      	ldr	r3, [r3, #0]
   1e0e6:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   1e0ea:	f013 0f04 	tst.w	r3, #4
   1e0ee:	d078      	beq.n	1e1e2 <bt_gatt_indicate+0x116>
	if (conn && conn->state != BT_CONN_CONNECTED) {
   1e0f0:	b115      	cbz	r5, 1e0f8 <bt_gatt_indicate+0x2c>
   1e0f2:	7aab      	ldrb	r3, [r5, #10]
   1e0f4:	2b07      	cmp	r3, #7
   1e0f6:	d177      	bne.n	1e1e8 <bt_gatt_indicate+0x11c>
	data.attr = params->attr;
   1e0f8:	6860      	ldr	r0, [r4, #4]
   1e0fa:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
   1e0fc:	f7ff fd34 	bl	1db68 <bt_gatt_attr_get_handle>
   1e100:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
   1e104:	6821      	ldr	r1, [r4, #0]
   1e106:	2900      	cmp	r1, #0
   1e108:	d045      	beq.n	1e196 <bt_gatt_indicate+0xca>
		if (!gatt_find_by_uuid(&data, params->uuid)) {
   1e10a:	a805      	add	r0, sp, #20
   1e10c:	f7ff fe6e 	bl	1ddec <gatt_find_by_uuid>
   1e110:	2800      	cmp	r0, #0
   1e112:	d06c      	beq.n	1e1ee <bt_gatt_indicate+0x122>
		params->attr = data.attr;
   1e114:	9b05      	ldr	r3, [sp, #20]
   1e116:	6063      	str	r3, [r4, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
   1e118:	9b05      	ldr	r3, [sp, #20]
   1e11a:	6818      	ldr	r0, [r3, #0]
   1e11c:	2300      	movs	r3, #0
   1e11e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
   1e122:	f642 0303 	movw	r3, #10243	; 0x2803
   1e126:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
   1e12a:	a90b      	add	r1, sp, #44	; 0x2c
   1e12c:	f00e fc26 	bl	2c97c <bt_uuid_cmp>
   1e130:	b948      	cbnz	r0, 1e146 <bt_gatt_indicate+0x7a>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
   1e132:	9805      	ldr	r0, [sp, #20]
   1e134:	68c3      	ldr	r3, [r0, #12]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
   1e136:	799b      	ldrb	r3, [r3, #6]
   1e138:	f013 0f20 	tst.w	r3, #32
   1e13c:	d030      	beq.n	1e1a0 <bt_gatt_indicate+0xd4>
		data.handle = bt_gatt_attr_value_handle(data.attr);
   1e13e:	f010 fce9 	bl	2eb14 <bt_gatt_attr_value_handle>
   1e142:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (conn) {
   1e146:	b375      	cbz	r5, 1e1a6 <bt_gatt_indicate+0xda>
		params->_ref = 1;
   1e148:	2301      	movs	r3, #1
   1e14a:	75a3      	strb	r3, [r4, #22]
		return gatt_indicate(conn, data.handle, params);
   1e14c:	4622      	mov	r2, r4
   1e14e:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   1e152:	4628      	mov	r0, r5
   1e154:	f7ff ff4a 	bl	1dfec <gatt_indicate>
}
   1e158:	b00c      	add	sp, #48	; 0x30
   1e15a:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(params, "invalid parameters\n");
   1e15c:	4e26      	ldr	r6, [pc, #152]	; (1e1f8 <bt_gatt_indicate+0x12c>)
   1e15e:	f640 320b 	movw	r2, #2827	; 0xb0b
   1e162:	4631      	mov	r1, r6
   1e164:	4825      	ldr	r0, [pc, #148]	; (1e1fc <bt_gatt_indicate+0x130>)
   1e166:	f00e f9e2 	bl	2c52e <assert_print>
   1e16a:	f640 310b 	movw	r1, #2827	; 0xb0b
   1e16e:	4630      	mov	r0, r6
   1e170:	f00e f9d6 	bl	2c520 <assert_post_action>
   1e174:	e7b0      	b.n	1e0d8 <bt_gatt_indicate+0xc>
	__ASSERT(params->attr || params->uuid, "invalid parameters\n");
   1e176:	6823      	ldr	r3, [r4, #0]
   1e178:	2b00      	cmp	r3, #0
   1e17a:	d1b0      	bne.n	1e0de <bt_gatt_indicate+0x12>
   1e17c:	4e1e      	ldr	r6, [pc, #120]	; (1e1f8 <bt_gatt_indicate+0x12c>)
   1e17e:	f640 320c 	movw	r2, #2828	; 0xb0c
   1e182:	4631      	mov	r1, r6
   1e184:	481d      	ldr	r0, [pc, #116]	; (1e1fc <bt_gatt_indicate+0x130>)
   1e186:	f00e f9d2 	bl	2c52e <assert_print>
   1e18a:	f640 310c 	movw	r1, #2828	; 0xb0c
   1e18e:	4630      	mov	r0, r6
   1e190:	f00e f9c6 	bl	2c520 <assert_post_action>
   1e194:	e7a3      	b.n	1e0de <bt_gatt_indicate+0x12>
		if (!data.handle) {
   1e196:	2800      	cmp	r0, #0
   1e198:	d1be      	bne.n	1e118 <bt_gatt_indicate+0x4c>
			return -ENOENT;
   1e19a:	f06f 0001 	mvn.w	r0, #1
   1e19e:	e7db      	b.n	1e158 <bt_gatt_indicate+0x8c>
			return -EINVAL;
   1e1a0:	f06f 0015 	mvn.w	r0, #21
   1e1a4:	e7d8      	b.n	1e158 <bt_gatt_indicate+0x8c>
	data.err = -ENOTCONN;
   1e1a6:	f06f 037f 	mvn.w	r3, #127	; 0x7f
   1e1aa:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
   1e1ac:	2302      	movs	r3, #2
   1e1ae:	f8ad 3020 	strh.w	r3, [sp, #32]
	data.ind_params = params;
   1e1b2:	9409      	str	r4, [sp, #36]	; 0x24
	params->_ref = 0;
   1e1b4:	2300      	movs	r3, #0
   1e1b6:	75a3      	strb	r3, [r4, #22]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   1e1b8:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
   1e1bc:	f642 1202 	movw	r2, #10498	; 0x2902
   1e1c0:	f8ad 202a 	strh.w	r2, [sp, #42]	; 0x2a
   1e1c4:	aa05      	add	r2, sp, #20
   1e1c6:	9202      	str	r2, [sp, #8]
   1e1c8:	4a0d      	ldr	r2, [pc, #52]	; (1e200 <bt_gatt_indicate+0x134>)
   1e1ca:	9201      	str	r2, [sp, #4]
   1e1cc:	2201      	movs	r2, #1
   1e1ce:	9200      	str	r2, [sp, #0]
   1e1d0:	aa0a      	add	r2, sp, #40	; 0x28
   1e1d2:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e1d6:	f8bd 0018 	ldrh.w	r0, [sp, #24]
   1e1da:	f7ff fd0d 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	return data.err;
   1e1de:	9807      	ldr	r0, [sp, #28]
   1e1e0:	e7ba      	b.n	1e158 <bt_gatt_indicate+0x8c>
		return -EAGAIN;
   1e1e2:	f06f 000a 	mvn.w	r0, #10
   1e1e6:	e7b7      	b.n	1e158 <bt_gatt_indicate+0x8c>
		return -ENOTCONN;
   1e1e8:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1e1ec:	e7b4      	b.n	1e158 <bt_gatt_indicate+0x8c>
			return -ENOENT;
   1e1ee:	f06f 0001 	mvn.w	r0, #1
   1e1f2:	e7b1      	b.n	1e158 <bt_gatt_indicate+0x8c>
   1e1f4:	200004ec 	.word	0x200004ec
   1e1f8:	0003a9b8 	.word	0x0003a9b8
   1e1fc:	00031600 	.word	0x00031600
   1e200:	0001e581 	.word	0x0001e581

0001e204 <sc_process>:
{
   1e204:	b570      	push	{r4, r5, r6, lr}
   1e206:	b082      	sub	sp, #8
   1e208:	4604      	mov	r4, r0
	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
   1e20a:	f100 0530 	add.w	r5, r0, #48	; 0x30
   1e20e:	f3bf 8f5b 	dmb	ish
   1e212:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1e214:	f3bf 8f5b 	dmb	ish
   1e218:	f013 0f02 	tst.w	r3, #2
   1e21c:	d12b      	bne.n	1e276 <sc_process+0x72>
	sc_range[0] = sys_cpu_to_le16(sc->start);
   1e21e:	f834 3c08 	ldrh.w	r3, [r4, #-8]
   1e222:	f8ad 3004 	strh.w	r3, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(sc->end);
   1e226:	f834 3c06 	ldrh.w	r3, [r4, #-6]
   1e22a:	f8ad 3006 	strh.w	r3, [sp, #6]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1e22e:	f3bf 8f5b 	dmb	ish
   1e232:	e855 3f00 	ldrex	r3, [r5]
   1e236:	f023 0301 	bic.w	r3, r3, #1
   1e23a:	e845 3200 	strex	r2, r3, [r5]
   1e23e:	2a00      	cmp	r2, #0
   1e240:	d1f7      	bne.n	1e232 <sc_process+0x2e>
   1e242:	f3bf 8f5b 	dmb	ish
	sc->start = 0U;
   1e246:	2000      	movs	r0, #0
   1e248:	f824 0c08 	strh.w	r0, [r4, #-8]
	sc->end = 0U;
   1e24c:	f824 0c06 	strh.w	r0, [r4, #-6]
	sc->params.attr = &_1_gatt_svc.attrs[2];
   1e250:	4b16      	ldr	r3, [pc, #88]	; (1e2ac <sc_process+0xa8>)
   1e252:	f844 3c1c 	str.w	r3, [r4, #-28]
	sc->params.func = sc_indicate_rsp;
   1e256:	4b16      	ldr	r3, [pc, #88]	; (1e2b0 <sc_process+0xac>)
   1e258:	f844 3c18 	str.w	r3, [r4, #-24]
	sc->params.data = &sc_range[0];
   1e25c:	ab01      	add	r3, sp, #4
   1e25e:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.len = sizeof(sc_range);
   1e262:	2304      	movs	r3, #4
   1e264:	f824 3c0c 	strh.w	r3, [r4, #-12]
	if (bt_gatt_indicate(NULL, &sc->params)) {
   1e268:	f1a4 0120 	sub.w	r1, r4, #32
   1e26c:	f7ff ff2e 	bl	1e0cc <bt_gatt_indicate>
   1e270:	b170      	cbz	r0, 1e290 <sc_process+0x8c>
}
   1e272:	b002      	add	sp, #8
   1e274:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(!atomic_test_bit(sc->flags, SC_INDICATE_PENDING),
   1e276:	4e0f      	ldr	r6, [pc, #60]	; (1e2b4 <sc_process+0xb0>)
   1e278:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
   1e27c:	4631      	mov	r1, r6
   1e27e:	480e      	ldr	r0, [pc, #56]	; (1e2b8 <sc_process+0xb4>)
   1e280:	f00e f955 	bl	2c52e <assert_print>
   1e284:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
   1e288:	4630      	mov	r0, r6
   1e28a:	f00e f949 	bl	2c520 <assert_post_action>
   1e28e:	e7c6      	b.n	1e21e <sc_process+0x1a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1e290:	f3bf 8f5b 	dmb	ish
   1e294:	e855 3f00 	ldrex	r3, [r5]
   1e298:	f043 0302 	orr.w	r3, r3, #2
   1e29c:	e845 3200 	strex	r2, r3, [r5]
   1e2a0:	2a00      	cmp	r2, #0
   1e2a2:	d1f7      	bne.n	1e294 <sc_process+0x90>
   1e2a4:	f3bf 8f5b 	dmb	ish
   1e2a8:	e7e3      	b.n	1e272 <sc_process+0x6e>
   1e2aa:	bf00      	nop
   1e2ac:	0003ac1c 	.word	0x0003ac1c
   1e2b0:	0001d6d5 	.word	0x0001d6d5
   1e2b4:	0003a9b8 	.word	0x0003a9b8
   1e2b8:	00031600 	.word	0x00031600

0001e2bc <sc_restore>:
{
   1e2bc:	b510      	push	{r4, lr}
   1e2be:	b082      	sub	sp, #8
   1e2c0:	4604      	mov	r4, r0
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
   1e2c2:	f100 0190 	add.w	r1, r0, #144	; 0x90
   1e2c6:	7a00      	ldrb	r0, [r0, #8]
   1e2c8:	f7ff f95e 	bl	1d588 <find_sc_cfg>
	if (!cfg) {
   1e2cc:	b1f0      	cbz	r0, 1e30c <sc_restore+0x50>
   1e2ce:	4603      	mov	r3, r0
	if (!(cfg->data.start || cfg->data.end)) {
   1e2d0:	8902      	ldrh	r2, [r0, #8]
   1e2d2:	b90a      	cbnz	r2, 1e2d8 <sc_restore+0x1c>
   1e2d4:	8941      	ldrh	r1, [r0, #10]
   1e2d6:	b1c9      	cbz	r1, 1e30c <sc_restore+0x50>
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
   1e2d8:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
   1e2dc:	895b      	ldrh	r3, [r3, #10]
   1e2de:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
   1e2e2:	4620      	mov	r0, r4
   1e2e4:	f7fd fab6 	bl	1b854 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   1e2e8:	490c      	ldr	r1, [pc, #48]	; (1e31c <sc_restore+0x60>)
   1e2ea:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1e2ee:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   1e2f2:	4a0b      	ldr	r2, [pc, #44]	; (1e320 <sc_restore+0x64>)
   1e2f4:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
   1e2f6:	4a0b      	ldr	r2, [pc, #44]	; (1e324 <sc_restore+0x68>)
   1e2f8:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
   1e2fa:	aa01      	add	r2, sp, #4
   1e2fc:	611a      	str	r2, [r3, #16]
	sc_restore_params[index].len = sizeof(sc_range);
   1e2fe:	2204      	movs	r2, #4
   1e300:	829a      	strh	r2, [r3, #20]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   1e302:	4619      	mov	r1, r3
   1e304:	4620      	mov	r0, r4
   1e306:	f7ff fee1 	bl	1e0cc <bt_gatt_indicate>
   1e30a:	b908      	cbnz	r0, 1e310 <sc_restore+0x54>
}
   1e30c:	b002      	add	sp, #8
   1e30e:	bd10      	pop	{r4, pc}
		BT_ERR("SC restore indication failed");
   1e310:	2145      	movs	r1, #69	; 0x45
   1e312:	4805      	ldr	r0, [pc, #20]	; (1e328 <sc_restore+0x6c>)
   1e314:	f00e f91a 	bl	2c54c <z_log_minimal_printk>
   1e318:	e7f8      	b.n	1e30c <sc_restore+0x50>
   1e31a:	bf00      	nop
   1e31c:	20003c0c 	.word	0x20003c0c
   1e320:	0003ac1c 	.word	0x0003ac1c
   1e324:	0002e637 	.word	0x0002e637
   1e328:	0003ab54 	.word	0x0003ab54

0001e32c <update_ccc>:
{
   1e32c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_conn *conn = data->conn;
   1e32e:	6817      	ldr	r7, [r2, #0]
	if (attr->write != bt_gatt_attr_write_ccc) {
   1e330:	6882      	ldr	r2, [r0, #8]
   1e332:	4b1b      	ldr	r3, [pc, #108]	; (1e3a0 <update_ccc+0x74>)
   1e334:	429a      	cmp	r2, r3
   1e336:	d001      	beq.n	1e33c <update_ccc+0x10>
}
   1e338:	2001      	movs	r0, #1
   1e33a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e33c:	4604      	mov	r4, r0
	ccc = attr->user_data;
   1e33e:	68c6      	ldr	r6, [r0, #12]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1e340:	2500      	movs	r5, #0
   1e342:	2d00      	cmp	r5, #0
   1e344:	d1f8      	bne.n	1e338 <update_ccc+0xc>
		if (!cfg->value ||
   1e346:	eb05 0385 	add.w	r3, r5, r5, lsl #2
   1e34a:	eb06 0343 	add.w	r3, r6, r3, lsl #1
   1e34e:	891b      	ldrh	r3, [r3, #8]
   1e350:	b31b      	cbz	r3, 1e39a <update_ccc+0x6e>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
   1e352:	eb05 0385 	add.w	r3, r5, r5, lsl #2
   1e356:	eb06 0243 	add.w	r2, r6, r3, lsl #1
   1e35a:	3201      	adds	r2, #1
   1e35c:	f816 1013 	ldrb.w	r1, [r6, r3, lsl #1]
   1e360:	4638      	mov	r0, r7
   1e362:	f00e ff75 	bl	2d250 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
   1e366:	b1c0      	cbz	r0, 1e39a <update_ccc+0x6e>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
   1e368:	f44f 7295 	mov.w	r2, #298	; 0x12a
   1e36c:	4621      	mov	r1, r4
   1e36e:	4638      	mov	r0, r7
   1e370:	f010 fc32 	bl	2ebd8 <bt_gatt_check_perm>
		if (err) {
   1e374:	b108      	cbz	r0, 1e37a <update_ccc+0x4e>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
   1e376:	2803      	cmp	r0, #3
   1e378:	d00a      	beq.n	1e390 <update_ccc+0x64>
		gatt_ccc_changed(attr, ccc);
   1e37a:	4631      	mov	r1, r6
   1e37c:	4620      	mov	r0, r4
   1e37e:	f010 f857 	bl	2e430 <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
   1e382:	4b08      	ldr	r3, [pc, #32]	; (1e3a4 <update_ccc+0x78>)
   1e384:	429e      	cmp	r6, r3
   1e386:	d1d7      	bne.n	1e338 <update_ccc+0xc>
			sc_restore(conn);
   1e388:	4638      	mov	r0, r7
   1e38a:	f7ff ff97 	bl	1e2bc <sc_restore>
   1e38e:	e7d3      	b.n	1e338 <update_ccc+0xc>
				BT_WARN("CCC %p not writable", attr);
   1e390:	4622      	mov	r2, r4
   1e392:	2157      	movs	r1, #87	; 0x57
   1e394:	4804      	ldr	r0, [pc, #16]	; (1e3a8 <update_ccc+0x7c>)
   1e396:	f00e f8d9 	bl	2c54c <z_log_minimal_printk>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1e39a:	3501      	adds	r5, #1
   1e39c:	e7d1      	b.n	1e342 <update_ccc+0x16>
   1e39e:	bf00      	nop
   1e3a0:	0001da39 	.word	0x0001da39
   1e3a4:	20000bd0 	.word	0x20000bd0
   1e3a8:	0003ab78 	.word	0x0003ab78

0001e3ac <gatt_notify>:
{
   1e3ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1e3b0:	4605      	mov	r5, r0
   1e3b2:	460f      	mov	r7, r1
   1e3b4:	4614      	mov	r4, r2
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   1e3b6:	2294      	movs	r2, #148	; 0x94
   1e3b8:	6861      	ldr	r1, [r4, #4]
   1e3ba:	f010 fc0d 	bl	2ebd8 <bt_gatt_check_perm>
   1e3be:	bb58      	cbnz	r0, 1e418 <gatt_notify+0x6c>
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_NOTIFY)) {
   1e3c0:	2201      	movs	r2, #1
   1e3c2:	6861      	ldr	r1, [r4, #4]
   1e3c4:	4628      	mov	r0, r5
   1e3c6:	f7ff fd41 	bl	1de4c <bt_gatt_is_subscribed>
   1e3ca:	b360      	cbz	r0, 1e426 <gatt_notify+0x7a>
				sizeof(*nfy) + params->len);
   1e3cc:	89a2      	ldrh	r2, [r4, #12]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   1e3ce:	3202      	adds	r2, #2
   1e3d0:	211b      	movs	r1, #27
   1e3d2:	4628      	mov	r0, r5
   1e3d4:	f7fe fb6a 	bl	1caac <bt_att_create_pdu>
	if (!buf) {
   1e3d8:	4680      	mov	r8, r0
   1e3da:	b358      	cbz	r0, 1e434 <gatt_notify+0x88>
   1e3dc:	f100 0908 	add.w	r9, r0, #8
   1e3e0:	2102      	movs	r1, #2
   1e3e2:	4648      	mov	r0, r9
   1e3e4:	f000 feae 	bl	1f144 <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
   1e3e8:	4606      	mov	r6, r0
   1e3ea:	f826 7b02 	strh.w	r7, [r6], #2
   1e3ee:	89a1      	ldrh	r1, [r4, #12]
   1e3f0:	4648      	mov	r0, r9
   1e3f2:	f000 fea7 	bl	1f144 <net_buf_simple_add>
   1e3f6:	89a2      	ldrh	r2, [r4, #12]
   1e3f8:	68a1      	ldr	r1, [r4, #8]
   1e3fa:	4630      	mov	r0, r6
   1e3fc:	f012 fd33 	bl	30e66 <memcpy>
	bt_att_set_tx_meta_data(buf, params->func, params->user_data, BT_ATT_CHAN_OPT(params));
   1e400:	2301      	movs	r3, #1
   1e402:	6962      	ldr	r2, [r4, #20]
   1e404:	6921      	ldr	r1, [r4, #16]
   1e406:	4640      	mov	r0, r8
   1e408:	f00f ffae 	bl	2e368 <bt_att_set_tx_meta_data>
	return bt_att_send(conn, buf);
   1e40c:	4641      	mov	r1, r8
   1e40e:	4628      	mov	r0, r5
   1e410:	f7ff f806 	bl	1d420 <bt_att_send>
}
   1e414:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		BT_WARN("Link is not encrypted");
   1e418:	2157      	movs	r1, #87	; 0x57
   1e41a:	480a      	ldr	r0, [pc, #40]	; (1e444 <gatt_notify+0x98>)
   1e41c:	f00e f896 	bl	2c54c <z_log_minimal_printk>
		return -EPERM;
   1e420:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e424:	e7f6      	b.n	1e414 <gatt_notify+0x68>
			BT_WARN("Device is not subscribed to characteristic");
   1e426:	2157      	movs	r1, #87	; 0x57
   1e428:	4807      	ldr	r0, [pc, #28]	; (1e448 <gatt_notify+0x9c>)
   1e42a:	f00e f88f 	bl	2c54c <z_log_minimal_printk>
			return -EINVAL;
   1e42e:	f06f 0015 	mvn.w	r0, #21
   1e432:	e7ef      	b.n	1e414 <gatt_notify+0x68>
		BT_WARN("No buffer available to send notification");
   1e434:	2157      	movs	r1, #87	; 0x57
   1e436:	4805      	ldr	r0, [pc, #20]	; (1e44c <gatt_notify+0xa0>)
   1e438:	f00e f888 	bl	2c54c <z_log_minimal_printk>
		return -ENOMEM;
   1e43c:	f06f 000b 	mvn.w	r0, #11
   1e440:	e7e8      	b.n	1e414 <gatt_notify+0x68>
   1e442:	bf00      	nop
   1e444:	0003aadc 	.word	0x0003aadc
   1e448:	0003aaf8 	.word	0x0003aaf8
   1e44c:	0003ab94 	.word	0x0003ab94

0001e450 <bt_gatt_notify_cb>:
{
   1e450:	b570      	push	{r4, r5, r6, lr}
   1e452:	b08c      	sub	sp, #48	; 0x30
   1e454:	4604      	mov	r4, r0
	__ASSERT(params, "invalid parameters\n");
   1e456:	460d      	mov	r5, r1
   1e458:	2900      	cmp	r1, #0
   1e45a:	d03f      	beq.n	1e4dc <bt_gatt_notify_cb+0x8c>
	__ASSERT(params->attr || params->uuid, "invalid parameters\n");
   1e45c:	686b      	ldr	r3, [r5, #4]
   1e45e:	2b00      	cmp	r3, #0
   1e460:	d049      	beq.n	1e4f6 <bt_gatt_notify_cb+0xa6>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1e462:	f3bf 8f5b 	dmb	ish
   1e466:	4b42      	ldr	r3, [pc, #264]	; (1e570 <bt_gatt_notify_cb+0x120>)
   1e468:	681b      	ldr	r3, [r3, #0]
   1e46a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   1e46e:	f013 0f04 	tst.w	r3, #4
   1e472:	d074      	beq.n	1e55e <bt_gatt_notify_cb+0x10e>
	if (conn && conn->state != BT_CONN_CONNECTED) {
   1e474:	b114      	cbz	r4, 1e47c <bt_gatt_notify_cb+0x2c>
   1e476:	7aa3      	ldrb	r3, [r4, #10]
   1e478:	2b07      	cmp	r3, #7
   1e47a:	d173      	bne.n	1e564 <bt_gatt_notify_cb+0x114>
	data.attr = params->attr;
   1e47c:	6868      	ldr	r0, [r5, #4]
   1e47e:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
   1e480:	f7ff fb72 	bl	1db68 <bt_gatt_attr_get_handle>
   1e484:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
   1e488:	6829      	ldr	r1, [r5, #0]
   1e48a:	2900      	cmp	r1, #0
   1e48c:	d043      	beq.n	1e516 <bt_gatt_notify_cb+0xc6>
		if (!gatt_find_by_uuid(&data, params->uuid)) {
   1e48e:	a805      	add	r0, sp, #20
   1e490:	f7ff fcac 	bl	1ddec <gatt_find_by_uuid>
   1e494:	2800      	cmp	r0, #0
   1e496:	d068      	beq.n	1e56a <bt_gatt_notify_cb+0x11a>
		params->attr = data.attr;
   1e498:	9b05      	ldr	r3, [sp, #20]
   1e49a:	606b      	str	r3, [r5, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
   1e49c:	9b05      	ldr	r3, [sp, #20]
   1e49e:	6818      	ldr	r0, [r3, #0]
   1e4a0:	2300      	movs	r3, #0
   1e4a2:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
   1e4a6:	f642 0303 	movw	r3, #10243	; 0x2803
   1e4aa:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
   1e4ae:	a90b      	add	r1, sp, #44	; 0x2c
   1e4b0:	f00e fa64 	bl	2c97c <bt_uuid_cmp>
   1e4b4:	b948      	cbnz	r0, 1e4ca <bt_gatt_notify_cb+0x7a>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
   1e4b6:	9805      	ldr	r0, [sp, #20]
   1e4b8:	68c3      	ldr	r3, [r0, #12]
		if (!(chrc->properties & BT_GATT_CHRC_NOTIFY)) {
   1e4ba:	799b      	ldrb	r3, [r3, #6]
   1e4bc:	f013 0f10 	tst.w	r3, #16
   1e4c0:	d02e      	beq.n	1e520 <bt_gatt_notify_cb+0xd0>
		data.handle = bt_gatt_attr_value_handle(data.attr);
   1e4c2:	f010 fb27 	bl	2eb14 <bt_gatt_attr_value_handle>
   1e4c6:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (conn) {
   1e4ca:	b364      	cbz	r4, 1e526 <bt_gatt_notify_cb+0xd6>
		return gatt_notify(conn, data.handle, params);
   1e4cc:	462a      	mov	r2, r5
   1e4ce:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   1e4d2:	4620      	mov	r0, r4
   1e4d4:	f7ff ff6a 	bl	1e3ac <gatt_notify>
}
   1e4d8:	b00c      	add	sp, #48	; 0x30
   1e4da:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(params, "invalid parameters\n");
   1e4dc:	4e25      	ldr	r6, [pc, #148]	; (1e574 <bt_gatt_notify_cb+0x124>)
   1e4de:	f640 222b 	movw	r2, #2603	; 0xa2b
   1e4e2:	4631      	mov	r1, r6
   1e4e4:	4824      	ldr	r0, [pc, #144]	; (1e578 <bt_gatt_notify_cb+0x128>)
   1e4e6:	f00e f822 	bl	2c52e <assert_print>
   1e4ea:	f640 212b 	movw	r1, #2603	; 0xa2b
   1e4ee:	4630      	mov	r0, r6
   1e4f0:	f00e f816 	bl	2c520 <assert_post_action>
   1e4f4:	e7b2      	b.n	1e45c <bt_gatt_notify_cb+0xc>
	__ASSERT(params->attr || params->uuid, "invalid parameters\n");
   1e4f6:	682b      	ldr	r3, [r5, #0]
   1e4f8:	2b00      	cmp	r3, #0
   1e4fa:	d1b2      	bne.n	1e462 <bt_gatt_notify_cb+0x12>
   1e4fc:	4e1d      	ldr	r6, [pc, #116]	; (1e574 <bt_gatt_notify_cb+0x124>)
   1e4fe:	f640 222c 	movw	r2, #2604	; 0xa2c
   1e502:	4631      	mov	r1, r6
   1e504:	481c      	ldr	r0, [pc, #112]	; (1e578 <bt_gatt_notify_cb+0x128>)
   1e506:	f00e f812 	bl	2c52e <assert_print>
   1e50a:	f640 212c 	movw	r1, #2604	; 0xa2c
   1e50e:	4630      	mov	r0, r6
   1e510:	f00e f806 	bl	2c520 <assert_post_action>
   1e514:	e7a5      	b.n	1e462 <bt_gatt_notify_cb+0x12>
		if (!data.handle) {
   1e516:	2800      	cmp	r0, #0
   1e518:	d1c0      	bne.n	1e49c <bt_gatt_notify_cb+0x4c>
			return -ENOENT;
   1e51a:	f06f 0001 	mvn.w	r0, #1
   1e51e:	e7db      	b.n	1e4d8 <bt_gatt_notify_cb+0x88>
			return -EINVAL;
   1e520:	f06f 0015 	mvn.w	r0, #21
   1e524:	e7d8      	b.n	1e4d8 <bt_gatt_notify_cb+0x88>
	data.err = -ENOTCONN;
   1e526:	f06f 037f 	mvn.w	r3, #127	; 0x7f
   1e52a:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_NOTIFY;
   1e52c:	2201      	movs	r2, #1
   1e52e:	f8ad 2020 	strh.w	r2, [sp, #32]
	data.nfy_params = params;
   1e532:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
   1e534:	2300      	movs	r3, #0
   1e536:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
   1e53a:	f642 1102 	movw	r1, #10498	; 0x2902
   1e53e:	f8ad 102a 	strh.w	r1, [sp, #42]	; 0x2a
   1e542:	a905      	add	r1, sp, #20
   1e544:	9102      	str	r1, [sp, #8]
   1e546:	490d      	ldr	r1, [pc, #52]	; (1e57c <bt_gatt_notify_cb+0x12c>)
   1e548:	9101      	str	r1, [sp, #4]
   1e54a:	9200      	str	r2, [sp, #0]
   1e54c:	aa0a      	add	r2, sp, #40	; 0x28
   1e54e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e552:	f8bd 0018 	ldrh.w	r0, [sp, #24]
   1e556:	f7ff fb4f 	bl	1dbf8 <bt_gatt_foreach_attr_type>
	return data.err;
   1e55a:	9807      	ldr	r0, [sp, #28]
   1e55c:	e7bc      	b.n	1e4d8 <bt_gatt_notify_cb+0x88>
		return -EAGAIN;
   1e55e:	f06f 000a 	mvn.w	r0, #10
   1e562:	e7b9      	b.n	1e4d8 <bt_gatt_notify_cb+0x88>
		return -ENOTCONN;
   1e564:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1e568:	e7b6      	b.n	1e4d8 <bt_gatt_notify_cb+0x88>
			return -ENOENT;
   1e56a:	f06f 0001 	mvn.w	r0, #1
   1e56e:	e7b3      	b.n	1e4d8 <bt_gatt_notify_cb+0x88>
   1e570:	200004ec 	.word	0x200004ec
   1e574:	0003a9b8 	.word	0x0003a9b8
   1e578:	00031600 	.word	0x00031600
   1e57c:	0001e581 	.word	0x0001e581

0001e580 <notify_cb>:
{
   1e580:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1e584:	b082      	sub	sp, #8
   1e586:	4616      	mov	r6, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
   1e588:	6882      	ldr	r2, [r0, #8]
   1e58a:	4b59      	ldr	r3, [pc, #356]	; (1e6f0 <notify_cb+0x170>)
   1e58c:	429a      	cmp	r2, r3
   1e58e:	d005      	beq.n	1e59c <notify_cb+0x1c>
		return BT_GATT_ITER_CONTINUE;
   1e590:	f04f 0901 	mov.w	r9, #1
}
   1e594:	4648      	mov	r0, r9
   1e596:	b002      	add	sp, #8
   1e598:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e59c:	4607      	mov	r7, r0
	ccc = attr->user_data;
   1e59e:	68c5      	ldr	r5, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
   1e5a0:	4b54      	ldr	r3, [pc, #336]	; (1e6f4 <notify_cb+0x174>)
   1e5a2:	429d      	cmp	r5, r3
   1e5a4:	d031      	beq.n	1e60a <notify_cb+0x8a>
			err = 0;
   1e5a6:	2400      	movs	r4, #0
   1e5a8:	e067      	b.n	1e67a <notify_cb+0xfa>
				sc = (struct sc_data *)data->ind_params->data;
   1e5aa:	6933      	ldr	r3, [r6, #16]
   1e5ac:	691a      	ldr	r2, [r3, #16]
				sc_save(cfg->id, &cfg->peer,
   1e5ae:	eb04 0044 	add.w	r0, r4, r4, lsl #1
   1e5b2:	8853      	ldrh	r3, [r2, #2]
   1e5b4:	8812      	ldrh	r2, [r2, #0]
   1e5b6:	4641      	mov	r1, r8
   1e5b8:	f8df c13c 	ldr.w	ip, [pc, #316]	; 1e6f8 <notify_cb+0x178>
   1e5bc:	f81c 0020 	ldrb.w	r0, [ip, r0, lsl #2]
   1e5c0:	f7ff fa00 	bl	1d9c4 <sc_save>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   1e5c4:	3401      	adds	r4, #1
   1e5c6:	2c00      	cmp	r4, #0
   1e5c8:	d1ed      	bne.n	1e5a6 <notify_cb+0x26>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   1e5ca:	eb04 0844 	add.w	r8, r4, r4, lsl #1
   1e5ce:	4b4a      	ldr	r3, [pc, #296]	; (1e6f8 <notify_cb+0x178>)
   1e5d0:	eb03 0888 	add.w	r8, r3, r8, lsl #2
   1e5d4:	f108 0801 	add.w	r8, r8, #1
   1e5d8:	2300      	movs	r3, #0
   1e5da:	9300      	str	r3, [sp, #0]
   1e5dc:	f8cd 3003 	str.w	r3, [sp, #3]
	return memcmp(a, b, sizeof(*a));
   1e5e0:	2207      	movs	r2, #7
   1e5e2:	4669      	mov	r1, sp
   1e5e4:	4640      	mov	r0, r8
   1e5e6:	f012 fc2e 	bl	30e46 <memcmp>
   1e5ea:	2800      	cmp	r0, #0
   1e5ec:	d0ea      	beq.n	1e5c4 <notify_cb+0x44>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
   1e5ee:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   1e5f2:	2207      	movs	r2, #7
   1e5f4:	4641      	mov	r1, r8
   1e5f6:	4840      	ldr	r0, [pc, #256]	; (1e6f8 <notify_cb+0x178>)
   1e5f8:	f810 0023 	ldrb.w	r0, [r0, r3, lsl #2]
   1e5fc:	f7fd fa9e 	bl	1bb3c <bt_conn_lookup_state_le>
			if (!conn) {
   1e600:	2800      	cmp	r0, #0
   1e602:	d0d2      	beq.n	1e5aa <notify_cb+0x2a>
			bt_conn_unref(conn);
   1e604:	f7fd f810 	bl	1b628 <bt_conn_unref>
   1e608:	e7dc      	b.n	1e5c4 <notify_cb+0x44>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   1e60a:	2400      	movs	r4, #0
   1e60c:	e7db      	b.n	1e5c6 <notify_cb+0x46>
			bt_conn_unref(conn);
   1e60e:	f7fd f80b 	bl	1b628 <bt_conn_unref>
			continue;
   1e612:	e031      	b.n	1e678 <notify_cb+0xf8>
			bt_conn_unref(conn);
   1e614:	4640      	mov	r0, r8
   1e616:	f7fd f807 	bl	1b628 <bt_conn_unref>
			continue;
   1e61a:	e02d      	b.n	1e678 <notify_cb+0xf8>
			BT_WARN("Link is not encrypted");
   1e61c:	2157      	movs	r1, #87	; 0x57
   1e61e:	4837      	ldr	r0, [pc, #220]	; (1e6fc <notify_cb+0x17c>)
   1e620:	f00d ff94 	bl	2c54c <z_log_minimal_printk>
			bt_conn_unref(conn);
   1e624:	4640      	mov	r0, r8
   1e626:	f7fc ffff 	bl	1b628 <bt_conn_unref>
			continue;
   1e62a:	e025      	b.n	1e678 <notify_cb+0xf8>
		    (cfg->value & BT_GATT_CCC_INDICATE)) {
   1e62c:	eb04 0284 	add.w	r2, r4, r4, lsl #2
   1e630:	eb05 0242 	add.w	r2, r5, r2, lsl #1
   1e634:	8912      	ldrh	r2, [r2, #8]
		if ((data->type == BT_GATT_CCC_INDICATE) &&
   1e636:	f012 0f02 	tst.w	r2, #2
   1e63a:	d049      	beq.n	1e6d0 <notify_cb+0x150>
			err = gatt_indicate(conn, data->handle, data->ind_params);
   1e63c:	6932      	ldr	r2, [r6, #16]
   1e63e:	88b1      	ldrh	r1, [r6, #4]
   1e640:	4640      	mov	r0, r8
   1e642:	f7ff fcd3 	bl	1dfec <gatt_indicate>
			if (err == 0) {
   1e646:	4682      	mov	sl, r0
   1e648:	b970      	cbnz	r0, 1e668 <notify_cb+0xe8>
				data->ind_params->_ref++;
   1e64a:	6932      	ldr	r2, [r6, #16]
   1e64c:	7d93      	ldrb	r3, [r2, #22]
   1e64e:	3301      	adds	r3, #1
   1e650:	7593      	strb	r3, [r2, #22]
   1e652:	e009      	b.n	1e668 <notify_cb+0xe8>
			   (cfg->value & BT_GATT_CCC_NOTIFY)) {
   1e654:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   1e658:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   1e65c:	891b      	ldrh	r3, [r3, #8]
		} else if ((data->type == BT_GATT_CCC_NOTIFY) &&
   1e65e:	f013 0f01 	tst.w	r3, #1
   1e662:	d13a      	bne.n	1e6da <notify_cb+0x15a>
			err = 0;
   1e664:	f04f 0a00 	mov.w	sl, #0
		bt_conn_unref(conn);
   1e668:	4640      	mov	r0, r8
   1e66a:	f7fc ffdd 	bl	1b628 <bt_conn_unref>
		if (err < 0) {
   1e66e:	f1ba 0f00 	cmp.w	sl, #0
   1e672:	db8f      	blt.n	1e594 <notify_cb+0x14>
		data->err = 0;
   1e674:	2300      	movs	r3, #0
   1e676:	60b3      	str	r3, [r6, #8]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1e678:	3401      	adds	r4, #1
   1e67a:	2c00      	cmp	r4, #0
   1e67c:	d134      	bne.n	1e6e8 <notify_cb+0x168>
		if (cfg->value != data->type) {
   1e67e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   1e682:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   1e686:	f8b3 c008 	ldrh.w	ip, [r3, #8]
   1e68a:	89b3      	ldrh	r3, [r6, #12]
   1e68c:	459c      	cmp	ip, r3
   1e68e:	d1f3      	bne.n	1e678 <notify_cb+0xf8>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   1e690:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   1e694:	eb05 0143 	add.w	r1, r5, r3, lsl #1
   1e698:	3101      	adds	r1, #1
   1e69a:	f815 0013 	ldrb.w	r0, [r5, r3, lsl #1]
   1e69e:	f7fd f9e5 	bl	1ba6c <bt_conn_lookup_addr_le>
		if (!conn) {
   1e6a2:	4680      	mov	r8, r0
   1e6a4:	2800      	cmp	r0, #0
   1e6a6:	d0e7      	beq.n	1e678 <notify_cb+0xf8>
		if (conn->state != BT_CONN_CONNECTED) {
   1e6a8:	7a83      	ldrb	r3, [r0, #10]
   1e6aa:	2b07      	cmp	r3, #7
   1e6ac:	d1af      	bne.n	1e60e <notify_cb+0x8e>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
   1e6ae:	696b      	ldr	r3, [r5, #20]
   1e6b0:	b11b      	cbz	r3, 1e6ba <notify_cb+0x13a>
   1e6b2:	4639      	mov	r1, r7
   1e6b4:	4798      	blx	r3
   1e6b6:	2800      	cmp	r0, #0
   1e6b8:	d0ac      	beq.n	1e614 <notify_cb+0x94>
		if (bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
   1e6ba:	2294      	movs	r2, #148	; 0x94
   1e6bc:	4639      	mov	r1, r7
   1e6be:	4640      	mov	r0, r8
   1e6c0:	f010 fa8a 	bl	2ebd8 <bt_gatt_check_perm>
   1e6c4:	4681      	mov	r9, r0
   1e6c6:	2800      	cmp	r0, #0
   1e6c8:	d1a8      	bne.n	1e61c <notify_cb+0x9c>
		if ((data->type == BT_GATT_CCC_INDICATE) &&
   1e6ca:	89b3      	ldrh	r3, [r6, #12]
   1e6cc:	2b02      	cmp	r3, #2
   1e6ce:	d0ad      	beq.n	1e62c <notify_cb+0xac>
		} else if ((data->type == BT_GATT_CCC_NOTIFY) &&
   1e6d0:	2b01      	cmp	r3, #1
   1e6d2:	d0bf      	beq.n	1e654 <notify_cb+0xd4>
			err = 0;
   1e6d4:	f04f 0a00 	mov.w	sl, #0
   1e6d8:	e7c6      	b.n	1e668 <notify_cb+0xe8>
			err = gatt_notify(conn, data->handle, data->nfy_params);
   1e6da:	6932      	ldr	r2, [r6, #16]
   1e6dc:	88b1      	ldrh	r1, [r6, #4]
   1e6de:	4640      	mov	r0, r8
   1e6e0:	f7ff fe64 	bl	1e3ac <gatt_notify>
   1e6e4:	4682      	mov	sl, r0
   1e6e6:	e7bf      	b.n	1e668 <notify_cb+0xe8>
	return BT_GATT_ITER_CONTINUE;
   1e6e8:	f04f 0901 	mov.w	r9, #1
   1e6ec:	e752      	b.n	1e594 <notify_cb+0x14>
   1e6ee:	bf00      	nop
   1e6f0:	0001da39 	.word	0x0001da39
   1e6f4:	20000bd0 	.word	0x20000bd0
   1e6f8:	20003c00 	.word	0x20003c00
   1e6fc:	0003aadc 	.word	0x0003aadc

0001e700 <bt_gatt_unsubscribe>:
	return 0;
}

int bt_gatt_unsubscribe(struct bt_conn *conn,
			struct bt_gatt_subscribe_params *params)
{
   1e700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e704:	460d      	mov	r5, r1
	struct gatt_sub *sub;
	struct bt_gatt_subscribe_params *tmp;
	bool has_subscription = false, found = false;

	__ASSERT(conn, "invalid parameters\n");
   1e706:	4680      	mov	r8, r0
   1e708:	b180      	cbz	r0, 1e72c <bt_gatt_unsubscribe+0x2c>
	__ASSERT(params, "invalid parameters\n");
   1e70a:	b1e5      	cbz	r5, 1e746 <bt_gatt_unsubscribe+0x46>

	if (conn->state != BT_CONN_CONNECTED) {
   1e70c:	f898 300a 	ldrb.w	r3, [r8, #10]
   1e710:	2b07      	cmp	r3, #7
   1e712:	d17d      	bne.n	1e810 <bt_gatt_unsubscribe+0x110>
		return -ENOTCONN;
	}

	sub = gatt_sub_find(conn);
   1e714:	4640      	mov	r0, r8
   1e716:	f7fe ff5b 	bl	1d5d0 <gatt_sub_find>
	if (!sub) {
   1e71a:	4607      	mov	r7, r0
   1e71c:	2800      	cmp	r0, #0
   1e71e:	d07a      	beq.n	1e816 <bt_gatt_unsubscribe+0x116>
	return list->head;
   1e720:	6884      	ldr	r4, [r0, #8]
		return -EINVAL;
	}

	/* Lookup existing subscriptions */
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   1e722:	b104      	cbz	r4, 1e726 <bt_gatt_unsubscribe+0x26>
   1e724:	3c18      	subs	r4, #24
   1e726:	2100      	movs	r1, #0
   1e728:	460e      	mov	r6, r1
   1e72a:	e020      	b.n	1e76e <bt_gatt_unsubscribe+0x6e>
	__ASSERT(conn, "invalid parameters\n");
   1e72c:	4c3e      	ldr	r4, [pc, #248]	; (1e828 <bt_gatt_unsubscribe+0x128>)
   1e72e:	f241 420f 	movw	r2, #5135	; 0x140f
   1e732:	4621      	mov	r1, r4
   1e734:	483d      	ldr	r0, [pc, #244]	; (1e82c <bt_gatt_unsubscribe+0x12c>)
   1e736:	f00d fefa 	bl	2c52e <assert_print>
   1e73a:	f241 410f 	movw	r1, #5135	; 0x140f
   1e73e:	4620      	mov	r0, r4
   1e740:	f00d feee 	bl	2c520 <assert_post_action>
   1e744:	e7e1      	b.n	1e70a <bt_gatt_unsubscribe+0xa>
	__ASSERT(params, "invalid parameters\n");
   1e746:	4c38      	ldr	r4, [pc, #224]	; (1e828 <bt_gatt_unsubscribe+0x128>)
   1e748:	f241 4210 	movw	r2, #5136	; 0x1410
   1e74c:	4621      	mov	r1, r4
   1e74e:	4837      	ldr	r0, [pc, #220]	; (1e82c <bt_gatt_unsubscribe+0x12c>)
   1e750:	f00d feed 	bl	2c52e <assert_print>
   1e754:	f241 4110 	movw	r1, #5136	; 0x1410
   1e758:	4620      	mov	r0, r4
   1e75a:	f00d fee1 	bl	2c520 <assert_post_action>
   1e75e:	e7d5      	b.n	1e70c <bt_gatt_unsubscribe+0xc>
		if (params == tmp) {
			found = true;
   1e760:	2101      	movs	r1, #1
Z_GENLIST_PEEK_NEXT(slist, snode)
   1e762:	f114 0318 	adds.w	r3, r4, #24
   1e766:	d00b      	beq.n	1e780 <bt_gatt_unsubscribe+0x80>
	return node->next;
   1e768:	69a4      	ldr	r4, [r4, #24]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   1e76a:	b104      	cbz	r4, 1e76e <bt_gatt_unsubscribe+0x6e>
   1e76c:	3c18      	subs	r4, #24
   1e76e:	b14c      	cbz	r4, 1e784 <bt_gatt_unsubscribe+0x84>
		if (params == tmp) {
   1e770:	42ac      	cmp	r4, r5
   1e772:	d0f5      	beq.n	1e760 <bt_gatt_unsubscribe+0x60>
			continue;
		}

		/* Check if there still remains any other subscription */
		if (tmp->value_handle == params->value_handle) {
   1e774:	89a2      	ldrh	r2, [r4, #12]
   1e776:	89ab      	ldrh	r3, [r5, #12]
   1e778:	429a      	cmp	r2, r3
   1e77a:	d1f2      	bne.n	1e762 <bt_gatt_unsubscribe+0x62>
			has_subscription = true;
   1e77c:	2601      	movs	r6, #1
   1e77e:	e7f0      	b.n	1e762 <bt_gatt_unsubscribe+0x62>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   1e780:	461c      	mov	r4, r3
   1e782:	e7f4      	b.n	1e76e <bt_gatt_unsubscribe+0x6e>
		}
	}

	if (!found) {
   1e784:	2900      	cmp	r1, #0
   1e786:	d049      	beq.n	1e81c <bt_gatt_unsubscribe+0x11c>
   1e788:	f3bf 8f5b 	dmb	ish
   1e78c:	696b      	ldr	r3, [r5, #20]
   1e78e:	f3bf 8f5b 	dmb	ish
		return -EINVAL;
	}

	/* Attempt to cancel if write is pending */
	if (atomic_test_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING)) {
   1e792:	f013 0f04 	tst.w	r3, #4
   1e796:	d10e      	bne.n	1e7b6 <bt_gatt_unsubscribe+0xb6>
		bt_gatt_cancel(conn, params);
	}

	if (!has_subscription) {
   1e798:	b93e      	cbnz	r6, 1e7aa <bt_gatt_unsubscribe+0xaa>
		int err;

		params->value = 0x0000;
   1e79a:	2300      	movs	r3, #0
   1e79c:	822b      	strh	r3, [r5, #16]
		err = gatt_write_ccc(conn, params);
   1e79e:	4629      	mov	r1, r5
   1e7a0:	4640      	mov	r0, r8
   1e7a2:	f7fe ffd7 	bl	1d754 <gatt_write_ccc>
		if (err) {
   1e7a6:	2800      	cmp	r0, #0
   1e7a8:	d13c      	bne.n	1e824 <bt_gatt_unsubscribe+0x124>
			return err;
		}
	}

	sys_slist_find_and_remove(&sub->list, &params->node);
   1e7aa:	f107 0108 	add.w	r1, r7, #8
   1e7ae:	f105 0218 	add.w	r2, r5, #24
	return list->head;
   1e7b2:	68bb      	ldr	r3, [r7, #8]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1e7b4:	e00f      	b.n	1e7d6 <bt_gatt_unsubscribe+0xd6>
		bt_gatt_cancel(conn, params);
   1e7b6:	4629      	mov	r1, r5
   1e7b8:	4640      	mov	r0, r8
   1e7ba:	f010 fa3f 	bl	2ec3c <bt_gatt_cancel>
   1e7be:	e7eb      	b.n	1e798 <bt_gatt_unsubscribe+0x98>
	return node->next;
   1e7c0:	69ab      	ldr	r3, [r5, #24]
	list->head = node;
   1e7c2:	60bb      	str	r3, [r7, #8]
	return list->tail;
   1e7c4:	6848      	ldr	r0, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   1e7c6:	4282      	cmp	r2, r0
   1e7c8:	d10f      	bne.n	1e7ea <bt_gatt_unsubscribe+0xea>
	list->tail = node;
   1e7ca:	604b      	str	r3, [r1, #4]
}
   1e7cc:	e00d      	b.n	1e7ea <bt_gatt_unsubscribe+0xea>
	list->tail = node;
   1e7ce:	604c      	str	r4, [r1, #4]
}
   1e7d0:	e00b      	b.n	1e7ea <bt_gatt_unsubscribe+0xea>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1e7d2:	461c      	mov	r4, r3
   1e7d4:	681b      	ldr	r3, [r3, #0]
   1e7d6:	b153      	cbz	r3, 1e7ee <bt_gatt_unsubscribe+0xee>
   1e7d8:	429a      	cmp	r2, r3
   1e7da:	d1fa      	bne.n	1e7d2 <bt_gatt_unsubscribe+0xd2>
Z_GENLIST_REMOVE(slist, snode)
   1e7dc:	2c00      	cmp	r4, #0
   1e7de:	d0ef      	beq.n	1e7c0 <bt_gatt_unsubscribe+0xc0>
	return node->next;
   1e7e0:	69ab      	ldr	r3, [r5, #24]
	parent->next = child;
   1e7e2:	6023      	str	r3, [r4, #0]
	return list->tail;
   1e7e4:	684b      	ldr	r3, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   1e7e6:	429a      	cmp	r2, r3
   1e7e8:	d0f1      	beq.n	1e7ce <bt_gatt_unsubscribe+0xce>
	parent->next = child;
   1e7ea:	2300      	movs	r3, #0
   1e7ec:	61ab      	str	r3, [r5, #24]

	if (gatt_sub_is_empty(sub)) {
   1e7ee:	4638      	mov	r0, r7
   1e7f0:	f00f fe4b 	bl	2e48a <gatt_sub_is_empty>
   1e7f4:	b940      	cbnz	r0, 1e808 <bt_gatt_unsubscribe+0x108>
		gatt_sub_free(sub);
	}

	if (has_subscription) {
   1e7f6:	b1a6      	cbz	r6, 1e822 <bt_gatt_unsubscribe+0x122>
		/* Notify with NULL data to complete unsubscribe */
		params->notify(conn, params, NULL, 0);
   1e7f8:	682c      	ldr	r4, [r5, #0]
   1e7fa:	2300      	movs	r3, #0
   1e7fc:	461a      	mov	r2, r3
   1e7fe:	4629      	mov	r1, r5
   1e800:	4640      	mov	r0, r8
   1e802:	47a0      	blx	r4
	}

	return 0;
   1e804:	2000      	movs	r0, #0
   1e806:	e00d      	b.n	1e824 <bt_gatt_unsubscribe+0x124>
		gatt_sub_free(sub);
   1e808:	4638      	mov	r0, r7
   1e80a:	f7ff f821 	bl	1d850 <gatt_sub_free>
   1e80e:	e7f2      	b.n	1e7f6 <bt_gatt_unsubscribe+0xf6>
		return -ENOTCONN;
   1e810:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1e814:	e006      	b.n	1e824 <bt_gatt_unsubscribe+0x124>
		return -EINVAL;
   1e816:	f06f 0015 	mvn.w	r0, #21
   1e81a:	e003      	b.n	1e824 <bt_gatt_unsubscribe+0x124>
		return -EINVAL;
   1e81c:	f06f 0015 	mvn.w	r0, #21
   1e820:	e000      	b.n	1e824 <bt_gatt_unsubscribe+0x124>
	return 0;
   1e822:	2000      	movs	r0, #0
}
   1e824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e828:	0003a9b8 	.word	0x0003a9b8
   1e82c:	00031600 	.word	0x00031600

0001e830 <bt_gatt_mult_notification>:
{
   1e830:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e834:	b087      	sub	sp, #28
   1e836:	4607      	mov	r7, r0
   1e838:	460c      	mov	r4, r1
   1e83a:	4693      	mov	fp, r2
	sub = gatt_sub_find(conn);
   1e83c:	f7fe fec8 	bl	1d5d0 <gatt_sub_find>
	if (!sub) {
   1e840:	b160      	cbz	r0, 1e85c <bt_gatt_mult_notification+0x2c>
   1e842:	4682      	mov	sl, r0
	net_buf_simple_init_with_data(&buf, (void *)data, length);
   1e844:	465a      	mov	r2, fp
   1e846:	4621      	mov	r1, r4
   1e848:	a803      	add	r0, sp, #12
   1e84a:	f010 fb36 	bl	2eeba <net_buf_simple_init_with_data>
	while (buf.len > sizeof(*nfy)) {
   1e84e:	e03a      	b.n	1e8c6 <bt_gatt_mult_notification+0x96>
			BT_ERR("Invalid data len %u > %u", len, length);
   1e850:	465b      	mov	r3, fp
   1e852:	464a      	mov	r2, r9
   1e854:	2145      	movs	r1, #69	; 0x45
   1e856:	482b      	ldr	r0, [pc, #172]	; (1e904 <bt_gatt_mult_notification+0xd4>)
   1e858:	f00d fe78 	bl	2c54c <z_log_minimal_printk>
}
   1e85c:	b007      	add	sp, #28
   1e85e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   1e862:	462c      	mov	r4, r5
   1e864:	9701      	str	r7, [sp, #4]
   1e866:	e00b      	b.n	1e880 <bt_gatt_mult_notification+0x50>
   1e868:	462c      	mov	r4, r5
   1e86a:	9701      	str	r7, [sp, #4]
   1e86c:	e008      	b.n	1e880 <bt_gatt_mult_notification+0x50>
   1e86e:	b1fc      	cbz	r4, 1e8b0 <bt_gatt_mult_notification+0x80>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1e870:	f114 0318 	adds.w	r3, r4, #24
   1e874:	d002      	beq.n	1e87c <bt_gatt_mult_notification+0x4c>
	return node->next;
   1e876:	69a3      	ldr	r3, [r4, #24]
   1e878:	b103      	cbz	r3, 1e87c <bt_gatt_mult_notification+0x4c>
   1e87a:	3b18      	subs	r3, #24
   1e87c:	4625      	mov	r5, r4
   1e87e:	461c      	mov	r4, r3
   1e880:	b1e5      	cbz	r5, 1e8bc <bt_gatt_mult_notification+0x8c>
			if (handle != params->value_handle) {
   1e882:	89ab      	ldrh	r3, [r5, #12]
   1e884:	429e      	cmp	r6, r3
   1e886:	d1f2      	bne.n	1e86e <bt_gatt_mult_notification+0x3e>
			if (check_subscribe_security_level(conn, params)) {
   1e888:	4629      	mov	r1, r5
   1e88a:	9801      	ldr	r0, [sp, #4]
   1e88c:	f00f fe02 	bl	2e494 <check_subscribe_security_level>
   1e890:	2800      	cmp	r0, #0
   1e892:	d0ec      	beq.n	1e86e <bt_gatt_mult_notification+0x3e>
				if (params->notify(conn, params, nfy->value, len) ==
   1e894:	464b      	mov	r3, r9
   1e896:	f108 0204 	add.w	r2, r8, #4
   1e89a:	4629      	mov	r1, r5
   1e89c:	9801      	ldr	r0, [sp, #4]
   1e89e:	682f      	ldr	r7, [r5, #0]
   1e8a0:	47b8      	blx	r7
   1e8a2:	2800      	cmp	r0, #0
   1e8a4:	d1e3      	bne.n	1e86e <bt_gatt_mult_notification+0x3e>
					bt_gatt_unsubscribe(conn, params);
   1e8a6:	4629      	mov	r1, r5
   1e8a8:	9801      	ldr	r0, [sp, #4]
   1e8aa:	f7ff ff29 	bl	1e700 <bt_gatt_unsubscribe>
   1e8ae:	e7de      	b.n	1e86e <bt_gatt_mult_notification+0x3e>
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   1e8b0:	4623      	mov	r3, r4
   1e8b2:	e7e3      	b.n	1e87c <bt_gatt_mult_notification+0x4c>
   1e8b4:	9701      	str	r7, [sp, #4]
   1e8b6:	e7e3      	b.n	1e880 <bt_gatt_mult_notification+0x50>
   1e8b8:	9701      	str	r7, [sp, #4]
   1e8ba:	e7e1      	b.n	1e880 <bt_gatt_mult_notification+0x50>
		net_buf_simple_pull_mem(&buf, len);
   1e8bc:	9f01      	ldr	r7, [sp, #4]
   1e8be:	4649      	mov	r1, r9
   1e8c0:	a803      	add	r0, sp, #12
   1e8c2:	f000 fbff 	bl	1f0c4 <net_buf_simple_pull_mem>
	while (buf.len > sizeof(*nfy)) {
   1e8c6:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1e8ca:	2b04      	cmp	r3, #4
   1e8cc:	d9c6      	bls.n	1e85c <bt_gatt_mult_notification+0x2c>
		nfy = net_buf_simple_pull_mem(&buf, sizeof(*nfy));
   1e8ce:	2104      	movs	r1, #4
   1e8d0:	a803      	add	r0, sp, #12
   1e8d2:	f000 fbf7 	bl	1f0c4 <net_buf_simple_pull_mem>
   1e8d6:	4680      	mov	r8, r0
		handle = sys_cpu_to_le16(nfy->handle);
   1e8d8:	8806      	ldrh	r6, [r0, #0]
		len = sys_cpu_to_le16(nfy->len);
   1e8da:	f8b0 9002 	ldrh.w	r9, [r0, #2]
		if (len > buf.len) {
   1e8de:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1e8e2:	454b      	cmp	r3, r9
   1e8e4:	d3b4      	bcc.n	1e850 <bt_gatt_mult_notification+0x20>
	return list->head;
   1e8e6:	f8da 5008 	ldr.w	r5, [sl, #8]
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
   1e8ea:	2d00      	cmp	r5, #0
   1e8ec:	d0b9      	beq.n	1e862 <bt_gatt_mult_notification+0x32>
   1e8ee:	3d18      	subs	r5, #24
   1e8f0:	d0ba      	beq.n	1e868 <bt_gatt_mult_notification+0x38>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1e8f2:	f115 0418 	adds.w	r4, r5, #24
   1e8f6:	d0dd      	beq.n	1e8b4 <bt_gatt_mult_notification+0x84>
	return node->next;
   1e8f8:	69ac      	ldr	r4, [r5, #24]
   1e8fa:	2c00      	cmp	r4, #0
   1e8fc:	d0dc      	beq.n	1e8b8 <bt_gatt_mult_notification+0x88>
   1e8fe:	3c18      	subs	r4, #24
   1e900:	9701      	str	r7, [sp, #4]
   1e902:	e7bd      	b.n	1e880 <bt_gatt_mult_notification+0x50>
   1e904:	0003abc4 	.word	0x0003abc4

0001e908 <bt_gatt_connected>:
	}
	return 0;
}

void bt_gatt_connected(struct bt_conn *conn)
{
   1e908:	b510      	push	{r4, lr}
   1e90a:	b086      	sub	sp, #24
   1e90c:	4604      	mov	r4, r0
	struct conn_data data;

	BT_DBG("conn %p", conn);

	data.conn = conn;
   1e90e:	9004      	str	r0, [sp, #16]
	data.sec = BT_SECURITY_L1;
   1e910:	2001      	movs	r0, #1
   1e912:	f88d 0014 	strb.w	r0, [sp, #20]
   1e916:	ab04      	add	r3, sp, #16
   1e918:	9302      	str	r3, [sp, #8]
   1e91a:	4b07      	ldr	r3, [pc, #28]	; (1e938 <bt_gatt_connected+0x30>)
   1e91c:	9301      	str	r3, [sp, #4]
   1e91e:	2200      	movs	r2, #0
   1e920:	9200      	str	r2, [sp, #0]
   1e922:	4613      	mov	r3, r2
   1e924:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e928:	f7ff f966 	bl	1dbf8 <bt_gatt_foreach_attr_type>
				err);
		}
	}

#if defined(CONFIG_BT_GATT_CLIENT)
	add_subscriptions(conn);
   1e92c:	4620      	mov	r0, r4
   1e92e:	f00f ff44 	bl	2e7ba <add_subscriptions>
	if (err) {
		BT_WARN("MTU Exchange failed (err %d)", err);
	}
#endif /* CONFIG_BT_GATT_AUTO_UPDATE_MTU */
#endif /* CONFIG_BT_GATT_CLIENT */
}
   1e932:	b006      	add	sp, #24
   1e934:	bd10      	pop	{r4, pc}
   1e936:	bf00      	nop
   1e938:	0001e32d 	.word	0x0001e32d

0001e93c <bt_gatt_att_max_mtu_changed>:

void bt_gatt_att_max_mtu_changed(struct bt_conn *conn, uint16_t tx, uint16_t rx)
{
   1e93c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e93e:	4605      	mov	r5, r0
   1e940:	460e      	mov	r6, r1
   1e942:	4617      	mov	r7, r2
	return list->head;
   1e944:	4b0a      	ldr	r3, [pc, #40]	; (1e970 <bt_gatt_att_max_mtu_changed+0x34>)
   1e946:	681c      	ldr	r4, [r3, #0]
	struct bt_gatt_cb *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
   1e948:	b134      	cbz	r4, 1e958 <bt_gatt_att_max_mtu_changed+0x1c>
   1e94a:	3c04      	subs	r4, #4
   1e94c:	e004      	b.n	1e958 <bt_gatt_att_max_mtu_changed+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1e94e:	1d23      	adds	r3, r4, #4
   1e950:	d00b      	beq.n	1e96a <bt_gatt_att_max_mtu_changed+0x2e>
	return node->next;
   1e952:	6864      	ldr	r4, [r4, #4]
   1e954:	b15c      	cbz	r4, 1e96e <bt_gatt_att_max_mtu_changed+0x32>
   1e956:	3c04      	subs	r4, #4
   1e958:	b14c      	cbz	r4, 1e96e <bt_gatt_att_max_mtu_changed+0x32>
		if (cb->att_mtu_updated) {
   1e95a:	6823      	ldr	r3, [r4, #0]
   1e95c:	2b00      	cmp	r3, #0
   1e95e:	d0f6      	beq.n	1e94e <bt_gatt_att_max_mtu_changed+0x12>
			cb->att_mtu_updated(conn, tx, rx);
   1e960:	463a      	mov	r2, r7
   1e962:	4631      	mov	r1, r6
   1e964:	4628      	mov	r0, r5
   1e966:	4798      	blx	r3
   1e968:	e7f1      	b.n	1e94e <bt_gatt_att_max_mtu_changed+0x12>
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
   1e96a:	461c      	mov	r4, r3
   1e96c:	e7f4      	b.n	1e958 <bt_gatt_att_max_mtu_changed+0x1c>
		}
	}
}
   1e96e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e970:	20003be4 	.word	0x20003be4

0001e974 <bt_gatt_disconnected>:

	return 0;
}

void bt_gatt_disconnected(struct bt_conn *conn)
{
   1e974:	b510      	push	{r4, lr}
   1e976:	b084      	sub	sp, #16
   1e978:	4604      	mov	r4, r0
   1e97a:	9002      	str	r0, [sp, #8]
   1e97c:	4b08      	ldr	r3, [pc, #32]	; (1e9a0 <bt_gatt_disconnected+0x2c>)
   1e97e:	9301      	str	r3, [sp, #4]
   1e980:	2200      	movs	r2, #0
   1e982:	9200      	str	r2, [sp, #0]
   1e984:	4613      	mov	r3, r2
   1e986:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1e98a:	2001      	movs	r0, #1
   1e98c:	f7ff f934 	bl	1dbf8 <bt_gatt_foreach_attr_type>
				     remove_peer_from_attr,
				     &addr_with_id);
	}

#if defined(CONFIG_BT_GATT_CLIENT)
	remove_subscriptions(conn);
   1e990:	4620      	mov	r0, r4
   1e992:	f00f ff8f 	bl	2e8b4 <remove_subscriptions>
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
   1e996:	4620      	mov	r0, r4
   1e998:	f00f ffd1 	bl	2e93e <remove_cf_cfg>
#endif
}
   1e99c:	b004      	add	sp, #16
   1e99e:	bd10      	pop	{r4, pc}
   1e9a0:	0001d77d 	.word	0x0001d77d

0001e9a4 <bt_smp_accept>:

	return 0;
}

static int bt_smp_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
   1e9a4:	b510      	push	{r4, lr}
   1e9a6:	4602      	mov	r2, r0
		.recv = bt_smp_recv,
	};

	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   1e9a8:	2000      	movs	r0, #0
   1e9aa:	b130      	cbz	r0, 1e9ba <bt_smp_accept+0x16>
		*chan = &smp->chan;

		return 0;
	}

	BT_ERR("No available SMP context for conn %p", conn);
   1e9ac:	2145      	movs	r1, #69	; 0x45
   1e9ae:	480b      	ldr	r0, [pc, #44]	; (1e9dc <bt_smp_accept+0x38>)
   1e9b0:	f00d fdcc 	bl	2c54c <z_log_minimal_printk>

	return -ENOMEM;
   1e9b4:	f06f 000b 	mvn.w	r0, #11
}
   1e9b8:	bd10      	pop	{r4, pc}
		if (smp->chan.conn) {
   1e9ba:	2394      	movs	r3, #148	; 0x94
   1e9bc:	fb00 f303 	mul.w	r3, r0, r3
   1e9c0:	4c07      	ldr	r4, [pc, #28]	; (1e9e0 <bt_smp_accept+0x3c>)
   1e9c2:	58e3      	ldr	r3, [r4, r3]
   1e9c4:	b10b      	cbz	r3, 1e9ca <bt_smp_accept+0x26>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   1e9c6:	3001      	adds	r0, #1
   1e9c8:	e7ef      	b.n	1e9aa <bt_smp_accept+0x6>
		smp->chan.ops = &ops;
   1e9ca:	4b05      	ldr	r3, [pc, #20]	; (1e9e0 <bt_smp_accept+0x3c>)
   1e9cc:	2294      	movs	r2, #148	; 0x94
   1e9ce:	fb02 3300 	mla	r3, r2, r0, r3
   1e9d2:	4a04      	ldr	r2, [pc, #16]	; (1e9e4 <bt_smp_accept+0x40>)
   1e9d4:	605a      	str	r2, [r3, #4]
		*chan = &smp->chan;
   1e9d6:	600b      	str	r3, [r1, #0]
		return 0;
   1e9d8:	e7ee      	b.n	1e9b8 <bt_smp_accept+0x14>
   1e9da:	bf00      	nop
   1e9dc:	0003ad20 	.word	0x0003ad20
   1e9e0:	20003c38 	.word	0x20003c38
   1e9e4:	0003ad54 	.word	0x0003ad54

0001e9e8 <pool_id>:
	return &_net_buf_pool_list[id];
}

static int pool_id(struct net_buf_pool *pool)
{
	return pool - _net_buf_pool_list;
   1e9e8:	4b03      	ldr	r3, [pc, #12]	; (1e9f8 <pool_id+0x10>)
   1e9ea:	1ac0      	subs	r0, r0, r3
   1e9ec:	1080      	asrs	r0, r0, #2
}
   1e9ee:	4b03      	ldr	r3, [pc, #12]	; (1e9fc <pool_id+0x14>)
   1e9f0:	fb03 f000 	mul.w	r0, r3, r0
   1e9f4:	4770      	bx	lr
   1e9f6:	bf00      	nop
   1e9f8:	20000f04 	.word	0x20000f04
   1e9fc:	c4ec4ec5 	.word	0xc4ec4ec5

0001ea00 <net_buf_pool_get>:
}
   1ea00:	2234      	movs	r2, #52	; 0x34
   1ea02:	4b02      	ldr	r3, [pc, #8]	; (1ea0c <net_buf_pool_get+0xc>)
   1ea04:	fb02 3000 	mla	r0, r2, r0, r3
   1ea08:	4770      	bx	lr
   1ea0a:	bf00      	nop
   1ea0c:	20000f04 	.word	0x20000f04

0001ea10 <net_buf_reset>:

	return buf;
}

void net_buf_reset(struct net_buf *buf)
{
   1ea10:	b538      	push	{r3, r4, r5, lr}
   1ea12:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(buf->flags == 0U);
   1ea14:	7943      	ldrb	r3, [r0, #5]
   1ea16:	b983      	cbnz	r3, 1ea3a <net_buf_reset+0x2a>
	__ASSERT_NO_MSG(buf->frags == NULL);
   1ea18:	6823      	ldr	r3, [r4, #0]
   1ea1a:	b14b      	cbz	r3, 1ea30 <net_buf_reset+0x20>
   1ea1c:	4d0c      	ldr	r5, [pc, #48]	; (1ea50 <net_buf_reset+0x40>)
   1ea1e:	2257      	movs	r2, #87	; 0x57
   1ea20:	4629      	mov	r1, r5
   1ea22:	480c      	ldr	r0, [pc, #48]	; (1ea54 <net_buf_reset+0x44>)
   1ea24:	f00d fd83 	bl	2c52e <assert_print>
   1ea28:	2157      	movs	r1, #87	; 0x57
   1ea2a:	4628      	mov	r0, r5
   1ea2c:	f00d fd78 	bl	2c520 <assert_post_action>
	buf->len  = 0U;
   1ea30:	2300      	movs	r3, #0
   1ea32:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf;
   1ea34:	6923      	ldr	r3, [r4, #16]
   1ea36:	60a3      	str	r3, [r4, #8]

	net_buf_simple_reset(&buf->b);
}
   1ea38:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(buf->flags == 0U);
   1ea3a:	4d05      	ldr	r5, [pc, #20]	; (1ea50 <net_buf_reset+0x40>)
   1ea3c:	2256      	movs	r2, #86	; 0x56
   1ea3e:	4629      	mov	r1, r5
   1ea40:	4804      	ldr	r0, [pc, #16]	; (1ea54 <net_buf_reset+0x44>)
   1ea42:	f00d fd74 	bl	2c52e <assert_print>
   1ea46:	2156      	movs	r1, #86	; 0x56
   1ea48:	4628      	mov	r0, r5
   1ea4a:	f00d fd69 	bl	2c520 <assert_post_action>
   1ea4e:	e7e3      	b.n	1ea18 <net_buf_reset+0x8>
   1ea50:	0003ad78 	.word	0x0003ad78
   1ea54:	00031600 	.word	0x00031600

0001ea58 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
   1ea58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ea5c:	b083      	sub	sp, #12
   1ea5e:	4604      	mov	r4, r0
   1ea60:	9101      	str	r1, [sp, #4]
   1ea62:	4616      	mov	r6, r2
   1ea64:	461f      	mov	r7, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
   1ea66:	4610      	mov	r0, r2
   1ea68:	4619      	mov	r1, r3
   1ea6a:	f012 f8ac 	bl	30bc6 <sys_clock_timeout_end_calc>
   1ea6e:	4681      	mov	r9, r0
   1ea70:	468a      	mov	sl, r1
	struct net_buf *buf;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(pool);
   1ea72:	b33c      	cbz	r4, 1eac4 <net_buf_alloc_len+0x6c>
	NET_BUF_DBG("%s():%d: pool %p size %zu", func, line, pool, size);

	/* We need to prevent race conditions
	 * when accessing pool->uninit_count.
	 */
	key = k_spin_lock(&pool->lock);
   1ea74:	f104 081c 	add.w	r8, r4, #28
   1ea78:	f04f 0340 	mov.w	r3, #64	; 0x40
   1ea7c:	f3ef 8b11 	mrs	fp, BASEPRI
   1ea80:	f383 8812 	msr	BASEPRI_MAX, r3
   1ea84:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1ea88:	4640      	mov	r0, r8
   1ea8a:	f007 fe0b 	bl	266a4 <z_spin_lock_valid>
   1ea8e:	b320      	cbz	r0, 1eada <net_buf_alloc_len+0x82>
	z_spin_lock_set_owner(l);
   1ea90:	4640      	mov	r0, r8
   1ea92:	f007 fe27 	bl	266e4 <z_spin_lock_set_owner>

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   1ea96:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1ea98:	2b00      	cmp	r3, #0
   1ea9a:	f000 8085 	beq.w	1eba8 <net_buf_alloc_len+0x150>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   1ea9e:	8c22      	ldrh	r2, [r4, #32]
   1eaa0:	4293      	cmp	r3, r2
   1eaa2:	d230      	bcs.n	1eb06 <net_buf_alloc_len+0xae>
	return z_impl_k_queue_get(queue, timeout);
   1eaa4:	2200      	movs	r2, #0
   1eaa6:	2300      	movs	r3, #0
   1eaa8:	4620      	mov	r0, r4
   1eaaa:	f008 f9fb 	bl	26ea4 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   1eaae:	4605      	mov	r5, r0
   1eab0:	b348      	cbz	r0, 1eb06 <net_buf_alloc_len+0xae>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1eab2:	4640      	mov	r0, r8
   1eab4:	f007 fe06 	bl	266c4 <z_spin_unlock_valid>
   1eab8:	b1d0      	cbz	r0, 1eaf0 <net_buf_alloc_len+0x98>
	__asm__ volatile(
   1eaba:	f38b 8811 	msr	BASEPRI, fp
   1eabe:	f3bf 8f6f 	isb	sy
				k_spin_unlock(&pool->lock, key);
				goto success;
   1eac2:	e03d      	b.n	1eb40 <net_buf_alloc_len+0xe8>
	__ASSERT_NO_MSG(pool);
   1eac4:	4d59      	ldr	r5, [pc, #356]	; (1ec2c <net_buf_alloc_len+0x1d4>)
   1eac6:	22f4      	movs	r2, #244	; 0xf4
   1eac8:	4629      	mov	r1, r5
   1eaca:	4859      	ldr	r0, [pc, #356]	; (1ec30 <net_buf_alloc_len+0x1d8>)
   1eacc:	f00d fd2f 	bl	2c52e <assert_print>
   1ead0:	21f4      	movs	r1, #244	; 0xf4
   1ead2:	4628      	mov	r0, r5
   1ead4:	f00d fd24 	bl	2c520 <assert_post_action>
   1ead8:	e7cc      	b.n	1ea74 <net_buf_alloc_len+0x1c>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1eada:	4d56      	ldr	r5, [pc, #344]	; (1ec34 <net_buf_alloc_len+0x1dc>)
   1eadc:	228e      	movs	r2, #142	; 0x8e
   1eade:	4629      	mov	r1, r5
   1eae0:	4853      	ldr	r0, [pc, #332]	; (1ec30 <net_buf_alloc_len+0x1d8>)
   1eae2:	f00d fd24 	bl	2c52e <assert_print>
   1eae6:	218e      	movs	r1, #142	; 0x8e
   1eae8:	4628      	mov	r0, r5
   1eaea:	f00d fd19 	bl	2c520 <assert_post_action>
   1eaee:	e7cf      	b.n	1ea90 <net_buf_alloc_len+0x38>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1eaf0:	4c50      	ldr	r4, [pc, #320]	; (1ec34 <net_buf_alloc_len+0x1dc>)
   1eaf2:	22b9      	movs	r2, #185	; 0xb9
   1eaf4:	4621      	mov	r1, r4
   1eaf6:	484e      	ldr	r0, [pc, #312]	; (1ec30 <net_buf_alloc_len+0x1d8>)
   1eaf8:	f00d fd19 	bl	2c52e <assert_print>
   1eafc:	21b9      	movs	r1, #185	; 0xb9
   1eafe:	4620      	mov	r0, r4
   1eb00:	f00d fd0e 	bl	2c520 <assert_post_action>
   1eb04:	e7d9      	b.n	1eaba <net_buf_alloc_len+0x62>
			}
		}

		uninit_count = pool->uninit_count--;
   1eb06:	8c65      	ldrh	r5, [r4, #34]	; 0x22
   1eb08:	1e6b      	subs	r3, r5, #1
   1eb0a:	8463      	strh	r3, [r4, #34]	; 0x22
   1eb0c:	4640      	mov	r0, r8
   1eb0e:	f007 fdd9 	bl	266c4 <z_spin_unlock_valid>
   1eb12:	2800      	cmp	r0, #0
   1eb14:	d03c      	beq.n	1eb90 <net_buf_alloc_len+0x138>
   1eb16:	f38b 8811 	msr	BASEPRI, fp
   1eb1a:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   1eb1e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   1eb22:	3317      	adds	r3, #23
   1eb24:	f023 0303 	bic.w	r3, r3, #3
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
   1eb28:	8c22      	ldrh	r2, [r4, #32]
   1eb2a:	1b55      	subs	r5, r2, r5
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
   1eb2c:	6b22      	ldr	r2, [r4, #48]	; 0x30
   1eb2e:	fb05 2503 	mla	r5, r5, r3, r2
	buf->pool_id = pool_id(pool);
   1eb32:	4620      	mov	r0, r4
   1eb34:	f7ff ff58 	bl	1e9e8 <pool_id>
   1eb38:	71a8      	strb	r0, [r5, #6]
	buf->user_data_size = pool->user_data_size;
   1eb3a:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   1eb3e:	71eb      	strb	r3, [r5, #7]
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   1eb40:	f8dd 8004 	ldr.w	r8, [sp, #4]
   1eb44:	f1b8 0f00 	cmp.w	r8, #0
   1eb48:	d05f      	beq.n	1ec0a <net_buf_alloc_len+0x1b2>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1eb4a:	ea56 0307 	orrs.w	r3, r6, r7
   1eb4e:	d005      	beq.n	1eb5c <net_buf_alloc_len+0x104>
   1eb50:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
   1eb54:	bf08      	it	eq
   1eb56:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
   1eb5a:	d141      	bne.n	1ebe0 <net_buf_alloc_len+0x188>
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   1eb5c:	4632      	mov	r2, r6
   1eb5e:	463b      	mov	r3, r7
   1eb60:	a901      	add	r1, sp, #4
   1eb62:	4628      	mov	r0, r5
   1eb64:	f010 f958 	bl	2ee18 <data_alloc>
   1eb68:	4604      	mov	r4, r0
   1eb6a:	6128      	str	r0, [r5, #16]
		if (!buf->__buf) {
   1eb6c:	2800      	cmp	r0, #0
   1eb6e:	d044      	beq.n	1ebfa <net_buf_alloc_len+0x1a2>
			net_buf_destroy(buf);
			return NULL;
		}

#if __ASSERT_ON
		NET_BUF_ASSERT(req_size <= size);
   1eb70:	9b01      	ldr	r3, [sp, #4]
   1eb72:	4598      	cmp	r8, r3
   1eb74:	d94b      	bls.n	1ec0e <net_buf_alloc_len+0x1b6>
   1eb76:	4c2d      	ldr	r4, [pc, #180]	; (1ec2c <net_buf_alloc_len+0x1d4>)
   1eb78:	f240 1255 	movw	r2, #341	; 0x155
   1eb7c:	4621      	mov	r1, r4
   1eb7e:	482c      	ldr	r0, [pc, #176]	; (1ec30 <net_buf_alloc_len+0x1d8>)
   1eb80:	f00d fcd5 	bl	2c52e <assert_print>
   1eb84:	f240 1155 	movw	r1, #341	; 0x155
   1eb88:	4620      	mov	r0, r4
   1eb8a:	f00d fcc9 	bl	2c520 <assert_post_action>
   1eb8e:	e03e      	b.n	1ec0e <net_buf_alloc_len+0x1b6>
   1eb90:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1ec34 <net_buf_alloc_len+0x1dc>
   1eb94:	22b9      	movs	r2, #185	; 0xb9
   1eb96:	4641      	mov	r1, r8
   1eb98:	4825      	ldr	r0, [pc, #148]	; (1ec30 <net_buf_alloc_len+0x1d8>)
   1eb9a:	f00d fcc8 	bl	2c52e <assert_print>
   1eb9e:	21b9      	movs	r1, #185	; 0xb9
   1eba0:	4640      	mov	r0, r8
   1eba2:	f00d fcbd 	bl	2c520 <assert_post_action>
   1eba6:	e7b6      	b.n	1eb16 <net_buf_alloc_len+0xbe>
   1eba8:	4640      	mov	r0, r8
   1ebaa:	f007 fd8b 	bl	266c4 <z_spin_unlock_valid>
   1ebae:	b160      	cbz	r0, 1ebca <net_buf_alloc_len+0x172>
   1ebb0:	f38b 8811 	msr	BASEPRI, fp
   1ebb4:	f3bf 8f6f 	isb	sy
   1ebb8:	4632      	mov	r2, r6
   1ebba:	463b      	mov	r3, r7
   1ebbc:	4620      	mov	r0, r4
   1ebbe:	f008 f971 	bl	26ea4 <z_impl_k_queue_get>
	if (!buf) {
   1ebc2:	4605      	mov	r5, r0
   1ebc4:	2800      	cmp	r0, #0
   1ebc6:	d1bb      	bne.n	1eb40 <net_buf_alloc_len+0xe8>
   1ebc8:	e02b      	b.n	1ec22 <net_buf_alloc_len+0x1ca>
   1ebca:	4d1a      	ldr	r5, [pc, #104]	; (1ec34 <net_buf_alloc_len+0x1dc>)
   1ebcc:	22b9      	movs	r2, #185	; 0xb9
   1ebce:	4629      	mov	r1, r5
   1ebd0:	4817      	ldr	r0, [pc, #92]	; (1ec30 <net_buf_alloc_len+0x1d8>)
   1ebd2:	f00d fcac 	bl	2c52e <assert_print>
   1ebd6:	21b9      	movs	r1, #185	; 0xb9
   1ebd8:	4628      	mov	r0, r5
   1ebda:	f00d fca1 	bl	2c520 <assert_post_action>
   1ebde:	e7e7      	b.n	1ebb0 <net_buf_alloc_len+0x158>
			int64_t remaining = end - sys_clock_tick_get();
   1ebe0:	f00a fcd8 	bl	29594 <sys_clock_tick_get>
   1ebe4:	ebb9 0600 	subs.w	r6, r9, r0
   1ebe8:	eb6a 0701 	sbc.w	r7, sl, r1
			if (remaining <= 0) {
   1ebec:	2e01      	cmp	r6, #1
   1ebee:	f177 0300 	sbcs.w	r3, r7, #0
   1ebf2:	dab3      	bge.n	1eb5c <net_buf_alloc_len+0x104>
				timeout = K_NO_WAIT;
   1ebf4:	2600      	movs	r6, #0
   1ebf6:	4637      	mov	r7, r6
   1ebf8:	e7b0      	b.n	1eb5c <net_buf_alloc_len+0x104>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1ebfa:	79a8      	ldrb	r0, [r5, #6]
   1ebfc:	f7ff ff00 	bl	1ea00 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
   1ec00:	4629      	mov	r1, r5
   1ec02:	f011 ff05 	bl	30a10 <k_queue_prepend>
			return NULL;
   1ec06:	4625      	mov	r5, r4
}
   1ec08:	e00b      	b.n	1ec22 <net_buf_alloc_len+0x1ca>
#endif
	} else {
		buf->__buf = NULL;
   1ec0a:	2300      	movs	r3, #0
   1ec0c:	612b      	str	r3, [r5, #16]
	}

	buf->ref   = 1U;
   1ec0e:	2301      	movs	r3, #1
   1ec10:	712b      	strb	r3, [r5, #4]
	buf->flags = 0U;
   1ec12:	2300      	movs	r3, #0
   1ec14:	716b      	strb	r3, [r5, #5]
	buf->frags = NULL;
   1ec16:	602b      	str	r3, [r5, #0]
	buf->size  = size;
   1ec18:	9b01      	ldr	r3, [sp, #4]
   1ec1a:	81eb      	strh	r3, [r5, #14]
	net_buf_reset(buf);
   1ec1c:	4628      	mov	r0, r5
   1ec1e:	f7ff fef7 	bl	1ea10 <net_buf_reset>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
   1ec22:	4628      	mov	r0, r5
   1ec24:	b003      	add	sp, #12
   1ec26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ec2a:	bf00      	nop
   1ec2c:	0003ad78 	.word	0x0003ad78
   1ec30:	00031600 	.word	0x00031600
   1ec34:	000390f0 	.word	0x000390f0

0001ec38 <net_buf_get>:
struct net_buf *net_buf_get_debug(struct k_fifo *fifo, k_timeout_t timeout,
				  const char *func, int line)
#else
struct net_buf *net_buf_get(struct k_fifo *fifo, k_timeout_t timeout)
#endif
{
   1ec38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ec3a:	4605      	mov	r5, r0
   1ec3c:	f008 f932 	bl	26ea4 <z_impl_k_queue_get>
	struct net_buf *buf, *frag;

	NET_BUF_DBG("%s():%d: fifo %p", func, line, fifo);

	buf = k_fifo_get(fifo, timeout);
	if (!buf) {
   1ec40:	4606      	mov	r6, r0
   1ec42:	b308      	cbz	r0, 1ec88 <net_buf_get+0x50>
	}

	NET_BUF_DBG("%s():%d: buf %p fifo %p", func, line, buf, fifo);

	/* Get any fragments belonging to this buffer */
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1ec44:	4604      	mov	r4, r0
   1ec46:	e004      	b.n	1ec52 <net_buf_get+0x1a>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
		__ASSERT_NO_MSG(frag->frags);

		/* The fragments flag is only for FIFO-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
   1ec48:	7963      	ldrb	r3, [r4, #5]
   1ec4a:	f023 0301 	bic.w	r3, r3, #1
   1ec4e:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1ec50:	6824      	ldr	r4, [r4, #0]
   1ec52:	7963      	ldrb	r3, [r4, #5]
   1ec54:	f013 0f01 	tst.w	r3, #1
   1ec58:	d014      	beq.n	1ec84 <net_buf_get+0x4c>
   1ec5a:	2200      	movs	r2, #0
   1ec5c:	2300      	movs	r3, #0
   1ec5e:	4628      	mov	r0, r5
   1ec60:	f008 f920 	bl	26ea4 <z_impl_k_queue_get>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   1ec64:	6020      	str	r0, [r4, #0]
		__ASSERT_NO_MSG(frag->frags);
   1ec66:	2800      	cmp	r0, #0
   1ec68:	d1ee      	bne.n	1ec48 <net_buf_get+0x10>
   1ec6a:	4f08      	ldr	r7, [pc, #32]	; (1ec8c <net_buf_get+0x54>)
   1ec6c:	f240 12ad 	movw	r2, #429	; 0x1ad
   1ec70:	4639      	mov	r1, r7
   1ec72:	4807      	ldr	r0, [pc, #28]	; (1ec90 <net_buf_get+0x58>)
   1ec74:	f00d fc5b 	bl	2c52e <assert_print>
   1ec78:	f240 11ad 	movw	r1, #429	; 0x1ad
   1ec7c:	4638      	mov	r0, r7
   1ec7e:	f00d fc4f 	bl	2c520 <assert_post_action>
   1ec82:	e7e1      	b.n	1ec48 <net_buf_get+0x10>
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
   1ec84:	2300      	movs	r3, #0
   1ec86:	6023      	str	r3, [r4, #0]

	return buf;
}
   1ec88:	4630      	mov	r0, r6
   1ec8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ec8c:	0003ad78 	.word	0x0003ad78
   1ec90:	00031600 	.word	0x00031600

0001ec94 <net_buf_simple_reserve>:
	buf->size  = size;
	buf->len   = size;
}

void net_buf_simple_reserve(struct net_buf_simple *buf, size_t reserve)
{
   1ec94:	b570      	push	{r4, r5, r6, lr}
   1ec96:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(buf);
   1ec98:	4604      	mov	r4, r0
   1ec9a:	b128      	cbz	r0, 1eca8 <net_buf_simple_reserve+0x14>
	__ASSERT_NO_MSG(buf->len == 0U);
   1ec9c:	88a3      	ldrh	r3, [r4, #4]
   1ec9e:	b983      	cbnz	r3, 1ecc2 <net_buf_simple_reserve+0x2e>
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
   1eca0:	68a3      	ldr	r3, [r4, #8]
   1eca2:	442b      	add	r3, r5
   1eca4:	6023      	str	r3, [r4, #0]
}
   1eca6:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(buf);
   1eca8:	4e0c      	ldr	r6, [pc, #48]	; (1ecdc <net_buf_simple_reserve+0x48>)
   1ecaa:	f44f 72e2 	mov.w	r2, #452	; 0x1c4
   1ecae:	4631      	mov	r1, r6
   1ecb0:	480b      	ldr	r0, [pc, #44]	; (1ece0 <net_buf_simple_reserve+0x4c>)
   1ecb2:	f00d fc3c 	bl	2c52e <assert_print>
   1ecb6:	f44f 71e2 	mov.w	r1, #452	; 0x1c4
   1ecba:	4630      	mov	r0, r6
   1ecbc:	f00d fc30 	bl	2c520 <assert_post_action>
   1ecc0:	e7ec      	b.n	1ec9c <net_buf_simple_reserve+0x8>
	__ASSERT_NO_MSG(buf->len == 0U);
   1ecc2:	4e06      	ldr	r6, [pc, #24]	; (1ecdc <net_buf_simple_reserve+0x48>)
   1ecc4:	f240 12c5 	movw	r2, #453	; 0x1c5
   1ecc8:	4631      	mov	r1, r6
   1ecca:	4805      	ldr	r0, [pc, #20]	; (1ece0 <net_buf_simple_reserve+0x4c>)
   1eccc:	f00d fc2f 	bl	2c52e <assert_print>
   1ecd0:	f240 11c5 	movw	r1, #453	; 0x1c5
   1ecd4:	4630      	mov	r0, r6
   1ecd6:	f00d fc23 	bl	2c520 <assert_post_action>
   1ecda:	e7e1      	b.n	1eca0 <net_buf_simple_reserve+0xc>
   1ecdc:	0003ad78 	.word	0x0003ad78
   1ece0:	00031600 	.word	0x00031600

0001ece4 <net_buf_slist_put>:

static struct k_spinlock net_buf_slist_lock;

void net_buf_slist_put(sys_slist_t *list, struct net_buf *buf)
{
   1ece4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ece8:	460d      	mov	r5, r1
	struct net_buf *tail;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(list);
   1ecea:	4606      	mov	r6, r0
   1ecec:	b110      	cbz	r0, 1ecf4 <net_buf_slist_put+0x10>
	__ASSERT_NO_MSG(buf);
   1ecee:	b175      	cbz	r5, 1ed0e <net_buf_slist_put+0x2a>
{
   1ecf0:	462c      	mov	r4, r5
   1ecf2:	e01e      	b.n	1ed32 <net_buf_slist_put+0x4e>
	__ASSERT_NO_MSG(list);
   1ecf4:	4c2d      	ldr	r4, [pc, #180]	; (1edac <net_buf_slist_put+0xc8>)
   1ecf6:	f44f 72e9 	mov.w	r2, #466	; 0x1d2
   1ecfa:	4621      	mov	r1, r4
   1ecfc:	482c      	ldr	r0, [pc, #176]	; (1edb0 <net_buf_slist_put+0xcc>)
   1ecfe:	f00d fc16 	bl	2c52e <assert_print>
   1ed02:	f44f 71e9 	mov.w	r1, #466	; 0x1d2
   1ed06:	4620      	mov	r0, r4
   1ed08:	f00d fc0a 	bl	2c520 <assert_post_action>
   1ed0c:	e7ef      	b.n	1ecee <net_buf_slist_put+0xa>
	__ASSERT_NO_MSG(buf);
   1ed0e:	4c27      	ldr	r4, [pc, #156]	; (1edac <net_buf_slist_put+0xc8>)
   1ed10:	f240 12d3 	movw	r2, #467	; 0x1d3
   1ed14:	4621      	mov	r1, r4
   1ed16:	4826      	ldr	r0, [pc, #152]	; (1edb0 <net_buf_slist_put+0xcc>)
   1ed18:	f00d fc09 	bl	2c52e <assert_print>
   1ed1c:	f240 11d3 	movw	r1, #467	; 0x1d3
   1ed20:	4620      	mov	r0, r4
   1ed22:	f00d fbfd 	bl	2c520 <assert_post_action>
   1ed26:	e7e3      	b.n	1ecf0 <net_buf_slist_put+0xc>

	for (tail = buf; tail->frags; tail = tail->frags) {
		tail->flags |= NET_BUF_FRAGS;
   1ed28:	7963      	ldrb	r3, [r4, #5]
   1ed2a:	f043 0301 	orr.w	r3, r3, #1
   1ed2e:	7163      	strb	r3, [r4, #5]
	for (tail = buf; tail->frags; tail = tail->frags) {
   1ed30:	4614      	mov	r4, r2
   1ed32:	6822      	ldr	r2, [r4, #0]
   1ed34:	2a00      	cmp	r2, #0
   1ed36:	d1f7      	bne.n	1ed28 <net_buf_slist_put+0x44>
	__asm__ volatile(
   1ed38:	f04f 0340 	mov.w	r3, #64	; 0x40
   1ed3c:	f3ef 8711 	mrs	r7, BASEPRI
   1ed40:	f383 8812 	msr	BASEPRI_MAX, r3
   1ed44:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1ed48:	481a      	ldr	r0, [pc, #104]	; (1edb4 <net_buf_slist_put+0xd0>)
   1ed4a:	f007 fcab 	bl	266a4 <z_spin_lock_valid>
   1ed4e:	b198      	cbz	r0, 1ed78 <net_buf_slist_put+0x94>
	z_spin_lock_set_owner(l);
   1ed50:	4818      	ldr	r0, [pc, #96]	; (1edb4 <net_buf_slist_put+0xd0>)
   1ed52:	f007 fcc7 	bl	266e4 <z_spin_lock_set_owner>
	}

	key = k_spin_lock(&net_buf_slist_lock);
	sys_slist_append_list(list, &buf->node, &tail->node);
   1ed56:	4623      	mov	r3, r4
Z_GENLIST_APPEND_LIST(slist, snode)
   1ed58:	b125      	cbz	r5, 1ed64 <net_buf_slist_put+0x80>
   1ed5a:	b11c      	cbz	r4, 1ed64 <net_buf_slist_put+0x80>
	return list->tail;
   1ed5c:	6872      	ldr	r2, [r6, #4]
Z_GENLIST_APPEND_LIST(slist, snode)
   1ed5e:	b1ba      	cbz	r2, 1ed90 <net_buf_slist_put+0xac>
	parent->next = child;
   1ed60:	6015      	str	r5, [r2, #0]
	list->tail = node;
   1ed62:	6073      	str	r3, [r6, #4]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1ed64:	4813      	ldr	r0, [pc, #76]	; (1edb4 <net_buf_slist_put+0xd0>)
   1ed66:	f007 fcad 	bl	266c4 <z_spin_unlock_valid>
   1ed6a:	b198      	cbz	r0, 1ed94 <net_buf_slist_put+0xb0>
	__asm__ volatile(
   1ed6c:	f387 8811 	msr	BASEPRI, r7
   1ed70:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&net_buf_slist_lock, key);
}
   1ed74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1ed78:	f8df 803c 	ldr.w	r8, [pc, #60]	; 1edb8 <net_buf_slist_put+0xd4>
   1ed7c:	228e      	movs	r2, #142	; 0x8e
   1ed7e:	4641      	mov	r1, r8
   1ed80:	480b      	ldr	r0, [pc, #44]	; (1edb0 <net_buf_slist_put+0xcc>)
   1ed82:	f00d fbd4 	bl	2c52e <assert_print>
   1ed86:	218e      	movs	r1, #142	; 0x8e
   1ed88:	4640      	mov	r0, r8
   1ed8a:	f00d fbc9 	bl	2c520 <assert_post_action>
   1ed8e:	e7df      	b.n	1ed50 <net_buf_slist_put+0x6c>
	list->head = node;
   1ed90:	6035      	str	r5, [r6, #0]
}
   1ed92:	e7e6      	b.n	1ed62 <net_buf_slist_put+0x7e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1ed94:	4c08      	ldr	r4, [pc, #32]	; (1edb8 <net_buf_slist_put+0xd4>)
   1ed96:	22b9      	movs	r2, #185	; 0xb9
   1ed98:	4621      	mov	r1, r4
   1ed9a:	4805      	ldr	r0, [pc, #20]	; (1edb0 <net_buf_slist_put+0xcc>)
   1ed9c:	f00d fbc7 	bl	2c52e <assert_print>
   1eda0:	21b9      	movs	r1, #185	; 0xb9
   1eda2:	4620      	mov	r0, r4
   1eda4:	f00d fbbc 	bl	2c520 <assert_post_action>
   1eda8:	e7e0      	b.n	1ed6c <net_buf_slist_put+0x88>
   1edaa:	bf00      	nop
   1edac:	0003ad78 	.word	0x0003ad78
   1edb0:	00031600 	.word	0x00031600
   1edb4:	20003ccc 	.word	0x20003ccc
   1edb8:	000390f0 	.word	0x000390f0

0001edbc <net_buf_slist_get>:

struct net_buf *net_buf_slist_get(sys_slist_t *list)
{
   1edbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct net_buf *buf, *frag;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(list);
   1edc0:	4605      	mov	r5, r0
   1edc2:	b1c0      	cbz	r0, 1edf6 <net_buf_slist_get+0x3a>
	__asm__ volatile(
   1edc4:	f04f 0340 	mov.w	r3, #64	; 0x40
   1edc8:	f3ef 8711 	mrs	r7, BASEPRI
   1edcc:	f383 8812 	msr	BASEPRI_MAX, r3
   1edd0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1edd4:	4832      	ldr	r0, [pc, #200]	; (1eea0 <net_buf_slist_get+0xe4>)
   1edd6:	f007 fc65 	bl	266a4 <z_spin_lock_valid>
   1edda:	b1c8      	cbz	r0, 1ee10 <net_buf_slist_get+0x54>
	z_spin_lock_set_owner(l);
   1eddc:	4830      	ldr	r0, [pc, #192]	; (1eea0 <net_buf_slist_get+0xe4>)
   1edde:	f007 fc81 	bl	266e4 <z_spin_lock_set_owner>
	return list->head;
   1ede2:	682e      	ldr	r6, [r5, #0]
Z_GENLIST_GET(slist, snode)
   1ede4:	2e00      	cmp	r6, #0
   1ede6:	d045      	beq.n	1ee74 <net_buf_slist_get+0xb8>
	return node->next;
   1ede8:	6833      	ldr	r3, [r6, #0]
	list->head = node;
   1edea:	602b      	str	r3, [r5, #0]
	return list->tail;
   1edec:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1edee:	4296      	cmp	r6, r2
   1edf0:	d019      	beq.n	1ee26 <net_buf_slist_get+0x6a>
{
   1edf2:	4634      	mov	r4, r6
   1edf4:	e020      	b.n	1ee38 <net_buf_slist_get+0x7c>
	__ASSERT_NO_MSG(list);
   1edf6:	4c2b      	ldr	r4, [pc, #172]	; (1eea4 <net_buf_slist_get+0xe8>)
   1edf8:	f240 12e3 	movw	r2, #483	; 0x1e3
   1edfc:	4621      	mov	r1, r4
   1edfe:	482a      	ldr	r0, [pc, #168]	; (1eea8 <net_buf_slist_get+0xec>)
   1ee00:	f00d fb95 	bl	2c52e <assert_print>
   1ee04:	f240 11e3 	movw	r1, #483	; 0x1e3
   1ee08:	4620      	mov	r0, r4
   1ee0a:	f00d fb89 	bl	2c520 <assert_post_action>
   1ee0e:	e7d9      	b.n	1edc4 <net_buf_slist_get+0x8>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1ee10:	4c26      	ldr	r4, [pc, #152]	; (1eeac <net_buf_slist_get+0xf0>)
   1ee12:	228e      	movs	r2, #142	; 0x8e
   1ee14:	4621      	mov	r1, r4
   1ee16:	4824      	ldr	r0, [pc, #144]	; (1eea8 <net_buf_slist_get+0xec>)
   1ee18:	f00d fb89 	bl	2c52e <assert_print>
   1ee1c:	218e      	movs	r1, #142	; 0x8e
   1ee1e:	4620      	mov	r0, r4
   1ee20:	f00d fb7e 	bl	2c520 <assert_post_action>
   1ee24:	e7da      	b.n	1eddc <net_buf_slist_get+0x20>
	list->tail = node;
   1ee26:	606b      	str	r3, [r5, #4]
}
   1ee28:	e7e3      	b.n	1edf2 <net_buf_slist_get+0x36>
	buf = (void *)sys_slist_get(list);

	if (buf) {
		/* Get any fragments belonging to this buffer */
		for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
			frag->frags = (void *)sys_slist_get(list);
   1ee2a:	6023      	str	r3, [r4, #0]
			__ASSERT_NO_MSG(frag->frags);
   1ee2c:	b193      	cbz	r3, 1ee54 <net_buf_slist_get+0x98>

			/* The fragments flag is only for list-internal usage */
			frag->flags &= ~NET_BUF_FRAGS;
   1ee2e:	7963      	ldrb	r3, [r4, #5]
   1ee30:	f023 0301 	bic.w	r3, r3, #1
   1ee34:	7163      	strb	r3, [r4, #5]
		for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1ee36:	6824      	ldr	r4, [r4, #0]
   1ee38:	7963      	ldrb	r3, [r4, #5]
   1ee3a:	f013 0f01 	tst.w	r3, #1
   1ee3e:	d017      	beq.n	1ee70 <net_buf_slist_get+0xb4>
	return list->head;
   1ee40:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET(slist, snode)
   1ee42:	2b00      	cmp	r3, #0
   1ee44:	d0f1      	beq.n	1ee2a <net_buf_slist_get+0x6e>
	return node->next;
   1ee46:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   1ee48:	602a      	str	r2, [r5, #0]
	return list->tail;
   1ee4a:	6869      	ldr	r1, [r5, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1ee4c:	428b      	cmp	r3, r1
   1ee4e:	d1ec      	bne.n	1ee2a <net_buf_slist_get+0x6e>
	list->tail = node;
   1ee50:	606a      	str	r2, [r5, #4]
}
   1ee52:	e7ea      	b.n	1ee2a <net_buf_slist_get+0x6e>
			__ASSERT_NO_MSG(frag->frags);
   1ee54:	f8df 804c 	ldr.w	r8, [pc, #76]	; 1eea4 <net_buf_slist_get+0xe8>
   1ee58:	f240 12ed 	movw	r2, #493	; 0x1ed
   1ee5c:	4641      	mov	r1, r8
   1ee5e:	4812      	ldr	r0, [pc, #72]	; (1eea8 <net_buf_slist_get+0xec>)
   1ee60:	f00d fb65 	bl	2c52e <assert_print>
   1ee64:	f240 11ed 	movw	r1, #493	; 0x1ed
   1ee68:	4640      	mov	r0, r8
   1ee6a:	f00d fb59 	bl	2c520 <assert_post_action>
   1ee6e:	e7de      	b.n	1ee2e <net_buf_slist_get+0x72>
		}

		/* Mark the end of the fragment list */
		frag->frags = NULL;
   1ee70:	2300      	movs	r3, #0
   1ee72:	6023      	str	r3, [r4, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1ee74:	480a      	ldr	r0, [pc, #40]	; (1eea0 <net_buf_slist_get+0xe4>)
   1ee76:	f007 fc25 	bl	266c4 <z_spin_unlock_valid>
   1ee7a:	b130      	cbz	r0, 1ee8a <net_buf_slist_get+0xce>
	__asm__ volatile(
   1ee7c:	f387 8811 	msr	BASEPRI, r7
   1ee80:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&net_buf_slist_lock, key);

	return buf;
}
   1ee84:	4630      	mov	r0, r6
   1ee86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ee8a:	4c08      	ldr	r4, [pc, #32]	; (1eeac <net_buf_slist_get+0xf0>)
   1ee8c:	22b9      	movs	r2, #185	; 0xb9
   1ee8e:	4621      	mov	r1, r4
   1ee90:	4805      	ldr	r0, [pc, #20]	; (1eea8 <net_buf_slist_get+0xec>)
   1ee92:	f00d fb4c 	bl	2c52e <assert_print>
   1ee96:	21b9      	movs	r1, #185	; 0xb9
   1ee98:	4620      	mov	r0, r4
   1ee9a:	f00d fb41 	bl	2c520 <assert_post_action>
   1ee9e:	e7ed      	b.n	1ee7c <net_buf_slist_get+0xc0>
   1eea0:	20003ccc 	.word	0x20003ccc
   1eea4:	0003ad78 	.word	0x0003ad78
   1eea8:	00031600 	.word	0x00031600
   1eeac:	000390f0 	.word	0x000390f0

0001eeb0 <net_buf_put>:

void net_buf_put(struct k_fifo *fifo, struct net_buf *buf)
{
   1eeb0:	b570      	push	{r4, r5, r6, lr}
   1eeb2:	460c      	mov	r4, r1
	struct net_buf *tail;

	__ASSERT_NO_MSG(fifo);
   1eeb4:	4605      	mov	r5, r0
   1eeb6:	b110      	cbz	r0, 1eebe <net_buf_put+0xe>
	__ASSERT_NO_MSG(buf);
   1eeb8:	b174      	cbz	r4, 1eed8 <net_buf_put+0x28>
{
   1eeba:	4622      	mov	r2, r4
   1eebc:	e01e      	b.n	1eefc <net_buf_put+0x4c>
	__ASSERT_NO_MSG(fifo);
   1eebe:	4e13      	ldr	r6, [pc, #76]	; (1ef0c <net_buf_put+0x5c>)
   1eec0:	f44f 7200 	mov.w	r2, #512	; 0x200
   1eec4:	4631      	mov	r1, r6
   1eec6:	4812      	ldr	r0, [pc, #72]	; (1ef10 <net_buf_put+0x60>)
   1eec8:	f00d fb31 	bl	2c52e <assert_print>
   1eecc:	f44f 7100 	mov.w	r1, #512	; 0x200
   1eed0:	4630      	mov	r0, r6
   1eed2:	f00d fb25 	bl	2c520 <assert_post_action>
   1eed6:	e7ef      	b.n	1eeb8 <net_buf_put+0x8>
	__ASSERT_NO_MSG(buf);
   1eed8:	4e0c      	ldr	r6, [pc, #48]	; (1ef0c <net_buf_put+0x5c>)
   1eeda:	f240 2201 	movw	r2, #513	; 0x201
   1eede:	4631      	mov	r1, r6
   1eee0:	480b      	ldr	r0, [pc, #44]	; (1ef10 <net_buf_put+0x60>)
   1eee2:	f00d fb24 	bl	2c52e <assert_print>
   1eee6:	f240 2101 	movw	r1, #513	; 0x201
   1eeea:	4630      	mov	r0, r6
   1eeec:	f00d fb18 	bl	2c520 <assert_post_action>
   1eef0:	e7e3      	b.n	1eeba <net_buf_put+0xa>

	for (tail = buf; tail->frags; tail = tail->frags) {
		tail->flags |= NET_BUF_FRAGS;
   1eef2:	7953      	ldrb	r3, [r2, #5]
   1eef4:	f043 0301 	orr.w	r3, r3, #1
   1eef8:	7153      	strb	r3, [r2, #5]
	for (tail = buf; tail->frags; tail = tail->frags) {
   1eefa:	4602      	mov	r2, r0
   1eefc:	6810      	ldr	r0, [r2, #0]
   1eefe:	2800      	cmp	r0, #0
   1ef00:	d1f7      	bne.n	1eef2 <net_buf_put+0x42>
	}

	k_fifo_put_list(fifo, buf, tail);
   1ef02:	4621      	mov	r1, r4
   1ef04:	4628      	mov	r0, r5
   1ef06:	f007 ff75 	bl	26df4 <k_queue_append_list>
}
   1ef0a:	bd70      	pop	{r4, r5, r6, pc}
   1ef0c:	0003ad78 	.word	0x0003ad78
   1ef10:	00031600 	.word	0x00031600

0001ef14 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   1ef14:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(buf);
   1ef16:	4604      	mov	r4, r0
   1ef18:	b9b8      	cbnz	r0, 1ef4a <net_buf_unref+0x36>
   1ef1a:	4d18      	ldr	r5, [pc, #96]	; (1ef7c <net_buf_unref+0x68>)
   1ef1c:	f44f 7204 	mov.w	r2, #528	; 0x210
   1ef20:	4629      	mov	r1, r5
   1ef22:	4817      	ldr	r0, [pc, #92]	; (1ef80 <net_buf_unref+0x6c>)
   1ef24:	f00d fb03 	bl	2c52e <assert_print>
   1ef28:	f44f 7104 	mov.w	r1, #528	; 0x210
   1ef2c:	4628      	mov	r0, r5
   1ef2e:	f00d faf7 	bl	2c520 <assert_post_action>
   1ef32:	e00a      	b.n	1ef4a <net_buf_unref+0x36>
		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
		}

		buf->data = NULL;
   1ef34:	2300      	movs	r3, #0
   1ef36:	60a3      	str	r3, [r4, #8]
		buf->frags = NULL;
   1ef38:	6023      	str	r3, [r4, #0]

		pool = net_buf_pool_get(buf->pool_id);
   1ef3a:	79a0      	ldrb	r0, [r4, #6]
   1ef3c:	f7ff fd60 	bl	1ea00 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
   1ef40:	6a83      	ldr	r3, [r0, #40]	; 0x28
   1ef42:	b193      	cbz	r3, 1ef6a <net_buf_unref+0x56>
			pool->destroy(buf);
   1ef44:	4620      	mov	r0, r4
   1ef46:	4798      	blx	r3
{
   1ef48:	462c      	mov	r4, r5
	while (buf) {
   1ef4a:	b1ac      	cbz	r4, 1ef78 <net_buf_unref+0x64>
		struct net_buf *frags = buf->frags;
   1ef4c:	6825      	ldr	r5, [r4, #0]
		if (--buf->ref > 0) {
   1ef4e:	7923      	ldrb	r3, [r4, #4]
   1ef50:	3b01      	subs	r3, #1
   1ef52:	b2db      	uxtb	r3, r3
   1ef54:	7123      	strb	r3, [r4, #4]
   1ef56:	b97b      	cbnz	r3, 1ef78 <net_buf_unref+0x64>
		if (buf->__buf) {
   1ef58:	6921      	ldr	r1, [r4, #16]
   1ef5a:	2900      	cmp	r1, #0
   1ef5c:	d0ea      	beq.n	1ef34 <net_buf_unref+0x20>
			data_unref(buf, buf->__buf);
   1ef5e:	4620      	mov	r0, r4
   1ef60:	f00f ff6e 	bl	2ee40 <data_unref>
			buf->__buf = NULL;
   1ef64:	2300      	movs	r3, #0
   1ef66:	6123      	str	r3, [r4, #16]
   1ef68:	e7e4      	b.n	1ef34 <net_buf_unref+0x20>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1ef6a:	79a0      	ldrb	r0, [r4, #6]
   1ef6c:	f7ff fd48 	bl	1ea00 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
   1ef70:	4621      	mov	r1, r4
   1ef72:	f011 fd4d 	bl	30a10 <k_queue_prepend>
}
   1ef76:	e7e7      	b.n	1ef48 <net_buf_unref+0x34>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   1ef78:	bd38      	pop	{r3, r4, r5, pc}
   1ef7a:	bf00      	nop
   1ef7c:	0003ad78 	.word	0x0003ad78
   1ef80:	00031600 	.word	0x00031600

0001ef84 <net_buf_ref>:

struct net_buf *net_buf_ref(struct net_buf *buf)
{
   1ef84:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(buf);
   1ef86:	4604      	mov	r4, r0
   1ef88:	b120      	cbz	r0, 1ef94 <net_buf_ref+0x10>

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   1ef8a:	7923      	ldrb	r3, [r4, #4]
   1ef8c:	3301      	adds	r3, #1
   1ef8e:	7123      	strb	r3, [r4, #4]
	return buf;
}
   1ef90:	4620      	mov	r0, r4
   1ef92:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(buf);
   1ef94:	4d06      	ldr	r5, [pc, #24]	; (1efb0 <net_buf_ref+0x2c>)
   1ef96:	f240 223f 	movw	r2, #575	; 0x23f
   1ef9a:	4629      	mov	r1, r5
   1ef9c:	4805      	ldr	r0, [pc, #20]	; (1efb4 <net_buf_ref+0x30>)
   1ef9e:	f00d fac6 	bl	2c52e <assert_print>
   1efa2:	f240 213f 	movw	r1, #575	; 0x23f
   1efa6:	4628      	mov	r0, r5
   1efa8:	f00d faba 	bl	2c520 <assert_post_action>
   1efac:	e7ed      	b.n	1ef8a <net_buf_ref+0x6>
   1efae:	bf00      	nop
   1efb0:	0003ad78 	.word	0x0003ad78
   1efb4:	00031600 	.word	0x00031600

0001efb8 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
   1efb8:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(buf);
   1efba:	4604      	mov	r4, r0
   1efbc:	b120      	cbz	r0, 1efc8 <net_buf_frag_last+0x10>

	while (buf->frags) {
   1efbe:	4620      	mov	r0, r4
   1efc0:	6824      	ldr	r4, [r4, #0]
   1efc2:	2c00      	cmp	r4, #0
   1efc4:	d1fb      	bne.n	1efbe <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
   1efc6:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(buf);
   1efc8:	4d06      	ldr	r5, [pc, #24]	; (1efe4 <net_buf_frag_last+0x2c>)
   1efca:	f44f 721f 	mov.w	r2, #636	; 0x27c
   1efce:	4629      	mov	r1, r5
   1efd0:	4805      	ldr	r0, [pc, #20]	; (1efe8 <net_buf_frag_last+0x30>)
   1efd2:	f00d faac 	bl	2c52e <assert_print>
   1efd6:	f44f 711f 	mov.w	r1, #636	; 0x27c
   1efda:	4628      	mov	r0, r5
   1efdc:	f00d faa0 	bl	2c520 <assert_post_action>
   1efe0:	e7ed      	b.n	1efbe <net_buf_frag_last+0x6>
   1efe2:	bf00      	nop
   1efe4:	0003ad78 	.word	0x0003ad78
   1efe8:	00031600 	.word	0x00031600

0001efec <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
   1efec:	b570      	push	{r4, r5, r6, lr}
   1efee:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(parent);
   1eff0:	4605      	mov	r5, r0
   1eff2:	b148      	cbz	r0, 1f008 <net_buf_frag_insert+0x1c>
	__ASSERT_NO_MSG(frag);
   1eff4:	b1ac      	cbz	r4, 1f022 <net_buf_frag_insert+0x36>

	if (parent->frags) {
   1eff6:	682b      	ldr	r3, [r5, #0]
   1eff8:	b123      	cbz	r3, 1f004 <net_buf_frag_insert+0x18>
		net_buf_frag_last(frag)->frags = parent->frags;
   1effa:	4620      	mov	r0, r4
   1effc:	f7ff ffdc 	bl	1efb8 <net_buf_frag_last>
   1f000:	682b      	ldr	r3, [r5, #0]
   1f002:	6003      	str	r3, [r0, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   1f004:	602c      	str	r4, [r5, #0]
}
   1f006:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(parent);
   1f008:	4e0c      	ldr	r6, [pc, #48]	; (1f03c <net_buf_frag_insert+0x50>)
   1f00a:	f240 2287 	movw	r2, #647	; 0x287
   1f00e:	4631      	mov	r1, r6
   1f010:	480b      	ldr	r0, [pc, #44]	; (1f040 <net_buf_frag_insert+0x54>)
   1f012:	f00d fa8c 	bl	2c52e <assert_print>
   1f016:	f240 2187 	movw	r1, #647	; 0x287
   1f01a:	4630      	mov	r0, r6
   1f01c:	f00d fa80 	bl	2c520 <assert_post_action>
   1f020:	e7e8      	b.n	1eff4 <net_buf_frag_insert+0x8>
	__ASSERT_NO_MSG(frag);
   1f022:	4e06      	ldr	r6, [pc, #24]	; (1f03c <net_buf_frag_insert+0x50>)
   1f024:	f44f 7222 	mov.w	r2, #648	; 0x288
   1f028:	4631      	mov	r1, r6
   1f02a:	4805      	ldr	r0, [pc, #20]	; (1f040 <net_buf_frag_insert+0x54>)
   1f02c:	f00d fa7f 	bl	2c52e <assert_print>
   1f030:	f44f 7122 	mov.w	r1, #648	; 0x288
   1f034:	4630      	mov	r0, r6
   1f036:	f00d fa73 	bl	2c520 <assert_post_action>
   1f03a:	e7dc      	b.n	1eff6 <net_buf_frag_insert+0xa>
   1f03c:	0003ad78 	.word	0x0003ad78
   1f040:	00031600 	.word	0x00031600

0001f044 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
   1f044:	b570      	push	{r4, r5, r6, lr}
   1f046:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(frag);
   1f048:	460d      	mov	r5, r1
   1f04a:	b141      	cbz	r1, 1f05e <net_buf_frag_add+0x1a>

	if (!head) {
   1f04c:	b1a4      	cbz	r4, 1f078 <net_buf_frag_add+0x34>
		return net_buf_ref(frag);
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);
   1f04e:	4620      	mov	r0, r4
   1f050:	f7ff ffb2 	bl	1efb8 <net_buf_frag_last>
   1f054:	4629      	mov	r1, r5
   1f056:	f7ff ffc9 	bl	1efec <net_buf_frag_insert>

	return head;
   1f05a:	4620      	mov	r0, r4
}
   1f05c:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(frag);
   1f05e:	4e08      	ldr	r6, [pc, #32]	; (1f080 <net_buf_frag_add+0x3c>)
   1f060:	f240 2293 	movw	r2, #659	; 0x293
   1f064:	4631      	mov	r1, r6
   1f066:	4807      	ldr	r0, [pc, #28]	; (1f084 <net_buf_frag_add+0x40>)
   1f068:	f00d fa61 	bl	2c52e <assert_print>
   1f06c:	f240 2193 	movw	r1, #659	; 0x293
   1f070:	4630      	mov	r0, r6
   1f072:	f00d fa55 	bl	2c520 <assert_post_action>
   1f076:	e7e9      	b.n	1f04c <net_buf_frag_add+0x8>
		return net_buf_ref(frag);
   1f078:	4628      	mov	r0, r5
   1f07a:	f7ff ff83 	bl	1ef84 <net_buf_ref>
   1f07e:	e7ed      	b.n	1f05c <net_buf_frag_add+0x18>
   1f080:	0003ad78 	.word	0x0003ad78
   1f084:	00031600 	.word	0x00031600

0001f088 <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
   1f088:	b570      	push	{r4, r5, r6, lr}
   1f08a:	4604      	mov	r4, r0
   1f08c:	460d      	mov	r5, r1
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);
   1f08e:	8883      	ldrh	r3, [r0, #4]
   1f090:	428b      	cmp	r3, r1
   1f092:	d306      	bcc.n	1f0a2 <net_buf_simple_pull+0x1a>

	buf->len -= len;
   1f094:	88a3      	ldrh	r3, [r4, #4]
   1f096:	1b5b      	subs	r3, r3, r5
   1f098:	80a3      	strh	r3, [r4, #4]
	return buf->data += len;
   1f09a:	6820      	ldr	r0, [r4, #0]
   1f09c:	4428      	add	r0, r5
   1f09e:	6020      	str	r0, [r4, #0]
}
   1f0a0:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(buf->len >= len);
   1f0a2:	4e06      	ldr	r6, [pc, #24]	; (1f0bc <net_buf_simple_pull+0x34>)
   1f0a4:	f240 4277 	movw	r2, #1143	; 0x477
   1f0a8:	4631      	mov	r1, r6
   1f0aa:	4805      	ldr	r0, [pc, #20]	; (1f0c0 <net_buf_simple_pull+0x38>)
   1f0ac:	f00d fa3f 	bl	2c52e <assert_print>
   1f0b0:	f240 4177 	movw	r1, #1143	; 0x477
   1f0b4:	4630      	mov	r0, r6
   1f0b6:	f00d fa33 	bl	2c520 <assert_post_action>
   1f0ba:	e7eb      	b.n	1f094 <net_buf_simple_pull+0xc>
   1f0bc:	0003ad78 	.word	0x0003ad78
   1f0c0:	00031600 	.word	0x00031600

0001f0c4 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   1f0c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f0c6:	4604      	mov	r4, r0
   1f0c8:	460d      	mov	r5, r1
	void *data = buf->data;
   1f0ca:	6806      	ldr	r6, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);
   1f0cc:	8883      	ldrh	r3, [r0, #4]
   1f0ce:	428b      	cmp	r3, r1
   1f0d0:	d307      	bcc.n	1f0e2 <net_buf_simple_pull_mem+0x1e>

	buf->len -= len;
   1f0d2:	88a3      	ldrh	r3, [r4, #4]
   1f0d4:	1b5b      	subs	r3, r3, r5
   1f0d6:	80a3      	strh	r3, [r4, #4]
	buf->data += len;
   1f0d8:	6821      	ldr	r1, [r4, #0]
   1f0da:	4429      	add	r1, r5
   1f0dc:	6021      	str	r1, [r4, #0]

	return data;
}
   1f0de:	4630      	mov	r0, r6
   1f0e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT_NO_MSG(buf->len >= len);
   1f0e2:	4f06      	ldr	r7, [pc, #24]	; (1f0fc <net_buf_simple_pull_mem+0x38>)
   1f0e4:	f240 4283 	movw	r2, #1155	; 0x483
   1f0e8:	4639      	mov	r1, r7
   1f0ea:	4805      	ldr	r0, [pc, #20]	; (1f100 <net_buf_simple_pull_mem+0x3c>)
   1f0ec:	f00d fa1f 	bl	2c52e <assert_print>
   1f0f0:	f240 4183 	movw	r1, #1155	; 0x483
   1f0f4:	4638      	mov	r0, r7
   1f0f6:	f00d fa13 	bl	2c520 <assert_post_action>
   1f0fa:	e7ea      	b.n	1f0d2 <net_buf_simple_pull_mem+0xe>
   1f0fc:	0003ad78 	.word	0x0003ad78
   1f100:	00031600 	.word	0x00031600

0001f104 <net_buf_simple_push>:
{
   1f104:	b570      	push	{r4, r5, r6, lr}
   1f106:	4605      	mov	r5, r0
   1f108:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);
   1f10a:	f00f fee4 	bl	2eed6 <net_buf_simple_headroom>
   1f10e:	42a0      	cmp	r0, r4
   1f110:	d306      	bcc.n	1f120 <net_buf_simple_push+0x1c>
	buf->data -= len;
   1f112:	6828      	ldr	r0, [r5, #0]
   1f114:	1b00      	subs	r0, r0, r4
   1f116:	6028      	str	r0, [r5, #0]
	buf->len += len;
   1f118:	88a9      	ldrh	r1, [r5, #4]
   1f11a:	440c      	add	r4, r1
   1f11c:	80ac      	strh	r4, [r5, #4]
}
   1f11e:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);
   1f120:	4e06      	ldr	r6, [pc, #24]	; (1f13c <net_buf_simple_push+0x38>)
   1f122:	f240 4217 	movw	r2, #1047	; 0x417
   1f126:	4631      	mov	r1, r6
   1f128:	4805      	ldr	r0, [pc, #20]	; (1f140 <net_buf_simple_push+0x3c>)
   1f12a:	f00d fa00 	bl	2c52e <assert_print>
   1f12e:	f240 4117 	movw	r1, #1047	; 0x417
   1f132:	4630      	mov	r0, r6
   1f134:	f00d f9f4 	bl	2c520 <assert_post_action>
   1f138:	e7eb      	b.n	1f112 <net_buf_simple_push+0xe>
   1f13a:	bf00      	nop
   1f13c:	0003ad78 	.word	0x0003ad78
   1f140:	00031600 	.word	0x00031600

0001f144 <net_buf_simple_add>:
{
   1f144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1f146:	4604      	mov	r4, r0
   1f148:	460d      	mov	r5, r1
	return buf->data + buf->len;
   1f14a:	6803      	ldr	r3, [r0, #0]
   1f14c:	8886      	ldrh	r6, [r0, #4]
   1f14e:	441e      	add	r6, r3
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
   1f150:	f00f fec5 	bl	2eede <net_buf_simple_tailroom>
   1f154:	42a8      	cmp	r0, r5
   1f156:	d304      	bcc.n	1f162 <net_buf_simple_add+0x1e>
	buf->len += len;
   1f158:	88a1      	ldrh	r1, [r4, #4]
   1f15a:	440d      	add	r5, r1
   1f15c:	80a5      	strh	r5, [r4, #4]
}
   1f15e:	4630      	mov	r0, r6
   1f160:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
   1f162:	4f06      	ldr	r7, [pc, #24]	; (1f17c <net_buf_simple_add+0x38>)
   1f164:	f44f 724a 	mov.w	r2, #808	; 0x328
   1f168:	4639      	mov	r1, r7
   1f16a:	4805      	ldr	r0, [pc, #20]	; (1f180 <net_buf_simple_add+0x3c>)
   1f16c:	f00d f9df 	bl	2c52e <assert_print>
   1f170:	f44f 714a 	mov.w	r1, #808	; 0x328
   1f174:	4638      	mov	r0, r7
   1f176:	f00d f9d3 	bl	2c520 <assert_post_action>
   1f17a:	e7ed      	b.n	1f158 <net_buf_simple_add+0x14>
   1f17c:	0003ad78 	.word	0x0003ad78
   1f180:	00031600 	.word	0x00031600

0001f184 <xoshiro128_initialize>:
{
	return (x << k) | (x >> (32 - k));
}

static int xoshiro128_initialize(const struct device *dev)
{
   1f184:	b508      	push	{r3, lr}
	entropy_driver = DEVICE_DT_GET(DT_CHOSEN(zephyr_entropy));
   1f186:	4805      	ldr	r0, [pc, #20]	; (1f19c <xoshiro128_initialize+0x18>)
   1f188:	4b05      	ldr	r3, [pc, #20]	; (1f1a0 <xoshiro128_initialize+0x1c>)
   1f18a:	6018      	str	r0, [r3, #0]
   1f18c:	f011 fb7a 	bl	30884 <z_device_is_ready>
	if (!device_is_ready(entropy_driver)) {
   1f190:	b108      	cbz	r0, 1f196 <xoshiro128_initialize+0x12>
		return -ENODEV;
	}
	return 0;
   1f192:	2000      	movs	r0, #0
}
   1f194:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1f196:	f06f 0012 	mvn.w	r0, #18
   1f19a:	e7fb      	b.n	1f194 <xoshiro128_initialize+0x10>
   1f19c:	0003100c 	.word	0x0003100c
   1f1a0:	20003cd0 	.word	0x20003cd0

0001f1a4 <get_hf_flags>:
static uint32_t *get_hf_flags(void)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
}
   1f1a4:	4800      	ldr	r0, [pc, #0]	; (1f1a8 <get_hf_flags+0x4>)
   1f1a6:	4770      	bx	lr
   1f1a8:	20003d2c 	.word	0x20003d2c

0001f1ac <get_subsys>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   1f1ac:	4b01      	ldr	r3, [pc, #4]	; (1f1b4 <get_subsys+0x8>)
   1f1ae:	1ac0      	subs	r0, r0, r3

	return (clock_control_subsys_t)offset;
}
   1f1b0:	1140      	asrs	r0, r0, #5
   1f1b2:	4770      	bx	lr
   1f1b4:	20003ce4 	.word	0x20003ce4

0001f1b8 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   1f1b8:	b530      	push	{r4, r5, lr}
   1f1ba:	b083      	sub	sp, #12
   1f1bc:	4605      	mov	r5, r0
   1f1be:	460c      	mov	r4, r1
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f1c0:	f7ff fff4 	bl	1f1ac <get_subsys>
   1f1c4:	4601      	mov	r1, r0
   1f1c6:	2340      	movs	r3, #64	; 0x40
   1f1c8:	9300      	str	r3, [sp, #0]
   1f1ca:	4623      	mov	r3, r4
   1f1cc:	4a05      	ldr	r2, [pc, #20]	; (1f1e4 <onoff_start+0x2c>)
   1f1ce:	4806      	ldr	r0, [pc, #24]	; (1f1e8 <onoff_start+0x30>)
   1f1d0:	f00f ff16 	bl	2f000 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
   1f1d4:	1e01      	subs	r1, r0, #0
   1f1d6:	db01      	blt.n	1f1dc <onoff_start+0x24>
		notify(mgr, err);
	}
}
   1f1d8:	b003      	add	sp, #12
   1f1da:	bd30      	pop	{r4, r5, pc}
		notify(mgr, err);
   1f1dc:	4628      	mov	r0, r5
   1f1de:	47a0      	blx	r4
}
   1f1e0:	e7fa      	b.n	1f1d8 <onoff_start+0x20>
   1f1e2:	bf00      	nop
   1f1e4:	0002f049 	.word	0x0002f049
   1f1e8:	00030fd4 	.word	0x00030fd4

0001f1ec <generic_hfclk_stop>:
{
   1f1ec:	b508      	push	{r3, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1f1ee:	4b0a      	ldr	r3, [pc, #40]	; (1f218 <generic_hfclk_stop+0x2c>)
   1f1f0:	f3bf 8f5b 	dmb	ish
   1f1f4:	e853 2f00 	ldrex	r2, [r3]
   1f1f8:	f022 0102 	bic.w	r1, r2, #2
   1f1fc:	e843 1000 	strex	r0, r1, [r3]
   1f200:	2800      	cmp	r0, #0
   1f202:	d1f7      	bne.n	1f1f4 <generic_hfclk_stop+0x8>
   1f204:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   1f208:	f012 0f01 	tst.w	r2, #1
   1f20c:	d000      	beq.n	1f210 <generic_hfclk_stop+0x24>
}
   1f20e:	bd08      	pop	{r3, pc}
	hfclk_stop();
   1f210:	f00f ff27 	bl	2f062 <hfclk_stop>
   1f214:	e7fb      	b.n	1f20e <generic_hfclk_stop+0x22>
   1f216:	bf00      	nop
   1f218:	20003d3c 	.word	0x20003d3c

0001f21c <get_status>:
{
   1f21c:	b570      	push	{r4, r5, r6, lr}
   1f21e:	4605      	mov	r5, r0
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   1f220:	b2cc      	uxtb	r4, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1f222:	2c01      	cmp	r4, #1
   1f224:	d807      	bhi.n	1f236 <get_status+0x1a>
	return GET_STATUS(get_sub_data(dev, type)->flags);
   1f226:	4621      	mov	r1, r4
   1f228:	4628      	mov	r0, r5
   1f22a:	f00f fe7c 	bl	2ef26 <get_sub_data>
   1f22e:	6880      	ldr	r0, [r0, #8]
}
   1f230:	f000 0007 	and.w	r0, r0, #7
   1f234:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1f236:	4e05      	ldr	r6, [pc, #20]	; (1f24c <get_status+0x30>)
   1f238:	2279      	movs	r2, #121	; 0x79
   1f23a:	4631      	mov	r1, r6
   1f23c:	4804      	ldr	r0, [pc, #16]	; (1f250 <get_status+0x34>)
   1f23e:	f00d f976 	bl	2c52e <assert_print>
   1f242:	2179      	movs	r1, #121	; 0x79
   1f244:	4630      	mov	r0, r6
   1f246:	f00d f96b 	bl	2c520 <assert_post_action>
   1f24a:	e7ec      	b.n	1f226 <get_status+0xa>
   1f24c:	0003adb0 	.word	0x0003adb0
   1f250:	00031600 	.word	0x00031600

0001f254 <stop>:
{
   1f254:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f258:	4607      	mov	r7, r0
   1f25a:	4616      	mov	r6, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   1f25c:	b2cc      	uxtb	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   1f25e:	4621      	mov	r1, r4
   1f260:	f00f fe61 	bl	2ef26 <get_sub_data>
   1f264:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1f266:	2c01      	cmp	r4, #1
   1f268:	d80f      	bhi.n	1f28a <stop+0x36>
	err = set_off_state(&subdata->flags, ctx);
   1f26a:	4631      	mov	r1, r6
   1f26c:	f105 0008 	add.w	r0, r5, #8
   1f270:	f00f fe6a 	bl	2ef48 <set_off_state>
	if (err < 0) {
   1f274:	2800      	cmp	r0, #0
   1f276:	db06      	blt.n	1f286 <stop+0x32>
	get_sub_config(dev, type)->stop();
   1f278:	4621      	mov	r1, r4
   1f27a:	4638      	mov	r0, r7
   1f27c:	f00f fe5a 	bl	2ef34 <get_sub_config>
   1f280:	6843      	ldr	r3, [r0, #4]
   1f282:	4798      	blx	r3
	return 0;
   1f284:	2000      	movs	r0, #0
}
   1f286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1f28a:	f8df 8020 	ldr.w	r8, [pc, #32]	; 1f2ac <stop+0x58>
   1f28e:	f240 124d 	movw	r2, #333	; 0x14d
   1f292:	4641      	mov	r1, r8
   1f294:	4804      	ldr	r0, [pc, #16]	; (1f2a8 <stop+0x54>)
   1f296:	f00d f94a 	bl	2c52e <assert_print>
   1f29a:	f240 114d 	movw	r1, #333	; 0x14d
   1f29e:	4640      	mov	r0, r8
   1f2a0:	f00d f93e 	bl	2c520 <assert_post_action>
   1f2a4:	e7e1      	b.n	1f26a <stop+0x16>
   1f2a6:	bf00      	nop
   1f2a8:	00031600 	.word	0x00031600
   1f2ac:	0003adb0 	.word	0x0003adb0

0001f2b0 <onoff_stop>:
{
   1f2b0:	b538      	push	{r3, r4, r5, lr}
   1f2b2:	4605      	mov	r5, r0
   1f2b4:	460c      	mov	r4, r1
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f2b6:	f7ff ff79 	bl	1f1ac <get_subsys>
   1f2ba:	4601      	mov	r1, r0
   1f2bc:	2240      	movs	r2, #64	; 0x40
   1f2be:	4803      	ldr	r0, [pc, #12]	; (1f2cc <onoff_stop+0x1c>)
   1f2c0:	f7ff ffc8 	bl	1f254 <stop>
   1f2c4:	4601      	mov	r1, r0
	notify(mgr, res);
   1f2c6:	4628      	mov	r0, r5
   1f2c8:	47a0      	blx	r4
}
   1f2ca:	bd38      	pop	{r3, r4, r5, pc}
   1f2cc:	00030fd4 	.word	0x00030fd4

0001f2d0 <clock_event_handler>:
		__ASSERT_NO_MSG(false);
	}
}

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
   1f2d0:	b510      	push	{r4, lr}
	const struct device *dev = CLOCK_DEVICE;

	switch (event) {
   1f2d2:	2801      	cmp	r0, #1
   1f2d4:	d01c      	beq.n	1f310 <clock_event_handler+0x40>
   1f2d6:	2803      	cmp	r0, #3
   1f2d8:	d01f      	beq.n	1f31a <clock_event_handler+0x4a>
   1f2da:	b160      	cbz	r0, 1f2f6 <clock_event_handler+0x26>
			/* Should not happen when calibration is disabled. */
			__ASSERT_NO_MSG(false);
		}
		break;
	default:
		__ASSERT_NO_MSG(0);
   1f2dc:	4c15      	ldr	r4, [pc, #84]	; (1f334 <clock_event_handler+0x64>)
   1f2de:	f240 2262 	movw	r2, #610	; 0x262
   1f2e2:	4621      	mov	r1, r4
   1f2e4:	4814      	ldr	r0, [pc, #80]	; (1f338 <clock_event_handler+0x68>)
   1f2e6:	f00d f922 	bl	2c52e <assert_print>
   1f2ea:	f240 2162 	movw	r1, #610	; 0x262
   1f2ee:	4620      	mov	r0, r4
   1f2f0:	f00d f916 	bl	2c520 <assert_post_action>
		break;
	}
}
   1f2f4:	e010      	b.n	1f318 <clock_event_handler+0x48>
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   1f2f6:	2100      	movs	r1, #0
   1f2f8:	4810      	ldr	r0, [pc, #64]	; (1f33c <clock_event_handler+0x6c>)
   1f2fa:	f00f fe14 	bl	2ef26 <get_sub_data>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   1f2fe:	6883      	ldr	r3, [r0, #8]
   1f300:	f013 0f07 	tst.w	r3, #7
   1f304:	d108      	bne.n	1f318 <clock_event_handler+0x48>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   1f306:	2100      	movs	r1, #0
   1f308:	480c      	ldr	r0, [pc, #48]	; (1f33c <clock_event_handler+0x6c>)
   1f30a:	f00f fe67 	bl	2efdc <clkstarted_handle>
   1f30e:	e003      	b.n	1f318 <clock_event_handler+0x48>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f310:	2101      	movs	r1, #1
   1f312:	480a      	ldr	r0, [pc, #40]	; (1f33c <clock_event_handler+0x6c>)
   1f314:	f00f fe62 	bl	2efdc <clkstarted_handle>
}
   1f318:	bd10      	pop	{r4, pc}
			__ASSERT_NO_MSG(false);
   1f31a:	4c06      	ldr	r4, [pc, #24]	; (1f334 <clock_event_handler+0x64>)
   1f31c:	f240 225e 	movw	r2, #606	; 0x25e
   1f320:	4621      	mov	r1, r4
   1f322:	4805      	ldr	r0, [pc, #20]	; (1f338 <clock_event_handler+0x68>)
   1f324:	f00d f903 	bl	2c52e <assert_print>
   1f328:	f240 215e 	movw	r1, #606	; 0x25e
   1f32c:	4620      	mov	r0, r4
   1f32e:	f00d f8f7 	bl	2c520 <assert_post_action>
		break;
   1f332:	e7f1      	b.n	1f318 <clock_event_handler+0x48>
   1f334:	0003adb0 	.word	0x0003adb0
   1f338:	00031600 	.word	0x00031600
   1f33c:	00030fd4 	.word	0x00030fd4

0001f340 <api_blocking_start>:
{
   1f340:	b500      	push	{lr}
   1f342:	b087      	sub	sp, #28
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f344:	f8cd d000 	str.w	sp, [sp]
   1f348:	f8cd d004 	str.w	sp, [sp, #4]
   1f34c:	2300      	movs	r3, #0
   1f34e:	9302      	str	r3, [sp, #8]
   1f350:	2301      	movs	r3, #1
   1f352:	9303      	str	r3, [sp, #12]
   1f354:	ab04      	add	r3, sp, #16
   1f356:	9304      	str	r3, [sp, #16]
   1f358:	9305      	str	r3, [sp, #20]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f35a:	466b      	mov	r3, sp
   1f35c:	4a06      	ldr	r2, [pc, #24]	; (1f378 <api_blocking_start+0x38>)
   1f35e:	f00f fe6b 	bl	2f038 <api_start>
	if (err < 0) {
   1f362:	2800      	cmp	r0, #0
   1f364:	db05      	blt.n	1f372 <api_blocking_start+0x32>
	return z_impl_k_sem_take(sem, timeout);
   1f366:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1f36a:	2300      	movs	r3, #0
   1f36c:	4668      	mov	r0, sp
   1f36e:	f007 fe51 	bl	27014 <z_impl_k_sem_take>
}
   1f372:	b007      	add	sp, #28
   1f374:	f85d fb04 	ldr.w	pc, [sp], #4
   1f378:	0002f081 	.word	0x0002f081

0001f37c <lfclk_start>:
{
   1f37c:	b508      	push	{r3, lr}
	if (!once) {
   1f37e:	4b07      	ldr	r3, [pc, #28]	; (1f39c <lfclk_start+0x20>)
   1f380:	781b      	ldrb	r3, [r3, #0]
   1f382:	b11b      	cbz	r3, 1f38c <lfclk_start+0x10>
}
#endif // defined(CLOCK_FEATURE_HFCLK_DIVIDE_PRESENT) || NRF_CLOCK_HAS_HFCLK_192M

NRFX_STATIC_INLINE void nrfx_clock_lfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   1f384:	2000      	movs	r0, #0
   1f386:	f003 fccb 	bl	22d20 <nrfx_clock_start>
}
   1f38a:	bd08      	pop	{r3, pc}
	z_impl_k_busy_wait(usec_to_wait);
   1f38c:	f44f 70a5 	mov.w	r0, #330	; 0x14a
   1f390:	f011 fc13 	bl	30bba <z_impl_k_busy_wait>
		once = true;
   1f394:	4b01      	ldr	r3, [pc, #4]	; (1f39c <lfclk_start+0x20>)
   1f396:	2201      	movs	r2, #1
   1f398:	701a      	strb	r2, [r3, #0]
   1f39a:	e7f3      	b.n	1f384 <lfclk_start+0x8>
   1f39c:	20004710 	.word	0x20004710

0001f3a0 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   1f3a0:	b570      	push	{r4, r5, r6, lr}
   1f3a2:	4606      	mov	r6, r0
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f3a4:	2200      	movs	r2, #0
   1f3a6:	2101      	movs	r1, #1
   1f3a8:	4610      	mov	r0, r2
   1f3aa:	f7f8 ffa5 	bl	182f8 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
   1f3ae:	4811      	ldr	r0, [pc, #68]	; (1f3f4 <clk_init+0x54>)
   1f3b0:	f003 fcee 	bl	22d90 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   1f3b4:	4b10      	ldr	r3, [pc, #64]	; (1f3f8 <clk_init+0x58>)
   1f3b6:	4298      	cmp	r0, r3
   1f3b8:	d119      	bne.n	1f3ee <clk_init+0x4e>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   1f3ba:	f011 f868 	bl	3048e <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
   1f3be:	2400      	movs	r4, #0
   1f3c0:	2c01      	cmp	r4, #1
   1f3c2:	d812      	bhi.n	1f3ea <clk_init+0x4a>
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   1f3c4:	4621      	mov	r1, r4
   1f3c6:	4630      	mov	r0, r6
   1f3c8:	f00f fdad 	bl	2ef26 <get_sub_data>
   1f3cc:	4605      	mov	r5, r0

		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f3ce:	4621      	mov	r1, r4
   1f3d0:	4630      	mov	r0, r6
   1f3d2:	f00f fdb5 	bl	2ef40 <get_onoff_manager>
   1f3d6:	4909      	ldr	r1, [pc, #36]	; (1f3fc <clk_init+0x5c>)
   1f3d8:	f00c fea2 	bl	2c120 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   1f3dc:	2800      	cmp	r0, #0
   1f3de:	db05      	blt.n	1f3ec <clk_init+0x4c>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f3e0:	2301      	movs	r3, #1
   1f3e2:	60ab      	str	r3, [r5, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f3e4:	441c      	add	r4, r3
   1f3e6:	b2e4      	uxtb	r4, r4
   1f3e8:	e7ea      	b.n	1f3c0 <clk_init+0x20>
	}

	return 0;
   1f3ea:	2000      	movs	r0, #0
}
   1f3ec:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   1f3ee:	f06f 0004 	mvn.w	r0, #4
   1f3f2:	e7fb      	b.n	1f3ec <clk_init+0x4c>
   1f3f4:	0001f2d1 	.word	0x0001f2d1
   1f3f8:	0bad0000 	.word	0x0bad0000
   1f3fc:	0003ae54 	.word	0x0003ae54

0001f400 <lfclk_spinwait>:
{
   1f400:	b570      	push	{r4, r5, r6, lr}
   1f402:	4605      	mov	r5, r0
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   1f404:	2801      	cmp	r0, #1
   1f406:	d107      	bne.n	1f418 <lfclk_spinwait+0x18>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   1f408:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f40c:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   1f410:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   1f414:	2b01      	cmp	r3, #1
   1f416:	d05a      	beq.n	1f4ce <lfclk_spinwait+0xce>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1f418:	f011 fa78 	bl	3090c <k_is_in_isr>
   1f41c:	b928      	cbnz	r0, 1f42a <lfclk_spinwait+0x2a>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   1f41e:	4b2f      	ldr	r3, [pc, #188]	; (1f4dc <lfclk_spinwait+0xdc>)
   1f420:	781b      	ldrb	r3, [r3, #0]
   1f422:	2b00      	cmp	r3, #0
   1f424:	d043      	beq.n	1f4ae <lfclk_spinwait+0xae>
   1f426:	2300      	movs	r3, #0
   1f428:	e000      	b.n	1f42c <lfclk_spinwait+0x2c>
   1f42a:	2301      	movs	r3, #1
	int key = isr_mode ? irq_lock() : 0;
   1f42c:	461c      	mov	r4, r3
   1f42e:	2b00      	cmp	r3, #0
   1f430:	d03f      	beq.n	1f4b2 <lfclk_spinwait+0xb2>
	__asm__ volatile(
   1f432:	f04f 0340 	mov.w	r3, #64	; 0x40
   1f436:	f3ef 8611 	mrs	r6, BASEPRI
   1f43a:	f383 8812 	msr	BASEPRI_MAX, r3
   1f43e:	f3bf 8f6f 	isb	sy
	if (!isr_mode) {
   1f442:	b924      	cbnz	r4, 1f44e <lfclk_spinwait+0x4e>
    p_reg->INTENCLR = mask;
   1f444:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f448:	2202      	movs	r2, #2
   1f44a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1f44e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   1f452:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   1f456:	f003 0303 	and.w	r3, r3, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1f45a:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
   1f45e:	f412 3f80 	tst.w	r2, #65536	; 0x10000
   1f462:	d12d      	bne.n	1f4c0 <lfclk_spinwait+0xc0>
    return false;
   1f464:	2200      	movs	r2, #0
	while (!(nrfx_clock_is_running(d, (void *)&type)
   1f466:	b11a      	cbz	r2, 1f470 <lfclk_spinwait+0x70>
   1f468:	2b01      	cmp	r3, #1
   1f46a:	d02b      	beq.n	1f4c4 <lfclk_spinwait+0xc4>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   1f46c:	2d01      	cmp	r5, #1
   1f46e:	d029      	beq.n	1f4c4 <lfclk_spinwait+0xc4>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   1f470:	b30c      	cbz	r4, 1f4b6 <lfclk_spinwait+0xb6>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   1f472:	4630      	mov	r0, r6
   1f474:	f7f8 fe9e 	bl	181b4 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   1f478:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f47c:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   1f480:	2b00      	cmp	r3, #0
   1f482:	d1e4      	bne.n	1f44e <lfclk_spinwait+0x4e>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1f484:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f488:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
   1f48c:	2b00      	cmp	r3, #0
   1f48e:	d0de      	beq.n	1f44e <lfclk_spinwait+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1f490:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f494:	2200      	movs	r2, #0
   1f496:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   1f49a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
   1f49e:	2201      	movs	r2, #1
   1f4a0:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1f4a4:	490e      	ldr	r1, [pc, #56]	; (1f4e0 <lfclk_spinwait+0xe0>)
   1f4a6:	f8c1 2180 	str.w	r2, [r1, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1f4aa:	609a      	str	r2, [r3, #8]
}
   1f4ac:	e7cf      	b.n	1f44e <lfclk_spinwait+0x4e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1f4ae:	2301      	movs	r3, #1
   1f4b0:	e7bc      	b.n	1f42c <lfclk_spinwait+0x2c>
	int key = isr_mode ? irq_lock() : 0;
   1f4b2:	2600      	movs	r6, #0
   1f4b4:	e7c5      	b.n	1f442 <lfclk_spinwait+0x42>
	return z_impl_k_sleep(timeout);
   1f4b6:	2021      	movs	r0, #33	; 0x21
   1f4b8:	2100      	movs	r1, #0
   1f4ba:	f009 fc4f 	bl	28d5c <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   1f4be:	e7db      	b.n	1f478 <lfclk_spinwait+0x78>
                return true;
   1f4c0:	2201      	movs	r2, #1
   1f4c2:	e7d0      	b.n	1f466 <lfclk_spinwait+0x66>
	if (isr_mode) {
   1f4c4:	b124      	cbz	r4, 1f4d0 <lfclk_spinwait+0xd0>
	__asm__ volatile(
   1f4c6:	f386 8811 	msr	BASEPRI, r6
   1f4ca:	f3bf 8f6f 	isb	sy
}
   1f4ce:	bd70      	pop	{r4, r5, r6, pc}
    p_reg->INTENSET = mask;
   1f4d0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f4d4:	2202      	movs	r2, #2
   1f4d6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1f4da:	e7f8      	b.n	1f4ce <lfclk_spinwait+0xce>
   1f4dc:	20004713 	.word	0x20004713
   1f4e0:	e000e100 	.word	0xe000e100

0001f4e4 <generic_hfclk_start>:
{
   1f4e4:	b510      	push	{r4, lr}
	__asm__ volatile(
   1f4e6:	f04f 0340 	mov.w	r3, #64	; 0x40
   1f4ea:	f3ef 8411 	mrs	r4, BASEPRI
   1f4ee:	f383 8812 	msr	BASEPRI_MAX, r3
   1f4f2:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   1f4f6:	4a13      	ldr	r2, [pc, #76]	; (1f544 <generic_hfclk_start+0x60>)
   1f4f8:	6813      	ldr	r3, [r2, #0]
   1f4fa:	f043 0302 	orr.w	r3, r3, #2
   1f4fe:	6013      	str	r3, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   1f500:	f013 0f01 	tst.w	r3, #1
   1f504:	d108      	bne.n	1f518 <generic_hfclk_start+0x34>
	bool already_started = false;
   1f506:	2300      	movs	r3, #0
	__asm__ volatile(
   1f508:	f384 8811 	msr	BASEPRI, r4
   1f50c:	f3bf 8f6f 	isb	sy
	if (already_started) {
   1f510:	b99b      	cbnz	r3, 1f53a <generic_hfclk_start+0x56>
	hfclk_start();
   1f512:	f00f fda1 	bl	2f058 <hfclk_start>
}
   1f516:	bd10      	pop	{r4, pc}
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   1f518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f51c:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   1f520:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   1f524:	f012 0f01 	tst.w	r2, #1
   1f528:	d101      	bne.n	1f52e <generic_hfclk_start+0x4a>
	bool already_started = false;
   1f52a:	2300      	movs	r3, #0
   1f52c:	e7ec      	b.n	1f508 <generic_hfclk_start+0x24>
			set_on_state(get_hf_flags());
   1f52e:	f7ff fe39 	bl	1f1a4 <get_hf_flags>
   1f532:	f00f fd40 	bl	2efb6 <set_on_state>
			already_started = true;
   1f536:	2301      	movs	r3, #1
   1f538:	e7e6      	b.n	1f508 <generic_hfclk_start+0x24>
		clkstarted_handle(CLOCK_DEVICE,
   1f53a:	2100      	movs	r1, #0
   1f53c:	4802      	ldr	r0, [pc, #8]	; (1f548 <generic_hfclk_start+0x64>)
   1f53e:	f00f fd4d 	bl	2efdc <clkstarted_handle>
		return;
   1f542:	e7e8      	b.n	1f516 <generic_hfclk_start+0x32>
   1f544:	20003d3c 	.word	0x20003d3c
   1f548:	00030fd4 	.word	0x00030fd4

0001f54c <z_nrf_clock_control_lf_on>:
{
   1f54c:	b538      	push	{r3, r4, r5, lr}
   1f54e:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1f550:	4b1e      	ldr	r3, [pc, #120]	; (1f5cc <z_nrf_clock_control_lf_on+0x80>)
   1f552:	2101      	movs	r1, #1
   1f554:	f3bf 8f5b 	dmb	ish
   1f558:	e853 2f00 	ldrex	r2, [r3]
   1f55c:	e843 1000 	strex	r0, r1, [r3]
   1f560:	2800      	cmp	r0, #0
   1f562:	d1f9      	bne.n	1f558 <z_nrf_clock_control_lf_on+0xc>
   1f564:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
   1f568:	b142      	cbz	r2, 1f57c <z_nrf_clock_control_lf_on+0x30>
	switch (start_mode) {
   1f56a:	b134      	cbz	r4, 1f57a <z_nrf_clock_control_lf_on+0x2e>
   1f56c:	1e63      	subs	r3, r4, #1
   1f56e:	b2db      	uxtb	r3, r3
   1f570:	2b01      	cmp	r3, #1
   1f572:	d81e      	bhi.n	1f5b2 <z_nrf_clock_control_lf_on+0x66>
		lfclk_spinwait(start_mode);
   1f574:	4620      	mov	r0, r4
   1f576:	f7ff ff43 	bl	1f400 <lfclk_spinwait>
}
   1f57a:	bd38      	pop	{r3, r4, r5, pc}
				get_onoff_manager(CLOCK_DEVICE,
   1f57c:	4814      	ldr	r0, [pc, #80]	; (1f5d0 <z_nrf_clock_control_lf_on+0x84>)
   1f57e:	f00f fcdf 	bl	2ef40 <get_onoff_manager>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   1f582:	4914      	ldr	r1, [pc, #80]	; (1f5d4 <z_nrf_clock_control_lf_on+0x88>)
   1f584:	2300      	movs	r3, #0
   1f586:	604b      	str	r3, [r1, #4]
   1f588:	608b      	str	r3, [r1, #8]
   1f58a:	60cb      	str	r3, [r1, #12]
   1f58c:	2301      	movs	r3, #1
   1f58e:	608b      	str	r3, [r1, #8]
		err = onoff_request(mgr, &cli);
   1f590:	f7f6 fd06 	bl	15fa0 <onoff_request>
		__ASSERT_NO_MSG(err >= 0);
   1f594:	2800      	cmp	r0, #0
   1f596:	dae8      	bge.n	1f56a <z_nrf_clock_control_lf_on+0x1e>
   1f598:	4d0f      	ldr	r5, [pc, #60]	; (1f5d8 <z_nrf_clock_control_lf_on+0x8c>)
   1f59a:	f44f 7208 	mov.w	r2, #544	; 0x220
   1f59e:	4629      	mov	r1, r5
   1f5a0:	480e      	ldr	r0, [pc, #56]	; (1f5dc <z_nrf_clock_control_lf_on+0x90>)
   1f5a2:	f00c ffc4 	bl	2c52e <assert_print>
   1f5a6:	f44f 7108 	mov.w	r1, #544	; 0x220
   1f5aa:	4628      	mov	r0, r5
   1f5ac:	f00c ffb8 	bl	2c520 <assert_post_action>
   1f5b0:	e7db      	b.n	1f56a <z_nrf_clock_control_lf_on+0x1e>
		__ASSERT_NO_MSG(false);
   1f5b2:	4c09      	ldr	r4, [pc, #36]	; (1f5d8 <z_nrf_clock_control_lf_on+0x8c>)
   1f5b4:	f240 2232 	movw	r2, #562	; 0x232
   1f5b8:	4621      	mov	r1, r4
   1f5ba:	4808      	ldr	r0, [pc, #32]	; (1f5dc <z_nrf_clock_control_lf_on+0x90>)
   1f5bc:	f00c ffb7 	bl	2c52e <assert_print>
   1f5c0:	f240 2132 	movw	r1, #562	; 0x232
   1f5c4:	4620      	mov	r0, r4
   1f5c6:	f00c ffab 	bl	2c520 <assert_post_action>
   1f5ca:	e7d6      	b.n	1f57a <z_nrf_clock_control_lf_on+0x2e>
   1f5cc:	20003d40 	.word	0x20003d40
   1f5d0:	00030fd4 	.word	0x00030fd4
   1f5d4:	20003cd4 	.word	0x20003cd4
   1f5d8:	0003adb0 	.word	0x0003adb0
   1f5dc:	00031600 	.word	0x00031600

0001f5e0 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
   1f5e0:	b510      	push	{r4, lr}
   1f5e2:	4604      	mov	r4, r0
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
   1f5e4:	280a      	cmp	r0, #10
   1f5e6:	d007      	beq.n	1f5f8 <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
   1f5e8:	4b07      	ldr	r3, [pc, #28]	; (1f608 <console_out+0x28>)
   1f5ea:	6818      	ldr	r0, [r3, #0]
   1f5ec:	b2e1      	uxtb	r1, r4
			     unsigned char out_char);

static inline void z_impl_uart_poll_out(const struct device *dev,
					unsigned char out_char)
{
	const struct uart_driver_api *api =
   1f5ee:	6883      	ldr	r3, [r0, #8]
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   1f5f0:	685b      	ldr	r3, [r3, #4]
   1f5f2:	4798      	blx	r3

	return c;
}
   1f5f4:	4620      	mov	r0, r4
   1f5f6:	bd10      	pop	{r4, pc}
		uart_poll_out(uart_console_dev, '\r');
   1f5f8:	4b03      	ldr	r3, [pc, #12]	; (1f608 <console_out+0x28>)
   1f5fa:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
   1f5fc:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
   1f5fe:	685b      	ldr	r3, [r3, #4]
   1f600:	210d      	movs	r1, #13
   1f602:	4798      	blx	r3
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
}
   1f604:	e7f0      	b.n	1f5e8 <console_out+0x8>
   1f606:	bf00      	nop
   1f608:	20003d44 	.word	0x20003d44

0001f60c <uart_console_hook_install>:
/**
 * @brief Install printk/stdout hook for UART console output
 */

static void uart_console_hook_install(void)
{
   1f60c:	b510      	push	{r4, lr}
#if defined(CONFIG_STDOUT_CONSOLE)
	__stdout_hook_install(console_out);
   1f60e:	4c04      	ldr	r4, [pc, #16]	; (1f620 <uart_console_hook_install+0x14>)
   1f610:	4620      	mov	r0, r4
   1f612:	f7f9 fcbd 	bl	18f90 <__stdout_hook_install>
#endif
#if defined(CONFIG_PRINTK)
	__printk_hook_install(console_out);
   1f616:	4620      	mov	r0, r4
   1f618:	f7f6 fa44 	bl	15aa4 <__printk_hook_install>
#endif
}
   1f61c:	bd10      	pop	{r4, pc}
   1f61e:	bf00      	nop
   1f620:	0001f5e1 	.word	0x0001f5e1

0001f624 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   1f624:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   1f626:	4806      	ldr	r0, [pc, #24]	; (1f640 <uart_console_init+0x1c>)
   1f628:	4b06      	ldr	r3, [pc, #24]	; (1f644 <uart_console_init+0x20>)
   1f62a:	6018      	str	r0, [r3, #0]
   1f62c:	f011 f92a 	bl	30884 <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
   1f630:	b118      	cbz	r0, 1f63a <uart_console_init+0x16>
		return -ENODEV;
	}

	uart_console_hook_install();
   1f632:	f7ff ffeb 	bl	1f60c <uart_console_hook_install>

	return 0;
   1f636:	2000      	movs	r0, #0
}
   1f638:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1f63a:	f06f 0012 	mvn.w	r0, #18
   1f63e:	e7fb      	b.n	1f638 <uart_console_init+0x14>
   1f640:	00031044 	.word	0x00031044
   1f644:	20003d44 	.word	0x20003d44

0001f648 <z_impl_gpio_pin_configure>:
{
   1f648:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f64c:	4605      	mov	r5, r0
   1f64e:	460e      	mov	r6, r1
   1f650:	4614      	mov	r4, r2
	const struct gpio_driver_api *api =
   1f652:	f8d0 a008 	ldr.w	sl, [r0, #8]
	__unused const struct gpio_driver_config *const cfg =
   1f656:	f8d0 b004 	ldr.w	fp, [r0, #4]
	struct gpio_driver_data *data =
   1f65a:	f8d0 8010 	ldr.w	r8, [r0, #16]
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   1f65e:	f012 6ffc 	tst.w	r2, #132120576	; 0x7e00000
   1f662:	d135      	bne.n	1f6d0 <z_impl_gpio_pin_configure+0x88>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   1f664:	f004 0330 	and.w	r3, r4, #48	; 0x30
   1f668:	2b30      	cmp	r3, #48	; 0x30
   1f66a:	d03e      	beq.n	1f6ea <z_impl_gpio_pin_configure+0xa2>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   1f66c:	f004 1302 	and.w	r3, r4, #131074	; 0x20002
   1f670:	2b02      	cmp	r3, #2
   1f672:	d047      	beq.n	1f704 <z_impl_gpio_pin_configure+0xbc>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   1f674:	f004 0306 	and.w	r3, r4, #6
   1f678:	2b04      	cmp	r3, #4
   1f67a:	d050      	beq.n	1f71e <z_impl_gpio_pin_configure+0xd6>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   1f67c:	f414 2740 	ands.w	r7, r4, #786432	; 0xc0000
   1f680:	d002      	beq.n	1f688 <z_impl_gpio_pin_configure+0x40>
   1f682:	f414 3f00 	tst.w	r4, #131072	; 0x20000
   1f686:	d057      	beq.n	1f738 <z_impl_gpio_pin_configure+0xf0>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   1f688:	f5b7 2f40 	cmp.w	r7, #786432	; 0xc0000
   1f68c:	d062      	beq.n	1f754 <z_impl_gpio_pin_configure+0x10c>
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   1f68e:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
   1f692:	d005      	beq.n	1f6a0 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   1f694:	b127      	cbz	r7, 1f6a0 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   1f696:	f014 0f01 	tst.w	r4, #1
   1f69a:	d001      	beq.n	1f6a0 <z_impl_gpio_pin_configure+0x58>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   1f69c:	f484 2440 	eor.w	r4, r4, #786432	; 0xc0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   1f6a0:	f424 1980 	bic.w	r9, r4, #1048576	; 0x100000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f6a4:	f8db 3000 	ldr.w	r3, [fp]
   1f6a8:	2701      	movs	r7, #1
   1f6aa:	40b7      	lsls	r7, r6
   1f6ac:	423b      	tst	r3, r7
   1f6ae:	d05f      	beq.n	1f770 <z_impl_gpio_pin_configure+0x128>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   1f6b0:	f014 0f01 	tst.w	r4, #1
   1f6b4:	d06a      	beq.n	1f78c <z_impl_gpio_pin_configure+0x144>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   1f6b6:	f8d8 3000 	ldr.w	r3, [r8]
   1f6ba:	433b      	orrs	r3, r7
   1f6bc:	f8c8 3000 	str.w	r3, [r8]
	return api->pin_configure(port, pin, flags);
   1f6c0:	f8da 3000 	ldr.w	r3, [sl]
   1f6c4:	464a      	mov	r2, r9
   1f6c6:	4631      	mov	r1, r6
   1f6c8:	4628      	mov	r0, r5
   1f6ca:	4798      	blx	r3
}
   1f6cc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   1f6d0:	4f32      	ldr	r7, [pc, #200]	; (1f79c <z_impl_gpio_pin_configure+0x154>)
   1f6d2:	f44f 722f 	mov.w	r2, #700	; 0x2bc
   1f6d6:	4639      	mov	r1, r7
   1f6d8:	4831      	ldr	r0, [pc, #196]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f6da:	f00c ff28 	bl	2c52e <assert_print>
   1f6de:	f44f 712f 	mov.w	r1, #700	; 0x2bc
   1f6e2:	4638      	mov	r0, r7
   1f6e4:	f00c ff1c 	bl	2c520 <assert_post_action>
   1f6e8:	e7bc      	b.n	1f664 <z_impl_gpio_pin_configure+0x1c>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   1f6ea:	4f2c      	ldr	r7, [pc, #176]	; (1f79c <z_impl_gpio_pin_configure+0x154>)
   1f6ec:	f240 22bf 	movw	r2, #703	; 0x2bf
   1f6f0:	4639      	mov	r1, r7
   1f6f2:	482b      	ldr	r0, [pc, #172]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f6f4:	f00c ff1b 	bl	2c52e <assert_print>
   1f6f8:	f240 21bf 	movw	r1, #703	; 0x2bf
   1f6fc:	4638      	mov	r0, r7
   1f6fe:	f00c ff0f 	bl	2c520 <assert_post_action>
   1f702:	e7b3      	b.n	1f66c <z_impl_gpio_pin_configure+0x24>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   1f704:	4f25      	ldr	r7, [pc, #148]	; (1f79c <z_impl_gpio_pin_configure+0x154>)
   1f706:	f240 22c3 	movw	r2, #707	; 0x2c3
   1f70a:	4639      	mov	r1, r7
   1f70c:	4824      	ldr	r0, [pc, #144]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f70e:	f00c ff0e 	bl	2c52e <assert_print>
   1f712:	f240 21c3 	movw	r1, #707	; 0x2c3
   1f716:	4638      	mov	r0, r7
   1f718:	f00c ff02 	bl	2c520 <assert_post_action>
   1f71c:	e7aa      	b.n	1f674 <z_impl_gpio_pin_configure+0x2c>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   1f71e:	4f1f      	ldr	r7, [pc, #124]	; (1f79c <z_impl_gpio_pin_configure+0x154>)
   1f720:	f240 22c7 	movw	r2, #711	; 0x2c7
   1f724:	4639      	mov	r1, r7
   1f726:	481e      	ldr	r0, [pc, #120]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f728:	f00c ff01 	bl	2c52e <assert_print>
   1f72c:	f240 21c7 	movw	r1, #711	; 0x2c7
   1f730:	4638      	mov	r0, r7
   1f732:	f00c fef5 	bl	2c520 <assert_post_action>
   1f736:	e7a1      	b.n	1f67c <z_impl_gpio_pin_configure+0x34>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   1f738:	f8df 9060 	ldr.w	r9, [pc, #96]	; 1f79c <z_impl_gpio_pin_configure+0x154>
   1f73c:	f240 22ca 	movw	r2, #714	; 0x2ca
   1f740:	4649      	mov	r1, r9
   1f742:	4817      	ldr	r0, [pc, #92]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f744:	f00c fef3 	bl	2c52e <assert_print>
   1f748:	f240 21ca 	movw	r1, #714	; 0x2ca
   1f74c:	4648      	mov	r0, r9
   1f74e:	f00c fee7 	bl	2c520 <assert_post_action>
   1f752:	e799      	b.n	1f688 <z_impl_gpio_pin_configure+0x40>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   1f754:	f8df 9044 	ldr.w	r9, [pc, #68]	; 1f79c <z_impl_gpio_pin_configure+0x154>
   1f758:	f240 22ce 	movw	r2, #718	; 0x2ce
   1f75c:	4649      	mov	r1, r9
   1f75e:	4810      	ldr	r0, [pc, #64]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f760:	f00c fee5 	bl	2c52e <assert_print>
   1f764:	f240 21ce 	movw	r1, #718	; 0x2ce
   1f768:	4648      	mov	r0, r9
   1f76a:	f00c fed9 	bl	2c520 <assert_post_action>
   1f76e:	e78e      	b.n	1f68e <z_impl_gpio_pin_configure+0x46>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f770:	f8df b028 	ldr.w	fp, [pc, #40]	; 1f79c <z_impl_gpio_pin_configure+0x154>
   1f774:	f240 22da 	movw	r2, #730	; 0x2da
   1f778:	4659      	mov	r1, fp
   1f77a:	4809      	ldr	r0, [pc, #36]	; (1f7a0 <z_impl_gpio_pin_configure+0x158>)
   1f77c:	f00c fed7 	bl	2c52e <assert_print>
   1f780:	f240 21da 	movw	r1, #730	; 0x2da
   1f784:	4658      	mov	r0, fp
   1f786:	f00c fecb 	bl	2c520 <assert_post_action>
   1f78a:	e791      	b.n	1f6b0 <z_impl_gpio_pin_configure+0x68>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   1f78c:	f8d8 3000 	ldr.w	r3, [r8]
   1f790:	ea23 0307 	bic.w	r3, r3, r7
   1f794:	f8c8 3000 	str.w	r3, [r8]
   1f798:	e792      	b.n	1f6c0 <z_impl_gpio_pin_configure+0x78>
   1f79a:	bf00      	nop
   1f79c:	000315cc 	.word	0x000315cc
   1f7a0:	00031600 	.word	0x00031600

0001f7a4 <st7789v_set_orientation>:
}

static int st7789v_set_orientation(const struct device *dev,
			    const enum display_orientation orientation)
{
	if (orientation == DISPLAY_ORIENTATION_NORMAL) {
   1f7a4:	b909      	cbnz	r1, 1f7aa <st7789v_set_orientation+0x6>
		return 0;
   1f7a6:	2000      	movs	r0, #0
	}
	LOG_ERR("Changing display orientation not implemented");
	return -ENOTSUP;
}
   1f7a8:	4770      	bx	lr
{
   1f7aa:	b508      	push	{r3, lr}
	LOG_ERR("Changing display orientation not implemented");
   1f7ac:	2145      	movs	r1, #69	; 0x45
   1f7ae:	4803      	ldr	r0, [pc, #12]	; (1f7bc <st7789v_set_orientation+0x18>)
   1f7b0:	f00c fecc 	bl	2c54c <z_log_minimal_printk>
	return -ENOTSUP;
   1f7b4:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   1f7b8:	bd08      	pop	{r3, pc}
   1f7ba:	bf00      	nop
   1f7bc:	0003ae60 	.word	0x0003ae60

0001f7c0 <st7789v_set_pixel_format>:
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
   1f7c0:	2910      	cmp	r1, #16
   1f7c2:	d101      	bne.n	1f7c8 <st7789v_set_pixel_format+0x8>
		return 0;
   1f7c4:	2000      	movs	r0, #0
}
   1f7c6:	4770      	bx	lr
{
   1f7c8:	b508      	push	{r3, lr}
	LOG_ERR("Pixel format change not implemented");
   1f7ca:	2145      	movs	r1, #69	; 0x45
   1f7cc:	4802      	ldr	r0, [pc, #8]	; (1f7d8 <st7789v_set_pixel_format+0x18>)
   1f7ce:	f00c febd 	bl	2c54c <z_log_minimal_printk>
	return -ENOTSUP;
   1f7d2:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   1f7d6:	bd08      	pop	{r3, pc}
   1f7d8:	0003ae94 	.word	0x0003ae94

0001f7dc <st7789v_transmit>:
{
   1f7dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f7e0:	b089      	sub	sp, #36	; 0x24
   1f7e2:	4616      	mov	r6, r2
   1f7e4:	461f      	mov	r7, r3
   1f7e6:	f88d 1007 	strb.w	r1, [sp, #7]
	const struct st7789v_config *config = dev->config;
   1f7ea:	6845      	ldr	r5, [r0, #4]
	uint16_t data = cmd;
   1f7ec:	b2cb      	uxtb	r3, r1
   1f7ee:	f8ad 301e 	strh.w	r3, [sp, #30]
	struct spi_buf tx_buf = { .buf = &cmd, .len = 1 };
   1f7f2:	f10d 0207 	add.w	r2, sp, #7
   1f7f6:	9205      	str	r2, [sp, #20]
   1f7f8:	2201      	movs	r2, #1
   1f7fa:	9206      	str	r2, [sp, #24]
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1 };
   1f7fc:	a905      	add	r1, sp, #20
   1f7fe:	9103      	str	r1, [sp, #12]
   1f800:	9204      	str	r2, [sp, #16]
	if (config->cmd_data_gpio.port != NULL) {
   1f802:	692c      	ldr	r4, [r5, #16]
   1f804:	2c00      	cmp	r4, #0
   1f806:	f000 80a2 	beq.w	1f94e <st7789v_transmit+0x172>
		if (cmd != ST7789V_CMD_NONE) {
   1f80a:	2bff      	cmp	r3, #255	; 0xff
   1f80c:	d12a      	bne.n	1f864 <st7789v_transmit+0x88>
		if (tx_data != NULL) {
   1f80e:	b336      	cbz	r6, 1f85e <st7789v_transmit+0x82>
			tx_buf.buf = tx_data;
   1f810:	9605      	str	r6, [sp, #20]
			tx_buf.len = tx_count;
   1f812:	9706      	str	r7, [sp, #24]
	return gpio_pin_set(spec->port, spec->pin, value);
   1f814:	692c      	ldr	r4, [r5, #16]
   1f816:	f895 8014 	ldrb.w	r8, [r5, #20]
	__unused const struct gpio_driver_config *const cfg =
   1f81a:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   1f81c:	6926      	ldr	r6, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f81e:	681b      	ldr	r3, [r3, #0]
   1f820:	2701      	movs	r7, #1
   1f822:	fa07 f708 	lsl.w	r7, r7, r8
   1f826:	423b      	tst	r3, r7
   1f828:	d06d      	beq.n	1f906 <st7789v_transmit+0x12a>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1f82a:	6833      	ldr	r3, [r6, #0]
   1f82c:	421f      	tst	r7, r3
   1f82e:	d178      	bne.n	1f922 <st7789v_transmit+0x146>
   1f830:	2700      	movs	r7, #0
	__unused const struct gpio_driver_config *const cfg =
   1f832:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f834:	681b      	ldr	r3, [r3, #0]
   1f836:	2601      	movs	r6, #1
   1f838:	fa06 f608 	lsl.w	r6, r6, r8
   1f83c:	4233      	tst	r3, r6
   1f83e:	d072      	beq.n	1f926 <st7789v_transmit+0x14a>
	if (value != 0)	{
   1f840:	2f00      	cmp	r7, #0
   1f842:	d07e      	beq.n	1f942 <st7789v_transmit+0x166>
	const struct gpio_driver_api *api =
   1f844:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   1f846:	68db      	ldr	r3, [r3, #12]
   1f848:	4631      	mov	r1, r6
   1f84a:	4620      	mov	r0, r4
   1f84c:	4798      	blx	r3
 * @return a value from spi_write().
 */
static inline int spi_write_dt(const struct spi_dt_spec *spec,
			       const struct spi_buf_set *tx_bufs)
{
	return spi_write(spec->bus, &spec->config, tx_bufs);
   1f84e:	4629      	mov	r1, r5
   1f850:	f851 0b04 	ldr.w	r0, [r1], #4
	const struct spi_driver_api *api =
   1f854:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1f856:	681c      	ldr	r4, [r3, #0]
   1f858:	2300      	movs	r3, #0
   1f85a:	aa03      	add	r2, sp, #12
   1f85c:	47a0      	blx	r4
}
   1f85e:	b009      	add	sp, #36	; 0x24
   1f860:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return gpio_pin_set(spec->port, spec->pin, value);
   1f864:	f895 9014 	ldrb.w	r9, [r5, #20]
	__unused const struct gpio_driver_config *const cfg =
   1f868:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   1f86a:	f8d4 a010 	ldr.w	sl, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f86e:	681b      	ldr	r3, [r3, #0]
   1f870:	fa02 f809 	lsl.w	r8, r2, r9
   1f874:	ea13 0f08 	tst.w	r3, r8
   1f878:	d020      	beq.n	1f8bc <st7789v_transmit+0xe0>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1f87a:	f8da 3000 	ldr.w	r3, [sl]
   1f87e:	ea18 0f03 	tst.w	r8, r3
   1f882:	d129      	bne.n	1f8d8 <st7789v_transmit+0xfc>
   1f884:	f04f 0a01 	mov.w	sl, #1
	__unused const struct gpio_driver_config *const cfg =
   1f888:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f88a:	681b      	ldr	r3, [r3, #0]
   1f88c:	f04f 0801 	mov.w	r8, #1
   1f890:	fa08 f809 	lsl.w	r8, r8, r9
   1f894:	ea13 0f08 	tst.w	r3, r8
   1f898:	d021      	beq.n	1f8de <st7789v_transmit+0x102>
	if (value != 0)	{
   1f89a:	f1ba 0f00 	cmp.w	sl, #0
   1f89e:	d02c      	beq.n	1f8fa <st7789v_transmit+0x11e>
	const struct gpio_driver_api *api =
   1f8a0:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   1f8a2:	68db      	ldr	r3, [r3, #12]
   1f8a4:	4641      	mov	r1, r8
   1f8a6:	4620      	mov	r0, r4
   1f8a8:	4798      	blx	r3
	return spi_write(spec->bus, &spec->config, tx_bufs);
   1f8aa:	4629      	mov	r1, r5
   1f8ac:	f851 0b04 	ldr.w	r0, [r1], #4
	const struct spi_driver_api *api =
   1f8b0:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1f8b2:	681c      	ldr	r4, [r3, #0]
   1f8b4:	2300      	movs	r3, #0
   1f8b6:	aa03      	add	r2, sp, #12
   1f8b8:	47a0      	blx	r4
	return spi_write(spec->bus, &spec->config, tx_bufs);
   1f8ba:	e7a8      	b.n	1f80e <st7789v_transmit+0x32>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f8bc:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 1f9a0 <st7789v_transmit+0x1c4>
   1f8c0:	f240 5225 	movw	r2, #1317	; 0x525
   1f8c4:	4659      	mov	r1, fp
   1f8c6:	4835      	ldr	r0, [pc, #212]	; (1f99c <st7789v_transmit+0x1c0>)
   1f8c8:	f00c fe31 	bl	2c52e <assert_print>
   1f8cc:	f240 5125 	movw	r1, #1317	; 0x525
   1f8d0:	4658      	mov	r0, fp
   1f8d2:	f00c fe25 	bl	2c520 <assert_post_action>
   1f8d6:	e7d0      	b.n	1f87a <st7789v_transmit+0x9e>
		value = (value != 0) ? 0 : 1;
   1f8d8:	f04f 0a00 	mov.w	sl, #0
   1f8dc:	e7d4      	b.n	1f888 <st7789v_transmit+0xac>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f8de:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 1f9a0 <st7789v_transmit+0x1c4>
   1f8e2:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1f8e6:	4649      	mov	r1, r9
   1f8e8:	482c      	ldr	r0, [pc, #176]	; (1f99c <st7789v_transmit+0x1c0>)
   1f8ea:	f00c fe20 	bl	2c52e <assert_print>
   1f8ee:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1f8f2:	4648      	mov	r0, r9
   1f8f4:	f00c fe14 	bl	2c520 <assert_post_action>
   1f8f8:	e7cf      	b.n	1f89a <st7789v_transmit+0xbe>
	const struct gpio_driver_api *api =
   1f8fa:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   1f8fc:	691b      	ldr	r3, [r3, #16]
   1f8fe:	4641      	mov	r1, r8
   1f900:	4620      	mov	r0, r4
   1f902:	4798      	blx	r3
   1f904:	e7d1      	b.n	1f8aa <st7789v_transmit+0xce>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f906:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1f9a0 <st7789v_transmit+0x1c4>
   1f90a:	f240 5225 	movw	r2, #1317	; 0x525
   1f90e:	4649      	mov	r1, r9
   1f910:	4822      	ldr	r0, [pc, #136]	; (1f99c <st7789v_transmit+0x1c0>)
   1f912:	f00c fe0c 	bl	2c52e <assert_print>
   1f916:	f240 5125 	movw	r1, #1317	; 0x525
   1f91a:	4648      	mov	r0, r9
   1f91c:	f00c fe00 	bl	2c520 <assert_post_action>
   1f920:	e783      	b.n	1f82a <st7789v_transmit+0x4e>
		value = (value != 0) ? 0 : 1;
   1f922:	2701      	movs	r7, #1
   1f924:	e785      	b.n	1f832 <st7789v_transmit+0x56>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f926:	f8df 8078 	ldr.w	r8, [pc, #120]	; 1f9a0 <st7789v_transmit+0x1c4>
   1f92a:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1f92e:	4641      	mov	r1, r8
   1f930:	481a      	ldr	r0, [pc, #104]	; (1f99c <st7789v_transmit+0x1c0>)
   1f932:	f00c fdfc 	bl	2c52e <assert_print>
   1f936:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1f93a:	4640      	mov	r0, r8
   1f93c:	f00c fdf0 	bl	2c520 <assert_post_action>
   1f940:	e77e      	b.n	1f840 <st7789v_transmit+0x64>
	const struct gpio_driver_api *api =
   1f942:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   1f944:	691b      	ldr	r3, [r3, #16]
   1f946:	4631      	mov	r1, r6
   1f948:	4620      	mov	r0, r4
   1f94a:	4798      	blx	r3
   1f94c:	e77f      	b.n	1f84e <st7789v_transmit+0x72>
		tx_buf.buf = &data;
   1f94e:	f10d 021e 	add.w	r2, sp, #30
   1f952:	9205      	str	r2, [sp, #20]
		tx_buf.len = 2;
   1f954:	2202      	movs	r2, #2
   1f956:	9206      	str	r2, [sp, #24]
		if (cmd != ST7789V_CMD_NONE) {
   1f958:	2bff      	cmp	r3, #255	; 0xff
   1f95a:	d104      	bne.n	1f966 <st7789v_transmit+0x18a>
		if (tx_data != NULL) {
   1f95c:	2e00      	cmp	r6, #0
   1f95e:	f43f af7e 	beq.w	1f85e <st7789v_transmit+0x82>
			for (size_t index = 0; index < tx_count; ++index) {
   1f962:	2400      	movs	r4, #0
   1f964:	e017      	b.n	1f996 <st7789v_transmit+0x1ba>
   1f966:	4629      	mov	r1, r5
   1f968:	f851 0b04 	ldr.w	r0, [r1], #4
	const struct spi_driver_api *api =
   1f96c:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1f96e:	681c      	ldr	r4, [r3, #0]
   1f970:	2300      	movs	r3, #0
   1f972:	aa03      	add	r2, sp, #12
   1f974:	47a0      	blx	r4
	return spi_write(spec->bus, &spec->config, tx_bufs);
   1f976:	e7f1      	b.n	1f95c <st7789v_transmit+0x180>
				data = 0x0100 | tx_data[index];
   1f978:	5d31      	ldrb	r1, [r6, r4]
   1f97a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   1f97e:	f8ad 101e 	strh.w	r1, [sp, #30]
   1f982:	4629      	mov	r1, r5
   1f984:	f851 0b04 	ldr.w	r0, [r1], #4
	const struct spi_driver_api *api =
   1f988:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1f98a:	f8d3 8000 	ldr.w	r8, [r3]
   1f98e:	2300      	movs	r3, #0
   1f990:	aa03      	add	r2, sp, #12
   1f992:	47c0      	blx	r8
			for (size_t index = 0; index < tx_count; ++index) {
   1f994:	3401      	adds	r4, #1
   1f996:	42bc      	cmp	r4, r7
   1f998:	d3ee      	bcc.n	1f978 <st7789v_transmit+0x19c>
   1f99a:	e760      	b.n	1f85e <st7789v_transmit+0x82>
   1f99c:	00031600 	.word	0x00031600
   1f9a0:	000315cc 	.word	0x000315cc

0001f9a4 <st7789v_reset_display>:
{
   1f9a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct st7789v_config *config = dev->config;
   1f9a8:	6844      	ldr	r4, [r0, #4]
	if (config->reset_gpio.port != NULL) {
   1f9aa:	69a3      	ldr	r3, [r4, #24]
   1f9ac:	2b00      	cmp	r3, #0
   1f9ae:	f000 808d 	beq.w	1facc <st7789v_reset_display+0x128>
   1f9b2:	2021      	movs	r0, #33	; 0x21
   1f9b4:	2100      	movs	r1, #0
   1f9b6:	f009 f9d1 	bl	28d5c <z_impl_k_sleep>
	return gpio_pin_set(spec->port, spec->pin, value);
   1f9ba:	69a5      	ldr	r5, [r4, #24]
   1f9bc:	f894 801c 	ldrb.w	r8, [r4, #28]
	__unused const struct gpio_driver_config *const cfg =
   1f9c0:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   1f9c2:	692f      	ldr	r7, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f9c4:	681b      	ldr	r3, [r3, #0]
   1f9c6:	2601      	movs	r6, #1
   1f9c8:	fa06 f608 	lsl.w	r6, r6, r8
   1f9cc:	4233      	tst	r3, r6
   1f9ce:	d036      	beq.n	1fa3e <st7789v_reset_display+0x9a>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1f9d0:	683b      	ldr	r3, [r7, #0]
   1f9d2:	421e      	tst	r6, r3
   1f9d4:	d141      	bne.n	1fa5a <st7789v_reset_display+0xb6>
   1f9d6:	2701      	movs	r7, #1
	__unused const struct gpio_driver_config *const cfg =
   1f9d8:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f9da:	681b      	ldr	r3, [r3, #0]
   1f9dc:	2601      	movs	r6, #1
   1f9de:	fa06 f608 	lsl.w	r6, r6, r8
   1f9e2:	4233      	tst	r3, r6
   1f9e4:	d03b      	beq.n	1fa5e <st7789v_reset_display+0xba>
	if (value != 0)	{
   1f9e6:	2f00      	cmp	r7, #0
   1f9e8:	d047      	beq.n	1fa7a <st7789v_reset_display+0xd6>
	const struct gpio_driver_api *api =
   1f9ea:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   1f9ec:	68db      	ldr	r3, [r3, #12]
   1f9ee:	4631      	mov	r1, r6
   1f9f0:	4628      	mov	r0, r5
   1f9f2:	4798      	blx	r3
   1f9f4:	20c5      	movs	r0, #197	; 0xc5
   1f9f6:	2100      	movs	r1, #0
   1f9f8:	f009 f9b0 	bl	28d5c <z_impl_k_sleep>
	return gpio_pin_set(spec->port, spec->pin, value);
   1f9fc:	69a5      	ldr	r5, [r4, #24]
   1f9fe:	7f27      	ldrb	r7, [r4, #28]
	__unused const struct gpio_driver_config *const cfg =
   1fa00:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   1fa02:	692c      	ldr	r4, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1fa04:	681b      	ldr	r3, [r3, #0]
   1fa06:	2601      	movs	r6, #1
   1fa08:	40be      	lsls	r6, r7
   1fa0a:	4233      	tst	r3, r6
   1fa0c:	d03b      	beq.n	1fa86 <st7789v_reset_display+0xe2>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1fa0e:	6823      	ldr	r3, [r4, #0]
   1fa10:	421e      	tst	r6, r3
   1fa12:	d146      	bne.n	1faa2 <st7789v_reset_display+0xfe>
   1fa14:	2600      	movs	r6, #0
	__unused const struct gpio_driver_config *const cfg =
   1fa16:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1fa18:	681b      	ldr	r3, [r3, #0]
   1fa1a:	2401      	movs	r4, #1
   1fa1c:	40bc      	lsls	r4, r7
   1fa1e:	4223      	tst	r3, r4
   1fa20:	d041      	beq.n	1faa6 <st7789v_reset_display+0x102>
	if (value != 0)	{
   1fa22:	2e00      	cmp	r6, #0
   1fa24:	d04c      	beq.n	1fac0 <st7789v_reset_display+0x11c>
	const struct gpio_driver_api *api =
   1fa26:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   1fa28:	68db      	ldr	r3, [r3, #12]
   1fa2a:	4621      	mov	r1, r4
   1fa2c:	4628      	mov	r0, r5
   1fa2e:	4798      	blx	r3
   1fa30:	f44f 7024 	mov.w	r0, #656	; 0x290
   1fa34:	2100      	movs	r1, #0
   1fa36:	f009 f991 	bl	28d5c <z_impl_k_sleep>
}
   1fa3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1fa3e:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 1fae4 <st7789v_reset_display+0x140>
   1fa42:	f240 5225 	movw	r2, #1317	; 0x525
   1fa46:	4649      	mov	r1, r9
   1fa48:	4825      	ldr	r0, [pc, #148]	; (1fae0 <st7789v_reset_display+0x13c>)
   1fa4a:	f00c fd70 	bl	2c52e <assert_print>
   1fa4e:	f240 5125 	movw	r1, #1317	; 0x525
   1fa52:	4648      	mov	r0, r9
   1fa54:	f00c fd64 	bl	2c520 <assert_post_action>
   1fa58:	e7ba      	b.n	1f9d0 <st7789v_reset_display+0x2c>
		value = (value != 0) ? 0 : 1;
   1fa5a:	2700      	movs	r7, #0
   1fa5c:	e7bc      	b.n	1f9d8 <st7789v_reset_display+0x34>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1fa5e:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1fae4 <st7789v_reset_display+0x140>
   1fa62:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1fa66:	4641      	mov	r1, r8
   1fa68:	481d      	ldr	r0, [pc, #116]	; (1fae0 <st7789v_reset_display+0x13c>)
   1fa6a:	f00c fd60 	bl	2c52e <assert_print>
   1fa6e:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1fa72:	4640      	mov	r0, r8
   1fa74:	f00c fd54 	bl	2c520 <assert_post_action>
   1fa78:	e7b5      	b.n	1f9e6 <st7789v_reset_display+0x42>
	const struct gpio_driver_api *api =
   1fa7a:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   1fa7c:	691b      	ldr	r3, [r3, #16]
   1fa7e:	4631      	mov	r1, r6
   1fa80:	4628      	mov	r0, r5
   1fa82:	4798      	blx	r3
   1fa84:	e7b6      	b.n	1f9f4 <st7789v_reset_display+0x50>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1fa86:	f8df 805c 	ldr.w	r8, [pc, #92]	; 1fae4 <st7789v_reset_display+0x140>
   1fa8a:	f240 5225 	movw	r2, #1317	; 0x525
   1fa8e:	4641      	mov	r1, r8
   1fa90:	4813      	ldr	r0, [pc, #76]	; (1fae0 <st7789v_reset_display+0x13c>)
   1fa92:	f00c fd4c 	bl	2c52e <assert_print>
   1fa96:	f240 5125 	movw	r1, #1317	; 0x525
   1fa9a:	4640      	mov	r0, r8
   1fa9c:	f00c fd40 	bl	2c520 <assert_post_action>
   1faa0:	e7b5      	b.n	1fa0e <st7789v_reset_display+0x6a>
		value = (value != 0) ? 0 : 1;
   1faa2:	2601      	movs	r6, #1
   1faa4:	e7b7      	b.n	1fa16 <st7789v_reset_display+0x72>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1faa6:	4f0f      	ldr	r7, [pc, #60]	; (1fae4 <st7789v_reset_display+0x140>)
   1faa8:	f240 42fc 	movw	r2, #1276	; 0x4fc
   1faac:	4639      	mov	r1, r7
   1faae:	480c      	ldr	r0, [pc, #48]	; (1fae0 <st7789v_reset_display+0x13c>)
   1fab0:	f00c fd3d 	bl	2c52e <assert_print>
   1fab4:	f240 41fc 	movw	r1, #1276	; 0x4fc
   1fab8:	4638      	mov	r0, r7
   1faba:	f00c fd31 	bl	2c520 <assert_post_action>
   1fabe:	e7b0      	b.n	1fa22 <st7789v_reset_display+0x7e>
	const struct gpio_driver_api *api =
   1fac0:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   1fac2:	691b      	ldr	r3, [r3, #16]
   1fac4:	4621      	mov	r1, r4
   1fac6:	4628      	mov	r0, r5
   1fac8:	4798      	blx	r3
   1faca:	e7b1      	b.n	1fa30 <st7789v_reset_display+0x8c>
		st7789v_transmit(dev, ST7789V_CMD_SW_RESET, NULL, 0);
   1facc:	2300      	movs	r3, #0
   1face:	461a      	mov	r2, r3
   1fad0:	2101      	movs	r1, #1
   1fad2:	f7ff fe83 	bl	1f7dc <st7789v_transmit>
   1fad6:	20a4      	movs	r0, #164	; 0xa4
   1fad8:	2100      	movs	r1, #0
   1fada:	f009 f93f 	bl	28d5c <z_impl_k_sleep>
}
   1fade:	e7ac      	b.n	1fa3a <st7789v_reset_display+0x96>
   1fae0:	00031600 	.word	0x00031600
   1fae4:	000315cc 	.word	0x000315cc

0001fae8 <st7789v_init>:
			 (uint8_t *)config->rgb_param,
			 sizeof(config->rgb_param));
}

static int st7789v_init(const struct device *dev)
{
   1fae8:	b538      	push	{r3, r4, r5, lr}
   1faea:	4605      	mov	r5, r0
	const struct st7789v_config *config = dev->config;
   1faec:	6844      	ldr	r4, [r0, #4]
	if (!device_is_ready(spec->bus)) {
   1faee:	6820      	ldr	r0, [r4, #0]
   1faf0:	f010 fec8 	bl	30884 <z_device_is_ready>
   1faf4:	4603      	mov	r3, r0
   1faf6:	b128      	cbz	r0, 1fb04 <st7789v_init+0x1c>
	if (spec->config.cs &&
   1faf8:	68e2      	ldr	r2, [r4, #12]
   1fafa:	b11a      	cbz	r2, 1fb04 <st7789v_init+0x1c>
	    !device_is_ready(spec->config.cs->gpio.port)) {
   1fafc:	6810      	ldr	r0, [r2, #0]
   1fafe:	f010 fec1 	bl	30884 <z_device_is_ready>
   1fb02:	4603      	mov	r3, r0

	if (!spi_is_ready(&config->bus)) {
   1fb04:	b33b      	cbz	r3, 1fb56 <st7789v_init+0x6e>
		LOG_ERR("SPI device not ready");
		return -ENODEV;
	}

	if (config->reset_gpio.port != NULL) {
   1fb06:	69a0      	ldr	r0, [r4, #24]
   1fb08:	b150      	cbz	r0, 1fb20 <st7789v_init+0x38>
   1fb0a:	f010 febb 	bl	30884 <z_device_is_ready>
		if (!device_is_ready(config->reset_gpio.port)) {
   1fb0e:	b348      	cbz	r0, 1fb64 <st7789v_init+0x7c>
	return gpio_pin_configure(spec->port,
   1fb10:	69a0      	ldr	r0, [r4, #24]
   1fb12:	7f21      	ldrb	r1, [r4, #28]
				  spec->dt_flags | extra_flags);
   1fb14:	8be2      	ldrh	r2, [r4, #30]
	return gpio_pin_configure(spec->port,
   1fb16:	f442 12b0 	orr.w	r2, r2, #1441792	; 0x160000
   1fb1a:	f7ff fd95 	bl	1f648 <z_impl_gpio_pin_configure>
			LOG_ERR("Reset GPIO device not ready");
			return -ENODEV;
		}

		if (gpio_pin_configure_dt(&config->reset_gpio, GPIO_OUTPUT_INACTIVE)) {
   1fb1e:	bb40      	cbnz	r0, 1fb72 <st7789v_init+0x8a>
			LOG_ERR("Couldn't configure reset pin");
			return -EIO;
		}
	}

	if (config->cmd_data_gpio.port != NULL) {
   1fb20:	6920      	ldr	r0, [r4, #16]
   1fb22:	b150      	cbz	r0, 1fb3a <st7789v_init+0x52>
   1fb24:	f010 feae 	bl	30884 <z_device_is_ready>
		if (!device_is_ready(config->cmd_data_gpio.port)) {
   1fb28:	b350      	cbz	r0, 1fb80 <st7789v_init+0x98>
   1fb2a:	6920      	ldr	r0, [r4, #16]
   1fb2c:	7d21      	ldrb	r1, [r4, #20]
				  spec->dt_flags | extra_flags);
   1fb2e:	8ae2      	ldrh	r2, [r4, #22]
	return gpio_pin_configure(spec->port,
   1fb30:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   1fb34:	f7ff fd88 	bl	1f648 <z_impl_gpio_pin_configure>
			LOG_ERR("CMD/DATA GPIO device not ready");
			return -ENODEV;
		}

		if (gpio_pin_configure_dt(&config->cmd_data_gpio, GPIO_OUTPUT)) {
   1fb38:	bb48      	cbnz	r0, 1fb8e <st7789v_init+0xa6>
			LOG_ERR("Couldn't configure CMD/DATA pin");
			return -EIO;
		}
	}

	st7789v_reset_display(dev);
   1fb3a:	4628      	mov	r0, r5
   1fb3c:	f7ff ff32 	bl	1f9a4 <st7789v_reset_display>

	st7789v_blanking_on(dev);
   1fb40:	4628      	mov	r0, r5
   1fb42:	f00f fb20 	bl	2f186 <st7789v_blanking_on>

	st7789v_lcd_init(dev);
   1fb46:	4628      	mov	r0, r5
   1fb48:	f00f fb25 	bl	2f196 <st7789v_lcd_init>

	st7789v_exit_sleep(dev);
   1fb4c:	4628      	mov	r0, r5
   1fb4e:	f00f fabc 	bl	2f0ca <st7789v_exit_sleep>

	return 0;
   1fb52:	2000      	movs	r0, #0
}
   1fb54:	bd38      	pop	{r3, r4, r5, pc}
		LOG_ERR("SPI device not ready");
   1fb56:	2145      	movs	r1, #69	; 0x45
   1fb58:	4810      	ldr	r0, [pc, #64]	; (1fb9c <st7789v_init+0xb4>)
   1fb5a:	f00c fcf7 	bl	2c54c <z_log_minimal_printk>
		return -ENODEV;
   1fb5e:	f06f 0012 	mvn.w	r0, #18
   1fb62:	e7f7      	b.n	1fb54 <st7789v_init+0x6c>
			LOG_ERR("Reset GPIO device not ready");
   1fb64:	2145      	movs	r1, #69	; 0x45
   1fb66:	480e      	ldr	r0, [pc, #56]	; (1fba0 <st7789v_init+0xb8>)
   1fb68:	f00c fcf0 	bl	2c54c <z_log_minimal_printk>
			return -ENODEV;
   1fb6c:	f06f 0012 	mvn.w	r0, #18
   1fb70:	e7f0      	b.n	1fb54 <st7789v_init+0x6c>
			LOG_ERR("Couldn't configure reset pin");
   1fb72:	2145      	movs	r1, #69	; 0x45
   1fb74:	480b      	ldr	r0, [pc, #44]	; (1fba4 <st7789v_init+0xbc>)
   1fb76:	f00c fce9 	bl	2c54c <z_log_minimal_printk>
			return -EIO;
   1fb7a:	f06f 0004 	mvn.w	r0, #4
   1fb7e:	e7e9      	b.n	1fb54 <st7789v_init+0x6c>
			LOG_ERR("CMD/DATA GPIO device not ready");
   1fb80:	2145      	movs	r1, #69	; 0x45
   1fb82:	4809      	ldr	r0, [pc, #36]	; (1fba8 <st7789v_init+0xc0>)
   1fb84:	f00c fce2 	bl	2c54c <z_log_minimal_printk>
			return -ENODEV;
   1fb88:	f06f 0012 	mvn.w	r0, #18
   1fb8c:	e7e2      	b.n	1fb54 <st7789v_init+0x6c>
			LOG_ERR("Couldn't configure CMD/DATA pin");
   1fb8e:	2145      	movs	r1, #69	; 0x45
   1fb90:	4806      	ldr	r0, [pc, #24]	; (1fbac <st7789v_init+0xc4>)
   1fb92:	f00c fcdb 	bl	2c54c <z_log_minimal_printk>
			return -EIO;
   1fb96:	f06f 0004 	mvn.w	r0, #4
   1fb9a:	e7db      	b.n	1fb54 <st7789v_init+0x6c>
   1fb9c:	0003aec0 	.word	0x0003aec0
   1fba0:	0003aedc 	.word	0x0003aedc
   1fba4:	0003af00 	.word	0x0003af00
   1fba8:	0003af24 	.word	0x0003af24
   1fbac:	0003af48 	.word	0x0003af48

0001fbb0 <st7789v_write>:
{
   1fbb0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1fbb4:	b083      	sub	sp, #12
   1fbb6:	4607      	mov	r7, r0
   1fbb8:	460c      	mov	r4, r1
   1fbba:	4690      	mov	r8, r2
   1fbbc:	461d      	mov	r5, r3
   1fbbe:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	__ASSERT(desc->width <= desc->pitch, "Pitch is smaller then width");
   1fbc0:	889a      	ldrh	r2, [r3, #4]
   1fbc2:	891b      	ldrh	r3, [r3, #8]
   1fbc4:	429a      	cmp	r2, r3
   1fbc6:	d819      	bhi.n	1fbfc <st7789v_write+0x4c>
	__ASSERT((desc->pitch * ST7789V_PIXEL_SIZE * desc->height) <= desc->buf_size,
   1fbc8:	892b      	ldrh	r3, [r5, #8]
   1fbca:	88ea      	ldrh	r2, [r5, #6]
   1fbcc:	fb02 f303 	mul.w	r3, r2, r3
   1fbd0:	682a      	ldr	r2, [r5, #0]
   1fbd2:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
   1fbd6:	d31d      	bcc.n	1fc14 <st7789v_write+0x64>
	st7789v_set_mem_area(dev, x, y, desc->width, desc->height);
   1fbd8:	88eb      	ldrh	r3, [r5, #6]
   1fbda:	9300      	str	r3, [sp, #0]
   1fbdc:	88ab      	ldrh	r3, [r5, #4]
   1fbde:	4642      	mov	r2, r8
   1fbe0:	4621      	mov	r1, r4
   1fbe2:	4638      	mov	r0, r7
   1fbe4:	f00f fa8f 	bl	2f106 <st7789v_set_mem_area>
	if (desc->pitch > desc->width) {
   1fbe8:	892a      	ldrh	r2, [r5, #8]
   1fbea:	88ab      	ldrh	r3, [r5, #4]
   1fbec:	429a      	cmp	r2, r3
   1fbee:	d91d      	bls.n	1fc2c <st7789v_write+0x7c>
		nbr_of_writes = desc->height;
   1fbf0:	f8b5 8006 	ldrh.w	r8, [r5, #6]
		write_h = 1U;
   1fbf4:	f04f 0901 	mov.w	r9, #1
	for (uint16_t write_cnt = 0U; write_cnt < nbr_of_writes; ++write_cnt) {
   1fbf8:	2400      	movs	r4, #0
   1fbfa:	e02a      	b.n	1fc52 <st7789v_write+0xa2>
	__ASSERT(desc->width <= desc->pitch, "Pitch is smaller then width");
   1fbfc:	f8df 906c 	ldr.w	r9, [pc, #108]	; 1fc6c <st7789v_write+0xbc>
   1fc00:	22b5      	movs	r2, #181	; 0xb5
   1fc02:	4649      	mov	r1, r9
   1fc04:	4818      	ldr	r0, [pc, #96]	; (1fc68 <st7789v_write+0xb8>)
   1fc06:	f00c fc92 	bl	2c52e <assert_print>
   1fc0a:	21b5      	movs	r1, #181	; 0xb5
   1fc0c:	4648      	mov	r0, r9
   1fc0e:	f00c fc87 	bl	2c520 <assert_post_action>
   1fc12:	e7d9      	b.n	1fbc8 <st7789v_write+0x18>
	__ASSERT((desc->pitch * ST7789V_PIXEL_SIZE * desc->height) <= desc->buf_size,
   1fc14:	f8df 9054 	ldr.w	r9, [pc, #84]	; 1fc6c <st7789v_write+0xbc>
   1fc18:	22b6      	movs	r2, #182	; 0xb6
   1fc1a:	4649      	mov	r1, r9
   1fc1c:	4812      	ldr	r0, [pc, #72]	; (1fc68 <st7789v_write+0xb8>)
   1fc1e:	f00c fc86 	bl	2c52e <assert_print>
   1fc22:	21b6      	movs	r1, #182	; 0xb6
   1fc24:	4648      	mov	r0, r9
   1fc26:	f00c fc7b 	bl	2c520 <assert_post_action>
   1fc2a:	e7d5      	b.n	1fbd8 <st7789v_write+0x28>
		write_h = desc->height;
   1fc2c:	f8b5 9006 	ldrh.w	r9, [r5, #6]
		nbr_of_writes = 1U;
   1fc30:	f04f 0801 	mov.w	r8, #1
   1fc34:	e7e0      	b.n	1fbf8 <st7789v_write+0x48>
		st7789v_transmit(dev, write_cnt == 0U ? ST7789V_CMD_RAMWR : ST7789V_CMD_NONE,
   1fc36:	212c      	movs	r1, #44	; 0x2c
				desc->width * ST7789V_PIXEL_SIZE * write_h);
   1fc38:	88ab      	ldrh	r3, [r5, #4]
   1fc3a:	fb03 f309 	mul.w	r3, r3, r9
		st7789v_transmit(dev, write_cnt == 0U ? ST7789V_CMD_RAMWR : ST7789V_CMD_NONE,
   1fc3e:	005b      	lsls	r3, r3, #1
   1fc40:	4632      	mov	r2, r6
   1fc42:	4638      	mov	r0, r7
   1fc44:	f7ff fdca 	bl	1f7dc <st7789v_transmit>
		write_data_start += (desc->pitch * ST7789V_PIXEL_SIZE);
   1fc48:	892b      	ldrh	r3, [r5, #8]
   1fc4a:	eb06 0643 	add.w	r6, r6, r3, lsl #1
	for (uint16_t write_cnt = 0U; write_cnt < nbr_of_writes; ++write_cnt) {
   1fc4e:	3401      	adds	r4, #1
   1fc50:	b2a4      	uxth	r4, r4
   1fc52:	45a0      	cmp	r8, r4
   1fc54:	d903      	bls.n	1fc5e <st7789v_write+0xae>
		st7789v_transmit(dev, write_cnt == 0U ? ST7789V_CMD_RAMWR : ST7789V_CMD_NONE,
   1fc56:	2c00      	cmp	r4, #0
   1fc58:	d0ed      	beq.n	1fc36 <st7789v_write+0x86>
   1fc5a:	21ff      	movs	r1, #255	; 0xff
   1fc5c:	e7ec      	b.n	1fc38 <st7789v_write+0x88>
}
   1fc5e:	2000      	movs	r0, #0
   1fc60:	b003      	add	sp, #12
   1fc62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1fc66:	bf00      	nop
   1fc68:	00031600 	.word	0x00031600
   1fc6c:	0003af70 	.word	0x0003af70

0001fc70 <get_dev>:
			dev = DEVICE_DT_INST_GET(i); \
		}

	if (0) {
	} /* Followed by else if from FOREACH macro. Done to avoid return statement in macro.  */
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fc70:	b908      	cbnz	r0, 1fc76 <get_dev+0x6>
   1fc72:	4802      	ldr	r0, [pc, #8]	; (1fc7c <get_dev+0xc>)
	#undef GPIO_NRF_GET_DEV

	return dev;
}
   1fc74:	4770      	bx	lr
	const struct device *dev = NULL;
   1fc76:	2000      	movs	r0, #0
   1fc78:	4770      	bx	lr
   1fc7a:	bf00      	nop
   1fc7c:	00030ff0 	.word	0x00030ff0

0001fc80 <gpio_nrfx_manage_callback>:
{
   1fc80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1fc84:	4616      	mov	r6, r2
	return port->data;
   1fc86:	6905      	ldr	r5, [r0, #16]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1fc88:	1d2f      	adds	r7, r5, #4
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
   1fc8a:	460c      	mov	r4, r1
   1fc8c:	b131      	cbz	r1, 1fc9c <gpio_nrfx_manage_callback+0x1c>
	__ASSERT(callback->handler, "No callback handler!");
   1fc8e:	6863      	ldr	r3, [r4, #4]
   1fc90:	b183      	cbz	r3, 1fcb4 <gpio_nrfx_manage_callback+0x34>
	return list->head;
   1fc92:	686b      	ldr	r3, [r5, #4]

	if (!sys_slist_is_empty(callbacks)) {
   1fc94:	2b00      	cmp	r3, #0
   1fc96:	d033      	beq.n	1fd00 <gpio_nrfx_manage_callback+0x80>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1fc98:	2100      	movs	r1, #0
   1fc9a:	e022      	b.n	1fce2 <gpio_nrfx_manage_callback+0x62>
	__ASSERT(callback, "No callback!");
   1fc9c:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1fd28 <gpio_nrfx_manage_callback+0xa8>
   1fca0:	2224      	movs	r2, #36	; 0x24
   1fca2:	4641      	mov	r1, r8
   1fca4:	481f      	ldr	r0, [pc, #124]	; (1fd24 <gpio_nrfx_manage_callback+0xa4>)
   1fca6:	f00c fc42 	bl	2c52e <assert_print>
   1fcaa:	2124      	movs	r1, #36	; 0x24
   1fcac:	4640      	mov	r0, r8
   1fcae:	f00c fc37 	bl	2c520 <assert_post_action>
   1fcb2:	e7ec      	b.n	1fc8e <gpio_nrfx_manage_callback+0xe>
	__ASSERT(callback->handler, "No callback handler!");
   1fcb4:	f8df 8070 	ldr.w	r8, [pc, #112]	; 1fd28 <gpio_nrfx_manage_callback+0xa8>
   1fcb8:	2225      	movs	r2, #37	; 0x25
   1fcba:	4641      	mov	r1, r8
   1fcbc:	4819      	ldr	r0, [pc, #100]	; (1fd24 <gpio_nrfx_manage_callback+0xa4>)
   1fcbe:	f00c fc36 	bl	2c52e <assert_print>
   1fcc2:	2125      	movs	r1, #37	; 0x25
   1fcc4:	4640      	mov	r0, r8
   1fcc6:	f00c fc2b 	bl	2c520 <assert_post_action>
   1fcca:	e7e2      	b.n	1fc92 <gpio_nrfx_manage_callback+0x12>
	return node->next;
   1fccc:	6823      	ldr	r3, [r4, #0]
	list->head = node;
   1fcce:	606b      	str	r3, [r5, #4]
	return list->tail;
   1fcd0:	687a      	ldr	r2, [r7, #4]
Z_GENLIST_REMOVE(slist, snode)
   1fcd2:	4294      	cmp	r4, r2
   1fcd4:	d10f      	bne.n	1fcf6 <gpio_nrfx_manage_callback+0x76>
	list->tail = node;
   1fcd6:	607b      	str	r3, [r7, #4]
}
   1fcd8:	e00d      	b.n	1fcf6 <gpio_nrfx_manage_callback+0x76>
	list->tail = node;
   1fcda:	6079      	str	r1, [r7, #4]
}
   1fcdc:	e00b      	b.n	1fcf6 <gpio_nrfx_manage_callback+0x76>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1fcde:	4619      	mov	r1, r3
   1fce0:	681b      	ldr	r3, [r3, #0]
   1fce2:	b15b      	cbz	r3, 1fcfc <gpio_nrfx_manage_callback+0x7c>
   1fce4:	429c      	cmp	r4, r3
   1fce6:	d1fa      	bne.n	1fcde <gpio_nrfx_manage_callback+0x5e>
Z_GENLIST_REMOVE(slist, snode)
   1fce8:	2900      	cmp	r1, #0
   1fcea:	d0ef      	beq.n	1fccc <gpio_nrfx_manage_callback+0x4c>
	return node->next;
   1fcec:	6823      	ldr	r3, [r4, #0]
	parent->next = child;
   1fcee:	600b      	str	r3, [r1, #0]
	return list->tail;
   1fcf0:	687b      	ldr	r3, [r7, #4]
Z_GENLIST_REMOVE(slist, snode)
   1fcf2:	429c      	cmp	r4, r3
   1fcf4:	d0f1      	beq.n	1fcda <gpio_nrfx_manage_callback+0x5a>
	parent->next = child;
   1fcf6:	2300      	movs	r3, #0
   1fcf8:	6023      	str	r3, [r4, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1fcfa:	2301      	movs	r3, #1
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
   1fcfc:	b903      	cbnz	r3, 1fd00 <gpio_nrfx_manage_callback+0x80>
			if (!set) {
   1fcfe:	b156      	cbz	r6, 1fd16 <gpio_nrfx_manage_callback+0x96>
				return -EINVAL;
			}
		}
	}

	if (set) {
   1fd00:	b166      	cbz	r6, 1fd1c <gpio_nrfx_manage_callback+0x9c>
	return list->head;
   1fd02:	686b      	ldr	r3, [r5, #4]
	parent->next = child;
   1fd04:	6023      	str	r3, [r4, #0]
	list->head = node;
   1fd06:	606c      	str	r4, [r5, #4]
	return list->tail;
   1fd08:	687b      	ldr	r3, [r7, #4]
Z_GENLIST_PREPEND(slist, snode)
   1fd0a:	b10b      	cbz	r3, 1fd10 <gpio_nrfx_manage_callback+0x90>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1fd0c:	2000      	movs	r0, #0
   1fd0e:	e006      	b.n	1fd1e <gpio_nrfx_manage_callback+0x9e>
	list->tail = node;
   1fd10:	607c      	str	r4, [r7, #4]
   1fd12:	2000      	movs	r0, #0
}
   1fd14:	e003      	b.n	1fd1e <gpio_nrfx_manage_callback+0x9e>
				return -EINVAL;
   1fd16:	f06f 0015 	mvn.w	r0, #21
   1fd1a:	e000      	b.n	1fd1e <gpio_nrfx_manage_callback+0x9e>
	return 0;
   1fd1c:	2000      	movs	r0, #0
}
   1fd1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1fd22:	bf00      	nop
   1fd24:	00031600 	.word	0x00031600
   1fd28:	0003b054 	.word	0x0003b054

0001fd2c <nrfx_gpio_handler>:

static void nrfx_gpio_handler(nrfx_gpiote_pin_t abs_pin,
			      nrfx_gpiote_trigger_t trigger,
			      void *context)
{
   1fd2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   1fd30:	f000 041f 	and.w	r4, r0, #31
	uint32_t pin = abs_pin;
	uint32_t port_id = nrf_gpio_pin_port_number_extract(&pin);
	const struct device *port = get_dev(port_id);
   1fd34:	0940      	lsrs	r0, r0, #5
   1fd36:	f7ff ff9b 	bl	1fc70 <get_dev>

	/* If given port is handled directly by nrfx driver it might not be enabled in DT. */
	if (port == NULL) {
   1fd3a:	b360      	cbz	r0, 1fd96 <nrfx_gpio_handler+0x6a>
   1fd3c:	4607      	mov	r7, r0
	return port->data;
   1fd3e:	6903      	ldr	r3, [r0, #16]
	}

	struct gpio_nrfx_data *data = get_port_data(port);
	sys_slist_t *list = &data->callbacks;

	gpio_fire_callbacks(list, port, BIT(pin));
   1fd40:	2601      	movs	r6, #1
   1fd42:	40a6      	lsls	r6, r4
	return list->head;
   1fd44:	685c      	ldr	r4, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fd46:	b11c      	cbz	r4, 1fd50 <nrfx_gpio_handler+0x24>
   1fd48:	4625      	mov	r5, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
   1fd4a:	b17c      	cbz	r4, 1fd6c <nrfx_gpio_handler+0x40>
	return node->next;
   1fd4c:	6825      	ldr	r5, [r4, #0]
   1fd4e:	e00d      	b.n	1fd6c <nrfx_gpio_handler+0x40>
   1fd50:	4625      	mov	r5, r4
   1fd52:	e00b      	b.n	1fd6c <nrfx_gpio_handler+0x40>
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   1fd54:	6863      	ldr	r3, [r4, #4]
   1fd56:	68a2      	ldr	r2, [r4, #8]
   1fd58:	4032      	ands	r2, r6
   1fd5a:	4621      	mov	r1, r4
   1fd5c:	4638      	mov	r0, r7
   1fd5e:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fd60:	b1bd      	cbz	r5, 1fd92 <nrfx_gpio_handler+0x66>
   1fd62:	462b      	mov	r3, r5
Z_GENLIST_PEEK_NEXT(slist, snode)
   1fd64:	b105      	cbz	r5, 1fd68 <nrfx_gpio_handler+0x3c>
	return node->next;
   1fd66:	682b      	ldr	r3, [r5, #0]
   1fd68:	462c      	mov	r4, r5
   1fd6a:	461d      	mov	r5, r3
   1fd6c:	b19c      	cbz	r4, 1fd96 <nrfx_gpio_handler+0x6a>
		if (cb->pin_mask & pins) {
   1fd6e:	68a3      	ldr	r3, [r4, #8]
   1fd70:	421e      	tst	r6, r3
   1fd72:	d0f5      	beq.n	1fd60 <nrfx_gpio_handler+0x34>
			__ASSERT(cb->handler, "No callback handler!");
   1fd74:	6863      	ldr	r3, [r4, #4]
   1fd76:	2b00      	cmp	r3, #0
   1fd78:	d1ec      	bne.n	1fd54 <nrfx_gpio_handler+0x28>
   1fd7a:	f8df 8024 	ldr.w	r8, [pc, #36]	; 1fda0 <nrfx_gpio_handler+0x74>
   1fd7e:	2245      	movs	r2, #69	; 0x45
   1fd80:	4641      	mov	r1, r8
   1fd82:	4806      	ldr	r0, [pc, #24]	; (1fd9c <nrfx_gpio_handler+0x70>)
   1fd84:	f00c fbd3 	bl	2c52e <assert_print>
   1fd88:	2145      	movs	r1, #69	; 0x45
   1fd8a:	4640      	mov	r0, r8
   1fd8c:	f00c fbc8 	bl	2c520 <assert_post_action>
   1fd90:	e7e0      	b.n	1fd54 <nrfx_gpio_handler+0x28>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fd92:	462b      	mov	r3, r5
   1fd94:	e7e8      	b.n	1fd68 <nrfx_gpio_handler+0x3c>
}
   1fd96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1fd9a:	bf00      	nop
   1fd9c:	00031600 	.word	0x00031600
   1fda0:	0003b054 	.word	0x0003b054

0001fda4 <gpio_nrfx_pin_interrupt_configure>:
{
   1fda4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fda6:	b085      	sub	sp, #20
   1fda8:	460e      	mov	r6, r1
   1fdaa:	4619      	mov	r1, r3
	return port->config;
   1fdac:	6843      	ldr	r3, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fdae:	7b1b      	ldrb	r3, [r3, #12]
   1fdb0:	f006 051f 	and.w	r5, r6, #31
   1fdb4:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
   1fdb8:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
   1fdbc:	d022      	beq.n	1fe04 <gpio_nrfx_pin_interrupt_configure+0x60>
   1fdbe:	4607      	mov	r7, r0
   1fdc0:	4614      	mov	r4, r2
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fdc2:	2300      	movs	r3, #0
   1fdc4:	9301      	str	r3, [sp, #4]
   1fdc6:	9302      	str	r3, [sp, #8]
		.trigger = get_trigger(mode, trig),
   1fdc8:	4610      	mov	r0, r2
   1fdca:	f00f fb1c 	bl	2f406 <get_trigger>
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fdce:	f88d 0004 	strb.w	r0, [sp, #4]
	return port->config;
   1fdd2:	687b      	ldr	r3, [r7, #4]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   1fdd4:	6899      	ldr	r1, [r3, #8]
   1fdd6:	40f1      	lsrs	r1, r6
   1fdd8:	f011 0101 	ands.w	r1, r1, #1
   1fddc:	d102      	bne.n	1fde4 <gpio_nrfx_pin_interrupt_configure+0x40>
   1fdde:	f1b4 7fa0 	cmp.w	r4, #20971520	; 0x1400000
   1fde2:	d014      	beq.n	1fe0e <gpio_nrfx_pin_interrupt_configure+0x6a>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fde4:	2300      	movs	r3, #0
   1fde6:	aa01      	add	r2, sp, #4
   1fde8:	4619      	mov	r1, r3
   1fdea:	4628      	mov	r0, r5
   1fdec:	f003 fc5e 	bl	236ac <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fdf0:	4b2c      	ldr	r3, [pc, #176]	; (1fea4 <gpio_nrfx_pin_interrupt_configure+0x100>)
   1fdf2:	4298      	cmp	r0, r3
   1fdf4:	d152      	bne.n	1fe9c <gpio_nrfx_pin_interrupt_configure+0xf8>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   1fdf6:	2101      	movs	r1, #1
   1fdf8:	4628      	mov	r0, r5
   1fdfa:	f003 fe99 	bl	23b30 <nrfx_gpiote_trigger_enable>
	return 0;
   1fdfe:	2000      	movs	r0, #0
}
   1fe00:	b005      	add	sp, #20
   1fe02:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrfx_gpiote_trigger_disable(abs_pin);
   1fe04:	4628      	mov	r0, r5
   1fe06:	f003 ff75 	bl	23cf4 <nrfx_gpiote_trigger_disable>
		return 0;
   1fe0a:	2000      	movs	r0, #0
   1fe0c:	e7f8      	b.n	1fe00 <gpio_nrfx_pin_interrupt_configure+0x5c>
    switch (port)
   1fe0e:	096b      	lsrs	r3, r5, #5
   1fe10:	d101      	bne.n	1fe16 <gpio_nrfx_pin_interrupt_configure+0x72>
            mask = P0_FEATURE_PINS_PRESENT;
   1fe12:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   1fe16:	f005 031f 	and.w	r3, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   1fe1a:	40d9      	lsrs	r1, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fe1c:	f011 0f01 	tst.w	r1, #1
   1fe20:	d018      	beq.n	1fe54 <gpio_nrfx_pin_interrupt_configure+0xb0>
    *p_pin = pin_number & 0x1F;
   1fe22:	f005 041f 	and.w	r4, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1fe26:	096b      	lsrs	r3, r5, #5
   1fe28:	d121      	bne.n	1fe6e <gpio_nrfx_pin_interrupt_configure+0xca>
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1fe2a:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
   1fe2e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   1fe32:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   1fe36:	f013 0f01 	tst.w	r3, #1
   1fe3a:	d1d3      	bne.n	1fde4 <gpio_nrfx_pin_interrupt_configure+0x40>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fe3c:	f10d 010f 	add.w	r1, sp, #15
   1fe40:	4628      	mov	r0, r5
   1fe42:	f003 fe07 	bl	23a54 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   1fe46:	4b18      	ldr	r3, [pc, #96]	; (1fea8 <gpio_nrfx_pin_interrupt_configure+0x104>)
   1fe48:	4298      	cmp	r0, r3
   1fe4a:	d01d      	beq.n	1fe88 <gpio_nrfx_pin_interrupt_configure+0xe4>
		trigger_config.p_in_channel = &ch;
   1fe4c:	f10d 030f 	add.w	r3, sp, #15
   1fe50:	9302      	str	r3, [sp, #8]
   1fe52:	e7c7      	b.n	1fde4 <gpio_nrfx_pin_interrupt_configure+0x40>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fe54:	4c15      	ldr	r4, [pc, #84]	; (1feac <gpio_nrfx_pin_interrupt_configure+0x108>)
   1fe56:	f240 2247 	movw	r2, #583	; 0x247
   1fe5a:	4621      	mov	r1, r4
   1fe5c:	4814      	ldr	r0, [pc, #80]	; (1feb0 <gpio_nrfx_pin_interrupt_configure+0x10c>)
   1fe5e:	f00c fb66 	bl	2c52e <assert_print>
   1fe62:	f240 2147 	movw	r1, #583	; 0x247
   1fe66:	4620      	mov	r0, r4
   1fe68:	f00c fb5a 	bl	2c520 <assert_post_action>
   1fe6c:	e7d9      	b.n	1fe22 <gpio_nrfx_pin_interrupt_configure+0x7e>
            NRFX_ASSERT(0);
   1fe6e:	4e0f      	ldr	r6, [pc, #60]	; (1feac <gpio_nrfx_pin_interrupt_configure+0x108>)
   1fe70:	f44f 7213 	mov.w	r2, #588	; 0x24c
   1fe74:	4631      	mov	r1, r6
   1fe76:	480e      	ldr	r0, [pc, #56]	; (1feb0 <gpio_nrfx_pin_interrupt_configure+0x10c>)
   1fe78:	f00c fb59 	bl	2c52e <assert_print>
   1fe7c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   1fe80:	4630      	mov	r0, r6
   1fe82:	f00c fb4d 	bl	2c520 <assert_post_action>
   1fe86:	e7d0      	b.n	1fe2a <gpio_nrfx_pin_interrupt_configure+0x86>
			err = nrfx_gpiote_channel_alloc(&ch);
   1fe88:	f10d 000f 	add.w	r0, sp, #15
   1fe8c:	f003 fe48 	bl	23b20 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   1fe90:	4b04      	ldr	r3, [pc, #16]	; (1fea4 <gpio_nrfx_pin_interrupt_configure+0x100>)
   1fe92:	4298      	cmp	r0, r3
   1fe94:	d0da      	beq.n	1fe4c <gpio_nrfx_pin_interrupt_configure+0xa8>
				return -ENOMEM;
   1fe96:	f06f 000b 	mvn.w	r0, #11
   1fe9a:	e7b1      	b.n	1fe00 <gpio_nrfx_pin_interrupt_configure+0x5c>
		return -EINVAL;
   1fe9c:	f06f 0015 	mvn.w	r0, #21
   1fea0:	e7ae      	b.n	1fe00 <gpio_nrfx_pin_interrupt_configure+0x5c>
   1fea2:	bf00      	nop
   1fea4:	0bad0000 	.word	0x0bad0000
   1fea8:	0bad0004 	.word	0x0bad0004
   1feac:	0003b084 	.word	0x0003b084
   1feb0:	00031600 	.word	0x00031600

0001feb4 <gpio_nrfx_pin_configure>:
{
   1feb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1feb8:	b086      	sub	sp, #24
   1feba:	460e      	mov	r6, r1
   1febc:	4614      	mov	r4, r2
	return port->config;
   1febe:	f8d0 8004 	ldr.w	r8, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fec2:	f898 300c 	ldrb.w	r3, [r8, #12]
   1fec6:	f001 051f 	and.w	r5, r1, #31
   1feca:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fece:	f10d 0117 	add.w	r1, sp, #23
   1fed2:	4628      	mov	r0, r5
   1fed4:	f003 fdbe 	bl	23a54 <nrfx_gpiote_channel_get>
   1fed8:	4607      	mov	r7, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1feda:	f414 3f40 	tst.w	r4, #196608	; 0x30000
   1fede:	d03b      	beq.n	1ff58 <gpio_nrfx_pin_configure+0xa4>
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fee0:	2100      	movs	r1, #0
   1fee2:	9103      	str	r1, [sp, #12]
   1fee4:	9104      	str	r1, [sp, #16]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fee6:	460b      	mov	r3, r1
   1fee8:	aa03      	add	r2, sp, #12
   1feea:	4628      	mov	r0, r5
   1feec:	f003 fbde 	bl	236ac <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fef0:	4b41      	ldr	r3, [pc, #260]	; (1fff8 <gpio_nrfx_pin_configure+0x144>)
   1fef2:	4298      	cmp	r0, r3
   1fef4:	d17d      	bne.n	1fff2 <gpio_nrfx_pin_configure+0x13e>
	if (free_ch) {
   1fef6:	429f      	cmp	r7, r3
   1fef8:	d04b      	beq.n	1ff92 <gpio_nrfx_pin_configure+0xde>
	if (flags & GPIO_OUTPUT) {
   1fefa:	f414 3f00 	tst.w	r4, #131072	; 0x20000
   1fefe:	d065      	beq.n	1ffcc <gpio_nrfx_pin_configure+0x118>
		int rv = get_drive(flags, &drive);
   1ff00:	f10d 0103 	add.w	r1, sp, #3
   1ff04:	4620      	mov	r0, r4
   1ff06:	f00f fa03 	bl	2f310 <get_drive>
		if (rv != 0) {
   1ff0a:	4607      	mov	r7, r0
   1ff0c:	bb58      	cbnz	r0, 1ff66 <gpio_nrfx_pin_configure+0xb2>
		nrfx_gpiote_output_config_t output_config = {
   1ff0e:	f89d 3003 	ldrb.w	r3, [sp, #3]
   1ff12:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   1ff16:	f414 3f80 	tst.w	r4, #65536	; 0x10000
   1ff1a:	bf0c      	ite	eq
   1ff1c:	2301      	moveq	r3, #1
   1ff1e:	2300      	movne	r3, #0
		nrfx_gpiote_output_config_t output_config = {
   1ff20:	f88d 3005 	strb.w	r3, [sp, #5]
			.pull = get_pull(flags)
   1ff24:	4620      	mov	r0, r4
   1ff26:	f00f fa36 	bl	2f396 <get_pull>
		nrfx_gpiote_output_config_t output_config = {
   1ff2a:	f88d 0006 	strb.w	r0, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1ff2e:	f414 2f00 	tst.w	r4, #524288	; 0x80000
   1ff32:	d040      	beq.n	1ffb6 <gpio_nrfx_pin_configure+0x102>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   1ff34:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1ff38:	2101      	movs	r1, #1
   1ff3a:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   1ff3e:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   1ff42:	2200      	movs	r2, #0
   1ff44:	a901      	add	r1, sp, #4
   1ff46:	4628      	mov	r0, r5
   1ff48:	f003 fc96 	bl	23878 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   1ff4c:	4b2a      	ldr	r3, [pc, #168]	; (1fff8 <gpio_nrfx_pin_configure+0x144>)
   1ff4e:	4298      	cmp	r0, r3
   1ff50:	d009      	beq.n	1ff66 <gpio_nrfx_pin_configure+0xb2>
   1ff52:	f06f 0715 	mvn.w	r7, #21
   1ff56:	e006      	b.n	1ff66 <gpio_nrfx_pin_configure+0xb2>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
   1ff58:	4628      	mov	r0, r5
   1ff5a:	f003 ff21 	bl	23da0 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
   1ff5e:	4b26      	ldr	r3, [pc, #152]	; (1fff8 <gpio_nrfx_pin_configure+0x144>)
   1ff60:	429f      	cmp	r7, r3
   1ff62:	d004      	beq.n	1ff6e <gpio_nrfx_pin_configure+0xba>
		return 0;
   1ff64:	2700      	movs	r7, #0
}
   1ff66:	4638      	mov	r0, r7
   1ff68:	b006      	add	sp, #24
   1ff6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			err = nrfx_gpiote_channel_free(ch);
   1ff6e:	f89d 0017 	ldrb.w	r0, [sp, #23]
   1ff72:	f003 fdcd 	bl	23b10 <nrfx_gpiote_channel_free>
			__ASSERT_NO_MSG(err == NRFX_SUCCESS);
   1ff76:	4b20      	ldr	r3, [pc, #128]	; (1fff8 <gpio_nrfx_pin_configure+0x144>)
   1ff78:	4298      	cmp	r0, r3
   1ff7a:	d0f3      	beq.n	1ff64 <gpio_nrfx_pin_configure+0xb0>
   1ff7c:	4c1f      	ldr	r4, [pc, #124]	; (1fffc <gpio_nrfx_pin_configure+0x148>)
   1ff7e:	2268      	movs	r2, #104	; 0x68
   1ff80:	4621      	mov	r1, r4
   1ff82:	481f      	ldr	r0, [pc, #124]	; (20000 <gpio_nrfx_pin_configure+0x14c>)
   1ff84:	f00c fad3 	bl	2c52e <assert_print>
   1ff88:	2168      	movs	r1, #104	; 0x68
   1ff8a:	4620      	mov	r0, r4
   1ff8c:	f00c fac8 	bl	2c520 <assert_post_action>
   1ff90:	e7e8      	b.n	1ff64 <gpio_nrfx_pin_configure+0xb0>
		err = nrfx_gpiote_channel_free(ch);
   1ff92:	f89d 0017 	ldrb.w	r0, [sp, #23]
   1ff96:	f003 fdbb 	bl	23b10 <nrfx_gpiote_channel_free>
		__ASSERT_NO_MSG(err == NRFX_SUCCESS);
   1ff9a:	4b17      	ldr	r3, [pc, #92]	; (1fff8 <gpio_nrfx_pin_configure+0x144>)
   1ff9c:	4298      	cmp	r0, r3
   1ff9e:	d0ac      	beq.n	1fefa <gpio_nrfx_pin_configure+0x46>
   1ffa0:	4f16      	ldr	r7, [pc, #88]	; (1fffc <gpio_nrfx_pin_configure+0x148>)
   1ffa2:	227a      	movs	r2, #122	; 0x7a
   1ffa4:	4639      	mov	r1, r7
   1ffa6:	4816      	ldr	r0, [pc, #88]	; (20000 <gpio_nrfx_pin_configure+0x14c>)
   1ffa8:	f00c fac1 	bl	2c52e <assert_print>
   1ffac:	217a      	movs	r1, #122	; 0x7a
   1ffae:	4638      	mov	r0, r7
   1ffb0:	f00c fab6 	bl	2c520 <assert_post_action>
   1ffb4:	e7a1      	b.n	1fefa <gpio_nrfx_pin_configure+0x46>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   1ffb6:	f414 2f80 	tst.w	r4, #262144	; 0x40000
   1ffba:	d0c2      	beq.n	1ff42 <gpio_nrfx_pin_configure+0x8e>
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   1ffbc:	f8d8 2004 	ldr.w	r2, [r8, #4]
   1ffc0:	2301      	movs	r3, #1
   1ffc2:	fa03 f606 	lsl.w	r6, r3, r6
    p_reg->OUTCLR = clr_mask;
   1ffc6:	f8c2 650c 	str.w	r6, [r2, #1292]	; 0x50c
}
   1ffca:	e7ba      	b.n	1ff42 <gpio_nrfx_pin_configure+0x8e>
		.pull = get_pull(flags)
   1ffcc:	4620      	mov	r0, r4
   1ffce:	f00f f9e2 	bl	2f396 <get_pull>
	nrfx_gpiote_input_config_t input_config = {
   1ffd2:	f88d 0008 	strb.w	r0, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1ffd6:	2300      	movs	r3, #0
   1ffd8:	461a      	mov	r2, r3
   1ffda:	a902      	add	r1, sp, #8
   1ffdc:	4628      	mov	r0, r5
   1ffde:	f003 fb65 	bl	236ac <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   1ffe2:	4b05      	ldr	r3, [pc, #20]	; (1fff8 <gpio_nrfx_pin_configure+0x144>)
   1ffe4:	4298      	cmp	r0, r3
   1ffe6:	d101      	bne.n	1ffec <gpio_nrfx_pin_configure+0x138>
   1ffe8:	2700      	movs	r7, #0
   1ffea:	e7bc      	b.n	1ff66 <gpio_nrfx_pin_configure+0xb2>
   1ffec:	f06f 0715 	mvn.w	r7, #21
   1fff0:	e7b9      	b.n	1ff66 <gpio_nrfx_pin_configure+0xb2>
		return -EINVAL;
   1fff2:	f06f 0715 	mvn.w	r7, #21
   1fff6:	e7b6      	b.n	1ff66 <gpio_nrfx_pin_configure+0xb2>
   1fff8:	0bad0000 	.word	0x0bad0000
   1fffc:	0003b0b8 	.word	0x0003b0b8
   20000:	00031600 	.word	0x00031600

00020004 <gpio_nrfx_init>:

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   20004:	b508      	push	{r3, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   20006:	f003 fd79 	bl	23afc <nrfx_gpiote_is_init>
   2000a:	b108      	cbz	r0, 20010 <gpio_nrfx_init+0xc>
		return 0;
   2000c:	2000      	movs	r0, #0

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   2000e:	bd08      	pop	{r3, pc}
	err = nrfx_gpiote_init(0/*not used*/);
   20010:	f003 fd4a 	bl	23aa8 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   20014:	4b08      	ldr	r3, [pc, #32]	; (20038 <gpio_nrfx_init+0x34>)
   20016:	4298      	cmp	r0, r3
   20018:	d10a      	bne.n	20030 <gpio_nrfx_init+0x2c>
	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   2001a:	2100      	movs	r1, #0
   2001c:	4807      	ldr	r0, [pc, #28]	; (2003c <gpio_nrfx_init+0x38>)
   2001e:	f003 fd13 	bl	23a48 <nrfx_gpiote_global_callback_set>
	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   20022:	2200      	movs	r2, #0
   20024:	2105      	movs	r1, #5
   20026:	2006      	movs	r0, #6
   20028:	f7f8 f966 	bl	182f8 <z_arm_irq_priority_set>
	return 0;
   2002c:	2000      	movs	r0, #0
   2002e:	e7ee      	b.n	2000e <gpio_nrfx_init+0xa>
		return -EIO;
   20030:	f06f 0004 	mvn.w	r0, #4
   20034:	e7eb      	b.n	2000e <gpio_nrfx_init+0xa>
   20036:	bf00      	nop
   20038:	0bad0000 	.word	0x0bad0000
   2003c:	0001fd2d 	.word	0x0001fd2d

00020040 <i2c_nrfx_twim_recover_bus>:

	return 0;
}

static int i2c_nrfx_twim_recover_bus(const struct device *dev)
{
   20040:	b570      	push	{r4, r5, r6, lr}
   20042:	b082      	sub	sp, #8
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   20044:	6845      	ldr	r5, [r0, #4]
	uint32_t scl_pin;
	uint32_t sda_pin;
	nrfx_err_t err;

#ifdef CONFIG_PINCTRL
	scl_pin = nrf_twim_scl_pin_get(dev_config->twim.p_twim);
   20046:	682b      	ldr	r3, [r5, #0]
    p_reg->PSEL.SDA = sda_pin;
}

NRF_STATIC_INLINE uint32_t nrf_twim_scl_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SCL;
   20048:	f8d3 4508 	ldr.w	r4, [r3, #1288]	; 0x508
}

NRF_STATIC_INLINE uint32_t nrf_twim_sda_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SDA;
   2004c:	f8d3 650c 	ldr.w	r6, [r3, #1292]	; 0x50c
	scl_pin = dev_config->twim_config.scl;
	sda_pin = dev_config->twim_config.sda;
#endif

	/* disable peripheral if active (required to release SCL/SDA lines) */
	(void)pm_device_state_get(dev, &state);
   20050:	f10d 0107 	add.w	r1, sp, #7
   20054:	f00c fa8a 	bl	2c56c <pm_device_state_get>
	if (state == PM_DEVICE_STATE_ACTIVE) {
   20058:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2005c:	b16b      	cbz	r3, 2007a <i2c_nrfx_twim_recover_bus+0x3a>
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
   2005e:	4631      	mov	r1, r6
   20060:	4620      	mov	r0, r4
   20062:	f005 fc51 	bl	25908 <nrfx_twi_twim_bus_recover>
   20066:	4604      	mov	r4, r0
	}

	err = nrfx_twim_bus_recover(scl_pin, sda_pin);

	/* restore peripheral if it was active before */
	if (state == PM_DEVICE_STATE_ACTIVE) {
   20068:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2006c:	b14b      	cbz	r3, 20082 <i2c_nrfx_twim_recover_bus+0x42>
		(void)pinctrl_apply_state(dev_config->pcfg,
					  PINCTRL_STATE_DEFAULT);
		nrfx_twim_enable(&dev_config->twim);
	}

	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
   2006e:	4b0f      	ldr	r3, [pc, #60]	; (200ac <i2c_nrfx_twim_recover_bus+0x6c>)
   20070:	429c      	cmp	r4, r3
   20072:	d118      	bne.n	200a6 <i2c_nrfx_twim_recover_bus+0x66>
   20074:	2000      	movs	r0, #0
}
   20076:	b002      	add	sp, #8
   20078:	bd70      	pop	{r4, r5, r6, pc}
		nrfx_twim_disable(&dev_config->twim);
   2007a:	4628      	mov	r0, r5
   2007c:	f005 fbaa 	bl	257d4 <nrfx_twim_disable>
   20080:	e7ed      	b.n	2005e <i2c_nrfx_twim_recover_bus+0x1e>
		(void)pinctrl_apply_state(dev_config->pcfg,
   20082:	6a2e      	ldr	r6, [r5, #32]
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
   20084:	466a      	mov	r2, sp
   20086:	2100      	movs	r1, #0
   20088:	4630      	mov	r0, r6
   2008a:	f00f fd5c 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2008e:	2800      	cmp	r0, #0
   20090:	db05      	blt.n	2009e <i2c_nrfx_twim_recover_bus+0x5e>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
   20092:	9b00      	ldr	r3, [sp, #0]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   20094:	6832      	ldr	r2, [r6, #0]
   20096:	7919      	ldrb	r1, [r3, #4]
   20098:	6818      	ldr	r0, [r3, #0]
   2009a:	f001 fd3f 	bl	21b1c <pinctrl_configure_pins>
		nrfx_twim_enable(&dev_config->twim);
   2009e:	4628      	mov	r0, r5
   200a0:	f005 fb6e 	bl	25780 <nrfx_twim_enable>
   200a4:	e7e3      	b.n	2006e <i2c_nrfx_twim_recover_bus+0x2e>
	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
   200a6:	f06f 000f 	mvn.w	r0, #15
   200aa:	e7e4      	b.n	20076 <i2c_nrfx_twim_recover_bus+0x36>
   200ac:	0bad0000 	.word	0x0bad0000

000200b0 <i2c_nrfx_twim_configure>:
{
   200b0:	b508      	push	{r3, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   200b2:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & i2c_config) {
   200b4:	f011 0f01 	tst.w	r1, #1
   200b8:	d11a      	bne.n	200f0 <i2c_nrfx_twim_configure+0x40>
	switch (I2C_SPEED_GET(i2c_config)) {
   200ba:	f3c1 0142 	ubfx	r1, r1, #1, #3
   200be:	2901      	cmp	r1, #1
   200c0:	d008      	beq.n	200d4 <i2c_nrfx_twim_configure+0x24>
   200c2:	2902      	cmp	r1, #2
   200c4:	d00d      	beq.n	200e2 <i2c_nrfx_twim_configure+0x32>
		LOG_ERR("unsupported speed");
   200c6:	2145      	movs	r1, #69	; 0x45
   200c8:	480b      	ldr	r0, [pc, #44]	; (200f8 <i2c_nrfx_twim_configure+0x48>)
   200ca:	f00c fa3f 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   200ce:	f06f 0015 	mvn.w	r0, #21
   200d2:	e005      	b.n	200e0 <i2c_nrfx_twim_configure+0x30>
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   200d4:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   200d6:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
   200da:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	return 0;
   200de:	2000      	movs	r0, #0
}
   200e0:	bd08      	pop	{r3, pc}
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   200e2:	681b      	ldr	r3, [r3, #0]
   200e4:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
   200e8:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	return 0;
   200ec:	2000      	movs	r0, #0
}
   200ee:	e7f7      	b.n	200e0 <i2c_nrfx_twim_configure+0x30>
		return -EINVAL;
   200f0:	f06f 0015 	mvn.w	r0, #21
   200f4:	e7f4      	b.n	200e0 <i2c_nrfx_twim_configure+0x30>
   200f6:	bf00      	nop
   200f8:	0003b12c 	.word	0x0003b12c

000200fc <i2c_nrfx_twim_transfer>:
{
   200fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20100:	b091      	sub	sp, #68	; 0x44
   20102:	9009      	str	r0, [sp, #36]	; 0x24
   20104:	4688      	mov	r8, r1
   20106:	4691      	mov	r9, r2
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   20108:	6901      	ldr	r1, [r0, #16]
   2010a:	460c      	mov	r4, r1
   2010c:	9107      	str	r1, [sp, #28]
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   2010e:	6840      	ldr	r0, [r0, #4]
   20110:	9006      	str	r0, [sp, #24]
	uint8_t *msg_buf = dev_data->msg_buf;
   20112:	f8d1 a034 	ldr.w	sl, [r1, #52]	; 0x34
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   20116:	8b02      	ldrh	r2, [r0, #24]
   20118:	9205      	str	r2, [sp, #20]
	nrfx_twim_xfer_desc_t cur_xfer = {
   2011a:	2500      	movs	r5, #0
   2011c:	950b      	str	r5, [sp, #44]	; 0x2c
   2011e:	950c      	str	r5, [sp, #48]	; 0x30
   20120:	950d      	str	r5, [sp, #52]	; 0x34
   20122:	950e      	str	r5, [sp, #56]	; 0x38
   20124:	950f      	str	r5, [sp, #60]	; 0x3c
   20126:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
	return z_impl_k_sem_take(sem, timeout);
   2012a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2012e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20132:	4608      	mov	r0, r1
   20134:	f006 ff6e 	bl	27014 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
   20138:	f104 0318 	add.w	r3, r4, #24
   2013c:	4618      	mov	r0, r3
   2013e:	9308      	str	r3, [sp, #32]
   20140:	2200      	movs	r2, #0
   20142:	2300      	movs	r3, #0
   20144:	f006 ff66 	bl	27014 <z_impl_k_sem_take>
	for (size_t i = 0; i < num_msgs; i++) {
   20148:	462e      	mov	r6, r5
	uint16_t msg_buf_used = 0;
   2014a:	462c      	mov	r4, r5
	int ret = 0;
   2014c:	9504      	str	r5, [sp, #16]
	for (size_t i = 0; i < num_msgs; i++) {
   2014e:	e047      	b.n	201e0 <i2c_nrfx_twim_transfer+0xe4>
				&& ((msgs[i].flags & I2C_MSG_READ)
   20150:	2200      	movs	r2, #0
		if (concat_next || (msg_buf_used != 0)) {
   20152:	9203      	str	r2, [sp, #12]
   20154:	b90a      	cbnz	r2, 2015a <i2c_nrfx_twim_transfer+0x5e>
   20156:	2c00      	cmp	r4, #0
   20158:	d077      	beq.n	2024a <i2c_nrfx_twim_transfer+0x14e>
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
   2015a:	686a      	ldr	r2, [r5, #4]
   2015c:	18a1      	adds	r1, r4, r2
   2015e:	9805      	ldr	r0, [sp, #20]
   20160:	4281      	cmp	r1, r0
   20162:	d864      	bhi.n	2022e <i2c_nrfx_twim_transfer+0x132>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
   20164:	f013 0f01 	tst.w	r3, #1
   20168:	d105      	bne.n	20176 <i2c_nrfx_twim_transfer+0x7a>
   2016a:	f858 100b 	ldr.w	r1, [r8, fp]
   2016e:	eb04 000a 	add.w	r0, r4, sl
   20172:	f010 fe78 	bl	30e66 <memcpy>
			msg_buf_used += msgs[i].len;
   20176:	686b      	ldr	r3, [r5, #4]
   20178:	441c      	add	r4, r3
   2017a:	b2a4      	uxth	r4, r4
		if (concat_next) {
   2017c:	9b03      	ldr	r3, [sp, #12]
   2017e:	2b00      	cmp	r3, #0
   20180:	d12d      	bne.n	201de <i2c_nrfx_twim_transfer+0xe2>
		if (msg_buf_used == 0) {
   20182:	2c00      	cmp	r4, #0
   20184:	d17f      	bne.n	20286 <i2c_nrfx_twim_transfer+0x18a>
			cur_xfer.p_primary_buf = msgs[i].buf;
   20186:	f858 300b 	ldr.w	r3, [r8, fp]
   2018a:	930e      	str	r3, [sp, #56]	; 0x38
			cur_xfer.primary_length = msgs[i].len;
   2018c:	686b      	ldr	r3, [r5, #4]
   2018e:	930c      	str	r3, [sp, #48]	; 0x30
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   20190:	7a2b      	ldrb	r3, [r5, #8]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
   20192:	f003 0201 	and.w	r2, r3, #1
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   20196:	f88d 202c 	strb.w	r2, [sp, #44]	; 0x2c
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   2019a:	f013 0f02 	tst.w	r3, #2
   2019e:	d076      	beq.n	2028e <i2c_nrfx_twim_transfer+0x192>
   201a0:	2200      	movs	r2, #0
   201a2:	a90b      	add	r1, sp, #44	; 0x2c
   201a4:	9806      	ldr	r0, [sp, #24]
   201a6:	f005 fb4d 	bl	25844 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   201aa:	4b58      	ldr	r3, [pc, #352]	; (2030c <i2c_nrfx_twim_transfer+0x210>)
   201ac:	4298      	cmp	r0, r3
   201ae:	d170      	bne.n	20292 <i2c_nrfx_twim_transfer+0x196>
   201b0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   201b4:	2300      	movs	r3, #0
   201b6:	9808      	ldr	r0, [sp, #32]
   201b8:	f006 ff2c 	bl	27014 <z_impl_k_sem_take>
		if (ret != 0) {
   201bc:	9004      	str	r0, [sp, #16]
   201be:	2800      	cmp	r0, #0
   201c0:	d172      	bne.n	202a8 <i2c_nrfx_twim_transfer+0x1ac>
		res = dev_data->res;
   201c2:	9b07      	ldr	r3, [sp, #28]
   201c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   201c6:	4b51      	ldr	r3, [pc, #324]	; (2030c <i2c_nrfx_twim_transfer+0x210>)
   201c8:	429a      	cmp	r2, r3
   201ca:	d179      	bne.n	202c0 <i2c_nrfx_twim_transfer+0x1c4>
		if ((msgs[i].flags & I2C_MSG_READ)
   201cc:	7a2b      	ldrb	r3, [r5, #8]
   201ce:	f013 0f01 	tst.w	r3, #1
   201d2:	d003      	beq.n	201dc <i2c_nrfx_twim_transfer+0xe0>
		    && cur_xfer.p_primary_buf == msg_buf) {
   201d4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   201d6:	459a      	cmp	sl, r3
   201d8:	f000 8084 	beq.w	202e4 <i2c_nrfx_twim_transfer+0x1e8>
		msg_buf_used = 0;
   201dc:	2400      	movs	r4, #0
   201de:	463e      	mov	r6, r7
	for (size_t i = 0; i < num_msgs; i++) {
   201e0:	454e      	cmp	r6, r9
   201e2:	f080 808b 	bcs.w	202fc <i2c_nrfx_twim_transfer+0x200>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   201e6:	eb06 0546 	add.w	r5, r6, r6, lsl #1
   201ea:	ea4f 0b85 	mov.w	fp, r5, lsl #2
   201ee:	eb08 0585 	add.w	r5, r8, r5, lsl #2
   201f2:	7a2b      	ldrb	r3, [r5, #8]
   201f4:	f013 0f08 	tst.w	r3, #8
   201f8:	d17d      	bne.n	202f6 <i2c_nrfx_twim_transfer+0x1fa>
		bool concat_next = ((i + 1) < num_msgs)
   201fa:	1c77      	adds	r7, r6, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
   201fc:	454f      	cmp	r7, r9
   201fe:	d2a7      	bcs.n	20150 <i2c_nrfx_twim_transfer+0x54>
				&& !(msgs[i].flags & I2C_MSG_STOP)
   20200:	f013 0f02 	tst.w	r3, #2
   20204:	d10d      	bne.n	20222 <i2c_nrfx_twim_transfer+0x126>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
   20206:	eb07 0247 	add.w	r2, r7, r7, lsl #1
   2020a:	eb08 0282 	add.w	r2, r8, r2, lsl #2
   2020e:	7a12      	ldrb	r2, [r2, #8]
   20210:	f012 0f04 	tst.w	r2, #4
   20214:	d107      	bne.n	20226 <i2c_nrfx_twim_transfer+0x12a>
				    == (msgs[i + 1].flags & I2C_MSG_READ));
   20216:	405a      	eors	r2, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
   20218:	f012 0f01 	tst.w	r2, #1
   2021c:	d005      	beq.n	2022a <i2c_nrfx_twim_transfer+0x12e>
   2021e:	2200      	movs	r2, #0
   20220:	e797      	b.n	20152 <i2c_nrfx_twim_transfer+0x56>
   20222:	2200      	movs	r2, #0
   20224:	e795      	b.n	20152 <i2c_nrfx_twim_transfer+0x56>
   20226:	2200      	movs	r2, #0
   20228:	e793      	b.n	20152 <i2c_nrfx_twim_transfer+0x56>
   2022a:	2201      	movs	r2, #1
   2022c:	e791      	b.n	20152 <i2c_nrfx_twim_transfer+0x56>
				LOG_ERR("Need to use concatenation buffer and "
   2022e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   20230:	681b      	ldr	r3, [r3, #0]
   20232:	9301      	str	r3, [sp, #4]
   20234:	9000      	str	r0, [sp, #0]
   20236:	4613      	mov	r3, r2
   20238:	4622      	mov	r2, r4
   2023a:	2145      	movs	r1, #69	; 0x45
   2023c:	4834      	ldr	r0, [pc, #208]	; (20310 <i2c_nrfx_twim_transfer+0x214>)
   2023e:	f00c f985 	bl	2c54c <z_log_minimal_printk>
				ret = -ENOSPC;
   20242:	f06f 031b 	mvn.w	r3, #27
   20246:	9304      	str	r3, [sp, #16]
				break;
   20248:	e058      	b.n	202fc <i2c_nrfx_twim_transfer+0x200>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   2024a:	f013 0f01 	tst.w	r3, #1
   2024e:	d195      	bne.n	2017c <i2c_nrfx_twim_transfer+0x80>
			   !nrfx_is_in_ram(msgs[i].buf)) {
   20250:	f858 100b 	ldr.w	r1, [r8, fp]

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   20254:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   20258:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2025c:	d08e      	beq.n	2017c <i2c_nrfx_twim_transfer+0x80>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
   2025e:	686a      	ldr	r2, [r5, #4]
   20260:	9b06      	ldr	r3, [sp, #24]
   20262:	8b5b      	ldrh	r3, [r3, #26]
   20264:	429a      	cmp	r2, r3
   20266:	d804      	bhi.n	20272 <i2c_nrfx_twim_transfer+0x176>
   20268:	4650      	mov	r0, sl
   2026a:	f010 fdfc 	bl	30e66 <memcpy>
			msg_buf_used = msgs[i].len;
   2026e:	88ac      	ldrh	r4, [r5, #4]
   20270:	e784      	b.n	2017c <i2c_nrfx_twim_transfer+0x80>
				LOG_ERR("Cannot copy flash buffer of size: %u. "
   20272:	9b09      	ldr	r3, [sp, #36]	; 0x24
   20274:	681b      	ldr	r3, [r3, #0]
   20276:	2145      	movs	r1, #69	; 0x45
   20278:	4826      	ldr	r0, [pc, #152]	; (20314 <i2c_nrfx_twim_transfer+0x218>)
   2027a:	f00c f967 	bl	2c54c <z_log_minimal_printk>
				ret = -EINVAL;
   2027e:	f06f 0315 	mvn.w	r3, #21
   20282:	9304      	str	r3, [sp, #16]
				break;
   20284:	e03a      	b.n	202fc <i2c_nrfx_twim_transfer+0x200>
			cur_xfer.p_primary_buf = msg_buf;
   20286:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
			cur_xfer.primary_length = msg_buf_used;
   2028a:	940c      	str	r4, [sp, #48]	; 0x30
   2028c:	e780      	b.n	20190 <i2c_nrfx_twim_transfer+0x94>
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   2028e:	2220      	movs	r2, #32
   20290:	e787      	b.n	201a2 <i2c_nrfx_twim_transfer+0xa6>
			if (res == NRFX_ERROR_BUSY) {
   20292:	330b      	adds	r3, #11
   20294:	4298      	cmp	r0, r3
   20296:	d003      	beq.n	202a0 <i2c_nrfx_twim_transfer+0x1a4>
				ret = -EIO;
   20298:	f06f 0304 	mvn.w	r3, #4
   2029c:	9304      	str	r3, [sp, #16]
   2029e:	e02d      	b.n	202fc <i2c_nrfx_twim_transfer+0x200>
				ret = -EBUSY;
   202a0:	f06f 030f 	mvn.w	r3, #15
   202a4:	9304      	str	r3, [sp, #16]
   202a6:	e029      	b.n	202fc <i2c_nrfx_twim_transfer+0x200>
			LOG_ERR("Error on I2C line occurred for message %d", i);
   202a8:	4632      	mov	r2, r6
   202aa:	2145      	movs	r1, #69	; 0x45
   202ac:	481a      	ldr	r0, [pc, #104]	; (20318 <i2c_nrfx_twim_transfer+0x21c>)
   202ae:	f00c f94d 	bl	2c54c <z_log_minimal_printk>
			(void)i2c_nrfx_twim_recover_bus(dev);
   202b2:	9809      	ldr	r0, [sp, #36]	; 0x24
   202b4:	f7ff fec4 	bl	20040 <i2c_nrfx_twim_recover_bus>
			ret = -EIO;
   202b8:	f06f 0304 	mvn.w	r3, #4
   202bc:	9304      	str	r3, [sp, #16]
			break;
   202be:	e01d      	b.n	202fc <i2c_nrfx_twim_transfer+0x200>
			LOG_ERR("Error 0x%08X occurred for message %d", res, i);
   202c0:	4633      	mov	r3, r6
   202c2:	2145      	movs	r1, #69	; 0x45
   202c4:	4815      	ldr	r0, [pc, #84]	; (2031c <i2c_nrfx_twim_transfer+0x220>)
   202c6:	f00c f941 	bl	2c54c <z_log_minimal_printk>
			ret = -EIO;
   202ca:	f06f 0304 	mvn.w	r3, #4
   202ce:	9304      	str	r3, [sp, #16]
			break;
   202d0:	e014      	b.n	202fc <i2c_nrfx_twim_transfer+0x200>
				msg_buf_used -= msgs[j].len;
   202d2:	1aa4      	subs	r4, r4, r2
   202d4:	b2a4      	uxth	r4, r4
   202d6:	eb0a 0104 	add.w	r1, sl, r4
   202da:	f858 0000 	ldr.w	r0, [r8, r0]
   202de:	f010 fdc2 	bl	30e66 <memcpy>
				j--;
   202e2:	3e01      	subs	r6, #1
			while (msg_buf_used >= msgs[j].len) {
   202e4:	eb06 0346 	add.w	r3, r6, r6, lsl #1
   202e8:	0098      	lsls	r0, r3, #2
   202ea:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   202ee:	685a      	ldr	r2, [r3, #4]
   202f0:	4294      	cmp	r4, r2
   202f2:	d2ee      	bcs.n	202d2 <i2c_nrfx_twim_transfer+0x1d6>
   202f4:	e772      	b.n	201dc <i2c_nrfx_twim_transfer+0xe0>
			ret = -ENOTSUP;
   202f6:	f06f 0385 	mvn.w	r3, #133	; 0x85
   202fa:	9304      	str	r3, [sp, #16]
	z_impl_k_sem_give(sem);
   202fc:	9807      	ldr	r0, [sp, #28]
   202fe:	f006 fe49 	bl	26f94 <z_impl_k_sem_give>
}
   20302:	9804      	ldr	r0, [sp, #16]
   20304:	b011      	add	sp, #68	; 0x44
   20306:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2030a:	bf00      	nop
   2030c:	0bad0000 	.word	0x0bad0000
   20310:	0003b144 	.word	0x0003b144
   20314:	0003b1dc 	.word	0x0003b1dc
   20318:	0003b248 	.word	0x0003b248
   2031c:	0003b278 	.word	0x0003b278

00020320 <event_handler>:
{
   20320:	b508      	push	{r3, lr}
	switch (p_event->type) {
   20322:	7803      	ldrb	r3, [r0, #0]
   20324:	2b01      	cmp	r3, #1
   20326:	d00c      	beq.n	20342 <event_handler+0x22>
   20328:	2b02      	cmp	r3, #2
   2032a:	d00d      	beq.n	20348 <event_handler+0x28>
   2032c:	b113      	cbz	r3, 20334 <event_handler+0x14>
		dev_data->res = NRFX_ERROR_INTERNAL;
   2032e:	4b08      	ldr	r3, [pc, #32]	; (20350 <event_handler+0x30>)
   20330:	630b      	str	r3, [r1, #48]	; 0x30
		break;
   20332:	e001      	b.n	20338 <event_handler+0x18>
		dev_data->res = NRFX_SUCCESS;
   20334:	4b07      	ldr	r3, [pc, #28]	; (20354 <event_handler+0x34>)
   20336:	630b      	str	r3, [r1, #48]	; 0x30
	k_sem_give(&dev_data->completion_sync);
   20338:	f101 0018 	add.w	r0, r1, #24
   2033c:	f006 fe2a 	bl	26f94 <z_impl_k_sem_give>
}
   20340:	bd08      	pop	{r3, pc}
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   20342:	4b05      	ldr	r3, [pc, #20]	; (20358 <event_handler+0x38>)
   20344:	630b      	str	r3, [r1, #48]	; 0x30
		break;
   20346:	e7f7      	b.n	20338 <event_handler+0x18>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   20348:	4b04      	ldr	r3, [pc, #16]	; (2035c <event_handler+0x3c>)
   2034a:	630b      	str	r3, [r1, #48]	; 0x30
		break;
   2034c:	e7f4      	b.n	20338 <event_handler+0x18>
   2034e:	bf00      	nop
   20350:	0bad0001 	.word	0x0bad0001
   20354:	0bad0000 	.word	0x0bad0000
   20358:	0bae0001 	.word	0x0bae0001
   2035c:	0bae0002 	.word	0x0bae0002

00020360 <i2c_nrfx_twim_init>:
	return ret;
}
#endif /* CONFIG_PM_DEVICE */

static int i2c_nrfx_twim_init(const struct device *dev)
{
   20360:	b5f0      	push	{r4, r5, r6, r7, lr}
   20362:	b083      	sub	sp, #12
   20364:	4604      	mov	r4, r0
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   20366:	6845      	ldr	r5, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   20368:	6907      	ldr	r7, [r0, #16]

	dev_config->irq_connect();
   2036a:	69eb      	ldr	r3, [r5, #28]
   2036c:	4798      	blx	r3

#ifdef CONFIG_PINCTRL
	int err = pinctrl_apply_state(dev_config->pcfg,
   2036e:	6a2e      	ldr	r6, [r5, #32]
	ret = pinctrl_lookup_state(config, id, &state);
   20370:	aa01      	add	r2, sp, #4
   20372:	2100      	movs	r1, #0
   20374:	4630      	mov	r0, r6
   20376:	f00f fbe6 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2037a:	2800      	cmp	r0, #0
   2037c:	db05      	blt.n	2038a <i2c_nrfx_twim_init+0x2a>
	return pinctrl_apply_state_direct(config, state);
   2037e:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   20380:	6832      	ldr	r2, [r6, #0]
   20382:	7919      	ldrb	r1, [r3, #4]
   20384:	6818      	ldr	r0, [r3, #0]
   20386:	f001 fbc9 	bl	21b1c <pinctrl_configure_pins>
				      COND_CODE_1(CONFIG_PM_DEVICE_RUNTIME,
						  (PINCTRL_STATE_SLEEP),
						  (PINCTRL_STATE_DEFAULT)));
	if (err < 0) {
   2038a:	2800      	cmp	r0, #0
   2038c:	db0d      	blt.n	203aa <i2c_nrfx_twim_init+0x4a>
		return err;
	}
#endif

	if (nrfx_twim_init(&dev_config->twim, &dev_config->twim_config,
   2038e:	463b      	mov	r3, r7
   20390:	4a0b      	ldr	r2, [pc, #44]	; (203c0 <i2c_nrfx_twim_init+0x60>)
   20392:	f105 0108 	add.w	r1, r5, #8
   20396:	4628      	mov	r0, r5
   20398:	f005 f990 	bl	256bc <nrfx_twim_init>
   2039c:	4b09      	ldr	r3, [pc, #36]	; (203c4 <i2c_nrfx_twim_init+0x64>)
   2039e:	4298      	cmp	r0, r3
   203a0:	d105      	bne.n	203ae <i2c_nrfx_twim_init+0x4e>

#ifdef CONFIG_PM_DEVICE_RUNTIME
	pm_device_init_suspended(dev);
	pm_device_runtime_enable(dev);
#else
	nrfx_twim_enable(&dev_config->twim);
   203a2:	4628      	mov	r0, r5
   203a4:	f005 f9ec 	bl	25780 <nrfx_twim_enable>
#endif

	return 0;
   203a8:	2000      	movs	r0, #0
}
   203aa:	b003      	add	sp, #12
   203ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("Failed to initialize device: %s", dev->name);
   203ae:	6822      	ldr	r2, [r4, #0]
   203b0:	2145      	movs	r1, #69	; 0x45
   203b2:	4805      	ldr	r0, [pc, #20]	; (203c8 <i2c_nrfx_twim_init+0x68>)
   203b4:	f00c f8ca 	bl	2c54c <z_log_minimal_printk>
		return -EIO;
   203b8:	f06f 0004 	mvn.w	r0, #4
   203bc:	e7f5      	b.n	203aa <i2c_nrfx_twim_init+0x4a>
   203be:	bf00      	nop
   203c0:	00020321 	.word	0x00020321
   203c4:	0bad0000 	.word	0x0bad0000
   203c8:	0003b2a4 	.word	0x0003b2a4

000203cc <pwm_nrfx_get_cycles_per_sec>:
{
	/* TODO: Since this function might be removed, we will always return
	 * 16MHz from this function and handle the conversion with prescaler,
	 * etc, in the pin set function. See issue #6958.
	 */
	*cycles = 16ul * 1000ul * 1000ul;
   203cc:	4802      	ldr	r0, [pc, #8]	; (203d8 <pwm_nrfx_get_cycles_per_sec+0xc>)
   203ce:	2100      	movs	r1, #0
   203d0:	e9c2 0100 	strd	r0, r1, [r2]

	return 0;
}
   203d4:	2000      	movs	r0, #0
   203d6:	4770      	bx	lr
   203d8:	00f42400 	.word	0x00f42400

000203dc <channel_psel_get>:
{
   203dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   203de:	460d      	mov	r5, r1
	*psel = nrf_pwm_pin_get(config->pwm.p_registers, (uint8_t)channel);
   203e0:	6816      	ldr	r6, [r2, #0]
   203e2:	b2c4      	uxtb	r4, r0
    }
}

NRF_STATIC_INLINE uint32_t nrf_pwm_pin_get(NRF_PWM_Type const * p_reg, uint8_t channel)
{
    NRFX_ASSERT(channel < NRF_PWM_CHANNEL_COUNT);
   203e4:	2c03      	cmp	r4, #3
   203e6:	d807      	bhi.n	203f8 <channel_psel_get+0x1c>
    return p_reg->PSEL.OUT[channel];
   203e8:	f504 74ac 	add.w	r4, r4, #344	; 0x158
   203ec:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   203f0:	6028      	str	r0, [r5, #0]
}
   203f2:	43c0      	mvns	r0, r0
   203f4:	0fc0      	lsrs	r0, r0, #31
   203f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    NRFX_ASSERT(channel < NRF_PWM_CHANNEL_COUNT);
   203f8:	4f06      	ldr	r7, [pc, #24]	; (20414 <channel_psel_get+0x38>)
   203fa:	f240 2293 	movw	r2, #659	; 0x293
   203fe:	4639      	mov	r1, r7
   20400:	4805      	ldr	r0, [pc, #20]	; (20418 <channel_psel_get+0x3c>)
   20402:	f00c f894 	bl	2c52e <assert_print>
   20406:	f240 2193 	movw	r1, #659	; 0x293
   2040a:	4638      	mov	r0, r7
   2040c:	f00c f888 	bl	2c520 <assert_post_action>
   20410:	e7ea      	b.n	203e8 <channel_psel_get+0xc>
   20412:	bf00      	nop
   20414:	0003b354 	.word	0x0003b354
   20418:	00031600 	.word	0x00031600

0002041c <pwm_period_check_and_set>:
{
   2041c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct pwm_nrfx_config *config = dev->config;
   20420:	6845      	ldr	r5, [r0, #4]
	struct pwm_nrfx_data *data = dev->data;
   20422:	6900      	ldr	r0, [r0, #16]
	if (period_cycles == data->period_cycles) {
   20424:	6803      	ldr	r3, [r0, #0]
   20426:	4293      	cmp	r3, r2
   20428:	d03b      	beq.n	204a2 <pwm_period_check_and_set+0x86>
	if ((data->pwm_needed & ~BIT(channel)) != 0) {
   2042a:	7b04      	ldrb	r4, [r0, #12]
   2042c:	2301      	movs	r3, #1
   2042e:	fa03 f101 	lsl.w	r1, r3, r1
   20432:	ea34 0301 	bics.w	r3, r4, r1
   20436:	d110      	bne.n	2045a <pwm_period_check_and_set+0x3e>
	countertop = period_cycles;
   20438:	4613      	mov	r3, r2
	prescaler = 0;
   2043a:	2400      	movs	r4, #0
		if (countertop <= PWM_COUNTERTOP_COUNTERTOP_Msk) {
   2043c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   20440:	d311      	bcc.n	20466 <pwm_period_check_and_set+0x4a>
		countertop >>= 1;
   20442:	085b      	lsrs	r3, r3, #1
		++prescaler;
   20444:	3401      	adds	r4, #1
   20446:	b2e4      	uxtb	r4, r4
	} while (prescaler <= PWM_PRESCALER_PRESCALER_Msk);
   20448:	2c07      	cmp	r4, #7
   2044a:	d9f7      	bls.n	2043c <pwm_period_check_and_set+0x20>
	LOG_ERR("Prescaler for period_cycles %u not found.", period_cycles);
   2044c:	2145      	movs	r1, #69	; 0x45
   2044e:	4816      	ldr	r0, [pc, #88]	; (204a8 <pwm_period_check_and_set+0x8c>)
   20450:	f00c f87c 	bl	2c54c <z_log_minimal_printk>
	return false;
   20454:	2000      	movs	r0, #0
}
   20456:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LOG_ERR("Incompatible period.");
   2045a:	2145      	movs	r1, #69	; 0x45
   2045c:	4813      	ldr	r0, [pc, #76]	; (204ac <pwm_period_check_and_set+0x90>)
   2045e:	f00c f875 	bl	2c54c <z_log_minimal_printk>
		return false;
   20462:	2000      	movs	r0, #0
   20464:	e7f7      	b.n	20456 <pwm_period_check_and_set+0x3a>
			data->period_cycles = period_cycles;
   20466:	6002      	str	r2, [r0, #0]
			data->prescaler     = prescaler;
   20468:	7344      	strb	r4, [r0, #13]
			nrf_pwm_configure(config->pwm.p_registers,
   2046a:	682e      	ldr	r6, [r5, #0]
   2046c:	7baf      	ldrb	r7, [r5, #14]
   2046e:	b29d      	uxth	r5, r3
NRF_STATIC_INLINE void nrf_pwm_configure(NRF_PWM_Type * p_reg,
                                         nrf_pwm_clk_t  base_clock,
                                         nrf_pwm_mode_t mode,
                                         uint16_t       top_value)
{
    NRFX_ASSERT(top_value <= PWM_COUNTERTOP_COUNTERTOP_Msk);
   20470:	f413 4f00 	tst.w	r3, #32768	; 0x8000
   20474:	d107      	bne.n	20486 <pwm_period_check_and_set+0x6a>

    p_reg->PRESCALER  = base_clock;
   20476:	f8c6 450c 	str.w	r4, [r6, #1292]	; 0x50c
    p_reg->MODE       = mode;
   2047a:	f8c6 7504 	str.w	r7, [r6, #1284]	; 0x504
    p_reg->COUNTERTOP = top_value;
   2047e:	f8c6 5508 	str.w	r5, [r6, #1288]	; 0x508
			return true;
   20482:	2001      	movs	r0, #1
}
   20484:	e7e7      	b.n	20456 <pwm_period_check_and_set+0x3a>
    NRFX_ASSERT(top_value <= PWM_COUNTERTOP_COUNTERTOP_Msk);
   20486:	f8df 802c 	ldr.w	r8, [pc, #44]	; 204b4 <pwm_period_check_and_set+0x98>
   2048a:	f44f 7227 	mov.w	r2, #668	; 0x29c
   2048e:	4641      	mov	r1, r8
   20490:	4807      	ldr	r0, [pc, #28]	; (204b0 <pwm_period_check_and_set+0x94>)
   20492:	f00c f84c 	bl	2c52e <assert_print>
   20496:	f44f 7127 	mov.w	r1, #668	; 0x29c
   2049a:	4640      	mov	r0, r8
   2049c:	f00c f840 	bl	2c520 <assert_post_action>
   204a0:	e7e9      	b.n	20476 <pwm_period_check_and_set+0x5a>
		return true;
   204a2:	2001      	movs	r0, #1
   204a4:	e7d7      	b.n	20456 <pwm_period_check_and_set+0x3a>
   204a6:	bf00      	nop
   204a8:	0003b3a4 	.word	0x0003b3a4
   204ac:	0003b388 	.word	0x0003b388
   204b0:	00031600 	.word	0x00031600
   204b4:	0003b354 	.word	0x0003b354

000204b8 <pwm_nrfx_init>:
	.set_cycles = pwm_nrfx_set_cycles,
	.get_cycles_per_sec = pwm_nrfx_get_cycles_per_sec,
};

static int pwm_nrfx_init(const struct device *dev)
{
   204b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   204bc:	b083      	sub	sp, #12
   204be:	4607      	mov	r7, r0
	const struct pwm_nrfx_config *config = dev->config;
   204c0:	6846      	ldr	r6, [r0, #4]
	struct pwm_nrfx_data *data = dev->data;
   204c2:	6905      	ldr	r5, [r0, #16]

#ifdef CONFIG_PINCTRL
	int ret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
   204c4:	6ab4      	ldr	r4, [r6, #40]	; 0x28
	ret = pinctrl_lookup_state(config, id, &state);
   204c6:	aa01      	add	r2, sp, #4
   204c8:	2100      	movs	r1, #0
   204ca:	4620      	mov	r0, r4
   204cc:	f00f fb3b 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   204d0:	2800      	cmp	r0, #0
   204d2:	db05      	blt.n	204e0 <pwm_nrfx_init+0x28>
	return pinctrl_apply_state_direct(config, state);
   204d4:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   204d6:	6822      	ldr	r2, [r4, #0]
   204d8:	7919      	ldrb	r1, [r3, #4]
   204da:	6818      	ldr	r0, [r3, #0]
   204dc:	f001 fb1e 	bl	21b1c <pinctrl_configure_pins>

	if (ret < 0) {
   204e0:	2800      	cmp	r0, #0
   204e2:	db67      	blt.n	205b4 <pwm_nrfx_init+0xfc>
		return ret;
	}

	data->initially_inverted = 0;
   204e4:	2400      	movs	r4, #0
   204e6:	73ac      	strb	r4, [r5, #14]
	for (size_t i = 0; i < ARRAY_SIZE(data->seq_values); i++) {
   204e8:	e022      	b.n	20530 <pwm_nrfx_init+0x78>
            mask = P0_FEATURE_PINS_PRESENT;
   204ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   204ee:	e02e      	b.n	2054e <pwm_nrfx_init+0x96>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   204f0:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 205d8 <pwm_nrfx_init+0x120>
   204f4:	f240 2247 	movw	r2, #583	; 0x247
   204f8:	4649      	mov	r1, r9
   204fa:	4834      	ldr	r0, [pc, #208]	; (205cc <pwm_nrfx_init+0x114>)
   204fc:	f00c f817 	bl	2c52e <assert_print>
   20500:	f240 2147 	movw	r1, #583	; 0x247
   20504:	4648      	mov	r0, r9
   20506:	f00c f80b 	bl	2c520 <assert_post_action>
   2050a:	e026      	b.n	2055a <pwm_nrfx_init+0xa2>
            NRFX_ASSERT(0);
   2050c:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 205d8 <pwm_nrfx_init+0x120>
   20510:	f44f 7213 	mov.w	r2, #588	; 0x24c
   20514:	4641      	mov	r1, r8
   20516:	482d      	ldr	r0, [pc, #180]	; (205cc <pwm_nrfx_init+0x114>)
   20518:	f00c f809 	bl	2c52e <assert_print>
   2051c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   20520:	4640      	mov	r0, r8
   20522:	f00b fffd 	bl	2c520 <assert_post_action>
   20526:	e01d      	b.n	20564 <pwm_nrfx_init+0xac>
		if (channel_psel_get(i, &psel, config)) {
			/* Mark channels as inverted according to what initial
			 * state of their outputs has been set by pinctrl (high
			 * idle state means that the channel is inverted).
			 */
			data->initially_inverted |=
   20528:	7baa      	ldrb	r2, [r5, #14]
   2052a:	4313      	orrs	r3, r2
   2052c:	73ab      	strb	r3, [r5, #14]
	for (size_t i = 0; i < ARRAY_SIZE(data->seq_values); i++) {
   2052e:	3401      	adds	r4, #1
   20530:	2c03      	cmp	r4, #3
   20532:	d823      	bhi.n	2057c <pwm_nrfx_init+0xc4>
		if (channel_psel_get(i, &psel, config)) {
   20534:	4632      	mov	r2, r6
   20536:	a901      	add	r1, sp, #4
   20538:	4620      	mov	r0, r4
   2053a:	f7ff ff4f 	bl	203dc <channel_psel_get>
   2053e:	2800      	cmp	r0, #0
   20540:	d0f5      	beq.n	2052e <pwm_nrfx_init+0x76>
				nrf_gpio_pin_out_read(psel) ? BIT(i) : 0;
   20542:	f8dd 8004 	ldr.w	r8, [sp, #4]
    switch (port)
   20546:	ea5f 1358 	movs.w	r3, r8, lsr #5
   2054a:	d0ce      	beq.n	204ea <pwm_nrfx_init+0x32>
    uint32_t mask = 0;
   2054c:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   2054e:	f008 021f 	and.w	r2, r8, #31
    return (mask & (1UL << pin_number)) ? true : false;
   20552:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   20554:	f013 0f01 	tst.w	r3, #1
   20558:	d0ca      	beq.n	204f0 <pwm_nrfx_init+0x38>
    *p_pin = pin_number & 0x1F;
   2055a:	f008 091f 	and.w	r9, r8, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2055e:	ea5f 1358 	movs.w	r3, r8, lsr #5
   20562:	d1d3      	bne.n	2050c <pwm_nrfx_init+0x54>
    return p_reg->OUT;
   20564:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   20568:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
    return ((nrf_gpio_port_out_read(reg) >> pin_number) & 1UL);
   2056c:	fa23 f309 	lsr.w	r3, r3, r9
   20570:	f013 0301 	ands.w	r3, r3, #1
   20574:	d0d8      	beq.n	20528 <pwm_nrfx_init+0x70>
   20576:	2301      	movs	r3, #1
   20578:	40a3      	lsls	r3, r4
   2057a:	e7d5      	b.n	20528 <pwm_nrfx_init+0x70>
		}
	}
#endif

	for (size_t i = 0; i < ARRAY_SIZE(data->seq_values); i++) {
   2057c:	2300      	movs	r3, #0
   2057e:	e005      	b.n	2058c <pwm_nrfx_init+0xd4>
		bool inverted = data->initially_inverted & BIT(i);

		data->seq_values[i] = PWM_NRFX_CH_VALUE(0, inverted);
   20580:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   20584:	eb05 0243 	add.w	r2, r5, r3, lsl #1
   20588:	8091      	strh	r1, [r2, #4]
	for (size_t i = 0; i < ARRAY_SIZE(data->seq_values); i++) {
   2058a:	3301      	adds	r3, #1
   2058c:	2b03      	cmp	r3, #3
   2058e:	d806      	bhi.n	2059e <pwm_nrfx_init+0xe6>
		bool inverted = data->initially_inverted & BIT(i);
   20590:	7ba9      	ldrb	r1, [r5, #14]
   20592:	2201      	movs	r2, #1
   20594:	409a      	lsls	r2, r3
		data->seq_values[i] = PWM_NRFX_CH_VALUE(0, inverted);
   20596:	4211      	tst	r1, r2
   20598:	d0f2      	beq.n	20580 <pwm_nrfx_init+0xc8>
   2059a:	2100      	movs	r1, #0
   2059c:	e7f2      	b.n	20584 <pwm_nrfx_init+0xcc>
	}

	nrfx_err_t result = nrfx_pwm_init(&config->pwm,
   2059e:	2300      	movs	r3, #0
   205a0:	461a      	mov	r2, r3
   205a2:	f106 0108 	add.w	r1, r6, #8
   205a6:	4630      	mov	r0, r6
   205a8:	f003 fdb6 	bl	24118 <nrfx_pwm_init>
					  &config->initial_config,
					  NULL,
					  NULL);
	if (result != NRFX_SUCCESS) {
   205ac:	4b08      	ldr	r3, [pc, #32]	; (205d0 <pwm_nrfx_init+0x118>)
   205ae:	4298      	cmp	r0, r3
   205b0:	d103      	bne.n	205ba <pwm_nrfx_init+0x102>
		LOG_ERR("Failed to initialize device: %s", dev->name);
		return -EBUSY;
	}

	return 0;
   205b2:	2000      	movs	r0, #0
}
   205b4:	b003      	add	sp, #12
   205b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LOG_ERR("Failed to initialize device: %s", dev->name);
   205ba:	683a      	ldr	r2, [r7, #0]
   205bc:	2145      	movs	r1, #69	; 0x45
   205be:	4805      	ldr	r0, [pc, #20]	; (205d4 <pwm_nrfx_init+0x11c>)
   205c0:	f00b ffc4 	bl	2c54c <z_log_minimal_printk>
		return -EBUSY;
   205c4:	f06f 000f 	mvn.w	r0, #15
   205c8:	e7f4      	b.n	205b4 <pwm_nrfx_init+0xfc>
   205ca:	bf00      	nop
   205cc:	00031600 	.word	0x00031600
   205d0:	0bad0000 	.word	0x0bad0000
   205d4:	0003b2a4 	.word	0x0003b2a4
   205d8:	0003b084 	.word	0x0003b084

000205dc <pwm_nrfx_set_cycles>:
{
   205dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   205e0:	b082      	sub	sp, #8
   205e2:	460d      	mov	r5, r1
	const struct pwm_nrfx_config *config = dev->config;
   205e4:	6844      	ldr	r4, [r0, #4]
	struct pwm_nrfx_data *data = dev->data;
   205e6:	6906      	ldr	r6, [r0, #16]
	bool inverted = (flags & PWM_POLARITY_INVERTED);
   205e8:	f8bd 8020 	ldrh.w	r8, [sp, #32]
	if (channel >= NRF_PWM_CHANNEL_COUNT) {
   205ec:	2903      	cmp	r1, #3
   205ee:	d80c      	bhi.n	2060a <pwm_nrfx_set_cycles+0x2e>
   205f0:	461f      	mov	r7, r3
   205f2:	f008 0801 	and.w	r8, r8, #1
	if (config->initial_config.count_mode == NRF_PWM_MODE_UP_AND_DOWN) {
   205f6:	7ba3      	ldrb	r3, [r4, #14]
   205f8:	2b01      	cmp	r3, #1
   205fa:	d00e      	beq.n	2061a <pwm_nrfx_set_cycles+0x3e>
	if (pulse_cycles == 0) {
   205fc:	b1e7      	cbz	r7, 20638 <pwm_nrfx_set_cycles+0x5c>
	} else if (pulse_cycles >= period_cycles) {
   205fe:	42ba      	cmp	r2, r7
   20600:	d80e      	bhi.n	20620 <pwm_nrfx_set_cycles+0x44>
	bool needs_pwm = false;
   20602:	2100      	movs	r1, #0
		compare_value = PWM_NRFX_CH_COMPARE_MASK;
   20604:	f647 72ff 	movw	r2, #32767	; 0x7fff
   20608:	e018      	b.n	2063c <pwm_nrfx_set_cycles+0x60>
		LOG_ERR("Invalid channel: %u.", channel);
   2060a:	460a      	mov	r2, r1
   2060c:	2145      	movs	r1, #69	; 0x45
   2060e:	4863      	ldr	r0, [pc, #396]	; (2079c <pwm_nrfx_set_cycles+0x1c0>)
   20610:	f00b ff9c 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   20614:	f06f 0015 	mvn.w	r0, #21
   20618:	e033      	b.n	20682 <pwm_nrfx_set_cycles+0xa6>
		period_cycles /= 2;
   2061a:	0852      	lsrs	r2, r2, #1
		pulse_cycles /= 2;
   2061c:	087f      	lsrs	r7, r7, #1
   2061e:	e7ed      	b.n	205fc <pwm_nrfx_set_cycles+0x20>
		if (!pwm_period_check_and_set(dev, channel, period_cycles)) {
   20620:	4629      	mov	r1, r5
   20622:	f7ff fefb 	bl	2041c <pwm_period_check_and_set>
   20626:	4601      	mov	r1, r0
   20628:	2800      	cmp	r0, #0
   2062a:	f000 80b3 	beq.w	20794 <pwm_nrfx_set_cycles+0x1b8>
		compare_value = (uint16_t)(pulse_cycles >> data->prescaler);
   2062e:	7b73      	ldrb	r3, [r6, #13]
   20630:	fa27 f303 	lsr.w	r3, r7, r3
   20634:	b29a      	uxth	r2, r3
		needs_pwm = true;
   20636:	e001      	b.n	2063c <pwm_nrfx_set_cycles+0x60>
	bool needs_pwm = false;
   20638:	2100      	movs	r1, #0
		compare_value = 0;
   2063a:	460a      	mov	r2, r1
	data->seq_values[channel] = PWM_NRFX_CH_VALUE(compare_value, inverted);
   2063c:	f1b8 0f00 	cmp.w	r8, #0
   20640:	d022      	beq.n	20688 <pwm_nrfx_set_cycles+0xac>
   20642:	2300      	movs	r3, #0
   20644:	4313      	orrs	r3, r2
   20646:	eb06 0245 	add.w	r2, r6, r5, lsl #1
   2064a:	8093      	strh	r3, [r2, #4]
	if (!needs_pwm) {
   2064c:	b1f9      	cbz	r1, 2068e <pwm_nrfx_set_cycles+0xb2>
		data->pwm_needed |= BIT(channel);
   2064e:	2101      	movs	r1, #1
   20650:	40a9      	lsls	r1, r5
   20652:	7b35      	ldrb	r5, [r6, #12]
   20654:	430d      	orrs	r5, r1
   20656:	7335      	strb	r5, [r6, #12]
	if (data->pwm_needed == 0) {
   20658:	7b33      	ldrb	r3, [r6, #12]
   2065a:	2b00      	cmp	r3, #0
   2065c:	f000 8092 	beq.w	20784 <pwm_nrfx_set_cycles+0x1a8>
		if (data->stop_requested) {
   20660:	7bf3      	ldrb	r3, [r6, #15]
   20662:	b133      	cbz	r3, 20672 <pwm_nrfx_set_cycles+0x96>
			data->stop_requested = false;
   20664:	2300      	movs	r3, #0
   20666:	73f3      	strb	r3, [r6, #15]
			while (!nrfx_pwm_is_stopped(&config->pwm)) {
   20668:	4620      	mov	r0, r4
   2066a:	f003 ff87 	bl	2457c <nrfx_pwm_is_stopped>
   2066e:	2800      	cmp	r0, #0
   20670:	d0fa      	beq.n	20668 <pwm_nrfx_set_cycles+0x8c>
		nrfx_pwm_simple_playback(&config->pwm, &config->seq, 1, 0);
   20672:	2300      	movs	r3, #0
   20674:	2201      	movs	r2, #1
   20676:	f104 0118 	add.w	r1, r4, #24
   2067a:	4620      	mov	r0, r4
   2067c:	f003 fe14 	bl	242a8 <nrfx_pwm_simple_playback>
	return 0;
   20680:	2000      	movs	r0, #0
}
   20682:	b002      	add	sp, #8
   20684:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->seq_values[channel] = PWM_NRFX_CH_VALUE(compare_value, inverted);
   20688:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   2068c:	e7da      	b.n	20644 <pwm_nrfx_set_cycles+0x68>
		if (channel_psel_get(channel, &psel, config)) {
   2068e:	4622      	mov	r2, r4
   20690:	a901      	add	r1, sp, #4
   20692:	4628      	mov	r0, r5
   20694:	f7ff fea2 	bl	203dc <channel_psel_get>
   20698:	b1f8      	cbz	r0, 206da <pwm_nrfx_set_cycles+0xfe>
			uint32_t out_level = (pulse_cycles == 0) ? 0 : 1;
   2069a:	1e3b      	subs	r3, r7, #0
   2069c:	bf18      	it	ne
   2069e:	2301      	movne	r3, #1
			if (inverted) {
   206a0:	f1b8 0f00 	cmp.w	r8, #0
   206a4:	d002      	beq.n	206ac <pwm_nrfx_set_cycles+0xd0>
				out_level ^= 1;
   206a6:	fab7 f387 	clz	r3, r7
   206aa:	095b      	lsrs	r3, r3, #5
			nrf_gpio_pin_write(psel, out_level);
   206ac:	9f01      	ldr	r7, [sp, #4]
    if (value == 0)
   206ae:	bbb3      	cbnz	r3, 2071e <pwm_nrfx_set_cycles+0x142>
    switch (port)
   206b0:	097a      	lsrs	r2, r7, #5
   206b2:	d101      	bne.n	206b8 <pwm_nrfx_set_cycles+0xdc>
            mask = P0_FEATURE_PINS_PRESENT;
   206b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   206b8:	f007 021f 	and.w	r2, r7, #31
    return (mask & (1UL << pin_number)) ? true : false;
   206bc:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   206be:	f013 0f01 	tst.w	r3, #1
   206c2:	d011      	beq.n	206e8 <pwm_nrfx_set_cycles+0x10c>
    *p_pin = pin_number & 0x1F;
   206c4:	f007 081f 	and.w	r8, r7, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   206c8:	097b      	lsrs	r3, r7, #5
   206ca:	d11b      	bne.n	20704 <pwm_nrfx_set_cycles+0x128>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   206cc:	2301      	movs	r3, #1
   206ce:	fa03 f308 	lsl.w	r3, r3, r8
    p_reg->OUTCLR = clr_mask;
   206d2:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   206d6:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
		data->pwm_needed &= ~BIT(channel);
   206da:	2101      	movs	r1, #1
   206dc:	40a9      	lsls	r1, r5
   206de:	7b35      	ldrb	r5, [r6, #12]
   206e0:	ea25 0501 	bic.w	r5, r5, r1
   206e4:	7335      	strb	r5, [r6, #12]
   206e6:	e7b7      	b.n	20658 <pwm_nrfx_set_cycles+0x7c>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   206e8:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 207a4 <pwm_nrfx_set_cycles+0x1c8>
   206ec:	f240 2247 	movw	r2, #583	; 0x247
   206f0:	4641      	mov	r1, r8
   206f2:	482b      	ldr	r0, [pc, #172]	; (207a0 <pwm_nrfx_set_cycles+0x1c4>)
   206f4:	f00b ff1b 	bl	2c52e <assert_print>
   206f8:	f240 2147 	movw	r1, #583	; 0x247
   206fc:	4640      	mov	r0, r8
   206fe:	f00b ff0f 	bl	2c520 <assert_post_action>
   20702:	e7df      	b.n	206c4 <pwm_nrfx_set_cycles+0xe8>
            NRFX_ASSERT(0);
   20704:	4f27      	ldr	r7, [pc, #156]	; (207a4 <pwm_nrfx_set_cycles+0x1c8>)
   20706:	f44f 7213 	mov.w	r2, #588	; 0x24c
   2070a:	4639      	mov	r1, r7
   2070c:	4824      	ldr	r0, [pc, #144]	; (207a0 <pwm_nrfx_set_cycles+0x1c4>)
   2070e:	f00b ff0e 	bl	2c52e <assert_print>
   20712:	f44f 7113 	mov.w	r1, #588	; 0x24c
   20716:	4638      	mov	r0, r7
   20718:	f00b ff02 	bl	2c520 <assert_post_action>
   2071c:	e7d6      	b.n	206cc <pwm_nrfx_set_cycles+0xf0>
    switch (port)
   2071e:	097b      	lsrs	r3, r7, #5
   20720:	d012      	beq.n	20748 <pwm_nrfx_set_cycles+0x16c>
    uint32_t mask = 0;
   20722:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   20724:	f007 021f 	and.w	r2, r7, #31
    return (mask & (1UL << pin_number)) ? true : false;
   20728:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2072a:	f013 0f01 	tst.w	r3, #1
   2072e:	d00e      	beq.n	2074e <pwm_nrfx_set_cycles+0x172>
    *p_pin = pin_number & 0x1F;
   20730:	f007 081f 	and.w	r8, r7, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   20734:	097b      	lsrs	r3, r7, #5
   20736:	d118      	bne.n	2076a <pwm_nrfx_set_cycles+0x18e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   20738:	2301      	movs	r3, #1
   2073a:	fa03 f308 	lsl.w	r3, r3, r8
    p_reg->OUTSET = set_mask;
   2073e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   20742:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
}
   20746:	e7c8      	b.n	206da <pwm_nrfx_set_cycles+0xfe>
            mask = P0_FEATURE_PINS_PRESENT;
   20748:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2074c:	e7ea      	b.n	20724 <pwm_nrfx_set_cycles+0x148>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2074e:	f8df 8054 	ldr.w	r8, [pc, #84]	; 207a4 <pwm_nrfx_set_cycles+0x1c8>
   20752:	f240 2247 	movw	r2, #583	; 0x247
   20756:	4641      	mov	r1, r8
   20758:	4811      	ldr	r0, [pc, #68]	; (207a0 <pwm_nrfx_set_cycles+0x1c4>)
   2075a:	f00b fee8 	bl	2c52e <assert_print>
   2075e:	f240 2147 	movw	r1, #583	; 0x247
   20762:	4640      	mov	r0, r8
   20764:	f00b fedc 	bl	2c520 <assert_post_action>
   20768:	e7e2      	b.n	20730 <pwm_nrfx_set_cycles+0x154>
            NRFX_ASSERT(0);
   2076a:	4f0e      	ldr	r7, [pc, #56]	; (207a4 <pwm_nrfx_set_cycles+0x1c8>)
   2076c:	f44f 7213 	mov.w	r2, #588	; 0x24c
   20770:	4639      	mov	r1, r7
   20772:	480b      	ldr	r0, [pc, #44]	; (207a0 <pwm_nrfx_set_cycles+0x1c4>)
   20774:	f00b fedb 	bl	2c52e <assert_print>
   20778:	f44f 7113 	mov.w	r1, #588	; 0x24c
   2077c:	4638      	mov	r0, r7
   2077e:	f00b fecf 	bl	2c520 <assert_post_action>
   20782:	e7d9      	b.n	20738 <pwm_nrfx_set_cycles+0x15c>
		nrfx_pwm_stop(&config->pwm, false);
   20784:	2100      	movs	r1, #0
   20786:	4620      	mov	r0, r4
   20788:	f003 ff2e 	bl	245e8 <nrfx_pwm_stop>
		data->stop_requested = true;
   2078c:	2301      	movs	r3, #1
   2078e:	73f3      	strb	r3, [r6, #15]
	return 0;
   20790:	2000      	movs	r0, #0
   20792:	e776      	b.n	20682 <pwm_nrfx_set_cycles+0xa6>
			return -EINVAL;
   20794:	f06f 0015 	mvn.w	r0, #21
   20798:	e773      	b.n	20682 <pwm_nrfx_set_cycles+0xa6>
   2079a:	bf00      	nop
   2079c:	0003b3d4 	.word	0x0003b3d4
   207a0:	00031600 	.word	0x00031600
   207a4:	0003b084 	.word	0x0003b084

000207a8 <z_impl_gpio_pin_configure>:
{
   207a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   207ac:	4605      	mov	r5, r0
   207ae:	460e      	mov	r6, r1
   207b0:	4614      	mov	r4, r2
	const struct gpio_driver_api *api =
   207b2:	f8d0 a008 	ldr.w	sl, [r0, #8]
	__unused const struct gpio_driver_config *const cfg =
   207b6:	f8d0 b004 	ldr.w	fp, [r0, #4]
	struct gpio_driver_data *data =
   207ba:	f8d0 8010 	ldr.w	r8, [r0, #16]
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   207be:	f012 6ffc 	tst.w	r2, #132120576	; 0x7e00000
   207c2:	d135      	bne.n	20830 <z_impl_gpio_pin_configure+0x88>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   207c4:	f004 0330 	and.w	r3, r4, #48	; 0x30
   207c8:	2b30      	cmp	r3, #48	; 0x30
   207ca:	d03e      	beq.n	2084a <z_impl_gpio_pin_configure+0xa2>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   207cc:	f004 1302 	and.w	r3, r4, #131074	; 0x20002
   207d0:	2b02      	cmp	r3, #2
   207d2:	d047      	beq.n	20864 <z_impl_gpio_pin_configure+0xbc>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   207d4:	f004 0306 	and.w	r3, r4, #6
   207d8:	2b04      	cmp	r3, #4
   207da:	d050      	beq.n	2087e <z_impl_gpio_pin_configure+0xd6>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   207dc:	f414 2740 	ands.w	r7, r4, #786432	; 0xc0000
   207e0:	d002      	beq.n	207e8 <z_impl_gpio_pin_configure+0x40>
   207e2:	f414 3f00 	tst.w	r4, #131072	; 0x20000
   207e6:	d057      	beq.n	20898 <z_impl_gpio_pin_configure+0xf0>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   207e8:	f5b7 2f40 	cmp.w	r7, #786432	; 0xc0000
   207ec:	d062      	beq.n	208b4 <z_impl_gpio_pin_configure+0x10c>
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   207ee:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
   207f2:	d005      	beq.n	20800 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   207f4:	b127      	cbz	r7, 20800 <z_impl_gpio_pin_configure+0x58>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   207f6:	f014 0f01 	tst.w	r4, #1
   207fa:	d001      	beq.n	20800 <z_impl_gpio_pin_configure+0x58>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   207fc:	f484 2440 	eor.w	r4, r4, #786432	; 0xc0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   20800:	f424 1980 	bic.w	r9, r4, #1048576	; 0x100000
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20804:	f8db 3000 	ldr.w	r3, [fp]
   20808:	2701      	movs	r7, #1
   2080a:	40b7      	lsls	r7, r6
   2080c:	423b      	tst	r3, r7
   2080e:	d05f      	beq.n	208d0 <z_impl_gpio_pin_configure+0x128>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   20810:	f014 0f01 	tst.w	r4, #1
   20814:	d06a      	beq.n	208ec <z_impl_gpio_pin_configure+0x144>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   20816:	f8d8 3000 	ldr.w	r3, [r8]
   2081a:	433b      	orrs	r3, r7
   2081c:	f8c8 3000 	str.w	r3, [r8]
	return api->pin_configure(port, pin, flags);
   20820:	f8da 3000 	ldr.w	r3, [sl]
   20824:	464a      	mov	r2, r9
   20826:	4631      	mov	r1, r6
   20828:	4628      	mov	r0, r5
   2082a:	4798      	blx	r3
}
   2082c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT((flags & GPIO_INT_MASK) == 0,
   20830:	4f32      	ldr	r7, [pc, #200]	; (208fc <z_impl_gpio_pin_configure+0x154>)
   20832:	f44f 722f 	mov.w	r2, #700	; 0x2bc
   20836:	4639      	mov	r1, r7
   20838:	4831      	ldr	r0, [pc, #196]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   2083a:	f00b fe78 	bl	2c52e <assert_print>
   2083e:	f44f 712f 	mov.w	r1, #700	; 0x2bc
   20842:	4638      	mov	r0, r7
   20844:	f00b fe6c 	bl	2c520 <assert_post_action>
   20848:	e7bc      	b.n	207c4 <z_impl_gpio_pin_configure+0x1c>
	__ASSERT((flags & (GPIO_PULL_UP | GPIO_PULL_DOWN)) !=
   2084a:	4f2c      	ldr	r7, [pc, #176]	; (208fc <z_impl_gpio_pin_configure+0x154>)
   2084c:	f240 22bf 	movw	r2, #703	; 0x2bf
   20850:	4639      	mov	r1, r7
   20852:	482b      	ldr	r0, [pc, #172]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   20854:	f00b fe6b 	bl	2c52e <assert_print>
   20858:	f240 21bf 	movw	r1, #703	; 0x2bf
   2085c:	4638      	mov	r0, r7
   2085e:	f00b fe5f 	bl	2c520 <assert_post_action>
   20862:	e7b3      	b.n	207cc <z_impl_gpio_pin_configure+0x24>
	__ASSERT((flags & GPIO_OUTPUT) != 0 || (flags & GPIO_SINGLE_ENDED) == 0,
   20864:	4f25      	ldr	r7, [pc, #148]	; (208fc <z_impl_gpio_pin_configure+0x154>)
   20866:	f240 22c3 	movw	r2, #707	; 0x2c3
   2086a:	4639      	mov	r1, r7
   2086c:	4824      	ldr	r0, [pc, #144]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   2086e:	f00b fe5e 	bl	2c52e <assert_print>
   20872:	f240 21c3 	movw	r1, #707	; 0x2c3
   20876:	4638      	mov	r0, r7
   20878:	f00b fe52 	bl	2c520 <assert_post_action>
   2087c:	e7aa      	b.n	207d4 <z_impl_gpio_pin_configure+0x2c>
	__ASSERT_NO_MSG((flags & GPIO_SINGLE_ENDED) != 0 ||
   2087e:	4f1f      	ldr	r7, [pc, #124]	; (208fc <z_impl_gpio_pin_configure+0x154>)
   20880:	f240 22c7 	movw	r2, #711	; 0x2c7
   20884:	4639      	mov	r1, r7
   20886:	481e      	ldr	r0, [pc, #120]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   20888:	f00b fe51 	bl	2c52e <assert_print>
   2088c:	f240 21c7 	movw	r1, #711	; 0x2c7
   20890:	4638      	mov	r0, r7
   20892:	f00b fe45 	bl	2c520 <assert_post_action>
   20896:	e7a1      	b.n	207dc <z_impl_gpio_pin_configure+0x34>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) == 0
   20898:	f8df 9060 	ldr.w	r9, [pc, #96]	; 208fc <z_impl_gpio_pin_configure+0x154>
   2089c:	f240 22ca 	movw	r2, #714	; 0x2ca
   208a0:	4649      	mov	r1, r9
   208a2:	4817      	ldr	r0, [pc, #92]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   208a4:	f00b fe43 	bl	2c52e <assert_print>
   208a8:	f240 21ca 	movw	r1, #714	; 0x2ca
   208ac:	4648      	mov	r0, r9
   208ae:	f00b fe37 	bl	2c520 <assert_post_action>
   208b2:	e799      	b.n	207e8 <z_impl_gpio_pin_configure+0x40>
	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
   208b4:	f8df 9044 	ldr.w	r9, [pc, #68]	; 208fc <z_impl_gpio_pin_configure+0x154>
   208b8:	f240 22ce 	movw	r2, #718	; 0x2ce
   208bc:	4649      	mov	r1, r9
   208be:	4810      	ldr	r0, [pc, #64]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   208c0:	f00b fe35 	bl	2c52e <assert_print>
   208c4:	f240 21ce 	movw	r1, #718	; 0x2ce
   208c8:	4648      	mov	r0, r9
   208ca:	f00b fe29 	bl	2c520 <assert_post_action>
   208ce:	e78e      	b.n	207ee <z_impl_gpio_pin_configure+0x46>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   208d0:	f8df b028 	ldr.w	fp, [pc, #40]	; 208fc <z_impl_gpio_pin_configure+0x154>
   208d4:	f240 22da 	movw	r2, #730	; 0x2da
   208d8:	4659      	mov	r1, fp
   208da:	4809      	ldr	r0, [pc, #36]	; (20900 <z_impl_gpio_pin_configure+0x158>)
   208dc:	f00b fe27 	bl	2c52e <assert_print>
   208e0:	f240 21da 	movw	r1, #730	; 0x2da
   208e4:	4658      	mov	r0, fp
   208e6:	f00b fe1b 	bl	2c520 <assert_post_action>
   208ea:	e791      	b.n	20810 <z_impl_gpio_pin_configure+0x68>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   208ec:	f8d8 3000 	ldr.w	r3, [r8]
   208f0:	ea23 0307 	bic.w	r3, r3, r7
   208f4:	f8c8 3000 	str.w	r3, [r8]
   208f8:	e792      	b.n	20820 <z_impl_gpio_pin_configure+0x78>
   208fa:	bf00      	nop
   208fc:	000315cc 	.word	0x000315cc
   20900:	00031600 	.word	0x00031600

00020904 <configure>:
	}
}

static int configure(const struct device *dev,
		     const struct spi_config *spi_cfg)
{
   20904:	b5f0      	push	{r4, r5, r6, r7, lr}
   20906:	b087      	sub	sp, #28
   20908:	460c      	mov	r4, r1
	struct spi_nrfx_data *dev_data = dev->data;
   2090a:	6905      	ldr	r5, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
   2090c:	6846      	ldr	r6, [r0, #4]
	struct spi_context *ctx = &dev_data->ctx;
	nrfx_spi_config_t config;
	nrfx_err_t result;

	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
   2090e:	f895 706d 	ldrb.w	r7, [r5, #109]	; 0x6d
   20912:	b11f      	cbz	r7, 2091c <configure+0x18>
	._ctx_name.num_cs_gpios = DT_PROP_LEN_OR(_node_id, cs_gpios, 0),

static inline bool spi_context_configured(struct spi_context *ctx,
					  const struct spi_config *config)
{
	return !!(ctx->config == config);
   20914:	682b      	ldr	r3, [r5, #0]
   20916:	428b      	cmp	r3, r1
   20918:	f000 80a7 	beq.w	20a6a <configure+0x166>
		/* Already configured. No need to do it again. */
		return 0;
	}

	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
   2091c:	88a3      	ldrh	r3, [r4, #4]
   2091e:	f413 6f00 	tst.w	r3, #2048	; 0x800
   20922:	d152      	bne.n	209ca <configure+0xc6>
		LOG_ERR("Half-duplex not supported");
		return -ENOTSUP;
	}

	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   20924:	f013 0f01 	tst.w	r3, #1
   20928:	d156      	bne.n	209d8 <configure+0xd4>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
		return -EINVAL;
	}

	if (spi_cfg->operation & SPI_MODE_LOOP) {
   2092a:	f013 0f08 	tst.w	r3, #8
   2092e:	d15b      	bne.n	209e8 <configure+0xe4>
	    (spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
		LOG_ERR("Only single line mode is supported");
		return -EINVAL;
	}

	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   20930:	f3c3 1345 	ubfx	r3, r3, #5, #6
   20934:	2b08      	cmp	r3, #8
   20936:	d15e      	bne.n	209f6 <configure+0xf2>
		LOG_ERR("Word sizes other than 8 bits are not supported");
		return -EINVAL;
	}

	if (spi_cfg->frequency < 125000) {
   20938:	6822      	ldr	r2, [r4, #0]
   2093a:	4b4d      	ldr	r3, [pc, #308]	; (20a70 <configure+0x16c>)
   2093c:	429a      	cmp	r2, r3
   2093e:	d961      	bls.n	20a04 <configure+0x100>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
		return -EINVAL;
	}

	config = dev_config->def_config;
   20940:	f10d 0c04 	add.w	ip, sp, #4
   20944:	f106 0e08 	add.w	lr, r6, #8
   20948:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   2094c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   20950:	f8de 3000 	ldr.w	r3, [lr]
   20954:	f8cc 3000 	str.w	r3, [ip]

	config.frequency = get_nrf_spi_frequency(spi_cfg->frequency);
   20958:	6823      	ldr	r3, [r4, #0]
	if (frequency < 250000) {
   2095a:	4a46      	ldr	r2, [pc, #280]	; (20a74 <configure+0x170>)
   2095c:	4293      	cmp	r3, r2
   2095e:	d958      	bls.n	20a12 <configure+0x10e>
	} else if (frequency < 500000) {
   20960:	4a45      	ldr	r2, [pc, #276]	; (20a78 <configure+0x174>)
   20962:	4293      	cmp	r3, r2
   20964:	d958      	bls.n	20a18 <configure+0x114>
	} else if (frequency < 1000000) {
   20966:	4a45      	ldr	r2, [pc, #276]	; (20a7c <configure+0x178>)
   20968:	4293      	cmp	r3, r2
   2096a:	d958      	bls.n	20a1e <configure+0x11a>
	} else if (frequency < 2000000) {
   2096c:	4a44      	ldr	r2, [pc, #272]	; (20a80 <configure+0x17c>)
   2096e:	4293      	cmp	r3, r2
   20970:	d958      	bls.n	20a24 <configure+0x120>
	} else if (frequency < 4000000) {
   20972:	4a44      	ldr	r2, [pc, #272]	; (20a84 <configure+0x180>)
   20974:	4293      	cmp	r3, r2
   20976:	d958      	bls.n	20a2a <configure+0x126>
	} else if (frequency < 8000000) {
   20978:	4a43      	ldr	r2, [pc, #268]	; (20a88 <configure+0x184>)
   2097a:	4293      	cmp	r3, r2
   2097c:	d258      	bcs.n	20a30 <configure+0x12c>
		return NRF_SPI_FREQ_4M;
   2097e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	config.frequency = get_nrf_spi_frequency(spi_cfg->frequency);
   20982:	9303      	str	r3, [sp, #12]
	config.mode      = get_nrf_spi_mode(spi_cfg->operation);
   20984:	88a3      	ldrh	r3, [r4, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   20986:	f013 0f02 	tst.w	r3, #2
   2098a:	d054      	beq.n	20a36 <configure+0x132>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
   2098c:	f013 0f04 	tst.w	r3, #4
   20990:	d056      	beq.n	20a40 <configure+0x13c>
			return NRF_SPI_MODE_3;
   20992:	2303      	movs	r3, #3
	config.mode      = get_nrf_spi_mode(spi_cfg->operation);
   20994:	f88d 3010 	strb.w	r3, [sp, #16]
	config.bit_order = get_nrf_spi_bit_order(spi_cfg->operation);
   20998:	88a3      	ldrh	r3, [r4, #4]
	if (operation & SPI_TRANSFER_LSB) {
   2099a:	f013 0f10 	tst.w	r3, #16
   2099e:	d053      	beq.n	20a48 <configure+0x144>
		return NRF_SPI_BIT_ORDER_LSB_FIRST;
   209a0:	2301      	movs	r3, #1
	config.bit_order = get_nrf_spi_bit_order(spi_cfg->operation);
   209a2:	f88d 3011 	strb.w	r3, [sp, #17]

	if (dev_data->initialized) {
   209a6:	2f00      	cmp	r7, #0
   209a8:	d150      	bne.n	20a4c <configure+0x148>
		nrfx_spi_uninit(&dev_config->spi);
		dev_data->initialized = false;
	}

	result = nrfx_spi_init(&dev_config->spi, &config,
   209aa:	462b      	mov	r3, r5
   209ac:	4a37      	ldr	r2, [pc, #220]	; (20a8c <configure+0x188>)
   209ae:	a901      	add	r1, sp, #4
   209b0:	4630      	mov	r0, r6
   209b2:	f004 f8f3 	bl	24b9c <nrfx_spi_init>
			       event_handler, dev_data);
	if (result != NRFX_SUCCESS) {
   209b6:	4b36      	ldr	r3, [pc, #216]	; (20a90 <configure+0x18c>)
   209b8:	4298      	cmp	r0, r3
   209ba:	d14e      	bne.n	20a5a <configure+0x156>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
		return -EIO;
	}

	dev_data->initialized = true;
   209bc:	2301      	movs	r3, #1
   209be:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d

	ctx->config = spi_cfg;
   209c2:	602c      	str	r4, [r5, #0]

	return 0;
   209c4:	2000      	movs	r0, #0
}
   209c6:	b007      	add	sp, #28
   209c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("Half-duplex not supported");
   209ca:	2145      	movs	r1, #69	; 0x45
   209cc:	4831      	ldr	r0, [pc, #196]	; (20a94 <configure+0x190>)
   209ce:	f00b fdbd 	bl	2c54c <z_log_minimal_printk>
		return -ENOTSUP;
   209d2:	f06f 0085 	mvn.w	r0, #133	; 0x85
   209d6:	e7f6      	b.n	209c6 <configure+0xc2>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
   209d8:	6802      	ldr	r2, [r0, #0]
   209da:	2145      	movs	r1, #69	; 0x45
   209dc:	482e      	ldr	r0, [pc, #184]	; (20a98 <configure+0x194>)
   209de:	f00b fdb5 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   209e2:	f06f 0015 	mvn.w	r0, #21
   209e6:	e7ee      	b.n	209c6 <configure+0xc2>
		LOG_ERR("Loopback mode is not supported");
   209e8:	2145      	movs	r1, #69	; 0x45
   209ea:	482c      	ldr	r0, [pc, #176]	; (20a9c <configure+0x198>)
   209ec:	f00b fdae 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   209f0:	f06f 0015 	mvn.w	r0, #21
   209f4:	e7e7      	b.n	209c6 <configure+0xc2>
		LOG_ERR("Word sizes other than 8 bits are not supported");
   209f6:	2145      	movs	r1, #69	; 0x45
   209f8:	4829      	ldr	r0, [pc, #164]	; (20aa0 <configure+0x19c>)
   209fa:	f00b fda7 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   209fe:	f06f 0015 	mvn.w	r0, #21
   20a02:	e7e0      	b.n	209c6 <configure+0xc2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
   20a04:	2145      	movs	r1, #69	; 0x45
   20a06:	4827      	ldr	r0, [pc, #156]	; (20aa4 <configure+0x1a0>)
   20a08:	f00b fda0 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   20a0c:	f06f 0015 	mvn.w	r0, #21
   20a10:	e7d9      	b.n	209c6 <configure+0xc2>
		return NRF_SPI_FREQ_125K;
   20a12:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   20a16:	e7b4      	b.n	20982 <configure+0x7e>
		return NRF_SPI_FREQ_250K;
   20a18:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   20a1c:	e7b1      	b.n	20982 <configure+0x7e>
		return NRF_SPI_FREQ_500K;
   20a1e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   20a22:	e7ae      	b.n	20982 <configure+0x7e>
		return NRF_SPI_FREQ_1M;
   20a24:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   20a28:	e7ab      	b.n	20982 <configure+0x7e>
		return NRF_SPI_FREQ_2M;
   20a2a:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   20a2e:	e7a8      	b.n	20982 <configure+0x7e>
		return NRF_SPI_FREQ_8M;
   20a30:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   20a34:	e7a5      	b.n	20982 <configure+0x7e>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
   20a36:	f013 0f04 	tst.w	r3, #4
   20a3a:	d003      	beq.n	20a44 <configure+0x140>
			return NRF_SPI_MODE_1;
   20a3c:	2301      	movs	r3, #1
   20a3e:	e7a9      	b.n	20994 <configure+0x90>
			return NRF_SPI_MODE_2;
   20a40:	2302      	movs	r3, #2
   20a42:	e7a7      	b.n	20994 <configure+0x90>
			return NRF_SPI_MODE_0;
   20a44:	2300      	movs	r3, #0
   20a46:	e7a5      	b.n	20994 <configure+0x90>
		return NRF_SPI_BIT_ORDER_MSB_FIRST;
   20a48:	2300      	movs	r3, #0
   20a4a:	e7aa      	b.n	209a2 <configure+0x9e>
		nrfx_spi_uninit(&dev_config->spi);
   20a4c:	4630      	mov	r0, r6
   20a4e:	f004 f913 	bl	24c78 <nrfx_spi_uninit>
		dev_data->initialized = false;
   20a52:	2300      	movs	r3, #0
   20a54:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
   20a58:	e7a7      	b.n	209aa <configure+0xa6>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
   20a5a:	4602      	mov	r2, r0
   20a5c:	2145      	movs	r1, #69	; 0x45
   20a5e:	4812      	ldr	r0, [pc, #72]	; (20aa8 <configure+0x1a4>)
   20a60:	f00b fd74 	bl	2c54c <z_log_minimal_printk>
		return -EIO;
   20a64:	f06f 0004 	mvn.w	r0, #4
   20a68:	e7ad      	b.n	209c6 <configure+0xc2>
		return 0;
   20a6a:	2000      	movs	r0, #0
   20a6c:	e7ab      	b.n	209c6 <configure+0xc2>
   20a6e:	bf00      	nop
   20a70:	0001e847 	.word	0x0001e847
   20a74:	0003d08f 	.word	0x0003d08f
   20a78:	0007a11f 	.word	0x0007a11f
   20a7c:	000f423f 	.word	0x000f423f
   20a80:	001e847f 	.word	0x001e847f
   20a84:	003d08ff 	.word	0x003d08ff
   20a88:	007a1200 	.word	0x007a1200
   20a8c:	00020ec9 	.word	0x00020ec9
   20a90:	0bad0000 	.word	0x0bad0000
   20a94:	0003b464 	.word	0x0003b464
   20a98:	0003b484 	.word	0x0003b484
   20a9c:	0003b4ac 	.word	0x0003b4ac
   20aa0:	0003b4d0 	.word	0x0003b4d0
   20aa4:	0003b504 	.word	0x0003b504
   20aa8:	0003b53c 	.word	0x0003b53c

00020aac <spi_nrfx_release>:
}
#endif /* CONFIG_SPI_ASYNC */

static int spi_nrfx_release(const struct device *dev,
			    const struct spi_config *spi_cfg)
{
   20aac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   20ab0:	6904      	ldr	r4, [r0, #16]
   20ab2:	6823      	ldr	r3, [r4, #0]

	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   20ab4:	428b      	cmp	r3, r1
   20ab6:	d15b      	bne.n	20b70 <spi_nrfx_release+0xc4>
		return -EINVAL;
	}

	if (dev_data->busy) {
   20ab8:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
   20abc:	2b00      	cmp	r3, #0
   20abe:	d15a      	bne.n	20b76 <spi_nrfx_release+0xca>
}

static inline void _spi_context_cs_control(struct spi_context *ctx,
					   bool on, bool force_off)
{
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   20ac0:	6823      	ldr	r3, [r4, #0]
   20ac2:	b333      	cbz	r3, 20b12 <spi_nrfx_release+0x66>
   20ac4:	689b      	ldr	r3, [r3, #8]
   20ac6:	b323      	cbz	r3, 20b12 <spi_nrfx_release+0x66>
   20ac8:	681a      	ldr	r2, [r3, #0]
   20aca:	b312      	cbz	r2, 20b12 <spi_nrfx_release+0x66>
			if (!force_off &&
			    ctx->config->operation & SPI_HOLD_ON_CS) {
				return;
			}

			k_busy_wait(ctx->config->cs->delay);
   20acc:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
   20ace:	f010 f874 	bl	30bba <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   20ad2:	6823      	ldr	r3, [r4, #0]
   20ad4:	689b      	ldr	r3, [r3, #8]
	return gpio_pin_set(spec->port, spec->pin, value);
   20ad6:	681d      	ldr	r5, [r3, #0]
   20ad8:	791f      	ldrb	r7, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   20ada:	686b      	ldr	r3, [r5, #4]
	const struct gpio_driver_data *const data =
   20adc:	f8d5 8010 	ldr.w	r8, [r5, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20ae0:	681b      	ldr	r3, [r3, #0]
   20ae2:	2601      	movs	r6, #1
   20ae4:	40be      	lsls	r6, r7
   20ae6:	4233      	tst	r3, r6
   20ae8:	d018      	beq.n	20b1c <spi_nrfx_release+0x70>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   20aea:	f8d8 3000 	ldr.w	r3, [r8]
   20aee:	421e      	tst	r6, r3
   20af0:	d122      	bne.n	20b38 <spi_nrfx_release+0x8c>
   20af2:	f04f 0800 	mov.w	r8, #0
	__unused const struct gpio_driver_config *const cfg =
   20af6:	686b      	ldr	r3, [r5, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20af8:	681b      	ldr	r3, [r3, #0]
   20afa:	2601      	movs	r6, #1
   20afc:	40be      	lsls	r6, r7
   20afe:	4233      	tst	r3, r6
   20b00:	d01d      	beq.n	20b3e <spi_nrfx_release+0x92>
	if (value != 0)	{
   20b02:	f1b8 0f00 	cmp.w	r8, #0
   20b06:	d027      	beq.n	20b58 <spi_nrfx_release+0xac>
	const struct gpio_driver_api *api =
   20b08:	68ab      	ldr	r3, [r5, #8]
	return api->port_set_bits_raw(port, pins);
   20b0a:	68db      	ldr	r3, [r3, #12]
   20b0c:	4631      	mov	r1, r6
   20b0e:	4628      	mov	r0, r5
   20b10:	4798      	blx	r3
	return sem->count;
   20b12:	69a3      	ldr	r3, [r4, #24]
static inline void spi_context_unlock_unconditionally(struct spi_context *ctx)
{
	/* Forcing CS to go to inactive status */
	_spi_context_cs_control(ctx, false, true);

	if (!k_sem_count_get(&ctx->lock)) {
   20b14:	b333      	cbz	r3, 20b64 <spi_nrfx_release+0xb8>
		return -EBUSY;
	}

	spi_context_unlock_unconditionally(&dev_data->ctx);

	return 0;
   20b16:	2000      	movs	r0, #0
}
   20b18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20b1c:	f8df 9060 	ldr.w	r9, [pc, #96]	; 20b80 <spi_nrfx_release+0xd4>
   20b20:	f240 5225 	movw	r2, #1317	; 0x525
   20b24:	4649      	mov	r1, r9
   20b26:	4815      	ldr	r0, [pc, #84]	; (20b7c <spi_nrfx_release+0xd0>)
   20b28:	f00b fd01 	bl	2c52e <assert_print>
   20b2c:	f240 5125 	movw	r1, #1317	; 0x525
   20b30:	4648      	mov	r0, r9
   20b32:	f00b fcf5 	bl	2c520 <assert_post_action>
   20b36:	e7d8      	b.n	20aea <spi_nrfx_release+0x3e>
		value = (value != 0) ? 0 : 1;
   20b38:	f04f 0801 	mov.w	r8, #1
   20b3c:	e7db      	b.n	20af6 <spi_nrfx_release+0x4a>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20b3e:	4f10      	ldr	r7, [pc, #64]	; (20b80 <spi_nrfx_release+0xd4>)
   20b40:	f240 42fc 	movw	r2, #1276	; 0x4fc
   20b44:	4639      	mov	r1, r7
   20b46:	480d      	ldr	r0, [pc, #52]	; (20b7c <spi_nrfx_release+0xd0>)
   20b48:	f00b fcf1 	bl	2c52e <assert_print>
   20b4c:	f240 41fc 	movw	r1, #1276	; 0x4fc
   20b50:	4638      	mov	r0, r7
   20b52:	f00b fce5 	bl	2c520 <assert_post_action>
   20b56:	e7d4      	b.n	20b02 <spi_nrfx_release+0x56>
	const struct gpio_driver_api *api =
   20b58:	68ab      	ldr	r3, [r5, #8]
	return api->port_clear_bits_raw(port, pins);
   20b5a:	691b      	ldr	r3, [r3, #16]
   20b5c:	4631      	mov	r1, r6
   20b5e:	4628      	mov	r0, r5
   20b60:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
   20b62:	e7d6      	b.n	20b12 <spi_nrfx_release+0x66>
		ctx->owner = NULL;
   20b64:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
   20b66:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
   20b6a:	f006 fa13 	bl	26f94 <z_impl_k_sem_give>
}
   20b6e:	e7d2      	b.n	20b16 <spi_nrfx_release+0x6a>
		return -EINVAL;
   20b70:	f06f 0015 	mvn.w	r0, #21
   20b74:	e7d0      	b.n	20b18 <spi_nrfx_release+0x6c>
		return -EBUSY;
   20b76:	f06f 000f 	mvn.w	r0, #15
   20b7a:	e7cd      	b.n	20b18 <spi_nrfx_release+0x6c>
   20b7c:	00031600 	.word	0x00031600
   20b80:	000315cc 	.word	0x000315cc

00020b84 <transfer_next_chunk>:
{
   20b84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   20b88:	b084      	sub	sp, #16
   20b8a:	4603      	mov	r3, r0
	const struct spi_nrfx_config *dev_config = dev->config;
   20b8c:	6840      	ldr	r0, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   20b8e:	691c      	ldr	r4, [r3, #16]
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   20b90:	6da2      	ldr	r2, [r4, #88]	; 0x58
   20b92:	2a00      	cmp	r2, #0
   20b94:	d060      	beq.n	20c58 <transfer_next_chunk+0xd4>
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
   20b96:	6e23      	ldr	r3, [r4, #96]	; 0x60
   20b98:	2b00      	cmp	r3, #0
   20b9a:	d05f      	beq.n	20c5c <transfer_next_chunk+0xd8>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
   20b9c:	4293      	cmp	r3, r2
   20b9e:	bf28      	it	cs
   20ba0:	4613      	movcs	r3, r2
	if (chunk_len > 0) {
   20ba2:	2b00      	cmp	r3, #0
   20ba4:	d066      	beq.n	20c74 <transfer_next_chunk+0xf0>
		dev_data->chunk_len = chunk_len;
   20ba6:	66a3      	str	r3, [r4, #104]	; 0x68
		xfer.p_tx_buffer = ctx->tx_buf;
   20ba8:	6d61      	ldr	r1, [r4, #84]	; 0x54
   20baa:	9100      	str	r1, [sp, #0]
	return !!(ctx->tx_buf && ctx->tx_len);
   20bac:	2900      	cmp	r1, #0
   20bae:	d057      	beq.n	20c60 <transfer_next_chunk+0xdc>
   20bb0:	2a00      	cmp	r2, #0
   20bb2:	d157      	bne.n	20c64 <transfer_next_chunk+0xe0>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   20bb4:	2a00      	cmp	r2, #0
   20bb6:	d057      	beq.n	20c68 <transfer_next_chunk+0xe4>
   20bb8:	461a      	mov	r2, r3
   20bba:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   20bbc:	6de2      	ldr	r2, [r4, #92]	; 0x5c
   20bbe:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   20bc0:	2a00      	cmp	r2, #0
   20bc2:	d053      	beq.n	20c6c <transfer_next_chunk+0xe8>
   20bc4:	6e22      	ldr	r2, [r4, #96]	; 0x60
   20bc6:	2a00      	cmp	r2, #0
   20bc8:	d152      	bne.n	20c70 <transfer_next_chunk+0xec>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   20bca:	b902      	cbnz	r2, 20bce <transfer_next_chunk+0x4a>
   20bcc:	2300      	movs	r3, #0
   20bce:	9303      	str	r3, [sp, #12]
		result = nrfx_spi_xfer(&dev_config->spi, &xfer, 0);
   20bd0:	2200      	movs	r2, #0
   20bd2:	4669      	mov	r1, sp
   20bd4:	f004 f96c 	bl	24eb0 <nrfx_spi_xfer>
		if (result == NRFX_SUCCESS) {
   20bd8:	4b3a      	ldr	r3, [pc, #232]	; (20cc4 <transfer_next_chunk+0x140>)
   20bda:	4298      	cmp	r0, r3
   20bdc:	d039      	beq.n	20c52 <transfer_next_chunk+0xce>
		error = -EIO;
   20bde:	f06f 0504 	mvn.w	r5, #4
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   20be2:	6823      	ldr	r3, [r4, #0]
   20be4:	b36b      	cbz	r3, 20c42 <transfer_next_chunk+0xbe>
   20be6:	689a      	ldr	r2, [r3, #8]
   20be8:	b35a      	cbz	r2, 20c42 <transfer_next_chunk+0xbe>
   20bea:	6811      	ldr	r1, [r2, #0]
   20bec:	b349      	cbz	r1, 20c42 <transfer_next_chunk+0xbe>
			    ctx->config->operation & SPI_HOLD_ON_CS) {
   20bee:	889b      	ldrh	r3, [r3, #4]
			if (!force_off &&
   20bf0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   20bf4:	d125      	bne.n	20c42 <transfer_next_chunk+0xbe>
			k_busy_wait(ctx->config->cs->delay);
   20bf6:	6890      	ldr	r0, [r2, #8]
	z_impl_k_busy_wait(usec_to_wait);
   20bf8:	f00f ffdf 	bl	30bba <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   20bfc:	6823      	ldr	r3, [r4, #0]
   20bfe:	689b      	ldr	r3, [r3, #8]
	return gpio_pin_set(spec->port, spec->pin, value);
   20c00:	681e      	ldr	r6, [r3, #0]
   20c02:	f893 8004 	ldrb.w	r8, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   20c06:	6873      	ldr	r3, [r6, #4]
	const struct gpio_driver_data *const data =
   20c08:	f8d6 9010 	ldr.w	r9, [r6, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20c0c:	681b      	ldr	r3, [r3, #0]
   20c0e:	2701      	movs	r7, #1
   20c10:	fa07 f708 	lsl.w	r7, r7, r8
   20c14:	423b      	tst	r3, r7
   20c16:	d02f      	beq.n	20c78 <transfer_next_chunk+0xf4>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   20c18:	f8d9 3000 	ldr.w	r3, [r9]
   20c1c:	421f      	tst	r7, r3
   20c1e:	d139      	bne.n	20c94 <transfer_next_chunk+0x110>
   20c20:	f04f 0900 	mov.w	r9, #0
	__unused const struct gpio_driver_config *const cfg =
   20c24:	6873      	ldr	r3, [r6, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20c26:	681b      	ldr	r3, [r3, #0]
   20c28:	2701      	movs	r7, #1
   20c2a:	fa07 f708 	lsl.w	r7, r7, r8
   20c2e:	423b      	tst	r3, r7
   20c30:	d033      	beq.n	20c9a <transfer_next_chunk+0x116>
	if (value != 0)	{
   20c32:	f1b9 0f00 	cmp.w	r9, #0
   20c36:	d03e      	beq.n	20cb6 <transfer_next_chunk+0x132>
	const struct gpio_driver_api *api =
   20c38:	68b3      	ldr	r3, [r6, #8]
	return api->port_set_bits_raw(port, pins);
   20c3a:	68db      	ldr	r3, [r3, #12]
   20c3c:	4639      	mov	r1, r7
   20c3e:	4630      	mov	r0, r6
   20c40:	4798      	blx	r3
	ctx->sync_status = status;
   20c42:	6425      	str	r5, [r4, #64]	; 0x40
	k_sem_give(&ctx->sync);
   20c44:	f104 0028 	add.w	r0, r4, #40	; 0x28
	z_impl_k_sem_give(sem);
   20c48:	f006 f9a4 	bl	26f94 <z_impl_k_sem_give>
	dev_data->busy = false;
   20c4c:	2300      	movs	r3, #0
   20c4e:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
}
   20c52:	b004      	add	sp, #16
   20c54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return ctx->rx_len;
   20c58:	6e23      	ldr	r3, [r4, #96]	; 0x60
   20c5a:	e7a2      	b.n	20ba2 <transfer_next_chunk+0x1e>
		return ctx->tx_len;
   20c5c:	4613      	mov	r3, r2
   20c5e:	e7a0      	b.n	20ba2 <transfer_next_chunk+0x1e>
	return !!(ctx->tx_buf && ctx->tx_len);
   20c60:	2200      	movs	r2, #0
   20c62:	e7a7      	b.n	20bb4 <transfer_next_chunk+0x30>
   20c64:	2201      	movs	r2, #1
   20c66:	e7a5      	b.n	20bb4 <transfer_next_chunk+0x30>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   20c68:	2200      	movs	r2, #0
   20c6a:	e7a6      	b.n	20bba <transfer_next_chunk+0x36>
	return !!(ctx->rx_buf && ctx->rx_len);
   20c6c:	2200      	movs	r2, #0
   20c6e:	e7ac      	b.n	20bca <transfer_next_chunk+0x46>
   20c70:	2201      	movs	r2, #1
   20c72:	e7aa      	b.n	20bca <transfer_next_chunk+0x46>
	int error = 0;
   20c74:	2500      	movs	r5, #0
   20c76:	e7b4      	b.n	20be2 <transfer_next_chunk+0x5e>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20c78:	f8df a050 	ldr.w	sl, [pc, #80]	; 20ccc <transfer_next_chunk+0x148>
   20c7c:	f240 5225 	movw	r2, #1317	; 0x525
   20c80:	4651      	mov	r1, sl
   20c82:	4811      	ldr	r0, [pc, #68]	; (20cc8 <transfer_next_chunk+0x144>)
   20c84:	f00b fc53 	bl	2c52e <assert_print>
   20c88:	f240 5125 	movw	r1, #1317	; 0x525
   20c8c:	4650      	mov	r0, sl
   20c8e:	f00b fc47 	bl	2c520 <assert_post_action>
   20c92:	e7c1      	b.n	20c18 <transfer_next_chunk+0x94>
		value = (value != 0) ? 0 : 1;
   20c94:	f04f 0901 	mov.w	r9, #1
   20c98:	e7c4      	b.n	20c24 <transfer_next_chunk+0xa0>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20c9a:	f8df 8030 	ldr.w	r8, [pc, #48]	; 20ccc <transfer_next_chunk+0x148>
   20c9e:	f240 42fc 	movw	r2, #1276	; 0x4fc
   20ca2:	4641      	mov	r1, r8
   20ca4:	4808      	ldr	r0, [pc, #32]	; (20cc8 <transfer_next_chunk+0x144>)
   20ca6:	f00b fc42 	bl	2c52e <assert_print>
   20caa:	f240 41fc 	movw	r1, #1276	; 0x4fc
   20cae:	4640      	mov	r0, r8
   20cb0:	f00b fc36 	bl	2c520 <assert_post_action>
   20cb4:	e7bd      	b.n	20c32 <transfer_next_chunk+0xae>
	const struct gpio_driver_api *api =
   20cb6:	68b3      	ldr	r3, [r6, #8]
	return api->port_clear_bits_raw(port, pins);
   20cb8:	691b      	ldr	r3, [r3, #16]
   20cba:	4639      	mov	r1, r7
   20cbc:	4630      	mov	r0, r6
   20cbe:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
   20cc0:	e7bf      	b.n	20c42 <transfer_next_chunk+0xbe>
   20cc2:	bf00      	nop
   20cc4:	0bad0000 	.word	0x0bad0000
   20cc8:	00031600 	.word	0x00031600
   20ccc:	000315cc 	.word	0x000315cc

00020cd0 <transceive>:
{
   20cd0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20cd4:	4606      	mov	r6, r0
   20cd6:	460d      	mov	r5, r1
   20cd8:	4690      	mov	r8, r2
   20cda:	461f      	mov	r7, r3
	struct spi_nrfx_data *dev_data = dev->data;
   20cdc:	6904      	ldr	r4, [r0, #16]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   20cde:	888b      	ldrh	r3, [r1, #4]
   20ce0:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   20ce4:	d004      	beq.n	20cf0 <transceive+0x20>
   20ce6:	69a3      	ldr	r3, [r4, #24]
   20ce8:	b913      	cbnz	r3, 20cf0 <transceive+0x20>
		(ctx->owner == spi_cfg)) {
   20cea:	6863      	ldr	r3, [r4, #4]
		(k_sem_count_get(&ctx->lock) == 0) &&
   20cec:	4299      	cmp	r1, r3
   20cee:	d008      	beq.n	20d02 <transceive+0x32>
	k_sem_take(&ctx->lock, K_FOREVER);
   20cf0:	f104 0010 	add.w	r0, r4, #16
	return z_impl_k_sem_take(sem, timeout);
   20cf4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   20cf8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20cfc:	f006 f98a 	bl	27014 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
   20d00:	6065      	str	r5, [r4, #4]
	error = configure(dev, spi_cfg);
   20d02:	4629      	mov	r1, r5
   20d04:	4630      	mov	r0, r6
   20d06:	f7ff fdfd 	bl	20904 <configure>
	if (error == 0) {
   20d0a:	4605      	mov	r5, r0
   20d0c:	b140      	cbz	r0, 20d20 <transceive+0x50>
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
   20d0e:	6823      	ldr	r3, [r4, #0]
   20d10:	889b      	ldrh	r3, [r3, #4]
   20d12:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   20d16:	f000 80ca 	beq.w	20eae <transceive+0x1de>
}
   20d1a:	4628      	mov	r0, r5
   20d1c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dev_data->busy = true;
   20d20:	2301      	movs	r3, #1
   20d22:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   20d26:	f1b8 0f00 	cmp.w	r8, #0
   20d2a:	d015      	beq.n	20d58 <transceive+0x88>
   20d2c:	f8d8 3000 	ldr.w	r3, [r8]
   20d30:	6463      	str	r3, [r4, #68]	; 0x44
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   20d32:	b19b      	cbz	r3, 20d5c <transceive+0x8c>
   20d34:	f8d8 3004 	ldr.w	r3, [r8, #4]
   20d38:	64a3      	str	r3, [r4, #72]	; 0x48
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
   20d3a:	f104 0144 	add.w	r1, r4, #68	; 0x44
   20d3e:	f104 0348 	add.w	r3, r4, #72	; 0x48
	while (*count) {
   20d42:	681a      	ldr	r2, [r3, #0]
   20d44:	b182      	cbz	r2, 20d68 <transceive+0x98>
		if (((*current)->len / dfs) != 0) {
   20d46:	680a      	ldr	r2, [r1, #0]
   20d48:	6850      	ldr	r0, [r2, #4]
   20d4a:	b948      	cbnz	r0, 20d60 <transceive+0x90>
		++(*current);
   20d4c:	3208      	adds	r2, #8
   20d4e:	600a      	str	r2, [r1, #0]
		--(*count);
   20d50:	681a      	ldr	r2, [r3, #0]
   20d52:	3a01      	subs	r2, #1
   20d54:	601a      	str	r2, [r3, #0]
   20d56:	e7f4      	b.n	20d42 <transceive+0x72>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   20d58:	4643      	mov	r3, r8
   20d5a:	e7e9      	b.n	20d30 <transceive+0x60>
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   20d5c:	2300      	movs	r3, #0
   20d5e:	e7eb      	b.n	20d38 <transceive+0x68>
			*buf_len = (*current)->len / dfs;
   20d60:	65a0      	str	r0, [r4, #88]	; 0x58
			return (*current)->buf;
   20d62:	6c63      	ldr	r3, [r4, #68]	; 0x44
   20d64:	681b      	ldr	r3, [r3, #0]
   20d66:	e001      	b.n	20d6c <transceive+0x9c>
	*buf_len = 0;
   20d68:	2300      	movs	r3, #0
   20d6a:	65a3      	str	r3, [r4, #88]	; 0x58
	ctx->tx_buf = (const uint8_t *)
   20d6c:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   20d6e:	b19f      	cbz	r7, 20d98 <transceive+0xc8>
   20d70:	683b      	ldr	r3, [r7, #0]
   20d72:	64e3      	str	r3, [r4, #76]	; 0x4c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   20d74:	b193      	cbz	r3, 20d9c <transceive+0xcc>
   20d76:	687b      	ldr	r3, [r7, #4]
   20d78:	6523      	str	r3, [r4, #80]	; 0x50
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
   20d7a:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   20d7e:	f104 0250 	add.w	r2, r4, #80	; 0x50
	while (*count) {
   20d82:	6813      	ldr	r3, [r2, #0]
   20d84:	b183      	cbz	r3, 20da8 <transceive+0xd8>
		if (((*current)->len / dfs) != 0) {
   20d86:	680b      	ldr	r3, [r1, #0]
   20d88:	6858      	ldr	r0, [r3, #4]
   20d8a:	b948      	cbnz	r0, 20da0 <transceive+0xd0>
		++(*current);
   20d8c:	3308      	adds	r3, #8
   20d8e:	600b      	str	r3, [r1, #0]
		--(*count);
   20d90:	6813      	ldr	r3, [r2, #0]
   20d92:	3b01      	subs	r3, #1
   20d94:	6013      	str	r3, [r2, #0]
   20d96:	e7f4      	b.n	20d82 <transceive+0xb2>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   20d98:	463b      	mov	r3, r7
   20d9a:	e7ea      	b.n	20d72 <transceive+0xa2>
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   20d9c:	2300      	movs	r3, #0
   20d9e:	e7eb      	b.n	20d78 <transceive+0xa8>
			*buf_len = (*current)->len / dfs;
   20da0:	6620      	str	r0, [r4, #96]	; 0x60
			return (*current)->buf;
   20da2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   20da4:	681b      	ldr	r3, [r3, #0]
   20da6:	e000      	b.n	20daa <transceive+0xda>
	*buf_len = 0;
   20da8:	6623      	str	r3, [r4, #96]	; 0x60
	ctx->rx_buf = (uint8_t *)
   20daa:	65e3      	str	r3, [r4, #92]	; 0x5c
	ctx->sync_status = 0;
   20dac:	2300      	movs	r3, #0
   20dae:	6423      	str	r3, [r4, #64]	; 0x40
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   20db0:	6823      	ldr	r3, [r4, #0]
   20db2:	b35b      	cbz	r3, 20e0c <transceive+0x13c>
   20db4:	689b      	ldr	r3, [r3, #8]
   20db6:	b34b      	cbz	r3, 20e0c <transceive+0x13c>
   20db8:	681f      	ldr	r7, [r3, #0]
   20dba:	b33f      	cbz	r7, 20e0c <transceive+0x13c>
	return gpio_pin_set(spec->port, spec->pin, value);
   20dbc:	f893 9004 	ldrb.w	r9, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   20dc0:	687b      	ldr	r3, [r7, #4]
	const struct gpio_driver_data *const data =
   20dc2:	f8d7 a010 	ldr.w	sl, [r7, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20dc6:	681b      	ldr	r3, [r3, #0]
   20dc8:	f04f 0801 	mov.w	r8, #1
   20dcc:	fa08 f809 	lsl.w	r8, r8, r9
   20dd0:	ea13 0f08 	tst.w	r3, r8
   20dd4:	d042      	beq.n	20e5c <transceive+0x18c>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   20dd6:	f8da 3000 	ldr.w	r3, [sl]
   20dda:	ea18 0f03 	tst.w	r8, r3
   20dde:	d100      	bne.n	20de2 <transceive+0x112>
   20de0:	2501      	movs	r5, #1
	__unused const struct gpio_driver_config *const cfg =
   20de2:	687b      	ldr	r3, [r7, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20de4:	681b      	ldr	r3, [r3, #0]
   20de6:	f04f 0801 	mov.w	r8, #1
   20dea:	fa08 f809 	lsl.w	r8, r8, r9
   20dee:	ea13 0f08 	tst.w	r3, r8
   20df2:	d041      	beq.n	20e78 <transceive+0x1a8>
	if (value != 0)	{
   20df4:	2d00      	cmp	r5, #0
   20df6:	d04d      	beq.n	20e94 <transceive+0x1c4>
	const struct gpio_driver_api *api =
   20df8:	68bb      	ldr	r3, [r7, #8]
	return api->port_set_bits_raw(port, pins);
   20dfa:	68db      	ldr	r3, [r3, #12]
   20dfc:	4641      	mov	r1, r8
   20dfe:	4638      	mov	r0, r7
   20e00:	4798      	blx	r3
			k_busy_wait(ctx->config->cs->delay);
   20e02:	6823      	ldr	r3, [r4, #0]
   20e04:	689b      	ldr	r3, [r3, #8]
   20e06:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
   20e08:	f00f fed7 	bl	30bba <z_impl_k_busy_wait>
		transfer_next_chunk(dev);
   20e0c:	4630      	mov	r0, r6
   20e0e:	f7ff feb9 	bl	20b84 <transfer_next_chunk>
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
   20e12:	6e20      	ldr	r0, [r4, #96]	; 0x60
   20e14:	6da3      	ldr	r3, [r4, #88]	; 0x58
   20e16:	4298      	cmp	r0, r3
   20e18:	bf38      	it	cc
   20e1a:	4618      	movcc	r0, r3
   20e1c:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
   20e20:	fb03 f000 	mul.w	r0, r3, r0
			     ctx->config->frequency;
   20e24:	4625      	mov	r5, r4
   20e26:	f855 3b28 	ldr.w	r3, [r5], #40
   20e2a:	681b      	ldr	r3, [r3, #0]
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
   20e2c:	fbb0 f0f3 	udiv	r0, r0, r3
		timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
   20e30:	30c8      	adds	r0, #200	; 0xc8
			return ((t * to_hz + off) / from_hz);
   20e32:	0c41      	lsrs	r1, r0, #17
   20e34:	03c0      	lsls	r0, r0, #15
   20e36:	f240 33e7 	movw	r3, #999	; 0x3e7
   20e3a:	18c0      	adds	r0, r0, r3
   20e3c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   20e40:	f04f 0300 	mov.w	r3, #0
   20e44:	f141 0100 	adc.w	r1, r1, #0
   20e48:	f7df fec6 	bl	bd8 <__aeabi_uldivmod>
   20e4c:	4602      	mov	r2, r0
   20e4e:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
   20e50:	4628      	mov	r0, r5
   20e52:	f006 f8df 	bl	27014 <z_impl_k_sem_take>
	if (k_sem_take(&ctx->sync, timeout)) {
   20e56:	bb18      	cbnz	r0, 20ea0 <transceive+0x1d0>
	status = ctx->sync_status;
   20e58:	6c25      	ldr	r5, [r4, #64]	; 0x40
	return status;
   20e5a:	e758      	b.n	20d0e <transceive+0x3e>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20e5c:	f8df b064 	ldr.w	fp, [pc, #100]	; 20ec4 <transceive+0x1f4>
   20e60:	f240 5225 	movw	r2, #1317	; 0x525
   20e64:	4659      	mov	r1, fp
   20e66:	4815      	ldr	r0, [pc, #84]	; (20ebc <transceive+0x1ec>)
   20e68:	f00b fb61 	bl	2c52e <assert_print>
   20e6c:	f240 5125 	movw	r1, #1317	; 0x525
   20e70:	4658      	mov	r0, fp
   20e72:	f00b fb55 	bl	2c520 <assert_post_action>
   20e76:	e7ae      	b.n	20dd6 <transceive+0x106>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   20e78:	f8df 9048 	ldr.w	r9, [pc, #72]	; 20ec4 <transceive+0x1f4>
   20e7c:	f240 42fc 	movw	r2, #1276	; 0x4fc
   20e80:	4649      	mov	r1, r9
   20e82:	480e      	ldr	r0, [pc, #56]	; (20ebc <transceive+0x1ec>)
   20e84:	f00b fb53 	bl	2c52e <assert_print>
   20e88:	f240 41fc 	movw	r1, #1276	; 0x4fc
   20e8c:	4648      	mov	r0, r9
   20e8e:	f00b fb47 	bl	2c520 <assert_post_action>
   20e92:	e7af      	b.n	20df4 <transceive+0x124>
	const struct gpio_driver_api *api =
   20e94:	68bb      	ldr	r3, [r7, #8]
	return api->port_clear_bits_raw(port, pins);
   20e96:	691b      	ldr	r3, [r3, #16]
   20e98:	4641      	mov	r1, r8
   20e9a:	4638      	mov	r0, r7
   20e9c:	4798      	blx	r3
   20e9e:	e7b0      	b.n	20e02 <transceive+0x132>
		LOG_ERR("Timeout waiting for transfer complete");
   20ea0:	2145      	movs	r1, #69	; 0x45
   20ea2:	4807      	ldr	r0, [pc, #28]	; (20ec0 <transceive+0x1f0>)
   20ea4:	f00b fb52 	bl	2c54c <z_log_minimal_printk>
		return -ETIMEDOUT;
   20ea8:	f06f 0573 	mvn.w	r5, #115	; 0x73
   20eac:	e72f      	b.n	20d0e <transceive+0x3e>
		ctx->owner = NULL;
   20eae:	2300      	movs	r3, #0
   20eb0:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
   20eb2:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
   20eb6:	f006 f86d 	bl	26f94 <z_impl_k_sem_give>
	return error;
   20eba:	e72e      	b.n	20d1a <transceive+0x4a>
   20ebc:	00031600 	.word	0x00031600
   20ec0:	0003b568 	.word	0x0003b568
   20ec4:	000315cc 	.word	0x000315cc

00020ec8 <event_handler>:
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
   20ec8:	7803      	ldrb	r3, [r0, #0]
   20eca:	2b00      	cmp	r3, #0
   20ecc:	d15f      	bne.n	20f8e <event_handler+0xc6>
{
   20ece:	b510      	push	{r4, lr}
   20ed0:	460c      	mov	r4, r1
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   20ed2:	6e8a      	ldr	r2, [r1, #104]	; 0x68
	if (!ctx->tx_len) {
   20ed4:	6d8b      	ldr	r3, [r1, #88]	; 0x58
   20ed6:	b143      	cbz	r3, 20eea <event_handler+0x22>
	if (len > ctx->tx_len) {
   20ed8:	429a      	cmp	r2, r3
   20eda:	d817      	bhi.n	20f0c <event_handler+0x44>
	ctx->tx_len -= len;
   20edc:	1a9b      	subs	r3, r3, r2
   20ede:	658b      	str	r3, [r1, #88]	; 0x58
	if (!ctx->tx_len) {
   20ee0:	b1cb      	cbz	r3, 20f16 <event_handler+0x4e>
	} else if (ctx->tx_buf) {
   20ee2:	6d4b      	ldr	r3, [r1, #84]	; 0x54
   20ee4:	b10b      	cbz	r3, 20eea <event_handler+0x22>
		ctx->tx_buf += dfs * len;
   20ee6:	4413      	add	r3, r2
   20ee8:	654b      	str	r3, [r1, #84]	; 0x54
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
   20eea:	6ea2      	ldr	r2, [r4, #104]	; 0x68
	if (!ctx->rx_len) {
   20eec:	6e23      	ldr	r3, [r4, #96]	; 0x60
   20eee:	b14b      	cbz	r3, 20f04 <event_handler+0x3c>
	if (len > ctx->rx_len) {
   20ef0:	429a      	cmp	r2, r3
   20ef2:	d82b      	bhi.n	20f4c <event_handler+0x84>
	ctx->rx_len -= len;
   20ef4:	1a9b      	subs	r3, r3, r2
   20ef6:	6623      	str	r3, [r4, #96]	; 0x60
	if (!ctx->rx_len) {
   20ef8:	2b00      	cmp	r3, #0
   20efa:	d02c      	beq.n	20f56 <event_handler+0x8e>
	} else if (ctx->rx_buf) {
   20efc:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   20efe:	b10b      	cbz	r3, 20f04 <event_handler+0x3c>
		ctx->rx_buf += dfs * len;
   20f00:	4413      	add	r3, r2
   20f02:	65e3      	str	r3, [r4, #92]	; 0x5c
		transfer_next_chunk(dev_data->dev);
   20f04:	6e60      	ldr	r0, [r4, #100]	; 0x64
   20f06:	f7ff fe3d 	bl	20b84 <transfer_next_chunk>
}
   20f0a:	bd10      	pop	{r4, pc}
		LOG_ERR("Update exceeds current buffer");
   20f0c:	2145      	movs	r1, #69	; 0x45
   20f0e:	4820      	ldr	r0, [pc, #128]	; (20f90 <event_handler+0xc8>)
   20f10:	f00b fb1c 	bl	2c54c <z_log_minimal_printk>
		return;
   20f14:	e7e9      	b.n	20eea <event_handler+0x22>
		++ctx->current_tx;
   20f16:	6c4b      	ldr	r3, [r1, #68]	; 0x44
   20f18:	3308      	adds	r3, #8
   20f1a:	644b      	str	r3, [r1, #68]	; 0x44
		--ctx->tx_count;
   20f1c:	6c8b      	ldr	r3, [r1, #72]	; 0x48
   20f1e:	3b01      	subs	r3, #1
   20f20:	648b      	str	r3, [r1, #72]	; 0x48
			spi_context_get_next_buf(&ctx->current_tx,
   20f22:	3144      	adds	r1, #68	; 0x44
   20f24:	f104 0248 	add.w	r2, r4, #72	; 0x48
	while (*count) {
   20f28:	6813      	ldr	r3, [r2, #0]
   20f2a:	b163      	cbz	r3, 20f46 <event_handler+0x7e>
		if (((*current)->len / dfs) != 0) {
   20f2c:	680b      	ldr	r3, [r1, #0]
   20f2e:	6858      	ldr	r0, [r3, #4]
   20f30:	b928      	cbnz	r0, 20f3e <event_handler+0x76>
		++(*current);
   20f32:	3308      	adds	r3, #8
   20f34:	600b      	str	r3, [r1, #0]
		--(*count);
   20f36:	6813      	ldr	r3, [r2, #0]
   20f38:	3b01      	subs	r3, #1
   20f3a:	6013      	str	r3, [r2, #0]
   20f3c:	e7f4      	b.n	20f28 <event_handler+0x60>
			*buf_len = (*current)->len / dfs;
   20f3e:	65a0      	str	r0, [r4, #88]	; 0x58
			return (*current)->buf;
   20f40:	6c63      	ldr	r3, [r4, #68]	; 0x44
   20f42:	681b      	ldr	r3, [r3, #0]
   20f44:	e000      	b.n	20f48 <event_handler+0x80>
	*buf_len = 0;
   20f46:	65a3      	str	r3, [r4, #88]	; 0x58
		ctx->tx_buf = (const uint8_t *)
   20f48:	6563      	str	r3, [r4, #84]	; 0x54
   20f4a:	e7ce      	b.n	20eea <event_handler+0x22>
		LOG_ERR("Update exceeds current buffer");
   20f4c:	2145      	movs	r1, #69	; 0x45
   20f4e:	4810      	ldr	r0, [pc, #64]	; (20f90 <event_handler+0xc8>)
   20f50:	f00b fafc 	bl	2c54c <z_log_minimal_printk>
		return;
   20f54:	e7d6      	b.n	20f04 <event_handler+0x3c>
		++ctx->current_rx;
   20f56:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   20f58:	3308      	adds	r3, #8
   20f5a:	64e3      	str	r3, [r4, #76]	; 0x4c
		--ctx->rx_count;
   20f5c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   20f5e:	3b01      	subs	r3, #1
   20f60:	6523      	str	r3, [r4, #80]	; 0x50
			spi_context_get_next_buf(&ctx->current_rx,
   20f62:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   20f66:	f104 0250 	add.w	r2, r4, #80	; 0x50
	while (*count) {
   20f6a:	6813      	ldr	r3, [r2, #0]
   20f6c:	b163      	cbz	r3, 20f88 <event_handler+0xc0>
		if (((*current)->len / dfs) != 0) {
   20f6e:	680b      	ldr	r3, [r1, #0]
   20f70:	6858      	ldr	r0, [r3, #4]
   20f72:	b928      	cbnz	r0, 20f80 <event_handler+0xb8>
		++(*current);
   20f74:	3308      	adds	r3, #8
   20f76:	600b      	str	r3, [r1, #0]
		--(*count);
   20f78:	6813      	ldr	r3, [r2, #0]
   20f7a:	3b01      	subs	r3, #1
   20f7c:	6013      	str	r3, [r2, #0]
   20f7e:	e7f4      	b.n	20f6a <event_handler+0xa2>
			*buf_len = (*current)->len / dfs;
   20f80:	6620      	str	r0, [r4, #96]	; 0x60
			return (*current)->buf;
   20f82:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   20f84:	681b      	ldr	r3, [r3, #0]
   20f86:	e000      	b.n	20f8a <event_handler+0xc2>
	*buf_len = 0;
   20f88:	6623      	str	r3, [r4, #96]	; 0x60
		ctx->rx_buf = (uint8_t *)
   20f8a:	65e3      	str	r3, [r4, #92]	; 0x5c
   20f8c:	e7ba      	b.n	20f04 <event_handler+0x3c>
   20f8e:	4770      	bx	lr
   20f90:	0003b594 	.word	0x0003b594

00020f94 <spi_nrfx_init>:
	return ret;
}
#endif /* CONFIG_PM_DEVICE */

static int spi_nrfx_init(const struct device *dev)
{
   20f94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   20f98:	b083      	sub	sp, #12
	const struct spi_nrfx_config *dev_config = dev->config;
   20f9a:	6844      	ldr	r4, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   20f9c:	6905      	ldr	r5, [r0, #16]
	int err;

#ifdef CONFIG_PINCTRL
	err = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
   20f9e:	6a26      	ldr	r6, [r4, #32]
	ret = pinctrl_lookup_state(config, id, &state);
   20fa0:	aa01      	add	r2, sp, #4
   20fa2:	2100      	movs	r1, #0
   20fa4:	4630      	mov	r0, r6
   20fa6:	f00e fdce 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   20faa:	2800      	cmp	r0, #0
   20fac:	db05      	blt.n	20fba <spi_nrfx_init+0x26>
	return pinctrl_apply_state_direct(config, state);
   20fae:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   20fb0:	6832      	ldr	r2, [r6, #0]
   20fb2:	7919      	ldrb	r1, [r3, #4]
   20fb4:	6818      	ldr	r0, [r3, #0]
   20fb6:	f000 fdb1 	bl	21b1c <pinctrl_configure_pins>
	if (err < 0) {
   20fba:	2800      	cmp	r0, #0
   20fbc:	db50      	blt.n	21060 <spi_nrfx_init+0xcc>
		return err;
	}
#endif

	dev_config->irq_connect();
   20fbe:	69e3      	ldr	r3, [r4, #28]
   20fc0:	4798      	blx	r3
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
   20fc2:	68ac      	ldr	r4, [r5, #8]
   20fc4:	68ab      	ldr	r3, [r5, #8]
   20fc6:	68ea      	ldr	r2, [r5, #12]
   20fc8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   20fcc:	429c      	cmp	r4, r3
   20fce:	d218      	bcs.n	21002 <spi_nrfx_init+0x6e>
		if (!device_is_ready(cs_gpio->port)) {
   20fd0:	6820      	ldr	r0, [r4, #0]
   20fd2:	f00f fc57 	bl	30884 <z_device_is_ready>
   20fd6:	b150      	cbz	r0, 20fee <spi_nrfx_init+0x5a>
	return gpio_pin_configure(spec->port,
   20fd8:	6820      	ldr	r0, [r4, #0]
   20fda:	7921      	ldrb	r1, [r4, #4]
				  spec->dt_flags | extra_flags);
   20fdc:	88e2      	ldrh	r2, [r4, #6]
	return gpio_pin_configure(spec->port,
   20fde:	f442 12b0 	orr.w	r2, r2, #1441792	; 0x160000
   20fe2:	f7ff fbe1 	bl	207a8 <z_impl_gpio_pin_configure>
		if (ret < 0) {
   20fe6:	2800      	cmp	r0, #0
   20fe8:	db0c      	blt.n	21004 <spi_nrfx_init+0x70>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
   20fea:	3408      	adds	r4, #8
   20fec:	e7ea      	b.n	20fc4 <spi_nrfx_init+0x30>
			LOG_ERR("CS GPIO port %s pin %d is not ready",
   20fee:	6822      	ldr	r2, [r4, #0]
   20ff0:	7923      	ldrb	r3, [r4, #4]
   20ff2:	6812      	ldr	r2, [r2, #0]
   20ff4:	2145      	movs	r1, #69	; 0x45
   20ff6:	4831      	ldr	r0, [pc, #196]	; (210bc <spi_nrfx_init+0x128>)
   20ff8:	f00b faa8 	bl	2c54c <z_log_minimal_printk>
			return -ENODEV;
   20ffc:	f06f 0012 	mvn.w	r0, #18
   21000:	e000      	b.n	21004 <spi_nrfx_init+0x70>
	return 0;
   21002:	2000      	movs	r0, #0

	err = spi_context_cs_configure_all(&dev_data->ctx);
	if (err < 0) {
   21004:	2800      	cmp	r0, #0
   21006:	db2b      	blt.n	21060 <spi_nrfx_init+0xcc>
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   21008:	682b      	ldr	r3, [r5, #0]
   2100a:	b333      	cbz	r3, 2105a <spi_nrfx_init+0xc6>
   2100c:	689b      	ldr	r3, [r3, #8]
   2100e:	b323      	cbz	r3, 2105a <spi_nrfx_init+0xc6>
   21010:	681a      	ldr	r2, [r3, #0]
   21012:	b312      	cbz	r2, 2105a <spi_nrfx_init+0xc6>
			k_busy_wait(ctx->config->cs->delay);
   21014:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
   21016:	f00f fdd0 	bl	30bba <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   2101a:	682b      	ldr	r3, [r5, #0]
   2101c:	689b      	ldr	r3, [r3, #8]
	return gpio_pin_set(spec->port, spec->pin, value);
   2101e:	681c      	ldr	r4, [r3, #0]
   21020:	791f      	ldrb	r7, [r3, #4]
	__unused const struct gpio_driver_config *const cfg =
   21022:	6863      	ldr	r3, [r4, #4]
	const struct gpio_driver_data *const data =
   21024:	f8d4 8010 	ldr.w	r8, [r4, #16]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   21028:	681b      	ldr	r3, [r3, #0]
   2102a:	2601      	movs	r6, #1
   2102c:	40be      	lsls	r6, r7
   2102e:	4233      	tst	r3, r6
   21030:	d019      	beq.n	21066 <spi_nrfx_init+0xd2>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   21032:	f8d8 3000 	ldr.w	r3, [r8]
   21036:	421e      	tst	r6, r3
   21038:	d123      	bne.n	21082 <spi_nrfx_init+0xee>
   2103a:	f04f 0800 	mov.w	r8, #0
	__unused const struct gpio_driver_config *const cfg =
   2103e:	6863      	ldr	r3, [r4, #4]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   21040:	681b      	ldr	r3, [r3, #0]
   21042:	2601      	movs	r6, #1
   21044:	40be      	lsls	r6, r7
   21046:	4233      	tst	r3, r6
   21048:	d01e      	beq.n	21088 <spi_nrfx_init+0xf4>
	if (value != 0)	{
   2104a:	f1b8 0f00 	cmp.w	r8, #0
   2104e:	d028      	beq.n	210a2 <spi_nrfx_init+0x10e>
	const struct gpio_driver_api *api =
   21050:	68a3      	ldr	r3, [r4, #8]
	return api->port_set_bits_raw(port, pins);
   21052:	68db      	ldr	r3, [r3, #12]
   21054:	4631      	mov	r1, r6
   21056:	4620      	mov	r0, r4
   21058:	4798      	blx	r3
   2105a:	69ab      	ldr	r3, [r5, #24]
	if (!k_sem_count_get(&ctx->lock)) {
   2105c:	b33b      	cbz	r3, 210ae <spi_nrfx_init+0x11a>
		return err;
	}

	spi_context_unlock_unconditionally(&dev_data->ctx);

	return 0;
   2105e:	2000      	movs	r0, #0
}
   21060:	b003      	add	sp, #12
   21062:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   21066:	f8df 905c 	ldr.w	r9, [pc, #92]	; 210c4 <spi_nrfx_init+0x130>
   2106a:	f240 5225 	movw	r2, #1317	; 0x525
   2106e:	4649      	mov	r1, r9
   21070:	4813      	ldr	r0, [pc, #76]	; (210c0 <spi_nrfx_init+0x12c>)
   21072:	f00b fa5c 	bl	2c52e <assert_print>
   21076:	f240 5125 	movw	r1, #1317	; 0x525
   2107a:	4648      	mov	r0, r9
   2107c:	f00b fa50 	bl	2c520 <assert_post_action>
   21080:	e7d7      	b.n	21032 <spi_nrfx_init+0x9e>
		value = (value != 0) ? 0 : 1;
   21082:	f04f 0801 	mov.w	r8, #1
   21086:	e7da      	b.n	2103e <spi_nrfx_init+0xaa>
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   21088:	4f0e      	ldr	r7, [pc, #56]	; (210c4 <spi_nrfx_init+0x130>)
   2108a:	f240 42fc 	movw	r2, #1276	; 0x4fc
   2108e:	4639      	mov	r1, r7
   21090:	480b      	ldr	r0, [pc, #44]	; (210c0 <spi_nrfx_init+0x12c>)
   21092:	f00b fa4c 	bl	2c52e <assert_print>
   21096:	f240 41fc 	movw	r1, #1276	; 0x4fc
   2109a:	4638      	mov	r0, r7
   2109c:	f00b fa40 	bl	2c520 <assert_post_action>
   210a0:	e7d3      	b.n	2104a <spi_nrfx_init+0xb6>
	const struct gpio_driver_api *api =
   210a2:	68a3      	ldr	r3, [r4, #8]
	return api->port_clear_bits_raw(port, pins);
   210a4:	691b      	ldr	r3, [r3, #16]
   210a6:	4631      	mov	r1, r6
   210a8:	4620      	mov	r0, r4
   210aa:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
   210ac:	e7d5      	b.n	2105a <spi_nrfx_init+0xc6>
		ctx->owner = NULL;
   210ae:	606b      	str	r3, [r5, #4]
		k_sem_give(&ctx->lock);
   210b0:	f105 0010 	add.w	r0, r5, #16
	z_impl_k_sem_give(sem);
   210b4:	f005 ff6e 	bl	26f94 <z_impl_k_sem_give>
}
   210b8:	e7d1      	b.n	2105e <spi_nrfx_init+0xca>
   210ba:	bf00      	nop
   210bc:	0003b5b8 	.word	0x0003b5b8
   210c0:	00031600 	.word	0x00031600
   210c4:	000315cc 	.word	0x000315cc

000210c8 <baudrate_set>:
#endif
};

static inline NRF_UARTE_Type *get_uarte_instance(const struct device *dev)
{
	const struct uarte_nrfx_config *config = dev->config;
   210c8:	6843      	ldr	r3, [r0, #4]

	return config->uarte_regs;
   210ca:	681a      	ldr	r2, [r3, #0]
static int baudrate_set(const struct device *dev, uint32_t baudrate)
{
	nrf_uarte_baudrate_t nrf_baudrate; /* calculated baudrate divisor */
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);

	switch (baudrate) {
   210cc:	f5b1 4f16 	cmp.w	r1, #38400	; 0x9600
   210d0:	d06f      	beq.n	211b2 <baudrate_set+0xea>
   210d2:	d83a      	bhi.n	2114a <baudrate_set+0x82>
   210d4:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
   210d8:	d06e      	beq.n	211b8 <baudrate_set+0xf0>
   210da:	d90a      	bls.n	210f2 <baudrate_set+0x2a>
   210dc:	f5b1 4fe1 	cmp.w	r1, #28800	; 0x7080
   210e0:	d075      	beq.n	211ce <baudrate_set+0x106>
   210e2:	d924      	bls.n	2112e <baudrate_set+0x66>
   210e4:	f647 2312 	movw	r3, #31250	; 0x7a12
   210e8:	4299      	cmp	r1, r3
   210ea:	d12b      	bne.n	21144 <baudrate_set+0x7c>
		break;
	case 28800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
		break;
	case 31250:
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   210ec:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   210f0:	e013      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   210f2:	f5b1 6f96 	cmp.w	r1, #1200	; 0x4b0
   210f6:	d061      	beq.n	211bc <baudrate_set+0xf4>
   210f8:	d907      	bls.n	2110a <baudrate_set+0x42>
   210fa:	f5b1 6f16 	cmp.w	r1, #2400	; 0x960
   210fe:	d063      	beq.n	211c8 <baudrate_set+0x100>
   21100:	f5b1 5f96 	cmp.w	r1, #4800	; 0x12c0
   21104:	d110      	bne.n	21128 <baudrate_set+0x60>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   21106:	4b3c      	ldr	r3, [pc, #240]	; (211f8 <baudrate_set+0x130>)
   21108:	e007      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   2110a:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
   2110e:	d058      	beq.n	211c2 <baudrate_set+0xfa>
   21110:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
   21114:	d105      	bne.n	21122 <baudrate_set+0x5a>
		nrf_baudrate = 0x00027000;
   21116:	f44f 331c 	mov.w	r3, #159744	; 0x27000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   2111a:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
		return -EINVAL;
	}

	nrf_uarte_baudrate_set(uarte, nrf_baudrate);

	return 0;
   2111e:	2000      	movs	r0, #0
   21120:	4770      	bx	lr
	switch (baudrate) {
   21122:	f06f 0015 	mvn.w	r0, #21
   21126:	4770      	bx	lr
   21128:	f06f 0015 	mvn.w	r0, #21
   2112c:	4770      	bx	lr
   2112e:	f5b1 5f61 	cmp.w	r1, #14400	; 0x3840
   21132:	d04e      	beq.n	211d2 <baudrate_set+0x10a>
   21134:	f5b1 4f96 	cmp.w	r1, #19200	; 0x4b00
   21138:	d101      	bne.n	2113e <baudrate_set+0x76>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   2113a:	4b30      	ldr	r3, [pc, #192]	; (211fc <baudrate_set+0x134>)
   2113c:	e7ed      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   2113e:	f06f 0015 	mvn.w	r0, #21
   21142:	4770      	bx	lr
   21144:	f06f 0015 	mvn.w	r0, #21
   21148:	4770      	bx	lr
   2114a:	f5b1 3f61 	cmp.w	r1, #230400	; 0x38400
   2114e:	d042      	beq.n	211d6 <baudrate_set+0x10e>
   21150:	d909      	bls.n	21166 <baudrate_set+0x9e>
   21152:	f5b1 2f61 	cmp.w	r1, #921600	; 0xe1000
   21156:	d046      	beq.n	211e6 <baudrate_set+0x11e>
   21158:	d91f      	bls.n	2119a <baudrate_set+0xd2>
   2115a:	4b29      	ldr	r3, [pc, #164]	; (21200 <baudrate_set+0x138>)
   2115c:	4299      	cmp	r1, r3
   2115e:	d148      	bne.n	211f2 <baudrate_set+0x12a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   21160:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   21164:	e7d9      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   21166:	f5b1 3f96 	cmp.w	r1, #76800	; 0x12c00
   2116a:	d037      	beq.n	211dc <baudrate_set+0x114>
   2116c:	d905      	bls.n	2117a <baudrate_set+0xb2>
   2116e:	f5b1 3fe1 	cmp.w	r1, #115200	; 0x1c200
   21172:	d10f      	bne.n	21194 <baudrate_set+0xcc>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   21174:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   21178:	e7cf      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   2117a:	f64d 23c0 	movw	r3, #56000	; 0xdac0
   2117e:	4299      	cmp	r1, r3
   21180:	d02e      	beq.n	211e0 <baudrate_set+0x118>
   21182:	f5b1 4f61 	cmp.w	r1, #57600	; 0xe100
   21186:	d102      	bne.n	2118e <baudrate_set+0xc6>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   21188:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   2118c:	e7c5      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   2118e:	f06f 0015 	mvn.w	r0, #21
   21192:	4770      	bx	lr
   21194:	f06f 0015 	mvn.w	r0, #21
   21198:	4770      	bx	lr
   2119a:	4b1a      	ldr	r3, [pc, #104]	; (21204 <baudrate_set+0x13c>)
   2119c:	4299      	cmp	r1, r3
   2119e:	d025      	beq.n	211ec <baudrate_set+0x124>
   211a0:	f5b1 2fe1 	cmp.w	r1, #460800	; 0x70800
   211a4:	d102      	bne.n	211ac <baudrate_set+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   211a6:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   211aa:	e7b6      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   211ac:	f06f 0015 	mvn.w	r0, #21
   211b0:	4770      	bx	lr
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   211b2:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   211b6:	e7b0      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   211b8:	4b13      	ldr	r3, [pc, #76]	; (21208 <baudrate_set+0x140>)
   211ba:	e7ae      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   211bc:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   211c0:	e7ab      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   211c2:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   211c6:	e7a8      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   211c8:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   211cc:	e7a5      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   211ce:	4b0f      	ldr	r3, [pc, #60]	; (2120c <baudrate_set+0x144>)
   211d0:	e7a3      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   211d2:	4b0f      	ldr	r3, [pc, #60]	; (21210 <baudrate_set+0x148>)
   211d4:	e7a1      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   211d6:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   211da:	e79e      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   211dc:	4b0d      	ldr	r3, [pc, #52]	; (21214 <baudrate_set+0x14c>)
   211de:	e79c      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   211e0:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   211e4:	e799      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   211e6:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   211ea:	e796      	b.n	2111a <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   211ec:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   211f0:	e793      	b.n	2111a <baudrate_set+0x52>
	switch (baudrate) {
   211f2:	f06f 0015 	mvn.w	r0, #21
}
   211f6:	4770      	bx	lr
   211f8:	0013b000 	.word	0x0013b000
   211fc:	004ea000 	.word	0x004ea000
   21200:	000f4240 	.word	0x000f4240
   21204:	0003d090 	.word	0x0003d090
   21208:	00275000 	.word	0x00275000
   2120c:	0075c000 	.word	0x0075c000
   21210:	003af000 	.word	0x003af000
   21214:	013a9000 	.word	0x013a9000

00021218 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   21218:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2121c:	4605      	mov	r5, r0
   2121e:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = dev->data;
   21220:	f8d0 8010 	ldr.w	r8, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   21224:	f00f fb72 	bl	3090c <k_is_in_isr>
   21228:	b920      	cbnz	r0, 21234 <uarte_nrfx_poll_out+0x1c>
	return !z_sys_post_kernel;
   2122a:	4b17      	ldr	r3, [pc, #92]	; (21288 <uarte_nrfx_poll_out+0x70>)
   2122c:	781b      	ldrb	r3, [r3, #0]
   2122e:	b143      	cbz	r3, 21242 <uarte_nrfx_poll_out+0x2a>
   21230:	2300      	movs	r3, #0
   21232:	e000      	b.n	21236 <uarte_nrfx_poll_out+0x1e>
   21234:	2301      	movs	r3, #1

		t = now;
	}
#endif

	if (isr_mode) {
   21236:	b953      	cbnz	r3, 2124e <uarte_nrfx_poll_out+0x36>
			}

			irq_unlock(key);
		}
	} else {
		key = wait_tx_ready(dev);
   21238:	4628      	mov	r0, r5
   2123a:	f00e faba 	bl	2f7b2 <wait_tx_ready>
   2123e:	4606      	mov	r6, r0
   21240:	e013      	b.n	2126a <uarte_nrfx_poll_out+0x52>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   21242:	2301      	movs	r3, #1
   21244:	e7f7      	b.n	21236 <uarte_nrfx_poll_out+0x1e>
   21246:	f384 8811 	msr	BASEPRI, r4
   2124a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2124e:	f04f 0340 	mov.w	r3, #64	; 0x40
   21252:	f3ef 8411 	mrs	r4, BASEPRI
   21256:	f383 8812 	msr	BASEPRI_MAX, r3
   2125a:	f3bf 8f6f 	isb	sy
   2125e:	4626      	mov	r6, r4
			if (is_tx_ready(dev)) {
   21260:	4628      	mov	r0, r5
   21262:	f00e fa3f 	bl	2f6e4 <is_tx_ready>
   21266:	2800      	cmp	r0, #0
   21268:	d0ed      	beq.n	21246 <uarte_nrfx_poll_out+0x2e>
	}

	*data->char_out = c;
   2126a:	f8d8 3010 	ldr.w	r3, [r8, #16]
   2126e:	701f      	strb	r7, [r3, #0]
	tx_start(dev, data->char_out, 1);
   21270:	2201      	movs	r2, #1
   21272:	f8d8 1010 	ldr.w	r1, [r8, #16]
   21276:	4628      	mov	r0, r5
   21278:	f00e fac2 	bl	2f800 <tx_start>
	__asm__ volatile(
   2127c:	f386 8811 	msr	BASEPRI, r6
   21280:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
   21284:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21288:	20004713 	.word	0x20004713

0002128c <endtx_stoptx_ppi_init>:
#endif /* UARTE_INTERRUPT_DRIVEN */
};

static int endtx_stoptx_ppi_init(NRF_UARTE_Type *uarte,
				 struct uarte_nrfx_data *data)
{
   2128c:	b538      	push	{r3, r4, r5, lr}
   2128e:	4604      	mov	r4, r0
   21290:	460d      	mov	r5, r1
	nrfx_err_t ret;

	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   21292:	f101 0018 	add.w	r0, r1, #24
   21296:	f002 fdfb 	bl	23e90 <nrfx_ppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   2129a:	4b0e      	ldr	r3, [pc, #56]	; (212d4 <endtx_stoptx_ppi_init+0x48>)
   2129c:	4298      	cmp	r0, r3
   2129e:	d111      	bne.n	212c4 <endtx_stoptx_ppi_init+0x38>
		LOG_ERR("Failed to allocate PPI Channel");
		return -EIO;
	}

	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
   212a0:	7e2b      	ldrb	r3, [r5, #24]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
   212a2:	f504 7190 	add.w	r1, r4, #288	; 0x120
    return (uint32_t)p_reg + (uint32_t)task;
   212a6:	340c      	adds	r4, #12
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   212a8:	4a0b      	ldr	r2, [pc, #44]	; (212d8 <endtx_stoptx_ppi_init+0x4c>)
   212aa:	33a2      	adds	r3, #162	; 0xa2
   212ac:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
    p_reg->CH[(uint32_t) channel].TEP = tep;
   212b0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   212b4:	605c      	str	r4, [r3, #4]
		nrf_uarte_event_address_get(uarte, NRF_UARTE_EVENT_ENDTX),
		nrf_uarte_task_address_get(uarte, NRF_UARTE_TASK_STOPTX));
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   212b6:	7e29      	ldrb	r1, [r5, #24]
   212b8:	2301      	movs	r3, #1
   212ba:	408b      	lsls	r3, r1
    p_reg->CHENSET = mask;
   212bc:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504

	return 0;
   212c0:	2000      	movs	r0, #0
}
   212c2:	bd38      	pop	{r3, r4, r5, pc}
		LOG_ERR("Failed to allocate PPI Channel");
   212c4:	2145      	movs	r1, #69	; 0x45
   212c6:	4805      	ldr	r0, [pc, #20]	; (212dc <endtx_stoptx_ppi_init+0x50>)
   212c8:	f00b f940 	bl	2c54c <z_log_minimal_printk>
		return -EIO;
   212cc:	f06f 0004 	mvn.w	r0, #4
   212d0:	e7f7      	b.n	212c2 <endtx_stoptx_ppi_init+0x36>
   212d2:	bf00      	nop
   212d4:	0bad0000 	.word	0x0bad0000
   212d8:	4001f000 	.word	0x4001f000
   212dc:	0003b6dc 	.word	0x0003b6dc

000212e0 <random_byte_get>:
	__asm__ volatile(
   212e0:	f04f 0340 	mov.w	r3, #64	; 0x40
   212e4:	f3ef 8211 	mrs	r2, BASEPRI
   212e8:	f383 8812 	msr	BASEPRI_MAX, r3
   212ec:	f3bf 8f6f 	isb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)rng_event);
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   212f0:	4b0a      	ldr	r3, [pc, #40]	; (2131c <random_byte_get+0x3c>)
   212f2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   212f6:	b16b      	cbz	r3, 21314 <random_byte_get+0x34>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   212f8:	4b08      	ldr	r3, [pc, #32]	; (2131c <random_byte_get+0x3c>)
   212fa:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
		retval = nrf_rng_random_value_get(NRF_RNG);
   212fe:	b2c0      	uxtb	r0, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   21300:	2100      	movs	r1, #0
   21302:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   21306:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
	__asm__ volatile(
   2130a:	f382 8811 	msr	BASEPRI, r2
   2130e:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
   21312:	4770      	bx	lr
	int retval = -EAGAIN;
   21314:	f06f 000a 	mvn.w	r0, #10
   21318:	e7f7      	b.n	2130a <random_byte_get+0x2a>
   2131a:	bf00      	nop
   2131c:	4000d000 	.word	0x4000d000

00021320 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static uint16_t rng_pool_get(struct rng_pool *rngp, uint8_t *buf, uint16_t len)
{
   21320:	b5f0      	push	{r4, r5, r6, r7, lr}
   21322:	4686      	mov	lr, r0
	uint32_t last  = rngp->last;
   21324:	7885      	ldrb	r5, [r0, #2]
	uint32_t mask  = rngp->mask;
   21326:	78c4      	ldrb	r4, [r0, #3]
	__asm__ volatile(
   21328:	f04f 0340 	mov.w	r3, #64	; 0x40
   2132c:	f3ef 8c11 	mrs	ip, BASEPRI
   21330:	f383 8812 	msr	BASEPRI_MAX, r3
   21334:	f3bf 8f6f 	isb	sy
	uint32_t first, available;
	uint32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   21338:	7806      	ldrb	r6, [r0, #0]
   2133a:	4633      	mov	r3, r6
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   2133c:	7847      	ldrb	r7, [r0, #1]

	available = (last - first) & mask;
   2133e:	1bad      	subs	r5, r5, r6
   21340:	4025      	ands	r5, r4
	if (available < len) {
   21342:	42aa      	cmp	r2, r5
   21344:	d900      	bls.n	21348 <rng_pool_get+0x28>
		len = available;
   21346:	b2aa      	uxth	r2, r5

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   21348:	18b0      	adds	r0, r6, r2
   2134a:	4020      	ands	r0, r4
   2134c:	f88e 0000 	strb.w	r0, [lr]
	__asm__ volatile(
   21350:	f38c 8811 	msr	BASEPRI, ip
   21354:	f3bf 8f6f 	isb	sy
	uint8_t *dst   = buf;
   21358:	4608      	mov	r0, r1
}
   2135a:	e007      	b.n	2136c <rng_pool_get+0x4c>
	irq_unlock(key);

	while (likely(len--)) {
		*dst++ = rngp->buffer[first];
   2135c:	eb0e 0203 	add.w	r2, lr, r3
   21360:	7952      	ldrb	r2, [r2, #5]
   21362:	f800 2b01 	strb.w	r2, [r0], #1
		first = (first + 1) & mask;
   21366:	3301      	adds	r3, #1
   21368:	4023      	ands	r3, r4
	while (likely(len--)) {
   2136a:	4662      	mov	r2, ip
   2136c:	f102 3cff 	add.w	ip, r2, #4294967295	; 0xffffffff
   21370:	fa1f fc8c 	uxth.w	ip, ip
   21374:	2a00      	cmp	r2, #0
   21376:	d1f1      	bne.n	2135c <rng_pool_get+0x3c>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   21378:	42be      	cmp	r6, r7
   2137a:	d10f      	bne.n	2139c <rng_pool_get+0x7c>
	__asm__ volatile(
   2137c:	f04f 0240 	mov.w	r2, #64	; 0x40
   21380:	f3ef 8311 	mrs	r3, BASEPRI
   21384:	f382 8812 	msr	BASEPRI_MAX, r2
   21388:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   2138c:	f89e 2000 	ldrb.w	r2, [lr]
   21390:	f88e 2001 	strb.w	r2, [lr, #1]
	__asm__ volatile(
   21394:	f383 8811 	msr	BASEPRI, r3
   21398:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
   2139c:	1a40      	subs	r0, r0, r1
   2139e:	b280      	uxth	r0, r0
	available = available - len;
   213a0:	1a2d      	subs	r5, r5, r0
	if (available <= rngp->threshold) {
   213a2:	f89e 3004 	ldrb.w	r3, [lr, #4]
   213a6:	42ab      	cmp	r3, r5
   213a8:	d302      	bcc.n	213b0 <rng_pool_get+0x90>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   213aa:	4b02      	ldr	r3, [pc, #8]	; (213b4 <rng_pool_get+0x94>)
   213ac:	2201      	movs	r2, #1
   213ae:	601a      	str	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   213b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   213b2:	bf00      	nop
   213b4:	4000d000 	.word	0x4000d000

000213b8 <entropy_nrf5_get_entropy_isr>:
}

static int entropy_nrf5_get_entropy_isr(const struct device *dev,
					uint8_t *buf, uint16_t len,
					uint32_t flags)
{
   213b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   213ba:	460e      	mov	r6, r1
   213bc:	4614      	mov	r4, r2
   213be:	461d      	mov	r5, r3
	uint16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
   213c0:	6902      	ldr	r2, [r0, #16]
   213c2:	4b2d      	ldr	r3, [pc, #180]	; (21478 <entropy_nrf5_get_entropy_isr+0xc0>)
   213c4:	429a      	cmp	r2, r3
   213c6:	d00b      	beq.n	213e0 <entropy_nrf5_get_entropy_isr+0x28>
   213c8:	4f2c      	ldr	r7, [pc, #176]	; (2147c <entropy_nrf5_get_entropy_isr+0xc4>)
   213ca:	f240 1205 	movw	r2, #261	; 0x105
   213ce:	4639      	mov	r1, r7
   213d0:	482b      	ldr	r0, [pc, #172]	; (21480 <entropy_nrf5_get_entropy_isr+0xc8>)
   213d2:	f00b f8ac 	bl	2c52e <assert_print>
   213d6:	f240 1105 	movw	r1, #261	; 0x105
   213da:	4638      	mov	r0, r7
   213dc:	f00b f8a0 	bl	2c520 <assert_post_action>

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   213e0:	f015 0f01 	tst.w	r5, #1
   213e4:	d105      	bne.n	213f2 <entropy_nrf5_get_entropy_isr+0x3a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   213e6:	4622      	mov	r2, r4
   213e8:	4631      	mov	r1, r6
   213ea:	4826      	ldr	r0, [pc, #152]	; (21484 <entropy_nrf5_get_entropy_isr+0xcc>)
   213ec:	f7ff ff98 	bl	21320 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
   213f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (len) {
   213f2:	b90c      	cbnz	r4, 213f8 <entropy_nrf5_get_entropy_isr+0x40>
	return cnt;
   213f4:	4620      	mov	r0, r4
   213f6:	e7fb      	b.n	213f0 <entropy_nrf5_get_entropy_isr+0x38>
	__asm__ volatile(
   213f8:	f04f 0340 	mov.w	r3, #64	; 0x40
   213fc:	f3ef 8511 	mrs	r5, BASEPRI
   21400:	f383 8812 	msr	BASEPRI_MAX, r3
   21404:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
   21408:	200d      	movs	r0, #13
   2140a:	f7f6 ff67 	bl	182dc <arch_irq_is_enabled>
   2140e:	4607      	mov	r7, r0
		irq_disable(IRQN);
   21410:	200d      	movs	r0, #13
   21412:	f7f6 ff4f 	bl	182b4 <arch_irq_disable>
	__asm__ volatile(
   21416:	f385 8811 	msr	BASEPRI, r5
   2141a:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   2141e:	4b1a      	ldr	r3, [pc, #104]	; (21488 <entropy_nrf5_get_entropy_isr+0xd0>)
   21420:	2200      	movs	r2, #0
   21422:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   21426:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   2142a:	2201      	movs	r2, #1
   2142c:	601a      	str	r2, [r3, #0]
   2142e:	4b17      	ldr	r3, [pc, #92]	; (2148c <entropy_nrf5_get_entropy_isr+0xd4>)
   21430:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   21434:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   21438:	4625      	mov	r5, r4
   2143a:	e004      	b.n	21446 <entropy_nrf5_get_entropy_isr+0x8e>
   2143c:	f3bf 8f4f 	dsb	sy
				__WFE();
   21440:	bf20      	wfe
				__SEV();
   21442:	bf40      	sev
				__WFE();
   21444:	bf20      	wfe
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   21446:	4b10      	ldr	r3, [pc, #64]	; (21488 <entropy_nrf5_get_entropy_isr+0xd0>)
   21448:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
			while (!nrf_rng_event_check(NRF_RNG,
   2144c:	2b00      	cmp	r3, #0
   2144e:	d0f5      	beq.n	2143c <entropy_nrf5_get_entropy_isr+0x84>
			byte = random_byte_get();
   21450:	f7ff ff46 	bl	212e0 <random_byte_get>
   21454:	4b0d      	ldr	r3, [pc, #52]	; (2148c <entropy_nrf5_get_entropy_isr+0xd4>)
   21456:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   2145a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
			if (byte < 0) {
   2145e:	2800      	cmp	r0, #0
   21460:	db02      	blt.n	21468 <entropy_nrf5_get_entropy_isr+0xb0>
			buf[--len] = byte;
   21462:	3d01      	subs	r5, #1
   21464:	b2ad      	uxth	r5, r5
   21466:	5570      	strb	r0, [r6, r5]
		} while (len);
   21468:	2d00      	cmp	r5, #0
   2146a:	d1ec      	bne.n	21446 <entropy_nrf5_get_entropy_isr+0x8e>
		if (irq_enabled) {
   2146c:	2f00      	cmp	r7, #0
   2146e:	d0c1      	beq.n	213f4 <entropy_nrf5_get_entropy_isr+0x3c>
			irq_enable(IRQN);
   21470:	200d      	movs	r0, #13
   21472:	f7f6 ff11 	bl	18298 <arch_irq_enable>
   21476:	e7bd      	b.n	213f4 <entropy_nrf5_get_entropy_isr+0x3c>
   21478:	20003d78 	.word	0x20003d78
   2147c:	0003b770 	.word	0x0003b770
   21480:	00031600 	.word	0x00031600
   21484:	20003da8 	.word	0x20003da8
   21488:	4000d000 	.word	0x4000d000
   2148c:	e000e100 	.word	0xe000e100

00021490 <isr>:
{
   21490:	b510      	push	{r4, lr}
	byte = random_byte_get();
   21492:	f7ff ff25 	bl	212e0 <random_byte_get>
	if (byte < 0) {
   21496:	2800      	cmp	r0, #0
   21498:	db06      	blt.n	214a8 <isr+0x18>
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   2149a:	b2c4      	uxtb	r4, r0
   2149c:	4621      	mov	r1, r4
   2149e:	480a      	ldr	r0, [pc, #40]	; (214c8 <isr+0x38>)
   214a0:	f00e fab6 	bl	2fa10 <rng_pool_put>
	if (ret < 0) {
   214a4:	2800      	cmp	r0, #0
   214a6:	db00      	blt.n	214aa <isr+0x1a>
}
   214a8:	bd10      	pop	{r4, pc}
		ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.thr),
   214aa:	4621      	mov	r1, r4
   214ac:	4807      	ldr	r0, [pc, #28]	; (214cc <isr+0x3c>)
   214ae:	f00e faaf 	bl	2fa10 <rng_pool_put>
		if (ret < 0) {
   214b2:	2800      	cmp	r0, #0
   214b4:	db03      	blt.n	214be <isr+0x2e>
	z_impl_k_sem_give(sem);
   214b6:	4806      	ldr	r0, [pc, #24]	; (214d0 <isr+0x40>)
   214b8:	f005 fd6c 	bl	26f94 <z_impl_k_sem_give>
}
   214bc:	e7f4      	b.n	214a8 <isr+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   214be:	4b05      	ldr	r3, [pc, #20]	; (214d4 <isr+0x44>)
   214c0:	2201      	movs	r2, #1
   214c2:	605a      	str	r2, [r3, #4]
}
   214c4:	e7f7      	b.n	214b6 <isr+0x26>
   214c6:	bf00      	nop
   214c8:	20003da8 	.word	0x20003da8
   214cc:	20003dbd 	.word	0x20003dbd
   214d0:	20003d90 	.word	0x20003d90
   214d4:	4000d000 	.word	0x4000d000

000214d8 <entropy_nrf5_get_entropy>:
{
   214d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   214da:	460f      	mov	r7, r1
   214dc:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
   214de:	6902      	ldr	r2, [r0, #16]
   214e0:	4b18      	ldr	r3, [pc, #96]	; (21544 <entropy_nrf5_get_entropy+0x6c>)
   214e2:	429a      	cmp	r2, r3
   214e4:	d012      	beq.n	2150c <entropy_nrf5_get_entropy+0x34>
   214e6:	4d18      	ldr	r5, [pc, #96]	; (21548 <entropy_nrf5_get_entropy+0x70>)
   214e8:	22e7      	movs	r2, #231	; 0xe7
   214ea:	4629      	mov	r1, r5
   214ec:	4817      	ldr	r0, [pc, #92]	; (2154c <entropy_nrf5_get_entropy+0x74>)
   214ee:	f00b f81e 	bl	2c52e <assert_print>
   214f2:	21e7      	movs	r1, #231	; 0xe7
   214f4:	4628      	mov	r0, r5
   214f6:	f00b f813 	bl	2c520 <assert_post_action>
   214fa:	e007      	b.n	2150c <entropy_nrf5_get_entropy+0x34>
	return z_impl_k_sem_take(sem, timeout);
   214fc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21500:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21504:	f106 0018 	add.w	r0, r6, #24
   21508:	f005 fd84 	bl	27014 <z_impl_k_sem_take>
	while (len) {
   2150c:	b1bc      	cbz	r4, 2153e <entropy_nrf5_get_entropy+0x66>
   2150e:	4e0d      	ldr	r6, [pc, #52]	; (21544 <entropy_nrf5_get_entropy+0x6c>)
   21510:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   21514:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21518:	4630      	mov	r0, r6
   2151a:	f005 fd7b 	bl	27014 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   2151e:	4622      	mov	r2, r4
   21520:	4639      	mov	r1, r7
   21522:	f106 0045 	add.w	r0, r6, #69	; 0x45
   21526:	f7ff fefb 	bl	21320 <rng_pool_get>
   2152a:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   2152c:	4630      	mov	r0, r6
   2152e:	f005 fd31 	bl	26f94 <z_impl_k_sem_give>
		if (bytes == 0U) {
   21532:	2d00      	cmp	r5, #0
   21534:	d0e2      	beq.n	214fc <entropy_nrf5_get_entropy+0x24>
		len -= bytes;
   21536:	1b64      	subs	r4, r4, r5
   21538:	b2a4      	uxth	r4, r4
		buf += bytes;
   2153a:	442f      	add	r7, r5
   2153c:	e7e6      	b.n	2150c <entropy_nrf5_get_entropy+0x34>
}
   2153e:	2000      	movs	r0, #0
   21540:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   21542:	bf00      	nop
   21544:	20003d78 	.word	0x20003d78
   21548:	0003b770 	.word	0x0003b770
   2154c:	00031600 	.word	0x00031600

00021550 <entropy_nrf5_init>:
		    &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(const struct device *dev)
{
   21550:	b510      	push	{r4, lr}
	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == dev->data);
   21552:	6902      	ldr	r2, [r0, #16]
   21554:	4b1f      	ldr	r3, [pc, #124]	; (215d4 <entropy_nrf5_init+0x84>)
   21556:	429a      	cmp	r2, r3
   21558:	d00b      	beq.n	21572 <entropy_nrf5_init+0x22>
   2155a:	4c1f      	ldr	r4, [pc, #124]	; (215d8 <entropy_nrf5_init+0x88>)
   2155c:	f44f 72aa 	mov.w	r2, #340	; 0x154
   21560:	4621      	mov	r1, r4
   21562:	481e      	ldr	r0, [pc, #120]	; (215dc <entropy_nrf5_init+0x8c>)
   21564:	f00a ffe3 	bl	2c52e <assert_print>
   21568:	f44f 71aa 	mov.w	r1, #340	; 0x154
   2156c:	4620      	mov	r0, r4
   2156e:	f00a ffd7 	bl	2c520 <assert_post_action>
	return z_impl_k_sem_init(sem, initial_count, limit);
   21572:	4c18      	ldr	r4, [pc, #96]	; (215d4 <entropy_nrf5_init+0x84>)
   21574:	2201      	movs	r2, #1
   21576:	4611      	mov	r1, r2
   21578:	4620      	mov	r0, r4
   2157a:	f00f fa54 	bl	30a26 <z_impl_k_sem_init>
   2157e:	2201      	movs	r2, #1
   21580:	2100      	movs	r1, #0
   21582:	f104 0018 	add.w	r0, r4, #24
   21586:	f00f fa4e 	bl	30a26 <z_impl_k_sem_init>
	k_sem_init(&entropy_nrf5_data.sem_lock, 1, 1);

	/* Synching semaphore */
	k_sem_init(&entropy_nrf5_data.sem_sync, 0, 1);

	rng_pool_init((struct rng_pool *)(entropy_nrf5_data.thr),
   2158a:	2204      	movs	r2, #4
   2158c:	2108      	movs	r1, #8
   2158e:	f104 0045 	add.w	r0, r4, #69	; 0x45
   21592:	f00e fa51 	bl	2fa38 <rng_pool_init>
		      CONFIG_ENTROPY_NRF5_THR_POOL_SIZE,
		      CONFIG_ENTROPY_NRF5_THR_THRESHOLD);
	rng_pool_init((struct rng_pool *)(entropy_nrf5_data.isr),
   21596:	220c      	movs	r2, #12
   21598:	2110      	movs	r1, #16
   2159a:	f104 0030 	add.w	r0, r4, #48	; 0x30
   2159e:	f00e fa4b 	bl	2fa38 <rng_pool_init>
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
}

NRF_STATIC_INLINE void nrf_rng_error_correction_disable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG &= ~RNG_CONFIG_DERCEN_Msk;
   215a2:	4b0f      	ldr	r3, [pc, #60]	; (215e0 <entropy_nrf5_init+0x90>)
   215a4:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   215a8:	f022 0201 	bic.w	r2, r2, #1
   215ac:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   215b0:	2400      	movs	r4, #0
   215b2:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
   215b6:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   215ba:	2101      	movs	r1, #1
   215bc:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   215c0:	6019      	str	r1, [r3, #0]

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
   215c2:	4622      	mov	r2, r4
   215c4:	200d      	movs	r0, #13
   215c6:	f7f6 fe97 	bl	182f8 <z_arm_irq_priority_set>
	irq_enable(IRQN);
   215ca:	200d      	movs	r0, #13
   215cc:	f7f6 fe64 	bl	18298 <arch_irq_enable>

	return 0;
}
   215d0:	4620      	mov	r0, r4
   215d2:	bd10      	pop	{r4, pc}
   215d4:	20003d78 	.word	0x20003d78
   215d8:	0003b770 	.word	0x0003b770
   215dc:	00031600 	.word	0x00031600
   215e0:	4000d000 	.word	0x4000d000

000215e4 <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(int32_t chan, uint32_t cyc)
{
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   215e4:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
   215e8:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   215ec:	4b01      	ldr	r3, [pc, #4]	; (215f4 <set_comparator+0x10>)
   215ee:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
}
   215f2:	4770      	bx	lr
   215f4:	40011000 	.word	0x40011000

000215f8 <get_comparator>:
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   215f8:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   215fc:	4b01      	ldr	r3, [pc, #4]	; (21604 <get_comparator+0xc>)
   215fe:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

static uint32_t get_comparator(int32_t chan)
{
	return nrf_rtc_cc_get(RTC, chan);
}
   21602:	4770      	bx	lr
   21604:	40011000 	.word	0x40011000

00021608 <event_enable>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
}

static void event_enable(int32_t chan)
{
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   21608:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   2160c:	4083      	lsls	r3, r0
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   2160e:	4a02      	ldr	r2, [pc, #8]	; (21618 <event_enable+0x10>)
   21610:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
}
   21614:	4770      	bx	lr
   21616:	bf00      	nop
   21618:	40011000 	.word	0x40011000

0002161c <event_disable>:

static void event_disable(int32_t chan)
{
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   2161c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   21620:	4083      	lsls	r3, r0
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   21622:	4a02      	ldr	r2, [pc, #8]	; (2162c <event_disable+0x10>)
   21624:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
}
   21628:	4770      	bx	lr
   2162a:	bf00      	nop
   2162c:	40011000 	.word	0x40011000

00021630 <counter>:
     return p_reg->COUNTER;
   21630:	4b01      	ldr	r3, [pc, #4]	; (21638 <counter+0x8>)
   21632:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

static uint32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
   21636:	4770      	bx	lr
   21638:	40011000 	.word	0x40011000

0002163c <compare_int_lock>:
	return 0;
#endif
}

static bool compare_int_lock(int32_t chan)
{
   2163c:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   2163e:	2301      	movs	r3, #1
   21640:	4083      	lsls	r3, r0
   21642:	ea6f 0c03 	mvn.w	ip, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   21646:	4a10      	ldr	r2, [pc, #64]	; (21688 <compare_int_lock+0x4c>)
   21648:	f3bf 8f5b 	dmb	ish
   2164c:	e852 1f00 	ldrex	r1, [r2]
   21650:	ea01 0e0c 	and.w	lr, r1, ip
   21654:	e842 e400 	strex	r4, lr, [r2]
   21658:	2c00      	cmp	r4, #0
   2165a:	d1f7      	bne.n	2164c <compare_int_lock+0x10>
   2165c:	f3bf 8f5b 	dmb	ish

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   21660:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   21664:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   21668:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   2166c:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
   21670:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
  __ASM volatile ("dmb 0xF":::"memory");
   21674:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   21678:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   2167c:	420b      	tst	r3, r1
}
   2167e:	bf14      	ite	ne
   21680:	2001      	movne	r0, #1
   21682:	2000      	moveq	r0, #0
   21684:	bd10      	pop	{r4, pc}
   21686:	bf00      	nop
   21688:	20003dd0 	.word	0x20003dd0

0002168c <channel_processing_check_and_clear>:
		event_enable(chan);
	}
}

static bool channel_processing_check_and_clear(int32_t chan)
{
   2168c:	b570      	push	{r4, r5, r6, lr}
   2168e:	4604      	mov	r4, r0
	bool result = false;

	uint32_t mcu_critical_state = full_int_lock();
   21690:	f00e f9fe 	bl	2fa90 <full_int_lock>
   21694:	4605      	mov	r5, r0

	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   21696:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   2169a:	40a3      	lsls	r3, r4
    return p_reg->INTENSET & mask;
   2169c:	4a17      	ldr	r2, [pc, #92]	; (216fc <channel_processing_check_and_clear+0x70>)
   2169e:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
   216a2:	4213      	tst	r3, r2
   216a4:	d105      	bne.n	216b2 <channel_processing_check_and_clear+0x26>
	bool result = false;
   216a6:	2600      	movs	r6, #0
		if (result) {
			event_clear(chan);
		}
	}

	full_int_unlock(mcu_critical_state);
   216a8:	4628      	mov	r0, r5
   216aa:	f00e f9f5 	bl	2fa98 <full_int_unlock>

	return result;
}
   216ae:	4630      	mov	r0, r6
   216b0:	bd70      	pop	{r4, r5, r6, pc}
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   216b2:	2301      	movs	r3, #1
   216b4:	40a3      	lsls	r3, r4
   216b6:	43db      	mvns	r3, r3
   216b8:	4a11      	ldr	r2, [pc, #68]	; (21700 <channel_processing_check_and_clear+0x74>)
   216ba:	f3bf 8f5b 	dmb	ish
   216be:	e852 1f00 	ldrex	r1, [r2]
   216c2:	ea01 0003 	and.w	r0, r1, r3
   216c6:	e842 0600 	strex	r6, r0, [r2]
   216ca:	2e00      	cmp	r6, #0
   216cc:	d1f7      	bne.n	216be <channel_processing_check_and_clear+0x32>
   216ce:	f3bf 8f5b 	dmb	ish
   216d2:	b959      	cbnz	r1, 216ec <channel_processing_check_and_clear+0x60>
			 nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   216d4:	f104 0350 	add.w	r3, r4, #80	; 0x50
   216d8:	009b      	lsls	r3, r3, #2
   216da:	b29b      	uxth	r3, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   216dc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   216e0:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
   216e4:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   216e6:	b113      	cbz	r3, 216ee <channel_processing_check_and_clear+0x62>
   216e8:	2301      	movs	r3, #1
   216ea:	e000      	b.n	216ee <channel_processing_check_and_clear+0x62>
   216ec:	2301      	movs	r3, #1
		if (result) {
   216ee:	461e      	mov	r6, r3
   216f0:	2b00      	cmp	r3, #0
   216f2:	d0d9      	beq.n	216a8 <channel_processing_check_and_clear+0x1c>
			event_clear(chan);
   216f4:	4620      	mov	r0, r4
   216f6:	f00e f9bc 	bl	2fa72 <event_clear>
   216fa:	e7d5      	b.n	216a8 <channel_processing_check_and_clear+0x1c>
   216fc:	40011000 	.word	0x40011000
   21700:	20003dcc 	.word	0x20003dcc

00021704 <compare_int_unlock>:
	if (key) {
   21704:	b901      	cbnz	r1, 21708 <compare_int_unlock+0x4>
}
   21706:	4770      	bx	lr
		atomic_or(&int_mask, BIT(chan));
   21708:	2301      	movs	r3, #1
   2170a:	4083      	lsls	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2170c:	4a11      	ldr	r2, [pc, #68]	; (21754 <compare_int_unlock+0x50>)
   2170e:	f3bf 8f5b 	dmb	ish
   21712:	e852 1f00 	ldrex	r1, [r2]
   21716:	4319      	orrs	r1, r3
   21718:	e842 1c00 	strex	ip, r1, [r2]
   2171c:	f1bc 0f00 	cmp.w	ip, #0
   21720:	d1f7      	bne.n	21712 <compare_int_unlock+0xe>
   21722:	f3bf 8f5b 	dmb	ish
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   21726:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   2172a:	4083      	lsls	r3, r0
    p_reg->INTENSET = mask;
   2172c:	4a0a      	ldr	r2, [pc, #40]	; (21758 <compare_int_unlock+0x54>)
   2172e:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   21732:	f3bf 8f5b 	dmb	ish
   21736:	4b09      	ldr	r3, [pc, #36]	; (2175c <compare_int_unlock+0x58>)
   21738:	681b      	ldr	r3, [r3, #0]
   2173a:	f3bf 8f5b 	dmb	ish
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   2173e:	fa23 f000 	lsr.w	r0, r3, r0
   21742:	f010 0f01 	tst.w	r0, #1
   21746:	d0de      	beq.n	21706 <compare_int_unlock+0x2>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   21748:	4b05      	ldr	r3, [pc, #20]	; (21760 <compare_int_unlock+0x5c>)
   2174a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   2174e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   21752:	e7d8      	b.n	21706 <compare_int_unlock+0x2>
   21754:	20003dd0 	.word	0x20003dd0
   21758:	40011000 	.word	0x40011000
   2175c:	20003dcc 	.word	0x20003dcc
   21760:	e000e100 	.word	0xe000e100

00021764 <sys_clock_timeout_handler>:
{
   21764:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   21768:	4607      	mov	r7, r0
   2176a:	4614      	mov	r4, r2
   2176c:	461e      	mov	r6, r3
	uint32_t cc_value = absolute_time_to_cc(expire_time);
   2176e:	4610      	mov	r0, r2
   21770:	4619      	mov	r1, r3
   21772:	f00e f98a 	bl	2fa8a <absolute_time_to_cc>
   21776:	4605      	mov	r5, r0
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   21778:	4b15      	ldr	r3, [pc, #84]	; (217d0 <sys_clock_timeout_handler+0x6c>)
   2177a:	681a      	ldr	r2, [r3, #0]
   2177c:	1aa0      	subs	r0, r4, r2
	last_count += dticks * CYC_PER_TICK;
   2177e:	601c      	str	r4, [r3, #0]
   21780:	605e      	str	r6, [r3, #4]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   21782:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   21786:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   2178a:	d309      	bcc.n	217a0 <sys_clock_timeout_handler+0x3c>
	return false;
   2178c:	2400      	movs	r4, #0
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   2178e:	f007 fe53 	bl	29438 <sys_clock_announce>
	if (cc_value == get_comparator(chan)) {
   21792:	4638      	mov	r0, r7
   21794:	f7ff ff30 	bl	215f8 <get_comparator>
   21798:	42a8      	cmp	r0, r5
   2179a:	d00e      	beq.n	217ba <sys_clock_timeout_handler+0x56>
}
   2179c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   217a0:	4b0c      	ldr	r3, [pc, #48]	; (217d4 <sys_clock_timeout_handler+0x70>)
   217a2:	681b      	ldr	r3, [r3, #0]
   217a4:	0a1a      	lsrs	r2, r3, #8
   217a6:	061b      	lsls	r3, r3, #24
   217a8:	eb15 0803 	adds.w	r8, r5, r3
   217ac:	f142 0900 	adc.w	r9, r2, #0
   217b0:	4b09      	ldr	r3, [pc, #36]	; (217d8 <sys_clock_timeout_handler+0x74>)
   217b2:	e9c3 8900 	strd	r8, r9, [r3]
		return true;
   217b6:	2401      	movs	r4, #1
   217b8:	e7e9      	b.n	2178e <sys_clock_timeout_handler+0x2a>
		if (!anchor_updated) {
   217ba:	b11c      	cbz	r4, 217c4 <sys_clock_timeout_handler+0x60>
		event_enable(chan);
   217bc:	4638      	mov	r0, r7
   217be:	f7ff ff23 	bl	21608 <event_enable>
}
   217c2:	e7eb      	b.n	2179c <sys_clock_timeout_handler+0x38>
			set_comparator(chan, COUNTER_HALF_SPAN);
   217c4:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
   217c8:	4638      	mov	r0, r7
   217ca:	f7ff ff0b 	bl	215e4 <set_comparator>
   217ce:	e7f5      	b.n	217bc <sys_clock_timeout_handler+0x58>
   217d0:	20002408 	.word	0x20002408
   217d4:	20003dd4 	.word	0x20003dd4
   217d8:	200023f0 	.word	0x200023f0

000217dc <z_nrf_rtc_timer_read>:
{
   217dc:	b538      	push	{r3, r4, r5, lr}
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   217de:	4b0d      	ldr	r3, [pc, #52]	; (21814 <z_nrf_rtc_timer_read+0x38>)
   217e0:	681c      	ldr	r4, [r3, #0]
   217e2:	0a25      	lsrs	r5, r4, #8
   217e4:	0624      	lsls	r4, r4, #24
  __ASM volatile ("dmb 0xF":::"memory");
   217e6:	f3bf 8f5f 	dmb	sy
	uint32_t cntr = counter();
   217ea:	f7ff ff21 	bl	21630 <counter>
   217ee:	4603      	mov	r3, r0
	val += cntr;
   217f0:	1900      	adds	r0, r0, r4
   217f2:	f145 0100 	adc.w	r1, r5, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   217f6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   217fa:	d20a      	bcs.n	21812 <z_nrf_rtc_timer_read+0x36>
		if (val < anchor) {
   217fc:	4b06      	ldr	r3, [pc, #24]	; (21818 <z_nrf_rtc_timer_read+0x3c>)
   217fe:	e9d3 2300 	ldrd	r2, r3, [r3]
   21802:	4290      	cmp	r0, r2
   21804:	eb71 0303 	sbcs.w	r3, r1, r3
   21808:	d203      	bcs.n	21812 <z_nrf_rtc_timer_read+0x36>
			val += COUNTER_SPAN;
   2180a:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   2180e:	f141 0100 	adc.w	r1, r1, #0
}
   21812:	bd38      	pop	{r3, r4, r5, pc}
   21814:	20003dd4 	.word	0x20003dd4
   21818:	200023f0 	.word	0x200023f0

0002181c <compare_set_nolocks>:
{
   2181c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2181e:	4606      	mov	r6, r0
   21820:	4614      	mov	r4, r2
   21822:	461d      	mov	r5, r3
	uint32_t cc_value = absolute_time_to_cc(target_time);
   21824:	4610      	mov	r0, r2
   21826:	4619      	mov	r1, r3
   21828:	f00e f92f 	bl	2fa8a <absolute_time_to_cc>
   2182c:	4607      	mov	r7, r0
	uint64_t curr_time = z_nrf_rtc_timer_read();
   2182e:	f7ff ffd5 	bl	217dc <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   21832:	42a0      	cmp	r0, r4
   21834:	eb71 0305 	sbcs.w	r3, r1, r5
   21838:	d21d      	bcs.n	21876 <compare_set_nolocks+0x5a>
		if (target_time - curr_time > COUNTER_SPAN) {
   2183a:	1a23      	subs	r3, r4, r0
   2183c:	eb65 0101 	sbc.w	r1, r5, r1
   21840:	4a1b      	ldr	r2, [pc, #108]	; (218b0 <compare_set_nolocks+0x94>)
   21842:	4293      	cmp	r3, r2
   21844:	f171 0300 	sbcs.w	r3, r1, #0
   21848:	d22f      	bcs.n	218aa <compare_set_nolocks+0x8e>
		if (target_time != cc_data[chan].target_time) {
   2184a:	4b1a      	ldr	r3, [pc, #104]	; (218b4 <compare_set_nolocks+0x98>)
   2184c:	eb03 1306 	add.w	r3, r3, r6, lsl #4
   21850:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   21854:	42ab      	cmp	r3, r5
   21856:	bf08      	it	eq
   21858:	42a2      	cmpeq	r2, r4
   2185a:	d01a      	beq.n	21892 <compare_set_nolocks+0x76>
			uint32_t cc_set = set_absolute_alarm(chan, cc_value);
   2185c:	4639      	mov	r1, r7
   2185e:	4630      	mov	r0, r6
   21860:	f00e f91d 	bl	2fa9e <set_absolute_alarm>
			target_time += counter_sub(cc_set, cc_value);
   21864:	4639      	mov	r1, r7
   21866:	f00e f900 	bl	2fa6a <counter_sub>
   2186a:	1900      	adds	r0, r0, r4
   2186c:	f145 0300 	adc.w	r3, r5, #0
   21870:	4604      	mov	r4, r0
   21872:	461d      	mov	r5, r3
   21874:	e00d      	b.n	21892 <compare_set_nolocks+0x76>
		atomic_or(&force_isr_mask, BIT(chan));
   21876:	2301      	movs	r3, #1
   21878:	40b3      	lsls	r3, r6
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2187a:	4a0f      	ldr	r2, [pc, #60]	; (218b8 <compare_set_nolocks+0x9c>)
   2187c:	f3bf 8f5b 	dmb	ish
   21880:	e852 1f00 	ldrex	r1, [r2]
   21884:	4319      	orrs	r1, r3
   21886:	e842 1000 	strex	r0, r1, [r2]
   2188a:	2800      	cmp	r0, #0
   2188c:	d1f8      	bne.n	21880 <compare_set_nolocks+0x64>
   2188e:	f3bf 8f5b 	dmb	ish
	cc_data[chan].target_time = target_time;
   21892:	4b08      	ldr	r3, [pc, #32]	; (218b4 <compare_set_nolocks+0x98>)
   21894:	0132      	lsls	r2, r6, #4
   21896:	eb03 1606 	add.w	r6, r3, r6, lsl #4
   2189a:	e9c6 4502 	strd	r4, r5, [r6, #8]
	cc_data[chan].callback = handler;
   2189e:	9906      	ldr	r1, [sp, #24]
   218a0:	5099      	str	r1, [r3, r2]
	cc_data[chan].user_context = user_data;
   218a2:	9b07      	ldr	r3, [sp, #28]
   218a4:	6073      	str	r3, [r6, #4]
	return ret;
   218a6:	2000      	movs	r0, #0
}
   218a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return -EINVAL;
   218aa:	f06f 0015 	mvn.w	r0, #21
   218ae:	e7fb      	b.n	218a8 <compare_set_nolocks+0x8c>
   218b0:	01000001 	.word	0x01000001
   218b4:	200023f8 	.word	0x200023f8
   218b8:	20003dcc 	.word	0x20003dcc

000218bc <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   218bc:	b530      	push	{r4, r5, lr}
   218be:	b083      	sub	sp, #12
    p_reg->PRESCALER = val;
   218c0:	2300      	movs	r3, #0
   218c2:	4a1d      	ldr	r2, [pc, #116]	; (21938 <sys_clock_driver_init+0x7c>)
   218c4:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   218c8:	2b00      	cmp	r3, #0
   218ca:	dd24      	ble.n	21916 <sys_clock_driver_init+0x5a>
    p_reg->INTENSET = mask;
   218cc:	4c1a      	ldr	r4, [pc, #104]	; (21938 <sys_clock_driver_init+0x7c>)
   218ce:	2502      	movs	r5, #2
   218d0:	f8c4 5304 	str.w	r5, [r4, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   218d4:	4b19      	ldr	r3, [pc, #100]	; (2193c <sys_clock_driver_init+0x80>)
   218d6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   218da:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   218de:	2200      	movs	r2, #0
   218e0:	2101      	movs	r1, #1
   218e2:	2011      	movs	r0, #17
   218e4:	f7f6 fd08 	bl	182f8 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   218e8:	2011      	movs	r0, #17
   218ea:	f7f6 fcd5 	bl	18298 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   218ee:	2301      	movs	r3, #1
   218f0:	60a3      	str	r3, [r4, #8]
   218f2:	6023      	str	r3, [r4, #0]

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   218f4:	4a12      	ldr	r2, [pc, #72]	; (21940 <sys_clock_driver_init+0x84>)
   218f6:	6013      	str	r3, [r2, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   218f8:	2400      	movs	r4, #0
   218fa:	9401      	str	r4, [sp, #4]
   218fc:	4b11      	ldr	r3, [pc, #68]	; (21944 <sys_clock_driver_init+0x88>)
   218fe:	9300      	str	r3, [sp, #0]
   21900:	4a11      	ldr	r2, [pc, #68]	; (21948 <sys_clock_driver_init+0x8c>)
   21902:	2300      	movs	r3, #0
   21904:	4620      	mov	r0, r4
   21906:	f00e f905 	bl	2fb14 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   2190a:	4628      	mov	r0, r5
   2190c:	f7fd fe1e 	bl	1f54c <z_nrf_clock_control_lf_on>

	return 0;
}
   21910:	4620      	mov	r0, r4
   21912:	b003      	add	sp, #12
   21914:	bd30      	pop	{r4, r5, pc}
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   21916:	4a0d      	ldr	r2, [pc, #52]	; (2194c <sys_clock_driver_init+0x90>)
   21918:	eb02 1203 	add.w	r2, r2, r3, lsl #4
   2191c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   21920:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   21924:	e9c2 0102 	strd	r0, r1, [r2, #8]
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   21928:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2192c:	409a      	lsls	r2, r3
    p_reg->INTENSET = mask;
   2192e:	4902      	ldr	r1, [pc, #8]	; (21938 <sys_clock_driver_init+0x7c>)
   21930:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   21934:	3301      	adds	r3, #1
   21936:	e7c7      	b.n	218c8 <sys_clock_driver_init+0xc>
   21938:	40011000 	.word	0x40011000
   2193c:	e000e100 	.word	0xe000e100
   21940:	20003dd0 	.word	0x20003dd0
   21944:	00021765 	.word	0x00021765
   21948:	007fffff 	.word	0x007fffff
   2194c:	200023f8 	.word	0x200023f8

00021950 <process_channel>:
{
   21950:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21954:	b082      	sub	sp, #8
   21956:	4604      	mov	r4, r0
	if (channel_processing_check_and_clear(chan)) {
   21958:	f7ff fe98 	bl	2168c <channel_processing_check_and_clear>
   2195c:	b910      	cbnz	r0, 21964 <process_channel+0x14>
}
   2195e:	b002      	add	sp, #8
   21960:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_time = z_nrf_rtc_timer_read();
   21964:	f7ff ff3a 	bl	217dc <z_nrf_rtc_timer_read>
   21968:	4682      	mov	sl, r0
   2196a:	460e      	mov	r6, r1
		mcu_critical_state = full_int_lock();
   2196c:	f00e f890 	bl	2fa90 <full_int_lock>
   21970:	4605      	mov	r5, r0
		expire_time = cc_data[chan].target_time;
   21972:	4b13      	ldr	r3, [pc, #76]	; (219c0 <process_channel+0x70>)
   21974:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   21978:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   2197c:	45c2      	cmp	sl, r8
   2197e:	eb76 0309 	sbcs.w	r3, r6, r9
   21982:	d20b      	bcs.n	2199c <process_channel+0x4c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   21984:	2600      	movs	r6, #0
		full_int_unlock(mcu_critical_state);
   21986:	4628      	mov	r0, r5
   21988:	f00e f886 	bl	2fa98 <full_int_unlock>
		if (handler) {
   2198c:	2e00      	cmp	r6, #0
   2198e:	d0e6      	beq.n	2195e <process_channel+0xe>
			handler(chan, expire_time, user_context);
   21990:	9700      	str	r7, [sp, #0]
   21992:	4642      	mov	r2, r8
   21994:	464b      	mov	r3, r9
   21996:	4620      	mov	r0, r4
   21998:	47b0      	blx	r6
}
   2199a:	e7e0      	b.n	2195e <process_channel+0xe>
			handler = cc_data[chan].callback;
   2199c:	4a08      	ldr	r2, [pc, #32]	; (219c0 <process_channel+0x70>)
   2199e:	0123      	lsls	r3, r4, #4
   219a0:	eb02 1104 	add.w	r1, r2, r4, lsl #4
   219a4:	58d6      	ldr	r6, [r2, r3]
			user_context = cc_data[chan].user_context;
   219a6:	684f      	ldr	r7, [r1, #4]
			cc_data[chan].callback = NULL;
   219a8:	2000      	movs	r0, #0
   219aa:	50d0      	str	r0, [r2, r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   219ac:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   219b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   219b4:	e9c1 2302 	strd	r2, r3, [r1, #8]
			event_disable(chan);
   219b8:	4620      	mov	r0, r4
   219ba:	f7ff fe2f 	bl	2161c <event_disable>
   219be:	e7e2      	b.n	21986 <process_channel+0x36>
   219c0:	200023f8 	.word	0x200023f8

000219c4 <rtc_nrf_isr>:
{
   219c4:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
   219c6:	4b0e      	ldr	r3, [pc, #56]	; (21a00 <rtc_nrf_isr+0x3c>)
   219c8:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   219cc:	f013 0f02 	tst.w	r3, #2
   219d0:	d00d      	beq.n	219ee <rtc_nrf_isr+0x2a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219d2:	4b0b      	ldr	r3, [pc, #44]	; (21a00 <rtc_nrf_isr+0x3c>)
   219d4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   219d8:	b14b      	cbz	r3, 219ee <rtc_nrf_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   219da:	4b09      	ldr	r3, [pc, #36]	; (21a00 <rtc_nrf_isr+0x3c>)
   219dc:	2200      	movs	r2, #0
   219de:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   219e2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		overflow_cnt++;
   219e6:	4a07      	ldr	r2, [pc, #28]	; (21a04 <rtc_nrf_isr+0x40>)
   219e8:	6813      	ldr	r3, [r2, #0]
   219ea:	3301      	adds	r3, #1
   219ec:	6013      	str	r3, [r2, #0]
{
   219ee:	2400      	movs	r4, #0
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   219f0:	2c00      	cmp	r4, #0
   219f2:	dd00      	ble.n	219f6 <rtc_nrf_isr+0x32>
}
   219f4:	bd10      	pop	{r4, pc}
		process_channel(chan);
   219f6:	4620      	mov	r0, r4
   219f8:	f7ff ffaa 	bl	21950 <process_channel>
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   219fc:	3401      	adds	r4, #1
   219fe:	e7f7      	b.n	219f0 <rtc_nrf_isr+0x2c>
   21a00:	40011000 	.word	0x40011000
   21a04:	20003dd4 	.word	0x20003dd4

00021a08 <sys_clock_set_timeout>:
{
   21a08:	b510      	push	{r4, lr}
   21a0a:	b082      	sub	sp, #8
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   21a0c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   21a10:	d006      	beq.n	21a20 <sys_clock_set_timeout+0x18>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   21a12:	2801      	cmp	r0, #1
   21a14:	dd06      	ble.n	21a24 <sys_clock_set_timeout+0x1c>
   21a16:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   21a1a:	da05      	bge.n	21a28 <sys_clock_set_timeout+0x20>
   21a1c:	1e44      	subs	r4, r0, #1
   21a1e:	e004      	b.n	21a2a <sys_clock_set_timeout+0x22>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   21a20:	480f      	ldr	r0, [pc, #60]	; (21a60 <sys_clock_set_timeout+0x58>)
   21a22:	e7f8      	b.n	21a16 <sys_clock_set_timeout+0xe>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   21a24:	2400      	movs	r4, #0
   21a26:	e000      	b.n	21a2a <sys_clock_set_timeout+0x22>
   21a28:	4c0d      	ldr	r4, [pc, #52]	; (21a60 <sys_clock_set_timeout+0x58>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   21a2a:	f7ff fed7 	bl	217dc <z_nrf_rtc_timer_read>
   21a2e:	4b0d      	ldr	r3, [pc, #52]	; (21a64 <sys_clock_set_timeout+0x5c>)
   21a30:	6819      	ldr	r1, [r3, #0]
   21a32:	685b      	ldr	r3, [r3, #4]
   21a34:	1a40      	subs	r0, r0, r1
	if (unannounced >= COUNTER_HALF_SPAN) {
   21a36:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   21a3a:	d300      	bcc.n	21a3e <sys_clock_set_timeout+0x36>
		ticks = 0;
   21a3c:	2400      	movs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   21a3e:	4420      	add	r0, r4
   21a40:	1c42      	adds	r2, r0, #1
	if (cyc > MAX_CYCLES) {
   21a42:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   21a46:	d300      	bcc.n	21a4a <sys_clock_set_timeout+0x42>
		cyc = MAX_CYCLES;
   21a48:	4a05      	ldr	r2, [pc, #20]	; (21a60 <sys_clock_set_timeout+0x58>)
	uint64_t target_time = cyc + last_count;
   21a4a:	2000      	movs	r0, #0
   21a4c:	188a      	adds	r2, r1, r2
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   21a4e:	9001      	str	r0, [sp, #4]
   21a50:	4905      	ldr	r1, [pc, #20]	; (21a68 <sys_clock_set_timeout+0x60>)
   21a52:	9100      	str	r1, [sp, #0]
   21a54:	f143 0300 	adc.w	r3, r3, #0
   21a58:	f00e f85c 	bl	2fb14 <compare_set>
}
   21a5c:	b002      	add	sp, #8
   21a5e:	bd10      	pop	{r4, pc}
   21a60:	007fffff 	.word	0x007fffff
   21a64:	20002408 	.word	0x20002408
   21a68:	00021765 	.word	0x00021765

00021a6c <sys_clock_elapsed>:
{
   21a6c:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   21a6e:	f7ff feb5 	bl	217dc <z_nrf_rtc_timer_read>
   21a72:	4b02      	ldr	r3, [pc, #8]	; (21a7c <sys_clock_elapsed+0x10>)
   21a74:	681b      	ldr	r3, [r3, #0]
}
   21a76:	1ac0      	subs	r0, r0, r3
   21a78:	bd08      	pop	{r3, pc}
   21a7a:	bf00      	nop
   21a7c:	20002408 	.word	0x20002408

00021a80 <nrf_pin_configure>:
 */
__unused static void nrf_pin_configure(pinctrl_soc_pin_t pin,
				       nrf_gpio_pin_dir_t dir,
				       nrf_gpio_pin_input_t input,
				       nrf_gpio_pin_drive_t drive)
{
   21a80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   21a84:	460c      	mov	r4, r1
   21a86:	4615      	mov	r5, r2
   21a88:	461f      	mov	r7, r3
	/* force input direction and disconnected buffer for low power */
	if (NRF_GET_LP(pin) == NRF_LP_ENABLE) {
   21a8a:	f410 5f80 	tst.w	r0, #4096	; 0x1000
   21a8e:	d001      	beq.n	21a94 <nrf_pin_configure+0x14>
		dir = NRF_GPIO_PIN_DIR_INPUT;
		input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   21a90:	2501      	movs	r5, #1
		dir = NRF_GPIO_PIN_DIR_INPUT;
   21a92:	2400      	movs	r4, #0
	}

	nrf_gpio_cfg(NRF_GET_PIN(pin), dir, input, NRF_GET_PULL(pin), drive,
   21a94:	f000 083f 	and.w	r8, r0, #63	; 0x3f
   21a98:	f3c0 1981 	ubfx	r9, r0, #6, #2
    switch (port)
   21a9c:	f010 0f20 	tst.w	r0, #32
   21aa0:	d019      	beq.n	21ad6 <nrf_pin_configure+0x56>
    uint32_t mask = 0;
   21aa2:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   21aa4:	f008 021f 	and.w	r2, r8, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21aa8:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21aaa:	f013 0f01 	tst.w	r3, #1
   21aae:	d015      	beq.n	21adc <nrf_pin_configure+0x5c>
    *p_pin = pin_number & 0x1F;
   21ab0:	f008 061f 	and.w	r6, r8, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21ab4:	ea5f 1358 	movs.w	r3, r8, lsr #5
   21ab8:	d11d      	bne.n	21af6 <nrf_pin_configure+0x76>
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21aba:	ea44 0445 	orr.w	r4, r4, r5, lsl #1
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
   21abe:	ea44 0489 	orr.w	r4, r4, r9, lsl #2
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21ac2:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
    reg->PIN_CNF[pin_number] = cnf;
   21ac6:	f506 76e0 	add.w	r6, r6, #448	; 0x1c0
   21aca:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21ace:	f842 4026 	str.w	r4, [r2, r6, lsl #2]
		     NRF_GPIO_PIN_NOSENSE);
}
   21ad2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            mask = P0_FEATURE_PINS_PRESENT;
   21ad6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21ada:	e7e3      	b.n	21aa4 <nrf_pin_configure+0x24>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21adc:	4e0d      	ldr	r6, [pc, #52]	; (21b14 <nrf_pin_configure+0x94>)
   21ade:	f240 2247 	movw	r2, #583	; 0x247
   21ae2:	4631      	mov	r1, r6
   21ae4:	480c      	ldr	r0, [pc, #48]	; (21b18 <nrf_pin_configure+0x98>)
   21ae6:	f00a fd22 	bl	2c52e <assert_print>
   21aea:	f240 2147 	movw	r1, #583	; 0x247
   21aee:	4630      	mov	r0, r6
   21af0:	f00a fd16 	bl	2c520 <assert_post_action>
   21af4:	e7dc      	b.n	21ab0 <nrf_pin_configure+0x30>
            NRFX_ASSERT(0);
   21af6:	f8df 801c 	ldr.w	r8, [pc, #28]	; 21b14 <nrf_pin_configure+0x94>
   21afa:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21afe:	4641      	mov	r1, r8
   21b00:	4805      	ldr	r0, [pc, #20]	; (21b18 <nrf_pin_configure+0x98>)
   21b02:	f00a fd14 	bl	2c52e <assert_print>
   21b06:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21b0a:	4640      	mov	r0, r8
   21b0c:	f00a fd08 	bl	2c520 <assert_post_action>
   21b10:	e7d3      	b.n	21aba <nrf_pin_configure+0x3a>
   21b12:	bf00      	nop
   21b14:	0003b084 	.word	0x0003b084
   21b18:	00031600 	.word	0x00031600

00021b1c <pinctrl_configure_pins>:

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
   21b1c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21b20:	4605      	mov	r5, r0
   21b22:	4688      	mov	r8, r1
   21b24:	4691      	mov	r9, r2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   21b26:	2400      	movs	r4, #0
   21b28:	e025      	b.n	21b76 <pinctrl_configure_pins+0x5a>
		__unused nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);

		switch (NRF_GET_FUN(pins[i])) {
#if defined(NRF_PSEL_UART)
		case NRF_FUN_UART_TX:
			NRF_PSEL_UART(reg, TXD) = NRF_GET_PIN(pins[i]);
   21b2a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21b2e:	f8c9 350c 	str.w	r3, [r9, #1292]	; 0x50c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 1);
   21b32:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21b36:	f003 0a3f 	and.w	sl, r3, #63	; 0x3f
    switch (port)
   21b3a:	f013 0f20 	tst.w	r3, #32
   21b3e:	d101      	bne.n	21b44 <pinctrl_configure_pins+0x28>
            mask = P0_FEATURE_PINS_PRESENT;
   21b40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   21b44:	f00a 031f 	and.w	r3, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21b48:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21b4a:	f012 0f01 	tst.w	r2, #1
   21b4e:	d055      	beq.n	21bfc <pinctrl_configure_pins+0xe0>
    *p_pin = pin_number & 0x1F;
   21b50:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21b54:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21b58:	d15e      	bne.n	21c18 <pinctrl_configure_pins+0xfc>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   21b5a:	2101      	movs	r1, #1
   21b5c:	fa01 f30b 	lsl.w	r3, r1, fp
    p_reg->OUTSET = set_mask;
   21b60:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21b64:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   21b68:	4633      	mov	r3, r6
   21b6a:	460a      	mov	r2, r1
   21b6c:	59e8      	ldr	r0, [r5, r7]
   21b6e:	f7ff ff87 	bl	21a80 <nrf_pin_configure>
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   21b72:	3401      	adds	r4, #1
   21b74:	b2e4      	uxtb	r4, r4
   21b76:	4544      	cmp	r4, r8
   21b78:	f080 835b 	bcs.w	22232 <pinctrl_configure_pins+0x716>
		__unused nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   21b7c:	00a7      	lsls	r7, r4, #2
   21b7e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21b82:	f3c3 2603 	ubfx	r6, r3, #8, #4
		switch (NRF_GET_FUN(pins[i])) {
   21b86:	0c1a      	lsrs	r2, r3, #16
   21b88:	2a19      	cmp	r2, #25
   21b8a:	f200 8354 	bhi.w	22236 <pinctrl_configure_pins+0x71a>
   21b8e:	a101      	add	r1, pc, #4	; (adr r1, 21b94 <pinctrl_configure_pins+0x78>)
   21b90:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   21b94:	00021b2b 	.word	0x00021b2b
   21b98:	00021c35 	.word	0x00021c35
   21b9c:	00021c4d 	.word	0x00021c4d
   21ba0:	00021cd3 	.word	0x00021cd3
   21ba4:	00021ceb 	.word	0x00021ceb
   21ba8:	00021d71 	.word	0x00021d71
   21bac:	00021df7 	.word	0x00021df7
   21bb0:	00022237 	.word	0x00022237
   21bb4:	00022237 	.word	0x00022237
   21bb8:	00022237 	.word	0x00022237
   21bbc:	00022237 	.word	0x00022237
   21bc0:	00021e0f 	.word	0x00021e0f
   21bc4:	00021e29 	.word	0x00021e29
   21bc8:	00022237 	.word	0x00022237
   21bcc:	00022237 	.word	0x00022237
   21bd0:	00022237 	.word	0x00022237
   21bd4:	00022237 	.word	0x00022237
   21bd8:	00022237 	.word	0x00022237
   21bdc:	00022237 	.word	0x00022237
   21be0:	00022237 	.word	0x00022237
   21be4:	00022237 	.word	0x00022237
   21be8:	00022237 	.word	0x00022237
   21bec:	00021e43 	.word	0x00021e43
   21bf0:	00021f45 	.word	0x00021f45
   21bf4:	0002203f 	.word	0x0002203f
   21bf8:	00022139 	.word	0x00022139
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21bfc:	f8df b340 	ldr.w	fp, [pc, #832]	; 21f40 <pinctrl_configure_pins+0x424>
   21c00:	f240 2247 	movw	r2, #583	; 0x247
   21c04:	4659      	mov	r1, fp
   21c06:	48cd      	ldr	r0, [pc, #820]	; (21f3c <pinctrl_configure_pins+0x420>)
   21c08:	f00a fc91 	bl	2c52e <assert_print>
   21c0c:	f240 2147 	movw	r1, #583	; 0x247
   21c10:	4658      	mov	r0, fp
   21c12:	f00a fc85 	bl	2c520 <assert_post_action>
   21c16:	e79b      	b.n	21b50 <pinctrl_configure_pins+0x34>
            NRFX_ASSERT(0);
   21c18:	f8df a324 	ldr.w	sl, [pc, #804]	; 21f40 <pinctrl_configure_pins+0x424>
   21c1c:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21c20:	4651      	mov	r1, sl
   21c22:	48c6      	ldr	r0, [pc, #792]	; (21f3c <pinctrl_configure_pins+0x420>)
   21c24:	f00a fc83 	bl	2c52e <assert_print>
   21c28:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21c2c:	4650      	mov	r0, sl
   21c2e:	f00a fc77 	bl	2c520 <assert_post_action>
   21c32:	e792      	b.n	21b5a <pinctrl_configure_pins+0x3e>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
		case NRF_FUN_UART_RX:
			NRF_PSEL_UART(reg, RXD) = NRF_GET_PIN(pins[i]);
   21c34:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21c38:	f8c9 3514 	str.w	r3, [r9, #1300]	; 0x514
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   21c3c:	4633      	mov	r3, r6
   21c3e:	2200      	movs	r2, #0
   21c40:	4611      	mov	r1, r2
   21c42:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   21c46:	f7ff ff1b 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   21c4a:	e792      	b.n	21b72 <pinctrl_configure_pins+0x56>
		case NRF_FUN_UART_RTS:
			NRF_PSEL_UART(reg, RTS) = NRF_GET_PIN(pins[i]);
   21c4c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21c50:	f8c9 3508 	str.w	r3, [r9, #1288]	; 0x508
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 1);
   21c54:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21c58:	f003 0b3f 	and.w	fp, r3, #63	; 0x3f
    switch (port)
   21c5c:	f013 0f20 	tst.w	r3, #32
   21c60:	d018      	beq.n	21c94 <pinctrl_configure_pins+0x178>
    uint32_t mask = 0;
   21c62:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   21c64:	f00b 021f 	and.w	r2, fp, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21c68:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21c6a:	f013 0f01 	tst.w	r3, #1
   21c6e:	d014      	beq.n	21c9a <pinctrl_configure_pins+0x17e>
    *p_pin = pin_number & 0x1F;
   21c70:	f00b 0a1f 	and.w	sl, fp, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21c74:	ea5f 135b 	movs.w	r3, fp, lsr #5
   21c78:	d11d      	bne.n	21cb6 <pinctrl_configure_pins+0x19a>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   21c7a:	2101      	movs	r1, #1
   21c7c:	fa01 f30a 	lsl.w	r3, r1, sl
    p_reg->OUTSET = set_mask;
   21c80:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21c84:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   21c88:	4633      	mov	r3, r6
   21c8a:	460a      	mov	r2, r1
   21c8c:	59e8      	ldr	r0, [r5, r7]
   21c8e:	f7ff fef7 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   21c92:	e76e      	b.n	21b72 <pinctrl_configure_pins+0x56>
            mask = P0_FEATURE_PINS_PRESENT;
   21c94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21c98:	e7e4      	b.n	21c64 <pinctrl_configure_pins+0x148>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21c9a:	f8df a2a4 	ldr.w	sl, [pc, #676]	; 21f40 <pinctrl_configure_pins+0x424>
   21c9e:	f240 2247 	movw	r2, #583	; 0x247
   21ca2:	4651      	mov	r1, sl
   21ca4:	48a5      	ldr	r0, [pc, #660]	; (21f3c <pinctrl_configure_pins+0x420>)
   21ca6:	f00a fc42 	bl	2c52e <assert_print>
   21caa:	f240 2147 	movw	r1, #583	; 0x247
   21cae:	4650      	mov	r0, sl
   21cb0:	f00a fc36 	bl	2c520 <assert_post_action>
   21cb4:	e7dc      	b.n	21c70 <pinctrl_configure_pins+0x154>
            NRFX_ASSERT(0);
   21cb6:	f8df b288 	ldr.w	fp, [pc, #648]	; 21f40 <pinctrl_configure_pins+0x424>
   21cba:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21cbe:	4659      	mov	r1, fp
   21cc0:	489e      	ldr	r0, [pc, #632]	; (21f3c <pinctrl_configure_pins+0x420>)
   21cc2:	f00a fc34 	bl	2c52e <assert_print>
   21cc6:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21cca:	4658      	mov	r0, fp
   21ccc:	f00a fc28 	bl	2c520 <assert_post_action>
   21cd0:	e7d3      	b.n	21c7a <pinctrl_configure_pins+0x15e>
		case NRF_FUN_UART_CTS:
			NRF_PSEL_UART(reg, CTS) = NRF_GET_PIN(pins[i]);
   21cd2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21cd6:	f8c9 3510 	str.w	r3, [r9, #1296]	; 0x510
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   21cda:	4633      	mov	r3, r6
   21cdc:	2200      	movs	r2, #0
   21cde:	4611      	mov	r1, r2
   21ce0:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   21ce4:	f7ff fecc 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   21ce8:	e743      	b.n	21b72 <pinctrl_configure_pins+0x56>
#endif /* defined(NRF_PSEL_UART) */
#if defined(NRF_PSEL_SPIM)
		case NRF_FUN_SPIM_SCK:
			NRF_PSEL_SPIM(reg, SCK) = NRF_GET_PIN(pins[i]);
   21cea:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21cee:	f8c9 3508 	str.w	r3, [r9, #1288]	; 0x508
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 0);
   21cf2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21cf6:	f003 0b3f 	and.w	fp, r3, #63	; 0x3f
    switch (port)
   21cfa:	f013 0f20 	tst.w	r3, #32
   21cfe:	d018      	beq.n	21d32 <pinctrl_configure_pins+0x216>
    uint32_t mask = 0;
   21d00:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   21d02:	f00b 021f 	and.w	r2, fp, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21d06:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21d08:	f013 0f01 	tst.w	r3, #1
   21d0c:	d014      	beq.n	21d38 <pinctrl_configure_pins+0x21c>
    *p_pin = pin_number & 0x1F;
   21d0e:	f00b 0a1f 	and.w	sl, fp, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21d12:	ea5f 135b 	movs.w	r3, fp, lsr #5
   21d16:	d11d      	bne.n	21d54 <pinctrl_configure_pins+0x238>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21d18:	2101      	movs	r1, #1
   21d1a:	fa01 f30a 	lsl.w	r3, r1, sl
    p_reg->OUTCLR = clr_mask;
   21d1e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21d22:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   21d26:	4633      	mov	r3, r6
   21d28:	2200      	movs	r2, #0
   21d2a:	59e8      	ldr	r0, [r5, r7]
   21d2c:	f7ff fea8 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   21d30:	e71f      	b.n	21b72 <pinctrl_configure_pins+0x56>
            mask = P0_FEATURE_PINS_PRESENT;
   21d32:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21d36:	e7e4      	b.n	21d02 <pinctrl_configure_pins+0x1e6>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21d38:	f8df a204 	ldr.w	sl, [pc, #516]	; 21f40 <pinctrl_configure_pins+0x424>
   21d3c:	f240 2247 	movw	r2, #583	; 0x247
   21d40:	4651      	mov	r1, sl
   21d42:	487e      	ldr	r0, [pc, #504]	; (21f3c <pinctrl_configure_pins+0x420>)
   21d44:	f00a fbf3 	bl	2c52e <assert_print>
   21d48:	f240 2147 	movw	r1, #583	; 0x247
   21d4c:	4650      	mov	r0, sl
   21d4e:	f00a fbe7 	bl	2c520 <assert_post_action>
   21d52:	e7dc      	b.n	21d0e <pinctrl_configure_pins+0x1f2>
            NRFX_ASSERT(0);
   21d54:	f8df b1e8 	ldr.w	fp, [pc, #488]	; 21f40 <pinctrl_configure_pins+0x424>
   21d58:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21d5c:	4659      	mov	r1, fp
   21d5e:	4877      	ldr	r0, [pc, #476]	; (21f3c <pinctrl_configure_pins+0x420>)
   21d60:	f00a fbe5 	bl	2c52e <assert_print>
   21d64:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21d68:	4658      	mov	r0, fp
   21d6a:	f00a fbd9 	bl	2c520 <assert_post_action>
   21d6e:	e7d3      	b.n	21d18 <pinctrl_configure_pins+0x1fc>
		case NRF_FUN_SPIM_MOSI:
			NRF_PSEL_SPIM(reg, MOSI) = NRF_GET_PIN(pins[i]);
   21d70:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21d74:	f8c9 350c 	str.w	r3, [r9, #1292]	; 0x50c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 0);
   21d78:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21d7c:	f003 0b3f 	and.w	fp, r3, #63	; 0x3f
    switch (port)
   21d80:	f013 0f20 	tst.w	r3, #32
   21d84:	d018      	beq.n	21db8 <pinctrl_configure_pins+0x29c>
    uint32_t mask = 0;
   21d86:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   21d88:	f00b 021f 	and.w	r2, fp, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21d8c:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21d8e:	f013 0f01 	tst.w	r3, #1
   21d92:	d014      	beq.n	21dbe <pinctrl_configure_pins+0x2a2>
    *p_pin = pin_number & 0x1F;
   21d94:	f00b 0a1f 	and.w	sl, fp, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21d98:	ea5f 135b 	movs.w	r3, fp, lsr #5
   21d9c:	d11d      	bne.n	21dda <pinctrl_configure_pins+0x2be>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21d9e:	2101      	movs	r1, #1
   21da0:	fa01 f30a 	lsl.w	r3, r1, sl
    p_reg->OUTCLR = clr_mask;
   21da4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21da8:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   21dac:	4633      	mov	r3, r6
   21dae:	460a      	mov	r2, r1
   21db0:	59e8      	ldr	r0, [r5, r7]
   21db2:	f7ff fe65 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   21db6:	e6dc      	b.n	21b72 <pinctrl_configure_pins+0x56>
            mask = P0_FEATURE_PINS_PRESENT;
   21db8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21dbc:	e7e4      	b.n	21d88 <pinctrl_configure_pins+0x26c>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21dbe:	f8df a180 	ldr.w	sl, [pc, #384]	; 21f40 <pinctrl_configure_pins+0x424>
   21dc2:	f240 2247 	movw	r2, #583	; 0x247
   21dc6:	4651      	mov	r1, sl
   21dc8:	485c      	ldr	r0, [pc, #368]	; (21f3c <pinctrl_configure_pins+0x420>)
   21dca:	f00a fbb0 	bl	2c52e <assert_print>
   21dce:	f240 2147 	movw	r1, #583	; 0x247
   21dd2:	4650      	mov	r0, sl
   21dd4:	f00a fba4 	bl	2c520 <assert_post_action>
   21dd8:	e7dc      	b.n	21d94 <pinctrl_configure_pins+0x278>
            NRFX_ASSERT(0);
   21dda:	f8df b164 	ldr.w	fp, [pc, #356]	; 21f40 <pinctrl_configure_pins+0x424>
   21dde:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21de2:	4659      	mov	r1, fp
   21de4:	4855      	ldr	r0, [pc, #340]	; (21f3c <pinctrl_configure_pins+0x420>)
   21de6:	f00a fba2 	bl	2c52e <assert_print>
   21dea:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21dee:	4658      	mov	r0, fp
   21df0:	f00a fb96 	bl	2c520 <assert_post_action>
   21df4:	e7d3      	b.n	21d9e <pinctrl_configure_pins+0x282>
		case NRF_FUN_SPIM_MISO:
			NRF_PSEL_SPIM(reg, MISO) = NRF_GET_PIN(pins[i]);
   21df6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21dfa:	f8c9 3510 	str.w	r3, [r9, #1296]	; 0x510
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   21dfe:	4633      	mov	r3, r6
   21e00:	2200      	movs	r2, #0
   21e02:	4611      	mov	r1, r2
   21e04:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   21e08:	f7ff fe3a 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   21e0c:	e6b1      	b.n	21b72 <pinctrl_configure_pins+0x56>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
#endif /* defined(NRF_PSEL_SPIS) */
#if defined(NRF_PSEL_TWIM)
		case NRF_FUN_TWIM_SCL:
			NRF_PSEL_TWIM(reg, SCL) = NRF_GET_PIN(pins[i]);
   21e0e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21e12:	f8c9 3508 	str.w	r3, [r9, #1288]	; 0x508
			if (drive == NRF_DRIVE_S0S1) {
   21e16:	b906      	cbnz	r6, 21e1a <pinctrl_configure_pins+0x2fe>
				 * suitable for TWI/TWIM peripherals (S0D1).
				 * This drive cannot be used always so that
				 * users are able to select e.g. H0D1 or E0E1
				 * in devicetree.
				 */
				drive = NRF_DRIVE_S0D1;
   21e18:	2606      	movs	r6, #6
			}
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   21e1a:	4633      	mov	r3, r6
   21e1c:	2200      	movs	r2, #0
   21e1e:	4611      	mov	r1, r2
   21e20:	59e8      	ldr	r0, [r5, r7]
   21e22:	f7ff fe2d 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   21e26:	e6a4      	b.n	21b72 <pinctrl_configure_pins+0x56>
		case NRF_FUN_TWIM_SDA:
			NRF_PSEL_TWIM(reg, SDA) = NRF_GET_PIN(pins[i]);
   21e28:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21e2c:	f8c9 350c 	str.w	r3, [r9, #1292]	; 0x50c
			if (drive == NRF_DRIVE_S0S1) {
   21e30:	b906      	cbnz	r6, 21e34 <pinctrl_configure_pins+0x318>
				drive = NRF_DRIVE_S0D1;
   21e32:	2606      	movs	r6, #6
			}
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   21e34:	4633      	mov	r3, r6
   21e36:	2200      	movs	r2, #0
   21e38:	4611      	mov	r1, r2
   21e3a:	59e8      	ldr	r0, [r5, r7]
   21e3c:	f7ff fe20 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   21e40:	e697      	b.n	21b72 <pinctrl_configure_pins+0x56>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
#endif /* defined(NRF_PSEL_PDM) */
#if defined(NRF_PSEL_PWM)
		case NRF_FUN_PWM_OUT0:
			NRF_PSEL_PWM(reg, OUT[0]) = NRF_GET_PIN(pins[i]);
   21e42:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21e46:	f8c9 3560 	str.w	r3, [r9, #1376]	; 0x560
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   21e4a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21e4e:	f003 0a3f 	and.w	sl, r3, #63	; 0x3f
   21e52:	f3c3 3240 	ubfx	r2, r3, #13, #1
    if (value == 0)
   21e56:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   21e5a:	d139      	bne.n	21ed0 <pinctrl_configure_pins+0x3b4>
    switch (port)
   21e5c:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21e60:	d101      	bne.n	21e66 <pinctrl_configure_pins+0x34a>
            mask = P0_FEATURE_PINS_PRESENT;
   21e62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   21e66:	f00a 031f 	and.w	r3, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21e6a:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21e6c:	f012 0f01 	tst.w	r2, #1
   21e70:	d012      	beq.n	21e98 <pinctrl_configure_pins+0x37c>
    *p_pin = pin_number & 0x1F;
   21e72:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21e76:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21e7a:	d11b      	bne.n	21eb4 <pinctrl_configure_pins+0x398>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21e7c:	2301      	movs	r3, #1
   21e7e:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTCLR = clr_mask;
   21e82:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21e86:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   21e8a:	4633      	mov	r3, r6
   21e8c:	2201      	movs	r2, #1
   21e8e:	4611      	mov	r1, r2
   21e90:	59e8      	ldr	r0, [r5, r7]
   21e92:	f7ff fdf5 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   21e96:	e66c      	b.n	21b72 <pinctrl_configure_pins+0x56>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21e98:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 21f40 <pinctrl_configure_pins+0x424>
   21e9c:	f240 2247 	movw	r2, #583	; 0x247
   21ea0:	4659      	mov	r1, fp
   21ea2:	4826      	ldr	r0, [pc, #152]	; (21f3c <pinctrl_configure_pins+0x420>)
   21ea4:	f00a fb43 	bl	2c52e <assert_print>
   21ea8:	f240 2147 	movw	r1, #583	; 0x247
   21eac:	4658      	mov	r0, fp
   21eae:	f00a fb37 	bl	2c520 <assert_post_action>
   21eb2:	e7de      	b.n	21e72 <pinctrl_configure_pins+0x356>
            NRFX_ASSERT(0);
   21eb4:	f8df a088 	ldr.w	sl, [pc, #136]	; 21f40 <pinctrl_configure_pins+0x424>
   21eb8:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21ebc:	4651      	mov	r1, sl
   21ebe:	481f      	ldr	r0, [pc, #124]	; (21f3c <pinctrl_configure_pins+0x420>)
   21ec0:	f00a fb35 	bl	2c52e <assert_print>
   21ec4:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21ec8:	4650      	mov	r0, sl
   21eca:	f00a fb29 	bl	2c520 <assert_post_action>
   21ece:	e7d5      	b.n	21e7c <pinctrl_configure_pins+0x360>
    switch (port)
   21ed0:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21ed4:	d013      	beq.n	21efe <pinctrl_configure_pins+0x3e2>
    uint32_t mask = 0;
   21ed6:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   21ed8:	f00a 021f 	and.w	r2, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21edc:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21ede:	f013 0f01 	tst.w	r3, #1
   21ee2:	d00f      	beq.n	21f04 <pinctrl_configure_pins+0x3e8>
    *p_pin = pin_number & 0x1F;
   21ee4:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21ee8:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21eec:	d118      	bne.n	21f20 <pinctrl_configure_pins+0x404>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   21eee:	2301      	movs	r3, #1
   21ef0:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTSET = set_mask;
   21ef4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21ef8:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   21efc:	e7c5      	b.n	21e8a <pinctrl_configure_pins+0x36e>
            mask = P0_FEATURE_PINS_PRESENT;
   21efe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21f02:	e7e9      	b.n	21ed8 <pinctrl_configure_pins+0x3bc>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21f04:	f8df b038 	ldr.w	fp, [pc, #56]	; 21f40 <pinctrl_configure_pins+0x424>
   21f08:	f240 2247 	movw	r2, #583	; 0x247
   21f0c:	4659      	mov	r1, fp
   21f0e:	480b      	ldr	r0, [pc, #44]	; (21f3c <pinctrl_configure_pins+0x420>)
   21f10:	f00a fb0d 	bl	2c52e <assert_print>
   21f14:	f240 2147 	movw	r1, #583	; 0x247
   21f18:	4658      	mov	r0, fp
   21f1a:	f00a fb01 	bl	2c520 <assert_post_action>
   21f1e:	e7e1      	b.n	21ee4 <pinctrl_configure_pins+0x3c8>
            NRFX_ASSERT(0);
   21f20:	f8df a01c 	ldr.w	sl, [pc, #28]	; 21f40 <pinctrl_configure_pins+0x424>
   21f24:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21f28:	4651      	mov	r1, sl
   21f2a:	4804      	ldr	r0, [pc, #16]	; (21f3c <pinctrl_configure_pins+0x420>)
   21f2c:	f00a faff 	bl	2c52e <assert_print>
   21f30:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21f34:	4650      	mov	r0, sl
   21f36:	f00a faf3 	bl	2c520 <assert_post_action>
   21f3a:	e7d8      	b.n	21eee <pinctrl_configure_pins+0x3d2>
   21f3c:	00031600 	.word	0x00031600
   21f40:	0003b084 	.word	0x0003b084
		case NRF_FUN_PWM_OUT1:
			NRF_PSEL_PWM(reg, OUT[1]) = NRF_GET_PIN(pins[i]);
   21f44:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   21f48:	f8c9 3564 	str.w	r3, [r9, #1380]	; 0x564
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   21f4c:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   21f50:	f003 0a3f 	and.w	sl, r3, #63	; 0x3f
   21f54:	f3c3 3240 	ubfx	r2, r3, #13, #1
    if (value == 0)
   21f58:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   21f5c:	d139      	bne.n	21fd2 <pinctrl_configure_pins+0x4b6>
    switch (port)
   21f5e:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21f62:	d101      	bne.n	21f68 <pinctrl_configure_pins+0x44c>
            mask = P0_FEATURE_PINS_PRESENT;
   21f64:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   21f68:	f00a 031f 	and.w	r3, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21f6c:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21f6e:	f012 0f01 	tst.w	r2, #1
   21f72:	d012      	beq.n	21f9a <pinctrl_configure_pins+0x47e>
    *p_pin = pin_number & 0x1F;
   21f74:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21f78:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21f7c:	d11b      	bne.n	21fb6 <pinctrl_configure_pins+0x49a>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21f7e:	2301      	movs	r3, #1
   21f80:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTCLR = clr_mask;
   21f84:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21f88:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   21f8c:	4633      	mov	r3, r6
   21f8e:	2201      	movs	r2, #1
   21f90:	4611      	mov	r1, r2
   21f92:	59e8      	ldr	r0, [r5, r7]
   21f94:	f7ff fd74 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   21f98:	e5eb      	b.n	21b72 <pinctrl_configure_pins+0x56>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21f9a:	f8df b2a8 	ldr.w	fp, [pc, #680]	; 22244 <pinctrl_configure_pins+0x728>
   21f9e:	f240 2247 	movw	r2, #583	; 0x247
   21fa2:	4659      	mov	r1, fp
   21fa4:	48a6      	ldr	r0, [pc, #664]	; (22240 <pinctrl_configure_pins+0x724>)
   21fa6:	f00a fac2 	bl	2c52e <assert_print>
   21faa:	f240 2147 	movw	r1, #583	; 0x247
   21fae:	4658      	mov	r0, fp
   21fb0:	f00a fab6 	bl	2c520 <assert_post_action>
   21fb4:	e7de      	b.n	21f74 <pinctrl_configure_pins+0x458>
            NRFX_ASSERT(0);
   21fb6:	f8df a28c 	ldr.w	sl, [pc, #652]	; 22244 <pinctrl_configure_pins+0x728>
   21fba:	f44f 7213 	mov.w	r2, #588	; 0x24c
   21fbe:	4651      	mov	r1, sl
   21fc0:	489f      	ldr	r0, [pc, #636]	; (22240 <pinctrl_configure_pins+0x724>)
   21fc2:	f00a fab4 	bl	2c52e <assert_print>
   21fc6:	f44f 7113 	mov.w	r1, #588	; 0x24c
   21fca:	4650      	mov	r0, sl
   21fcc:	f00a faa8 	bl	2c520 <assert_post_action>
   21fd0:	e7d5      	b.n	21f7e <pinctrl_configure_pins+0x462>
    switch (port)
   21fd2:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21fd6:	d013      	beq.n	22000 <pinctrl_configure_pins+0x4e4>
    uint32_t mask = 0;
   21fd8:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   21fda:	f00a 021f 	and.w	r2, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   21fde:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   21fe0:	f013 0f01 	tst.w	r3, #1
   21fe4:	d00f      	beq.n	22006 <pinctrl_configure_pins+0x4ea>
    *p_pin = pin_number & 0x1F;
   21fe6:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   21fea:	ea5f 135a 	movs.w	r3, sl, lsr #5
   21fee:	d118      	bne.n	22022 <pinctrl_configure_pins+0x506>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   21ff0:	2301      	movs	r3, #1
   21ff2:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTSET = set_mask;
   21ff6:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   21ffa:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   21ffe:	e7c5      	b.n	21f8c <pinctrl_configure_pins+0x470>
            mask = P0_FEATURE_PINS_PRESENT;
   22000:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22004:	e7e9      	b.n	21fda <pinctrl_configure_pins+0x4be>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   22006:	f8df b23c 	ldr.w	fp, [pc, #572]	; 22244 <pinctrl_configure_pins+0x728>
   2200a:	f240 2247 	movw	r2, #583	; 0x247
   2200e:	4659      	mov	r1, fp
   22010:	488b      	ldr	r0, [pc, #556]	; (22240 <pinctrl_configure_pins+0x724>)
   22012:	f00a fa8c 	bl	2c52e <assert_print>
   22016:	f240 2147 	movw	r1, #583	; 0x247
   2201a:	4658      	mov	r0, fp
   2201c:	f00a fa80 	bl	2c520 <assert_post_action>
   22020:	e7e1      	b.n	21fe6 <pinctrl_configure_pins+0x4ca>
            NRFX_ASSERT(0);
   22022:	f8df a220 	ldr.w	sl, [pc, #544]	; 22244 <pinctrl_configure_pins+0x728>
   22026:	f44f 7213 	mov.w	r2, #588	; 0x24c
   2202a:	4651      	mov	r1, sl
   2202c:	4884      	ldr	r0, [pc, #528]	; (22240 <pinctrl_configure_pins+0x724>)
   2202e:	f00a fa7e 	bl	2c52e <assert_print>
   22032:	f44f 7113 	mov.w	r1, #588	; 0x24c
   22036:	4650      	mov	r0, sl
   22038:	f00a fa72 	bl	2c520 <assert_post_action>
   2203c:	e7d8      	b.n	21ff0 <pinctrl_configure_pins+0x4d4>
		case NRF_FUN_PWM_OUT2:
			NRF_PSEL_PWM(reg, OUT[2]) = NRF_GET_PIN(pins[i]);
   2203e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   22042:	f8c9 3568 	str.w	r3, [r9, #1384]	; 0x568
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   22046:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   2204a:	f003 0a3f 	and.w	sl, r3, #63	; 0x3f
   2204e:	f3c3 3240 	ubfx	r2, r3, #13, #1
    if (value == 0)
   22052:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   22056:	d139      	bne.n	220cc <pinctrl_configure_pins+0x5b0>
    switch (port)
   22058:	ea5f 135a 	movs.w	r3, sl, lsr #5
   2205c:	d101      	bne.n	22062 <pinctrl_configure_pins+0x546>
            mask = P0_FEATURE_PINS_PRESENT;
   2205e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   22062:	f00a 031f 	and.w	r3, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   22066:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   22068:	f012 0f01 	tst.w	r2, #1
   2206c:	d012      	beq.n	22094 <pinctrl_configure_pins+0x578>
    *p_pin = pin_number & 0x1F;
   2206e:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   22072:	ea5f 135a 	movs.w	r3, sl, lsr #5
   22076:	d11b      	bne.n	220b0 <pinctrl_configure_pins+0x594>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22078:	2301      	movs	r3, #1
   2207a:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTCLR = clr_mask;
   2207e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   22082:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   22086:	4633      	mov	r3, r6
   22088:	2201      	movs	r2, #1
   2208a:	4611      	mov	r1, r2
   2208c:	59e8      	ldr	r0, [r5, r7]
   2208e:	f7ff fcf7 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   22092:	e56e      	b.n	21b72 <pinctrl_configure_pins+0x56>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   22094:	f8df b1ac 	ldr.w	fp, [pc, #428]	; 22244 <pinctrl_configure_pins+0x728>
   22098:	f240 2247 	movw	r2, #583	; 0x247
   2209c:	4659      	mov	r1, fp
   2209e:	4868      	ldr	r0, [pc, #416]	; (22240 <pinctrl_configure_pins+0x724>)
   220a0:	f00a fa45 	bl	2c52e <assert_print>
   220a4:	f240 2147 	movw	r1, #583	; 0x247
   220a8:	4658      	mov	r0, fp
   220aa:	f00a fa39 	bl	2c520 <assert_post_action>
   220ae:	e7de      	b.n	2206e <pinctrl_configure_pins+0x552>
            NRFX_ASSERT(0);
   220b0:	f8df a190 	ldr.w	sl, [pc, #400]	; 22244 <pinctrl_configure_pins+0x728>
   220b4:	f44f 7213 	mov.w	r2, #588	; 0x24c
   220b8:	4651      	mov	r1, sl
   220ba:	4861      	ldr	r0, [pc, #388]	; (22240 <pinctrl_configure_pins+0x724>)
   220bc:	f00a fa37 	bl	2c52e <assert_print>
   220c0:	f44f 7113 	mov.w	r1, #588	; 0x24c
   220c4:	4650      	mov	r0, sl
   220c6:	f00a fa2b 	bl	2c520 <assert_post_action>
   220ca:	e7d5      	b.n	22078 <pinctrl_configure_pins+0x55c>
    switch (port)
   220cc:	ea5f 135a 	movs.w	r3, sl, lsr #5
   220d0:	d013      	beq.n	220fa <pinctrl_configure_pins+0x5de>
    uint32_t mask = 0;
   220d2:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   220d4:	f00a 021f 	and.w	r2, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   220d8:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   220da:	f013 0f01 	tst.w	r3, #1
   220de:	d00f      	beq.n	22100 <pinctrl_configure_pins+0x5e4>
    *p_pin = pin_number & 0x1F;
   220e0:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   220e4:	ea5f 135a 	movs.w	r3, sl, lsr #5
   220e8:	d118      	bne.n	2211c <pinctrl_configure_pins+0x600>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   220ea:	2301      	movs	r3, #1
   220ec:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTSET = set_mask;
   220f0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   220f4:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   220f8:	e7c5      	b.n	22086 <pinctrl_configure_pins+0x56a>
            mask = P0_FEATURE_PINS_PRESENT;
   220fa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   220fe:	e7e9      	b.n	220d4 <pinctrl_configure_pins+0x5b8>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   22100:	f8df b140 	ldr.w	fp, [pc, #320]	; 22244 <pinctrl_configure_pins+0x728>
   22104:	f240 2247 	movw	r2, #583	; 0x247
   22108:	4659      	mov	r1, fp
   2210a:	484d      	ldr	r0, [pc, #308]	; (22240 <pinctrl_configure_pins+0x724>)
   2210c:	f00a fa0f 	bl	2c52e <assert_print>
   22110:	f240 2147 	movw	r1, #583	; 0x247
   22114:	4658      	mov	r0, fp
   22116:	f00a fa03 	bl	2c520 <assert_post_action>
   2211a:	e7e1      	b.n	220e0 <pinctrl_configure_pins+0x5c4>
            NRFX_ASSERT(0);
   2211c:	f8df a124 	ldr.w	sl, [pc, #292]	; 22244 <pinctrl_configure_pins+0x728>
   22120:	f44f 7213 	mov.w	r2, #588	; 0x24c
   22124:	4651      	mov	r1, sl
   22126:	4846      	ldr	r0, [pc, #280]	; (22240 <pinctrl_configure_pins+0x724>)
   22128:	f00a fa01 	bl	2c52e <assert_print>
   2212c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   22130:	4650      	mov	r0, sl
   22132:	f00a f9f5 	bl	2c520 <assert_post_action>
   22136:	e7d8      	b.n	220ea <pinctrl_configure_pins+0x5ce>
		case NRF_FUN_PWM_OUT3:
			NRF_PSEL_PWM(reg, OUT[3]) = NRF_GET_PIN(pins[i]);
   22138:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   2213c:	f8c9 356c 	str.w	r3, [r9, #1388]	; 0x56c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   22140:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   22144:	f003 0a3f 	and.w	sl, r3, #63	; 0x3f
   22148:	f3c3 3240 	ubfx	r2, r3, #13, #1
    if (value == 0)
   2214c:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   22150:	d139      	bne.n	221c6 <pinctrl_configure_pins+0x6aa>
    switch (port)
   22152:	ea5f 135a 	movs.w	r3, sl, lsr #5
   22156:	d101      	bne.n	2215c <pinctrl_configure_pins+0x640>
            mask = P0_FEATURE_PINS_PRESENT;
   22158:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   2215c:	f00a 031f 	and.w	r3, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   22160:	40da      	lsrs	r2, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   22162:	f012 0f01 	tst.w	r2, #1
   22166:	d012      	beq.n	2218e <pinctrl_configure_pins+0x672>
    *p_pin = pin_number & 0x1F;
   22168:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2216c:	ea5f 135a 	movs.w	r3, sl, lsr #5
   22170:	d11b      	bne.n	221aa <pinctrl_configure_pins+0x68e>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22172:	2301      	movs	r3, #1
   22174:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTCLR = clr_mask;
   22178:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   2217c:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   22180:	4633      	mov	r3, r6
   22182:	2201      	movs	r2, #1
   22184:	4611      	mov	r1, r2
   22186:	59e8      	ldr	r0, [r5, r7]
   22188:	f7ff fc7a 	bl	21a80 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   2218c:	e4f1      	b.n	21b72 <pinctrl_configure_pins+0x56>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2218e:	f8df b0b4 	ldr.w	fp, [pc, #180]	; 22244 <pinctrl_configure_pins+0x728>
   22192:	f240 2247 	movw	r2, #583	; 0x247
   22196:	4659      	mov	r1, fp
   22198:	4829      	ldr	r0, [pc, #164]	; (22240 <pinctrl_configure_pins+0x724>)
   2219a:	f00a f9c8 	bl	2c52e <assert_print>
   2219e:	f240 2147 	movw	r1, #583	; 0x247
   221a2:	4658      	mov	r0, fp
   221a4:	f00a f9bc 	bl	2c520 <assert_post_action>
   221a8:	e7de      	b.n	22168 <pinctrl_configure_pins+0x64c>
            NRFX_ASSERT(0);
   221aa:	f8df a098 	ldr.w	sl, [pc, #152]	; 22244 <pinctrl_configure_pins+0x728>
   221ae:	f44f 7213 	mov.w	r2, #588	; 0x24c
   221b2:	4651      	mov	r1, sl
   221b4:	4822      	ldr	r0, [pc, #136]	; (22240 <pinctrl_configure_pins+0x724>)
   221b6:	f00a f9ba 	bl	2c52e <assert_print>
   221ba:	f44f 7113 	mov.w	r1, #588	; 0x24c
   221be:	4650      	mov	r0, sl
   221c0:	f00a f9ae 	bl	2c520 <assert_post_action>
   221c4:	e7d5      	b.n	22172 <pinctrl_configure_pins+0x656>
    switch (port)
   221c6:	ea5f 135a 	movs.w	r3, sl, lsr #5
   221ca:	d013      	beq.n	221f4 <pinctrl_configure_pins+0x6d8>
    uint32_t mask = 0;
   221cc:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   221ce:	f00a 021f 	and.w	r2, sl, #31
    return (mask & (1UL << pin_number)) ? true : false;
   221d2:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   221d4:	f013 0f01 	tst.w	r3, #1
   221d8:	d00f      	beq.n	221fa <pinctrl_configure_pins+0x6de>
    *p_pin = pin_number & 0x1F;
   221da:	f00a 0b1f 	and.w	fp, sl, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   221de:	ea5f 135a 	movs.w	r3, sl, lsr #5
   221e2:	d118      	bne.n	22216 <pinctrl_configure_pins+0x6fa>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   221e4:	2301      	movs	r3, #1
   221e6:	fa03 f30b 	lsl.w	r3, r3, fp
    p_reg->OUTSET = set_mask;
   221ea:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   221ee:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   221f2:	e7c5      	b.n	22180 <pinctrl_configure_pins+0x664>
            mask = P0_FEATURE_PINS_PRESENT;
   221f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   221f8:	e7e9      	b.n	221ce <pinctrl_configure_pins+0x6b2>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   221fa:	f8df b048 	ldr.w	fp, [pc, #72]	; 22244 <pinctrl_configure_pins+0x728>
   221fe:	f240 2247 	movw	r2, #583	; 0x247
   22202:	4659      	mov	r1, fp
   22204:	480e      	ldr	r0, [pc, #56]	; (22240 <pinctrl_configure_pins+0x724>)
   22206:	f00a f992 	bl	2c52e <assert_print>
   2220a:	f240 2147 	movw	r1, #583	; 0x247
   2220e:	4658      	mov	r0, fp
   22210:	f00a f986 	bl	2c520 <assert_post_action>
   22214:	e7e1      	b.n	221da <pinctrl_configure_pins+0x6be>
            NRFX_ASSERT(0);
   22216:	f8df a02c 	ldr.w	sl, [pc, #44]	; 22244 <pinctrl_configure_pins+0x728>
   2221a:	f44f 7213 	mov.w	r2, #588	; 0x24c
   2221e:	4651      	mov	r1, sl
   22220:	4807      	ldr	r0, [pc, #28]	; (22240 <pinctrl_configure_pins+0x724>)
   22222:	f00a f984 	bl	2c52e <assert_print>
   22226:	f44f 7113 	mov.w	r1, #588	; 0x24c
   2222a:	4650      	mov	r0, sl
   2222c:	f00a f978 	bl	2c520 <assert_post_action>
   22230:	e7d8      	b.n	221e4 <pinctrl_configure_pins+0x6c8>
		default:
			return -ENOTSUP;
		}
	}

	return 0;
   22232:	2000      	movs	r0, #0
   22234:	e001      	b.n	2223a <pinctrl_configure_pins+0x71e>
		switch (NRF_GET_FUN(pins[i])) {
   22236:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   2223a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2223e:	bf00      	nop
   22240:	00031600 	.word	0x00031600
   22244:	0003b084 	.word	0x0003b084

00022248 <multithreading_lock_acquire>:
#include "multithreading_lock.h"

static K_MUTEX_DEFINE(mpsl_lock);

int multithreading_lock_acquire(k_timeout_t timeout)
{
   22248:	b508      	push	{r3, lr}
   2224a:	4602      	mov	r2, r0
   2224c:	460b      	mov	r3, r1
	return z_impl_k_mutex_lock(mutex, timeout);
   2224e:	4802      	ldr	r0, [pc, #8]	; (22258 <multithreading_lock_acquire+0x10>)
   22250:	f004 fbbe 	bl	269d0 <z_impl_k_mutex_lock>
	return k_mutex_lock(&mpsl_lock, timeout);
}
   22254:	bd08      	pop	{r3, pc}
   22256:	bf00      	nop
   22258:	20000eb8 	.word	0x20000eb8

0002225c <multithreading_lock_release>:

void multithreading_lock_release(void)
{
   2225c:	b508      	push	{r3, lr}
	return z_impl_k_mutex_unlock(mutex);
   2225e:	4802      	ldr	r0, [pc, #8]	; (22268 <multithreading_lock_release+0xc>)
   22260:	f004 fcac 	bl	26bbc <z_impl_k_mutex_unlock>
	k_mutex_unlock(&mpsl_lock);
}
   22264:	bd08      	pop	{r3, pc}
   22266:	bf00      	nop
   22268:	20000eb8 	.word	0x20000eb8

0002226c <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   2226c:	b508      	push	{r3, lr}
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   2226e:	2145      	movs	r1, #69	; 0x45
   22270:	4802      	ldr	r0, [pc, #8]	; (2227c <k_sys_fatal_error_handler+0x10>)
   22272:	f00a f96b 	bl	2c54c <z_log_minimal_printk>
		sys_arch_reboot(0);
   22276:	2000      	movs	r0, #0
   22278:	f7f6 fed0 	bl	1901c <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   2227c:	0003b7e8 	.word	0x0003b7e8

00022280 <sdc_assertion_handler>:
	bt_ctlr_assert_handle((char *) file, line);
}

#else /* !IS_ENABLED(CONFIG_BT_CTLR_ASSERT_HANDLER) */
void sdc_assertion_handler(const char *const file, const uint32_t line)
{
   22280:	b508      	push	{r3, lr}
   22282:	4602      	mov	r2, r0
   22284:	460b      	mov	r3, r1
	BT_ERR("SoftDevice Controller ASSERT: %s, %d", file, line);
   22286:	2145      	movs	r1, #69	; 0x45
   22288:	4804      	ldr	r0, [pc, #16]	; (2229c <sdc_assertion_handler+0x1c>)
   2228a:	f00a f95f 	bl	2c54c <z_log_minimal_printk>
	k_oops();
   2228e:	4040      	eors	r0, r0
   22290:	f380 8811 	msr	BASEPRI, r0
   22294:	f04f 0003 	mov.w	r0, #3
   22298:	df02      	svc	2
}
   2229a:	bd08      	pop	{r3, pc}
   2229c:	0003b80c 	.word	0x0003b80c

000222a0 <event_packet_process>:
		return false;
	}
}

static void event_packet_process(uint8_t *hci_buf)
{
   222a0:	b570      	push	{r4, r5, r6, lr}
   222a2:	4604      	mov	r4, r0
	bool discardable = event_packet_is_discardable(hci_buf);
   222a4:	f00d fc68 	bl	2fb78 <event_packet_is_discardable>
   222a8:	4603      	mov	r3, r0
	struct bt_hci_evt_hdr *hdr = (void *)hci_buf;
	struct net_buf *evt_buf;

	if (hdr->evt == BT_HCI_EVT_LE_META_EVENT) {
   222aa:	7820      	ldrb	r0, [r4, #0]
		       opcode, cs->status);
	} else {
		BT_DBG("Event (0x%02x) len %u", hdr->evt, hdr->len);
	}

	evt_buf = bt_buf_get_evt(hdr->evt, discardable,
   222ac:	461d      	mov	r5, r3
   222ae:	b183      	cbz	r3, 222d2 <event_packet_process+0x32>
   222b0:	2200      	movs	r2, #0
   222b2:	2300      	movs	r3, #0
   222b4:	4629      	mov	r1, r5
   222b6:	f7f7 f80f 	bl	192d8 <bt_buf_get_evt>
				 discardable ? K_NO_WAIT : K_FOREVER);

	if (!evt_buf) {
   222ba:	4606      	mov	r6, r0
   222bc:	b170      	cbz	r0, 222dc <event_packet_process+0x3c>

		BT_ERR("No event buffer available");
		return;
	}

	net_buf_add_mem(evt_buf, &hci_buf[0], hdr->len + sizeof(*hdr));
   222be:	7862      	ldrb	r2, [r4, #1]
	return net_buf_simple_add_mem(&buf->b, mem, len);
   222c0:	3202      	adds	r2, #2
   222c2:	4621      	mov	r1, r4
   222c4:	3008      	adds	r0, #8
   222c6:	f00c fe13 	bl	2eef0 <net_buf_simple_add_mem>
	bt_recv(evt_buf);
   222ca:	4630      	mov	r0, r6
   222cc:	f7f8 f9a6 	bl	1a61c <bt_recv>
}
   222d0:	bd70      	pop	{r4, r5, r6, pc}
	evt_buf = bt_buf_get_evt(hdr->evt, discardable,
   222d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   222d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   222da:	e7eb      	b.n	222b4 <event_packet_process+0x14>
		if (discardable) {
   222dc:	2d00      	cmp	r5, #0
   222de:	d1f7      	bne.n	222d0 <event_packet_process+0x30>
		BT_ERR("No event buffer available");
   222e0:	2145      	movs	r1, #69	; 0x45
   222e2:	4802      	ldr	r0, [pc, #8]	; (222ec <event_packet_process+0x4c>)
   222e4:	f00a f932 	bl	2c54c <z_log_minimal_printk>
		return;
   222e8:	e7f2      	b.n	222d0 <event_packet_process+0x30>
   222ea:	bf00      	nop
   222ec:	0003b838 	.word	0x0003b838

000222f0 <data_packet_process>:
{
   222f0:	b538      	push	{r3, r4, r5, lr}
   222f2:	4604      	mov	r4, r0
	struct net_buf *data_buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
   222f4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   222f8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   222fc:	2003      	movs	r0, #3
   222fe:	f7f6 ffa7 	bl	19250 <bt_buf_get_rx>
	if (!data_buf) {
   22302:	b150      	cbz	r0, 2231a <data_packet_process+0x2a>
   22304:	4605      	mov	r5, r0
	len = sys_le16_to_cpu(hdr->len);
   22306:	8862      	ldrh	r2, [r4, #2]
   22308:	3204      	adds	r2, #4
   2230a:	4621      	mov	r1, r4
   2230c:	3008      	adds	r0, #8
   2230e:	f00c fdef 	bl	2eef0 <net_buf_simple_add_mem>
	bt_recv(data_buf);
   22312:	4628      	mov	r0, r5
   22314:	f7f8 f982 	bl	1a61c <bt_recv>
}
   22318:	bd38      	pop	{r3, r4, r5, pc}
		BT_ERR("No data buffer available");
   2231a:	2145      	movs	r1, #69	; 0x45
   2231c:	4801      	ldr	r0, [pc, #4]	; (22324 <data_packet_process+0x34>)
   2231e:	f00a f915 	bl	2c54c <z_log_minimal_printk>
		return;
   22322:	e7f9      	b.n	22318 <data_packet_process+0x28>
   22324:	0003b858 	.word	0x0003b858

00022328 <fetch_and_process_hci_msg>:
	return true;
}


static bool fetch_and_process_hci_msg(uint8_t *p_hci_buffer)
{
   22328:	b530      	push	{r4, r5, lr}
   2232a:	b083      	sub	sp, #12
   2232c:	4604      	mov	r4, r0
	int errcode;
	sdc_hci_msg_type_t msg_type;

	errcode = MULTITHREADING_LOCK_ACQUIRE();
   2232e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22332:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   22336:	f7ff ff87 	bl	22248 <multithreading_lock_acquire>
	if (!errcode) {
   2233a:	4605      	mov	r5, r0
   2233c:	b158      	cbz	r0, 22356 <fetch_and_process_hci_msg+0x2e>
		errcode = hci_internal_msg_get(p_hci_buffer, &msg_type);
		MULTITHREADING_LOCK_RELEASE();
	}

	if (errcode) {
   2233e:	bb35      	cbnz	r5, 2238e <fetch_and_process_hci_msg+0x66>
		return false;
	}

	if (msg_type == SDC_HCI_MSG_TYPE_EVT) {
   22340:	f89d 3007 	ldrb.w	r3, [sp, #7]
   22344:	2b04      	cmp	r3, #4
   22346:	d00f      	beq.n	22368 <fetch_and_process_hci_msg+0x40>
		event_packet_process(p_hci_buffer);
	} else if (msg_type == SDC_HCI_MSG_TYPE_DATA) {
   22348:	2b02      	cmp	r3, #2
   2234a:	d112      	bne.n	22372 <fetch_and_process_hci_msg+0x4a>
		data_packet_process(p_hci_buffer);
   2234c:	4620      	mov	r0, r4
   2234e:	f7ff ffcf 	bl	222f0 <data_packet_process>
	} else {
		__ASSERT(false, "sdc_hci_msg_type_t has changed. This if-else needs a new branch");
		return false;
	}

	return true;
   22352:	2001      	movs	r0, #1
   22354:	e01c      	b.n	22390 <fetch_and_process_hci_msg+0x68>
		errcode = hci_internal_msg_get(p_hci_buffer, &msg_type);
   22356:	f10d 0107 	add.w	r1, sp, #7
   2235a:	4620      	mov	r0, r4
   2235c:	f000 f9e4 	bl	22728 <hci_internal_msg_get>
   22360:	4605      	mov	r5, r0
		MULTITHREADING_LOCK_RELEASE();
   22362:	f7ff ff7b 	bl	2225c <multithreading_lock_release>
   22366:	e7ea      	b.n	2233e <fetch_and_process_hci_msg+0x16>
		event_packet_process(p_hci_buffer);
   22368:	4620      	mov	r0, r4
   2236a:	f7ff ff99 	bl	222a0 <event_packet_process>
	return true;
   2236e:	2001      	movs	r0, #1
   22370:	e00e      	b.n	22390 <fetch_and_process_hci_msg+0x68>
		__ASSERT(false, "sdc_hci_msg_type_t has changed. This if-else needs a new branch");
   22372:	4c08      	ldr	r4, [pc, #32]	; (22394 <fetch_and_process_hci_msg+0x6c>)
   22374:	f240 128f 	movw	r2, #399	; 0x18f
   22378:	4621      	mov	r1, r4
   2237a:	4807      	ldr	r0, [pc, #28]	; (22398 <fetch_and_process_hci_msg+0x70>)
   2237c:	f00a f8d7 	bl	2c52e <assert_print>
   22380:	f240 118f 	movw	r1, #399	; 0x18f
   22384:	4620      	mov	r0, r4
   22386:	f00a f8cb 	bl	2c520 <assert_post_action>
		return false;
   2238a:	2000      	movs	r0, #0
   2238c:	e000      	b.n	22390 <fetch_and_process_hci_msg+0x68>
		return false;
   2238e:	2000      	movs	r0, #0
}
   22390:	b003      	add	sp, #12
   22392:	bd30      	pop	{r4, r5, pc}
   22394:	0003b878 	.word	0x0003b878
   22398:	00031600 	.word	0x00031600

0002239c <rand_prio_low_vector_get_blocking>:
	__ASSERT(ret >= 0, "The entropy source returned an error in the high priority context");
	return ret >= 0 ? ret : 0;
}

static void rand_prio_low_vector_get_blocking(uint8_t *p_buff, uint8_t length)
{
   2239c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2239e:	4604      	mov	r4, r0
	int err = entropy_get_entropy(entropy_source, p_buff, length);
   223a0:	460d      	mov	r5, r1

static inline int z_impl_entropy_get_entropy(const struct device *dev,
					     uint8_t *buffer,
					     uint16_t length)
{
	const struct entropy_driver_api *api =
   223a2:	4b11      	ldr	r3, [pc, #68]	; (223e8 <rand_prio_low_vector_get_blocking+0x4c>)
   223a4:	689e      	ldr	r6, [r3, #8]
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
   223a6:	6833      	ldr	r3, [r6, #0]
   223a8:	b133      	cbz	r3, 223b8 <rand_prio_low_vector_get_blocking+0x1c>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   223aa:	6833      	ldr	r3, [r6, #0]
   223ac:	462a      	mov	r2, r5
   223ae:	4621      	mov	r1, r4
   223b0:	480d      	ldr	r0, [pc, #52]	; (223e8 <rand_prio_low_vector_get_blocking+0x4c>)
   223b2:	4798      	blx	r3

	__ASSERT(err == 0, "The entropy source returned an error in a blocking call");
   223b4:	b958      	cbnz	r0, 223ce <rand_prio_low_vector_get_blocking+0x32>
	(void) err;
}
   223b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT(api->get_entropy != NULL,
   223b8:	4f0c      	ldr	r7, [pc, #48]	; (223ec <rand_prio_low_vector_get_blocking+0x50>)
   223ba:	224b      	movs	r2, #75	; 0x4b
   223bc:	4639      	mov	r1, r7
   223be:	480c      	ldr	r0, [pc, #48]	; (223f0 <rand_prio_low_vector_get_blocking+0x54>)
   223c0:	f00a f8b5 	bl	2c52e <assert_print>
   223c4:	214b      	movs	r1, #75	; 0x4b
   223c6:	4638      	mov	r0, r7
   223c8:	f00a f8aa 	bl	2c520 <assert_post_action>
   223cc:	e7ed      	b.n	223aa <rand_prio_low_vector_get_blocking+0xe>
	__ASSERT(err == 0, "The entropy source returned an error in a blocking call");
   223ce:	4c09      	ldr	r4, [pc, #36]	; (223f4 <rand_prio_low_vector_get_blocking+0x58>)
   223d0:	f44f 72e7 	mov.w	r2, #462	; 0x1ce
   223d4:	4621      	mov	r1, r4
   223d6:	4806      	ldr	r0, [pc, #24]	; (223f0 <rand_prio_low_vector_get_blocking+0x54>)
   223d8:	f00a f8a9 	bl	2c52e <assert_print>
   223dc:	f44f 71e7 	mov.w	r1, #462	; 0x1ce
   223e0:	4620      	mov	r0, r4
   223e2:	f00a f89d 	bl	2c520 <assert_post_action>
}
   223e6:	e7e6      	b.n	223b6 <rand_prio_low_vector_get_blocking+0x1a>
   223e8:	0003100c 	.word	0x0003100c
   223ec:	0003b8b4 	.word	0x0003b8b4
   223f0:	00031600 	.word	0x00031600
   223f4:	0003b878 	.word	0x0003b878

000223f8 <hci_driver_receive_process>:
{
   223f8:	b570      	push	{r4, r5, r6, lr}
	received_evt = fetch_and_process_hci_evt(&hci_buf[0]);
   223fa:	4d0a      	ldr	r5, [pc, #40]	; (22424 <hci_driver_receive_process+0x2c>)
   223fc:	4628      	mov	r0, r5
   223fe:	f00d fbd0 	bl	2fba2 <fetch_and_process_hci_evt>
   22402:	4604      	mov	r4, r0
		received_data = fetch_and_process_acl_data(&hci_buf[0]);
   22404:	4628      	mov	r0, r5
   22406:	f00d fbe5 	bl	2fbd4 <fetch_and_process_acl_data>
   2240a:	4606      	mov	r6, r0
	received_msg = fetch_and_process_hci_msg(&hci_buf[0]);
   2240c:	4628      	mov	r0, r5
   2240e:	f7ff ff8b 	bl	22328 <fetch_and_process_hci_msg>
	if (received_evt || received_data || received_msg) {
   22412:	b90c      	cbnz	r4, 22418 <hci_driver_receive_process+0x20>
   22414:	b906      	cbnz	r6, 22418 <hci_driver_receive_process+0x20>
   22416:	b118      	cbz	r0, 22420 <hci_driver_receive_process+0x28>
 *
 * @return N/A
 */
static inline int mpsl_work_submit(struct k_work *work)
{
	return k_work_submit_to_queue(&mpsl_work_q, work);
   22418:	4903      	ldr	r1, [pc, #12]	; (22428 <hci_driver_receive_process+0x30>)
   2241a:	4804      	ldr	r0, [pc, #16]	; (2242c <hci_driver_receive_process+0x34>)
   2241c:	f00e fb60 	bl	30ae0 <k_work_submit_to_queue>
}
   22420:	bd70      	pop	{r4, r5, r6, pc}
   22422:	bf00      	nop
   22424:	20003dd8 	.word	0x20003dd8
   22428:	20003e20 	.word	0x20003e20
   2242c:	200024e0 	.word	0x200024e0

00022430 <hci_driver_init>:

	(void)sdc_hci_cmd_vs_zephyr_write_bd_addr(bd_addr);
}

static int hci_driver_init(const struct device *unused)
{
   22430:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);
	int err = 0;

	bt_hci_driver_register(&drv);
   22432:	4803      	ldr	r0, [pc, #12]	; (22440 <hci_driver_init+0x10>)
   22434:	f7f8 f930 	bl	1a698 <bt_hci_driver_register>

	err = sdc_init(sdc_assertion_handler);
   22438:	4802      	ldr	r0, [pc, #8]	; (22444 <hci_driver_init+0x14>)
   2243a:	f7e2 fe41 	bl	50c0 <sdc_init>
	return err;
}
   2243e:	bd08      	pop	{r3, pc}
   22440:	0003b9bc 	.word	0x0003b9bc
   22444:	00022281 	.word	0x00022281

00022448 <acl_handle>:
{
   22448:	b538      	push	{r3, r4, r5, lr}
   2244a:	4604      	mov	r4, r0
	int errcode = MULTITHREADING_LOCK_ACQUIRE();
   2244c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22450:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   22454:	f7ff fef8 	bl	22248 <multithreading_lock_acquire>
	if (!errcode) {
   22458:	4605      	mov	r5, r0
   2245a:	b108      	cbz	r0, 22460 <acl_handle+0x18>
}
   2245c:	4628      	mov	r0, r5
   2245e:	bd38      	pop	{r3, r4, r5, pc}
		errcode = sdc_hci_data_put(acl->data);
   22460:	68a0      	ldr	r0, [r4, #8]
   22462:	f7eb f98e 	bl	d782 <sdc_hci_data_put>
   22466:	4605      	mov	r5, r0
		MULTITHREADING_LOCK_RELEASE();
   22468:	f7ff fef8 	bl	2225c <multithreading_lock_release>
		if (errcode) {
   2246c:	2d00      	cmp	r5, #0
   2246e:	d0f5      	beq.n	2245c <acl_handle+0x14>
   22470:	4902      	ldr	r1, [pc, #8]	; (2247c <acl_handle+0x34>)
   22472:	4803      	ldr	r0, [pc, #12]	; (22480 <acl_handle+0x38>)
   22474:	f00e fb34 	bl	30ae0 <k_work_submit_to_queue>
}
   22478:	e7f0      	b.n	2245c <acl_handle+0x14>
   2247a:	bf00      	nop
   2247c:	20003e20 	.word	0x20003e20
   22480:	200024e0 	.word	0x200024e0

00022484 <cmd_handle>:
{
   22484:	b538      	push	{r3, r4, r5, lr}
   22486:	4605      	mov	r5, r0
	int errcode = MULTITHREADING_LOCK_ACQUIRE();
   22488:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2248c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   22490:	f7ff feda 	bl	22248 <multithreading_lock_acquire>
	if (!errcode) {
   22494:	4604      	mov	r4, r0
   22496:	b110      	cbz	r0, 2249e <cmd_handle+0x1a>
	if (errcode) {
   22498:	b144      	cbz	r4, 224ac <cmd_handle+0x28>
}
   2249a:	4620      	mov	r0, r4
   2249c:	bd38      	pop	{r3, r4, r5, pc}
		errcode = hci_internal_cmd_put(cmd->data);
   2249e:	68a8      	ldr	r0, [r5, #8]
   224a0:	f000 f91e 	bl	226e0 <hci_internal_cmd_put>
   224a4:	4604      	mov	r4, r0
		MULTITHREADING_LOCK_RELEASE();
   224a6:	f7ff fed9 	bl	2225c <multithreading_lock_release>
   224aa:	e7f5      	b.n	22498 <cmd_handle+0x14>
   224ac:	4902      	ldr	r1, [pc, #8]	; (224b8 <cmd_handle+0x34>)
   224ae:	4803      	ldr	r0, [pc, #12]	; (224bc <cmd_handle+0x38>)
   224b0:	f00e fb16 	bl	30ae0 <k_work_submit_to_queue>
	return 0;
   224b4:	e7f1      	b.n	2249a <cmd_handle+0x16>
   224b6:	bf00      	nop
   224b8:	20003e20 	.word	0x20003e20
   224bc:	200024e0 	.word	0x200024e0

000224c0 <rand_prio_high_vector_get>:
{
   224c0:	b538      	push	{r3, r4, r5, lr}
static inline int entropy_get_entropy_isr(const struct device *dev,
					  uint8_t *buffer,
					  uint16_t length,
					  uint32_t flags)
{
	const struct entropy_driver_api *api =
   224c2:	4b0f      	ldr	r3, [pc, #60]	; (22500 <rand_prio_high_vector_get+0x40>)
   224c4:	689b      	ldr	r3, [r3, #8]
		(const struct entropy_driver_api *)dev->api;

	if (unlikely(!api->get_entropy_isr)) {
   224c6:	685c      	ldr	r4, [r3, #4]
   224c8:	b154      	cbz	r4, 224e0 <rand_prio_high_vector_get+0x20>
   224ca:	460a      	mov	r2, r1
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
   224cc:	2300      	movs	r3, #0
   224ce:	4601      	mov	r1, r0
   224d0:	480b      	ldr	r0, [pc, #44]	; (22500 <rand_prio_high_vector_get+0x40>)
   224d2:	47a0      	blx	r4
	__ASSERT(ret >= 0, "The entropy source returned an error in the high priority context");
   224d4:	1e04      	subs	r4, r0, #0
   224d6:	db05      	blt.n	224e4 <rand_prio_high_vector_get+0x24>
	return ret >= 0 ? ret : 0;
   224d8:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
}
   224dc:	b2c0      	uxtb	r0, r0
   224de:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   224e0:	f06f 0485 	mvn.w	r4, #133	; 0x85
	__ASSERT(ret >= 0, "The entropy source returned an error in the high priority context");
   224e4:	4d07      	ldr	r5, [pc, #28]	; (22504 <rand_prio_high_vector_get+0x44>)
   224e6:	f44f 72e3 	mov.w	r2, #454	; 0x1c6
   224ea:	4629      	mov	r1, r5
   224ec:	4806      	ldr	r0, [pc, #24]	; (22508 <rand_prio_high_vector_get+0x48>)
   224ee:	f00a f81e 	bl	2c52e <assert_print>
   224f2:	f44f 71e3 	mov.w	r1, #454	; 0x1c6
   224f6:	4628      	mov	r0, r5
   224f8:	f00a f812 	bl	2c520 <assert_post_action>
   224fc:	e7ec      	b.n	224d8 <rand_prio_high_vector_get+0x18>
   224fe:	bf00      	nop
   22500:	0003100c 	.word	0x0003100c
   22504:	0003b878 	.word	0x0003b878
   22508:	00031600 	.word	0x00031600

0002250c <rand_prio_low_vector_get>:
{
   2250c:	b538      	push	{r3, r4, r5, lr}
	const struct entropy_driver_api *api =
   2250e:	4b0f      	ldr	r3, [pc, #60]	; (2254c <rand_prio_low_vector_get+0x40>)
   22510:	689b      	ldr	r3, [r3, #8]
	if (unlikely(!api->get_entropy_isr)) {
   22512:	685c      	ldr	r4, [r3, #4]
   22514:	b154      	cbz	r4, 2252c <rand_prio_low_vector_get+0x20>
   22516:	460a      	mov	r2, r1
	return api->get_entropy_isr(dev, buffer, length, flags);
   22518:	2300      	movs	r3, #0
   2251a:	4601      	mov	r1, r0
   2251c:	480b      	ldr	r0, [pc, #44]	; (2254c <rand_prio_low_vector_get+0x40>)
   2251e:	47a0      	blx	r4
	__ASSERT(ret >= 0, "The entropy source returned an error in the low priority context");
   22520:	1e04      	subs	r4, r0, #0
   22522:	db05      	blt.n	22530 <rand_prio_low_vector_get+0x24>
	return ret >= 0 ? ret : 0;
   22524:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
}
   22528:	b2c0      	uxtb	r0, r0
   2252a:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   2252c:	f06f 0485 	mvn.w	r4, #133	; 0x85
	__ASSERT(ret >= 0, "The entropy source returned an error in the low priority context");
   22530:	4d07      	ldr	r5, [pc, #28]	; (22550 <rand_prio_low_vector_get+0x44>)
   22532:	f44f 72df 	mov.w	r2, #446	; 0x1be
   22536:	4629      	mov	r1, r5
   22538:	4806      	ldr	r0, [pc, #24]	; (22554 <rand_prio_low_vector_get+0x48>)
   2253a:	f009 fff8 	bl	2c52e <assert_print>
   2253e:	f44f 71df 	mov.w	r1, #446	; 0x1be
   22542:	4628      	mov	r0, r5
   22544:	f009 ffec 	bl	2c520 <assert_post_action>
   22548:	e7ec      	b.n	22524 <rand_prio_low_vector_get+0x18>
   2254a:	bf00      	nop
   2254c:	0003100c 	.word	0x0003100c
   22550:	0003b878 	.word	0x0003b878
   22554:	00031600 	.word	0x00031600

00022558 <configure_memory_usage>:
{
   22558:	b500      	push	{lr}
   2255a:	b083      	sub	sp, #12
	cfg.central_count.count = SDC_CENTRAL_COUNT;
   2255c:	2000      	movs	r0, #0
   2255e:	f88d 0004 	strb.w	r0, [sp, #4]
		sdc_cfg_set(SDC_DEFAULT_RESOURCE_CFG_TAG,
   22562:	aa01      	add	r2, sp, #4
   22564:	2101      	movs	r1, #1
   22566:	f7e2 fd1d 	bl	4fa4 <sdc_cfg_set>
	if (required_memory < 0) {
   2256a:	2800      	cmp	r0, #0
   2256c:	db3d      	blt.n	225ea <configure_memory_usage+0x92>
	cfg.peripheral_count.count = CONFIG_BT_CTLR_SDC_PERIPHERAL_COUNT;
   2256e:	2301      	movs	r3, #1
   22570:	f88d 3004 	strb.w	r3, [sp, #4]
		sdc_cfg_set(SDC_DEFAULT_RESOURCE_CFG_TAG,
   22574:	aa01      	add	r2, sp, #4
   22576:	2102      	movs	r1, #2
   22578:	2000      	movs	r0, #0
   2257a:	f7e2 fd13 	bl	4fa4 <sdc_cfg_set>
	if (required_memory < 0) {
   2257e:	2800      	cmp	r0, #0
   22580:	db33      	blt.n	225ea <configure_memory_usage+0x92>
	cfg.buffer_cfg.rx_packet_size = MAX_RX_PACKET_SIZE;
   22582:	231b      	movs	r3, #27
   22584:	f88d 3005 	strb.w	r3, [sp, #5]
	cfg.buffer_cfg.tx_packet_size = MAX_TX_PACKET_SIZE;
   22588:	f88d 3004 	strb.w	r3, [sp, #4]
	cfg.buffer_cfg.rx_packet_count = CONFIG_BT_CTLR_SDC_RX_PACKET_COUNT;
   2258c:	2302      	movs	r3, #2
   2258e:	f88d 3007 	strb.w	r3, [sp, #7]
	cfg.buffer_cfg.tx_packet_count = CONFIG_BT_CTLR_SDC_TX_PACKET_COUNT;
   22592:	2103      	movs	r1, #3
   22594:	f88d 1006 	strb.w	r1, [sp, #6]
		sdc_cfg_set(SDC_DEFAULT_RESOURCE_CFG_TAG,
   22598:	aa01      	add	r2, sp, #4
   2259a:	2000      	movs	r0, #0
   2259c:	f7e2 fd02 	bl	4fa4 <sdc_cfg_set>
	if (required_memory < 0) {
   225a0:	2800      	cmp	r0, #0
   225a2:	db22      	blt.n	225ea <configure_memory_usage+0x92>
	cfg.event_length.event_length_us =
   225a4:	f641 534c 	movw	r3, #7500	; 0x1d4c
   225a8:	9301      	str	r3, [sp, #4]
		sdc_cfg_set(SDC_DEFAULT_RESOURCE_CFG_TAG,
   225aa:	aa01      	add	r2, sp, #4
   225ac:	2104      	movs	r1, #4
   225ae:	2000      	movs	r0, #0
   225b0:	f7e2 fcf8 	bl	4fa4 <sdc_cfg_set>
	if (required_memory < 0) {
   225b4:	2800      	cmp	r0, #0
   225b6:	db18      	blt.n	225ea <configure_memory_usage+0x92>
	cfg.adv_count.count = SDC_ADV_SET_COUNT;
   225b8:	2301      	movs	r3, #1
   225ba:	f88d 3004 	strb.w	r3, [sp, #4]
	sdc_cfg_set(SDC_DEFAULT_RESOURCE_CFG_TAG,
   225be:	aa01      	add	r2, sp, #4
   225c0:	2105      	movs	r1, #5
   225c2:	2000      	movs	r0, #0
   225c4:	f7e2 fcee 	bl	4fa4 <sdc_cfg_set>
	if (required_memory < 0) {
   225c8:	2800      	cmp	r0, #0
   225ca:	db0e      	blt.n	225ea <configure_memory_usage+0x92>
		cfg.adv_buffer_cfg.max_adv_data = SDC_DEFAULT_ADV_BUF_SIZE;
   225cc:	231f      	movs	r3, #31
   225ce:	f8ad 3004 	strh.w	r3, [sp, #4]
		sdc_cfg_set(SDC_DEFAULT_RESOURCE_CFG_TAG,
   225d2:	aa01      	add	r2, sp, #4
   225d4:	2107      	movs	r1, #7
   225d6:	2000      	movs	r0, #0
   225d8:	f7e2 fce4 	bl	4fa4 <sdc_cfg_set>
		if (required_memory < 0) {
   225dc:	2800      	cmp	r0, #0
   225de:	db04      	blt.n	225ea <configure_memory_usage+0x92>
	if (required_memory > sizeof(sdc_mempool)) {
   225e0:	f240 7314 	movw	r3, #1812	; 0x714
   225e4:	4298      	cmp	r0, r3
   225e6:	d803      	bhi.n	225f0 <configure_memory_usage+0x98>
	return 0;
   225e8:	2000      	movs	r0, #0
}
   225ea:	b003      	add	sp, #12
   225ec:	f85d fb04 	ldr.w	pc, [sp], #4
		BT_ERR("Allocated memory too low: %u < %u",
   225f0:	4603      	mov	r3, r0
   225f2:	f240 7214 	movw	r2, #1812	; 0x714
   225f6:	2145      	movs	r1, #69	; 0x45
   225f8:	4805      	ldr	r0, [pc, #20]	; (22610 <configure_memory_usage+0xb8>)
   225fa:	f009 ffa7 	bl	2c54c <z_log_minimal_printk>
		k_panic();
   225fe:	4040      	eors	r0, r0
   22600:	f380 8811 	msr	BASEPRI, r0
   22604:	f04f 0004 	mov.w	r0, #4
   22608:	df02      	svc	2
		return -ENOMEM;
   2260a:	f06f 000b 	mvn.w	r0, #11
   2260e:	e7ec      	b.n	225ea <configure_memory_usage+0x92>
   22610:	0003b8e8 	.word	0x0003b8e8

00022614 <hci_driver_open>:
{
   22614:	b530      	push	{r4, r5, lr}
   22616:	b089      	sub	sp, #36	; 0x24
		hci_ecdh_init();
   22618:	f000 fa3e 	bl	22a98 <hci_ecdh_init>
	sdc_build_revision_get(build_revision);
   2261c:	a803      	add	r0, sp, #12
   2261e:	f7e2 fcb3 	bl	4f88 <sdc_build_revision_get>
	LOG_HEXDUMP_INF(build_revision, sizeof(build_revision),
   22622:	4a25      	ldr	r2, [pc, #148]	; (226b8 <hci_driver_open+0xa4>)
   22624:	2149      	movs	r1, #73	; 0x49
   22626:	4825      	ldr	r0, [pc, #148]	; (226bc <hci_driver_open+0xa8>)
   22628:	f009 ff90 	bl	2c54c <z_log_minimal_printk>
   2262c:	2214      	movs	r2, #20
   2262e:	a903      	add	r1, sp, #12
   22630:	2003      	movs	r0, #3
   22632:	f7f4 febd 	bl	173b0 <z_log_minimal_hexdump_print>
	err = configure_supported_features();
   22636:	f00d fb05 	bl	2fc44 <configure_supported_features>
	if (err) {
   2263a:	4604      	mov	r4, r0
   2263c:	b110      	cbz	r0, 22644 <hci_driver_open+0x30>
}
   2263e:	4620      	mov	r0, r4
   22640:	b009      	add	sp, #36	; 0x24
   22642:	bd30      	pop	{r4, r5, pc}
	err = configure_memory_usage();
   22644:	f7ff ff88 	bl	22558 <configure_memory_usage>
	if (err) {
   22648:	4604      	mov	r4, r0
   2264a:	2800      	cmp	r0, #0
   2264c:	d1f7      	bne.n	2263e <hci_driver_open+0x2a>
   2264e:	481c      	ldr	r0, [pc, #112]	; (226c0 <hci_driver_open+0xac>)
   22650:	f00e f918 	bl	30884 <z_device_is_ready>
	if (!device_is_ready(entropy_source)) {
   22654:	b1c8      	cbz	r0, 2268a <hci_driver_open+0x76>
	sdc_rand_source_t rand_functions = {
   22656:	4a1b      	ldr	r2, [pc, #108]	; (226c4 <hci_driver_open+0xb0>)
   22658:	466b      	mov	r3, sp
   2265a:	ca07      	ldmia	r2, {r0, r1, r2}
   2265c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	err = sdc_rand_source_register(&rand_functions);
   22660:	4618      	mov	r0, r3
   22662:	f7e2 fe3f 	bl	52e4 <sdc_rand_source_register>
	if (err) {
   22666:	4604      	mov	r4, r0
   22668:	b9b0      	cbnz	r0, 22698 <hci_driver_open+0x84>
	k_work_init(&receive_work, receive_work_handler);
   2266a:	4917      	ldr	r1, [pc, #92]	; (226c8 <hci_driver_open+0xb4>)
   2266c:	4817      	ldr	r0, [pc, #92]	; (226cc <hci_driver_open+0xb8>)
   2266e:	f004 ff7f 	bl	27570 <k_work_init>
	err = MULTITHREADING_LOCK_ACQUIRE();
   22672:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22676:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2267a:	f7ff fde5 	bl	22248 <multithreading_lock_acquire>
	if (!err) {
   2267e:	4605      	mov	r5, r0
   22680:	b190      	cbz	r0, 226a8 <hci_driver_open+0x94>
	if (err < 0) {
   22682:	2d00      	cmp	r5, #0
   22684:	dadb      	bge.n	2263e <hci_driver_open+0x2a>
		return err;
   22686:	462c      	mov	r4, r5
   22688:	e7d9      	b.n	2263e <hci_driver_open+0x2a>
		BT_ERR("Entropy source device not ready");
   2268a:	2145      	movs	r1, #69	; 0x45
   2268c:	4810      	ldr	r0, [pc, #64]	; (226d0 <hci_driver_open+0xbc>)
   2268e:	f009 ff5d 	bl	2c54c <z_log_minimal_printk>
		return -ENODEV;
   22692:	f06f 0412 	mvn.w	r4, #18
   22696:	e7d2      	b.n	2263e <hci_driver_open+0x2a>
		BT_ERR("Failed to register rand source (%d)", err);
   22698:	4602      	mov	r2, r0
   2269a:	2145      	movs	r1, #69	; 0x45
   2269c:	480d      	ldr	r0, [pc, #52]	; (226d4 <hci_driver_open+0xc0>)
   2269e:	f009 ff55 	bl	2c54c <z_log_minimal_printk>
		return -EINVAL;
   226a2:	f06f 0415 	mvn.w	r4, #21
   226a6:	e7ca      	b.n	2263e <hci_driver_open+0x2a>
		err = sdc_enable(hci_driver_receive_process, sdc_mempool);
   226a8:	490b      	ldr	r1, [pc, #44]	; (226d8 <hci_driver_open+0xc4>)
   226aa:	480c      	ldr	r0, [pc, #48]	; (226dc <hci_driver_open+0xc8>)
   226ac:	f7e2 fce0 	bl	5070 <sdc_enable>
   226b0:	4605      	mov	r5, r0
		MULTITHREADING_LOCK_RELEASE();
   226b2:	f7ff fdd3 	bl	2225c <multithreading_lock_release>
   226b6:	e7e4      	b.n	22682 <hci_driver_open+0x6e>
   226b8:	0003b910 	.word	0x0003b910
   226bc:	0003b938 	.word	0x0003b938
   226c0:	0003100c 	.word	0x0003100c
   226c4:	00031448 	.word	0x00031448
   226c8:	0002fc07 	.word	0x0002fc07
   226cc:	20003e20 	.word	0x20003e20
   226d0:	0003b940 	.word	0x0003b940
   226d4:	0003b968 	.word	0x0003b968
   226d8:	20003e30 	.word	0x20003e30
   226dc:	000223f9 	.word	0x000223f9

000226e0 <hci_internal_cmd_put>:

int hci_internal_cmd_put(uint8_t *cmd_in)
{
	uint16_t opcode = sys_get_le16(cmd_in);

	if (cmd_complete_or_status.occurred) {
   226e0:	4b07      	ldr	r3, [pc, #28]	; (22700 <hci_internal_cmd_put+0x20>)
   226e2:	781b      	ldrb	r3, [r3, #0]
   226e4:	b943      	cbnz	r3, 226f8 <hci_internal_cmd_put+0x18>
{
   226e6:	b510      	push	{r4, lr}
		> HCI_CMD_PACKET_MAX_SIZE) {
		return -EINVAL;
	}

	if (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT)) {
		cmd_put(cmd_in, &cmd_complete_or_status.raw_event[0]);
   226e8:	4c05      	ldr	r4, [pc, #20]	; (22700 <hci_internal_cmd_put+0x20>)
   226ea:	1c61      	adds	r1, r4, #1
   226ec:	f00d fe3c 	bl	30368 <cmd_put>
	{
		/* SDC_HCI_OPCODE_CMD_CB_HOST_NUMBER_OF_COMPLETED_PACKETS will only generate
		 *  command complete if it fails.
		 */

		cmd_complete_or_status.occurred = true;
   226f0:	2301      	movs	r3, #1
   226f2:	7023      	strb	r3, [r4, #0]
	}

	return 0;
   226f4:	2000      	movs	r0, #0
}
   226f6:	bd10      	pop	{r4, pc}
		return -NRF_EPERM;
   226f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   226fc:	4770      	bx	lr
   226fe:	bf00      	nop
   22700:	20004544 	.word	0x20004544

00022704 <hci_internal_evt_get>:

int hci_internal_evt_get(uint8_t *evt_out)
{
   22704:	b510      	push	{r4, lr}
	if (cmd_complete_or_status.occurred) {
   22706:	4b07      	ldr	r3, [pc, #28]	; (22724 <hci_internal_evt_get+0x20>)
   22708:	781b      	ldrb	r3, [r3, #0]
   2270a:	b143      	cbz	r3, 2271e <hci_internal_evt_get+0x1a>
		struct bt_hci_evt_hdr *evt_hdr = (void *)&cmd_complete_or_status.raw_event[0];

		memcpy(evt_out,
   2270c:	4c05      	ldr	r4, [pc, #20]	; (22724 <hci_internal_evt_get+0x20>)
   2270e:	78a2      	ldrb	r2, [r4, #2]
   22710:	3202      	adds	r2, #2
   22712:	1c61      	adds	r1, r4, #1
   22714:	f00e fba7 	bl	30e66 <memcpy>
		       &cmd_complete_or_status.raw_event[0],
		       evt_hdr->len + BT_HCI_EVT_HDR_SIZE);
		cmd_complete_or_status.occurred = false;
   22718:	2000      	movs	r0, #0
   2271a:	7020      	strb	r0, [r4, #0]

		return 0;
	}

	return sdc_hci_evt_get(evt_out);
}
   2271c:	bd10      	pop	{r4, pc}
	return sdc_hci_evt_get(evt_out);
   2271e:	f7eb f83b 	bl	d798 <sdc_hci_evt_get>
   22722:	e7fb      	b.n	2271c <hci_internal_evt_get+0x18>
   22724:	20004544 	.word	0x20004544

00022728 <hci_internal_msg_get>:

int hci_internal_msg_get(uint8_t *msg_out, sdc_hci_msg_type_t *msg_type_out)
{
   22728:	b538      	push	{r3, r4, r5, lr}
   2272a:	460c      	mov	r4, r1
	if (cmd_complete_or_status.occurred) {
   2272c:	4b08      	ldr	r3, [pc, #32]	; (22750 <hci_internal_msg_get+0x28>)
   2272e:	781b      	ldrb	r3, [r3, #0]
   22730:	b153      	cbz	r3, 22748 <hci_internal_msg_get+0x20>
		struct bt_hci_evt_hdr *evt_hdr = (void *)&cmd_complete_or_status.raw_event[0];

		memcpy(msg_out,
   22732:	4d07      	ldr	r5, [pc, #28]	; (22750 <hci_internal_msg_get+0x28>)
   22734:	78aa      	ldrb	r2, [r5, #2]
   22736:	3202      	adds	r2, #2
   22738:	1c69      	adds	r1, r5, #1
   2273a:	f00e fb94 	bl	30e66 <memcpy>
					 &cmd_complete_or_status.raw_event[0],
					 evt_hdr->len + BT_HCI_EVT_HDR_SIZE);
		cmd_complete_or_status.occurred = false;
   2273e:	2000      	movs	r0, #0
   22740:	7028      	strb	r0, [r5, #0]

		*msg_type_out = SDC_HCI_MSG_TYPE_EVT;
   22742:	2304      	movs	r3, #4
   22744:	7023      	strb	r3, [r4, #0]

		return 0;
	}

	return sdc_hci_get(msg_out, msg_type_out);
}
   22746:	bd38      	pop	{r3, r4, r5, pc}
	return sdc_hci_get(msg_out, msg_type_out);
   22748:	f7eb f833 	bl	d7b2 <sdc_hci_get>
   2274c:	e7fb      	b.n	22746 <hci_internal_msg_get+0x1e>
   2274e:	bf00      	nop
   22750:	20004544 	.word	0x20004544

00022754 <bt_rand>:
#define BT_ECB_BLOCK_SIZE 16

static const struct device *dev = DEVICE_DT_GET(DT_NODELABEL(rng));

int bt_rand(void *buf, size_t len)
{
   22754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22756:	4606      	mov	r6, r0
   22758:	460c      	mov	r4, r1
   2275a:	4810      	ldr	r0, [pc, #64]	; (2279c <bt_rand+0x48>)
   2275c:	f00e f892 	bl	30884 <z_device_is_ready>
	if (unlikely(!device_is_ready(dev))) {
   22760:	f080 0301 	eor.w	r3, r0, #1
   22764:	f013 0fff 	tst.w	r3, #255	; 0xff
   22768:	d115      	bne.n	22796 <bt_rand+0x42>
		return -ENODEV;
	}

	return entropy_get_entropy(dev, (uint8_t *)buf, len);
   2276a:	b2a4      	uxth	r4, r4
	const struct entropy_driver_api *api =
   2276c:	4b0b      	ldr	r3, [pc, #44]	; (2279c <bt_rand+0x48>)
   2276e:	689d      	ldr	r5, [r3, #8]
	__ASSERT(api->get_entropy != NULL,
   22770:	682b      	ldr	r3, [r5, #0]
   22772:	b12b      	cbz	r3, 22780 <bt_rand+0x2c>
	return api->get_entropy(dev, buffer, length);
   22774:	682b      	ldr	r3, [r5, #0]
   22776:	4622      	mov	r2, r4
   22778:	4631      	mov	r1, r6
   2277a:	4808      	ldr	r0, [pc, #32]	; (2279c <bt_rand+0x48>)
   2277c:	4798      	blx	r3
}
   2277e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT(api->get_entropy != NULL,
   22780:	4f07      	ldr	r7, [pc, #28]	; (227a0 <bt_rand+0x4c>)
   22782:	224b      	movs	r2, #75	; 0x4b
   22784:	4639      	mov	r1, r7
   22786:	4807      	ldr	r0, [pc, #28]	; (227a4 <bt_rand+0x50>)
   22788:	f009 fed1 	bl	2c52e <assert_print>
   2278c:	214b      	movs	r1, #75	; 0x4b
   2278e:	4638      	mov	r0, r7
   22790:	f009 fec6 	bl	2c520 <assert_post_action>
   22794:	e7ee      	b.n	22774 <bt_rand+0x20>
		return -ENODEV;
   22796:	f06f 0012 	mvn.w	r0, #18
   2279a:	e7f0      	b.n	2277e <bt_rand+0x2a>
   2279c:	0003100c 	.word	0x0003100c
   227a0:	0003b8b4 	.word	0x0003b8b4
   227a4:	00031600 	.word	0x00031600

000227a8 <public_key>:

#if defined(CONFIG_BT_CTLR_ECDH_LIB_OBERON)
#include <ocrypto_ecdh_p256.h>

static uint8_t public_key(void)
{
   227a8:	b508      	push	{r3, lr}
	int err;

	do {
		err = bt_rand(ecdh.private_key_be, 32);
   227aa:	2120      	movs	r1, #32
   227ac:	480a      	ldr	r0, [pc, #40]	; (227d8 <public_key+0x30>)
   227ae:	f7ff ffd1 	bl	22754 <bt_rand>
		if (err) {
   227b2:	b970      	cbnz	r0, 227d2 <public_key+0x2a>
			return BT_HCI_ERR_UNSPECIFIED;
		}

		if (!memcmp(ecdh.private_key_be, debug_private_key_be, 32)) {
   227b4:	2220      	movs	r2, #32
   227b6:	4909      	ldr	r1, [pc, #36]	; (227dc <public_key+0x34>)
   227b8:	4807      	ldr	r0, [pc, #28]	; (227d8 <public_key+0x30>)
   227ba:	f00e fb44 	bl	30e46 <memcmp>
   227be:	2800      	cmp	r0, #0
   227c0:	d0f3      	beq.n	227aa <public_key+0x2>
			err = -1;
			continue;
		}

		err = ocrypto_ecdh_p256_public_key(ecdh.public_key_be,
   227c2:	4905      	ldr	r1, [pc, #20]	; (227d8 <public_key+0x30>)
   227c4:	f101 0020 	add.w	r0, r1, #32
   227c8:	f007 fe08 	bl	2a3dc <ocrypto_ecdh_p256_public_key>
						   ecdh.private_key_be);
	} while (err);
   227cc:	2800      	cmp	r0, #0
   227ce:	d1ec      	bne.n	227aa <public_key+0x2>
   227d0:	e000      	b.n	227d4 <public_key+0x2c>
			return BT_HCI_ERR_UNSPECIFIED;
   227d2:	201f      	movs	r0, #31

	return 0;
}
   227d4:	bd08      	pop	{r3, pc}
   227d6:	bf00      	nop
   227d8:	20004590 	.word	0x20004590
   227dc:	0003ba80 	.word	0x0003ba80

000227e0 <common_secret>:

static uint8_t common_secret(bool use_debug)
{
   227e0:	b508      	push	{r3, lr}
	int err;

	err = ocrypto_ecdh_p256_common_secret(ecdh.dhkey_be,
   227e2:	b140      	cbz	r0, 227f6 <common_secret+0x16>
   227e4:	4908      	ldr	r1, [pc, #32]	; (22808 <common_secret+0x28>)
   227e6:	4809      	ldr	r0, [pc, #36]	; (2280c <common_secret+0x2c>)
   227e8:	4602      	mov	r2, r0
   227ea:	f007 fe0b 	bl	2a404 <ocrypto_ecdh_p256_common_secret>
					      use_debug ? debug_private_key_be :
							  ecdh.private_key_be,
					      ecdh.public_key_be);
	/* -1: public or private key was not a valid key */
	if (err) {
   227ee:	4602      	mov	r2, r0
   227f0:	b918      	cbnz	r0, 227fa <common_secret+0x1a>
		 */
		BT_ERR("public key is not valid (err %d)", err);
		return BT_HCI_ERR_INVALID_PARAM;
	}

	return 0;
   227f2:	2000      	movs	r0, #0
}
   227f4:	bd08      	pop	{r3, pc}
	err = ocrypto_ecdh_p256_common_secret(ecdh.dhkey_be,
   227f6:	4906      	ldr	r1, [pc, #24]	; (22810 <common_secret+0x30>)
   227f8:	e7f5      	b.n	227e6 <common_secret+0x6>
		BT_ERR("public key is not valid (err %d)", err);
   227fa:	2145      	movs	r1, #69	; 0x45
   227fc:	4805      	ldr	r0, [pc, #20]	; (22814 <common_secret+0x34>)
   227fe:	f009 fea5 	bl	2c54c <z_log_minimal_printk>
		return BT_HCI_ERR_INVALID_PARAM;
   22802:	2012      	movs	r0, #18
   22804:	e7f6      	b.n	227f4 <common_secret+0x14>
   22806:	bf00      	nop
   22808:	0003ba80 	.word	0x0003ba80
   2280c:	200045b0 	.word	0x200045b0
   22810:	20004590 	.word	0x20004590
   22814:	0003b9f4 	.word	0x0003b9f4

00022818 <work_submit>:

static struct k_thread ecdh_thread_data;
static K_KERNEL_STACK_DEFINE(ecdh_thread_stack, CONFIG_BT_CTLR_ECDH_STACK_SIZE);

static void work_submit(void)
{
   22818:	b508      	push	{r3, lr}
	return z_impl_k_poll_signal_raise(sig, result);
   2281a:	2100      	movs	r1, #0
   2281c:	4801      	ldr	r0, [pc, #4]	; (22824 <work_submit+0xc>)
   2281e:	f007 fc15 	bl	2a04c <z_impl_k_poll_signal_raise>
	k_poll_signal_raise(&ecdh_signal, 0);
}
   22822:	bd08      	pop	{r3, pc}
   22824:	200045f0 	.word	0x200045f0

00022828 <ecdh_p256_common_secret>:
{
   22828:	b570      	push	{r4, r5, r6, lr}
	status = common_secret(use_debug);
   2282a:	f7ff ffd9 	bl	227e0 <common_secret>
   2282e:	4604      	mov	r4, r0
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   22830:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   22834:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22838:	2001      	movs	r0, #1
   2283a:	f7f6 fd09 	bl	19250 <bt_buf_get_rx>
   2283e:	4605      	mov	r5, r0
	return net_buf_simple_add(&buf->b, len);
   22840:	f100 0608 	add.w	r6, r0, #8
   22844:	2102      	movs	r1, #2
   22846:	4630      	mov	r0, r6
   22848:	f7fc fc7c 	bl	1f144 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
   2284c:	233e      	movs	r3, #62	; 0x3e
   2284e:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
   22850:	2322      	movs	r3, #34	; 0x22
   22852:	7043      	strb	r3, [r0, #1]
   22854:	2101      	movs	r1, #1
   22856:	4630      	mov	r0, r6
   22858:	f7fc fc74 	bl	1f144 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
   2285c:	2309      	movs	r3, #9
   2285e:	7003      	strb	r3, [r0, #0]
   22860:	2121      	movs	r1, #33	; 0x21
   22862:	4630      	mov	r0, r6
   22864:	f7fc fc6e 	bl	1f144 <net_buf_simple_add>
	evt->status = status;
   22868:	7004      	strb	r4, [r0, #0]
	if (status) {
   2286a:	b134      	cbz	r4, 2287a <ecdh_p256_common_secret+0x52>
__ssp_bos_icheck3(memset, void *, int)
   2286c:	2220      	movs	r2, #32
   2286e:	21ff      	movs	r1, #255	; 0xff
   22870:	3001      	adds	r0, #1
   22872:	f00e fb19 	bl	30ea8 <memset>
}
   22876:	4628      	mov	r0, r5
   22878:	bd70      	pop	{r4, r5, r6, pc}
		sys_memcpy_swap(evt->dhkey, ecdh.dhkey_be,
   2287a:	1c44      	adds	r4, r0, #1
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   2287c:	4b13      	ldr	r3, [pc, #76]	; (228cc <ecdh_p256_common_secret+0xa4>)
   2287e:	429c      	cmp	r4, r3
   22880:	d902      	bls.n	22888 <ecdh_p256_common_secret+0x60>
   22882:	3320      	adds	r3, #32
   22884:	429c      	cmp	r4, r3
   22886:	d213      	bcs.n	228b0 <ecdh_p256_common_secret+0x88>
   22888:	4b10      	ldr	r3, [pc, #64]	; (228cc <ecdh_p256_common_secret+0xa4>)
   2288a:	429c      	cmp	r4, r3
   2288c:	d204      	bcs.n	22898 <ecdh_p256_common_secret+0x70>
   2288e:	f104 0320 	add.w	r3, r4, #32
   22892:	4a0e      	ldr	r2, [pc, #56]	; (228cc <ecdh_p256_common_secret+0xa4>)
   22894:	4293      	cmp	r3, r2
   22896:	d90b      	bls.n	228b0 <ecdh_p256_common_secret+0x88>
   22898:	4e0d      	ldr	r6, [pc, #52]	; (228d0 <ecdh_p256_common_secret+0xa8>)
   2289a:	f240 2217 	movw	r2, #535	; 0x217
   2289e:	4631      	mov	r1, r6
   228a0:	480c      	ldr	r0, [pc, #48]	; (228d4 <ecdh_p256_common_secret+0xac>)
   228a2:	f009 fe44 	bl	2c52e <assert_print>
   228a6:	f240 2117 	movw	r1, #535	; 0x217
   228aa:	4630      	mov	r0, r6
   228ac:	f009 fe38 	bl	2c520 <assert_post_action>
	psrc += length - 1;
   228b0:	4b09      	ldr	r3, [pc, #36]	; (228d8 <ecdh_p256_common_secret+0xb0>)
	for (; length > 0; length--) {
   228b2:	2220      	movs	r2, #32
   228b4:	e006      	b.n	228c4 <ecdh_p256_common_secret+0x9c>
		*pdst++ = *psrc--;
   228b6:	4620      	mov	r0, r4
   228b8:	f813 1901 	ldrb.w	r1, [r3], #-1
   228bc:	f800 1b01 	strb.w	r1, [r0], #1
	for (; length > 0; length--) {
   228c0:	3a01      	subs	r2, #1
		*pdst++ = *psrc--;
   228c2:	4604      	mov	r4, r0
	for (; length > 0; length--) {
   228c4:	2a00      	cmp	r2, #0
   228c6:	d1f6      	bne.n	228b6 <ecdh_p256_common_secret+0x8e>
   228c8:	e7d5      	b.n	22876 <ecdh_p256_common_secret+0x4e>
   228ca:	bf00      	nop
   228cc:	200045b0 	.word	0x200045b0
   228d0:	0003ba1c 	.word	0x0003ba1c
   228d4:	00031600 	.word	0x00031600
   228d8:	200045cf 	.word	0x200045cf

000228dc <ecdh_p256_public_key>:
{
   228dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status = public_key();
   228de:	f7ff ff63 	bl	227a8 <public_key>
   228e2:	4606      	mov	r6, r0
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   228e4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   228e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   228ec:	2001      	movs	r0, #1
   228ee:	f7f6 fcaf 	bl	19250 <bt_buf_get_rx>
   228f2:	4605      	mov	r5, r0
   228f4:	f100 0408 	add.w	r4, r0, #8
   228f8:	2102      	movs	r1, #2
   228fa:	4620      	mov	r0, r4
   228fc:	f7fc fc22 	bl	1f144 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
   22900:	233e      	movs	r3, #62	; 0x3e
   22902:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
   22904:	2342      	movs	r3, #66	; 0x42
   22906:	7043      	strb	r3, [r0, #1]
   22908:	2101      	movs	r1, #1
   2290a:	4620      	mov	r0, r4
   2290c:	f7fc fc1a 	bl	1f144 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
   22910:	2308      	movs	r3, #8
   22912:	7003      	strb	r3, [r0, #0]
   22914:	2141      	movs	r1, #65	; 0x41
   22916:	4620      	mov	r0, r4
   22918:	f7fc fc14 	bl	1f144 <net_buf_simple_add>
   2291c:	4604      	mov	r4, r0
	evt->status = status;
   2291e:	7006      	strb	r6, [r0, #0]
	if (status) {
   22920:	b136      	cbz	r6, 22930 <ecdh_p256_public_key+0x54>
   22922:	2240      	movs	r2, #64	; 0x40
   22924:	2100      	movs	r1, #0
   22926:	3001      	adds	r0, #1
   22928:	f00e fabe 	bl	30ea8 <memset>
}
   2292c:	4628      	mov	r0, r5
   2292e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sys_memcpy_swap(&evt->key[0], &ecdh.public_key_be[0], 32);
   22930:	1c46      	adds	r6, r0, #1
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   22932:	4b27      	ldr	r3, [pc, #156]	; (229d0 <ecdh_p256_public_key+0xf4>)
   22934:	429e      	cmp	r6, r3
   22936:	d902      	bls.n	2293e <ecdh_p256_public_key+0x62>
   22938:	3320      	adds	r3, #32
   2293a:	429e      	cmp	r6, r3
   2293c:	d213      	bcs.n	22966 <ecdh_p256_public_key+0x8a>
   2293e:	4b24      	ldr	r3, [pc, #144]	; (229d0 <ecdh_p256_public_key+0xf4>)
   22940:	429e      	cmp	r6, r3
   22942:	d204      	bcs.n	2294e <ecdh_p256_public_key+0x72>
   22944:	f106 0320 	add.w	r3, r6, #32
   22948:	4a21      	ldr	r2, [pc, #132]	; (229d0 <ecdh_p256_public_key+0xf4>)
   2294a:	4293      	cmp	r3, r2
   2294c:	d90b      	bls.n	22966 <ecdh_p256_public_key+0x8a>
   2294e:	4f21      	ldr	r7, [pc, #132]	; (229d4 <ecdh_p256_public_key+0xf8>)
   22950:	f240 2217 	movw	r2, #535	; 0x217
   22954:	4639      	mov	r1, r7
   22956:	4820      	ldr	r0, [pc, #128]	; (229d8 <ecdh_p256_public_key+0xfc>)
   22958:	f009 fde9 	bl	2c52e <assert_print>
   2295c:	f240 2117 	movw	r1, #535	; 0x217
   22960:	4638      	mov	r0, r7
   22962:	f009 fddd 	bl	2c520 <assert_post_action>
	psrc += length - 1;
   22966:	4b1d      	ldr	r3, [pc, #116]	; (229dc <ecdh_p256_public_key+0x100>)
	for (; length > 0; length--) {
   22968:	2120      	movs	r1, #32
   2296a:	e006      	b.n	2297a <ecdh_p256_public_key+0x9e>
		*pdst++ = *psrc--;
   2296c:	4632      	mov	r2, r6
   2296e:	f813 0901 	ldrb.w	r0, [r3], #-1
   22972:	f802 0b01 	strb.w	r0, [r2], #1
	for (; length > 0; length--) {
   22976:	3901      	subs	r1, #1
		*pdst++ = *psrc--;
   22978:	4616      	mov	r6, r2
	for (; length > 0; length--) {
   2297a:	2900      	cmp	r1, #0
   2297c:	d1f6      	bne.n	2296c <ecdh_p256_public_key+0x90>
		sys_memcpy_swap(&evt->key[32], &ecdh.public_key_be[32], 32);
   2297e:	3421      	adds	r4, #33	; 0x21
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   22980:	4b17      	ldr	r3, [pc, #92]	; (229e0 <ecdh_p256_public_key+0x104>)
   22982:	429c      	cmp	r4, r3
   22984:	d902      	bls.n	2298c <ecdh_p256_public_key+0xb0>
   22986:	3320      	adds	r3, #32
   22988:	429c      	cmp	r4, r3
   2298a:	d213      	bcs.n	229b4 <ecdh_p256_public_key+0xd8>
   2298c:	4b14      	ldr	r3, [pc, #80]	; (229e0 <ecdh_p256_public_key+0x104>)
   2298e:	429c      	cmp	r4, r3
   22990:	d204      	bcs.n	2299c <ecdh_p256_public_key+0xc0>
   22992:	f104 0320 	add.w	r3, r4, #32
   22996:	4a12      	ldr	r2, [pc, #72]	; (229e0 <ecdh_p256_public_key+0x104>)
   22998:	4293      	cmp	r3, r2
   2299a:	d90b      	bls.n	229b4 <ecdh_p256_public_key+0xd8>
   2299c:	4e0d      	ldr	r6, [pc, #52]	; (229d4 <ecdh_p256_public_key+0xf8>)
   2299e:	f240 2217 	movw	r2, #535	; 0x217
   229a2:	4631      	mov	r1, r6
   229a4:	480c      	ldr	r0, [pc, #48]	; (229d8 <ecdh_p256_public_key+0xfc>)
   229a6:	f009 fdc2 	bl	2c52e <assert_print>
   229aa:	f240 2117 	movw	r1, #535	; 0x217
   229ae:	4630      	mov	r0, r6
   229b0:	f009 fdb6 	bl	2c520 <assert_post_action>
	psrc += length - 1;
   229b4:	4b0b      	ldr	r3, [pc, #44]	; (229e4 <ecdh_p256_public_key+0x108>)
	for (; length > 0; length--) {
   229b6:	2120      	movs	r1, #32
   229b8:	e006      	b.n	229c8 <ecdh_p256_public_key+0xec>
		*pdst++ = *psrc--;
   229ba:	4622      	mov	r2, r4
   229bc:	f813 0901 	ldrb.w	r0, [r3], #-1
   229c0:	f802 0b01 	strb.w	r0, [r2], #1
	for (; length > 0; length--) {
   229c4:	3901      	subs	r1, #1
		*pdst++ = *psrc--;
   229c6:	4614      	mov	r4, r2
	for (; length > 0; length--) {
   229c8:	2900      	cmp	r1, #0
   229ca:	d1f6      	bne.n	229ba <ecdh_p256_public_key+0xde>
   229cc:	e7ae      	b.n	2292c <ecdh_p256_public_key+0x50>
   229ce:	bf00      	nop
   229d0:	200045b0 	.word	0x200045b0
   229d4:	0003ba1c 	.word	0x0003ba1c
   229d8:	00031600 	.word	0x00031600
   229dc:	200045cf 	.word	0x200045cf
   229e0:	200045d0 	.word	0x200045d0
   229e4:	200045ef 	.word	0x200045ef

000229e8 <ecdh_cmd_process>:
{
   229e8:	b508      	push	{r3, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   229ea:	f3bf 8f5b 	dmb	ish
   229ee:	4b15      	ldr	r3, [pc, #84]	; (22a44 <ecdh_cmd_process+0x5c>)
   229f0:	681b      	ldr	r3, [r3, #0]
   229f2:	f3bf 8f5b 	dmb	ish
	switch (atomic_get(&cmd)) {
   229f6:	2b02      	cmp	r3, #2
   229f8:	d01c      	beq.n	22a34 <ecdh_cmd_process+0x4c>
   229fa:	2b04      	cmp	r3, #4
   229fc:	d01e      	beq.n	22a3c <ecdh_cmd_process+0x54>
   229fe:	2b01      	cmp	r3, #1
   22a00:	d005      	beq.n	22a0e <ecdh_cmd_process+0x26>
		BT_WARN("Unknown command");
   22a02:	2157      	movs	r1, #87	; 0x57
   22a04:	4810      	ldr	r0, [pc, #64]	; (22a48 <ecdh_cmd_process+0x60>)
   22a06:	f009 fda1 	bl	2c54c <z_log_minimal_printk>
		buf = NULL;
   22a0a:	2000      	movs	r0, #0
		break;
   22a0c:	e001      	b.n	22a12 <ecdh_cmd_process+0x2a>
		buf = ecdh_p256_public_key();
   22a0e:	f7ff ff65 	bl	228dc <ecdh_p256_public_key>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   22a12:	4b0c      	ldr	r3, [pc, #48]	; (22a44 <ecdh_cmd_process+0x5c>)
   22a14:	2200      	movs	r2, #0
   22a16:	f3bf 8f5b 	dmb	ish
   22a1a:	e853 1f00 	ldrex	r1, [r3]
   22a1e:	e843 2c00 	strex	ip, r2, [r3]
   22a22:	f1bc 0f00 	cmp.w	ip, #0
   22a26:	d1f8      	bne.n	22a1a <ecdh_cmd_process+0x32>
   22a28:	f3bf 8f5b 	dmb	ish
	if (buf) {
   22a2c:	b108      	cbz	r0, 22a32 <ecdh_cmd_process+0x4a>
		bt_recv(buf);
   22a2e:	f7f7 fdf5 	bl	1a61c <bt_recv>
}
   22a32:	bd08      	pop	{r3, pc}
		buf = ecdh_p256_common_secret(false);
   22a34:	2000      	movs	r0, #0
   22a36:	f7ff fef7 	bl	22828 <ecdh_p256_common_secret>
		break;
   22a3a:	e7ea      	b.n	22a12 <ecdh_cmd_process+0x2a>
		buf = ecdh_p256_common_secret(true);
   22a3c:	2001      	movs	r0, #1
   22a3e:	f7ff fef3 	bl	22828 <ecdh_p256_common_secret>
		break;
   22a42:	e7e6      	b.n	22a12 <ecdh_cmd_process+0x2a>
   22a44:	2000458c 	.word	0x2000458c
   22a48:	0003ba50 	.word	0x0003ba50

00022a4c <ecdh_thread>:

static void ecdh_thread(void *p1, void *p2, void *p3)
{
   22a4c:	b500      	push	{lr}
   22a4e:	b087      	sub	sp, #28
	struct k_poll_event events[1] = {
   22a50:	2300      	movs	r3, #0
   22a52:	9301      	str	r3, [sp, #4]
   22a54:	9302      	str	r3, [sp, #8]
   22a56:	9303      	str	r3, [sp, #12]
   22a58:	9304      	str	r3, [sp, #16]
   22a5a:	9305      	str	r3, [sp, #20]
   22a5c:	f89d 3011 	ldrb.w	r3, [sp, #17]
   22a60:	2201      	movs	r2, #1
   22a62:	f362 0304 	bfi	r3, r2, #0, #5
   22a66:	f88d 3011 	strb.w	r3, [sp, #17]
   22a6a:	4b0a      	ldr	r3, [pc, #40]	; (22a94 <ecdh_thread+0x48>)
   22a6c:	9305      	str	r3, [sp, #20]
	return z_impl_k_poll(events, num_events, timeout);
   22a6e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   22a72:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22a76:	2101      	movs	r1, #1
   22a78:	a801      	add	r0, sp, #4
   22a7a:	f007 f9f3 	bl	29e64 <z_impl_k_poll>
	z_impl_k_poll_signal_reset(sig);
   22a7e:	4805      	ldr	r0, [pc, #20]	; (22a94 <ecdh_thread+0x48>)
   22a80:	f00e f944 	bl	30d0c <z_impl_k_poll_signal_reset>

	while (true) {
		k_poll(events, 1, K_FOREVER);

		k_poll_signal_reset(&ecdh_signal);
		events[0].state = K_POLL_STATE_NOT_READY;
   22a84:	9b04      	ldr	r3, [sp, #16]
   22a86:	f36f 3352 	bfc	r3, #13, #6
   22a8a:	9304      	str	r3, [sp, #16]

		ecdh_cmd_process();
   22a8c:	f7ff ffac 	bl	229e8 <ecdh_cmd_process>
	while (true) {
   22a90:	e7ed      	b.n	22a6e <ecdh_thread+0x22>
   22a92:	bf00      	nop
   22a94:	200045f0 	.word	0x200045f0

00022a98 <hci_ecdh_init>:
	}
}
#endif /* !defined(CONFIG_BT_CTLR_ECDH_IN_MPSL_WORK) */

void hci_ecdh_init(void)
{
   22a98:	b510      	push	{r4, lr}
   22a9a:	b088      	sub	sp, #32
	z_impl_k_poll_signal_init(sig);
   22a9c:	480d      	ldr	r0, [pc, #52]	; (22ad4 <hci_ecdh_init+0x3c>)
   22a9e:	f00e f930 	bl	30d02 <z_impl_k_poll_signal_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   22aa2:	4c0d      	ldr	r4, [pc, #52]	; (22ad8 <hci_ecdh_init+0x40>)
   22aa4:	2200      	movs	r2, #0
   22aa6:	2300      	movs	r3, #0
   22aa8:	e9cd 2306 	strd	r2, r3, [sp, #24]
   22aac:	2300      	movs	r3, #0
   22aae:	9304      	str	r3, [sp, #16]
   22ab0:	220a      	movs	r2, #10
   22ab2:	9203      	str	r2, [sp, #12]
   22ab4:	9302      	str	r3, [sp, #8]
   22ab6:	9301      	str	r3, [sp, #4]
   22ab8:	9300      	str	r3, [sp, #0]
   22aba:	4b08      	ldr	r3, [pc, #32]	; (22adc <hci_ecdh_init+0x44>)
   22abc:	f44f 7262 	mov.w	r2, #904	; 0x388
   22ac0:	4907      	ldr	r1, [pc, #28]	; (22ae0 <hci_ecdh_init+0x48>)
   22ac2:	4620      	mov	r0, r4
   22ac4:	f003 fd3e 	bl	26544 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
   22ac8:	4906      	ldr	r1, [pc, #24]	; (22ae4 <hci_ecdh_init+0x4c>)
   22aca:	4620      	mov	r0, r4
   22acc:	f00d ff24 	bl	30918 <z_impl_k_thread_name_set>
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecdh_thread_data, "BT CTLR ECDH");
#else
	k_work_init(&ecdh_work, ecdh_work_handler);
#endif /* !defined(CONFIG_BT_CTLR_ECDH_IN_MPSL_WORK) */
}
   22ad0:	b008      	add	sp, #32
   22ad2:	bd10      	pop	{r4, pc}
   22ad4:	200045f0 	.word	0x200045f0
   22ad8:	20002410 	.word	0x20002410
   22adc:	00022a4d 	.word	0x00022a4d
   22ae0:	20005d00 	.word	0x20005d00
   22ae4:	0003ba68 	.word	0x0003ba68

00022ae8 <hci_cmd_le_read_local_p256_public_key>:

uint8_t hci_cmd_le_read_local_p256_public_key(void)
{
   22ae8:	b508      	push	{r3, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   22aea:	4b0a      	ldr	r3, [pc, #40]	; (22b14 <hci_cmd_le_read_local_p256_public_key+0x2c>)
   22aec:	2201      	movs	r2, #1
   22aee:	f3bf 8f5b 	dmb	ish
   22af2:	e853 1f00 	ldrex	r1, [r3]
   22af6:	2900      	cmp	r1, #0
   22af8:	d103      	bne.n	22b02 <hci_cmd_le_read_local_p256_public_key+0x1a>
   22afa:	e843 2000 	strex	r0, r2, [r3]
   22afe:	2800      	cmp	r0, #0
   22b00:	d1f7      	bne.n	22af2 <hci_cmd_le_read_local_p256_public_key+0xa>
   22b02:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&cmd, 0, GEN_PUBLIC_KEY)) {
   22b06:	d103      	bne.n	22b10 <hci_cmd_le_read_local_p256_public_key+0x28>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	work_submit();
   22b08:	f7ff fe86 	bl	22818 <work_submit>

	return 0;
   22b0c:	2000      	movs	r0, #0
}
   22b0e:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   22b10:	200c      	movs	r0, #12
   22b12:	e7fc      	b.n	22b0e <hci_cmd_le_read_local_p256_public_key+0x26>
   22b14:	2000458c 	.word	0x2000458c

00022b18 <cmd_le_generate_dhkey>:

uint8_t cmd_le_generate_dhkey(uint8_t *key, uint8_t key_type)
{
   22b18:	b538      	push	{r3, r4, r5, lr}
   22b1a:	4604      	mov	r4, r0
	if (!atomic_cas(&cmd, 0, key_type ? GEN_DHKEY_DEBUG : GEN_DHKEY)) {
   22b1c:	b369      	cbz	r1, 22b7a <cmd_le_generate_dhkey+0x62>
   22b1e:	2204      	movs	r2, #4
   22b20:	4b31      	ldr	r3, [pc, #196]	; (22be8 <cmd_le_generate_dhkey+0xd0>)
   22b22:	f3bf 8f5b 	dmb	ish
   22b26:	e853 1f00 	ldrex	r1, [r3]
   22b2a:	2900      	cmp	r1, #0
   22b2c:	d103      	bne.n	22b36 <cmd_le_generate_dhkey+0x1e>
   22b2e:	e843 2000 	strex	r0, r2, [r3]
   22b32:	2800      	cmp	r0, #0
   22b34:	d1f7      	bne.n	22b26 <cmd_le_generate_dhkey+0xe>
   22b36:	f3bf 8f5b 	dmb	ish
   22b3a:	d152      	bne.n	22be2 <cmd_le_generate_dhkey+0xca>
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   22b3c:	4b2b      	ldr	r3, [pc, #172]	; (22bec <cmd_le_generate_dhkey+0xd4>)
   22b3e:	429c      	cmp	r4, r3
   22b40:	d204      	bcs.n	22b4c <cmd_le_generate_dhkey+0x34>
   22b42:	f104 0320 	add.w	r3, r4, #32
   22b46:	4a29      	ldr	r2, [pc, #164]	; (22bec <cmd_le_generate_dhkey+0xd4>)
   22b48:	4293      	cmp	r3, r2
   22b4a:	d911      	bls.n	22b70 <cmd_le_generate_dhkey+0x58>
   22b4c:	4b27      	ldr	r3, [pc, #156]	; (22bec <cmd_le_generate_dhkey+0xd4>)
   22b4e:	429c      	cmp	r4, r3
   22b50:	d902      	bls.n	22b58 <cmd_le_generate_dhkey+0x40>
   22b52:	3320      	adds	r3, #32
   22b54:	429c      	cmp	r4, r3
   22b56:	d20b      	bcs.n	22b70 <cmd_le_generate_dhkey+0x58>
   22b58:	4d25      	ldr	r5, [pc, #148]	; (22bf0 <cmd_le_generate_dhkey+0xd8>)
   22b5a:	f240 2217 	movw	r2, #535	; 0x217
   22b5e:	4629      	mov	r1, r5
   22b60:	4824      	ldr	r0, [pc, #144]	; (22bf4 <cmd_le_generate_dhkey+0xdc>)
   22b62:	f009 fce4 	bl	2c52e <assert_print>
   22b66:	f240 2117 	movw	r1, #535	; 0x217
   22b6a:	4628      	mov	r0, r5
   22b6c:	f009 fcd8 	bl	2c520 <assert_post_action>
	psrc += length - 1;
   22b70:	f104 021f 	add.w	r2, r4, #31
	uint8_t *pdst = (uint8_t *)dst;
   22b74:	4b1d      	ldr	r3, [pc, #116]	; (22bec <cmd_le_generate_dhkey+0xd4>)
	for (; length > 0; length--) {
   22b76:	2120      	movs	r1, #32
   22b78:	e006      	b.n	22b88 <cmd_le_generate_dhkey+0x70>
   22b7a:	2202      	movs	r2, #2
   22b7c:	e7d0      	b.n	22b20 <cmd_le_generate_dhkey+0x8>
		*pdst++ = *psrc--;
   22b7e:	f812 0901 	ldrb.w	r0, [r2], #-1
   22b82:	f803 0b01 	strb.w	r0, [r3], #1
	for (; length > 0; length--) {
   22b86:	3901      	subs	r1, #1
   22b88:	2900      	cmp	r1, #0
   22b8a:	d1f8      	bne.n	22b7e <cmd_le_generate_dhkey+0x66>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	sys_memcpy_swap(&ecdh.public_key_be[0], &key[0], 32);
	sys_memcpy_swap(&ecdh.public_key_be[32], &key[32], 32);
   22b8c:	3420      	adds	r4, #32
	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
   22b8e:	4b1a      	ldr	r3, [pc, #104]	; (22bf8 <cmd_le_generate_dhkey+0xe0>)
   22b90:	429c      	cmp	r4, r3
   22b92:	d204      	bcs.n	22b9e <cmd_le_generate_dhkey+0x86>
   22b94:	f104 0320 	add.w	r3, r4, #32
   22b98:	4a17      	ldr	r2, [pc, #92]	; (22bf8 <cmd_le_generate_dhkey+0xe0>)
   22b9a:	4293      	cmp	r3, r2
   22b9c:	d911      	bls.n	22bc2 <cmd_le_generate_dhkey+0xaa>
   22b9e:	4b16      	ldr	r3, [pc, #88]	; (22bf8 <cmd_le_generate_dhkey+0xe0>)
   22ba0:	429c      	cmp	r4, r3
   22ba2:	d902      	bls.n	22baa <cmd_le_generate_dhkey+0x92>
   22ba4:	3320      	adds	r3, #32
   22ba6:	429c      	cmp	r4, r3
   22ba8:	d20b      	bcs.n	22bc2 <cmd_le_generate_dhkey+0xaa>
   22baa:	4d11      	ldr	r5, [pc, #68]	; (22bf0 <cmd_le_generate_dhkey+0xd8>)
   22bac:	f240 2217 	movw	r2, #535	; 0x217
   22bb0:	4629      	mov	r1, r5
   22bb2:	4810      	ldr	r0, [pc, #64]	; (22bf4 <cmd_le_generate_dhkey+0xdc>)
   22bb4:	f009 fcbb 	bl	2c52e <assert_print>
   22bb8:	f240 2117 	movw	r1, #535	; 0x217
   22bbc:	4628      	mov	r0, r5
   22bbe:	f009 fcaf 	bl	2c520 <assert_post_action>
	psrc += length - 1;
   22bc2:	f104 031f 	add.w	r3, r4, #31
	uint8_t *pdst = (uint8_t *)dst;
   22bc6:	4a0c      	ldr	r2, [pc, #48]	; (22bf8 <cmd_le_generate_dhkey+0xe0>)
	for (; length > 0; length--) {
   22bc8:	2120      	movs	r1, #32
   22bca:	e004      	b.n	22bd6 <cmd_le_generate_dhkey+0xbe>
		*pdst++ = *psrc--;
   22bcc:	f813 0901 	ldrb.w	r0, [r3], #-1
   22bd0:	f802 0b01 	strb.w	r0, [r2], #1
	for (; length > 0; length--) {
   22bd4:	3901      	subs	r1, #1
   22bd6:	2900      	cmp	r1, #0
   22bd8:	d1f8      	bne.n	22bcc <cmd_le_generate_dhkey+0xb4>

	work_submit();
   22bda:	f7ff fe1d 	bl	22818 <work_submit>

	return 0;
   22bde:	2000      	movs	r0, #0
}
   22be0:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   22be2:	200c      	movs	r0, #12
   22be4:	e7fc      	b.n	22be0 <cmd_le_generate_dhkey+0xc8>
   22be6:	bf00      	nop
   22be8:	2000458c 	.word	0x2000458c
   22bec:	200045b0 	.word	0x200045b0
   22bf0:	0003ba1c 	.word	0x0003ba1c
   22bf4:	00031600 	.word	0x00031600
   22bf8:	200045d0 	.word	0x200045d0

00022bfc <mpsl_lib_init>:
	return 0;
#endif
}

static int mpsl_lib_init(const struct device *dev)
{
   22bfc:	b510      	push	{r4, lr}
   22bfe:	b082      	sub	sp, #8
	ARG_UNUSED(dev);
	int err = 0;
	mpsl_clock_lfclk_cfg_t clock_cfg;

	clock_cfg.source = m_config_clock_source_get();
   22c00:	f00d fc18 	bl	30434 <m_config_clock_source_get>
   22c04:	f88d 0000 	strb.w	r0, [sp]
	clock_cfg.accuracy_ppm = CONFIG_CLOCK_CONTROL_NRF_ACCURACY;
   22c08:	2332      	movs	r3, #50	; 0x32
   22c0a:	f8ad 3004 	strh.w	r3, [sp, #4]
	clock_cfg.skip_wait_lfclk_started =
   22c0e:	2300      	movs	r3, #0
   22c10:	f88d 3006 	strb.w	r3, [sp, #6]
	clock_cfg.rc_ctiv = (CONFIG_CLOCK_CONTROL_NRF_CALIBRATION_PERIOD * 4 / 1000);
	clock_cfg.rc_temp_ctiv = CONFIG_CLOCK_CONTROL_NRF_CALIBRATION_MAX_SKIP + 1;
	BUILD_ASSERT(CONFIG_CLOCK_CONTROL_NRF_CALIBRATION_TEMP_DIFF == 2,
		     "MPSL always uses a temperature diff threshold of 0.5 degrees");
#else
	clock_cfg.rc_ctiv = 0;
   22c14:	f88d 3001 	strb.w	r3, [sp, #1]
	clock_cfg.rc_temp_ctiv = 0;
   22c18:	f88d 3002 	strb.w	r3, [sp, #2]
#endif

	err = mpsl_init(&clock_cfg, MPSL_LOW_PRIO_IRQn, m_assert_handler);
   22c1c:	4a0c      	ldr	r2, [pc, #48]	; (22c50 <mpsl_lib_init+0x54>)
   22c1e:	2119      	movs	r1, #25
   22c20:	4668      	mov	r0, sp
   22c22:	f7e1 ffeb 	bl	4bfc <mpsl_init>
	if (err) {
   22c26:	4604      	mov	r4, r0
   22c28:	b110      	cbz	r0, 22c30 <mpsl_lib_init+0x34>
			   mpsl_rtc0_isr_wrapper, IRQ_CONNECT_FLAGS);
	IRQ_DIRECT_CONNECT(RADIO_IRQn, MPSL_HIGH_IRQ_PRIORITY,
			   mpsl_radio_isr_wrapper, IRQ_CONNECT_FLAGS);

	return 0;
}
   22c2a:	4620      	mov	r0, r4
   22c2c:	b002      	add	sp, #8
   22c2e:	bd10      	pop	{r4, pc}
	IRQ_DIRECT_CONNECT(TIMER0_IRQn, MPSL_HIGH_IRQ_PRIORITY,
   22c30:	2201      	movs	r2, #1
   22c32:	2100      	movs	r1, #0
   22c34:	2008      	movs	r0, #8
   22c36:	f7f5 fb5f 	bl	182f8 <z_arm_irq_priority_set>
	IRQ_DIRECT_CONNECT(RTC0_IRQn, MPSL_HIGH_IRQ_PRIORITY,
   22c3a:	2201      	movs	r2, #1
   22c3c:	2100      	movs	r1, #0
   22c3e:	200b      	movs	r0, #11
   22c40:	f7f5 fb5a 	bl	182f8 <z_arm_irq_priority_set>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, MPSL_HIGH_IRQ_PRIORITY,
   22c44:	2201      	movs	r2, #1
   22c46:	2100      	movs	r1, #0
   22c48:	4610      	mov	r0, r2
   22c4a:	f7f5 fb55 	bl	182f8 <z_arm_irq_priority_set>
	return 0;
   22c4e:	e7ec      	b.n	22c2a <mpsl_lib_init+0x2e>
   22c50:	00022c55 	.word	0x00022c55

00022c54 <m_assert_handler>:
{
   22c54:	b508      	push	{r3, lr}
   22c56:	4602      	mov	r2, r0
   22c58:	460b      	mov	r3, r1
	LOG_ERR("MPSL ASSERT: %s, %d", file, line);
   22c5a:	2145      	movs	r1, #69	; 0x45
   22c5c:	4804      	ldr	r0, [pc, #16]	; (22c70 <m_assert_handler+0x1c>)
   22c5e:	f009 fc75 	bl	2c54c <z_log_minimal_printk>
	k_oops();
   22c62:	4040      	eors	r0, r0
   22c64:	f380 8811 	msr	BASEPRI, r0
   22c68:	f04f 0003 	mov.w	r0, #3
   22c6c:	df02      	svc	2
}
   22c6e:	bd08      	pop	{r3, pc}
   22c70:	0003baa0 	.word	0x0003baa0

00022c74 <mpsl_low_prio_work_handler>:
{
   22c74:	b510      	push	{r4, lr}
	errcode = MULTITHREADING_LOCK_ACQUIRE();
   22c76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22c7a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   22c7e:	f7ff fae3 	bl	22248 <multithreading_lock_acquire>
	__ASSERT_NO_MSG(errcode == 0);
   22c82:	b920      	cbnz	r0, 22c8e <mpsl_low_prio_work_handler+0x1a>
	mpsl_low_priority_process();
   22c84:	f7ea f933 	bl	ceee <mpsl_low_priority_process>
	MULTITHREADING_LOCK_RELEASE();
   22c88:	f7ff fae8 	bl	2225c <multithreading_lock_release>
}
   22c8c:	bd10      	pop	{r4, pc}
	__ASSERT_NO_MSG(errcode == 0);
   22c8e:	4c05      	ldr	r4, [pc, #20]	; (22ca4 <mpsl_low_prio_work_handler+0x30>)
   22c90:	2247      	movs	r2, #71	; 0x47
   22c92:	4621      	mov	r1, r4
   22c94:	4804      	ldr	r0, [pc, #16]	; (22ca8 <mpsl_low_prio_work_handler+0x34>)
   22c96:	f009 fc4a 	bl	2c52e <assert_print>
   22c9a:	2147      	movs	r1, #71	; 0x47
   22c9c:	4620      	mov	r0, r4
   22c9e:	f009 fc3f 	bl	2c520 <assert_post_action>
   22ca2:	e7ef      	b.n	22c84 <mpsl_low_prio_work_handler+0x10>
   22ca4:	0003babc 	.word	0x0003babc
   22ca8:	00031600 	.word	0x00031600

00022cac <mpsl_low_prio_init>:

static int mpsl_low_prio_init(const struct device *dev)
{
   22cac:	b530      	push	{r4, r5, lr}
   22cae:	b083      	sub	sp, #12
	ARG_UNUSED(dev);

	k_work_queue_start(&mpsl_work_q, mpsl_work_stack,
   22cb0:	4d0d      	ldr	r5, [pc, #52]	; (22ce8 <mpsl_low_prio_init+0x3c>)
   22cb2:	2400      	movs	r4, #0
   22cb4:	9400      	str	r4, [sp, #0]
   22cb6:	f06f 0309 	mvn.w	r3, #9
   22cba:	f44f 6280 	mov.w	r2, #1024	; 0x400
   22cbe:	490b      	ldr	r1, [pc, #44]	; (22cec <mpsl_low_prio_init+0x40>)
   22cc0:	4628      	mov	r0, r5
   22cc2:	f004 fced 	bl	276a0 <k_work_queue_start>
   22cc6:	490a      	ldr	r1, [pc, #40]	; (22cf0 <mpsl_low_prio_init+0x44>)
   22cc8:	4628      	mov	r0, r5
   22cca:	f00d fe25 	bl	30918 <z_impl_k_thread_name_set>
			   K_THREAD_STACK_SIZEOF(mpsl_work_stack),
			   K_PRIO_COOP(CONFIG_MPSL_THREAD_COOP_PRIO), NULL);
	k_thread_name_set(&mpsl_work_q.thread, "MPSL Work");
	k_work_init(&mpsl_low_prio_work, mpsl_low_prio_work_handler);
   22cce:	4909      	ldr	r1, [pc, #36]	; (22cf4 <mpsl_low_prio_init+0x48>)
   22cd0:	4809      	ldr	r0, [pc, #36]	; (22cf8 <mpsl_low_prio_init+0x4c>)
   22cd2:	f004 fc4d 	bl	27570 <k_work_init>

	IRQ_CONNECT(MPSL_LOW_PRIO_IRQn, MPSL_LOW_PRIO,
   22cd6:	4622      	mov	r2, r4
   22cd8:	2104      	movs	r1, #4
   22cda:	2019      	movs	r0, #25
   22cdc:	f7f5 fb0c 	bl	182f8 <z_arm_irq_priority_set>
		    mpsl_low_prio_irq_handler, NULL, 0);

	return 0;
}
   22ce0:	4620      	mov	r0, r4
   22ce2:	b003      	add	sp, #12
   22ce4:	bd30      	pop	{r4, r5, pc}
   22ce6:	bf00      	nop
   22ce8:	200024e0 	.word	0x200024e0
   22cec:	20006100 	.word	0x20006100
   22cf0:	0003baec 	.word	0x0003baec
   22cf4:	00022c75 	.word	0x00022c75
   22cf8:	20004600 	.word	0x20004600

00022cfc <mpsl_low_prio_irq_handler>:
{
   22cfc:	b508      	push	{r3, lr}
	k_work_submit_to_queue(&mpsl_work_q, &mpsl_low_prio_work);
   22cfe:	4902      	ldr	r1, [pc, #8]	; (22d08 <mpsl_low_prio_irq_handler+0xc>)
   22d00:	4802      	ldr	r0, [pc, #8]	; (22d0c <mpsl_low_prio_irq_handler+0x10>)
   22d02:	f00d feed 	bl	30ae0 <k_work_submit_to_queue>
}
   22d06:	bd08      	pop	{r3, pc}
   22d08:	20004600 	.word	0x20004600
   22d0c:	200024e0 	.word	0x200024e0

00022d10 <mpsl_hfclk_callback>:
#include <mpsl_clock.h>

static nrfx_clock_event_handler_t event_handler;

static void mpsl_hfclk_callback(void)
{
   22d10:	b508      	push	{r3, lr}
	event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   22d12:	4b02      	ldr	r3, [pc, #8]	; (22d1c <mpsl_hfclk_callback+0xc>)
   22d14:	681b      	ldr	r3, [r3, #0]
   22d16:	2000      	movs	r0, #0
   22d18:	4798      	blx	r3
}
   22d1a:	bd08      	pop	{r3, pc}
   22d1c:	20004610 	.word	0x20004610

00022d20 <nrfx_clock_start>:

void nrfx_clock_start(nrf_clock_domain_t domain)
{
   22d20:	b510      	push	{r4, lr}
	switch (domain) {
   22d22:	b128      	cbz	r0, 22d30 <nrfx_clock_start+0x10>
   22d24:	2801      	cmp	r0, #1
   22d26:	d108      	bne.n	22d3a <nrfx_clock_start+0x1a>
	case NRF_CLOCK_DOMAIN_HFCLK:
		mpsl_clock_hfclk_request(mpsl_hfclk_callback);
   22d28:	4809      	ldr	r0, [pc, #36]	; (22d50 <nrfx_clock_start+0x30>)
   22d2a:	f7e1 fddd 	bl	48e8 <mpsl_clock_hfclk_request>
		event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
		break;
	default:
		__ASSERT(0, "Not supported");
	}
}
   22d2e:	bd10      	pop	{r4, pc}
		event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   22d30:	4b08      	ldr	r3, [pc, #32]	; (22d54 <nrfx_clock_start+0x34>)
   22d32:	681b      	ldr	r3, [r3, #0]
   22d34:	2001      	movs	r0, #1
   22d36:	4798      	blx	r3
		break;
   22d38:	e7f9      	b.n	22d2e <nrfx_clock_start+0xe>
		__ASSERT(0, "Not supported");
   22d3a:	4c07      	ldr	r4, [pc, #28]	; (22d58 <nrfx_clock_start+0x38>)
   22d3c:	221c      	movs	r2, #28
   22d3e:	4621      	mov	r1, r4
   22d40:	4806      	ldr	r0, [pc, #24]	; (22d5c <nrfx_clock_start+0x3c>)
   22d42:	f009 fbf4 	bl	2c52e <assert_print>
   22d46:	211c      	movs	r1, #28
   22d48:	4620      	mov	r0, r4
   22d4a:	f009 fbe9 	bl	2c520 <assert_post_action>
}
   22d4e:	e7ee      	b.n	22d2e <nrfx_clock_start+0xe>
   22d50:	00022d11 	.word	0x00022d11
   22d54:	20004610 	.word	0x20004610
   22d58:	0003bb04 	.word	0x0003bb04
   22d5c:	00031600 	.word	0x00031600

00022d60 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
	switch (domain) {
   22d60:	b180      	cbz	r0, 22d84 <nrfx_clock_stop+0x24>
{
   22d62:	b510      	push	{r4, lr}
	switch (domain) {
   22d64:	2801      	cmp	r0, #1
   22d66:	d102      	bne.n	22d6e <nrfx_clock_stop+0xe>
	case NRF_CLOCK_DOMAIN_HFCLK:
		mpsl_clock_hfclk_release();
   22d68:	f7e1 fdb0 	bl	48cc <mpsl_clock_hfclk_release>
		/* empty */
		break;
	default:
		__ASSERT(0, "Not supported");
	}
}
   22d6c:	bd10      	pop	{r4, pc}
		__ASSERT(0, "Not supported");
   22d6e:	4c06      	ldr	r4, [pc, #24]	; (22d88 <nrfx_clock_stop+0x28>)
   22d70:	222a      	movs	r2, #42	; 0x2a
   22d72:	4621      	mov	r1, r4
   22d74:	4805      	ldr	r0, [pc, #20]	; (22d8c <nrfx_clock_stop+0x2c>)
   22d76:	f009 fbda 	bl	2c52e <assert_print>
   22d7a:	212a      	movs	r1, #42	; 0x2a
   22d7c:	4620      	mov	r0, r4
   22d7e:	f009 fbcf 	bl	2c520 <assert_post_action>
}
   22d82:	e7f3      	b.n	22d6c <nrfx_clock_stop+0xc>
   22d84:	4770      	bx	lr
   22d86:	bf00      	nop
   22d88:	0003bb04 	.word	0x0003bb04
   22d8c:	00031600 	.word	0x00031600

00022d90 <nrfx_clock_init>:

}

nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t handler)
{
	event_handler = handler;
   22d90:	4b01      	ldr	r3, [pc, #4]	; (22d98 <nrfx_clock_init+0x8>)
   22d92:	6018      	str	r0, [r3, #0]

	return NRFX_SUCCESS;
}
   22d94:	4801      	ldr	r0, [pc, #4]	; (22d9c <nrfx_clock_init+0xc>)
   22d96:	4770      	bx	lr
   22d98:	20004610 	.word	0x20004610
   22d9c:	0bad0000 	.word	0x0bad0000

00022da0 <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
   22da0:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   22da4:	4905      	ldr	r1, [pc, #20]	; (22dbc <__NVIC_SystemReset+0x1c>)
   22da6:	68ca      	ldr	r2, [r1, #12]
   22da8:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   22dac:	4b04      	ldr	r3, [pc, #16]	; (22dc0 <__NVIC_SystemReset+0x20>)
   22dae:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   22db0:	60cb      	str	r3, [r1, #12]
   22db2:	f3bf 8f4f 	dsb	sy
    __NOP();
   22db6:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   22db8:	e7fd      	b.n	22db6 <__NVIC_SystemReset+0x16>
   22dba:	bf00      	nop
   22dbc:	e000ed00 	.word	0xe000ed00
   22dc0:	05fa0004 	.word	0x05fa0004

00022dc4 <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   22dc4:	4b02      	ldr	r3, [pc, #8]	; (22dd0 <nvmc_wait+0xc>)
   22dc6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   22dca:	2b00      	cmp	r3, #0
   22dcc:	d0fa      	beq.n	22dc4 <nvmc_wait>
}
   22dce:	4770      	bx	lr
   22dd0:	4001e000 	.word	0x4001e000

00022dd4 <nvmc_config>:

/*  Configure the NVMC to "mode".
    Mode must be an enumerator of field NVMC_CONFIG_WEN */
void nvmc_config(uint32_t mode)
{
   22dd4:	b508      	push	{r3, lr}
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
   22dd6:	4b03      	ldr	r3, [pc, #12]	; (22de4 <nvmc_config+0x10>)
   22dd8:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
    nvmc_wait();
   22ddc:	f7ff fff2 	bl	22dc4 <nvmc_wait>
}
   22de0:	bd08      	pop	{r3, pc}
   22de2:	bf00      	nop
   22de4:	4001e000 	.word	0x4001e000

00022de8 <SystemCoreClockUpdate>:

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   22de8:	4b01      	ldr	r3, [pc, #4]	; (22df0 <SystemCoreClockUpdate+0x8>)
   22dea:	4a02      	ldr	r2, [pc, #8]	; (22df4 <SystemCoreClockUpdate+0xc>)
   22dec:	601a      	str	r2, [r3, #0]
}
   22dee:	4770      	bx	lr
   22df0:	20000d88 	.word	0x20000d88
   22df4:	03d09000 	.word	0x03d09000

00022df8 <SystemInit>:

void SystemInit(void)
{
   22df8:	b538      	push	{r3, r4, r5, lr}
    #endif

    #if NRF52_ERRATA_12_ENABLE_WORKAROUND
        /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_12()){
   22dfa:	f00d fb4d 	bl	30498 <nrf52_errata_12>
   22dfe:	b140      	cbz	r0, 22e12 <SystemInit+0x1a>
            *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
   22e00:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22e04:	f8d3 3324 	ldr.w	r3, [r3, #804]	; 0x324
   22e08:	f3c3 2304 	ubfx	r3, r3, #8, #5
   22e0c:	4a83      	ldr	r2, [pc, #524]	; (2301c <SystemInit+0x224>)
   22e0e:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    #endif

    #if NRF52_ERRATA_16_ENABLE_WORKAROUND
        /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_16()){
   22e12:	f00d fb53 	bl	304bc <nrf52_errata_16>
   22e16:	b110      	cbz	r0, 22e1e <SystemInit+0x26>
            *(volatile uint32_t *)0x4007C074 = 3131961357ul;
   22e18:	4b81      	ldr	r3, [pc, #516]	; (23020 <SystemInit+0x228>)
   22e1a:	4a82      	ldr	r2, [pc, #520]	; (23024 <SystemInit+0x22c>)
   22e1c:	675a      	str	r2, [r3, #116]	; 0x74
    #endif

    #if NRF52_ERRATA_31_ENABLE_WORKAROUND
        /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_31()){
   22e1e:	f00d fb63 	bl	304e8 <nrf52_errata_31>
   22e22:	b148      	cbz	r0, 22e38 <SystemInit+0x40>
            *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
   22e24:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22e28:	f8d3 3244 	ldr.w	r3, [r3, #580]	; 0x244
   22e2c:	f3c3 3342 	ubfx	r3, r3, #13, #3
   22e30:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   22e34:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
    #endif

    #if NRF52_ERRATA_32_ENABLE_WORKAROUND
        /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_32()){
   22e38:	f00d fb68 	bl	3050c <nrf52_errata_32>
   22e3c:	b130      	cbz	r0, 22e4c <SystemInit+0x54>
            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
   22e3e:	4a7a      	ldr	r2, [pc, #488]	; (23028 <SystemInit+0x230>)
   22e40:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   22e44:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   22e48:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
   22e4c:	f00d fb74 	bl	30538 <nrf52_errata_36>
   22e50:	b140      	cbz	r0, 22e64 <SystemInit+0x6c>
            NRF_CLOCK->EVENTS_DONE = 0;
   22e52:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22e56:	2200      	movs	r2, #0
   22e58:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
   22e5c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
   22e60:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_37_ENABLE_WORKAROUND
        /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_37()){
   22e64:	f00d fb7a 	bl	3055c <nrf52_errata_37>
   22e68:	b120      	cbz	r0, 22e74 <SystemInit+0x7c>
            *(volatile uint32_t *)0x400005A0 = 0x3;
   22e6a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22e6e:	2203      	movs	r2, #3
   22e70:	f8c3 25a0 	str.w	r2, [r3, #1440]	; 0x5a0
    #endif

    #if NRF52_ERRATA_57_ENABLE_WORKAROUND
        /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_57()){
   22e74:	f00d fb88 	bl	30588 <nrf52_errata_57>
   22e78:	b160      	cbz	r0, 22e94 <SystemInit+0x9c>
            *(volatile uint32_t *)0x40005610 = 0x00000005;
   22e7a:	4b6c      	ldr	r3, [pc, #432]	; (2302c <SystemInit+0x234>)
   22e7c:	2205      	movs	r2, #5
   22e7e:	f8c3 2610 	str.w	r2, [r3, #1552]	; 0x610
            *(volatile uint32_t *)0x40005688 = 0x00000001;
   22e82:	2201      	movs	r2, #1
   22e84:	f8c3 2688 	str.w	r2, [r3, #1672]	; 0x688
            *(volatile uint32_t *)0x40005618 = 0x00000000;
   22e88:	2200      	movs	r2, #0
   22e8a:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
            *(volatile uint32_t *)0x40005614 = 0x0000003F;
   22e8e:	223f      	movs	r2, #63	; 0x3f
   22e90:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
   22e94:	f00d fb8e 	bl	305b4 <nrf52_errata_66>
   22e98:	2800      	cmp	r0, #0
   22e9a:	d046      	beq.n	22f2a <SystemInit+0x132>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   22e9c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   22ea0:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   22ea4:	4b62      	ldr	r3, [pc, #392]	; (23030 <SystemInit+0x238>)
   22ea6:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   22eaa:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   22eae:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   22eb2:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   22eb6:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   22eba:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   22ebe:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   22ec2:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   22ec6:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   22eca:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   22ece:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   22ed2:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   22ed6:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   22eda:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   22ede:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   22ee2:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   22ee6:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   22eea:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   22eee:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   22ef2:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   22ef6:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   22efa:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   22efe:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   22f02:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   22f06:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   22f0a:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   22f0e:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   22f12:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
   22f16:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   22f1a:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
   22f1e:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   22f22:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   22f26:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_108_ENABLE_WORKAROUND
        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_108()){
   22f2a:	f00d fb65 	bl	305f8 <nrf52_errata_108>
   22f2e:	b148      	cbz	r0, 22f44 <SystemInit+0x14c>
            *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
   22f30:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22f34:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   22f38:	f003 034f 	and.w	r3, r3, #79	; 0x4f
   22f3c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   22f40:	f8c2 3ee4 	str.w	r3, [r2, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
   22f44:	f00d fb6a 	bl	3061c <nrf52_errata_136>
   22f48:	b160      	cbz	r0, 22f64 <SystemInit+0x16c>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   22f4a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22f4e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   22f52:	f013 0f01 	tst.w	r3, #1
   22f56:	d005      	beq.n	22f64 <SystemInit+0x16c>
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   22f58:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22f5c:	f06f 0201 	mvn.w	r2, #1
   22f60:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    #endif

    #if NRF52_ERRATA_182_ENABLE_WORKAROUND
        /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_182()){
   22f64:	f00d fb6c 	bl	30640 <nrf52_errata_182>
   22f68:	b130      	cbz	r0, 22f78 <SystemInit+0x180>
            *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
   22f6a:	4a32      	ldr	r2, [pc, #200]	; (23034 <SystemInit+0x23c>)
   22f6c:	f8d2 373c 	ldr.w	r3, [r2, #1852]	; 0x73c
   22f70:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   22f74:	f8c2 373c 	str.w	r3, [r2, #1852]	; 0x73c

    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
     * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
     * operations are not used in your code. */
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
   22f78:	4a2b      	ldr	r2, [pc, #172]	; (23028 <SystemInit+0x230>)
   22f7a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   22f7e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   22f82:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
   22f86:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   22f8a:	f3bf 8f6f 	isb	sy
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
   22f8e:	f00d fb6b 	bl	30668 <nrf52_configuration_249>
   22f92:	b138      	cbz	r0, 22fa4 <SystemInit+0x1ac>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
   22f94:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   22f98:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
   22f9c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   22fa0:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure NFCT pins as GPIOs if NFCT is not to be used in your code. If CONFIG_NFCT_PINS_AS_GPIOS is not defined,
       two GPIOs (see Product Specification to see which ones) will be reserved for NFC and will not be available as
       normal GPIOs. */
    #if defined (CONFIG_NFCT_PINS_AS_GPIOS) && defined(NFCT_PRESENT)
        if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
   22fa4:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   22fa8:	f8d3 320c 	ldr.w	r3, [r3, #524]	; 0x20c
   22fac:	f013 0f01 	tst.w	r3, #1
   22fb0:	d10e      	bne.n	22fd0 <SystemInit+0x1d8>

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   22fb2:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   22fb6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   22fba:	2b00      	cmp	r3, #0
   22fbc:	db1a      	blt.n	22ff4 <SystemInit+0x1fc>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   22fbe:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   22fc2:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   22fc6:	2b00      	cmp	r3, #0
   22fc8:	db14      	blt.n	22ff4 <SystemInit+0x1fc>
            nvmc_config(NVMC_CONFIG_WEN_Ren);
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
   22fca:	f7ff ff0d 	bl	22de8 <SystemCoreClockUpdate>
}
   22fce:	bd38      	pop	{r3, r4, r5, pc}
            nvmc_config(NVMC_CONFIG_WEN_Wen);
   22fd0:	2001      	movs	r0, #1
   22fd2:	f7ff feff 	bl	22dd4 <nvmc_config>
            NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
   22fd6:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
   22fda:	f8d2 320c 	ldr.w	r3, [r2, #524]	; 0x20c
   22fde:	f023 0301 	bic.w	r3, r3, #1
   22fe2:	f8c2 320c 	str.w	r3, [r2, #524]	; 0x20c
            nvmc_wait();
   22fe6:	f7ff feed 	bl	22dc4 <nvmc_wait>
            nvmc_config(NVMC_CONFIG_WEN_Ren);
   22fea:	2000      	movs	r0, #0
   22fec:	f7ff fef2 	bl	22dd4 <nvmc_config>
            NVIC_SystemReset();
   22ff0:	f7ff fed6 	bl	22da0 <__NVIC_SystemReset>
            nvmc_config(NVMC_CONFIG_WEN_Wen);
   22ff4:	2001      	movs	r0, #1
   22ff6:	f7ff feed 	bl	22dd4 <nvmc_config>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
   22ffa:	f04f 2410 	mov.w	r4, #268439552	; 0x10001000
   22ffe:	2515      	movs	r5, #21
   23000:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
            nvmc_wait();
   23004:	f7ff fede 	bl	22dc4 <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
   23008:	f8c4 5204 	str.w	r5, [r4, #516]	; 0x204
            nvmc_wait();
   2300c:	f7ff feda 	bl	22dc4 <nvmc_wait>
            nvmc_config(NVMC_CONFIG_WEN_Ren);
   23010:	2000      	movs	r0, #0
   23012:	f7ff fedf 	bl	22dd4 <nvmc_config>
            NVIC_SystemReset();
   23016:	f7ff fec3 	bl	22da0 <__NVIC_SystemReset>
   2301a:	bf00      	nop
   2301c:	40013000 	.word	0x40013000
   23020:	4007c000 	.word	0x4007c000
   23024:	baadf00d 	.word	0xbaadf00d
   23028:	e000ed00 	.word	0xe000ed00
   2302c:	40005000 	.word	0x40005000
   23030:	4000c000 	.word	0x4000c000
   23034:	40001000 	.word	0x40001000

00023038 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   23038:	b510      	push	{r4, lr}
    int8_t idx;
    uint32_t new_mask, prev_mask;

    do {
        prev_mask = *p_mask;
   2303a:	6804      	ldr	r4, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   2303c:	fab4 f384 	clz	r3, r4
   23040:	f1c3 031f 	rsb	r3, r3, #31
   23044:	fa5f fc83 	uxtb.w	ip, r3
        if (idx < 0) {
   23048:	2b00      	cmp	r3, #0
   2304a:	db16      	blt.n	2307a <nrfx_flag32_alloc+0x42>
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   2304c:	2201      	movs	r2, #1
   2304e:	fa02 f303 	lsl.w	r3, r2, r3
   23052:	ea24 0303 	bic.w	r3, r4, r3
   23056:	f3bf 8f5b 	dmb	ish
   2305a:	e850 2f00 	ldrex	r2, [r0]
   2305e:	42a2      	cmp	r2, r4
   23060:	d104      	bne.n	2306c <nrfx_flag32_alloc+0x34>
   23062:	e840 3e00 	strex	lr, r3, [r0]
   23066:	f1be 0f00 	cmp.w	lr, #0
   2306a:	d1f6      	bne.n	2305a <nrfx_flag32_alloc+0x22>
   2306c:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   23070:	d1e3      	bne.n	2303a <nrfx_flag32_alloc+0x2>

    *p_flag = idx;
   23072:	f881 c000 	strb.w	ip, [r1]

    return NRFX_SUCCESS;
   23076:	4802      	ldr	r0, [pc, #8]	; (23080 <nrfx_flag32_alloc+0x48>)
}
   23078:	bd10      	pop	{r4, pc}
            return NRFX_ERROR_NO_MEM;
   2307a:	4802      	ldr	r0, [pc, #8]	; (23084 <nrfx_flag32_alloc+0x4c>)
   2307c:	e7fc      	b.n	23078 <nrfx_flag32_alloc+0x40>
   2307e:	bf00      	nop
   23080:	0bad0000 	.word	0x0bad0000
   23084:	0bad0002 	.word	0x0bad0002

00023088 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   23088:	6803      	ldr	r3, [r0, #0]
   2308a:	40cb      	lsrs	r3, r1
   2308c:	f013 0f01 	tst.w	r3, #1
   23090:	d115      	bne.n	230be <nrfx_flag32_free+0x36>
{
   23092:	b500      	push	{lr}
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
   23094:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   23096:	2301      	movs	r3, #1
   23098:	408b      	lsls	r3, r1
   2309a:	4313      	orrs	r3, r2
   2309c:	f3bf 8f5b 	dmb	ish
   230a0:	e850 cf00 	ldrex	ip, [r0]
   230a4:	4594      	cmp	ip, r2
   230a6:	d104      	bne.n	230b2 <nrfx_flag32_free+0x2a>
   230a8:	e840 3e00 	strex	lr, r3, [r0]
   230ac:	f1be 0f00 	cmp.w	lr, #0
   230b0:	d1f6      	bne.n	230a0 <nrfx_flag32_free+0x18>
   230b2:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   230b6:	d1ed      	bne.n	23094 <nrfx_flag32_free+0xc>

    return NRFX_SUCCESS;
   230b8:	4802      	ldr	r0, [pc, #8]	; (230c4 <nrfx_flag32_free+0x3c>)
}
   230ba:	f85d fb04 	ldr.w	pc, [sp], #4
        return NRFX_ERROR_INVALID_PARAM;
   230be:	4802      	ldr	r0, [pc, #8]	; (230c8 <nrfx_flag32_free+0x40>)
}
   230c0:	4770      	bx	lr
   230c2:	bf00      	nop
   230c4:	0bad0000 	.word	0x0bad0000
   230c8:	0bad0004 	.word	0x0bad0004

000230cc <pin_in_use>:
 *
 * @return True if pin is in use.
 */
static bool pin_in_use(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   230cc:	3008      	adds	r0, #8
   230ce:	4b03      	ldr	r3, [pc, #12]	; (230dc <pin_in_use+0x10>)
   230d0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   230d4:	f000 0001 	and.w	r0, r0, #1
   230d8:	4770      	bx	lr
   230da:	bf00      	nop
   230dc:	20000d8c 	.word	0x20000d8c

000230e0 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   230e0:	3008      	adds	r0, #8
   230e2:	4b03      	ldr	r3, [pc, #12]	; (230f0 <pin_in_use_by_te+0x10>)
   230e4:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   230e8:	f3c0 1040 	ubfx	r0, r0, #5, #1
   230ec:	4770      	bx	lr
   230ee:	bf00      	nop
   230f0:	20000d8c 	.word	0x20000d8c

000230f4 <pin_has_trigger>:
 *
 * @return True if pin has trigger.
 */
static bool pin_has_trigger(uint32_t pin)
{
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
   230f4:	3008      	adds	r0, #8
   230f6:	4b04      	ldr	r3, [pc, #16]	; (23108 <pin_has_trigger+0x14>)
   230f8:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   230fc:	f010 001c 	ands.w	r0, r0, #28
   23100:	bf18      	it	ne
   23102:	2001      	movne	r0, #1
   23104:	4770      	bx	lr
   23106:	bf00      	nop
   23108:	20000d8c 	.word	0x20000d8c

0002310c <pin_is_output>:
 *
 * @return True if pin is output.
 */
static bool pin_is_output(uint32_t pin)
{
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   2310c:	3008      	adds	r0, #8
   2310e:	4b03      	ldr	r3, [pc, #12]	; (2311c <pin_is_output+0x10>)
   23110:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   23114:	f3c0 0040 	ubfx	r0, r0, #1, #1
   23118:	4770      	bx	lr
   2311a:	bf00      	nop
   2311c:	20000d8c 	.word	0x20000d8c

00023120 <pin_te_get>:
}

/* Returns gpiote TE channel associated with the pin */
static uint8_t pin_te_get(nrfx_gpiote_pin_t pin)
{
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   23120:	3008      	adds	r0, #8
   23122:	4b02      	ldr	r3, [pc, #8]	; (2312c <pin_te_get+0xc>)
   23124:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   23128:	0b40      	lsrs	r0, r0, #13
   2312a:	4770      	bx	lr
   2312c:	20000d8c 	.word	0x20000d8c

00023130 <handler_in_use>:
}

static bool handler_in_use(int32_t handler_id)
{

    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   23130:	2200      	movs	r2, #0
   23132:	e004      	b.n	2313e <handler_in_use+0xe>
    {
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   23134:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23138:	4283      	cmp	r3, r0
   2313a:	d00f      	beq.n	2315c <handler_in_use+0x2c>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   2313c:	3201      	adds	r2, #1
   2313e:	2a1f      	cmp	r2, #31
   23140:	d80a      	bhi.n	23158 <handler_in_use+0x28>
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   23142:	f102 0308 	add.w	r3, r2, #8
   23146:	4906      	ldr	r1, [pc, #24]	; (23160 <handler_in_use+0x30>)
   23148:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   2314c:	f413 7f80 	tst.w	r3, #256	; 0x100
   23150:	d0f0      	beq.n	23134 <handler_in_use+0x4>
   23152:	f3c3 2343 	ubfx	r3, r3, #9, #4
   23156:	e7ef      	b.n	23138 <handler_in_use+0x8>
        {
            return true;
        }
    }

    return false;
   23158:	2000      	movs	r0, #0
   2315a:	4770      	bx	lr
            return true;
   2315c:	2001      	movs	r0, #1
}
   2315e:	4770      	bx	lr
   23160:	20000d8c 	.word	0x20000d8c

00023164 <find_handler>:
    return NRFX_SUCCESS;
}

static int32_t find_handler(nrfx_gpiote_interrupt_handler_t handler, void * p_context)
{
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
   23164:	2300      	movs	r3, #0
   23166:	b113      	cbz	r3, 2316e <find_handler+0xa>
        {
            return i;
        }
    }

    return -1;
   23168:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   2316c:	4770      	bx	lr
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   2316e:	4a07      	ldr	r2, [pc, #28]	; (2318c <find_handler+0x28>)
   23170:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
   23174:	4282      	cmp	r2, r0
   23176:	d001      	beq.n	2317c <find_handler+0x18>
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
   23178:	3301      	adds	r3, #1
   2317a:	e7f4      	b.n	23166 <find_handler+0x2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   2317c:	4a03      	ldr	r2, [pc, #12]	; (2318c <find_handler+0x28>)
   2317e:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   23182:	6852      	ldr	r2, [r2, #4]
   23184:	428a      	cmp	r2, r1
   23186:	d1f7      	bne.n	23178 <find_handler+0x14>
            return i;
   23188:	4618      	mov	r0, r3
   2318a:	4770      	bx	lr
   2318c:	20000d8c 	.word	0x20000d8c

00023190 <channel_handler_get>:
}

/* Return handler associated with given pin or null. */
static nrfx_gpiote_handler_config_t const * channel_handler_get(nrfx_gpiote_pin_t pin)
{
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   23190:	3008      	adds	r0, #8
   23192:	4b06      	ldr	r3, [pc, #24]	; (231ac <channel_handler_get+0x1c>)
   23194:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   23198:	f410 7f80 	tst.w	r0, #256	; 0x100
   2319c:	d004      	beq.n	231a8 <channel_handler_get+0x18>
   2319e:	f3c0 2043 	ubfx	r0, r0, #9, #4
    if (handler_id == PIN_FLAG_NO_HANDLER)
    {
        return NULL;
    }

    return &m_cb.handlers[handler_id];
   231a2:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   231a6:	4770      	bx	lr
        return NULL;
   231a8:	2000      	movs	r0, #0
}
   231aa:	4770      	bx	lr
   231ac:	20000d8c 	.word	0x20000d8c

000231b0 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   231b0:	b570      	push	{r4, r5, r6, lr}
   231b2:	4604      	mov	r4, r0
   231b4:	460d      	mov	r5, r1
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);
   231b6:	f7ff ffeb 	bl	23190 <channel_handler_get>

    if (handler)
   231ba:	b120      	cbz	r0, 231c6 <call_handler+0x16>
    {
        handler->handler(pin, trigger, handler->p_context);
   231bc:	6806      	ldr	r6, [r0, #0]
   231be:	6842      	ldr	r2, [r0, #4]
   231c0:	4629      	mov	r1, r5
   231c2:	4620      	mov	r0, r4
   231c4:	47b0      	blx	r6
    }
    if (m_cb.global_handler.handler)
   231c6:	4b04      	ldr	r3, [pc, #16]	; (231d8 <call_handler+0x28>)
   231c8:	689b      	ldr	r3, [r3, #8]
   231ca:	b123      	cbz	r3, 231d6 <call_handler+0x26>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   231cc:	4a02      	ldr	r2, [pc, #8]	; (231d8 <call_handler+0x28>)
   231ce:	68d2      	ldr	r2, [r2, #12]
   231d0:	4629      	mov	r1, r5
   231d2:	4620      	mov	r0, r4
   231d4:	4798      	blx	r3
    }
}
   231d6:	bd70      	pop	{r4, r5, r6, pc}
   231d8:	20000d8c 	.word	0x20000d8c

000231dc <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   231dc:	f100 0208 	add.w	r2, r0, #8
   231e0:	4b16      	ldr	r3, [pc, #88]	; (2323c <release_handler+0x60>)
   231e2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   231e6:	f413 7f80 	tst.w	r3, #256	; 0x100
   231ea:	d025      	beq.n	23238 <release_handler+0x5c>
{
   231ec:	b510      	push	{r4, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   231ee:	f3c3 2443 	ubfx	r4, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   231f2:	4610      	mov	r0, r2
   231f4:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   231f8:	4a10      	ldr	r2, [pc, #64]	; (2323c <release_handler+0x60>)
   231fa:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    if (!handler_in_use(handler_id))
   231fe:	4620      	mov	r0, r4
   23200:	f7ff ff96 	bl	23130 <handler_in_use>
   23204:	b100      	cbz	r0, 23208 <release_handler+0x2c>
}
   23206:	bd10      	pop	{r4, pc}
        m_cb.handlers[handler_id].handler = NULL;
   23208:	480c      	ldr	r0, [pc, #48]	; (2323c <release_handler+0x60>)
   2320a:	2300      	movs	r3, #0
   2320c:	f840 3034 	str.w	r3, [r0, r4, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   23210:	4621      	mov	r1, r4
   23212:	3054      	adds	r0, #84	; 0x54
   23214:	f7ff ff38 	bl	23088 <nrfx_flag32_free>
        NRFX_ASSERT(err == NRFX_SUCCESS);
   23218:	4b09      	ldr	r3, [pc, #36]	; (23240 <release_handler+0x64>)
   2321a:	4298      	cmp	r0, r3
   2321c:	d0f3      	beq.n	23206 <release_handler+0x2a>
   2321e:	4c09      	ldr	r4, [pc, #36]	; (23244 <release_handler+0x68>)
   23220:	f44f 7299 	mov.w	r2, #306	; 0x132
   23224:	4621      	mov	r1, r4
   23226:	4808      	ldr	r0, [pc, #32]	; (23248 <release_handler+0x6c>)
   23228:	f009 f981 	bl	2c52e <assert_print>
   2322c:	f44f 7199 	mov.w	r1, #306	; 0x132
   23230:	4620      	mov	r0, r4
   23232:	f009 f975 	bl	2c520 <assert_post_action>
   23236:	e7e6      	b.n	23206 <release_handler+0x2a>
   23238:	4770      	bx	lr
   2323a:	bf00      	nop
   2323c:	20000d8c 	.word	0x20000d8c
   23240:	0bad0000 	.word	0x0bad0000
   23244:	0003bb44 	.word	0x0003bb44
   23248:	00031600 	.word	0x00031600

0002324c <pin_handler_trigger_uninit>:
{
   2324c:	b510      	push	{r4, lr}
   2324e:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin))
   23250:	f7ff ff46 	bl	230e0 <pin_in_use_by_te>
   23254:	b140      	cbz	r0, 23268 <pin_handler_trigger_uninit+0x1c>
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   23256:	4620      	mov	r0, r4
   23258:	f7ff ff62 	bl	23120 <pin_te_get>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   2325c:	f500 70a2 	add.w	r0, r0, #324	; 0x144
   23260:	4b06      	ldr	r3, [pc, #24]	; (2327c <pin_handler_trigger_uninit+0x30>)
   23262:	2200      	movs	r2, #0
   23264:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
    release_handler(pin);
   23268:	4620      	mov	r0, r4
   2326a:	f7ff ffb7 	bl	231dc <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   2326e:	3408      	adds	r4, #8
   23270:	4b03      	ldr	r3, [pc, #12]	; (23280 <pin_handler_trigger_uninit+0x34>)
   23272:	2200      	movs	r2, #0
   23274:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
}
   23278:	bd10      	pop	{r4, pc}
   2327a:	bf00      	nop
   2327c:	40006000 	.word	0x40006000
   23280:	20000d8c 	.word	0x20000d8c

00023284 <pin_handler_set>:
{
   23284:	b570      	push	{r4, r5, r6, lr}
   23286:	b082      	sub	sp, #8
   23288:	4606      	mov	r6, r0
   2328a:	460c      	mov	r4, r1
   2328c:	4615      	mov	r5, r2
    release_handler(pin);
   2328e:	f7ff ffa5 	bl	231dc <release_handler>
    if (!handler)
   23292:	b324      	cbz	r4, 232de <pin_handler_set+0x5a>
    handler_id = find_handler(handler, p_context);
   23294:	4629      	mov	r1, r5
   23296:	4620      	mov	r0, r4
   23298:	f7ff ff64 	bl	23164 <find_handler>
    if (handler_id < 0)
   2329c:	1e03      	subs	r3, r0, #0
   2329e:	db13      	blt.n	232c8 <pin_handler_set+0x44>
    m_cb.handlers[handler_id].handler = handler;
   232a0:	4a10      	ldr	r2, [pc, #64]	; (232e4 <pin_handler_set+0x60>)
   232a2:	f842 4033 	str.w	r4, [r2, r3, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
   232a6:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
   232aa:	604d      	str	r5, [r1, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   232ac:	025b      	lsls	r3, r3, #9
   232ae:	b29b      	uxth	r3, r3
   232b0:	f106 0008 	add.w	r0, r6, #8
   232b4:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
   232b8:	430b      	orrs	r3, r1
   232ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   232be:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    return NRFX_SUCCESS;
   232c2:	4809      	ldr	r0, [pc, #36]	; (232e8 <pin_handler_set+0x64>)
}
   232c4:	b002      	add	sp, #8
   232c6:	bd70      	pop	{r4, r5, r6, pc}
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   232c8:	f10d 0107 	add.w	r1, sp, #7
   232cc:	4807      	ldr	r0, [pc, #28]	; (232ec <pin_handler_set+0x68>)
   232ce:	f7ff feb3 	bl	23038 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   232d2:	4b05      	ldr	r3, [pc, #20]	; (232e8 <pin_handler_set+0x64>)
   232d4:	4298      	cmp	r0, r3
   232d6:	d1f5      	bne.n	232c4 <pin_handler_set+0x40>
        handler_id = (int32_t)id;
   232d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   232dc:	e7e0      	b.n	232a0 <pin_handler_set+0x1c>
        return NRFX_SUCCESS;
   232de:	4802      	ldr	r0, [pc, #8]	; (232e8 <pin_handler_set+0x64>)
   232e0:	e7f0      	b.n	232c4 <pin_handler_set+0x40>
   232e2:	bf00      	nop
   232e4:	20000d8c 	.word	0x20000d8c
   232e8:	0bad0000 	.word	0x0bad0000
   232ec:	20000de0 	.word	0x20000de0

000232f0 <gpiote_evt_handle>:
    } while (input_read_and_check(input, pins_to_check));
}
#endif // defined(NRF_GPIO_LATCH_PRESENT)

static void gpiote_evt_handle(uint32_t mask)
{
   232f0:	b538      	push	{r3, r4, r5, lr}
   232f2:	4604      	mov	r4, r0
    while (mask)
   232f4:	e018      	b.n	23328 <gpiote_evt_handle+0x38>
    {
        uint32_t ch = NRF_CTZ(mask);
   232f6:	fa94 f3a4 	rbit	r3, r4
   232fa:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   232fe:	2201      	movs	r2, #1
   23300:	409a      	lsls	r2, r3
   23302:	ea24 0402 	bic.w	r4, r4, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   23306:	4a0a      	ldr	r2, [pc, #40]	; (23330 <gpiote_evt_handle+0x40>)
   23308:	f503 73a2 	add.w	r3, r3, #324	; 0x144
   2330c:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   23310:	f3c5 2504 	ubfx	r5, r5, #8, #5
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   23314:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
        nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, ch);
        nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, ch);

        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   23318:	f3c0 4001 	ubfx	r0, r0, #16, #2
   2331c:	f00d f9d5 	bl	306ca <gpiote_polarity_to_trigger>
   23320:	4601      	mov	r1, r0
   23322:	4628      	mov	r0, r5
   23324:	f7ff ff44 	bl	231b0 <call_handler>
    while (mask)
   23328:	2c00      	cmp	r4, #0
   2332a:	d1e4      	bne.n	232f6 <gpiote_evt_handle+0x6>
    }
}
   2332c:	bd38      	pop	{r3, r4, r5, pc}
   2332e:	bf00      	nop
   23330:	40006000 	.word	0x40006000

00023334 <next_sense_cond_call_handler>:
{
   23334:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   23338:	4604      	mov	r4, r0
   2333a:	460d      	mov	r5, r1
   2333c:	4616      	mov	r6, r2
    if (is_level(trigger))
   2333e:	4608      	mov	r0, r1
   23340:	f00d f9c5 	bl	306ce <is_level>
   23344:	bb58      	cbnz	r0, 2339e <next_sense_cond_call_handler+0x6a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   23346:	2e02      	cmp	r6, #2
   23348:	f000 80cc 	beq.w	234e4 <next_sense_cond_call_handler+0x1b0>
   2334c:	f04f 0802 	mov.w	r8, #2
    switch (port)
   23350:	0963      	lsrs	r3, r4, #5
   23352:	f000 80ca 	beq.w	234ea <next_sense_cond_call_handler+0x1b6>
    uint32_t mask = 0;
   23356:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23358:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2335c:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2335e:	f013 0f01 	tst.w	r3, #1
   23362:	f000 80c5 	beq.w	234f0 <next_sense_cond_call_handler+0x1bc>
    *p_pin = pin_number & 0x1F;
   23366:	f004 071f 	and.w	r7, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2336a:	0963      	lsrs	r3, r4, #5
   2336c:	f040 80cd 	bne.w	2350a <next_sense_cond_call_handler+0x1d6>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   23370:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
   23374:	f507 72e0 	add.w	r2, r7, #448	; 0x1c0
   23378:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    cnf &= ~to_update;
   2337c:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   23380:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   23384:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   23388:	2d03      	cmp	r5, #3
   2338a:	f000 80cf 	beq.w	2352c <next_sense_cond_call_handler+0x1f8>
   2338e:	2e02      	cmp	r6, #2
   23390:	f000 80c9 	beq.w	23526 <next_sense_cond_call_handler+0x1f2>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   23394:	2e03      	cmp	r6, #3
   23396:	f000 80ce 	beq.w	23536 <next_sense_cond_call_handler+0x202>
}
   2339a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        call_handler(pin, trigger);
   2339e:	4629      	mov	r1, r5
   233a0:	4620      	mov	r0, r4
   233a2:	f7ff ff05 	bl	231b0 <call_handler>
    switch (port)
   233a6:	0963      	lsrs	r3, r4, #5
   233a8:	d045      	beq.n	23436 <next_sense_cond_call_handler+0x102>
    uint32_t mask = 0;
   233aa:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   233ac:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   233b0:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   233b2:	f013 0f01 	tst.w	r3, #1
   233b6:	d041      	beq.n	2343c <next_sense_cond_call_handler+0x108>
    *p_pin = pin_number & 0x1F;
   233b8:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   233bc:	0963      	lsrs	r3, r4, #5
   233be:	d14a      	bne.n	23456 <next_sense_cond_call_handler+0x122>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   233c0:	f505 75e0 	add.w	r5, r5, #448	; 0x1c0
   233c4:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   233c8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
   233cc:	f3c3 4301 	ubfx	r3, r3, #16, #2
        if (nrf_gpio_pin_sense_get(pin) == sense)
   233d0:	429e      	cmp	r6, r3
   233d2:	d1e2      	bne.n	2339a <next_sense_cond_call_handler+0x66>
    switch (port)
   233d4:	0963      	lsrs	r3, r4, #5
   233d6:	d04b      	beq.n	23470 <next_sense_cond_call_handler+0x13c>
    uint32_t mask = 0;
   233d8:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   233da:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   233de:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   233e0:	f013 0f01 	tst.w	r3, #1
   233e4:	d047      	beq.n	23476 <next_sense_cond_call_handler+0x142>
    *p_pin = pin_number & 0x1F;
   233e6:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   233ea:	0963      	lsrs	r3, r4, #5
   233ec:	d150      	bne.n	23490 <next_sense_cond_call_handler+0x15c>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   233ee:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
   233f2:	f505 73e0 	add.w	r3, r5, #448	; 0x1c0
   233f6:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
   233fa:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf;
   233fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    switch (port)
   23402:	0963      	lsrs	r3, r4, #5
   23404:	d051      	beq.n	234aa <next_sense_cond_call_handler+0x176>
    uint32_t mask = 0;
   23406:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23408:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2340c:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2340e:	f013 0f01 	tst.w	r3, #1
   23412:	d04d      	beq.n	234b0 <next_sense_cond_call_handler+0x17c>
    *p_pin = pin_number & 0x1F;
   23414:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23418:	0963      	lsrs	r3, r4, #5
   2341a:	d156      	bne.n	234ca <next_sense_cond_call_handler+0x196>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   2341c:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
   23420:	f505 73e0 	add.w	r3, r5, #448	; 0x1c0
   23424:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
   23428:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   2342c:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   23430:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
   23434:	e7b1      	b.n	2339a <next_sense_cond_call_handler+0x66>
            mask = P0_FEATURE_PINS_PRESENT;
   23436:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2343a:	e7b7      	b.n	233ac <next_sense_cond_call_handler+0x78>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2343c:	4d40      	ldr	r5, [pc, #256]	; (23540 <next_sense_cond_call_handler+0x20c>)
   2343e:	f240 2247 	movw	r2, #583	; 0x247
   23442:	4629      	mov	r1, r5
   23444:	483f      	ldr	r0, [pc, #252]	; (23544 <next_sense_cond_call_handler+0x210>)
   23446:	f009 f872 	bl	2c52e <assert_print>
   2344a:	f240 2147 	movw	r1, #583	; 0x247
   2344e:	4628      	mov	r0, r5
   23450:	f009 f866 	bl	2c520 <assert_post_action>
   23454:	e7b0      	b.n	233b8 <next_sense_cond_call_handler+0x84>
            NRFX_ASSERT(0);
   23456:	4f3a      	ldr	r7, [pc, #232]	; (23540 <next_sense_cond_call_handler+0x20c>)
   23458:	f44f 7213 	mov.w	r2, #588	; 0x24c
   2345c:	4639      	mov	r1, r7
   2345e:	4839      	ldr	r0, [pc, #228]	; (23544 <next_sense_cond_call_handler+0x210>)
   23460:	f009 f865 	bl	2c52e <assert_print>
   23464:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23468:	4638      	mov	r0, r7
   2346a:	f009 f859 	bl	2c520 <assert_post_action>
   2346e:	e7a7      	b.n	233c0 <next_sense_cond_call_handler+0x8c>
            mask = P0_FEATURE_PINS_PRESENT;
   23470:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23474:	e7b1      	b.n	233da <next_sense_cond_call_handler+0xa6>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23476:	4d32      	ldr	r5, [pc, #200]	; (23540 <next_sense_cond_call_handler+0x20c>)
   23478:	f240 2247 	movw	r2, #583	; 0x247
   2347c:	4629      	mov	r1, r5
   2347e:	4831      	ldr	r0, [pc, #196]	; (23544 <next_sense_cond_call_handler+0x210>)
   23480:	f009 f855 	bl	2c52e <assert_print>
   23484:	f240 2147 	movw	r1, #583	; 0x247
   23488:	4628      	mov	r0, r5
   2348a:	f009 f849 	bl	2c520 <assert_post_action>
   2348e:	e7aa      	b.n	233e6 <next_sense_cond_call_handler+0xb2>
            NRFX_ASSERT(0);
   23490:	4f2b      	ldr	r7, [pc, #172]	; (23540 <next_sense_cond_call_handler+0x20c>)
   23492:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23496:	4639      	mov	r1, r7
   23498:	482a      	ldr	r0, [pc, #168]	; (23544 <next_sense_cond_call_handler+0x210>)
   2349a:	f009 f848 	bl	2c52e <assert_print>
   2349e:	f44f 7113 	mov.w	r1, #588	; 0x24c
   234a2:	4638      	mov	r0, r7
   234a4:	f009 f83c 	bl	2c520 <assert_post_action>
   234a8:	e7a1      	b.n	233ee <next_sense_cond_call_handler+0xba>
            mask = P0_FEATURE_PINS_PRESENT;
   234aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   234ae:	e7ab      	b.n	23408 <next_sense_cond_call_handler+0xd4>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   234b0:	4d23      	ldr	r5, [pc, #140]	; (23540 <next_sense_cond_call_handler+0x20c>)
   234b2:	f240 2247 	movw	r2, #583	; 0x247
   234b6:	4629      	mov	r1, r5
   234b8:	4822      	ldr	r0, [pc, #136]	; (23544 <next_sense_cond_call_handler+0x210>)
   234ba:	f009 f838 	bl	2c52e <assert_print>
   234be:	f240 2147 	movw	r1, #583	; 0x247
   234c2:	4628      	mov	r0, r5
   234c4:	f009 f82c 	bl	2c520 <assert_post_action>
   234c8:	e7a4      	b.n	23414 <next_sense_cond_call_handler+0xe0>
            NRFX_ASSERT(0);
   234ca:	4c1d      	ldr	r4, [pc, #116]	; (23540 <next_sense_cond_call_handler+0x20c>)
   234cc:	f44f 7213 	mov.w	r2, #588	; 0x24c
   234d0:	4621      	mov	r1, r4
   234d2:	481c      	ldr	r0, [pc, #112]	; (23544 <next_sense_cond_call_handler+0x210>)
   234d4:	f009 f82b 	bl	2c52e <assert_print>
   234d8:	f44f 7113 	mov.w	r1, #588	; 0x24c
   234dc:	4620      	mov	r0, r4
   234de:	f009 f81f 	bl	2c520 <assert_post_action>
   234e2:	e79b      	b.n	2341c <next_sense_cond_call_handler+0xe8>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   234e4:	f04f 0803 	mov.w	r8, #3
   234e8:	e732      	b.n	23350 <next_sense_cond_call_handler+0x1c>
            mask = P0_FEATURE_PINS_PRESENT;
   234ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   234ee:	e733      	b.n	23358 <next_sense_cond_call_handler+0x24>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   234f0:	4f13      	ldr	r7, [pc, #76]	; (23540 <next_sense_cond_call_handler+0x20c>)
   234f2:	f240 2247 	movw	r2, #583	; 0x247
   234f6:	4639      	mov	r1, r7
   234f8:	4812      	ldr	r0, [pc, #72]	; (23544 <next_sense_cond_call_handler+0x210>)
   234fa:	f009 f818 	bl	2c52e <assert_print>
   234fe:	f240 2147 	movw	r1, #583	; 0x247
   23502:	4638      	mov	r0, r7
   23504:	f009 f80c 	bl	2c520 <assert_post_action>
   23508:	e72d      	b.n	23366 <next_sense_cond_call_handler+0x32>
            NRFX_ASSERT(0);
   2350a:	f8df 9034 	ldr.w	r9, [pc, #52]	; 23540 <next_sense_cond_call_handler+0x20c>
   2350e:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23512:	4649      	mov	r1, r9
   23514:	480b      	ldr	r0, [pc, #44]	; (23544 <next_sense_cond_call_handler+0x210>)
   23516:	f009 f80a 	bl	2c52e <assert_print>
   2351a:	f44f 7113 	mov.w	r1, #588	; 0x24c
   2351e:	4648      	mov	r0, r9
   23520:	f008 fffe 	bl	2c520 <assert_post_action>
   23524:	e724      	b.n	23370 <next_sense_cond_call_handler+0x3c>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   23526:	2d01      	cmp	r5, #1
   23528:	f47f af34 	bne.w	23394 <next_sense_cond_call_handler+0x60>
            call_handler(pin, trigger);
   2352c:	4629      	mov	r1, r5
   2352e:	4620      	mov	r0, r4
   23530:	f7ff fe3e 	bl	231b0 <call_handler>
}
   23534:	e731      	b.n	2339a <next_sense_cond_call_handler+0x66>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   23536:	2d02      	cmp	r5, #2
   23538:	f47f af2f 	bne.w	2339a <next_sense_cond_call_handler+0x66>
   2353c:	e7f6      	b.n	2352c <next_sense_cond_call_handler+0x1f8>
   2353e:	bf00      	nop
   23540:	0003b084 	.word	0x0003b084
   23544:	00031600 	.word	0x00031600

00023548 <port_event_handle>:
{
   23548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2354c:	b082      	sub	sp, #8
    for (i = start_port; i < (start_port + length); i++)
   2354e:	2300      	movs	r3, #0
   23550:	a801      	add	r0, sp, #4
   23552:	e008      	b.n	23566 <port_event_handle+0x1e>
        *p_masks = gpio_regs[i]->LATCH;
   23554:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   23558:	f8d2 1520 	ldr.w	r1, [r2, #1312]	; 0x520
   2355c:	f840 1b04 	str.w	r1, [r0], #4
        gpio_regs[i]->LATCH = *p_masks;
   23560:	f8c2 1520 	str.w	r1, [r2, #1312]	; 0x520
    for (i = start_port; i < (start_port + length); i++)
   23564:	3301      	adds	r3, #1
   23566:	2b00      	cmp	r3, #0
   23568:	d0f4      	beq.n	23554 <port_event_handle+0xc>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   2356a:	2500      	movs	r5, #0
   2356c:	2d00      	cmp	r5, #0
   2356e:	d03d      	beq.n	235ec <port_event_handle+0xa4>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   23570:	4b4a      	ldr	r3, [pc, #296]	; (2369c <port_event_handle+0x154>)
   23572:	2200      	movs	r2, #0
   23574:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
   23578:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
    } while (latch_pending_read_and_check(latch));
   2357c:	a801      	add	r0, sp, #4
   2357e:	f00d f8ab 	bl	306d8 <latch_pending_read_and_check>
   23582:	2800      	cmp	r0, #0
   23584:	d1f1      	bne.n	2356a <port_event_handle+0x22>
}
   23586:	b002      	add	sp, #8
   23588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            mask = P0_FEATURE_PINS_PRESENT;
   2358c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23590:	e04e      	b.n	23630 <port_event_handle+0xe8>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23592:	4f43      	ldr	r7, [pc, #268]	; (236a0 <port_event_handle+0x158>)
   23594:	f240 2247 	movw	r2, #583	; 0x247
   23598:	4639      	mov	r1, r7
   2359a:	4842      	ldr	r0, [pc, #264]	; (236a4 <port_event_handle+0x15c>)
   2359c:	f008 ffc7 	bl	2c52e <assert_print>
   235a0:	f240 2147 	movw	r1, #583	; 0x247
   235a4:	4638      	mov	r0, r7
   235a6:	f008 ffbb 	bl	2c520 <assert_post_action>
   235aa:	e047      	b.n	2363c <port_event_handle+0xf4>
            NRFX_ASSERT(0);
   235ac:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 236a0 <port_event_handle+0x158>
   235b0:	f44f 7213 	mov.w	r2, #588	; 0x24c
   235b4:	4641      	mov	r1, r8
   235b6:	483b      	ldr	r0, [pc, #236]	; (236a4 <port_event_handle+0x15c>)
   235b8:	f008 ffb9 	bl	2c52e <assert_print>
   235bc:	f44f 7113 	mov.w	r1, #588	; 0x24c
   235c0:	4640      	mov	r0, r8
   235c2:	f008 ffad 	bl	2c520 <assert_post_action>
   235c6:	e03d      	b.n	23644 <port_event_handle+0xfc>
            mask = P0_FEATURE_PINS_PRESENT;
   235c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   235cc:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   235d0:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   235d2:	f013 0f01 	tst.w	r3, #1
   235d6:	d045      	beq.n	23664 <port_event_handle+0x11c>
    *p_pin = pin_number & 0x1F;
   235d8:	f004 061f 	and.w	r6, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   235dc:	0963      	lsrs	r3, r4, #5
   235de:	d14e      	bne.n	2367e <port_event_handle+0x136>
    reg->LATCH = (1 << pin_number);
   235e0:	2301      	movs	r3, #1
   235e2:	40b3      	lsls	r3, r6
   235e4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   235e8:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
            while (latch[i])
   235ec:	ab02      	add	r3, sp, #8
   235ee:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   235f2:	f853 4c04 	ldr.w	r4, [r3, #-4]
   235f6:	2c00      	cmp	r4, #0
   235f8:	d04e      	beq.n	23698 <port_event_handle+0x150>
                uint32_t pin = NRF_CTZ(latch[i]);
   235fa:	fa94 f4a4 	rbit	r4, r4
   235fe:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
   23602:	eb04 1445 	add.w	r4, r4, r5, lsl #5
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   23606:	f104 0208 	add.w	r2, r4, #8
   2360a:	4b27      	ldr	r3, [pc, #156]	; (236a8 <port_event_handle+0x160>)
   2360c:	f833 6012 	ldrh.w	r6, [r3, r2, lsl #1]
   23610:	f3c6 0682 	ubfx	r6, r6, #2, #3
 * @param[in,out] p_mask Pointer to mask with bit fields.
 */
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   23614:	08e1      	lsrs	r1, r4, #3
    bit = BITMASK_RELBIT_GET(bit);
   23616:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   2361a:	a801      	add	r0, sp, #4
   2361c:	2301      	movs	r3, #1
   2361e:	fa03 f202 	lsl.w	r2, r3, r2
   23622:	5c43      	ldrb	r3, [r0, r1]
   23624:	ea23 0302 	bic.w	r3, r3, r2
   23628:	5443      	strb	r3, [r0, r1]
    switch (port)
   2362a:	0963      	lsrs	r3, r4, #5
   2362c:	d0ae      	beq.n	2358c <port_event_handle+0x44>
    uint32_t mask = 0;
   2362e:	462b      	mov	r3, r5
    pin_number &= 0x1F;
   23630:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23634:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23636:	f013 0f01 	tst.w	r3, #1
   2363a:	d0aa      	beq.n	23592 <port_event_handle+0x4a>
    *p_pin = pin_number & 0x1F;
   2363c:	f004 071f 	and.w	r7, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23640:	0963      	lsrs	r3, r4, #5
   23642:	d1b3      	bne.n	235ac <port_event_handle+0x64>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   23644:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   23648:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   2364c:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
                next_sense_cond_call_handler(pin, trigger, sense);
   23650:	f3c2 4201 	ubfx	r2, r2, #16, #2
   23654:	4631      	mov	r1, r6
   23656:	4620      	mov	r0, r4
   23658:	f7ff fe6c 	bl	23334 <next_sense_cond_call_handler>
    switch (port)
   2365c:	0963      	lsrs	r3, r4, #5
   2365e:	d0b3      	beq.n	235c8 <port_event_handle+0x80>
    uint32_t mask = 0;
   23660:	462b      	mov	r3, r5
   23662:	e7b3      	b.n	235cc <port_event_handle+0x84>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23664:	4e0e      	ldr	r6, [pc, #56]	; (236a0 <port_event_handle+0x158>)
   23666:	f240 2247 	movw	r2, #583	; 0x247
   2366a:	4631      	mov	r1, r6
   2366c:	480d      	ldr	r0, [pc, #52]	; (236a4 <port_event_handle+0x15c>)
   2366e:	f008 ff5e 	bl	2c52e <assert_print>
   23672:	f240 2147 	movw	r1, #583	; 0x247
   23676:	4630      	mov	r0, r6
   23678:	f008 ff52 	bl	2c520 <assert_post_action>
   2367c:	e7ac      	b.n	235d8 <port_event_handle+0x90>
            NRFX_ASSERT(0);
   2367e:	4c08      	ldr	r4, [pc, #32]	; (236a0 <port_event_handle+0x158>)
   23680:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23684:	4621      	mov	r1, r4
   23686:	4807      	ldr	r0, [pc, #28]	; (236a4 <port_event_handle+0x15c>)
   23688:	f008 ff51 	bl	2c52e <assert_print>
   2368c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23690:	4620      	mov	r0, r4
   23692:	f008 ff45 	bl	2c520 <assert_post_action>
   23696:	e7a3      	b.n	235e0 <port_event_handle+0x98>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   23698:	3501      	adds	r5, #1
   2369a:	e767      	b.n	2356c <port_event_handle+0x24>
   2369c:	40006000 	.word	0x40006000
   236a0:	0003b084 	.word	0x0003b084
   236a4:	00031600 	.word	0x00031600
   236a8:	20000d8c 	.word	0x20000d8c

000236ac <nrfx_gpiote_input_configure>:
{
   236ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   236b0:	4604      	mov	r4, r0
   236b2:	4615      	mov	r5, r2
   236b4:	461e      	mov	r6, r3
    if (p_input_config)
   236b6:	2900      	cmp	r1, #0
   236b8:	d03b      	beq.n	23732 <nrfx_gpiote_input_configure+0x86>
   236ba:	4688      	mov	r8, r1
        if (pin_is_task_output(pin))
   236bc:	f00c ffef 	bl	3069e <pin_is_task_output>
   236c0:	2800      	cmp	r0, #0
   236c2:	f040 80c4 	bne.w	2384e <nrfx_gpiote_input_configure+0x1a2>
    switch (port)
   236c6:	0963      	lsrs	r3, r4, #5
   236c8:	d057      	beq.n	2377a <nrfx_gpiote_input_configure+0xce>
    uint32_t mask = 0;
   236ca:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   236cc:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   236d0:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   236d2:	f013 0f01 	tst.w	r3, #1
   236d6:	d053      	beq.n	23780 <nrfx_gpiote_input_configure+0xd4>
    *p_pin = pin_number & 0x1F;
   236d8:	f004 071f 	and.w	r7, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   236dc:	0963      	lsrs	r3, r4, #5
   236de:	d15c      	bne.n	2379a <nrfx_gpiote_input_configure+0xee>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   236e0:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
   236e4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   236e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   236ec:	f1b8 0f00 	cmp.w	r8, #0
   236f0:	d061      	beq.n	237b6 <nrfx_gpiote_input_configure+0x10a>
   236f2:	220c      	movs	r2, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   236f4:	f042 0203 	orr.w	r2, r2, #3
    cnf &= ~to_update;
   236f8:	ea23 0302 	bic.w	r3, r3, r2
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   236fc:	f1b8 0f00 	cmp.w	r8, #0
   23700:	d05b      	beq.n	237ba <nrfx_gpiote_input_configure+0x10e>
   23702:	f898 2000 	ldrb.w	r2, [r8]
   23706:	0092      	lsls	r2, r2, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   23708:	4313      	orrs	r3, r2
    reg->PIN_CNF[pin_number] = cnf;
   2370a:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   2370e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   23712:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   23716:	4a52      	ldr	r2, [pc, #328]	; (23860 <nrfx_gpiote_input_configure+0x1b4>)
   23718:	f104 0108 	add.w	r1, r4, #8
   2371c:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   23720:	f023 0302 	bic.w	r3, r3, #2
   23724:	b29b      	uxth	r3, r3
   23726:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   2372a:	f043 0301 	orr.w	r3, r3, #1
   2372e:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_trigger_config)
   23732:	b1cd      	cbz	r5, 23768 <nrfx_gpiote_input_configure+0xbc>
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   23734:	782f      	ldrb	r7, [r5, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   23736:	f8d5 8004 	ldr.w	r8, [r5, #4]
        if (pin_is_output(pin))
   2373a:	4620      	mov	r0, r4
   2373c:	f7ff fce6 	bl	2310c <pin_is_output>
   23740:	2800      	cmp	r0, #0
   23742:	d03c      	beq.n	237be <nrfx_gpiote_input_configure+0x112>
            if (use_evt)
   23744:	f1b8 0f00 	cmp.w	r8, #0
   23748:	f040 8083 	bne.w	23852 <nrfx_gpiote_input_configure+0x1a6>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   2374c:	4a44      	ldr	r2, [pc, #272]	; (23860 <nrfx_gpiote_input_configure+0x1b4>)
   2374e:	f104 0108 	add.w	r1, r4, #8
   23752:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   23756:	f023 031c 	bic.w	r3, r3, #28
   2375a:	b29b      	uxth	r3, r3
   2375c:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   23760:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
   23764:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_handler_config)
   23768:	2e00      	cmp	r6, #0
   2376a:	d076      	beq.n	2385a <nrfx_gpiote_input_configure+0x1ae>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   2376c:	6872      	ldr	r2, [r6, #4]
   2376e:	6831      	ldr	r1, [r6, #0]
   23770:	4620      	mov	r0, r4
   23772:	f7ff fd87 	bl	23284 <pin_handler_set>
}
   23776:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            mask = P0_FEATURE_PINS_PRESENT;
   2377a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2377e:	e7a5      	b.n	236cc <nrfx_gpiote_input_configure+0x20>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23780:	4f38      	ldr	r7, [pc, #224]	; (23864 <nrfx_gpiote_input_configure+0x1b8>)
   23782:	f240 2247 	movw	r2, #583	; 0x247
   23786:	4639      	mov	r1, r7
   23788:	4837      	ldr	r0, [pc, #220]	; (23868 <nrfx_gpiote_input_configure+0x1bc>)
   2378a:	f008 fed0 	bl	2c52e <assert_print>
   2378e:	f240 2147 	movw	r1, #583	; 0x247
   23792:	4638      	mov	r0, r7
   23794:	f008 fec4 	bl	2c520 <assert_post_action>
   23798:	e79e      	b.n	236d8 <nrfx_gpiote_input_configure+0x2c>
            NRFX_ASSERT(0);
   2379a:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 23864 <nrfx_gpiote_input_configure+0x1b8>
   2379e:	f44f 7213 	mov.w	r2, #588	; 0x24c
   237a2:	4649      	mov	r1, r9
   237a4:	4830      	ldr	r0, [pc, #192]	; (23868 <nrfx_gpiote_input_configure+0x1bc>)
   237a6:	f008 fec2 	bl	2c52e <assert_print>
   237aa:	f44f 7113 	mov.w	r1, #588	; 0x24c
   237ae:	4648      	mov	r0, r9
   237b0:	f008 feb6 	bl	2c520 <assert_post_action>
   237b4:	e794      	b.n	236e0 <nrfx_gpiote_input_configure+0x34>
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   237b6:	2200      	movs	r2, #0
   237b8:	e79c      	b.n	236f4 <nrfx_gpiote_input_configure+0x48>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   237ba:	2200      	movs	r2, #0
   237bc:	e7a4      	b.n	23708 <nrfx_gpiote_input_configure+0x5c>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   237be:	4a28      	ldr	r2, [pc, #160]	; (23860 <nrfx_gpiote_input_configure+0x1b4>)
   237c0:	f104 0108 	add.w	r1, r4, #8
   237c4:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   237c8:	f023 0320 	bic.w	r3, r3, #32
   237cc:	04db      	lsls	r3, r3, #19
   237ce:	0cdb      	lsrs	r3, r3, #19
   237d0:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
            if (use_evt)
   237d4:	f1b8 0f00 	cmp.w	r8, #0
   237d8:	d0b8      	beq.n	2374c <nrfx_gpiote_input_configure+0xa0>
                if (!edge)
   237da:	2f03      	cmp	r7, #3
   237dc:	d83b      	bhi.n	23856 <nrfx_gpiote_input_configure+0x1aa>
                uint8_t ch = *p_trigger_config->p_in_channel;
   237de:	686b      	ldr	r3, [r5, #4]
   237e0:	781d      	ldrb	r5, [r3, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   237e2:	b937      	cbnz	r7, 237f2 <nrfx_gpiote_input_configure+0x146>
    p_reg->CONFIG[idx] = 0;
   237e4:	f505 75a2 	add.w	r5, r5, #324	; 0x144
   237e8:	4b20      	ldr	r3, [pc, #128]	; (2386c <nrfx_gpiote_input_configure+0x1c0>)
   237ea:	2200      	movs	r2, #0
   237ec:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
#endif
}
   237f0:	e7ac      	b.n	2374c <nrfx_gpiote_input_configure+0xa0>
                    nrf_gpiote_polarity_t polarity = gpiote_trigger_to_polarity(trigger);
   237f2:	4638      	mov	r0, r7
   237f4:	f00c ff6a 	bl	306cc <gpiote_trigger_to_polarity>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   237f8:	4b1c      	ldr	r3, [pc, #112]	; (2386c <nrfx_gpiote_input_configure+0x1c0>)
   237fa:	f505 72a2 	add.w	r2, r5, #324	; 0x144
   237fe:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   23802:	f021 0103 	bic.w	r1, r1, #3
   23806:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   2380a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   2380e:	f421 3147 	bic.w	r1, r1, #203776	; 0x31c00
   23812:	f421 7140 	bic.w	r1, r1, #768	; 0x300
   23816:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   2381a:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
   2381e:	0221      	lsls	r1, r4, #8
   23820:	f401 51f8 	and.w	r1, r1, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
   23824:	0400      	lsls	r0, r0, #16
   23826:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   2382a:	4301      	orrs	r1, r0
   2382c:	ea4c 0101 	orr.w	r1, ip, r1
   23830:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   23834:	036b      	lsls	r3, r5, #13
   23836:	b29b      	uxth	r3, r3
   23838:	4a09      	ldr	r2, [pc, #36]	; (23860 <nrfx_gpiote_input_configure+0x1b4>)
   2383a:	f104 0108 	add.w	r1, r4, #8
   2383e:	f832 0011 	ldrh.w	r0, [r2, r1, lsl #1]
   23842:	4303      	orrs	r3, r0
   23844:	f043 0320 	orr.w	r3, r3, #32
   23848:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
   2384c:	e77e      	b.n	2374c <nrfx_gpiote_input_configure+0xa0>
            return NRFX_ERROR_INVALID_PARAM;
   2384e:	4808      	ldr	r0, [pc, #32]	; (23870 <nrfx_gpiote_input_configure+0x1c4>)
   23850:	e791      	b.n	23776 <nrfx_gpiote_input_configure+0xca>
                return NRFX_ERROR_INVALID_PARAM;
   23852:	4807      	ldr	r0, [pc, #28]	; (23870 <nrfx_gpiote_input_configure+0x1c4>)
   23854:	e78f      	b.n	23776 <nrfx_gpiote_input_configure+0xca>
                    return NRFX_ERROR_INVALID_PARAM;
   23856:	4806      	ldr	r0, [pc, #24]	; (23870 <nrfx_gpiote_input_configure+0x1c4>)
   23858:	e78d      	b.n	23776 <nrfx_gpiote_input_configure+0xca>
        err = NRFX_SUCCESS;
   2385a:	4806      	ldr	r0, [pc, #24]	; (23874 <nrfx_gpiote_input_configure+0x1c8>)
   2385c:	e78b      	b.n	23776 <nrfx_gpiote_input_configure+0xca>
   2385e:	bf00      	nop
   23860:	20000d8c 	.word	0x20000d8c
   23864:	0003b084 	.word	0x0003b084
   23868:	00031600 	.word	0x00031600
   2386c:	40006000 	.word	0x40006000
   23870:	0bad0004 	.word	0x0bad0004
   23874:	0bad0000 	.word	0x0bad0000

00023878 <nrfx_gpiote_output_configure>:
{
   23878:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2387c:	4604      	mov	r4, r0
   2387e:	4615      	mov	r5, r2
    if (p_config)
   23880:	2900      	cmp	r1, #0
   23882:	d05c      	beq.n	2393e <nrfx_gpiote_output_configure+0xc6>
   23884:	460f      	mov	r7, r1
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   23886:	f00c ff19 	bl	306bc <pin_is_input>
   2388a:	b128      	cbz	r0, 23898 <nrfx_gpiote_output_configure+0x20>
   2388c:	4620      	mov	r0, r4
   2388e:	f7ff fc27 	bl	230e0 <pin_in_use_by_te>
   23892:	2800      	cmp	r0, #0
   23894:	f040 80c3 	bne.w	23a1e <nrfx_gpiote_output_configure+0x1a6>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   23898:	4620      	mov	r0, r4
   2389a:	f7ff fc2b 	bl	230f4 <pin_has_trigger>
   2389e:	b118      	cbz	r0, 238a8 <nrfx_gpiote_output_configure+0x30>
   238a0:	787b      	ldrb	r3, [r7, #1]
   238a2:	2b01      	cmp	r3, #1
   238a4:	f000 80bd 	beq.w	23a22 <nrfx_gpiote_output_configure+0x1aa>
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
   238a8:	f107 0901 	add.w	r9, r7, #1
   238ac:	f107 0802 	add.w	r8, r7, #2
    switch (port)
   238b0:	0963      	lsrs	r3, r4, #5
   238b2:	d061      	beq.n	23978 <nrfx_gpiote_output_configure+0x100>
    uint32_t mask = 0;
   238b4:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   238b6:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   238ba:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   238bc:	f013 0f01 	tst.w	r3, #1
   238c0:	d05d      	beq.n	2397e <nrfx_gpiote_output_configure+0x106>
    *p_pin = pin_number & 0x1F;
   238c2:	f004 061f 	and.w	r6, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   238c6:	0963      	lsrs	r3, r4, #5
   238c8:	d166      	bne.n	23998 <nrfx_gpiote_output_configure+0x120>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   238ca:	f506 73e0 	add.w	r3, r6, #448	; 0x1c0
   238ce:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   238d2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   238d6:	f1b9 0f00 	cmp.w	r9, #0
   238da:	d06b      	beq.n	239b4 <nrfx_gpiote_output_configure+0x13c>
   238dc:	2302      	movs	r3, #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   238de:	f043 0301 	orr.w	r3, r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   238e2:	f1b8 0f00 	cmp.w	r8, #0
   238e6:	d067      	beq.n	239b8 <nrfx_gpiote_output_configure+0x140>
   238e8:	210c      	movs	r1, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   238ea:	430b      	orrs	r3, r1
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   238ec:	2f00      	cmp	r7, #0
   238ee:	d065      	beq.n	239bc <nrfx_gpiote_output_configure+0x144>
   238f0:	f44f 61e0 	mov.w	r1, #1792	; 0x700
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   238f4:	430b      	orrs	r3, r1
    cnf &= ~to_update;
   238f6:	ea22 0203 	bic.w	r2, r2, r3
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   238fa:	f1b9 0f00 	cmp.w	r9, #0
   238fe:	d05f      	beq.n	239c0 <nrfx_gpiote_output_configure+0x148>
   23900:	787b      	ldrb	r3, [r7, #1]
   23902:	005b      	lsls	r3, r3, #1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   23904:	f043 0301 	orr.w	r3, r3, #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   23908:	f1b8 0f00 	cmp.w	r8, #0
   2390c:	d05a      	beq.n	239c4 <nrfx_gpiote_output_configure+0x14c>
   2390e:	78b9      	ldrb	r1, [r7, #2]
   23910:	0089      	lsls	r1, r1, #2
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   23912:	430b      	orrs	r3, r1
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   23914:	2f00      	cmp	r7, #0
   23916:	d057      	beq.n	239c8 <nrfx_gpiote_output_configure+0x150>
   23918:	7839      	ldrb	r1, [r7, #0]
   2391a:	0209      	lsls	r1, r1, #8
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   2391c:	430b      	orrs	r3, r1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   2391e:	4313      	orrs	r3, r2
    reg->PIN_CNF[pin_number] = cnf;
   23920:	f506 76e0 	add.w	r6, r6, #448	; 0x1c0
   23924:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   23928:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   2392c:	4a40      	ldr	r2, [pc, #256]	; (23a30 <nrfx_gpiote_output_configure+0x1b8>)
   2392e:	f104 0108 	add.w	r1, r4, #8
   23932:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   23936:	f043 0303 	orr.w	r3, r3, #3
   2393a:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_task_config)
   2393e:	2d00      	cmp	r5, #0
   23940:	d071      	beq.n	23a26 <nrfx_gpiote_output_configure+0x1ae>
        if (pin_is_input(pin))
   23942:	4620      	mov	r0, r4
   23944:	f00c feba 	bl	306bc <pin_is_input>
   23948:	2800      	cmp	r0, #0
   2394a:	d16e      	bne.n	23a2a <nrfx_gpiote_output_configure+0x1b2>
        uint32_t ch = p_task_config->task_ch;
   2394c:	782b      	ldrb	r3, [r5, #0]
    p_reg->CONFIG[idx] = 0;
   2394e:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   23952:	4a38      	ldr	r2, [pc, #224]	; (23a34 <nrfx_gpiote_output_configure+0x1bc>)
   23954:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   23958:	4935      	ldr	r1, [pc, #212]	; (23a30 <nrfx_gpiote_output_configure+0x1b8>)
   2395a:	f104 0008 	add.w	r0, r4, #8
   2395e:	f831 2010 	ldrh.w	r2, [r1, r0, lsl #1]
   23962:	f022 0220 	bic.w	r2, r2, #32
   23966:	04d2      	lsls	r2, r2, #19
   23968:	0cd2      	lsrs	r2, r2, #19
   2396a:	f821 2010 	strh.w	r2, [r1, r0, lsl #1]
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   2396e:	786a      	ldrb	r2, [r5, #1]
   23970:	bb62      	cbnz	r2, 239cc <nrfx_gpiote_output_configure+0x154>
    return NRFX_SUCCESS;
   23972:	4831      	ldr	r0, [pc, #196]	; (23a38 <nrfx_gpiote_output_configure+0x1c0>)
}
   23974:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            mask = P0_FEATURE_PINS_PRESENT;
   23978:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2397c:	e79b      	b.n	238b6 <nrfx_gpiote_output_configure+0x3e>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2397e:	4e2f      	ldr	r6, [pc, #188]	; (23a3c <nrfx_gpiote_output_configure+0x1c4>)
   23980:	f240 2247 	movw	r2, #583	; 0x247
   23984:	4631      	mov	r1, r6
   23986:	482e      	ldr	r0, [pc, #184]	; (23a40 <nrfx_gpiote_output_configure+0x1c8>)
   23988:	f008 fdd1 	bl	2c52e <assert_print>
   2398c:	f240 2147 	movw	r1, #583	; 0x247
   23990:	4630      	mov	r0, r6
   23992:	f008 fdc5 	bl	2c520 <assert_post_action>
   23996:	e794      	b.n	238c2 <nrfx_gpiote_output_configure+0x4a>
            NRFX_ASSERT(0);
   23998:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 23a3c <nrfx_gpiote_output_configure+0x1c4>
   2399c:	f44f 7213 	mov.w	r2, #588	; 0x24c
   239a0:	4651      	mov	r1, sl
   239a2:	4827      	ldr	r0, [pc, #156]	; (23a40 <nrfx_gpiote_output_configure+0x1c8>)
   239a4:	f008 fdc3 	bl	2c52e <assert_print>
   239a8:	f44f 7113 	mov.w	r1, #588	; 0x24c
   239ac:	4650      	mov	r0, sl
   239ae:	f008 fdb7 	bl	2c520 <assert_post_action>
   239b2:	e78a      	b.n	238ca <nrfx_gpiote_output_configure+0x52>
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   239b4:	2300      	movs	r3, #0
   239b6:	e792      	b.n	238de <nrfx_gpiote_output_configure+0x66>
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   239b8:	2100      	movs	r1, #0
   239ba:	e796      	b.n	238ea <nrfx_gpiote_output_configure+0x72>
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   239bc:	2100      	movs	r1, #0
   239be:	e799      	b.n	238f4 <nrfx_gpiote_output_configure+0x7c>
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   239c0:	2300      	movs	r3, #0
   239c2:	e79f      	b.n	23904 <nrfx_gpiote_output_configure+0x8c>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   239c4:	2100      	movs	r1, #0
   239c6:	e7a4      	b.n	23912 <nrfx_gpiote_output_configure+0x9a>
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   239c8:	2100      	movs	r1, #0
   239ca:	e7a7      	b.n	2391c <nrfx_gpiote_output_configure+0xa4>
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   239cc:	78af      	ldrb	r7, [r5, #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   239ce:	4819      	ldr	r0, [pc, #100]	; (23a34 <nrfx_gpiote_output_configure+0x1bc>)
   239d0:	f503 75a2 	add.w	r5, r3, #324	; 0x144
   239d4:	f850 1025 	ldr.w	r1, [r0, r5, lsl #2]
   239d8:	f421 1198 	bic.w	r1, r1, #1245184	; 0x130000
   239dc:	f421 51f8 	bic.w	r1, r1, #7936	; 0x1f00
   239e0:	f840 1025 	str.w	r1, [r0, r5, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   239e4:	f850 6025 	ldr.w	r6, [r0, r5, lsl #2]
   239e8:	0221      	lsls	r1, r4, #8
   239ea:	f401 51f8 	and.w	r1, r1, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   239ee:	0412      	lsls	r2, r2, #16
   239f0:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   239f4:	430a      	orrs	r2, r1
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   239f6:	0539      	lsls	r1, r7, #20
   239f8:	f401 1180 	and.w	r1, r1, #1048576	; 0x100000
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   239fc:	430a      	orrs	r2, r1
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   239fe:	4332      	orrs	r2, r6
   23a00:	f840 2025 	str.w	r2, [r0, r5, lsl #2]
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   23a04:	035b      	lsls	r3, r3, #13
   23a06:	b29b      	uxth	r3, r3
   23a08:	4a09      	ldr	r2, [pc, #36]	; (23a30 <nrfx_gpiote_output_configure+0x1b8>)
   23a0a:	3408      	adds	r4, #8
   23a0c:	f832 1014 	ldrh.w	r1, [r2, r4, lsl #1]
   23a10:	430b      	orrs	r3, r1
   23a12:	f043 0320 	orr.w	r3, r3, #32
   23a16:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]
    return NRFX_SUCCESS;
   23a1a:	4807      	ldr	r0, [pc, #28]	; (23a38 <nrfx_gpiote_output_configure+0x1c0>)
   23a1c:	e7aa      	b.n	23974 <nrfx_gpiote_output_configure+0xfc>
   23a1e:	4809      	ldr	r0, [pc, #36]	; (23a44 <nrfx_gpiote_output_configure+0x1cc>)
   23a20:	e7a8      	b.n	23974 <nrfx_gpiote_output_configure+0xfc>
   23a22:	4808      	ldr	r0, [pc, #32]	; (23a44 <nrfx_gpiote_output_configure+0x1cc>)
   23a24:	e7a6      	b.n	23974 <nrfx_gpiote_output_configure+0xfc>
   23a26:	4804      	ldr	r0, [pc, #16]	; (23a38 <nrfx_gpiote_output_configure+0x1c0>)
   23a28:	e7a4      	b.n	23974 <nrfx_gpiote_output_configure+0xfc>
            return NRFX_ERROR_INVALID_PARAM;
   23a2a:	4806      	ldr	r0, [pc, #24]	; (23a44 <nrfx_gpiote_output_configure+0x1cc>)
   23a2c:	e7a2      	b.n	23974 <nrfx_gpiote_output_configure+0xfc>
   23a2e:	bf00      	nop
   23a30:	20000d8c 	.word	0x20000d8c
   23a34:	40006000 	.word	0x40006000
   23a38:	0bad0000 	.word	0x0bad0000
   23a3c:	0003b084 	.word	0x0003b084
   23a40:	00031600 	.word	0x00031600
   23a44:	0bad0004 	.word	0x0bad0004

00023a48 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   23a48:	4b01      	ldr	r3, [pc, #4]	; (23a50 <nrfx_gpiote_global_callback_set+0x8>)
   23a4a:	6098      	str	r0, [r3, #8]
    m_cb.global_handler.p_context = p_context;
   23a4c:	60d9      	str	r1, [r3, #12]
}
   23a4e:	4770      	bx	lr
   23a50:	20000d8c 	.word	0x20000d8c

00023a54 <nrfx_gpiote_channel_get>:
{
   23a54:	b570      	push	{r4, r5, r6, lr}
   23a56:	4604      	mov	r4, r0
    NRFX_ASSERT(p_channel);
   23a58:	460d      	mov	r5, r1
   23a5a:	b159      	cbz	r1, 23a74 <nrfx_gpiote_channel_get+0x20>
    if (pin_in_use_by_te(pin))
   23a5c:	4620      	mov	r0, r4
   23a5e:	f7ff fb3f 	bl	230e0 <pin_in_use_by_te>
   23a62:	b1a0      	cbz	r0, 23a8e <nrfx_gpiote_channel_get+0x3a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   23a64:	3408      	adds	r4, #8
   23a66:	4b0b      	ldr	r3, [pc, #44]	; (23a94 <nrfx_gpiote_channel_get+0x40>)
   23a68:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   23a6c:	0b5b      	lsrs	r3, r3, #13
   23a6e:	702b      	strb	r3, [r5, #0]
        return NRFX_SUCCESS;
   23a70:	4809      	ldr	r0, [pc, #36]	; (23a98 <nrfx_gpiote_channel_get+0x44>)
}
   23a72:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_channel);
   23a74:	4e09      	ldr	r6, [pc, #36]	; (23a9c <nrfx_gpiote_channel_get+0x48>)
   23a76:	f240 2235 	movw	r2, #565	; 0x235
   23a7a:	4631      	mov	r1, r6
   23a7c:	4808      	ldr	r0, [pc, #32]	; (23aa0 <nrfx_gpiote_channel_get+0x4c>)
   23a7e:	f008 fd56 	bl	2c52e <assert_print>
   23a82:	f240 2135 	movw	r1, #565	; 0x235
   23a86:	4630      	mov	r0, r6
   23a88:	f008 fd4a 	bl	2c520 <assert_post_action>
   23a8c:	e7e6      	b.n	23a5c <nrfx_gpiote_channel_get+0x8>
        return NRFX_ERROR_INVALID_PARAM;
   23a8e:	4805      	ldr	r0, [pc, #20]	; (23aa4 <nrfx_gpiote_channel_get+0x50>)
   23a90:	e7ef      	b.n	23a72 <nrfx_gpiote_channel_get+0x1e>
   23a92:	bf00      	nop
   23a94:	20000d8c 	.word	0x20000d8c
   23a98:	0bad0000 	.word	0x0bad0000
   23a9c:	0003bb44 	.word	0x0003bb44
   23aa0:	00031600 	.word	0x00031600
   23aa4:	0bad0004 	.word	0x0bad0004

00023aa8 <nrfx_gpiote_init>:
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   23aa8:	4b10      	ldr	r3, [pc, #64]	; (23aec <nrfx_gpiote_init+0x44>)
   23aaa:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
   23aae:	b10b      	cbz	r3, 23ab4 <nrfx_gpiote_init+0xc>
        return err_code;
   23ab0:	480f      	ldr	r0, [pc, #60]	; (23af0 <nrfx_gpiote_init+0x48>)
}
   23ab2:	4770      	bx	lr
{
   23ab4:	b510      	push	{r4, lr}
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   23ab6:	4c0d      	ldr	r4, [pc, #52]	; (23aec <nrfx_gpiote_init+0x44>)
   23ab8:	2240      	movs	r2, #64	; 0x40
   23aba:	2100      	movs	r1, #0
   23abc:	f104 0010 	add.w	r0, r4, #16
   23ac0:	f00d f9f2 	bl	30ea8 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   23ac4:	2006      	movs	r0, #6
   23ac6:	f7f4 fbe7 	bl	18298 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   23aca:	4b0a      	ldr	r3, [pc, #40]	; (23af4 <nrfx_gpiote_init+0x4c>)
   23acc:	2200      	movs	r2, #0
   23ace:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
   23ad2:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   23ad6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   23ada:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   23ade:	2301      	movs	r3, #1
   23ae0:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   23ae4:	6563      	str	r3, [r4, #84]	; 0x54
    return err_code;
   23ae6:	4804      	ldr	r0, [pc, #16]	; (23af8 <nrfx_gpiote_init+0x50>)
}
   23ae8:	bd10      	pop	{r4, pc}
   23aea:	bf00      	nop
   23aec:	20000d8c 	.word	0x20000d8c
   23af0:	0bad0005 	.word	0x0bad0005
   23af4:	40006000 	.word	0x40006000
   23af8:	0bad0000 	.word	0x0bad0000

00023afc <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   23afc:	4b03      	ldr	r3, [pc, #12]	; (23b0c <nrfx_gpiote_is_init+0x10>)
   23afe:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   23b02:	3800      	subs	r0, #0
   23b04:	bf18      	it	ne
   23b06:	2001      	movne	r0, #1
   23b08:	4770      	bx	lr
   23b0a:	bf00      	nop
   23b0c:	20000d8c 	.word	0x20000d8c

00023b10 <nrfx_gpiote_channel_free>:
{
   23b10:	b508      	push	{r3, lr}
   23b12:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   23b14:	4801      	ldr	r0, [pc, #4]	; (23b1c <nrfx_gpiote_channel_free+0xc>)
   23b16:	f7ff fab7 	bl	23088 <nrfx_flag32_free>
}
   23b1a:	bd08      	pop	{r3, pc}
   23b1c:	20000ddc 	.word	0x20000ddc

00023b20 <nrfx_gpiote_channel_alloc>:
{
   23b20:	b508      	push	{r3, lr}
   23b22:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   23b24:	4801      	ldr	r0, [pc, #4]	; (23b2c <nrfx_gpiote_channel_alloc+0xc>)
   23b26:	f7ff fa87 	bl	23038 <nrfx_flag32_alloc>
}
   23b2a:	bd08      	pop	{r3, pc}
   23b2c:	20000ddc 	.word	0x20000ddc

00023b30 <nrfx_gpiote_trigger_enable>:
{
   23b30:	b570      	push	{r4, r5, r6, lr}
   23b32:	4604      	mov	r4, r0
   23b34:	460d      	mov	r5, r1
    NRFX_ASSERT(pin_has_trigger(pin));
   23b36:	f7ff fadd 	bl	230f4 <pin_has_trigger>
   23b3a:	b1b8      	cbz	r0, 23b6c <nrfx_gpiote_trigger_enable+0x3c>
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   23b3c:	4620      	mov	r0, r4
   23b3e:	f7ff facf 	bl	230e0 <pin_in_use_by_te>
   23b42:	b118      	cbz	r0, 23b4c <nrfx_gpiote_trigger_enable+0x1c>
   23b44:	4620      	mov	r0, r4
   23b46:	f00c fdb9 	bl	306bc <pin_is_input>
   23b4a:	b9e0      	cbnz	r0, 23b86 <nrfx_gpiote_trigger_enable+0x56>
        NRFX_ASSERT(int_enable);
   23b4c:	2d00      	cmp	r5, #0
   23b4e:	d049      	beq.n	23be4 <nrfx_gpiote_trigger_enable+0xb4>
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   23b50:	f104 0308 	add.w	r3, r4, #8
   23b54:	4a61      	ldr	r2, [pc, #388]	; (23cdc <nrfx_gpiote_trigger_enable+0x1ac>)
   23b56:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   23b5a:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   23b5e:	2b04      	cmp	r3, #4
   23b60:	f000 8081 	beq.w	23c66 <nrfx_gpiote_trigger_enable+0x136>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   23b64:	2b05      	cmp	r3, #5
   23b66:	d14a      	bne.n	23bfe <nrfx_gpiote_trigger_enable+0xce>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   23b68:	2602      	movs	r6, #2
   23b6a:	e07d      	b.n	23c68 <nrfx_gpiote_trigger_enable+0x138>
    NRFX_ASSERT(pin_has_trigger(pin));
   23b6c:	4e5c      	ldr	r6, [pc, #368]	; (23ce0 <nrfx_gpiote_trigger_enable+0x1b0>)
   23b6e:	f240 32df 	movw	r2, #991	; 0x3df
   23b72:	4631      	mov	r1, r6
   23b74:	485b      	ldr	r0, [pc, #364]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23b76:	f008 fcda 	bl	2c52e <assert_print>
   23b7a:	f240 31df 	movw	r1, #991	; 0x3df
   23b7e:	4630      	mov	r0, r6
   23b80:	f008 fcce 	bl	2c520 <assert_post_action>
   23b84:	e7da      	b.n	23b3c <nrfx_gpiote_trigger_enable+0xc>
        uint8_t ch = pin_te_get(pin);
   23b86:	4620      	mov	r0, r4
   23b88:	f7ff faca 	bl	23120 <pin_te_get>
   23b8c:	4604      	mov	r4, r0
}
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
   23b8e:	2807      	cmp	r0, #7
   23b90:	d81b      	bhi.n	23bca <nrfx_gpiote_trigger_enable+0x9a>
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   23b92:	00a3      	lsls	r3, r4, #2
   23b94:	f503 7380 	add.w	r3, r3, #256	; 0x100
   23b98:	b29b      	uxth	r3, r3
    return ((uint32_t)p_reg + event);
   23b9a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   23b9e:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   23ba2:	2200      	movs	r2, #0
   23ba4:	601a      	str	r2, [r3, #0]
   23ba6:	681b      	ldr	r3, [r3, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   23ba8:	4a4f      	ldr	r2, [pc, #316]	; (23ce8 <nrfx_gpiote_trigger_enable+0x1b8>)
   23baa:	f504 71a2 	add.w	r1, r4, #324	; 0x144
   23bae:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   23bb2:	f043 0301 	orr.w	r3, r3, #1
   23bb6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        if (int_enable)
   23bba:	2d00      	cmp	r5, #0
   23bbc:	d06d      	beq.n	23c9a <nrfx_gpiote_trigger_enable+0x16a>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   23bbe:	2001      	movs	r0, #1
   23bc0:	fa00 f404 	lsl.w	r4, r0, r4
    p_reg->INTENSET = mask;
   23bc4:	f8c2 4304 	str.w	r4, [r2, #772]	; 0x304
}
   23bc8:	e067      	b.n	23c9a <nrfx_gpiote_trigger_enable+0x16a>
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
   23bca:	4e48      	ldr	r6, [pc, #288]	; (23cec <nrfx_gpiote_trigger_enable+0x1bc>)
   23bcc:	f44f 7223 	mov.w	r2, #652	; 0x28c
   23bd0:	4631      	mov	r1, r6
   23bd2:	4844      	ldr	r0, [pc, #272]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23bd4:	f008 fcab 	bl	2c52e <assert_print>
   23bd8:	f44f 7123 	mov.w	r1, #652	; 0x28c
   23bdc:	4630      	mov	r0, r6
   23bde:	f008 fc9f 	bl	2c520 <assert_post_action>
   23be2:	e7d6      	b.n	23b92 <nrfx_gpiote_trigger_enable+0x62>
        NRFX_ASSERT(int_enable);
   23be4:	4d3e      	ldr	r5, [pc, #248]	; (23ce0 <nrfx_gpiote_trigger_enable+0x1b0>)
   23be6:	f240 32ee 	movw	r2, #1006	; 0x3ee
   23bea:	4629      	mov	r1, r5
   23bec:	483d      	ldr	r0, [pc, #244]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23bee:	f008 fc9e 	bl	2c52e <assert_print>
   23bf2:	f240 31ee 	movw	r1, #1006	; 0x3ee
   23bf6:	4628      	mov	r0, r5
   23bf8:	f008 fc92 	bl	2c520 <assert_post_action>
   23bfc:	e7a8      	b.n	23b50 <nrfx_gpiote_trigger_enable+0x20>
    switch (port)
   23bfe:	0963      	lsrs	r3, r4, #5
   23c00:	d014      	beq.n	23c2c <nrfx_gpiote_trigger_enable+0xfc>
    uint32_t mask = 0;
   23c02:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23c04:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23c08:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23c0a:	f013 0f01 	tst.w	r3, #1
   23c0e:	d010      	beq.n	23c32 <nrfx_gpiote_trigger_enable+0x102>
    *p_pin = pin_number & 0x1F;
   23c10:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23c14:	0963      	lsrs	r3, r4, #5
   23c16:	d119      	bne.n	23c4c <nrfx_gpiote_trigger_enable+0x11c>
    return p_reg->IN;
   23c18:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   23c1c:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   23c20:	40eb      	lsrs	r3, r5
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   23c22:	f013 0f01 	tst.w	r3, #1
   23c26:	d039      	beq.n	23c9c <nrfx_gpiote_trigger_enable+0x16c>
   23c28:	2603      	movs	r6, #3
   23c2a:	e01d      	b.n	23c68 <nrfx_gpiote_trigger_enable+0x138>
            mask = P0_FEATURE_PINS_PRESENT;
   23c2c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23c30:	e7e8      	b.n	23c04 <nrfx_gpiote_trigger_enable+0xd4>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23c32:	4d2f      	ldr	r5, [pc, #188]	; (23cf0 <nrfx_gpiote_trigger_enable+0x1c0>)
   23c34:	f240 2247 	movw	r2, #583	; 0x247
   23c38:	4629      	mov	r1, r5
   23c3a:	482a      	ldr	r0, [pc, #168]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23c3c:	f008 fc77 	bl	2c52e <assert_print>
   23c40:	f240 2147 	movw	r1, #583	; 0x247
   23c44:	4628      	mov	r0, r5
   23c46:	f008 fc6b 	bl	2c520 <assert_post_action>
   23c4a:	e7e1      	b.n	23c10 <nrfx_gpiote_trigger_enable+0xe0>
            NRFX_ASSERT(0);
   23c4c:	4e28      	ldr	r6, [pc, #160]	; (23cf0 <nrfx_gpiote_trigger_enable+0x1c0>)
   23c4e:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23c52:	4631      	mov	r1, r6
   23c54:	4823      	ldr	r0, [pc, #140]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23c56:	f008 fc6a 	bl	2c52e <assert_print>
   23c5a:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23c5e:	4630      	mov	r0, r6
   23c60:	f008 fc5e 	bl	2c520 <assert_post_action>
   23c64:	e7d8      	b.n	23c18 <nrfx_gpiote_trigger_enable+0xe8>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   23c66:	2603      	movs	r6, #3
    switch (port)
   23c68:	0963      	lsrs	r3, r4, #5
   23c6a:	d019      	beq.n	23ca0 <nrfx_gpiote_trigger_enable+0x170>
    uint32_t mask = 0;
   23c6c:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23c6e:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23c72:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23c74:	f013 0f01 	tst.w	r3, #1
   23c78:	d015      	beq.n	23ca6 <nrfx_gpiote_trigger_enable+0x176>
    *p_pin = pin_number & 0x1F;
   23c7a:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23c7e:	0963      	lsrs	r3, r4, #5
   23c80:	d11e      	bne.n	23cc0 <nrfx_gpiote_trigger_enable+0x190>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   23c82:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
   23c86:	f505 72e0 	add.w	r2, r5, #448	; 0x1c0
   23c8a:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    cnf &= ~to_update;
   23c8e:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   23c92:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   23c96:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
   23c9a:	bd70      	pop	{r4, r5, r6, pc}
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   23c9c:	2602      	movs	r6, #2
   23c9e:	e7e3      	b.n	23c68 <nrfx_gpiote_trigger_enable+0x138>
            mask = P0_FEATURE_PINS_PRESENT;
   23ca0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23ca4:	e7e3      	b.n	23c6e <nrfx_gpiote_trigger_enable+0x13e>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23ca6:	4d12      	ldr	r5, [pc, #72]	; (23cf0 <nrfx_gpiote_trigger_enable+0x1c0>)
   23ca8:	f240 2247 	movw	r2, #583	; 0x247
   23cac:	4629      	mov	r1, r5
   23cae:	480d      	ldr	r0, [pc, #52]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23cb0:	f008 fc3d 	bl	2c52e <assert_print>
   23cb4:	f240 2147 	movw	r1, #583	; 0x247
   23cb8:	4628      	mov	r0, r5
   23cba:	f008 fc31 	bl	2c520 <assert_post_action>
   23cbe:	e7dc      	b.n	23c7a <nrfx_gpiote_trigger_enable+0x14a>
            NRFX_ASSERT(0);
   23cc0:	4c0b      	ldr	r4, [pc, #44]	; (23cf0 <nrfx_gpiote_trigger_enable+0x1c0>)
   23cc2:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23cc6:	4621      	mov	r1, r4
   23cc8:	4806      	ldr	r0, [pc, #24]	; (23ce4 <nrfx_gpiote_trigger_enable+0x1b4>)
   23cca:	f008 fc30 	bl	2c52e <assert_print>
   23cce:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23cd2:	4620      	mov	r0, r4
   23cd4:	f008 fc24 	bl	2c520 <assert_post_action>
   23cd8:	e7d3      	b.n	23c82 <nrfx_gpiote_trigger_enable+0x152>
   23cda:	bf00      	nop
   23cdc:	20000d8c 	.word	0x20000d8c
   23ce0:	0003bb44 	.word	0x0003bb44
   23ce4:	00031600 	.word	0x00031600
   23ce8:	40006000 	.word	0x40006000
   23cec:	0003bb84 	.word	0x0003bb84
   23cf0:	0003b084 	.word	0x0003b084

00023cf4 <nrfx_gpiote_trigger_disable>:
{
   23cf4:	b538      	push	{r3, r4, r5, lr}
   23cf6:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   23cf8:	f7ff f9f2 	bl	230e0 <pin_in_use_by_te>
   23cfc:	b1a0      	cbz	r0, 23d28 <nrfx_gpiote_trigger_disable+0x34>
   23cfe:	4620      	mov	r0, r4
   23d00:	f00c fcdc 	bl	306bc <pin_is_input>
   23d04:	b180      	cbz	r0, 23d28 <nrfx_gpiote_trigger_disable+0x34>
        uint8_t ch = pin_te_get(pin);
   23d06:	4620      	mov	r0, r4
   23d08:	f7ff fa0a 	bl	23120 <pin_te_get>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   23d0c:	2201      	movs	r2, #1
   23d0e:	4082      	lsls	r2, r0
    p_reg->INTENCLR = mask;
   23d10:	4b20      	ldr	r3, [pc, #128]	; (23d94 <nrfx_gpiote_trigger_disable+0xa0>)
   23d12:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   23d16:	f500 70a2 	add.w	r0, r0, #324	; 0x144
   23d1a:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
   23d1e:	f022 0203 	bic.w	r2, r2, #3
   23d22:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
   23d26:	e016      	b.n	23d56 <nrfx_gpiote_trigger_disable+0x62>
    switch (port)
   23d28:	0963      	lsrs	r3, r4, #5
   23d2a:	d015      	beq.n	23d58 <nrfx_gpiote_trigger_disable+0x64>
    uint32_t mask = 0;
   23d2c:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23d2e:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23d32:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23d34:	f013 0f01 	tst.w	r3, #1
   23d38:	d011      	beq.n	23d5e <nrfx_gpiote_trigger_disable+0x6a>
    *p_pin = pin_number & 0x1F;
   23d3a:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23d3e:	0963      	lsrs	r3, r4, #5
   23d40:	d11a      	bne.n	23d78 <nrfx_gpiote_trigger_disable+0x84>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   23d42:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
   23d46:	f505 73e0 	add.w	r3, r5, #448	; 0x1c0
   23d4a:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
   23d4e:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf;
   23d52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   23d56:	bd38      	pop	{r3, r4, r5, pc}
            mask = P0_FEATURE_PINS_PRESENT;
   23d58:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23d5c:	e7e7      	b.n	23d2e <nrfx_gpiote_trigger_disable+0x3a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23d5e:	4d0e      	ldr	r5, [pc, #56]	; (23d98 <nrfx_gpiote_trigger_disable+0xa4>)
   23d60:	f240 2247 	movw	r2, #583	; 0x247
   23d64:	4629      	mov	r1, r5
   23d66:	480d      	ldr	r0, [pc, #52]	; (23d9c <nrfx_gpiote_trigger_disable+0xa8>)
   23d68:	f008 fbe1 	bl	2c52e <assert_print>
   23d6c:	f240 2147 	movw	r1, #583	; 0x247
   23d70:	4628      	mov	r0, r5
   23d72:	f008 fbd5 	bl	2c520 <assert_post_action>
   23d76:	e7e0      	b.n	23d3a <nrfx_gpiote_trigger_disable+0x46>
            NRFX_ASSERT(0);
   23d78:	4c07      	ldr	r4, [pc, #28]	; (23d98 <nrfx_gpiote_trigger_disable+0xa4>)
   23d7a:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23d7e:	4621      	mov	r1, r4
   23d80:	4806      	ldr	r0, [pc, #24]	; (23d9c <nrfx_gpiote_trigger_disable+0xa8>)
   23d82:	f008 fbd4 	bl	2c52e <assert_print>
   23d86:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23d8a:	4620      	mov	r0, r4
   23d8c:	f008 fbc8 	bl	2c520 <assert_post_action>
   23d90:	e7d7      	b.n	23d42 <nrfx_gpiote_trigger_disable+0x4e>
   23d92:	bf00      	nop
   23d94:	40006000 	.word	0x40006000
   23d98:	0003b084 	.word	0x0003b084
   23d9c:	00031600 	.word	0x00031600

00023da0 <nrfx_gpiote_pin_uninit>:
{
   23da0:	b538      	push	{r3, r4, r5, lr}
   23da2:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   23da4:	f7ff f992 	bl	230cc <pin_in_use>
   23da8:	b908      	cbnz	r0, 23dae <nrfx_gpiote_pin_uninit+0xe>
        return NRFX_ERROR_INVALID_PARAM;
   23daa:	481d      	ldr	r0, [pc, #116]	; (23e20 <nrfx_gpiote_pin_uninit+0x80>)
}
   23dac:	bd38      	pop	{r3, r4, r5, pc}
    nrfx_gpiote_trigger_disable(pin);
   23dae:	4620      	mov	r0, r4
   23db0:	f7ff ffa0 	bl	23cf4 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   23db4:	4620      	mov	r0, r4
   23db6:	f7ff fa49 	bl	2324c <pin_handler_trigger_uninit>
    switch (port)
   23dba:	0963      	lsrs	r3, r4, #5
   23dbc:	d013      	beq.n	23de6 <nrfx_gpiote_pin_uninit+0x46>
    uint32_t mask = 0;
   23dbe:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23dc0:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23dc4:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23dc6:	f013 0f01 	tst.w	r3, #1
   23dca:	d00f      	beq.n	23dec <nrfx_gpiote_pin_uninit+0x4c>
    *p_pin = pin_number & 0x1F;
   23dcc:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23dd0:	0963      	lsrs	r3, r4, #5
   23dd2:	d118      	bne.n	23e06 <nrfx_gpiote_pin_uninit+0x66>
    reg->PIN_CNF[pin_number] = cnf;
   23dd4:	f505 75e0 	add.w	r5, r5, #448	; 0x1c0
   23dd8:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   23ddc:	2202      	movs	r2, #2
   23dde:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
    return NRFX_SUCCESS;
   23de2:	4810      	ldr	r0, [pc, #64]	; (23e24 <nrfx_gpiote_pin_uninit+0x84>)
}
   23de4:	e7e2      	b.n	23dac <nrfx_gpiote_pin_uninit+0xc>
            mask = P0_FEATURE_PINS_PRESENT;
   23de6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23dea:	e7e9      	b.n	23dc0 <nrfx_gpiote_pin_uninit+0x20>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23dec:	4d0e      	ldr	r5, [pc, #56]	; (23e28 <nrfx_gpiote_pin_uninit+0x88>)
   23dee:	f240 2247 	movw	r2, #583	; 0x247
   23df2:	4629      	mov	r1, r5
   23df4:	480d      	ldr	r0, [pc, #52]	; (23e2c <nrfx_gpiote_pin_uninit+0x8c>)
   23df6:	f008 fb9a 	bl	2c52e <assert_print>
   23dfa:	f240 2147 	movw	r1, #583	; 0x247
   23dfe:	4628      	mov	r0, r5
   23e00:	f008 fb8e 	bl	2c520 <assert_post_action>
   23e04:	e7e2      	b.n	23dcc <nrfx_gpiote_pin_uninit+0x2c>
            NRFX_ASSERT(0);
   23e06:	4c08      	ldr	r4, [pc, #32]	; (23e28 <nrfx_gpiote_pin_uninit+0x88>)
   23e08:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23e0c:	4621      	mov	r1, r4
   23e0e:	4807      	ldr	r0, [pc, #28]	; (23e2c <nrfx_gpiote_pin_uninit+0x8c>)
   23e10:	f008 fb8d 	bl	2c52e <assert_print>
   23e14:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23e18:	4620      	mov	r0, r4
   23e1a:	f008 fb81 	bl	2c520 <assert_post_action>
   23e1e:	e7d9      	b.n	23dd4 <nrfx_gpiote_pin_uninit+0x34>
   23e20:	0bad0004 	.word	0x0bad0004
   23e24:	0bad0000 	.word	0x0bad0000
   23e28:	0003b084 	.word	0x0003b084
   23e2c:	00031600 	.word	0x00031600

00023e30 <nrfx_gpiote_irq_handler>:

void nrfx_gpiote_irq_handler(void)
{
   23e30:	b538      	push	{r3, r4, r5, lr}
    uint32_t status = 0;
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   23e32:	2001      	movs	r0, #1
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
   23e34:	f44f 7380 	mov.w	r3, #256	; 0x100

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   23e38:	2100      	movs	r1, #0
    uint32_t status = 0;
   23e3a:	460c      	mov	r4, r1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   23e3c:	e003      	b.n	23e46 <nrfx_gpiote_irq_handler+0x16>
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
        }
        mask <<= 1;
   23e3e:	0040      	lsls	r0, r0, #1
        /* Incrementing to next event, utilizing the fact that events are grouped together
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
   23e40:	3304      	adds	r3, #4
   23e42:	b29b      	uxth	r3, r3
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   23e44:	3101      	adds	r1, #1
   23e46:	2907      	cmp	r1, #7
   23e48:	d814      	bhi.n	23e74 <nrfx_gpiote_irq_handler+0x44>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   23e4a:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
   23e4e:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
   23e52:	6812      	ldr	r2, [r2, #0]
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   23e54:	2a00      	cmp	r2, #0
   23e56:	d0f2      	beq.n	23e3e <nrfx_gpiote_irq_handler+0xe>
    return p_reg->INTENSET & mask;
   23e58:	4a0c      	ldr	r2, [pc, #48]	; (23e8c <nrfx_gpiote_irq_handler+0x5c>)
   23e5a:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
   23e5e:	4210      	tst	r0, r2
   23e60:	d0ed      	beq.n	23e3e <nrfx_gpiote_irq_handler+0xe>
    return ((uint32_t)p_reg + event);
   23e62:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
   23e66:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   23e6a:	2500      	movs	r5, #0
   23e6c:	6015      	str	r5, [r2, #0]
   23e6e:	6812      	ldr	r2, [r2, #0]
            status |= mask;
   23e70:	4304      	orrs	r4, r0
   23e72:	e7e4      	b.n	23e3e <nrfx_gpiote_irq_handler+0xe>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   23e74:	4b05      	ldr	r3, [pc, #20]	; (23e8c <nrfx_gpiote_irq_handler+0x5c>)
   23e76:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   23e7a:	b91b      	cbnz	r3, 23e84 <nrfx_gpiote_irq_handler+0x54>
    {
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
   23e7c:	4620      	mov	r0, r4
   23e7e:	f7ff fa37 	bl	232f0 <gpiote_evt_handle>
}
   23e82:	bd38      	pop	{r3, r4, r5, pc}
        port_event_handle();
   23e84:	f7ff fb60 	bl	23548 <port_event_handle>
   23e88:	e7f8      	b.n	23e7c <nrfx_gpiote_irq_handler+0x4c>
   23e8a:	bf00      	nop
   23e8c:	40006000 	.word	0x40006000

00023e90 <nrfx_ppi_channel_alloc>:
    nrfx_flag32_init(&m_groups_allocated, NRFX_PPI_ALL_APP_GROUPS_MASK);
}


nrfx_err_t nrfx_ppi_channel_alloc(nrf_ppi_channel_t * p_channel)
{
   23e90:	b508      	push	{r3, lr}
   23e92:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_channels_allocated, (uint8_t *)p_channel);
   23e94:	4801      	ldr	r0, [pc, #4]	; (23e9c <nrfx_ppi_channel_alloc+0xc>)
   23e96:	f7ff f8cf 	bl	23038 <nrfx_flag32_alloc>
}
   23e9a:	bd08      	pop	{r3, pc}
   23e9c:	20000de8 	.word	0x20000de8

00023ea0 <deconfigure_pins>:
        nrf_pwm_pins_set(p_instance->p_registers, out_pins);
    }
}

static void deconfigure_pins(nrfx_pwm_t const * p_instance)
{
   23ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23ea2:	4607      	mov	r7, r0
    for (uint8_t ch_idx = 0; ch_idx < NRF_PWM_CHANNEL_COUNT; ch_idx++)
   23ea4:	2400      	movs	r4, #0
   23ea6:	e021      	b.n	23eec <deconfigure_pins+0x4c>
    NRFX_ASSERT(channel < NRF_PWM_CHANNEL_COUNT);
   23ea8:	4e26      	ldr	r6, [pc, #152]	; (23f44 <deconfigure_pins+0xa4>)
   23eaa:	f240 2293 	movw	r2, #659	; 0x293
   23eae:	4631      	mov	r1, r6
   23eb0:	4825      	ldr	r0, [pc, #148]	; (23f48 <deconfigure_pins+0xa8>)
   23eb2:	f008 fb3c 	bl	2c52e <assert_print>
   23eb6:	f240 2193 	movw	r1, #659	; 0x293
   23eba:	4630      	mov	r0, r6
   23ebc:	f008 fb30 	bl	2c520 <assert_post_action>
   23ec0:	e019      	b.n	23ef6 <deconfigure_pins+0x56>
            mask = P0_FEATURE_PINS_PRESENT;
   23ec2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   23ec6:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23eca:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23ecc:	f013 0f01 	tst.w	r3, #1
   23ed0:	d01c      	beq.n	23f0c <deconfigure_pins+0x6c>
    *p_pin = pin_number & 0x1F;
   23ed2:	f005 061f 	and.w	r6, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23ed6:	096b      	lsrs	r3, r5, #5
   23ed8:	d125      	bne.n	23f26 <deconfigure_pins+0x86>
    reg->PIN_CNF[pin_number] = cnf;
   23eda:	f506 76e0 	add.w	r6, r6, #448	; 0x1c0
   23ede:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   23ee2:	2202      	movs	r2, #2
   23ee4:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   23ee8:	3401      	adds	r4, #1
   23eea:	b2e4      	uxtb	r4, r4
   23eec:	2c03      	cmp	r4, #3
   23eee:	d827      	bhi.n	23f40 <deconfigure_pins+0xa0>
    {
        uint32_t pin = nrf_pwm_pin_get(p_instance->p_registers, ch_idx);
   23ef0:	683d      	ldr	r5, [r7, #0]
   23ef2:	2c03      	cmp	r4, #3
   23ef4:	d8d8      	bhi.n	23ea8 <deconfigure_pins+0x8>
    return p_reg->PSEL.OUT[channel];
   23ef6:	f504 73ac 	add.w	r3, r4, #344	; 0x158
   23efa:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
        if (pin != NRF_PWM_PIN_NOT_CONNECTED)
   23efe:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
   23f02:	d0f1      	beq.n	23ee8 <deconfigure_pins+0x48>
    switch (port)
   23f04:	096b      	lsrs	r3, r5, #5
   23f06:	d0dc      	beq.n	23ec2 <deconfigure_pins+0x22>
    uint32_t mask = 0;
   23f08:	2300      	movs	r3, #0
   23f0a:	e7dc      	b.n	23ec6 <deconfigure_pins+0x26>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23f0c:	4e0f      	ldr	r6, [pc, #60]	; (23f4c <deconfigure_pins+0xac>)
   23f0e:	f240 2247 	movw	r2, #583	; 0x247
   23f12:	4631      	mov	r1, r6
   23f14:	480c      	ldr	r0, [pc, #48]	; (23f48 <deconfigure_pins+0xa8>)
   23f16:	f008 fb0a 	bl	2c52e <assert_print>
   23f1a:	f240 2147 	movw	r1, #583	; 0x247
   23f1e:	4630      	mov	r0, r6
   23f20:	f008 fafe 	bl	2c520 <assert_post_action>
   23f24:	e7d5      	b.n	23ed2 <deconfigure_pins+0x32>
            NRFX_ASSERT(0);
   23f26:	4d09      	ldr	r5, [pc, #36]	; (23f4c <deconfigure_pins+0xac>)
   23f28:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23f2c:	4629      	mov	r1, r5
   23f2e:	4806      	ldr	r0, [pc, #24]	; (23f48 <deconfigure_pins+0xa8>)
   23f30:	f008 fafd 	bl	2c52e <assert_print>
   23f34:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23f38:	4628      	mov	r0, r5
   23f3a:	f008 faf1 	bl	2c520 <assert_post_action>
   23f3e:	e7cc      	b.n	23eda <deconfigure_pins+0x3a>
        {
            nrf_gpio_cfg_default(pin);
        }
    }
}
   23f40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   23f42:	bf00      	nop
   23f44:	0003b354 	.word	0x0003b354
   23f48:	00031600 	.word	0x00031600
   23f4c:	0003b084 	.word	0x0003b084

00023f50 <configure_pins>:
{
   23f50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   23f54:	b085      	sub	sp, #20
   23f56:	4680      	mov	r8, r0
   23f58:	460e      	mov	r6, r1
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   23f5a:	7b0b      	ldrb	r3, [r1, #12]
   23f5c:	2b00      	cmp	r3, #0
   23f5e:	f000 80bf 	beq.w	240e0 <configure_pins+0x190>
   23f62:	7b4b      	ldrb	r3, [r1, #13]
   23f64:	2b00      	cmp	r3, #0
   23f66:	f040 80cf 	bne.w	24108 <configure_pins+0x1b8>
   23f6a:	2400      	movs	r4, #0
   23f6c:	e073      	b.n	24056 <configure_pins+0x106>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23f6e:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 24114 <configure_pins+0x1c4>
   23f72:	f240 2247 	movw	r2, #583	; 0x247
   23f76:	4649      	mov	r1, r9
   23f78:	4865      	ldr	r0, [pc, #404]	; (24110 <configure_pins+0x1c0>)
   23f7a:	f008 fad8 	bl	2c52e <assert_print>
   23f7e:	f240 2147 	movw	r1, #583	; 0x247
   23f82:	4648      	mov	r0, r9
   23f84:	f008 facc 	bl	2c520 <assert_post_action>
   23f88:	e084      	b.n	24094 <configure_pins+0x144>
            NRFX_ASSERT(0);
   23f8a:	4d62      	ldr	r5, [pc, #392]	; (24114 <configure_pins+0x1c4>)
   23f8c:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23f90:	4629      	mov	r1, r5
   23f92:	485f      	ldr	r0, [pc, #380]	; (24110 <configure_pins+0x1c0>)
   23f94:	f008 facb 	bl	2c52e <assert_print>
   23f98:	f44f 7113 	mov.w	r1, #588	; 0x24c
   23f9c:	4628      	mov	r0, r5
   23f9e:	f008 fabf 	bl	2c520 <assert_post_action>
   23fa2:	e07c      	b.n	2409e <configure_pins+0x14e>
    switch (port)
   23fa4:	096b      	lsrs	r3, r5, #5
   23fa6:	d012      	beq.n	23fce <configure_pins+0x7e>
    uint32_t mask = 0;
   23fa8:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   23faa:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   23fae:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23fb0:	f013 0f01 	tst.w	r3, #1
   23fb4:	d00e      	beq.n	23fd4 <configure_pins+0x84>
    *p_pin = pin_number & 0x1F;
   23fb6:	f005 091f 	and.w	r9, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   23fba:	096b      	lsrs	r3, r5, #5
   23fbc:	d118      	bne.n	23ff0 <configure_pins+0xa0>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   23fbe:	2301      	movs	r3, #1
   23fc0:	fa03 f309 	lsl.w	r3, r3, r9
    p_reg->OUTSET = set_mask;
   23fc4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   23fc8:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   23fcc:	e06e      	b.n	240ac <configure_pins+0x15c>
            mask = P0_FEATURE_PINS_PRESENT;
   23fce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23fd2:	e7ea      	b.n	23faa <configure_pins+0x5a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   23fd4:	f8df 913c 	ldr.w	r9, [pc, #316]	; 24114 <configure_pins+0x1c4>
   23fd8:	f240 2247 	movw	r2, #583	; 0x247
   23fdc:	4649      	mov	r1, r9
   23fde:	484c      	ldr	r0, [pc, #304]	; (24110 <configure_pins+0x1c0>)
   23fe0:	f008 faa5 	bl	2c52e <assert_print>
   23fe4:	f240 2147 	movw	r1, #583	; 0x247
   23fe8:	4648      	mov	r0, r9
   23fea:	f008 fa99 	bl	2c520 <assert_post_action>
   23fee:	e7e2      	b.n	23fb6 <configure_pins+0x66>
            NRFX_ASSERT(0);
   23ff0:	4d48      	ldr	r5, [pc, #288]	; (24114 <configure_pins+0x1c4>)
   23ff2:	f44f 7213 	mov.w	r2, #588	; 0x24c
   23ff6:	4629      	mov	r1, r5
   23ff8:	4845      	ldr	r0, [pc, #276]	; (24110 <configure_pins+0x1c0>)
   23ffa:	f008 fa98 	bl	2c52e <assert_print>
   23ffe:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24002:	4628      	mov	r0, r5
   24004:	f008 fa8c 	bl	2c520 <assert_post_action>
   24008:	e7d9      	b.n	23fbe <configure_pins+0x6e>
            mask = P0_FEATURE_PINS_PRESENT;
   2400a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2400e:	e055      	b.n	240bc <configure_pins+0x16c>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24010:	4f40      	ldr	r7, [pc, #256]	; (24114 <configure_pins+0x1c4>)
   24012:	f240 2247 	movw	r2, #583	; 0x247
   24016:	4639      	mov	r1, r7
   24018:	483d      	ldr	r0, [pc, #244]	; (24110 <configure_pins+0x1c0>)
   2401a:	f008 fa88 	bl	2c52e <assert_print>
   2401e:	f240 2147 	movw	r1, #583	; 0x247
   24022:	4638      	mov	r0, r7
   24024:	f008 fa7c 	bl	2c520 <assert_post_action>
   24028:	e04e      	b.n	240c8 <configure_pins+0x178>
            NRFX_ASSERT(0);
   2402a:	4d3a      	ldr	r5, [pc, #232]	; (24114 <configure_pins+0x1c4>)
   2402c:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24030:	4629      	mov	r1, r5
   24032:	4837      	ldr	r0, [pc, #220]	; (24110 <configure_pins+0x1c0>)
   24034:	f008 fa7b 	bl	2c52e <assert_print>
   24038:	f44f 7113 	mov.w	r1, #588	; 0x24c
   2403c:	4628      	mov	r0, r5
   2403e:	f008 fa6f 	bl	2c520 <assert_post_action>
   24042:	e045      	b.n	240d0 <configure_pins+0x180>
            out_pins[i] = NRF_PWM_PIN_NOT_CONNECTED;
   24044:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   24048:	ab04      	add	r3, sp, #16
   2404a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   2404e:	f843 2c10 	str.w	r2, [r3, #-16]
    for (i = 0; i < NRF_PWM_CHANNEL_COUNT; ++i)
   24052:	3401      	adds	r4, #1
   24054:	b2e4      	uxtb	r4, r4
   24056:	2c03      	cmp	r4, #3
   24058:	d844      	bhi.n	240e4 <configure_pins+0x194>
        uint8_t output_pin = p_config->output_pins[i];
   2405a:	4627      	mov	r7, r4
   2405c:	5d33      	ldrb	r3, [r6, r4]
        if (output_pin != NRFX_PWM_PIN_NOT_USED)
   2405e:	2bff      	cmp	r3, #255	; 0xff
   24060:	d0f0      	beq.n	24044 <configure_pins+0xf4>
            bool inverted = output_pin &  NRFX_PWM_PIN_INVERTED;
   24062:	09da      	lsrs	r2, r3, #7
            out_pins[i]   = output_pin & ~NRFX_PWM_PIN_INVERTED;
   24064:	f023 0580 	bic.w	r5, r3, #128	; 0x80
   24068:	ab04      	add	r3, sp, #16
   2406a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   2406e:	f843 5c10 	str.w	r5, [r3, #-16]
            if (!p_config->skip_gpio_cfg)
   24072:	7b33      	ldrb	r3, [r6, #12]
   24074:	2b00      	cmp	r3, #0
   24076:	d1ec      	bne.n	24052 <configure_pins+0x102>
                nrf_gpio_pin_write(out_pins[i], inverted ? 1 : 0);
   24078:	4613      	mov	r3, r2
    if (value == 0)
   2407a:	2a00      	cmp	r2, #0
   2407c:	d192      	bne.n	23fa4 <configure_pins+0x54>
    switch (port)
   2407e:	096a      	lsrs	r2, r5, #5
   24080:	d101      	bne.n	24086 <configure_pins+0x136>
            mask = P0_FEATURE_PINS_PRESENT;
   24082:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   24086:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2408a:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2408c:	f013 0f01 	tst.w	r3, #1
   24090:	f43f af6d 	beq.w	23f6e <configure_pins+0x1e>
    *p_pin = pin_number & 0x1F;
   24094:	f005 091f 	and.w	r9, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24098:	096b      	lsrs	r3, r5, #5
   2409a:	f47f af76 	bne.w	23f8a <configure_pins+0x3a>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2409e:	2301      	movs	r3, #1
   240a0:	fa03 f309 	lsl.w	r3, r3, r9
    p_reg->OUTCLR = clr_mask;
   240a4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   240a8:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
                nrf_gpio_cfg_output(out_pins[i]);
   240ac:	ab04      	add	r3, sp, #16
   240ae:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   240b2:	f857 5c10 	ldr.w	r5, [r7, #-16]
    switch (port)
   240b6:	096b      	lsrs	r3, r5, #5
   240b8:	d0a7      	beq.n	2400a <configure_pins+0xba>
    uint32_t mask = 0;
   240ba:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   240bc:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   240c0:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   240c2:	f013 0f01 	tst.w	r3, #1
   240c6:	d0a3      	beq.n	24010 <configure_pins+0xc0>
    *p_pin = pin_number & 0x1F;
   240c8:	f005 071f 	and.w	r7, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   240cc:	096b      	lsrs	r3, r5, #5
   240ce:	d1ac      	bne.n	2402a <configure_pins+0xda>
    reg->PIN_CNF[pin_number] = cnf;
   240d0:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   240d4:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   240d8:	2203      	movs	r2, #3
   240da:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
}
   240de:	e7b8      	b.n	24052 <configure_pins+0x102>
   240e0:	2400      	movs	r4, #0
   240e2:	e7b8      	b.n	24056 <configure_pins+0x106>
    if (!p_config->skip_psel_cfg)
   240e4:	7b73      	ldrb	r3, [r6, #13]
   240e6:	b97b      	cbnz	r3, 24108 <configure_pins+0x1b8>
        nrf_pwm_pins_set(p_instance->p_registers, out_pins);
   240e8:	f8d8 0000 	ldr.w	r0, [r8]
    for (i = 0; i < NRF_PWM_CHANNEL_COUNT; ++i)
   240ec:	2b03      	cmp	r3, #3
   240ee:	d80b      	bhi.n	24108 <configure_pins+0x1b8>
        p_reg->PSEL.OUT[i] = out_pins[i];
   240f0:	aa04      	add	r2, sp, #16
   240f2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   240f6:	f852 1c10 	ldr.w	r1, [r2, #-16]
   240fa:	f503 72ac 	add.w	r2, r3, #344	; 0x158
   240fe:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
    for (i = 0; i < NRF_PWM_CHANNEL_COUNT; ++i)
   24102:	3301      	adds	r3, #1
   24104:	b2db      	uxtb	r3, r3
   24106:	e7f1      	b.n	240ec <configure_pins+0x19c>
}
   24108:	b005      	add	sp, #20
   2410a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2410e:	bf00      	nop
   24110:	00031600 	.word	0x00031600
   24114:	0003b084 	.word	0x0003b084

00024118 <nrfx_pwm_init>:

nrfx_err_t nrfx_pwm_init(nrfx_pwm_t const *        p_instance,
                         nrfx_pwm_config_t const * p_config,
                         nrfx_pwm_handler_t        handler,
                         void *                    p_context)
{
   24118:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2411c:	4604      	mov	r4, r0
   2411e:	4690      	mov	r8, r2
   24120:	461f      	mov	r7, r3
    NRFX_ASSERT(p_config);
   24122:	460e      	mov	r6, r1
   24124:	b151      	cbz	r1, 2413c <nrfx_pwm_init+0x24>

    nrfx_err_t err_code;

    pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   24126:	7925      	ldrb	r5, [r4, #4]

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   24128:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   2412c:	493c      	ldr	r1, [pc, #240]	; (24220 <nrfx_pwm_init+0x108>)
   2412e:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   24132:	7a0b      	ldrb	r3, [r1, #8]
   24134:	b16b      	cbz	r3, 24152 <nrfx_pwm_init+0x3a>
    {
        err_code = NRFX_ERROR_INVALID_STATE;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
   24136:	483b      	ldr	r0, [pc, #236]	; (24224 <nrfx_pwm_init+0x10c>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   24138:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    NRFX_ASSERT(p_config);
   2413c:	4d3a      	ldr	r5, [pc, #232]	; (24228 <nrfx_pwm_init+0x110>)
   2413e:	228c      	movs	r2, #140	; 0x8c
   24140:	4629      	mov	r1, r5
   24142:	483a      	ldr	r0, [pc, #232]	; (2422c <nrfx_pwm_init+0x114>)
   24144:	f008 f9f3 	bl	2c52e <assert_print>
   24148:	218c      	movs	r1, #140	; 0x8c
   2414a:	4628      	mov	r0, r5
   2414c:	f008 f9e8 	bl	2c520 <assert_post_action>
   24150:	e7e9      	b.n	24126 <nrfx_pwm_init+0xe>
    p_cb->handler = handler;
   24152:	4a33      	ldr	r2, [pc, #204]	; (24220 <nrfx_pwm_init+0x108>)
   24154:	eb05 0145 	add.w	r1, r5, r5, lsl #1
   24158:	eb02 0381 	add.w	r3, r2, r1, lsl #2
   2415c:	f842 8021 	str.w	r8, [r2, r1, lsl #2]
    p_cb->p_context = p_context;
   24160:	605f      	str	r7, [r3, #4]
    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
   24162:	7b32      	ldrb	r2, [r6, #12]
   24164:	729a      	strb	r2, [r3, #10]
    configure_pins(p_instance, p_config);
   24166:	4631      	mov	r1, r6
   24168:	4620      	mov	r0, r4
   2416a:	f7ff fef1 	bl	23f50 <configure_pins>
    nrf_pwm_enable(p_instance->p_registers);
   2416e:	6823      	ldr	r3, [r4, #0]
    p_reg->ENABLE = (PWM_ENABLE_ENABLE_Enabled << PWM_ENABLE_ENABLE_Pos);
   24170:	2201      	movs	r2, #1
   24172:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    nrf_pwm_configure(p_instance->p_registers,
   24176:	6827      	ldr	r7, [r4, #0]
   24178:	f896 a005 	ldrb.w	sl, [r6, #5]
   2417c:	f896 9006 	ldrb.w	r9, [r6, #6]
   24180:	f8b6 8008 	ldrh.w	r8, [r6, #8]
    NRFX_ASSERT(top_value <= PWM_COUNTERTOP_COUNTERTOP_Msk);
   24184:	f9b6 3008 	ldrsh.w	r3, [r6, #8]
   24188:	2b00      	cmp	r3, #0
   2418a:	db3b      	blt.n	24204 <nrfx_pwm_init+0xec>
    p_reg->PRESCALER  = base_clock;
   2418c:	f8c7 a50c 	str.w	sl, [r7, #1292]	; 0x50c
    p_reg->MODE       = mode;
   24190:	f8c7 9504 	str.w	r9, [r7, #1284]	; 0x504
    p_reg->COUNTERTOP = top_value;
   24194:	f8c7 8508 	str.w	r8, [r7, #1288]	; 0x508
    nrf_pwm_decoder_set(p_instance->p_registers,
   24198:	6822      	ldr	r2, [r4, #0]
   2419a:	7ab3      	ldrb	r3, [r6, #10]
   2419c:	7af1      	ldrb	r1, [r6, #11]

NRF_STATIC_INLINE void nrf_pwm_decoder_set(NRF_PWM_Type *     p_reg,
                                           nrf_pwm_dec_load_t dec_load,
                                           nrf_pwm_dec_step_t dec_step)
{
    p_reg->DECODER = ((uint32_t)dec_load << PWM_DECODER_LOAD_Pos) |
   2419e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   241a2:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
    nrf_pwm_shorts_set(p_instance->p_registers, 0);
   241a6:	6822      	ldr	r2, [r4, #0]
    p_reg->SHORTS = mask;
   241a8:	2300      	movs	r3, #0
   241aa:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    nrf_pwm_int_set(p_instance->p_registers, 0);
   241ae:	6822      	ldr	r2, [r4, #0]
    p_reg->INTEN = mask;
   241b0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
    nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_LOOPSDONE);
   241b4:	6822      	ldr	r2, [r4, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   241b6:	f8c2 311c 	str.w	r3, [r2, #284]	; 0x11c
   241ba:	f8d2 211c 	ldr.w	r2, [r2, #284]	; 0x11c
    nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_SEQEND0);
   241be:	6822      	ldr	r2, [r4, #0]
   241c0:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
   241c4:	f8d2 2110 	ldr.w	r2, [r2, #272]	; 0x110
    nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_SEQEND1);
   241c8:	6822      	ldr	r2, [r4, #0]
   241ca:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
   241ce:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
    nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_STOPPED);
   241d2:	6822      	ldr	r2, [r4, #0]
   241d4:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
   241d8:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    if (p_cb->handler)
   241dc:	eb05 0345 	add.w	r3, r5, r5, lsl #1
   241e0:	4a0f      	ldr	r2, [pc, #60]	; (24220 <nrfx_pwm_init+0x108>)
   241e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   241e6:	b123      	cbz	r3, 241f2 <nrfx_pwm_init+0xda>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_registers));
   241e8:	6820      	ldr	r0, [r4, #0]
   241ea:	f340 3007 	sbfx	r0, r0, #12, #8
   241ee:	f7f4 f853 	bl	18298 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   241f2:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   241f6:	4b0a      	ldr	r3, [pc, #40]	; (24220 <nrfx_pwm_init+0x108>)
   241f8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
   241fc:	2301      	movs	r3, #1
   241fe:	722b      	strb	r3, [r5, #8]
    return err_code;
   24200:	480b      	ldr	r0, [pc, #44]	; (24230 <nrfx_pwm_init+0x118>)
   24202:	e799      	b.n	24138 <nrfx_pwm_init+0x20>
    NRFX_ASSERT(top_value <= PWM_COUNTERTOP_COUNTERTOP_Msk);
   24204:	f8df b02c 	ldr.w	fp, [pc, #44]	; 24234 <nrfx_pwm_init+0x11c>
   24208:	f44f 7227 	mov.w	r2, #668	; 0x29c
   2420c:	4659      	mov	r1, fp
   2420e:	4807      	ldr	r0, [pc, #28]	; (2422c <nrfx_pwm_init+0x114>)
   24210:	f008 f98d 	bl	2c52e <assert_print>
   24214:	f44f 7127 	mov.w	r1, #668	; 0x29c
   24218:	4658      	mov	r0, fp
   2421a:	f008 f981 	bl	2c520 <assert_post_action>
   2421e:	e7b5      	b.n	2418c <nrfx_pwm_init+0x74>
   24220:	20004614 	.word	0x20004614
   24224:	0bad0005 	.word	0x0bad0005
   24228:	0003bbbc 	.word	0x0003bbbc
   2422c:	00031600 	.word	0x00031600
   24230:	0bad0000 	.word	0x0bad0000
   24234:	0003b354 	.word	0x0003b354

00024238 <nrfx_pwm_uninit>:


void nrfx_pwm_uninit(nrfx_pwm_t const * p_instance)
{
   24238:	b570      	push	{r4, r5, r6, lr}
   2423a:	4605      	mov	r5, r0
    pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   2423c:	7904      	ldrb	r4, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2423e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   24242:	4b16      	ldr	r3, [pc, #88]	; (2429c <nrfx_pwm_uninit+0x64>)
   24244:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   24248:	7a1b      	ldrb	r3, [r3, #8]
   2424a:	b1bb      	cbz	r3, 2427c <nrfx_pwm_uninit+0x44>

    NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_registers));
   2424c:	6828      	ldr	r0, [r5, #0]
   2424e:	f340 3007 	sbfx	r0, r0, #12, #8
   24252:	f7f4 f82f 	bl	182b4 <arch_irq_disable>
#if defined(USE_DMA_ISSUE_WORKAROUND)
    NRFX_IRQ_DISABLE(DMA_ISSUE_EGU_IRQn);
#endif

    nrf_pwm_disable(p_instance->p_registers);
   24256:	682b      	ldr	r3, [r5, #0]
    p_reg->ENABLE = (PWM_ENABLE_ENABLE_Disabled << PWM_ENABLE_ENABLE_Pos);
   24258:	2200      	movs	r2, #0
   2425a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500

    if (!p_cb->skip_gpio_cfg)
   2425e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   24262:	4a0e      	ldr	r2, [pc, #56]	; (2429c <nrfx_pwm_uninit+0x64>)
   24264:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   24268:	7a9b      	ldrb	r3, [r3, #10]
   2426a:	b193      	cbz	r3, 24292 <nrfx_pwm_uninit+0x5a>
    {
        deconfigure_pins(p_instance);
    }

    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   2426c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   24270:	4b0a      	ldr	r3, [pc, #40]	; (2429c <nrfx_pwm_uninit+0x64>)
   24272:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   24276:	2300      	movs	r3, #0
   24278:	7223      	strb	r3, [r4, #8]
}
   2427a:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2427c:	4e08      	ldr	r6, [pc, #32]	; (242a0 <nrfx_pwm_uninit+0x68>)
   2427e:	22ca      	movs	r2, #202	; 0xca
   24280:	4631      	mov	r1, r6
   24282:	4808      	ldr	r0, [pc, #32]	; (242a4 <nrfx_pwm_uninit+0x6c>)
   24284:	f008 f953 	bl	2c52e <assert_print>
   24288:	21ca      	movs	r1, #202	; 0xca
   2428a:	4630      	mov	r0, r6
   2428c:	f008 f948 	bl	2c520 <assert_post_action>
   24290:	e7dc      	b.n	2424c <nrfx_pwm_uninit+0x14>
        deconfigure_pins(p_instance);
   24292:	4628      	mov	r0, r5
   24294:	f7ff fe04 	bl	23ea0 <deconfigure_pins>
   24298:	e7e8      	b.n	2426c <nrfx_pwm_uninit+0x34>
   2429a:	bf00      	nop
   2429c:	20004614 	.word	0x20004614
   242a0:	0003bbbc 	.word	0x0003bbbc
   242a4:	00031600 	.word	0x00031600

000242a8 <nrfx_pwm_simple_playback>:

uint32_t nrfx_pwm_simple_playback(nrfx_pwm_t const *         p_instance,
                                  nrf_pwm_sequence_t const * p_sequence,
                                  uint16_t                   playback_count,
                                  uint32_t                   flags)
{
   242a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   242ac:	4605      	mov	r5, r0
   242ae:	460c      	mov	r4, r1
   242b0:	4617      	mov	r7, r2
   242b2:	461e      	mov	r6, r3
    pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   242b4:	7903      	ldrb	r3, [r0, #4]
   242b6:	4aad      	ldr	r2, [pc, #692]	; (2456c <nrfx_pwm_simple_playback+0x2c4>)
   242b8:	eb03 0843 	add.w	r8, r3, r3, lsl #1
   242bc:	eb02 0888 	add.w	r8, r2, r8, lsl #2
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   242c0:	f898 3008 	ldrb.w	r3, [r8, #8]
   242c4:	2b00      	cmp	r3, #0
   242c6:	d06d      	beq.n	243a4 <nrfx_pwm_simple_playback+0xfc>
    NRFX_ASSERT(playback_count > 0);
   242c8:	2f00      	cmp	r7, #0
   242ca:	d079      	beq.n	243c0 <nrfx_pwm_simple_playback+0x118>
    NRFX_ASSERT(nrfx_is_in_ram(p_sequence->values.p_raw));
   242cc:	6823      	ldr	r3, [r4, #0]
   242ce:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   242d2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   242d6:	f040 8081 	bne.w	243dc <nrfx_pwm_simple_playback+0x134>

    // To take advantage of the looping mechanism, we need to use both sequences
    // (single sequence can be played back only once).
    nrf_pwm_sequence_set(p_instance->p_registers, 0, p_sequence);
   242da:	f8d5 9000 	ldr.w	r9, [r5]
    NRFX_ASSERT(p_seq != NULL);
   242de:	2c00      	cmp	r4, #0
   242e0:	f000 808a 	beq.w	243f8 <nrfx_pwm_simple_playback+0x150>
    nrf_pwm_seq_ptr_set(      p_reg, seq_id, p_seq->values.p_raw);
   242e4:	f8d4 a000 	ldr.w	sl, [r4]
    NRFX_ASSERT(p_values != NULL);
   242e8:	f1ba 0f00 	cmp.w	sl, #0
   242ec:	f000 8092 	beq.w	24414 <nrfx_pwm_simple_playback+0x16c>
    p_reg->SEQ[seq_id].PTR = (uint32_t)p_values;
   242f0:	f8c9 a520 	str.w	sl, [r9, #1312]	; 0x520
    nrf_pwm_seq_cnt_set(      p_reg, seq_id, p_seq->length);
   242f4:	f8b4 a004 	ldrh.w	sl, [r4, #4]
    NRFX_ASSERT(length != 0);
   242f8:	f1ba 0f00 	cmp.w	sl, #0
   242fc:	f000 8098 	beq.w	24430 <nrfx_pwm_simple_playback+0x188>
    NRFX_ASSERT(length <= PWM_SEQ_CNT_CNT_Msk);
   24300:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
   24304:	f040 80a2 	bne.w	2444c <nrfx_pwm_simple_playback+0x1a4>
    p_reg->SEQ[seq_id].CNT = length;
   24308:	f8c9 a524 	str.w	sl, [r9, #1316]	; 0x524
    nrf_pwm_seq_refresh_set(  p_reg, seq_id, p_seq->repeats);
   2430c:	f8d4 a008 	ldr.w	sl, [r4, #8]
    NRFX_ASSERT(refresh <= PWM_SEQ_REFRESH_CNT_Msk);
   24310:	f1ba 7f80 	cmp.w	sl, #16777216	; 0x1000000
   24314:	f080 80a8 	bcs.w	24468 <nrfx_pwm_simple_playback+0x1c0>
    p_reg->SEQ[seq_id].REFRESH  = refresh;
   24318:	f8c9 a528 	str.w	sl, [r9, #1320]	; 0x528
    nrf_pwm_seq_end_delay_set(p_reg, seq_id, p_seq->end_delay);
   2431c:	f8d4 a00c 	ldr.w	sl, [r4, #12]
    NRFX_ASSERT(end_delay <= PWM_SEQ_ENDDELAY_CNT_Msk);
   24320:	f1ba 7f80 	cmp.w	sl, #16777216	; 0x1000000
   24324:	f080 80ae 	bcs.w	24484 <nrfx_pwm_simple_playback+0x1dc>
    p_reg->SEQ[seq_id].ENDDELAY = end_delay;
   24328:	f8c9 a52c 	str.w	sl, [r9, #1324]	; 0x52c
    nrf_pwm_sequence_set(p_instance->p_registers, 1, p_sequence);
   2432c:	f8d5 9000 	ldr.w	r9, [r5]
    NRFX_ASSERT(p_seq != NULL);
   24330:	2c00      	cmp	r4, #0
   24332:	f000 80b5 	beq.w	244a0 <nrfx_pwm_simple_playback+0x1f8>
    nrf_pwm_seq_ptr_set(      p_reg, seq_id, p_seq->values.p_raw);
   24336:	f8d4 a000 	ldr.w	sl, [r4]
    NRFX_ASSERT(p_values != NULL);
   2433a:	f1ba 0f00 	cmp.w	sl, #0
   2433e:	f000 80bd 	beq.w	244bc <nrfx_pwm_simple_playback+0x214>
    p_reg->SEQ[seq_id].PTR = (uint32_t)p_values;
   24342:	f8c9 a540 	str.w	sl, [r9, #1344]	; 0x540
    nrf_pwm_seq_cnt_set(      p_reg, seq_id, p_seq->length);
   24346:	f8b4 a004 	ldrh.w	sl, [r4, #4]
    NRFX_ASSERT(length != 0);
   2434a:	f1ba 0f00 	cmp.w	sl, #0
   2434e:	f000 80c3 	beq.w	244d8 <nrfx_pwm_simple_playback+0x230>
    NRFX_ASSERT(length <= PWM_SEQ_CNT_CNT_Msk);
   24352:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
   24356:	f040 80cd 	bne.w	244f4 <nrfx_pwm_simple_playback+0x24c>
    p_reg->SEQ[seq_id].CNT = length;
   2435a:	f8c9 a544 	str.w	sl, [r9, #1348]	; 0x544
    nrf_pwm_seq_refresh_set(  p_reg, seq_id, p_seq->repeats);
   2435e:	f8d4 a008 	ldr.w	sl, [r4, #8]
    NRFX_ASSERT(refresh <= PWM_SEQ_REFRESH_CNT_Msk);
   24362:	f1ba 7f80 	cmp.w	sl, #16777216	; 0x1000000
   24366:	f080 80d3 	bcs.w	24510 <nrfx_pwm_simple_playback+0x268>
    p_reg->SEQ[seq_id].REFRESH  = refresh;
   2436a:	f8c9 a548 	str.w	sl, [r9, #1352]	; 0x548
    nrf_pwm_seq_end_delay_set(p_reg, seq_id, p_seq->end_delay);
   2436e:	68e4      	ldr	r4, [r4, #12]
    NRFX_ASSERT(end_delay <= PWM_SEQ_ENDDELAY_CNT_Msk);
   24370:	f1b4 7f80 	cmp.w	r4, #16777216	; 0x1000000
   24374:	f080 80da 	bcs.w	2452c <nrfx_pwm_simple_playback+0x284>
    p_reg->SEQ[seq_id].ENDDELAY = end_delay;
   24378:	f8c9 454c 	str.w	r4, [r9, #1356]	; 0x54c
    bool odd = (playback_count & 1);
   2437c:	f007 0301 	and.w	r3, r7, #1
    nrf_pwm_loop_set(p_instance->p_registers,
   24380:	6829      	ldr	r1, [r5, #0]
   24382:	eb03 0757 	add.w	r7, r3, r7, lsr #1
}

NRF_STATIC_INLINE void nrf_pwm_loop_set(NRF_PWM_Type * p_reg,
                                        uint16_t       loop_count)
{
    p_reg->LOOP = loop_count;
   24386:	f8c1 7514 	str.w	r7, [r1, #1300]	; 0x514
        (playback_count / 2) + (odd ? 1 : 0));

    uint32_t shorts_mask;
    if (flags & NRFX_PWM_FLAG_STOP)
   2438a:	f016 0f01 	tst.w	r6, #1
   2438e:	f040 80db 	bne.w	24548 <nrfx_pwm_simple_playback+0x2a0>
    {
        shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
    }
    else if (flags & NRFX_PWM_FLAG_LOOP)
   24392:	f016 0202 	ands.w	r2, r6, #2
   24396:	f000 80d8 	beq.w	2454a <nrfx_pwm_simple_playback+0x2a2>
    {
        shorts_mask = odd ? NRF_PWM_SHORT_LOOPSDONE_SEQSTART1_MASK
                          : NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
   2439a:	2b00      	cmp	r3, #0
   2439c:	f000 80e1 	beq.w	24562 <nrfx_pwm_simple_playback+0x2ba>
   243a0:	2208      	movs	r2, #8
   243a2:	e0d2      	b.n	2454a <nrfx_pwm_simple_playback+0x2a2>
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   243a4:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 24574 <nrfx_pwm_simple_playback+0x2cc>
   243a8:	f44f 7296 	mov.w	r2, #300	; 0x12c
   243ac:	4649      	mov	r1, r9
   243ae:	4870      	ldr	r0, [pc, #448]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   243b0:	f008 f8bd 	bl	2c52e <assert_print>
   243b4:	f44f 7196 	mov.w	r1, #300	; 0x12c
   243b8:	4648      	mov	r0, r9
   243ba:	f008 f8b1 	bl	2c520 <assert_post_action>
   243be:	e783      	b.n	242c8 <nrfx_pwm_simple_playback+0x20>
    NRFX_ASSERT(playback_count > 0);
   243c0:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 24574 <nrfx_pwm_simple_playback+0x2cc>
   243c4:	f240 122d 	movw	r2, #301	; 0x12d
   243c8:	4649      	mov	r1, r9
   243ca:	4869      	ldr	r0, [pc, #420]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   243cc:	f008 f8af 	bl	2c52e <assert_print>
   243d0:	f240 112d 	movw	r1, #301	; 0x12d
   243d4:	4648      	mov	r0, r9
   243d6:	f008 f8a3 	bl	2c520 <assert_post_action>
   243da:	e777      	b.n	242cc <nrfx_pwm_simple_playback+0x24>
    NRFX_ASSERT(nrfx_is_in_ram(p_sequence->values.p_raw));
   243dc:	f8df 9194 	ldr.w	r9, [pc, #404]	; 24574 <nrfx_pwm_simple_playback+0x2cc>
   243e0:	f44f 7297 	mov.w	r2, #302	; 0x12e
   243e4:	4649      	mov	r1, r9
   243e6:	4862      	ldr	r0, [pc, #392]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   243e8:	f008 f8a1 	bl	2c52e <assert_print>
   243ec:	f44f 7197 	mov.w	r1, #302	; 0x12e
   243f0:	4648      	mov	r0, r9
   243f2:	f008 f895 	bl	2c520 <assert_post_action>
   243f6:	e770      	b.n	242da <nrfx_pwm_simple_playback+0x32>
    NRFX_ASSERT(p_seq != NULL);
   243f8:	f8df a17c 	ldr.w	sl, [pc, #380]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   243fc:	f240 22a7 	movw	r2, #679	; 0x2a7
   24400:	4651      	mov	r1, sl
   24402:	485b      	ldr	r0, [pc, #364]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24404:	f008 f893 	bl	2c52e <assert_print>
   24408:	f240 21a7 	movw	r1, #679	; 0x2a7
   2440c:	4650      	mov	r0, sl
   2440e:	f008 f887 	bl	2c520 <assert_post_action>
   24412:	e767      	b.n	242e4 <nrfx_pwm_simple_playback+0x3c>
    NRFX_ASSERT(p_values != NULL);
   24414:	f8df b160 	ldr.w	fp, [pc, #352]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   24418:	f44f 722d 	mov.w	r2, #692	; 0x2b4
   2441c:	4659      	mov	r1, fp
   2441e:	4854      	ldr	r0, [pc, #336]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24420:	f008 f885 	bl	2c52e <assert_print>
   24424:	f44f 712d 	mov.w	r1, #692	; 0x2b4
   24428:	4658      	mov	r0, fp
   2442a:	f008 f879 	bl	2c520 <assert_post_action>
   2442e:	e75f      	b.n	242f0 <nrfx_pwm_simple_playback+0x48>
    NRFX_ASSERT(length != 0);
   24430:	f8df b144 	ldr.w	fp, [pc, #324]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   24434:	f240 22bd 	movw	r2, #701	; 0x2bd
   24438:	4659      	mov	r1, fp
   2443a:	484d      	ldr	r0, [pc, #308]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   2443c:	f008 f877 	bl	2c52e <assert_print>
   24440:	f240 21bd 	movw	r1, #701	; 0x2bd
   24444:	4658      	mov	r0, fp
   24446:	f008 f86b 	bl	2c520 <assert_post_action>
   2444a:	e759      	b.n	24300 <nrfx_pwm_simple_playback+0x58>
    NRFX_ASSERT(length <= PWM_SEQ_CNT_CNT_Msk);
   2444c:	f8df b128 	ldr.w	fp, [pc, #296]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   24450:	f240 22be 	movw	r2, #702	; 0x2be
   24454:	4659      	mov	r1, fp
   24456:	4846      	ldr	r0, [pc, #280]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24458:	f008 f869 	bl	2c52e <assert_print>
   2445c:	f240 21be 	movw	r1, #702	; 0x2be
   24460:	4658      	mov	r0, fp
   24462:	f008 f85d 	bl	2c520 <assert_post_action>
   24466:	e74f      	b.n	24308 <nrfx_pwm_simple_playback+0x60>
    NRFX_ASSERT(refresh <= PWM_SEQ_REFRESH_CNT_Msk);
   24468:	f8df b10c 	ldr.w	fp, [pc, #268]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   2446c:	f240 22c7 	movw	r2, #711	; 0x2c7
   24470:	4659      	mov	r1, fp
   24472:	483f      	ldr	r0, [pc, #252]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24474:	f008 f85b 	bl	2c52e <assert_print>
   24478:	f240 21c7 	movw	r1, #711	; 0x2c7
   2447c:	4658      	mov	r0, fp
   2447e:	f008 f84f 	bl	2c520 <assert_post_action>
   24482:	e749      	b.n	24318 <nrfx_pwm_simple_playback+0x70>
    NRFX_ASSERT(end_delay <= PWM_SEQ_ENDDELAY_CNT_Msk);
   24484:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   24488:	f44f 7234 	mov.w	r2, #720	; 0x2d0
   2448c:	4659      	mov	r1, fp
   2448e:	4838      	ldr	r0, [pc, #224]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24490:	f008 f84d 	bl	2c52e <assert_print>
   24494:	f44f 7134 	mov.w	r1, #720	; 0x2d0
   24498:	4658      	mov	r0, fp
   2449a:	f008 f841 	bl	2c520 <assert_post_action>
   2449e:	e743      	b.n	24328 <nrfx_pwm_simple_playback+0x80>
    NRFX_ASSERT(p_seq != NULL);
   244a0:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   244a4:	f240 22a7 	movw	r2, #679	; 0x2a7
   244a8:	4651      	mov	r1, sl
   244aa:	4831      	ldr	r0, [pc, #196]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   244ac:	f008 f83f 	bl	2c52e <assert_print>
   244b0:	f240 21a7 	movw	r1, #679	; 0x2a7
   244b4:	4650      	mov	r0, sl
   244b6:	f008 f833 	bl	2c520 <assert_post_action>
   244ba:	e73c      	b.n	24336 <nrfx_pwm_simple_playback+0x8e>
    NRFX_ASSERT(p_values != NULL);
   244bc:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   244c0:	f44f 722d 	mov.w	r2, #692	; 0x2b4
   244c4:	4659      	mov	r1, fp
   244c6:	482a      	ldr	r0, [pc, #168]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   244c8:	f008 f831 	bl	2c52e <assert_print>
   244cc:	f44f 712d 	mov.w	r1, #692	; 0x2b4
   244d0:	4658      	mov	r0, fp
   244d2:	f008 f825 	bl	2c520 <assert_post_action>
   244d6:	e734      	b.n	24342 <nrfx_pwm_simple_playback+0x9a>
    NRFX_ASSERT(length != 0);
   244d8:	f8df b09c 	ldr.w	fp, [pc, #156]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   244dc:	f240 22bd 	movw	r2, #701	; 0x2bd
   244e0:	4659      	mov	r1, fp
   244e2:	4823      	ldr	r0, [pc, #140]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   244e4:	f008 f823 	bl	2c52e <assert_print>
   244e8:	f240 21bd 	movw	r1, #701	; 0x2bd
   244ec:	4658      	mov	r0, fp
   244ee:	f008 f817 	bl	2c520 <assert_post_action>
   244f2:	e72e      	b.n	24352 <nrfx_pwm_simple_playback+0xaa>
    NRFX_ASSERT(length <= PWM_SEQ_CNT_CNT_Msk);
   244f4:	f8df b080 	ldr.w	fp, [pc, #128]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   244f8:	f240 22be 	movw	r2, #702	; 0x2be
   244fc:	4659      	mov	r1, fp
   244fe:	481c      	ldr	r0, [pc, #112]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24500:	f008 f815 	bl	2c52e <assert_print>
   24504:	f240 21be 	movw	r1, #702	; 0x2be
   24508:	4658      	mov	r0, fp
   2450a:	f008 f809 	bl	2c520 <assert_post_action>
   2450e:	e724      	b.n	2435a <nrfx_pwm_simple_playback+0xb2>
    NRFX_ASSERT(refresh <= PWM_SEQ_REFRESH_CNT_Msk);
   24510:	f8df b064 	ldr.w	fp, [pc, #100]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   24514:	f240 22c7 	movw	r2, #711	; 0x2c7
   24518:	4659      	mov	r1, fp
   2451a:	4815      	ldr	r0, [pc, #84]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   2451c:	f008 f807 	bl	2c52e <assert_print>
   24520:	f240 21c7 	movw	r1, #711	; 0x2c7
   24524:	4658      	mov	r0, fp
   24526:	f007 fffb 	bl	2c520 <assert_post_action>
   2452a:	e71e      	b.n	2436a <nrfx_pwm_simple_playback+0xc2>
    NRFX_ASSERT(end_delay <= PWM_SEQ_ENDDELAY_CNT_Msk);
   2452c:	f8df a048 	ldr.w	sl, [pc, #72]	; 24578 <nrfx_pwm_simple_playback+0x2d0>
   24530:	f44f 7234 	mov.w	r2, #720	; 0x2d0
   24534:	4651      	mov	r1, sl
   24536:	480e      	ldr	r0, [pc, #56]	; (24570 <nrfx_pwm_simple_playback+0x2c8>)
   24538:	f007 fff9 	bl	2c52e <assert_print>
   2453c:	f44f 7134 	mov.w	r1, #720	; 0x2d0
   24540:	4650      	mov	r0, sl
   24542:	f007 ffed 	bl	2c520 <assert_post_action>
   24546:	e717      	b.n	24378 <nrfx_pwm_simple_playback+0xd0>
        shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
   24548:	2210      	movs	r2, #16
    }
    else
    {
        shorts_mask = 0;
    }
    nrf_pwm_shorts_set(p_instance->p_registers, shorts_mask);
   2454a:	6829      	ldr	r1, [r5, #0]
    p_reg->SHORTS = mask;
   2454c:	f8c1 2200 	str.w	r2, [r1, #512]	; 0x200
                  __func__,
                  p_sequence->length);
    NRFX_LOG_DEBUG("Sequence data:");
    NRFX_LOG_HEXDUMP_DEBUG((uint8_t *)p_sequence->values.p_raw,
                           p_sequence->length * sizeof(uint16_t));
    return start_playback(p_instance, p_cb, flags,
   24550:	b2f2      	uxtb	r2, r6
   24552:	b143      	cbz	r3, 24566 <nrfx_pwm_simple_playback+0x2be>
   24554:	230c      	movs	r3, #12
   24556:	4641      	mov	r1, r8
   24558:	4628      	mov	r0, r5
   2455a:	f00c f8d6 	bl	3070a <start_playback>
        odd ? NRF_PWM_TASK_SEQSTART1 : NRF_PWM_TASK_SEQSTART0);
}
   2455e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                          : NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
   24562:	2204      	movs	r2, #4
   24564:	e7f1      	b.n	2454a <nrfx_pwm_simple_playback+0x2a2>
    return start_playback(p_instance, p_cb, flags,
   24566:	2308      	movs	r3, #8
   24568:	e7f5      	b.n	24556 <nrfx_pwm_simple_playback+0x2ae>
   2456a:	bf00      	nop
   2456c:	20004614 	.word	0x20004614
   24570:	00031600 	.word	0x00031600
   24574:	0003bbbc 	.word	0x0003bbbc
   24578:	0003b354 	.word	0x0003b354

0002457c <nrfx_pwm_is_stopped>:
    return ret_val;
}


bool nrfx_pwm_is_stopped(nrfx_pwm_t const * p_instance)
{
   2457c:	b570      	push	{r4, r5, r6, lr}
   2457e:	4605      	mov	r5, r0
    pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   24580:	7904      	ldrb	r4, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   24582:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   24586:	4b15      	ldr	r3, [pc, #84]	; (245dc <nrfx_pwm_is_stopped+0x60>)
   24588:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   2458c:	7a1b      	ldrb	r3, [r3, #8]
   2458e:	b1ab      	cbz	r3, 245bc <nrfx_pwm_is_stopped+0x40>

    bool ret_val = false;

    // If the event handler is used (interrupts are enabled), the state will
    // be changed in interrupt handler when the STOPPED event occurs.
    if (p_cb->state != NRFX_DRV_STATE_POWERED_ON)
   24590:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   24594:	4a11      	ldr	r2, [pc, #68]	; (245dc <nrfx_pwm_is_stopped+0x60>)
   24596:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2459a:	7a1b      	ldrb	r3, [r3, #8]
   2459c:	b2db      	uxtb	r3, r3
   2459e:	2b02      	cmp	r3, #2
   245a0:	d019      	beq.n	245d6 <nrfx_pwm_is_stopped+0x5a>
    {
        ret_val = true;
   245a2:	2001      	movs	r0, #1
    }
    // If interrupts are disabled, we must check the STOPPED event here.
    if (nrf_pwm_event_check(p_instance->p_registers, NRF_PWM_EVENT_STOPPED))
   245a4:	682b      	ldr	r3, [r5, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   245a6:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   245aa:	b133      	cbz	r3, 245ba <nrfx_pwm_is_stopped+0x3e>
    {
        p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   245ac:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   245b0:	4b0a      	ldr	r3, [pc, #40]	; (245dc <nrfx_pwm_is_stopped+0x60>)
   245b2:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   245b6:	2001      	movs	r0, #1
   245b8:	7220      	strb	r0, [r4, #8]
        ret_val = true;
    }

    NRFX_LOG_INFO("%s returned %d.", __func__, ret_val);
    return ret_val;
}
   245ba:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   245bc:	4e08      	ldr	r6, [pc, #32]	; (245e0 <nrfx_pwm_is_stopped+0x64>)
   245be:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
   245c2:	4631      	mov	r1, r6
   245c4:	4807      	ldr	r0, [pc, #28]	; (245e4 <nrfx_pwm_is_stopped+0x68>)
   245c6:	f007 ffb2 	bl	2c52e <assert_print>
   245ca:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
   245ce:	4630      	mov	r0, r6
   245d0:	f007 ffa6 	bl	2c520 <assert_post_action>
   245d4:	e7dc      	b.n	24590 <nrfx_pwm_is_stopped+0x14>
    bool ret_val = false;
   245d6:	2000      	movs	r0, #0
   245d8:	e7e4      	b.n	245a4 <nrfx_pwm_is_stopped+0x28>
   245da:	bf00      	nop
   245dc:	20004614 	.word	0x20004614
   245e0:	0003bbbc 	.word	0x0003bbbc
   245e4:	00031600 	.word	0x00031600

000245e8 <nrfx_pwm_stop>:
{
   245e8:	b570      	push	{r4, r5, r6, lr}
   245ea:	4604      	mov	r4, r0
   245ec:	460d      	mov	r5, r1
    NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state != NRFX_DRV_STATE_UNINITIALIZED);
   245ee:	7903      	ldrb	r3, [r0, #4]
   245f0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   245f4:	4a13      	ldr	r2, [pc, #76]	; (24644 <nrfx_pwm_stop+0x5c>)
   245f6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   245fa:	7a1b      	ldrb	r3, [r3, #8]
   245fc:	b1ab      	cbz	r3, 2462a <nrfx_pwm_stop+0x42>
    nrf_pwm_shorts_set(p_instance->p_registers, 0);
   245fe:	6823      	ldr	r3, [r4, #0]
    p_reg->SHORTS = mask;
   24600:	2200      	movs	r2, #0
   24602:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    nrf_pwm_task_trigger(p_instance->p_registers, NRF_PWM_TASK_STOP);
   24606:	6823      	ldr	r3, [r4, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24608:	2201      	movs	r2, #1
   2460a:	605a      	str	r2, [r3, #4]
    if (nrfx_pwm_is_stopped(p_instance))
   2460c:	4620      	mov	r0, r4
   2460e:	f7ff ffb5 	bl	2457c <nrfx_pwm_is_stopped>
   24612:	4603      	mov	r3, r0
   24614:	b938      	cbnz	r0, 24626 <nrfx_pwm_stop+0x3e>
            if (nrfx_pwm_is_stopped(p_instance))
   24616:	4620      	mov	r0, r4
   24618:	f7ff ffb0 	bl	2457c <nrfx_pwm_is_stopped>
   2461c:	4603      	mov	r3, r0
   2461e:	b910      	cbnz	r0, 24626 <nrfx_pwm_stop+0x3e>
        } while (wait_until_stopped);
   24620:	2d00      	cmp	r5, #0
   24622:	d1f8      	bne.n	24616 <nrfx_pwm_stop+0x2e>
    bool ret_val = false;
   24624:	462b      	mov	r3, r5
}
   24626:	4618      	mov	r0, r3
   24628:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state != NRFX_DRV_STATE_UNINITIALIZED);
   2462a:	4e07      	ldr	r6, [pc, #28]	; (24648 <nrfx_pwm_stop+0x60>)
   2462c:	f240 1285 	movw	r2, #389	; 0x185
   24630:	4631      	mov	r1, r6
   24632:	4806      	ldr	r0, [pc, #24]	; (2464c <nrfx_pwm_stop+0x64>)
   24634:	f007 ff7b 	bl	2c52e <assert_print>
   24638:	f240 1185 	movw	r1, #389	; 0x185
   2463c:	4630      	mov	r0, r6
   2463e:	f007 ff6f 	bl	2c520 <assert_post_action>
   24642:	e7dc      	b.n	245fe <nrfx_pwm_stop+0x16>
   24644:	20004614 	.word	0x20004614
   24648:	0003bbbc 	.word	0x0003bbbc
   2464c:	00031600 	.word	0x00031600

00024650 <finish_transfer>:

    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
}

static void finish_transfer(spi_control_block_t * p_cb)
{
   24650:	b570      	push	{r4, r5, r6, lr}
   24652:	4604      	mov	r4, r0
    // If Slave Select signal is used, this is the time to deactivate it.
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   24654:	7f85      	ldrb	r5, [r0, #30]
   24656:	2dff      	cmp	r5, #255	; 0xff
   24658:	d108      	bne.n	2466c <finish_transfer+0x1c>
        nrf_gpio_pin_write(p_cb->ss_pin, 1);
    }

    // By clearing this flag before calling the handler we allow subsequent
    // transfers to be started directly from the handler function.
    p_cb->transfer_in_progress = false;
   2465a:	2300      	movs	r3, #0
   2465c:	7763      	strb	r3, [r4, #29]

    p_cb->evt.type = NRFX_SPI_EVENT_DONE;
   2465e:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   24660:	4620      	mov	r0, r4
   24662:	f850 3b08 	ldr.w	r3, [r0], #8
   24666:	6861      	ldr	r1, [r4, #4]
   24668:	4798      	blx	r3
}
   2466a:	bd70      	pop	{r4, r5, r6, pc}
    switch (port)
   2466c:	096b      	lsrs	r3, r5, #5
   2466e:	d011      	beq.n	24694 <finish_transfer+0x44>
    uint32_t mask = 0;
   24670:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24672:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24676:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24678:	f013 0f01 	tst.w	r3, #1
   2467c:	d00d      	beq.n	2469a <finish_transfer+0x4a>
    *p_pin = pin_number & 0x1F;
   2467e:	f005 061f 	and.w	r6, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24682:	096b      	lsrs	r3, r5, #5
   24684:	d116      	bne.n	246b4 <finish_transfer+0x64>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   24686:	2301      	movs	r3, #1
   24688:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
   2468a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   2468e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   24692:	e7e2      	b.n	2465a <finish_transfer+0xa>
            mask = P0_FEATURE_PINS_PRESENT;
   24694:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24698:	e7eb      	b.n	24672 <finish_transfer+0x22>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2469a:	4e0d      	ldr	r6, [pc, #52]	; (246d0 <finish_transfer+0x80>)
   2469c:	f240 2247 	movw	r2, #583	; 0x247
   246a0:	4631      	mov	r1, r6
   246a2:	480c      	ldr	r0, [pc, #48]	; (246d4 <finish_transfer+0x84>)
   246a4:	f007 ff43 	bl	2c52e <assert_print>
   246a8:	f240 2147 	movw	r1, #583	; 0x247
   246ac:	4630      	mov	r0, r6
   246ae:	f007 ff37 	bl	2c520 <assert_post_action>
   246b2:	e7e4      	b.n	2467e <finish_transfer+0x2e>
            NRFX_ASSERT(0);
   246b4:	4d06      	ldr	r5, [pc, #24]	; (246d0 <finish_transfer+0x80>)
   246b6:	f44f 7213 	mov.w	r2, #588	; 0x24c
   246ba:	4629      	mov	r1, r5
   246bc:	4805      	ldr	r0, [pc, #20]	; (246d4 <finish_transfer+0x84>)
   246be:	f007 ff36 	bl	2c52e <assert_print>
   246c2:	f44f 7113 	mov.w	r1, #588	; 0x24c
   246c6:	4628      	mov	r0, r5
   246c8:	f007 ff2a 	bl	2c520 <assert_post_action>
   246cc:	e7db      	b.n	24686 <finish_transfer+0x36>
   246ce:	bf00      	nop
   246d0:	0003b084 	.word	0x0003b084
   246d4:	00031600 	.word	0x00031600

000246d8 <irq_handler>:
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
    p_cb->abort = true;
}

static void irq_handler(NRF_SPI_Type * p_spi, spi_control_block_t * p_cb)
{
   246d8:	b570      	push	{r4, r5, r6, lr}
   246da:	4604      	mov	r4, r0
   246dc:	460d      	mov	r5, r1
    NRFX_ASSERT(p_cb->handler);
   246de:	680b      	ldr	r3, [r1, #0]
   246e0:	b153      	cbz	r3, 246f8 <irq_handler+0x20>
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_spi_event_clear(NRF_SPI_Type *  p_reg,
                                           nrf_spi_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   246e2:	2300      	movs	r3, #0
   246e4:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
   246e8:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108

    nrf_spi_event_clear(p_spi, NRF_SPI_EVENT_READY);
    NRFX_LOG_DEBUG("Event: NRF_SPI_EVENT_READY.");

    if (!transfer_byte(p_spi, p_cb))
   246ec:	4629      	mov	r1, r5
   246ee:	4620      	mov	r0, r4
   246f0:	f00c f837 	bl	30762 <transfer_byte>
   246f4:	b168      	cbz	r0, 24712 <irq_handler+0x3a>
    {
        finish_transfer(p_cb);
    }
}
   246f6:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_cb->handler);
   246f8:	4e08      	ldr	r6, [pc, #32]	; (2471c <irq_handler+0x44>)
   246fa:	f240 129b 	movw	r2, #411	; 0x19b
   246fe:	4631      	mov	r1, r6
   24700:	4807      	ldr	r0, [pc, #28]	; (24720 <irq_handler+0x48>)
   24702:	f007 ff14 	bl	2c52e <assert_print>
   24706:	f240 119b 	movw	r1, #411	; 0x19b
   2470a:	4630      	mov	r0, r6
   2470c:	f007 ff08 	bl	2c520 <assert_post_action>
   24710:	e7e7      	b.n	246e2 <irq_handler+0xa>
        finish_transfer(p_cb);
   24712:	4628      	mov	r0, r5
   24714:	f7ff ff9c 	bl	24650 <finish_transfer>
}
   24718:	e7ed      	b.n	246f6 <irq_handler+0x1e>
   2471a:	bf00      	nop
   2471c:	0003bbf8 	.word	0x0003bbf8
   24720:	00031600 	.word	0x00031600

00024724 <spi_xfer>:
{
   24724:	b538      	push	{r3, r4, r5, lr}
   24726:	4604      	mov	r4, r0
   24728:	460d      	mov	r5, r1
    p_cb->bytes_transferred = 0;
   2472a:	2300      	movs	r3, #0
   2472c:	620b      	str	r3, [r1, #32]
}

NRF_STATIC_INLINE void nrf_spi_int_disable(NRF_SPI_Type * p_reg,
                                           uint32_t       mask)
{
    p_reg->INTENCLR = mask;
   2472e:	2104      	movs	r1, #4
   24730:	f8c0 1308 	str.w	r1, [r0, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   24734:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
   24738:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
   2473c:	6853      	ldr	r3, [r2, #4]
    nrf_spi_txd_set(p_spi,
   2473e:	b183      	cbz	r3, 24762 <spi_xfer+0x3e>
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
   24740:	6813      	ldr	r3, [r2, #0]
    nrf_spi_txd_set(p_spi,
   24742:	781b      	ldrb	r3, [r3, #0]
#endif
}

NRF_STATIC_INLINE void nrf_spi_txd_set(NRF_SPI_Type * p_reg, uint8_t data)
{
    p_reg->TXD = data;
   24744:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_xfer_desc->tx_length > 1)
   24748:	6853      	ldr	r3, [r2, #4]
   2474a:	2b01      	cmp	r3, #1
   2474c:	d90b      	bls.n	24766 <spi_xfer+0x42>
        nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
   2474e:	6813      	ldr	r3, [r2, #0]
   24750:	785b      	ldrb	r3, [r3, #1]
   24752:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_cb->handler)
   24756:	682b      	ldr	r3, [r5, #0]
   24758:	b163      	cbz	r3, 24774 <spi_xfer+0x50>
    p_reg->INTENSET = mask;
   2475a:	2304      	movs	r3, #4
   2475c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   24760:	bd38      	pop	{r3, r4, r5, pc}
    nrf_spi_txd_set(p_spi,
   24762:	7feb      	ldrb	r3, [r5, #31]
   24764:	e7ee      	b.n	24744 <spi_xfer+0x20>
    else if (p_xfer_desc->rx_length > 1)
   24766:	68d3      	ldr	r3, [r2, #12]
   24768:	2b01      	cmp	r3, #1
   2476a:	d9f4      	bls.n	24756 <spi_xfer+0x32>
        nrf_spi_txd_set(p_spi, p_cb->orc);
   2476c:	7feb      	ldrb	r3, [r5, #31]
    p_reg->TXD = data;
   2476e:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
}
   24772:	e7f0      	b.n	24756 <spi_xfer+0x32>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   24774:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
            while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
   24778:	2b00      	cmp	r3, #0
   2477a:	d0fb      	beq.n	24774 <spi_xfer+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2477c:	2300      	movs	r3, #0
   2477e:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
   24782:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
        } while (transfer_byte(p_spi, p_cb));
   24786:	4629      	mov	r1, r5
   24788:	4620      	mov	r0, r4
   2478a:	f00b ffea 	bl	30762 <transfer_byte>
   2478e:	2800      	cmp	r0, #0
   24790:	d1f0      	bne.n	24774 <spi_xfer+0x50>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   24792:	7fac      	ldrb	r4, [r5, #30]
   24794:	2cff      	cmp	r4, #255	; 0xff
   24796:	d0e3      	beq.n	24760 <spi_xfer+0x3c>
    switch (port)
   24798:	0963      	lsrs	r3, r4, #5
   2479a:	d011      	beq.n	247c0 <spi_xfer+0x9c>
    uint32_t mask = 0;
   2479c:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   2479e:	f004 021f 	and.w	r2, r4, #31
    return (mask & (1UL << pin_number)) ? true : false;
   247a2:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   247a4:	f013 0f01 	tst.w	r3, #1
   247a8:	d00d      	beq.n	247c6 <spi_xfer+0xa2>
    *p_pin = pin_number & 0x1F;
   247aa:	f004 051f 	and.w	r5, r4, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   247ae:	0963      	lsrs	r3, r4, #5
   247b0:	d116      	bne.n	247e0 <spi_xfer+0xbc>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   247b2:	2301      	movs	r3, #1
   247b4:	40ab      	lsls	r3, r5
    p_reg->OUTSET = set_mask;
   247b6:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   247ba:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
}
   247be:	e7cf      	b.n	24760 <spi_xfer+0x3c>
            mask = P0_FEATURE_PINS_PRESENT;
   247c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   247c4:	e7eb      	b.n	2479e <spi_xfer+0x7a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   247c6:	4d0d      	ldr	r5, [pc, #52]	; (247fc <spi_xfer+0xd8>)
   247c8:	f240 2247 	movw	r2, #583	; 0x247
   247cc:	4629      	mov	r1, r5
   247ce:	480c      	ldr	r0, [pc, #48]	; (24800 <spi_xfer+0xdc>)
   247d0:	f007 fead 	bl	2c52e <assert_print>
   247d4:	f240 2147 	movw	r1, #583	; 0x247
   247d8:	4628      	mov	r0, r5
   247da:	f007 fea1 	bl	2c520 <assert_post_action>
   247de:	e7e4      	b.n	247aa <spi_xfer+0x86>
            NRFX_ASSERT(0);
   247e0:	4c06      	ldr	r4, [pc, #24]	; (247fc <spi_xfer+0xd8>)
   247e2:	f44f 7213 	mov.w	r2, #588	; 0x24c
   247e6:	4621      	mov	r1, r4
   247e8:	4805      	ldr	r0, [pc, #20]	; (24800 <spi_xfer+0xdc>)
   247ea:	f007 fea0 	bl	2c52e <assert_print>
   247ee:	f44f 7113 	mov.w	r1, #588	; 0x24c
   247f2:	4620      	mov	r0, r4
   247f4:	f007 fe94 	bl	2c520 <assert_post_action>
   247f8:	e7db      	b.n	247b2 <spi_xfer+0x8e>
   247fa:	bf00      	nop
   247fc:	0003b084 	.word	0x0003b084
   24800:	00031600 	.word	0x00031600

00024804 <configure_pins>:
{
   24804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24808:	4605      	mov	r5, r0
   2480a:	460c      	mov	r4, r1
    if (!p_config->skip_gpio_cfg)
   2480c:	7bcb      	ldrb	r3, [r1, #15]
   2480e:	b19b      	cbz	r3, 24838 <configure_pins+0x34>
    if (!p_config->skip_psel_cfg)
   24810:	7c23      	ldrb	r3, [r4, #16]
   24812:	b97b      	cbnz	r3, 24834 <configure_pins+0x30>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
   24814:	7863      	ldrb	r3, [r4, #1]
                            : NRF_SPI_PIN_NOT_CONNECTED;
   24816:	2bff      	cmp	r3, #255	; 0xff
   24818:	f000 81b6 	beq.w	24b88 <configure_pins+0x384>
   2481c:	461a      	mov	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
   2481e:	78a3      	ldrb	r3, [r4, #2]
                            : NRF_SPI_PIN_NOT_CONNECTED;
   24820:	2bff      	cmp	r3, #255	; 0xff
   24822:	f000 81b4 	beq.w	24b8e <configure_pins+0x38a>
        nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
   24826:	7821      	ldrb	r1, [r4, #0]
    p_reg->PSELSCK  = sck_pin;
   24828:	f8c5 1508 	str.w	r1, [r5, #1288]	; 0x508
    p_reg->PSELMOSI = mosi_pin;
   2482c:	f8c5 250c 	str.w	r2, [r5, #1292]	; 0x50c
    p_reg->PSELMISO = miso_pin;
   24830:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
}
   24834:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        nrf_gpio_pin_write(p_config->sck_pin,
   24838:	780e      	ldrb	r6, [r1, #0]
                           p_config->mode <= NRF_SPI_MODE_1 ? 0 : 1);
   2483a:	7b0b      	ldrb	r3, [r1, #12]
        nrf_gpio_pin_write(p_config->sck_pin,
   2483c:	2b01      	cmp	r3, #1
   2483e:	bf94      	ite	ls
   24840:	2300      	movls	r3, #0
   24842:	2301      	movhi	r3, #1
    if (value == 0)
   24844:	2b00      	cmp	r3, #0
   24846:	d17f      	bne.n	24948 <configure_pins+0x144>
    switch (port)
   24848:	0972      	lsrs	r2, r6, #5
   2484a:	d101      	bne.n	24850 <configure_pins+0x4c>
            mask = P0_FEATURE_PINS_PRESENT;
   2484c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    pin_number &= 0x1F;
   24850:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24854:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24856:	f013 0f01 	tst.w	r3, #1
   2485a:	d05b      	beq.n	24914 <configure_pins+0x110>
    *p_pin = pin_number & 0x1F;
   2485c:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24860:	0973      	lsrs	r3, r6, #5
   24862:	d164      	bne.n	2492e <configure_pins+0x12a>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   24864:	2301      	movs	r3, #1
   24866:	40bb      	lsls	r3, r7
    p_reg->OUTCLR = clr_mask;
   24868:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   2486c:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
        nrf_gpio_cfg(p_config->sck_pin,
   24870:	7826      	ldrb	r6, [r4, #0]
    switch (port)
   24872:	0973      	lsrs	r3, r6, #5
   24874:	f000 8099 	beq.w	249aa <configure_pins+0x1a6>
    uint32_t mask = 0;
   24878:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   2487a:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2487e:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24880:	f013 0f01 	tst.w	r3, #1
   24884:	f000 8094 	beq.w	249b0 <configure_pins+0x1ac>
    *p_pin = pin_number & 0x1F;
   24888:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2488c:	0973      	lsrs	r3, r6, #5
   2488e:	f040 809c 	bne.w	249ca <configure_pins+0x1c6>
    reg->PIN_CNF[pin_number] = cnf;
   24892:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   24896:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   2489a:	2201      	movs	r2, #1
   2489c:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
        if (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
   248a0:	7866      	ldrb	r6, [r4, #1]
   248a2:	2eff      	cmp	r6, #255	; 0xff
   248a4:	f040 809e 	bne.w	249e4 <configure_pins+0x1e0>
        if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
   248a8:	78a6      	ldrb	r6, [r4, #2]
   248aa:	2eff      	cmp	r6, #255	; 0xff
   248ac:	f040 80fd 	bne.w	24aaa <configure_pins+0x2a6>
        if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
   248b0:	78e6      	ldrb	r6, [r4, #3]
   248b2:	2eff      	cmp	r6, #255	; 0xff
   248b4:	d0ac      	beq.n	24810 <configure_pins+0xc>
    switch (port)
   248b6:	0973      	lsrs	r3, r6, #5
   248b8:	f000 812c 	beq.w	24b14 <configure_pins+0x310>
    uint32_t mask = 0;
   248bc:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   248be:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   248c2:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   248c4:	f013 0f01 	tst.w	r3, #1
   248c8:	f000 8127 	beq.w	24b1a <configure_pins+0x316>
    *p_pin = pin_number & 0x1F;
   248cc:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   248d0:	0973      	lsrs	r3, r6, #5
   248d2:	f040 812f 	bne.w	24b34 <configure_pins+0x330>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   248d6:	2301      	movs	r3, #1
   248d8:	40bb      	lsls	r3, r7
    p_reg->OUTSET = set_mask;
   248da:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   248de:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
            nrf_gpio_cfg_output(p_config->ss_pin);
   248e2:	78e6      	ldrb	r6, [r4, #3]
    switch (port)
   248e4:	0973      	lsrs	r3, r6, #5
   248e6:	f000 8132 	beq.w	24b4e <configure_pins+0x34a>
    uint32_t mask = 0;
   248ea:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   248ec:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   248f0:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   248f2:	f013 0f01 	tst.w	r3, #1
   248f6:	f000 812d 	beq.w	24b54 <configure_pins+0x350>
    *p_pin = pin_number & 0x1F;
   248fa:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   248fe:	0973      	lsrs	r3, r6, #5
   24900:	f040 8135 	bne.w	24b6e <configure_pins+0x36a>
    reg->PIN_CNF[pin_number] = cnf;
   24904:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   24908:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   2490c:	2203      	movs	r2, #3
   2490e:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
}
   24912:	e77d      	b.n	24810 <configure_pins+0xc>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24914:	4f9f      	ldr	r7, [pc, #636]	; (24b94 <configure_pins+0x390>)
   24916:	f240 2247 	movw	r2, #583	; 0x247
   2491a:	4639      	mov	r1, r7
   2491c:	489e      	ldr	r0, [pc, #632]	; (24b98 <configure_pins+0x394>)
   2491e:	f007 fe06 	bl	2c52e <assert_print>
   24922:	f240 2147 	movw	r1, #583	; 0x247
   24926:	4638      	mov	r0, r7
   24928:	f007 fdfa 	bl	2c520 <assert_post_action>
   2492c:	e796      	b.n	2485c <configure_pins+0x58>
            NRFX_ASSERT(0);
   2492e:	4e99      	ldr	r6, [pc, #612]	; (24b94 <configure_pins+0x390>)
   24930:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24934:	4631      	mov	r1, r6
   24936:	4898      	ldr	r0, [pc, #608]	; (24b98 <configure_pins+0x394>)
   24938:	f007 fdf9 	bl	2c52e <assert_print>
   2493c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24940:	4630      	mov	r0, r6
   24942:	f007 fded 	bl	2c520 <assert_post_action>
   24946:	e78d      	b.n	24864 <configure_pins+0x60>
    switch (port)
   24948:	0973      	lsrs	r3, r6, #5
   2494a:	d011      	beq.n	24970 <configure_pins+0x16c>
    uint32_t mask = 0;
   2494c:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   2494e:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24952:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24954:	f013 0f01 	tst.w	r3, #1
   24958:	d00d      	beq.n	24976 <configure_pins+0x172>
    *p_pin = pin_number & 0x1F;
   2495a:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2495e:	0973      	lsrs	r3, r6, #5
   24960:	d116      	bne.n	24990 <configure_pins+0x18c>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   24962:	2301      	movs	r3, #1
   24964:	40bb      	lsls	r3, r7
    p_reg->OUTSET = set_mask;
   24966:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   2496a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
   2496e:	e77f      	b.n	24870 <configure_pins+0x6c>
            mask = P0_FEATURE_PINS_PRESENT;
   24970:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24974:	e7eb      	b.n	2494e <configure_pins+0x14a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24976:	4f87      	ldr	r7, [pc, #540]	; (24b94 <configure_pins+0x390>)
   24978:	f240 2247 	movw	r2, #583	; 0x247
   2497c:	4639      	mov	r1, r7
   2497e:	4886      	ldr	r0, [pc, #536]	; (24b98 <configure_pins+0x394>)
   24980:	f007 fdd5 	bl	2c52e <assert_print>
   24984:	f240 2147 	movw	r1, #583	; 0x247
   24988:	4638      	mov	r0, r7
   2498a:	f007 fdc9 	bl	2c520 <assert_post_action>
   2498e:	e7e4      	b.n	2495a <configure_pins+0x156>
            NRFX_ASSERT(0);
   24990:	4e80      	ldr	r6, [pc, #512]	; (24b94 <configure_pins+0x390>)
   24992:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24996:	4631      	mov	r1, r6
   24998:	487f      	ldr	r0, [pc, #508]	; (24b98 <configure_pins+0x394>)
   2499a:	f007 fdc8 	bl	2c52e <assert_print>
   2499e:	f44f 7113 	mov.w	r1, #588	; 0x24c
   249a2:	4630      	mov	r0, r6
   249a4:	f007 fdbc 	bl	2c520 <assert_post_action>
   249a8:	e7db      	b.n	24962 <configure_pins+0x15e>
            mask = P0_FEATURE_PINS_PRESENT;
   249aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   249ae:	e764      	b.n	2487a <configure_pins+0x76>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   249b0:	4f78      	ldr	r7, [pc, #480]	; (24b94 <configure_pins+0x390>)
   249b2:	f240 2247 	movw	r2, #583	; 0x247
   249b6:	4639      	mov	r1, r7
   249b8:	4877      	ldr	r0, [pc, #476]	; (24b98 <configure_pins+0x394>)
   249ba:	f007 fdb8 	bl	2c52e <assert_print>
   249be:	f240 2147 	movw	r1, #583	; 0x247
   249c2:	4638      	mov	r0, r7
   249c4:	f007 fdac 	bl	2c520 <assert_post_action>
   249c8:	e75e      	b.n	24888 <configure_pins+0x84>
            NRFX_ASSERT(0);
   249ca:	4e72      	ldr	r6, [pc, #456]	; (24b94 <configure_pins+0x390>)
   249cc:	f44f 7213 	mov.w	r2, #588	; 0x24c
   249d0:	4631      	mov	r1, r6
   249d2:	4871      	ldr	r0, [pc, #452]	; (24b98 <configure_pins+0x394>)
   249d4:	f007 fdab 	bl	2c52e <assert_print>
   249d8:	f44f 7113 	mov.w	r1, #588	; 0x24c
   249dc:	4630      	mov	r0, r6
   249de:	f007 fd9f 	bl	2c520 <assert_post_action>
   249e2:	e756      	b.n	24892 <configure_pins+0x8e>
    switch (port)
   249e4:	0973      	lsrs	r3, r6, #5
   249e6:	d026      	beq.n	24a36 <configure_pins+0x232>
    uint32_t mask = 0;
   249e8:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   249ea:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   249ee:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   249f0:	f013 0f01 	tst.w	r3, #1
   249f4:	d022      	beq.n	24a3c <configure_pins+0x238>
    *p_pin = pin_number & 0x1F;
   249f6:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   249fa:	0973      	lsrs	r3, r6, #5
   249fc:	d12b      	bne.n	24a56 <configure_pins+0x252>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   249fe:	2301      	movs	r3, #1
   24a00:	40bb      	lsls	r3, r7
    p_reg->OUTCLR = clr_mask;
   24a02:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   24a06:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
            nrf_gpio_cfg_output(p_config->mosi_pin);
   24a0a:	7866      	ldrb	r6, [r4, #1]
    switch (port)
   24a0c:	0973      	lsrs	r3, r6, #5
   24a0e:	d02f      	beq.n	24a70 <configure_pins+0x26c>
    uint32_t mask = 0;
   24a10:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24a12:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24a16:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24a18:	f013 0f01 	tst.w	r3, #1
   24a1c:	d02b      	beq.n	24a76 <configure_pins+0x272>
    *p_pin = pin_number & 0x1F;
   24a1e:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24a22:	0973      	lsrs	r3, r6, #5
   24a24:	d134      	bne.n	24a90 <configure_pins+0x28c>
    reg->PIN_CNF[pin_number] = cnf;
   24a26:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   24a2a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   24a2e:	2203      	movs	r2, #3
   24a30:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
}
   24a34:	e738      	b.n	248a8 <configure_pins+0xa4>
            mask = P0_FEATURE_PINS_PRESENT;
   24a36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24a3a:	e7d6      	b.n	249ea <configure_pins+0x1e6>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24a3c:	4f55      	ldr	r7, [pc, #340]	; (24b94 <configure_pins+0x390>)
   24a3e:	f240 2247 	movw	r2, #583	; 0x247
   24a42:	4639      	mov	r1, r7
   24a44:	4854      	ldr	r0, [pc, #336]	; (24b98 <configure_pins+0x394>)
   24a46:	f007 fd72 	bl	2c52e <assert_print>
   24a4a:	f240 2147 	movw	r1, #583	; 0x247
   24a4e:	4638      	mov	r0, r7
   24a50:	f007 fd66 	bl	2c520 <assert_post_action>
   24a54:	e7cf      	b.n	249f6 <configure_pins+0x1f2>
            NRFX_ASSERT(0);
   24a56:	4e4f      	ldr	r6, [pc, #316]	; (24b94 <configure_pins+0x390>)
   24a58:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24a5c:	4631      	mov	r1, r6
   24a5e:	484e      	ldr	r0, [pc, #312]	; (24b98 <configure_pins+0x394>)
   24a60:	f007 fd65 	bl	2c52e <assert_print>
   24a64:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24a68:	4630      	mov	r0, r6
   24a6a:	f007 fd59 	bl	2c520 <assert_post_action>
   24a6e:	e7c6      	b.n	249fe <configure_pins+0x1fa>
            mask = P0_FEATURE_PINS_PRESENT;
   24a70:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24a74:	e7cd      	b.n	24a12 <configure_pins+0x20e>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24a76:	4f47      	ldr	r7, [pc, #284]	; (24b94 <configure_pins+0x390>)
   24a78:	f240 2247 	movw	r2, #583	; 0x247
   24a7c:	4639      	mov	r1, r7
   24a7e:	4846      	ldr	r0, [pc, #280]	; (24b98 <configure_pins+0x394>)
   24a80:	f007 fd55 	bl	2c52e <assert_print>
   24a84:	f240 2147 	movw	r1, #583	; 0x247
   24a88:	4638      	mov	r0, r7
   24a8a:	f007 fd49 	bl	2c520 <assert_post_action>
   24a8e:	e7c6      	b.n	24a1e <configure_pins+0x21a>
            NRFX_ASSERT(0);
   24a90:	4e40      	ldr	r6, [pc, #256]	; (24b94 <configure_pins+0x390>)
   24a92:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24a96:	4631      	mov	r1, r6
   24a98:	483f      	ldr	r0, [pc, #252]	; (24b98 <configure_pins+0x394>)
   24a9a:	f007 fd48 	bl	2c52e <assert_print>
   24a9e:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24aa2:	4630      	mov	r0, r6
   24aa4:	f007 fd3c 	bl	2c520 <assert_post_action>
   24aa8:	e7bd      	b.n	24a26 <configure_pins+0x222>
            nrf_gpio_cfg_input(p_config->miso_pin, p_config->miso_pull);
   24aaa:	f894 800e 	ldrb.w	r8, [r4, #14]
    switch (port)
   24aae:	0973      	lsrs	r3, r6, #5
   24ab0:	d013      	beq.n	24ada <configure_pins+0x2d6>
    uint32_t mask = 0;
   24ab2:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24ab4:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24ab8:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24aba:	f013 0f01 	tst.w	r3, #1
   24abe:	d00f      	beq.n	24ae0 <configure_pins+0x2dc>
    *p_pin = pin_number & 0x1F;
   24ac0:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24ac4:	0973      	lsrs	r3, r6, #5
   24ac6:	d118      	bne.n	24afa <configure_pins+0x2f6>
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   24ac8:	ea4f 0388 	mov.w	r3, r8, lsl #2
    reg->PIN_CNF[pin_number] = cnf;
   24acc:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   24ad0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   24ad4:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
}
   24ad8:	e6ea      	b.n	248b0 <configure_pins+0xac>
            mask = P0_FEATURE_PINS_PRESENT;
   24ada:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24ade:	e7e9      	b.n	24ab4 <configure_pins+0x2b0>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24ae0:	4f2c      	ldr	r7, [pc, #176]	; (24b94 <configure_pins+0x390>)
   24ae2:	f240 2247 	movw	r2, #583	; 0x247
   24ae6:	4639      	mov	r1, r7
   24ae8:	482b      	ldr	r0, [pc, #172]	; (24b98 <configure_pins+0x394>)
   24aea:	f007 fd20 	bl	2c52e <assert_print>
   24aee:	f240 2147 	movw	r1, #583	; 0x247
   24af2:	4638      	mov	r0, r7
   24af4:	f007 fd14 	bl	2c520 <assert_post_action>
   24af8:	e7e2      	b.n	24ac0 <configure_pins+0x2bc>
            NRFX_ASSERT(0);
   24afa:	4e26      	ldr	r6, [pc, #152]	; (24b94 <configure_pins+0x390>)
   24afc:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24b00:	4631      	mov	r1, r6
   24b02:	4825      	ldr	r0, [pc, #148]	; (24b98 <configure_pins+0x394>)
   24b04:	f007 fd13 	bl	2c52e <assert_print>
   24b08:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24b0c:	4630      	mov	r0, r6
   24b0e:	f007 fd07 	bl	2c520 <assert_post_action>
   24b12:	e7d9      	b.n	24ac8 <configure_pins+0x2c4>
            mask = P0_FEATURE_PINS_PRESENT;
   24b14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24b18:	e6d1      	b.n	248be <configure_pins+0xba>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24b1a:	4f1e      	ldr	r7, [pc, #120]	; (24b94 <configure_pins+0x390>)
   24b1c:	f240 2247 	movw	r2, #583	; 0x247
   24b20:	4639      	mov	r1, r7
   24b22:	481d      	ldr	r0, [pc, #116]	; (24b98 <configure_pins+0x394>)
   24b24:	f007 fd03 	bl	2c52e <assert_print>
   24b28:	f240 2147 	movw	r1, #583	; 0x247
   24b2c:	4638      	mov	r0, r7
   24b2e:	f007 fcf7 	bl	2c520 <assert_post_action>
   24b32:	e6cb      	b.n	248cc <configure_pins+0xc8>
            NRFX_ASSERT(0);
   24b34:	4e17      	ldr	r6, [pc, #92]	; (24b94 <configure_pins+0x390>)
   24b36:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24b3a:	4631      	mov	r1, r6
   24b3c:	4816      	ldr	r0, [pc, #88]	; (24b98 <configure_pins+0x394>)
   24b3e:	f007 fcf6 	bl	2c52e <assert_print>
   24b42:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24b46:	4630      	mov	r0, r6
   24b48:	f007 fcea 	bl	2c520 <assert_post_action>
   24b4c:	e6c3      	b.n	248d6 <configure_pins+0xd2>
            mask = P0_FEATURE_PINS_PRESENT;
   24b4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24b52:	e6cb      	b.n	248ec <configure_pins+0xe8>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24b54:	4f0f      	ldr	r7, [pc, #60]	; (24b94 <configure_pins+0x390>)
   24b56:	f240 2247 	movw	r2, #583	; 0x247
   24b5a:	4639      	mov	r1, r7
   24b5c:	480e      	ldr	r0, [pc, #56]	; (24b98 <configure_pins+0x394>)
   24b5e:	f007 fce6 	bl	2c52e <assert_print>
   24b62:	f240 2147 	movw	r1, #583	; 0x247
   24b66:	4638      	mov	r0, r7
   24b68:	f007 fcda 	bl	2c520 <assert_post_action>
   24b6c:	e6c5      	b.n	248fa <configure_pins+0xf6>
            NRFX_ASSERT(0);
   24b6e:	4e09      	ldr	r6, [pc, #36]	; (24b94 <configure_pins+0x390>)
   24b70:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24b74:	4631      	mov	r1, r6
   24b76:	4808      	ldr	r0, [pc, #32]	; (24b98 <configure_pins+0x394>)
   24b78:	f007 fcd9 	bl	2c52e <assert_print>
   24b7c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24b80:	4630      	mov	r0, r6
   24b82:	f007 fccd 	bl	2c520 <assert_post_action>
   24b86:	e6bd      	b.n	24904 <configure_pins+0x100>
                            : NRF_SPI_PIN_NOT_CONNECTED;
   24b88:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   24b8c:	e647      	b.n	2481e <configure_pins+0x1a>
                            : NRF_SPI_PIN_NOT_CONNECTED;
   24b8e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24b92:	e648      	b.n	24826 <configure_pins+0x22>
   24b94:	0003b084 	.word	0x0003b084
   24b98:	00031600 	.word	0x00031600

00024b9c <nrfx_spi_init>:
{
   24b9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24ba0:	4605      	mov	r5, r0
   24ba2:	4690      	mov	r8, r2
   24ba4:	461f      	mov	r7, r3
    NRFX_ASSERT(p_config);
   24ba6:	460e      	mov	r6, r1
   24ba8:	b161      	cbz	r1, 24bc4 <nrfx_spi_init+0x28>
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   24baa:	792c      	ldrb	r4, [r5, #4]
    NRF_SPI_Type * p_spi = p_instance->p_reg;
   24bac:	f8d5 9000 	ldr.w	r9, [r5]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   24bb0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24bb4:	492b      	ldr	r1, [pc, #172]	; (24c64 <nrfx_spi_init+0xc8>)
   24bb6:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   24bba:	7f0b      	ldrb	r3, [r1, #28]
   24bbc:	b16b      	cbz	r3, 24bda <nrfx_spi_init+0x3e>
        return err_code;
   24bbe:	482a      	ldr	r0, [pc, #168]	; (24c68 <nrfx_spi_init+0xcc>)
}
   24bc0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    NRFX_ASSERT(p_config);
   24bc4:	4c29      	ldr	r4, [pc, #164]	; (24c6c <nrfx_spi_init+0xd0>)
   24bc6:	227c      	movs	r2, #124	; 0x7c
   24bc8:	4621      	mov	r1, r4
   24bca:	4829      	ldr	r0, [pc, #164]	; (24c70 <nrfx_spi_init+0xd4>)
   24bcc:	f007 fcaf 	bl	2c52e <assert_print>
   24bd0:	217c      	movs	r1, #124	; 0x7c
   24bd2:	4620      	mov	r0, r4
   24bd4:	f007 fca4 	bl	2c520 <assert_post_action>
   24bd8:	e7e7      	b.n	24baa <nrfx_spi_init+0xe>
    p_cb->handler = handler;
   24bda:	4a22      	ldr	r2, [pc, #136]	; (24c64 <nrfx_spi_init+0xc8>)
   24bdc:	eb04 0184 	add.w	r1, r4, r4, lsl #2
   24be0:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
   24be4:	f842 8031 	str.w	r8, [r2, r1, lsl #3]
    p_cb->p_context = p_context;
   24be8:	605f      	str	r7, [r3, #4]
    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
   24bea:	7bf2      	ldrb	r2, [r6, #15]
   24bec:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    p_cb->ss_pin = p_config->ss_pin;
   24bf0:	78f2      	ldrb	r2, [r6, #3]
   24bf2:	779a      	strb	r2, [r3, #30]
    p_cb->orc = p_config->orc;
   24bf4:	7972      	ldrb	r2, [r6, #5]
   24bf6:	77da      	strb	r2, [r3, #31]
    configure_pins(p_spi, p_config);
   24bf8:	4631      	mov	r1, r6
   24bfa:	4648      	mov	r0, r9
   24bfc:	f7ff fe02 	bl	24804 <configure_pins>
    nrf_spi_frequency_set(p_spi, p_config->frequency);
   24c00:	68b3      	ldr	r3, [r6, #8]
}

NRF_STATIC_INLINE void nrf_spi_frequency_set(NRF_SPI_Type *      p_reg,
                                             nrf_spi_frequency_t frequency)
{
    p_reg->FREQUENCY = (uint32_t)frequency;
   24c02:	f8c9 3524 	str.w	r3, [r9, #1316]	; 0x524
    nrf_spi_configure(p_spi, p_config->mode, p_config->bit_order);
   24c06:	7b32      	ldrb	r2, [r6, #12]
   24c08:	7b73      	ldrb	r3, [r6, #13]
NRF_STATIC_INLINE void nrf_spi_configure(NRF_SPI_Type *      p_reg,
                                         nrf_spi_mode_t      spi_mode,
                                         nrf_spi_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
   24c0a:	3b00      	subs	r3, #0
   24c0c:	bf18      	it	ne
   24c0e:	2301      	movne	r3, #1
    switch (spi_mode)
   24c10:	2a02      	cmp	r2, #2
   24c12:	d021      	beq.n	24c58 <nrfx_spi_init+0xbc>
   24c14:	2a03      	cmp	r2, #3
   24c16:	d022      	beq.n	24c5e <nrfx_spi_init+0xc2>
   24c18:	2a01      	cmp	r2, #1
   24c1a:	d01a      	beq.n	24c52 <nrfx_spi_init+0xb6>
    case NRF_SPI_MODE_3:
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   24c1c:	f8c9 3554 	str.w	r3, [r9, #1364]	; 0x554
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
   24c20:	2301      	movs	r3, #1
   24c22:	f8c9 3500 	str.w	r3, [r9, #1280]	; 0x500
    if (p_cb->handler)
   24c26:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24c2a:	4a0e      	ldr	r2, [pc, #56]	; (24c64 <nrfx_spi_init+0xc8>)
   24c2c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   24c30:	b123      	cbz	r3, 24c3c <nrfx_spi_init+0xa0>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   24c32:	6828      	ldr	r0, [r5, #0]
   24c34:	f340 3007 	sbfx	r0, r0, #12, #8
   24c38:	f7f3 fb2e 	bl	18298 <arch_irq_enable>
    p_cb->transfer_in_progress = false;
   24c3c:	4b09      	ldr	r3, [pc, #36]	; (24c64 <nrfx_spi_init+0xc8>)
   24c3e:	eb04 0284 	add.w	r2, r4, r4, lsl #2
   24c42:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   24c46:	2100      	movs	r1, #0
   24c48:	7751      	strb	r1, [r2, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   24c4a:	2301      	movs	r3, #1
   24c4c:	7713      	strb	r3, [r2, #28]
    return err_code;
   24c4e:	4809      	ldr	r0, [pc, #36]	; (24c74 <nrfx_spi_init+0xd8>)
   24c50:	e7b6      	b.n	24bc0 <nrfx_spi_init+0x24>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
   24c52:	f043 0302 	orr.w	r3, r3, #2
        break;
   24c56:	e7e1      	b.n	24c1c <nrfx_spi_init+0x80>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
   24c58:	f043 0304 	orr.w	r3, r3, #4
        break;
   24c5c:	e7de      	b.n	24c1c <nrfx_spi_init+0x80>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
   24c5e:	f043 0306 	orr.w	r3, r3, #6
        break;
   24c62:	e7db      	b.n	24c1c <nrfx_spi_init+0x80>
   24c64:	20004620 	.word	0x20004620
   24c68:	0bad0005 	.word	0x0bad0005
   24c6c:	0003bbf8 	.word	0x0003bbf8
   24c70:	00031600 	.word	0x00031600
   24c74:	0bad0000 	.word	0x0bad0000

00024c78 <nrfx_spi_uninit>:
{
   24c78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24c7a:	4605      	mov	r5, r0
    spi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   24c7c:	7904      	ldrb	r4, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   24c7e:	eb04 0284 	add.w	r2, r4, r4, lsl #2
   24c82:	4b87      	ldr	r3, [pc, #540]	; (24ea0 <nrfx_spi_uninit+0x228>)
   24c84:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   24c88:	7f1b      	ldrb	r3, [r3, #28]
   24c8a:	b303      	cbz	r3, 24cce <nrfx_spi_uninit+0x56>
    NRF_SPI_Type * p_spi = p_instance->p_reg;
   24c8c:	682d      	ldr	r5, [r5, #0]
    if (p_cb->handler)
   24c8e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24c92:	4a83      	ldr	r2, [pc, #524]	; (24ea0 <nrfx_spi_uninit+0x228>)
   24c94:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   24c98:	b133      	cbz	r3, 24ca8 <nrfx_spi_uninit+0x30>
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
   24c9a:	f345 3007 	sbfx	r0, r5, #12, #8
   24c9e:	f7f3 fb09 	bl	182b4 <arch_irq_disable>
    p_reg->INTENCLR = mask;
   24ca2:	2304      	movs	r3, #4
   24ca4:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Disabled << SPI_ENABLE_ENABLE_Pos);
   24ca8:	2300      	movs	r3, #0
   24caa:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    if (!p_cb->skip_gpio_cfg)
   24cae:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24cb2:	4a7b      	ldr	r2, [pc, #492]	; (24ea0 <nrfx_spi_uninit+0x228>)
   24cb4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   24cb8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   24cbc:	b193      	cbz	r3, 24ce4 <nrfx_spi_uninit+0x6c>
    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   24cbe:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   24cc2:	4b77      	ldr	r3, [pc, #476]	; (24ea0 <nrfx_spi_uninit+0x228>)
   24cc4:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   24cc8:	2300      	movs	r3, #0
   24cca:	7723      	strb	r3, [r4, #28]
}
   24ccc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   24cce:	4e75      	ldr	r6, [pc, #468]	; (24ea4 <nrfx_spi_uninit+0x22c>)
   24cd0:	22c1      	movs	r2, #193	; 0xc1
   24cd2:	4631      	mov	r1, r6
   24cd4:	4874      	ldr	r0, [pc, #464]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24cd6:	f007 fc2a 	bl	2c52e <assert_print>
   24cda:	21c1      	movs	r1, #193	; 0xc1
   24cdc:	4630      	mov	r0, r6
   24cde:	f007 fc1f 	bl	2c520 <assert_post_action>
   24ce2:	e7d3      	b.n	24c8c <nrfx_spi_uninit+0x14>
    return p_reg->PSELSCK;
   24ce4:	f8d5 6508 	ldr.w	r6, [r5, #1288]	; 0x508
    switch (port)
   24ce8:	0973      	lsrs	r3, r6, #5
   24cea:	d03b      	beq.n	24d64 <nrfx_spi_uninit+0xec>
    uint32_t mask = 0;
   24cec:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24cee:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24cf2:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24cf4:	f013 0f01 	tst.w	r3, #1
   24cf8:	d037      	beq.n	24d6a <nrfx_spi_uninit+0xf2>
    *p_pin = pin_number & 0x1F;
   24cfa:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24cfe:	0973      	lsrs	r3, r6, #5
   24d00:	d140      	bne.n	24d84 <nrfx_spi_uninit+0x10c>
    reg->PIN_CNF[pin_number] = cnf;
   24d02:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   24d06:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   24d0a:	2202      	movs	r2, #2
   24d0c:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
    return p_reg->PSELMISO;
   24d10:	f8d5 6510 	ldr.w	r6, [r5, #1296]	; 0x510
        if (miso_pin != NRF_SPI_PIN_NOT_CONNECTED)
   24d14:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
   24d18:	d141      	bne.n	24d9e <nrfx_spi_uninit+0x126>
    return p_reg->PSELMOSI;
   24d1a:	f8d5 550c 	ldr.w	r5, [r5, #1292]	; 0x50c
        if (mosi_pin != NRF_SPI_PIN_NOT_CONNECTED)
   24d1e:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
   24d22:	d16e      	bne.n	24e02 <nrfx_spi_uninit+0x18a>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   24d24:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24d28:	4a5d      	ldr	r2, [pc, #372]	; (24ea0 <nrfx_spi_uninit+0x228>)
   24d2a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   24d2e:	7f9d      	ldrb	r5, [r3, #30]
   24d30:	2dff      	cmp	r5, #255	; 0xff
   24d32:	d0c4      	beq.n	24cbe <nrfx_spi_uninit+0x46>
    switch (port)
   24d34:	096b      	lsrs	r3, r5, #5
   24d36:	f000 8096 	beq.w	24e66 <nrfx_spi_uninit+0x1ee>
    uint32_t mask = 0;
   24d3a:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24d3c:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24d40:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24d42:	f013 0f01 	tst.w	r3, #1
   24d46:	f000 8091 	beq.w	24e6c <nrfx_spi_uninit+0x1f4>
    *p_pin = pin_number & 0x1F;
   24d4a:	f005 061f 	and.w	r6, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24d4e:	096b      	lsrs	r3, r5, #5
   24d50:	f040 8099 	bne.w	24e86 <nrfx_spi_uninit+0x20e>
    reg->PIN_CNF[pin_number] = cnf;
   24d54:	f506 76e0 	add.w	r6, r6, #448	; 0x1c0
   24d58:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   24d5c:	2202      	movs	r2, #2
   24d5e:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
}
   24d62:	e7ac      	b.n	24cbe <nrfx_spi_uninit+0x46>
            mask = P0_FEATURE_PINS_PRESENT;
   24d64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24d68:	e7c1      	b.n	24cee <nrfx_spi_uninit+0x76>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24d6a:	4f50      	ldr	r7, [pc, #320]	; (24eac <nrfx_spi_uninit+0x234>)
   24d6c:	f240 2247 	movw	r2, #583	; 0x247
   24d70:	4639      	mov	r1, r7
   24d72:	484d      	ldr	r0, [pc, #308]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24d74:	f007 fbdb 	bl	2c52e <assert_print>
   24d78:	f240 2147 	movw	r1, #583	; 0x247
   24d7c:	4638      	mov	r0, r7
   24d7e:	f007 fbcf 	bl	2c520 <assert_post_action>
   24d82:	e7ba      	b.n	24cfa <nrfx_spi_uninit+0x82>
            NRFX_ASSERT(0);
   24d84:	4e49      	ldr	r6, [pc, #292]	; (24eac <nrfx_spi_uninit+0x234>)
   24d86:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24d8a:	4631      	mov	r1, r6
   24d8c:	4846      	ldr	r0, [pc, #280]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24d8e:	f007 fbce 	bl	2c52e <assert_print>
   24d92:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24d96:	4630      	mov	r0, r6
   24d98:	f007 fbc2 	bl	2c520 <assert_post_action>
   24d9c:	e7b1      	b.n	24d02 <nrfx_spi_uninit+0x8a>
    switch (port)
   24d9e:	0973      	lsrs	r3, r6, #5
   24da0:	d012      	beq.n	24dc8 <nrfx_spi_uninit+0x150>
    uint32_t mask = 0;
   24da2:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24da4:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24da8:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24daa:	f013 0f01 	tst.w	r3, #1
   24dae:	d00e      	beq.n	24dce <nrfx_spi_uninit+0x156>
    *p_pin = pin_number & 0x1F;
   24db0:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24db4:	0973      	lsrs	r3, r6, #5
   24db6:	d117      	bne.n	24de8 <nrfx_spi_uninit+0x170>
    reg->PIN_CNF[pin_number] = cnf;
   24db8:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   24dbc:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   24dc0:	2202      	movs	r2, #2
   24dc2:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
}
   24dc6:	e7a8      	b.n	24d1a <nrfx_spi_uninit+0xa2>
            mask = P0_FEATURE_PINS_PRESENT;
   24dc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24dcc:	e7ea      	b.n	24da4 <nrfx_spi_uninit+0x12c>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24dce:	4f37      	ldr	r7, [pc, #220]	; (24eac <nrfx_spi_uninit+0x234>)
   24dd0:	f240 2247 	movw	r2, #583	; 0x247
   24dd4:	4639      	mov	r1, r7
   24dd6:	4834      	ldr	r0, [pc, #208]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24dd8:	f007 fba9 	bl	2c52e <assert_print>
   24ddc:	f240 2147 	movw	r1, #583	; 0x247
   24de0:	4638      	mov	r0, r7
   24de2:	f007 fb9d 	bl	2c520 <assert_post_action>
   24de6:	e7e3      	b.n	24db0 <nrfx_spi_uninit+0x138>
            NRFX_ASSERT(0);
   24de8:	4e30      	ldr	r6, [pc, #192]	; (24eac <nrfx_spi_uninit+0x234>)
   24dea:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24dee:	4631      	mov	r1, r6
   24df0:	482d      	ldr	r0, [pc, #180]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24df2:	f007 fb9c 	bl	2c52e <assert_print>
   24df6:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24dfa:	4630      	mov	r0, r6
   24dfc:	f007 fb90 	bl	2c520 <assert_post_action>
   24e00:	e7da      	b.n	24db8 <nrfx_spi_uninit+0x140>
    switch (port)
   24e02:	096b      	lsrs	r3, r5, #5
   24e04:	d012      	beq.n	24e2c <nrfx_spi_uninit+0x1b4>
    uint32_t mask = 0;
   24e06:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24e08:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24e0c:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24e0e:	f013 0f01 	tst.w	r3, #1
   24e12:	d00e      	beq.n	24e32 <nrfx_spi_uninit+0x1ba>
    *p_pin = pin_number & 0x1F;
   24e14:	f005 061f 	and.w	r6, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24e18:	096b      	lsrs	r3, r5, #5
   24e1a:	d117      	bne.n	24e4c <nrfx_spi_uninit+0x1d4>
    reg->PIN_CNF[pin_number] = cnf;
   24e1c:	f506 76e0 	add.w	r6, r6, #448	; 0x1c0
   24e20:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   24e24:	2202      	movs	r2, #2
   24e26:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
}
   24e2a:	e77b      	b.n	24d24 <nrfx_spi_uninit+0xac>
            mask = P0_FEATURE_PINS_PRESENT;
   24e2c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24e30:	e7ea      	b.n	24e08 <nrfx_spi_uninit+0x190>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24e32:	4e1e      	ldr	r6, [pc, #120]	; (24eac <nrfx_spi_uninit+0x234>)
   24e34:	f240 2247 	movw	r2, #583	; 0x247
   24e38:	4631      	mov	r1, r6
   24e3a:	481b      	ldr	r0, [pc, #108]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24e3c:	f007 fb77 	bl	2c52e <assert_print>
   24e40:	f240 2147 	movw	r1, #583	; 0x247
   24e44:	4630      	mov	r0, r6
   24e46:	f007 fb6b 	bl	2c520 <assert_post_action>
   24e4a:	e7e3      	b.n	24e14 <nrfx_spi_uninit+0x19c>
            NRFX_ASSERT(0);
   24e4c:	4d17      	ldr	r5, [pc, #92]	; (24eac <nrfx_spi_uninit+0x234>)
   24e4e:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24e52:	4629      	mov	r1, r5
   24e54:	4814      	ldr	r0, [pc, #80]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24e56:	f007 fb6a 	bl	2c52e <assert_print>
   24e5a:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24e5e:	4628      	mov	r0, r5
   24e60:	f007 fb5e 	bl	2c520 <assert_post_action>
   24e64:	e7da      	b.n	24e1c <nrfx_spi_uninit+0x1a4>
            mask = P0_FEATURE_PINS_PRESENT;
   24e66:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24e6a:	e767      	b.n	24d3c <nrfx_spi_uninit+0xc4>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24e6c:	4e0f      	ldr	r6, [pc, #60]	; (24eac <nrfx_spi_uninit+0x234>)
   24e6e:	f240 2247 	movw	r2, #583	; 0x247
   24e72:	4631      	mov	r1, r6
   24e74:	480c      	ldr	r0, [pc, #48]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24e76:	f007 fb5a 	bl	2c52e <assert_print>
   24e7a:	f240 2147 	movw	r1, #583	; 0x247
   24e7e:	4630      	mov	r0, r6
   24e80:	f007 fb4e 	bl	2c520 <assert_post_action>
   24e84:	e761      	b.n	24d4a <nrfx_spi_uninit+0xd2>
            NRFX_ASSERT(0);
   24e86:	4d09      	ldr	r5, [pc, #36]	; (24eac <nrfx_spi_uninit+0x234>)
   24e88:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24e8c:	4629      	mov	r1, r5
   24e8e:	4806      	ldr	r0, [pc, #24]	; (24ea8 <nrfx_spi_uninit+0x230>)
   24e90:	f007 fb4d 	bl	2c52e <assert_print>
   24e94:	f44f 7113 	mov.w	r1, #588	; 0x24c
   24e98:	4628      	mov	r0, r5
   24e9a:	f007 fb41 	bl	2c520 <assert_post_action>
   24e9e:	e759      	b.n	24d54 <nrfx_spi_uninit+0xdc>
   24ea0:	20004620 	.word	0x20004620
   24ea4:	0003bbf8 	.word	0x0003bbf8
   24ea8:	00031600 	.word	0x00031600
   24eac:	0003b084 	.word	0x0003b084

00024eb0 <nrfx_spi_xfer>:
{
   24eb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24eb4:	4606      	mov	r6, r0
   24eb6:	460d      	mov	r5, r1
   24eb8:	4690      	mov	r8, r2
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   24eba:	7904      	ldrb	r4, [r0, #4]
   24ebc:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24ec0:	4f57      	ldr	r7, [pc, #348]	; (25020 <nrfx_spi_xfer+0x170>)
   24ec2:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   24ec6:	7f3b      	ldrb	r3, [r7, #28]
   24ec8:	2b00      	cmp	r3, #0
   24eca:	d039      	beq.n	24f40 <nrfx_spi_xfer+0x90>
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   24ecc:	682b      	ldr	r3, [r5, #0]
   24ece:	2b00      	cmp	r3, #0
   24ed0:	d044      	beq.n	24f5c <nrfx_spi_xfer+0xac>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   24ed2:	68ab      	ldr	r3, [r5, #8]
   24ed4:	2b00      	cmp	r3, #0
   24ed6:	d052      	beq.n	24f7e <nrfx_spi_xfer+0xce>
    if (p_cb->transfer_in_progress)
   24ed8:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24edc:	4950      	ldr	r1, [pc, #320]	; (25020 <nrfx_spi_xfer+0x170>)
   24ede:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   24ee2:	7f5b      	ldrb	r3, [r3, #29]
   24ee4:	2b00      	cmp	r3, #0
   24ee6:	f040 8098 	bne.w	2501a <nrfx_spi_xfer+0x16a>
        if (p_cb->handler)
   24eea:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24eee:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
   24ef2:	b12b      	cbz	r3, 24f00 <nrfx_spi_xfer+0x50>
            p_cb->transfer_in_progress = true;
   24ef4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   24ef8:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   24efc:	2201      	movs	r2, #1
   24efe:	775a      	strb	r2, [r3, #29]
    p_cb->evt.xfer_desc = *p_xfer_desc;
   24f00:	eb04 0c84 	add.w	ip, r4, r4, lsl #2
   24f04:	4b46      	ldr	r3, [pc, #280]	; (25020 <nrfx_spi_xfer+0x170>)
   24f06:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
   24f0a:	f10c 0e0c 	add.w	lr, ip, #12
   24f0e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   24f12:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
    p_cb->abort = false;
   24f16:	2300      	movs	r3, #0
   24f18:	f88c 3024 	strb.w	r3, [ip, #36]	; 0x24
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
   24f1c:	f89c 901e 	ldrb.w	r9, [ip, #30]
   24f20:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
   24f24:	d13c      	bne.n	24fa0 <nrfx_spi_xfer+0xf0>
    if (flags)
   24f26:	f1b8 0f00 	cmp.w	r8, #0
   24f2a:	d06f      	beq.n	2500c <nrfx_spi_xfer+0x15c>
        p_cb->transfer_in_progress = false;
   24f2c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   24f30:	4b3b      	ldr	r3, [pc, #236]	; (25020 <nrfx_spi_xfer+0x170>)
   24f32:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   24f36:	2300      	movs	r3, #0
   24f38:	7763      	strb	r3, [r4, #29]
        err_code = NRFX_ERROR_NOT_SUPPORTED;
   24f3a:	483a      	ldr	r0, [pc, #232]	; (25024 <nrfx_spi_xfer+0x174>)
}
   24f3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   24f40:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 25034 <nrfx_spi_xfer+0x184>
   24f44:	f44f 72b3 	mov.w	r2, #358	; 0x166
   24f48:	4649      	mov	r1, r9
   24f4a:	4837      	ldr	r0, [pc, #220]	; (25028 <nrfx_spi_xfer+0x178>)
   24f4c:	f007 faef 	bl	2c52e <assert_print>
   24f50:	f44f 71b3 	mov.w	r1, #358	; 0x166
   24f54:	4648      	mov	r0, r9
   24f56:	f007 fae3 	bl	2c520 <assert_post_action>
   24f5a:	e7b7      	b.n	24ecc <nrfx_spi_xfer+0x1c>
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   24f5c:	686b      	ldr	r3, [r5, #4]
   24f5e:	2b00      	cmp	r3, #0
   24f60:	d0b7      	beq.n	24ed2 <nrfx_spi_xfer+0x22>
   24f62:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 25034 <nrfx_spi_xfer+0x184>
   24f66:	f240 1267 	movw	r2, #359	; 0x167
   24f6a:	4649      	mov	r1, r9
   24f6c:	482e      	ldr	r0, [pc, #184]	; (25028 <nrfx_spi_xfer+0x178>)
   24f6e:	f007 fade 	bl	2c52e <assert_print>
   24f72:	f240 1167 	movw	r1, #359	; 0x167
   24f76:	4648      	mov	r0, r9
   24f78:	f007 fad2 	bl	2c520 <assert_post_action>
   24f7c:	e7a9      	b.n	24ed2 <nrfx_spi_xfer+0x22>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   24f7e:	68eb      	ldr	r3, [r5, #12]
   24f80:	2b00      	cmp	r3, #0
   24f82:	d0a9      	beq.n	24ed8 <nrfx_spi_xfer+0x28>
   24f84:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 25034 <nrfx_spi_xfer+0x184>
   24f88:	f44f 72b4 	mov.w	r2, #360	; 0x168
   24f8c:	4649      	mov	r1, r9
   24f8e:	4826      	ldr	r0, [pc, #152]	; (25028 <nrfx_spi_xfer+0x178>)
   24f90:	f007 facd 	bl	2c52e <assert_print>
   24f94:	f44f 71b4 	mov.w	r1, #360	; 0x168
   24f98:	4648      	mov	r0, r9
   24f9a:	f007 fac1 	bl	2c520 <assert_post_action>
   24f9e:	e79b      	b.n	24ed8 <nrfx_spi_xfer+0x28>
    switch (port)
   24fa0:	ea5f 1359 	movs.w	r3, r9, lsr #5
   24fa4:	d013      	beq.n	24fce <nrfx_spi_xfer+0x11e>
    uint32_t mask = 0;
   24fa6:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   24fa8:	f009 021f 	and.w	r2, r9, #31
    return (mask & (1UL << pin_number)) ? true : false;
   24fac:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24fae:	f013 0f01 	tst.w	r3, #1
   24fb2:	d00f      	beq.n	24fd4 <nrfx_spi_xfer+0x124>
    *p_pin = pin_number & 0x1F;
   24fb4:	f009 0a1f 	and.w	sl, r9, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   24fb8:	ea5f 1359 	movs.w	r3, r9, lsr #5
   24fbc:	d118      	bne.n	24ff0 <nrfx_spi_xfer+0x140>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   24fbe:	2301      	movs	r3, #1
   24fc0:	fa03 f30a 	lsl.w	r3, r3, sl
    p_reg->OUTCLR = clr_mask;
   24fc4:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   24fc8:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
   24fcc:	e7ab      	b.n	24f26 <nrfx_spi_xfer+0x76>
            mask = P0_FEATURE_PINS_PRESENT;
   24fce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24fd2:	e7e9      	b.n	24fa8 <nrfx_spi_xfer+0xf8>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   24fd4:	f8df a060 	ldr.w	sl, [pc, #96]	; 25038 <nrfx_spi_xfer+0x188>
   24fd8:	f240 2247 	movw	r2, #583	; 0x247
   24fdc:	4651      	mov	r1, sl
   24fde:	4812      	ldr	r0, [pc, #72]	; (25028 <nrfx_spi_xfer+0x178>)
   24fe0:	f007 faa5 	bl	2c52e <assert_print>
   24fe4:	f240 2147 	movw	r1, #583	; 0x247
   24fe8:	4650      	mov	r0, sl
   24fea:	f007 fa99 	bl	2c520 <assert_post_action>
   24fee:	e7e1      	b.n	24fb4 <nrfx_spi_xfer+0x104>
            NRFX_ASSERT(0);
   24ff0:	f8df 9044 	ldr.w	r9, [pc, #68]	; 25038 <nrfx_spi_xfer+0x188>
   24ff4:	f44f 7213 	mov.w	r2, #588	; 0x24c
   24ff8:	4649      	mov	r1, r9
   24ffa:	480b      	ldr	r0, [pc, #44]	; (25028 <nrfx_spi_xfer+0x178>)
   24ffc:	f007 fa97 	bl	2c52e <assert_print>
   25000:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25004:	4648      	mov	r0, r9
   25006:	f007 fa8b 	bl	2c520 <assert_post_action>
   2500a:	e7d8      	b.n	24fbe <nrfx_spi_xfer+0x10e>
        spi_xfer(p_instance->p_reg, p_cb, p_xfer_desc);
   2500c:	462a      	mov	r2, r5
   2500e:	4639      	mov	r1, r7
   25010:	6830      	ldr	r0, [r6, #0]
   25012:	f7ff fb87 	bl	24724 <spi_xfer>
    nrfx_err_t err_code = NRFX_SUCCESS;
   25016:	4805      	ldr	r0, [pc, #20]	; (2502c <nrfx_spi_xfer+0x17c>)
   25018:	e790      	b.n	24f3c <nrfx_spi_xfer+0x8c>
        return err_code;
   2501a:	4805      	ldr	r0, [pc, #20]	; (25030 <nrfx_spi_xfer+0x180>)
   2501c:	e78e      	b.n	24f3c <nrfx_spi_xfer+0x8c>
   2501e:	bf00      	nop
   25020:	20004620 	.word	0x20004620
   25024:	0bad0003 	.word	0x0bad0003
   25028:	00031600 	.word	0x00031600
   2502c:	0bad0000 	.word	0x0bad0000
   25030:	0bad000b 	.word	0x0bad000b
   25034:	0003bbf8 	.word	0x0003bbf8
   25038:	0003b084 	.word	0x0003b084

0002503c <nrfx_spi_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPI1_ENABLED)
void nrfx_spi_1_irq_handler(void)
{
   2503c:	b508      	push	{r3, lr}
    irq_handler(NRF_SPI1, &m_cb[NRFX_SPI1_INST_IDX]);
   2503e:	4903      	ldr	r1, [pc, #12]	; (2504c <nrfx_spi_1_irq_handler+0x10>)
   25040:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
   25044:	f7ff fb48 	bl	246d8 <irq_handler>
}
   25048:	bd08      	pop	{r3, pc}
   2504a:	bf00      	nop
   2504c:	20004620 	.word	0x20004620

00025050 <nrfx_spi_2_irq_handler>:
#endif

#if NRFX_CHECK(NRFX_SPI2_ENABLED)
void nrfx_spi_2_irq_handler(void)
{
   25050:	b508      	push	{r3, lr}
    irq_handler(NRF_SPI2, &m_cb[NRFX_SPI2_INST_IDX]);
   25052:	4902      	ldr	r1, [pc, #8]	; (2505c <nrfx_spi_2_irq_handler+0xc>)
   25054:	4802      	ldr	r0, [pc, #8]	; (25060 <nrfx_spi_2_irq_handler+0x10>)
   25056:	f7ff fb3f 	bl	246d8 <irq_handler>
}
   2505a:	bd08      	pop	{r3, pc}
   2505c:	20004648 	.word	0x20004648
   25060:	40023000 	.word	0x40023000

00025064 <twi_process_error>:
} twim_control_block_t;

static twim_control_block_t m_cb[NRFX_TWIM_ENABLED_COUNT];

static nrfx_err_t twi_process_error(uint32_t errorsrc)
{
   25064:	4603      	mov	r3, r0
    nrfx_err_t ret = NRFX_ERROR_INTERNAL;

    if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   25066:	f010 0f01 	tst.w	r0, #1
   2506a:	d108      	bne.n	2507e <twi_process_error+0x1a>
    nrfx_err_t ret = NRFX_ERROR_INTERNAL;
   2506c:	4806      	ldr	r0, [pc, #24]	; (25088 <twi_process_error+0x24>)
    {
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    }

    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   2506e:	f013 0f02 	tst.w	r3, #2
   25072:	d000      	beq.n	25076 <twi_process_error+0x12>
    {
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   25074:	4805      	ldr	r0, [pc, #20]	; (2508c <twi_process_error+0x28>)
    }

    if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   25076:	f013 0f04 	tst.w	r3, #4
   2507a:	d102      	bne.n	25082 <twi_process_error+0x1e>
    {
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    }

    return ret;
}
   2507c:	4770      	bx	lr
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   2507e:	4804      	ldr	r0, [pc, #16]	; (25090 <twi_process_error+0x2c>)
   25080:	e7f5      	b.n	2506e <twi_process_error+0xa>
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   25082:	4804      	ldr	r0, [pc, #16]	; (25094 <twi_process_error+0x30>)
    return ret;
   25084:	e7fa      	b.n	2507c <twi_process_error+0x18>
   25086:	bf00      	nop
   25088:	0bad0001 	.word	0x0bad0001
   2508c:	0bae0001 	.word	0x0bae0001
   25090:	0bae0000 	.word	0x0bae0000
   25094:	0bae0002 	.word	0x0bae0002

00025098 <twim_xfer>:
}
static nrfx_err_t twim_xfer(twim_control_block_t        * p_cb,
                            NRF_TWIM_Type               * p_twim,
                            nrfx_twim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
   25098:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2509c:	4605      	mov	r5, r0
   2509e:	460c      	mov	r4, r1
   250a0:	4616      	mov	r6, r2
   250a2:	461f      	mov	r7, r3
    nrfx_err_t err_code = NRFX_SUCCESS;
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    p_cb->error = false;
   250a4:	2300      	movs	r3, #0
   250a6:	f880 302e 	strb.w	r3, [r0, #46]	; 0x2e

    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   250aa:	6853      	ldr	r3, [r2, #4]
   250ac:	b133      	cbz	r3, 250bc <twim_xfer+0x24>
   250ae:	68d3      	ldr	r3, [r2, #12]
   250b0:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   250b4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   250b8:	f040 8164 	bne.w	25384 <twim_xfer+0x2ec>
    p_reg->INTENCLR = mask;
   250bc:	4bb6      	ldr	r3, [pc, #728]	; (25398 <twim_xfer+0x300>)
   250be:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    /* Block TWI interrupts to ensure that function is not interrupted by TWI interrupt. */
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    if (p_cb->busy)
   250c2:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   250c6:	f003 08ff 	and.w	r8, r3, #255	; 0xff
   250ca:	2b00      	cmp	r3, #0
   250cc:	d136      	bne.n	2513c <twim_xfer+0xa4>
        return err_code;
    }
    else
    {
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   250ce:	f017 0f14 	tst.w	r7, #20
   250d2:	bf0c      	ite	eq
   250d4:	2301      	moveq	r3, #1
   250d6:	2300      	movne	r3, #0
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   250d8:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    }

    p_cb->xfer_desc = *p_xfer_desc;
   250dc:	f105 0c0c 	add.w	ip, r5, #12
   250e0:	46b6      	mov	lr, r6
   250e2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   250e6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   250ea:	f8de 3000 	ldr.w	r3, [lr]
   250ee:	f8cc 3000 	str.w	r3, [ip]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   250f2:	f3c7 1300 	ubfx	r3, r7, #4, #1
   250f6:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
    p_cb->flags = flags;
   250fa:	622f      	str	r7, [r5, #32]
    nrf_twim_address_set(p_twim, p_xfer_desc->address);
   250fc:	7873      	ldrb	r3, [r6, #1]
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   250fe:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25102:	2300      	movs	r3, #0
   25104:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   25108:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
   2510c:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
   25110:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
   25114:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
   25118:	f8d4 2160 	ldr.w	r2, [r4, #352]	; 0x160
   2511c:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   25120:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_STOPPED);
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_ERROR);
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_LASTTX);
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_SUSPENDED);

    twim_list_enable_handle(p_twim, flags);
   25124:	4639      	mov	r1, r7
   25126:	4620      	mov	r0, r4
   25128:	f00b fb97 	bl	3085a <twim_list_enable_handle>
    switch (p_xfer_desc->type)
   2512c:	7833      	ldrb	r3, [r6, #0]
   2512e:	2b03      	cmp	r3, #3
   25130:	f200 80db 	bhi.w	252ea <twim_xfer+0x252>
   25134:	e8df f003 	tbb	[pc, r3]
   25138:	086ac788 	.word	0x086ac788
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   2513c:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   2513e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
        return err_code;
   25142:	f8df 925c 	ldr.w	r9, [pc, #604]	; 253a0 <twim_xfer+0x308>
   25146:	e0b4      	b.n	252b2 <twim_xfer+0x21a>
    {
    case NRFX_TWIM_XFER_TXTX:
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
   25148:	f017 0f10 	tst.w	r7, #16
   2514c:	d134      	bne.n	251b8 <twim_xfer+0x120>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
   2514e:	f017 0f08 	tst.w	r7, #8
   25152:	d13f      	bne.n	251d4 <twim_xfer+0x13c>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
   25154:	f017 0f04 	tst.w	r7, #4
   25158:	d14a      	bne.n	251f0 <twim_xfer+0x158>
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   2515a:	6933      	ldr	r3, [r6, #16]
   2515c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   25160:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   25164:	f040 8111 	bne.w	2538a <twim_xfer+0x2f2>
}

NRF_STATIC_INLINE void nrf_twim_shorts_set(NRF_TWIM_Type * p_reg,
                                           uint32_t mask)
{
    p_reg->SHORTS = mask;
   25168:	f44f 7380 	mov.w	r3, #256	; 0x100
   2516c:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
                             __func__,
                             NRFX_LOG_ERROR_STRING_GET(err_code));
            return err_code;
        }
        nrf_twim_shorts_set(p_twim, NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK);
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   25170:	68f2      	ldr	r2, [r6, #12]
   25172:	6873      	ldr	r3, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25174:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   25178:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2517c:	2300      	movs	r3, #0
   2517e:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   25182:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25186:	2301      	movs	r3, #1
   25188:	6223      	str	r3, [r4, #32]
   2518a:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2518c:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_TXSTARTED);
        nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_RESUME);
        nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_STARTTX);
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   25190:	2b00      	cmp	r3, #0
   25192:	d0fb      	beq.n	2518c <twim_xfer+0xf4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25194:	2300      	movs	r3, #0
   25196:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   2519a:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
        {}
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_TXSTARTED));
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_TXSTARTED);
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   2519e:	6932      	ldr	r2, [r6, #16]
   251a0:	68b3      	ldr	r3, [r6, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   251a2:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   251a6:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   251aa:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   251ae:	60ab      	str	r3, [r5, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   251b0:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   251b2:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 253a4 <twim_xfer+0x30c>
        break;
   251b6:	e05c      	b.n	25272 <twim_xfer+0x1da>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
   251b8:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 253a8 <twim_xfer+0x310>
   251bc:	f240 12dd 	movw	r2, #477	; 0x1dd
   251c0:	4649      	mov	r1, r9
   251c2:	4876      	ldr	r0, [pc, #472]	; (2539c <twim_xfer+0x304>)
   251c4:	f007 f9b3 	bl	2c52e <assert_print>
   251c8:	f240 11dd 	movw	r1, #477	; 0x1dd
   251cc:	4648      	mov	r0, r9
   251ce:	f007 f9a7 	bl	2c520 <assert_post_action>
   251d2:	e7bc      	b.n	2514e <twim_xfer+0xb6>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
   251d4:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 253a8 <twim_xfer+0x310>
   251d8:	f44f 72ef 	mov.w	r2, #478	; 0x1de
   251dc:	4649      	mov	r1, r9
   251de:	486f      	ldr	r0, [pc, #444]	; (2539c <twim_xfer+0x304>)
   251e0:	f007 f9a5 	bl	2c52e <assert_print>
   251e4:	f44f 71ef 	mov.w	r1, #478	; 0x1de
   251e8:	4648      	mov	r0, r9
   251ea:	f007 f999 	bl	2c520 <assert_post_action>
   251ee:	e7b1      	b.n	25154 <twim_xfer+0xbc>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
   251f0:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 253a8 <twim_xfer+0x310>
   251f4:	f240 12df 	movw	r2, #479	; 0x1df
   251f8:	4649      	mov	r1, r9
   251fa:	4868      	ldr	r0, [pc, #416]	; (2539c <twim_xfer+0x304>)
   251fc:	f007 f997 	bl	2c52e <assert_print>
   25200:	f240 11df 	movw	r1, #479	; 0x1df
   25204:	4648      	mov	r0, r9
   25206:	f007 f98b 	bl	2c520 <assert_post_action>
   2520a:	e7a6      	b.n	2515a <twim_xfer+0xc2>
    case NRFX_TWIM_XFER_TXRX:
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   2520c:	68f2      	ldr	r2, [r6, #12]
   2520e:	6873      	ldr	r3, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25210:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   25214:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   25218:	6933      	ldr	r3, [r6, #16]
   2521a:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
   2521e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   25222:	f040 80b5 	bne.w	25390 <twim_xfer+0x2f8>
            NRFX_LOG_WARNING("Function: %s, error code: %s.",
                             __func__,
                             NRFX_LOG_ERROR_STRING_GET(err_code));
            return err_code;
        }
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   25226:	68b2      	ldr	r2, [r6, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   25228:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   2522c:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   25230:	f44f 5384 	mov.w	r3, #4224	; 0x1080
   25234:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_shorts_set(p_twim, NRF_TWIM_SHORT_LASTTX_STARTRX_MASK |
                                    NRF_TWIM_SHORT_LASTRX_STOP_MASK);
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   25238:	2302      	movs	r3, #2
   2523a:	60ab      	str	r3, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2523c:	2301      	movs	r3, #1
   2523e:	6223      	str	r3, [r4, #32]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   25240:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   25242:	f8df 9160 	ldr.w	r9, [pc, #352]	; 253a4 <twim_xfer+0x30c>
}
   25246:	e014      	b.n	25272 <twim_xfer+0x1da>
        nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_RESUME);
        break;
    case NRFX_TWIM_XFER_TX:
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   25248:	68f2      	ldr	r2, [r6, #12]
   2524a:	6873      	ldr	r3, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2524c:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   25250:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   25254:	f017 0f20 	tst.w	r7, #32
   25258:	d02e      	beq.n	252b8 <twim_xfer+0x220>
    p_reg->SHORTS = mask;
   2525a:	f44f 7380 	mov.w	r3, #256	; 0x100
   2525e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        {
            nrf_twim_shorts_set(p_twim, NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK);
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   25262:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   25266:	60ab      	str	r3, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25268:	2301      	movs	r3, #1
   2526a:	6223      	str	r3, [r4, #32]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   2526c:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   2526e:	f8df 9134 	ldr.w	r9, [pc, #308]	; 253a4 <twim_xfer+0x30c>
    default:
        err_code = NRFX_ERROR_INVALID_PARAM;
        break;
    }

    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   25272:	f017 0f08 	tst.w	r7, #8
   25276:	d107      	bne.n	25288 <twim_xfer+0x1f0>
   25278:	7832      	ldrb	r2, [r6, #0]
   2527a:	2a03      	cmp	r2, #3
   2527c:	d004      	beq.n	25288 <twim_xfer+0x1f0>
   2527e:	2201      	movs	r2, #1
   25280:	50e2      	str	r2, [r4, r3]
    {
        nrf_twim_task_trigger(p_twim, start_task);
        if (p_xfer_desc->primary_length == 0)
   25282:	6873      	ldr	r3, [r6, #4]
   25284:	b903      	cbnz	r3, 25288 <twim_xfer+0x1f0>
   25286:	6162      	str	r2, [r4, #20]
        {
            nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_STOP);
        }
    }

    if (p_cb->handler)
   25288:	682b      	ldr	r3, [r5, #0]
   2528a:	b393      	cbz	r3, 252f2 <twim_xfer+0x25a>
    {
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   2528c:	f017 0f04 	tst.w	r7, #4
   25290:	d001      	beq.n	25296 <twim_xfer+0x1fe>
        {
            p_cb->int_mask = 0;
   25292:	2300      	movs	r3, #0
   25294:	60ab      	str	r3, [r5, #8]
        }

        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   25296:	f017 0f40 	tst.w	r7, #64	; 0x40
   2529a:	d103      	bne.n	252a4 <twim_xfer+0x20c>
        {
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   2529c:	68ab      	ldr	r3, [r5, #8]
   2529e:	f043 0302 	orr.w	r3, r3, #2
   252a2:	60ab      	str	r3, [r5, #8]
        }

        // Interrupts for ERROR are implicitly enabled, regardless of driver configuration.
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   252a4:	68ab      	ldr	r3, [r5, #8]
   252a6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   252aa:	60ab      	str	r3, [r5, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   252ac:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   252ae:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
                err_code = NRFX_ERROR_INTERNAL;
            }
        }
    }
    return err_code;
}
   252b2:	4648      	mov	r0, r9
   252b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    p_reg->SHORTS = mask;
   252b8:	f44f 7300 	mov.w	r3, #512	; 0x200
   252bc:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   252c0:	2302      	movs	r3, #2
   252c2:	60ab      	str	r3, [r5, #8]
   252c4:	e7d0      	b.n	25268 <twim_xfer+0x1d0>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   252c6:	68f2      	ldr	r2, [r6, #12]
   252c8:	6873      	ldr	r3, [r6, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   252ca:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   252ce:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   252d2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   252d6:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   252da:	2302      	movs	r3, #2
   252dc:	60ab      	str	r3, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   252de:	2301      	movs	r3, #1
   252e0:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   252e2:	2300      	movs	r3, #0
    nrfx_err_t err_code = NRFX_SUCCESS;
   252e4:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 253a4 <twim_xfer+0x30c>
}
   252e8:	e7c3      	b.n	25272 <twim_xfer+0x1da>
    switch (p_xfer_desc->type)
   252ea:	2308      	movs	r3, #8
   252ec:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 253ac <twim_xfer+0x314>
   252f0:	e7bf      	b.n	25272 <twim_xfer+0x1da>
        bool transmission_finished = false;
   252f2:	4643      	mov	r3, r8
   252f4:	e000      	b.n	252f8 <twim_xfer+0x260>
        } while (!transmission_finished);
   252f6:	bb6b      	cbnz	r3, 25354 <twim_xfer+0x2bc>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   252f8:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   252fc:	b102      	cbz	r2, 25300 <twim_xfer+0x268>
                transmission_finished = true;
   252fe:	2301      	movs	r3, #1
   25300:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   25304:	b12a      	cbz	r2, 25312 <twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25306:	2300      	movs	r3, #0
   25308:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   2530c:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   25310:	2301      	movs	r3, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25312:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   25316:	2a00      	cmp	r2, #0
   25318:	d0ed      	beq.n	252f6 <twim_xfer+0x25e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2531a:	2200      	movs	r2, #0
   2531c:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
   25320:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25324:	f8d4 2160 	ldr.w	r2, [r4, #352]	; 0x160
}

NRF_STATIC_INLINE uint32_t nrf_twim_shorts_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->SHORTS;
   25328:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   2532c:	b112      	cbz	r2, 25334 <twim_xfer+0x29c>
   2532e:	f411 7f00 	tst.w	r1, #512	; 0x200
   25332:	d103      	bne.n	2533c <twim_xfer+0x2a4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25334:	2301      	movs	r3, #1
   25336:	6223      	str	r3, [r4, #32]
   25338:	6163      	str	r3, [r4, #20]
                    transmission_finished = false;
   2533a:	4643      	mov	r3, r8
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   2533c:	2a00      	cmp	r2, #0
   2533e:	d0da      	beq.n	252f6 <twim_xfer+0x25e>
   25340:	f411 7f80 	tst.w	r1, #256	; 0x100
   25344:	d0d7      	beq.n	252f6 <twim_xfer+0x25e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25346:	2300      	movs	r3, #0
   25348:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   2534c:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   25350:	4643      	mov	r3, r8
   25352:	e7d1      	b.n	252f8 <twim_xfer+0x260>
    uint32_t error_source = p_reg->ERRORSRC;
   25354:	f8d4 04c4 	ldr.w	r0, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   25358:	f8c4 04c4 	str.w	r0, [r4, #1220]	; 0x4c4
        p_cb->busy = false;
   2535c:	2300      	movs	r3, #0
   2535e:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
        if (errorsrc)
   25362:	b118      	cbz	r0, 2536c <twim_xfer+0x2d4>
            err_code = twi_process_error(errorsrc);
   25364:	f7ff fe7e 	bl	25064 <twi_process_error>
   25368:	4681      	mov	r9, r0
   2536a:	e7a2      	b.n	252b2 <twim_xfer+0x21a>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   2536c:	f017 0f40 	tst.w	r7, #64	; 0x40
   25370:	d19f      	bne.n	252b2 <twim_xfer+0x21a>
                !xfer_completeness_check(p_twim, p_cb))
   25372:	4629      	mov	r1, r5
   25374:	4620      	mov	r0, r4
   25376:	f00b fa2f 	bl	307d8 <xfer_completeness_check>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   2537a:	2800      	cmp	r0, #0
   2537c:	d199      	bne.n	252b2 <twim_xfer+0x21a>
                err_code = NRFX_ERROR_INTERNAL;
   2537e:	f8df 9030 	ldr.w	r9, [pc, #48]	; 253b0 <twim_xfer+0x318>
   25382:	e796      	b.n	252b2 <twim_xfer+0x21a>
        return err_code;
   25384:	f8df 902c 	ldr.w	r9, [pc, #44]	; 253b4 <twim_xfer+0x31c>
   25388:	e793      	b.n	252b2 <twim_xfer+0x21a>
            return err_code;
   2538a:	f8df 9028 	ldr.w	r9, [pc, #40]	; 253b4 <twim_xfer+0x31c>
   2538e:	e790      	b.n	252b2 <twim_xfer+0x21a>
            return err_code;
   25390:	f8df 9020 	ldr.w	r9, [pc, #32]	; 253b4 <twim_xfer+0x31c>
   25394:	e78d      	b.n	252b2 <twim_xfer+0x21a>
   25396:	bf00      	nop
   25398:	019c0202 	.word	0x019c0202
   2539c:	00031600 	.word	0x00031600
   253a0:	0bad000b 	.word	0x0bad000b
   253a4:	0bad0000 	.word	0x0bad0000
   253a8:	0003bc34 	.word	0x0003bc34
   253ac:	0bad0004 	.word	0x0bad0004
   253b0:	0bad0001 	.word	0x0bad0001
   253b4:	0bad000a 	.word	0x0bad000a

000253b8 <twim_irq_handler>:
{
    return nrf_twim_event_address_get(p_instance->p_twim, NRF_TWIM_EVENT_STOPPED);
}

static void twim_irq_handler(NRF_TWIM_Type * p_twim, twim_control_block_t * p_cb)
{
   253b8:	b570      	push	{r4, r5, r6, lr}
   253ba:	b086      	sub	sp, #24
   253bc:	4604      	mov	r4, r0
   253be:	460d      	mov	r5, r1
            return;
        }
    }
#endif

    NRFX_ASSERT(p_cb->handler);
   253c0:	680b      	ldr	r3, [r1, #0]
   253c2:	2b00      	cmp	r3, #0
   253c4:	d06f      	beq.n	254a6 <twim_irq_handler+0xee>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   253c6:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124

    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   253ca:	b143      	cbz	r3, 253de <twim_irq_handler+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   253cc:	2300      	movs	r3, #0
   253ce:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
   253d2:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   253d6:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    {
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_ERROR);
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_ERROR));
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   253da:	2b00      	cmp	r3, #0
   253dc:	d070      	beq.n	254c0 <twim_irq_handler+0x108>
   253de:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
        }
    }

    nrfx_twim_evt_t event;

    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   253e2:	2b00      	cmp	r3, #0
   253e4:	f000 808c 	beq.w	25500 <twim_irq_handler+0x148>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   253e8:	2300      	movs	r3, #0
   253ea:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   253ee:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    {
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_STOPPED));
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_STOPPED);

        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   253f2:	6a2b      	ldr	r3, [r5, #32]
   253f4:	f013 0f40 	tst.w	r3, #64	; 0x40
   253f8:	d103      	bne.n	25402 <twim_irq_handler+0x4a>
   253fa:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   253fe:	2b00      	cmp	r3, #0
   25400:	d075      	beq.n	254ee <twim_irq_handler+0x136>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
        }

        // Further processing of STOPPED event is valid only if NO_XFER_EVT_HANDLER
        // setting is not used.
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   25402:	6a2b      	ldr	r3, [r5, #32]
   25404:	f013 0f04 	tst.w	r3, #4
   25408:	d130      	bne.n	2546c <twim_irq_handler+0xb4>
        {
            event.xfer_desc = p_cb->xfer_desc;
   2540a:	f10d 0c04 	add.w	ip, sp, #4
   2540e:	f105 0e0c 	add.w	lr, r5, #12
   25412:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   25416:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2541a:	f8de 3000 	ldr.w	r3, [lr]
   2541e:	f8cc 3000 	str.w	r3, [ip]
   25422:	2300      	movs	r3, #0
   25424:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
   25428:	f8d4 2160 	ldr.w	r2, [r4, #352]	; 0x160
   2542c:	f8c4 315c 	str.w	r3, [r4, #348]	; 0x15c
   25430:	f8d4 315c 	ldr.w	r3, [r4, #348]	; 0x15c
            nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_LASTTX);
            nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_LASTRX);
            if (!p_cb->repeated || p_cb->error)
   25434:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   25438:	b113      	cbz	r3, 25440 <twim_irq_handler+0x88>
   2543a:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   2543e:	b1ab      	cbz	r3, 2546c <twim_irq_handler+0xb4>
    p_reg->SHORTS = mask;
   25440:	2300      	movs	r3, #0
   25442:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            {
                nrf_twim_shorts_set(p_twim, 0);
                p_cb->int_mask = 0;
   25446:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   25448:	4b59      	ldr	r3, [pc, #356]	; (255b0 <twim_irq_handler+0x1f8>)
   2544a:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   2544e:	0b22      	lsrs	r2, r4, #12
   25450:	f344 3307 	sbfx	r3, r4, #12, #8
  if ((int32_t)(IRQn) >= 0)
   25454:	2b00      	cmp	r3, #0
   25456:	db09      	blt.n	2546c <twim_irq_handler+0xb4>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   25458:	f002 021f 	and.w	r2, r2, #31
   2545c:	095b      	lsrs	r3, r3, #5
   2545e:	2101      	movs	r1, #1
   25460:	fa01 f202 	lsl.w	r2, r1, r2
   25464:	3360      	adds	r3, #96	; 0x60
   25466:	4953      	ldr	r1, [pc, #332]	; (255b4 <twim_irq_handler+0x1fc>)
   25468:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    uint32_t error_source = p_reg->ERRORSRC;
   2546c:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   25470:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            return;
        }
    }

    uint32_t errorsrc = nrf_twim_errorsrc_get_and_clear(p_twim);
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   25474:	f013 0f02 	tst.w	r3, #2
   25478:	f000 8081 	beq.w	2557e <twim_irq_handler+0x1c6>
    {
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   2547c:	2301      	movs	r3, #1
   2547e:	f88d 3000 	strb.w	r3, [sp]
    {
        event.type = NRFX_TWIM_EVT_DONE;
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_DONE));
    }

    if (!p_cb->repeated)
   25482:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   25486:	b90b      	cbnz	r3, 2548c <twim_irq_handler+0xd4>
    {
        p_cb->busy = false;
   25488:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    }

    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   2548c:	6a2b      	ldr	r3, [r5, #32]
   2548e:	f013 0f04 	tst.w	r3, #4
   25492:	d002      	beq.n	2549a <twim_irq_handler+0xe2>
   25494:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   25498:	b11b      	cbz	r3, 254a2 <twim_irq_handler+0xea>
    {
        p_cb->handler(&event, p_cb->p_context);
   2549a:	682b      	ldr	r3, [r5, #0]
   2549c:	6869      	ldr	r1, [r5, #4]
   2549e:	4668      	mov	r0, sp
   254a0:	4798      	blx	r3
    }
}
   254a2:	b006      	add	sp, #24
   254a4:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_cb->handler);
   254a6:	4e44      	ldr	r6, [pc, #272]	; (255b8 <twim_irq_handler+0x200>)
   254a8:	f44f 7237 	mov.w	r2, #732	; 0x2dc
   254ac:	4631      	mov	r1, r6
   254ae:	4843      	ldr	r0, [pc, #268]	; (255bc <twim_irq_handler+0x204>)
   254b0:	f007 f83d 	bl	2c52e <assert_print>
   254b4:	f44f 7137 	mov.w	r1, #732	; 0x2dc
   254b8:	4630      	mov	r0, r6
   254ba:	f007 f831 	bl	2c520 <assert_post_action>
   254be:	e782      	b.n	253c6 <twim_irq_handler+0xe>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   254c0:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   254c2:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   254c6:	2302      	movs	r3, #2
   254c8:	60ab      	str	r3, [r5, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   254ca:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   254cc:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   254d0:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   254d4:	b123      	cbz	r3, 254e0 <twim_irq_handler+0x128>
    return p_reg->SHORTS;
   254d6:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
   254da:	f413 7f00 	tst.w	r3, #512	; 0x200
   254de:	d102      	bne.n	254e6 <twim_irq_handler+0x12e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   254e0:	2301      	movs	r3, #1
   254e2:	6223      	str	r3, [r4, #32]
   254e4:	6163      	str	r3, [r4, #20]
            p_cb->error = true;
   254e6:	2301      	movs	r3, #1
   254e8:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
            return;
   254ec:	e7d9      	b.n	254a2 <twim_irq_handler+0xea>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   254ee:	4629      	mov	r1, r5
   254f0:	4620      	mov	r0, r4
   254f2:	f00b f971 	bl	307d8 <xfer_completeness_check>
   254f6:	f080 0001 	eor.w	r0, r0, #1
   254fa:	f885 002e 	strb.w	r0, [r5, #46]	; 0x2e
   254fe:	e780      	b.n	25402 <twim_irq_handler+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25500:	2300      	movs	r3, #0
   25502:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   25506:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   2550a:	7b2b      	ldrb	r3, [r5, #12]
   2550c:	bb2b      	cbnz	r3, 2555a <twim_irq_handler+0x1a2>
            event.xfer_desc = p_cb->xfer_desc;
   2550e:	f10d 0c04 	add.w	ip, sp, #4
   25512:	f105 0e0c 	add.w	lr, r5, #12
   25516:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   2551a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2551e:	f8de 3000 	ldr.w	r3, [lr]
   25522:	f8cc 3000 	str.w	r3, [ip]
            if (!p_cb->repeated)
   25526:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   2552a:	2b00      	cmp	r3, #0
   2552c:	d19e      	bne.n	2546c <twim_irq_handler+0xb4>
    p_reg->SHORTS = mask;
   2552e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
                p_cb->int_mask = 0;
   25532:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   25534:	4b1e      	ldr	r3, [pc, #120]	; (255b0 <twim_irq_handler+0x1f8>)
   25536:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
   2553a:	0b22      	lsrs	r2, r4, #12
   2553c:	f344 3307 	sbfx	r3, r4, #12, #8
  if ((int32_t)(IRQn) >= 0)
   25540:	2b00      	cmp	r3, #0
   25542:	db93      	blt.n	2546c <twim_irq_handler+0xb4>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   25544:	f002 021f 	and.w	r2, r2, #31
   25548:	095b      	lsrs	r3, r3, #5
   2554a:	2101      	movs	r1, #1
   2554c:	fa01 f202 	lsl.w	r2, r1, r2
   25550:	3360      	adds	r3, #96	; 0x60
   25552:	4918      	ldr	r1, [pc, #96]	; (255b4 <twim_irq_handler+0x1fc>)
   25554:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   25558:	e788      	b.n	2546c <twim_irq_handler+0xb4>
    p_reg->SHORTS = mask;
   2555a:	f44f 7300 	mov.w	r3, #512	; 0x200
   2555e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   25562:	f240 2302 	movw	r3, #514	; 0x202
   25566:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   25568:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   2556c:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   25570:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   25572:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25576:	2301      	movs	r3, #1
   25578:	60a3      	str	r3, [r4, #8]
   2557a:	6223      	str	r3, [r4, #32]
            return;
   2557c:	e791      	b.n	254a2 <twim_irq_handler+0xea>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   2557e:	f013 0f04 	tst.w	r3, #4
   25582:	d003      	beq.n	2558c <twim_irq_handler+0x1d4>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   25584:	2302      	movs	r3, #2
   25586:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_DATA_NACK));
   2558a:	e77a      	b.n	25482 <twim_irq_handler+0xca>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   2558c:	f013 0f01 	tst.w	r3, #1
   25590:	d003      	beq.n	2559a <twim_irq_handler+0x1e2>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   25592:	2303      	movs	r3, #3
   25594:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_OVERRUN));
   25598:	e773      	b.n	25482 <twim_irq_handler+0xca>
    else if (p_cb->error)
   2559a:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   2559e:	b11b      	cbz	r3, 255a8 <twim_irq_handler+0x1f0>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   255a0:	2304      	movs	r3, #4
   255a2:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_BUS_ERROR));
   255a6:	e76c      	b.n	25482 <twim_irq_handler+0xca>
        event.type = NRFX_TWIM_EVT_DONE;
   255a8:	2300      	movs	r3, #0
   255aa:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_DONE));
   255ae:	e768      	b.n	25482 <twim_irq_handler+0xca>
   255b0:	019c0202 	.word	0x019c0202
   255b4:	e000e100 	.word	0xe000e100
   255b8:	0003bc34 	.word	0x0003bc34
   255bc:	00031600 	.word	0x00031600

000255c0 <twim_pins_configure>:
{
   255c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   255c2:	4605      	mov	r5, r0
   255c4:	460c      	mov	r4, r1
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   255c6:	7b8b      	ldrb	r3, [r1, #14]
   255c8:	b10b      	cbz	r3, 255ce <twim_pins_configure+0xe>
   255ca:	7bca      	ldrb	r2, [r1, #15]
   255cc:	b942      	cbnz	r2, 255e0 <twim_pins_configure+0x20>
    if (!p_config->skip_gpio_cfg)
   255ce:	b14b      	cbz	r3, 255e4 <twim_pins_configure+0x24>
    if (!p_config->skip_psel_cfg)
   255d0:	7be3      	ldrb	r3, [r4, #15]
   255d2:	b92b      	cbnz	r3, 255e0 <twim_pins_configure+0x20>
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   255d4:	6822      	ldr	r2, [r4, #0]
   255d6:	6863      	ldr	r3, [r4, #4]
    p_reg->PSEL.SCL = scl_pin;
   255d8:	f8c5 2508 	str.w	r2, [r5, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   255dc:	f8c5 350c 	str.w	r3, [r5, #1292]	; 0x50c
}
   255e0:	2001      	movs	r0, #1
   255e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        TWIM_PIN_INIT(p_config->scl, drive);
   255e4:	6826      	ldr	r6, [r4, #0]
    switch (port)
   255e6:	0973      	lsrs	r3, r6, #5
   255e8:	d029      	beq.n	2563e <twim_pins_configure+0x7e>
    uint32_t mask = 0;
   255ea:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   255ec:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   255f0:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   255f2:	f013 0f01 	tst.w	r3, #1
   255f6:	d025      	beq.n	25644 <twim_pins_configure+0x84>
    *p_pin = pin_number & 0x1F;
   255f8:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   255fc:	0973      	lsrs	r3, r6, #5
   255fe:	d12e      	bne.n	2565e <twim_pins_configure+0x9e>
    reg->PIN_CNF[pin_number] = cnf;
   25600:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   25604:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   25608:	f240 620c 	movw	r2, #1548	; 0x60c
   2560c:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
        TWIM_PIN_INIT(p_config->sda, drive);
   25610:	6866      	ldr	r6, [r4, #4]
    switch (port)
   25612:	0973      	lsrs	r3, r6, #5
   25614:	d030      	beq.n	25678 <twim_pins_configure+0xb8>
    uint32_t mask = 0;
   25616:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25618:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2561c:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2561e:	f013 0f01 	tst.w	r3, #1
   25622:	d02c      	beq.n	2567e <twim_pins_configure+0xbe>
    *p_pin = pin_number & 0x1F;
   25624:	f006 071f 	and.w	r7, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25628:	0973      	lsrs	r3, r6, #5
   2562a:	d135      	bne.n	25698 <twim_pins_configure+0xd8>
    reg->PIN_CNF[pin_number] = cnf;
   2562c:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
   25630:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   25634:	f240 620c 	movw	r2, #1548	; 0x60c
   25638:	f843 2027 	str.w	r2, [r3, r7, lsl #2]
   2563c:	e7c8      	b.n	255d0 <twim_pins_configure+0x10>
            mask = P0_FEATURE_PINS_PRESENT;
   2563e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25642:	e7d3      	b.n	255ec <twim_pins_configure+0x2c>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25644:	4f1b      	ldr	r7, [pc, #108]	; (256b4 <twim_pins_configure+0xf4>)
   25646:	f240 2247 	movw	r2, #583	; 0x247
   2564a:	4639      	mov	r1, r7
   2564c:	481a      	ldr	r0, [pc, #104]	; (256b8 <twim_pins_configure+0xf8>)
   2564e:	f006 ff6e 	bl	2c52e <assert_print>
   25652:	f240 2147 	movw	r1, #583	; 0x247
   25656:	4638      	mov	r0, r7
   25658:	f006 ff62 	bl	2c520 <assert_post_action>
   2565c:	e7cc      	b.n	255f8 <twim_pins_configure+0x38>
            NRFX_ASSERT(0);
   2565e:	4e15      	ldr	r6, [pc, #84]	; (256b4 <twim_pins_configure+0xf4>)
   25660:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25664:	4631      	mov	r1, r6
   25666:	4814      	ldr	r0, [pc, #80]	; (256b8 <twim_pins_configure+0xf8>)
   25668:	f006 ff61 	bl	2c52e <assert_print>
   2566c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25670:	4630      	mov	r0, r6
   25672:	f006 ff55 	bl	2c520 <assert_post_action>
   25676:	e7c3      	b.n	25600 <twim_pins_configure+0x40>
            mask = P0_FEATURE_PINS_PRESENT;
   25678:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2567c:	e7cc      	b.n	25618 <twim_pins_configure+0x58>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2567e:	4f0d      	ldr	r7, [pc, #52]	; (256b4 <twim_pins_configure+0xf4>)
   25680:	f240 2247 	movw	r2, #583	; 0x247
   25684:	4639      	mov	r1, r7
   25686:	480c      	ldr	r0, [pc, #48]	; (256b8 <twim_pins_configure+0xf8>)
   25688:	f006 ff51 	bl	2c52e <assert_print>
   2568c:	f240 2147 	movw	r1, #583	; 0x247
   25690:	4638      	mov	r0, r7
   25692:	f006 ff45 	bl	2c520 <assert_post_action>
   25696:	e7c5      	b.n	25624 <twim_pins_configure+0x64>
            NRFX_ASSERT(0);
   25698:	4e06      	ldr	r6, [pc, #24]	; (256b4 <twim_pins_configure+0xf4>)
   2569a:	f44f 7213 	mov.w	r2, #588	; 0x24c
   2569e:	4631      	mov	r1, r6
   256a0:	4805      	ldr	r0, [pc, #20]	; (256b8 <twim_pins_configure+0xf8>)
   256a2:	f006 ff44 	bl	2c52e <assert_print>
   256a6:	f44f 7113 	mov.w	r1, #588	; 0x24c
   256aa:	4630      	mov	r0, r6
   256ac:	f006 ff38 	bl	2c520 <assert_post_action>
   256b0:	e7bc      	b.n	2562c <twim_pins_configure+0x6c>
   256b2:	bf00      	nop
   256b4:	0003b084 	.word	0x0003b084
   256b8:	00031600 	.word	0x00031600

000256bc <nrfx_twim_init>:
{
   256bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   256c0:	4604      	mov	r4, r0
   256c2:	4616      	mov	r6, r2
   256c4:	461d      	mov	r5, r3
    NRFX_ASSERT(p_config);
   256c6:	4688      	mov	r8, r1
   256c8:	b161      	cbz	r1, 256e4 <nrfx_twim_init+0x28>
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   256ca:	7927      	ldrb	r7, [r4, #4]
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   256cc:	f8d4 9000 	ldr.w	r9, [r4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   256d0:	4925      	ldr	r1, [pc, #148]	; (25768 <nrfx_twim_init+0xac>)
   256d2:	2334      	movs	r3, #52	; 0x34
   256d4:	fb03 1107 	mla	r1, r3, r7, r1
   256d8:	f891 302d 	ldrb.w	r3, [r1, #45]	; 0x2d
   256dc:	b17b      	cbz	r3, 256fe <nrfx_twim_init+0x42>
        return err_code;
   256de:	4823      	ldr	r0, [pc, #140]	; (2576c <nrfx_twim_init+0xb0>)
}
   256e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    NRFX_ASSERT(p_config);
   256e4:	4f22      	ldr	r7, [pc, #136]	; (25770 <nrfx_twim_init+0xb4>)
   256e6:	f240 1215 	movw	r2, #277	; 0x115
   256ea:	4639      	mov	r1, r7
   256ec:	4821      	ldr	r0, [pc, #132]	; (25774 <nrfx_twim_init+0xb8>)
   256ee:	f006 ff1e 	bl	2c52e <assert_print>
   256f2:	f240 1115 	movw	r1, #277	; 0x115
   256f6:	4638      	mov	r0, r7
   256f8:	f006 ff12 	bl	2c520 <assert_post_action>
   256fc:	e7e5      	b.n	256ca <nrfx_twim_init+0xe>
    p_cb->handler         = event_handler;
   256fe:	491a      	ldr	r1, [pc, #104]	; (25768 <nrfx_twim_init+0xac>)
   25700:	2234      	movs	r2, #52	; 0x34
   25702:	fb07 f202 	mul.w	r2, r7, r2
   25706:	188b      	adds	r3, r1, r2
   25708:	508e      	str	r6, [r1, r2]
    p_cb->p_context       = p_context;
   2570a:	605d      	str	r5, [r3, #4]
    p_cb->int_mask        = 0;
   2570c:	2200      	movs	r2, #0
   2570e:	609a      	str	r2, [r3, #8]
    p_cb->repeated        = false;
   25710:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    p_cb->busy            = false;
   25714:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   25718:	f898 200d 	ldrb.w	r2, [r8, #13]
   2571c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   25720:	f898 200e 	ldrb.w	r2, [r8, #14]
   25724:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
    if (!twim_pins_configure(p_twim, p_config))
   25728:	4641      	mov	r1, r8
   2572a:	4648      	mov	r0, r9
   2572c:	f7ff ff48 	bl	255c0 <twim_pins_configure>
   25730:	b1b8      	cbz	r0, 25762 <nrfx_twim_init+0xa6>
    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
   25732:	f8d8 3008 	ldr.w	r3, [r8, #8]
    p_reg->FREQUENCY = frequency;
   25736:	f8c9 3524 	str.w	r3, [r9, #1316]	; 0x524
    if (p_cb->handler)
   2573a:	2334      	movs	r3, #52	; 0x34
   2573c:	fb07 f303 	mul.w	r3, r7, r3
   25740:	4a09      	ldr	r2, [pc, #36]	; (25768 <nrfx_twim_init+0xac>)
   25742:	58d3      	ldr	r3, [r2, r3]
   25744:	b123      	cbz	r3, 25750 <nrfx_twim_init+0x94>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   25746:	6820      	ldr	r0, [r4, #0]
   25748:	f340 3007 	sbfx	r0, r0, #12, #8
   2574c:	f7f2 fda4 	bl	18298 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   25750:	4b05      	ldr	r3, [pc, #20]	; (25768 <nrfx_twim_init+0xac>)
   25752:	2234      	movs	r2, #52	; 0x34
   25754:	fb02 3707 	mla	r7, r2, r7, r3
   25758:	2301      	movs	r3, #1
   2575a:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    return err_code;
   2575e:	4806      	ldr	r0, [pc, #24]	; (25778 <nrfx_twim_init+0xbc>)
   25760:	e7be      	b.n	256e0 <nrfx_twim_init+0x24>
        return NRFX_ERROR_INVALID_PARAM;
   25762:	4806      	ldr	r0, [pc, #24]	; (2577c <nrfx_twim_init+0xc0>)
   25764:	e7bc      	b.n	256e0 <nrfx_twim_init+0x24>
   25766:	bf00      	nop
   25768:	20004670 	.word	0x20004670
   2576c:	0bad0005 	.word	0x0bad0005
   25770:	0003bc34 	.word	0x0003bc34
   25774:	00031600 	.word	0x00031600
   25778:	0bad0000 	.word	0x0bad0000
   2577c:	0bad0004 	.word	0x0bad0004

00025780 <nrfx_twim_enable>:
{
   25780:	b570      	push	{r4, r5, r6, lr}
   25782:	4604      	mov	r4, r0
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   25784:	7905      	ldrb	r5, [r0, #4]
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   25786:	4b10      	ldr	r3, [pc, #64]	; (257c8 <nrfx_twim_enable+0x48>)
   25788:	2234      	movs	r2, #52	; 0x34
   2578a:	fb02 3305 	mla	r3, r2, r5, r3
   2578e:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   25792:	2b01      	cmp	r3, #1
   25794:	d10b      	bne.n	257ae <nrfx_twim_enable+0x2e>
    nrf_twim_enable(p_instance->p_twim);
   25796:	6823      	ldr	r3, [r4, #0]
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   25798:	2206      	movs	r2, #6
   2579a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   2579e:	4b0a      	ldr	r3, [pc, #40]	; (257c8 <nrfx_twim_enable+0x48>)
   257a0:	2234      	movs	r2, #52	; 0x34
   257a2:	fb02 3305 	mla	r3, r2, r5, r3
   257a6:	2202      	movs	r2, #2
   257a8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
}
   257ac:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   257ae:	4e07      	ldr	r6, [pc, #28]	; (257cc <nrfx_twim_enable+0x4c>)
   257b0:	f240 1279 	movw	r2, #377	; 0x179
   257b4:	4631      	mov	r1, r6
   257b6:	4806      	ldr	r0, [pc, #24]	; (257d0 <nrfx_twim_enable+0x50>)
   257b8:	f006 feb9 	bl	2c52e <assert_print>
   257bc:	f240 1179 	movw	r1, #377	; 0x179
   257c0:	4630      	mov	r0, r6
   257c2:	f006 fead 	bl	2c520 <assert_post_action>
   257c6:	e7e6      	b.n	25796 <nrfx_twim_enable+0x16>
   257c8:	20004670 	.word	0x20004670
   257cc:	0003bc34 	.word	0x0003bc34
   257d0:	00031600 	.word	0x00031600

000257d4 <nrfx_twim_disable>:
{
   257d4:	b570      	push	{r4, r5, r6, lr}
   257d6:	4604      	mov	r4, r0
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   257d8:	7905      	ldrb	r5, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   257da:	4b16      	ldr	r3, [pc, #88]	; (25834 <nrfx_twim_disable+0x60>)
   257dc:	2234      	movs	r2, #52	; 0x34
   257de:	fb02 3305 	mla	r3, r2, r5, r3
   257e2:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   257e6:	b1bb      	cbz	r3, 25818 <nrfx_twim_disable+0x44>
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   257e8:	6822      	ldr	r2, [r4, #0]
    p_cb->int_mask = 0;
   257ea:	4b12      	ldr	r3, [pc, #72]	; (25834 <nrfx_twim_disable+0x60>)
   257ec:	2134      	movs	r1, #52	; 0x34
   257ee:	fb01 3305 	mla	r3, r1, r5, r3
   257f2:	2100      	movs	r1, #0
   257f4:	6099      	str	r1, [r3, #8]
    p_reg->INTENCLR = mask;
   257f6:	4810      	ldr	r0, [pc, #64]	; (25838 <nrfx_twim_disable+0x64>)
   257f8:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   257fc:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
   25800:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
   25804:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   25808:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2580c:	2201      	movs	r2, #1
   2580e:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    p_cb->busy = false;
   25812:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
}
   25816:	bd70      	pop	{r4, r5, r6, pc}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   25818:	4e08      	ldr	r6, [pc, #32]	; (2583c <nrfx_twim_disable+0x68>)
   2581a:	f44f 72c2 	mov.w	r2, #388	; 0x184
   2581e:	4631      	mov	r1, r6
   25820:	4807      	ldr	r0, [pc, #28]	; (25840 <nrfx_twim_disable+0x6c>)
   25822:	f006 fe84 	bl	2c52e <assert_print>
   25826:	f44f 71c2 	mov.w	r1, #388	; 0x184
   2582a:	4630      	mov	r0, r6
   2582c:	f006 fe78 	bl	2c520 <assert_post_action>
   25830:	e7da      	b.n	257e8 <nrfx_twim_disable+0x14>
   25832:	bf00      	nop
   25834:	20004670 	.word	0x20004670
   25838:	019c0202 	.word	0x019c0202
   2583c:	0003bc34 	.word	0x0003bc34
   25840:	00031600 	.word	0x00031600

00025844 <nrfx_twim_xfer>:
{
   25844:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   25848:	4604      	mov	r4, r0
   2584a:	460d      	mov	r5, r1
   2584c:	4617      	mov	r7, r2
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   2584e:	7903      	ldrb	r3, [r0, #4]
   25850:	b92b      	cbnz	r3, 2585e <nrfx_twim_xfer+0x1a>
   25852:	684b      	ldr	r3, [r1, #4]
   25854:	2bff      	cmp	r3, #255	; 0xff
   25856:	d802      	bhi.n	2585e <nrfx_twim_xfer+0x1a>
   25858:	688b      	ldr	r3, [r1, #8]
   2585a:	2bff      	cmp	r3, #255	; 0xff
   2585c:	d90b      	bls.n	25876 <nrfx_twim_xfer+0x32>
   2585e:	4e22      	ldr	r6, [pc, #136]	; (258e8 <nrfx_twim_xfer+0xa4>)
   25860:	f240 2299 	movw	r2, #665	; 0x299
   25864:	4631      	mov	r1, r6
   25866:	4821      	ldr	r0, [pc, #132]	; (258ec <nrfx_twim_xfer+0xa8>)
   25868:	f006 fe61 	bl	2c52e <assert_print>
   2586c:	f240 2199 	movw	r1, #665	; 0x299
   25870:	4630      	mov	r0, r6
   25872:	f006 fe55 	bl	2c520 <assert_post_action>
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   25876:	7926      	ldrb	r6, [r4, #4]
   25878:	4b1d      	ldr	r3, [pc, #116]	; (258f0 <nrfx_twim_xfer+0xac>)
   2587a:	2134      	movs	r1, #52	; 0x34
   2587c:	fb06 f101 	mul.w	r1, r6, r1
   25880:	eb03 0801 	add.w	r8, r3, r1
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   25884:	585b      	ldr	r3, [r3, r1]
   25886:	b16b      	cbz	r3, 258a4 <nrfx_twim_xfer+0x60>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   25888:	2334      	movs	r3, #52	; 0x34
   2588a:	fb03 f606 	mul.w	r6, r3, r6
   2588e:	4b18      	ldr	r3, [pc, #96]	; (258f0 <nrfx_twim_xfer+0xac>)
   25890:	599b      	ldr	r3, [r3, r6]
   25892:	b1c3      	cbz	r3, 258c6 <nrfx_twim_xfer+0x82>
    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   25894:	463b      	mov	r3, r7
   25896:	462a      	mov	r2, r5
   25898:	6821      	ldr	r1, [r4, #0]
   2589a:	4640      	mov	r0, r8
   2589c:	f7ff fbfc 	bl	25098 <twim_xfer>
}
   258a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   258a4:	782b      	ldrb	r3, [r5, #0]
   258a6:	2b02      	cmp	r3, #2
   258a8:	d1ee      	bne.n	25888 <nrfx_twim_xfer+0x44>
   258aa:	f8df 903c 	ldr.w	r9, [pc, #60]	; 258e8 <nrfx_twim_xfer+0xa4>
   258ae:	f240 22a1 	movw	r2, #673	; 0x2a1
   258b2:	4649      	mov	r1, r9
   258b4:	480d      	ldr	r0, [pc, #52]	; (258ec <nrfx_twim_xfer+0xa8>)
   258b6:	f006 fe3a 	bl	2c52e <assert_print>
   258ba:	f240 21a1 	movw	r1, #673	; 0x2a1
   258be:	4648      	mov	r0, r9
   258c0:	f006 fe2e 	bl	2c520 <assert_post_action>
   258c4:	e7e0      	b.n	25888 <nrfx_twim_xfer+0x44>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   258c6:	782b      	ldrb	r3, [r5, #0]
   258c8:	2b03      	cmp	r3, #3
   258ca:	d1e3      	bne.n	25894 <nrfx_twim_xfer+0x50>
   258cc:	4e06      	ldr	r6, [pc, #24]	; (258e8 <nrfx_twim_xfer+0xa4>)
   258ce:	f240 22a2 	movw	r2, #674	; 0x2a2
   258d2:	4631      	mov	r1, r6
   258d4:	4805      	ldr	r0, [pc, #20]	; (258ec <nrfx_twim_xfer+0xa8>)
   258d6:	f006 fe2a 	bl	2c52e <assert_print>
   258da:	f240 21a2 	movw	r1, #674	; 0x2a2
   258de:	4630      	mov	r0, r6
   258e0:	f006 fe1e 	bl	2c520 <assert_post_action>
   258e4:	e7d6      	b.n	25894 <nrfx_twim_xfer+0x50>
   258e6:	bf00      	nop
   258e8:	0003bc34 	.word	0x0003bc34
   258ec:	00031600 	.word	0x00031600
   258f0:	20004670 	.word	0x20004670

000258f4 <nrfx_twim_0_irq_handler>:

#if NRFX_CHECK(NRFX_TWIM0_ENABLED)
void nrfx_twim_0_irq_handler(void)
{
   258f4:	b508      	push	{r3, lr}
    twim_irq_handler(NRF_TWIM0, &m_cb[NRFX_TWIM0_INST_IDX]);
   258f6:	4902      	ldr	r1, [pc, #8]	; (25900 <nrfx_twim_0_irq_handler+0xc>)
   258f8:	4802      	ldr	r0, [pc, #8]	; (25904 <nrfx_twim_0_irq_handler+0x10>)
   258fa:	f7ff fd5d 	bl	253b8 <twim_irq_handler>
}
   258fe:	bd08      	pop	{r3, pc}
   25900:	20004670 	.word	0x20004670
   25904:	40003000 	.word	0x40003000

00025908 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
   25908:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2590c:	4605      	mov	r5, r0
   2590e:	460e      	mov	r6, r1
    switch (port)
   25910:	0943      	lsrs	r3, r0, #5
   25912:	d052      	beq.n	259ba <nrfx_twi_twim_bus_recover+0xb2>
    uint32_t mask = 0;
   25914:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25916:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2591a:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2591c:	f013 0f01 	tst.w	r3, #1
   25920:	d04e      	beq.n	259c0 <nrfx_twi_twim_bus_recover+0xb8>
    *p_pin = pin_number & 0x1F;
   25922:	f005 041f 	and.w	r4, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25926:	096b      	lsrs	r3, r5, #5
   25928:	d157      	bne.n	259da <nrfx_twi_twim_bus_recover+0xd2>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   2592a:	2301      	movs	r3, #1
   2592c:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   2592e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   25932:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    switch (port)
   25936:	0973      	lsrs	r3, r6, #5
   25938:	d05c      	beq.n	259f4 <nrfx_twi_twim_bus_recover+0xec>
    uint32_t mask = 0;
   2593a:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   2593c:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25940:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25942:	f013 0f01 	tst.w	r3, #1
   25946:	d058      	beq.n	259fa <nrfx_twi_twim_bus_recover+0xf2>
    *p_pin = pin_number & 0x1F;
   25948:	f006 041f 	and.w	r4, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2594c:	0973      	lsrs	r3, r6, #5
   2594e:	d161      	bne.n	25a14 <nrfx_twi_twim_bus_recover+0x10c>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25950:	2301      	movs	r3, #1
   25952:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   25954:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   25958:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    switch (port)
   2595c:	096b      	lsrs	r3, r5, #5
   2595e:	d066      	beq.n	25a2e <nrfx_twi_twim_bus_recover+0x126>
    uint32_t mask = 0;
   25960:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25962:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25966:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25968:	f013 0f01 	tst.w	r3, #1
   2596c:	d062      	beq.n	25a34 <nrfx_twi_twim_bus_recover+0x12c>
    *p_pin = pin_number & 0x1F;
   2596e:	f005 041f 	and.w	r4, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25972:	096b      	lsrs	r3, r5, #5
   25974:	d16b      	bne.n	25a4e <nrfx_twi_twim_bus_recover+0x146>
    reg->PIN_CNF[pin_number] = cnf;
   25976:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
   2597a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   2597e:	f240 620d 	movw	r2, #1549	; 0x60d
   25982:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    switch (port)
   25986:	0973      	lsrs	r3, r6, #5
   25988:	d06e      	beq.n	25a68 <nrfx_twi_twim_bus_recover+0x160>
    uint32_t mask = 0;
   2598a:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   2598c:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25990:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25992:	f013 0f01 	tst.w	r3, #1
   25996:	d06a      	beq.n	25a6e <nrfx_twi_twim_bus_recover+0x166>
    *p_pin = pin_number & 0x1F;
   25998:	f006 041f 	and.w	r4, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   2599c:	0973      	lsrs	r3, r6, #5
   2599e:	d173      	bne.n	25a88 <nrfx_twi_twim_bus_recover+0x180>
    reg->PIN_CNF[pin_number] = cnf;
   259a0:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
   259a4:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   259a8:	f240 620d 	movw	r2, #1549	; 0x60d
   259ac:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    nrf_gpio_pin_set(scl_pin);
    nrf_gpio_pin_set(sda_pin);

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
   259b0:	2004      	movs	r0, #4
   259b2:	f00a fe70 	bl	30696 <nrfx_busy_wait>

    for (uint8_t i = 0; i < 9; i++)
   259b6:	2700      	movs	r7, #0
   259b8:	e0c6      	b.n	25b48 <nrfx_twi_twim_bus_recover+0x240>
            mask = P0_FEATURE_PINS_PRESENT;
   259ba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   259be:	e7aa      	b.n	25916 <nrfx_twi_twim_bus_recover+0xe>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   259c0:	4cc1      	ldr	r4, [pc, #772]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   259c2:	f240 2247 	movw	r2, #583	; 0x247
   259c6:	4621      	mov	r1, r4
   259c8:	48c0      	ldr	r0, [pc, #768]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   259ca:	f006 fdb0 	bl	2c52e <assert_print>
   259ce:	f240 2147 	movw	r1, #583	; 0x247
   259d2:	4620      	mov	r0, r4
   259d4:	f006 fda4 	bl	2c520 <assert_post_action>
   259d8:	e7a3      	b.n	25922 <nrfx_twi_twim_bus_recover+0x1a>
            NRFX_ASSERT(0);
   259da:	4fbb      	ldr	r7, [pc, #748]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   259dc:	f44f 7213 	mov.w	r2, #588	; 0x24c
   259e0:	4639      	mov	r1, r7
   259e2:	48ba      	ldr	r0, [pc, #744]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   259e4:	f006 fda3 	bl	2c52e <assert_print>
   259e8:	f44f 7113 	mov.w	r1, #588	; 0x24c
   259ec:	4638      	mov	r0, r7
   259ee:	f006 fd97 	bl	2c520 <assert_post_action>
   259f2:	e79a      	b.n	2592a <nrfx_twi_twim_bus_recover+0x22>
            mask = P0_FEATURE_PINS_PRESENT;
   259f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   259f8:	e7a0      	b.n	2593c <nrfx_twi_twim_bus_recover+0x34>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   259fa:	4cb3      	ldr	r4, [pc, #716]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   259fc:	f240 2247 	movw	r2, #583	; 0x247
   25a00:	4621      	mov	r1, r4
   25a02:	48b2      	ldr	r0, [pc, #712]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25a04:	f006 fd93 	bl	2c52e <assert_print>
   25a08:	f240 2147 	movw	r1, #583	; 0x247
   25a0c:	4620      	mov	r0, r4
   25a0e:	f006 fd87 	bl	2c520 <assert_post_action>
   25a12:	e799      	b.n	25948 <nrfx_twi_twim_bus_recover+0x40>
            NRFX_ASSERT(0);
   25a14:	4fac      	ldr	r7, [pc, #688]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25a16:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25a1a:	4639      	mov	r1, r7
   25a1c:	48ab      	ldr	r0, [pc, #684]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25a1e:	f006 fd86 	bl	2c52e <assert_print>
   25a22:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25a26:	4638      	mov	r0, r7
   25a28:	f006 fd7a 	bl	2c520 <assert_post_action>
   25a2c:	e790      	b.n	25950 <nrfx_twi_twim_bus_recover+0x48>
            mask = P0_FEATURE_PINS_PRESENT;
   25a2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25a32:	e796      	b.n	25962 <nrfx_twi_twim_bus_recover+0x5a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25a34:	4ca4      	ldr	r4, [pc, #656]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25a36:	f240 2247 	movw	r2, #583	; 0x247
   25a3a:	4621      	mov	r1, r4
   25a3c:	48a3      	ldr	r0, [pc, #652]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25a3e:	f006 fd76 	bl	2c52e <assert_print>
   25a42:	f240 2147 	movw	r1, #583	; 0x247
   25a46:	4620      	mov	r0, r4
   25a48:	f006 fd6a 	bl	2c520 <assert_post_action>
   25a4c:	e78f      	b.n	2596e <nrfx_twi_twim_bus_recover+0x66>
            NRFX_ASSERT(0);
   25a4e:	4f9e      	ldr	r7, [pc, #632]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25a50:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25a54:	4639      	mov	r1, r7
   25a56:	489d      	ldr	r0, [pc, #628]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25a58:	f006 fd69 	bl	2c52e <assert_print>
   25a5c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25a60:	4638      	mov	r0, r7
   25a62:	f006 fd5d 	bl	2c520 <assert_post_action>
   25a66:	e786      	b.n	25976 <nrfx_twi_twim_bus_recover+0x6e>
            mask = P0_FEATURE_PINS_PRESENT;
   25a68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25a6c:	e78e      	b.n	2598c <nrfx_twi_twim_bus_recover+0x84>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25a6e:	4c96      	ldr	r4, [pc, #600]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25a70:	f240 2247 	movw	r2, #583	; 0x247
   25a74:	4621      	mov	r1, r4
   25a76:	4895      	ldr	r0, [pc, #596]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25a78:	f006 fd59 	bl	2c52e <assert_print>
   25a7c:	f240 2147 	movw	r1, #583	; 0x247
   25a80:	4620      	mov	r0, r4
   25a82:	f006 fd4d 	bl	2c520 <assert_post_action>
   25a86:	e787      	b.n	25998 <nrfx_twi_twim_bus_recover+0x90>
            NRFX_ASSERT(0);
   25a88:	4f8f      	ldr	r7, [pc, #572]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25a8a:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25a8e:	4639      	mov	r1, r7
   25a90:	488e      	ldr	r0, [pc, #568]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25a92:	f006 fd4c 	bl	2c52e <assert_print>
   25a96:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25a9a:	4638      	mov	r0, r7
   25a9c:	f006 fd40 	bl	2c520 <assert_post_action>
   25aa0:	e77e      	b.n	259a0 <nrfx_twi_twim_bus_recover+0x98>
            mask = P0_FEATURE_PINS_PRESENT;
   25aa2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25aa6:	e054      	b.n	25b52 <nrfx_twi_twim_bus_recover+0x24a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25aa8:	4c87      	ldr	r4, [pc, #540]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25aaa:	f240 2247 	movw	r2, #583	; 0x247
   25aae:	4621      	mov	r1, r4
   25ab0:	4886      	ldr	r0, [pc, #536]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25ab2:	f006 fd3c 	bl	2c52e <assert_print>
   25ab6:	f240 2147 	movw	r1, #583	; 0x247
   25aba:	4620      	mov	r0, r4
   25abc:	f006 fd30 	bl	2c520 <assert_post_action>
   25ac0:	e04d      	b.n	25b5e <nrfx_twi_twim_bus_recover+0x256>
            NRFX_ASSERT(0);
   25ac2:	f8df 8204 	ldr.w	r8, [pc, #516]	; 25cc8 <nrfx_twi_twim_bus_recover+0x3c0>
   25ac6:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25aca:	4641      	mov	r1, r8
   25acc:	487f      	ldr	r0, [pc, #508]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25ace:	f006 fd2e 	bl	2c52e <assert_print>
   25ad2:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25ad6:	4640      	mov	r0, r8
   25ad8:	f006 fd22 	bl	2c520 <assert_post_action>
   25adc:	e043      	b.n	25b66 <nrfx_twi_twim_bus_recover+0x25e>
            mask = P0_FEATURE_PINS_PRESENT;
   25ade:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25ae2:	e04b      	b.n	25b7c <nrfx_twi_twim_bus_recover+0x274>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25ae4:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 25cc8 <nrfx_twi_twim_bus_recover+0x3c0>
   25ae8:	f240 2247 	movw	r2, #583	; 0x247
   25aec:	4641      	mov	r1, r8
   25aee:	4877      	ldr	r0, [pc, #476]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25af0:	f006 fd1d 	bl	2c52e <assert_print>
   25af4:	f240 2147 	movw	r1, #583	; 0x247
   25af8:	4640      	mov	r0, r8
   25afa:	f006 fd11 	bl	2c520 <assert_post_action>
   25afe:	e043      	b.n	25b88 <nrfx_twi_twim_bus_recover+0x280>
            NRFX_ASSERT(0);
   25b00:	f8df 91c4 	ldr.w	r9, [pc, #452]	; 25cc8 <nrfx_twi_twim_bus_recover+0x3c0>
   25b04:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25b08:	4649      	mov	r1, r9
   25b0a:	4870      	ldr	r0, [pc, #448]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25b0c:	f006 fd0f 	bl	2c52e <assert_print>
   25b10:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25b14:	4648      	mov	r0, r9
   25b16:	f006 fd03 	bl	2c520 <assert_post_action>
   25b1a:	e039      	b.n	25b90 <nrfx_twi_twim_bus_recover+0x288>
    pin_number &= 0x1F;
   25b1c:	f005 031f 	and.w	r3, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25b20:	fa24 f303 	lsr.w	r3, r4, r3
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25b24:	f013 0f01 	tst.w	r3, #1
   25b28:	d041      	beq.n	25bae <nrfx_twi_twim_bus_recover+0x2a6>
    *p_pin = pin_number & 0x1F;
   25b2a:	f005 041f 	and.w	r4, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25b2e:	096b      	lsrs	r3, r5, #5
   25b30:	d14a      	bne.n	25bc8 <nrfx_twi_twim_bus_recover+0x2c0>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25b32:	2301      	movs	r3, #1
   25b34:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   25b36:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   25b3a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
            nrf_gpio_pin_set(scl_pin);
            NRFX_DELAY_US(4);
   25b3e:	2004      	movs	r0, #4
   25b40:	f00a fda9 	bl	30696 <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   25b44:	3701      	adds	r7, #1
   25b46:	b2ff      	uxtb	r7, r7
   25b48:	2f08      	cmp	r7, #8
   25b4a:	d84b      	bhi.n	25be4 <nrfx_twi_twim_bus_recover+0x2dc>
    switch (port)
   25b4c:	0973      	lsrs	r3, r6, #5
   25b4e:	d0a8      	beq.n	25aa2 <nrfx_twi_twim_bus_recover+0x19a>
    uint32_t mask = 0;
   25b50:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25b52:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25b56:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25b58:	f013 0f01 	tst.w	r3, #1
   25b5c:	d0a4      	beq.n	25aa8 <nrfx_twi_twim_bus_recover+0x1a0>
    *p_pin = pin_number & 0x1F;
   25b5e:	f006 041f 	and.w	r4, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25b62:	0973      	lsrs	r3, r6, #5
   25b64:	d1ad      	bne.n	25ac2 <nrfx_twi_twim_bus_recover+0x1ba>
    return p_reg->IN;
   25b66:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   25b6a:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   25b6e:	40e3      	lsrs	r3, r4
        if (nrf_gpio_pin_read(sda_pin))
   25b70:	f013 0401 	ands.w	r4, r3, #1
   25b74:	d136      	bne.n	25be4 <nrfx_twi_twim_bus_recover+0x2dc>
    switch (port)
   25b76:	096b      	lsrs	r3, r5, #5
   25b78:	d0b1      	beq.n	25ade <nrfx_twi_twim_bus_recover+0x1d6>
    uint32_t mask = 0;
   25b7a:	4623      	mov	r3, r4
    pin_number &= 0x1F;
   25b7c:	f005 021f 	and.w	r2, r5, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25b80:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25b82:	f013 0f01 	tst.w	r3, #1
   25b86:	d0ad      	beq.n	25ae4 <nrfx_twi_twim_bus_recover+0x1dc>
    *p_pin = pin_number & 0x1F;
   25b88:	f005 081f 	and.w	r8, r5, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25b8c:	096b      	lsrs	r3, r5, #5
   25b8e:	d1b7      	bne.n	25b00 <nrfx_twi_twim_bus_recover+0x1f8>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   25b90:	2301      	movs	r3, #1
   25b92:	fa03 f308 	lsl.w	r3, r3, r8
    p_reg->OUTCLR = clr_mask;
   25b96:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   25b9a:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
            NRFX_DELAY_US(4);
   25b9e:	2004      	movs	r0, #4
   25ba0:	f00a fd79 	bl	30696 <nrfx_busy_wait>
    switch (port)
   25ba4:	096b      	lsrs	r3, r5, #5
   25ba6:	d1b9      	bne.n	25b1c <nrfx_twi_twim_bus_recover+0x214>
            mask = P0_FEATURE_PINS_PRESENT;
   25ba8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   25bac:	e7b6      	b.n	25b1c <nrfx_twi_twim_bus_recover+0x214>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25bae:	4c46      	ldr	r4, [pc, #280]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25bb0:	f240 2247 	movw	r2, #583	; 0x247
   25bb4:	4621      	mov	r1, r4
   25bb6:	4845      	ldr	r0, [pc, #276]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25bb8:	f006 fcb9 	bl	2c52e <assert_print>
   25bbc:	f240 2147 	movw	r1, #583	; 0x247
   25bc0:	4620      	mov	r0, r4
   25bc2:	f006 fcad 	bl	2c520 <assert_post_action>
   25bc6:	e7b0      	b.n	25b2a <nrfx_twi_twim_bus_recover+0x222>
            NRFX_ASSERT(0);
   25bc8:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 25cc8 <nrfx_twi_twim_bus_recover+0x3c0>
   25bcc:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25bd0:	4641      	mov	r1, r8
   25bd2:	483e      	ldr	r0, [pc, #248]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25bd4:	f006 fcab 	bl	2c52e <assert_print>
   25bd8:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25bdc:	4640      	mov	r0, r8
   25bde:	f006 fc9f 	bl	2c520 <assert_post_action>
   25be2:	e7a6      	b.n	25b32 <nrfx_twi_twim_bus_recover+0x22a>
    switch (port)
   25be4:	0973      	lsrs	r3, r6, #5
   25be6:	d041      	beq.n	25c6c <nrfx_twi_twim_bus_recover+0x364>
    uint32_t mask = 0;
   25be8:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25bea:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25bee:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25bf0:	f013 0f01 	tst.w	r3, #1
   25bf4:	d03d      	beq.n	25c72 <nrfx_twi_twim_bus_recover+0x36a>
    *p_pin = pin_number & 0x1F;
   25bf6:	f006 041f 	and.w	r4, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25bfa:	0973      	lsrs	r3, r6, #5
   25bfc:	d146      	bne.n	25c8c <nrfx_twi_twim_bus_recover+0x384>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   25bfe:	2301      	movs	r3, #1
   25c00:	40a3      	lsls	r3, r4
    p_reg->OUTCLR = clr_mask;
   25c02:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   25c06:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
   25c0a:	2004      	movs	r0, #4
   25c0c:	f00a fd43 	bl	30696 <nrfx_busy_wait>
    switch (port)
   25c10:	0973      	lsrs	r3, r6, #5
   25c12:	d048      	beq.n	25ca6 <nrfx_twi_twim_bus_recover+0x39e>
    uint32_t mask = 0;
   25c14:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25c16:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25c1a:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25c1c:	f013 0f01 	tst.w	r3, #1
   25c20:	d044      	beq.n	25cac <nrfx_twi_twim_bus_recover+0x3a4>
    *p_pin = pin_number & 0x1F;
   25c22:	f006 041f 	and.w	r4, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25c26:	0973      	lsrs	r3, r6, #5
   25c28:	d154      	bne.n	25cd4 <nrfx_twi_twim_bus_recover+0x3cc>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25c2a:	2301      	movs	r3, #1
   25c2c:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   25c2e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   25c32:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    nrf_gpio_pin_set(sda_pin);
    NRFX_DELAY_US(4);
   25c36:	2004      	movs	r0, #4
   25c38:	f00a fd2d 	bl	30696 <nrfx_busy_wait>
    switch (port)
   25c3c:	0973      	lsrs	r3, r6, #5
   25c3e:	d056      	beq.n	25cee <nrfx_twi_twim_bus_recover+0x3e6>
    uint32_t mask = 0;
   25c40:	2300      	movs	r3, #0
    pin_number &= 0x1F;
   25c42:	f006 021f 	and.w	r2, r6, #31
    return (mask & (1UL << pin_number)) ? true : false;
   25c46:	40d3      	lsrs	r3, r2
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25c48:	f013 0f01 	tst.w	r3, #1
   25c4c:	d052      	beq.n	25cf4 <nrfx_twi_twim_bus_recover+0x3ec>
    *p_pin = pin_number & 0x1F;
   25c4e:	f006 041f 	and.w	r4, r6, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   25c52:	0973      	lsrs	r3, r6, #5
   25c54:	d15b      	bne.n	25d0e <nrfx_twi_twim_bus_recover+0x406>
    return p_reg->IN;
   25c56:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
   25c5a:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   25c5e:	40e3      	lsrs	r3, r4

    if (nrf_gpio_pin_read(sda_pin))
   25c60:	f013 0f01 	tst.w	r3, #1
   25c64:	d060      	beq.n	25d28 <nrfx_twi_twim_bus_recover+0x420>
    {
        return NRFX_SUCCESS;
   25c66:	481a      	ldr	r0, [pc, #104]	; (25cd0 <nrfx_twi_twim_bus_recover+0x3c8>)
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
   25c68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            mask = P0_FEATURE_PINS_PRESENT;
   25c6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25c70:	e7bb      	b.n	25bea <nrfx_twi_twim_bus_recover+0x2e2>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25c72:	4c15      	ldr	r4, [pc, #84]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25c74:	f240 2247 	movw	r2, #583	; 0x247
   25c78:	4621      	mov	r1, r4
   25c7a:	4814      	ldr	r0, [pc, #80]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25c7c:	f006 fc57 	bl	2c52e <assert_print>
   25c80:	f240 2147 	movw	r1, #583	; 0x247
   25c84:	4620      	mov	r0, r4
   25c86:	f006 fc4b 	bl	2c520 <assert_post_action>
   25c8a:	e7b4      	b.n	25bf6 <nrfx_twi_twim_bus_recover+0x2ee>
            NRFX_ASSERT(0);
   25c8c:	4d0e      	ldr	r5, [pc, #56]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25c8e:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25c92:	4629      	mov	r1, r5
   25c94:	480d      	ldr	r0, [pc, #52]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25c96:	f006 fc4a 	bl	2c52e <assert_print>
   25c9a:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25c9e:	4628      	mov	r0, r5
   25ca0:	f006 fc3e 	bl	2c520 <assert_post_action>
   25ca4:	e7ab      	b.n	25bfe <nrfx_twi_twim_bus_recover+0x2f6>
            mask = P0_FEATURE_PINS_PRESENT;
   25ca6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25caa:	e7b4      	b.n	25c16 <nrfx_twi_twim_bus_recover+0x30e>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25cac:	4c06      	ldr	r4, [pc, #24]	; (25cc8 <nrfx_twi_twim_bus_recover+0x3c0>)
   25cae:	f240 2247 	movw	r2, #583	; 0x247
   25cb2:	4621      	mov	r1, r4
   25cb4:	4805      	ldr	r0, [pc, #20]	; (25ccc <nrfx_twi_twim_bus_recover+0x3c4>)
   25cb6:	f006 fc3a 	bl	2c52e <assert_print>
   25cba:	f240 2147 	movw	r1, #583	; 0x247
   25cbe:	4620      	mov	r0, r4
   25cc0:	f006 fc2e 	bl	2c520 <assert_post_action>
   25cc4:	e7ad      	b.n	25c22 <nrfx_twi_twim_bus_recover+0x31a>
   25cc6:	bf00      	nop
   25cc8:	0003b084 	.word	0x0003b084
   25ccc:	00031600 	.word	0x00031600
   25cd0:	0bad0000 	.word	0x0bad0000
            NRFX_ASSERT(0);
   25cd4:	4d15      	ldr	r5, [pc, #84]	; (25d2c <nrfx_twi_twim_bus_recover+0x424>)
   25cd6:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25cda:	4629      	mov	r1, r5
   25cdc:	4814      	ldr	r0, [pc, #80]	; (25d30 <nrfx_twi_twim_bus_recover+0x428>)
   25cde:	f006 fc26 	bl	2c52e <assert_print>
   25ce2:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25ce6:	4628      	mov	r0, r5
   25ce8:	f006 fc1a 	bl	2c520 <assert_post_action>
   25cec:	e79d      	b.n	25c2a <nrfx_twi_twim_bus_recover+0x322>
            mask = P0_FEATURE_PINS_PRESENT;
   25cee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25cf2:	e7a6      	b.n	25c42 <nrfx_twi_twim_bus_recover+0x33a>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   25cf4:	4c0d      	ldr	r4, [pc, #52]	; (25d2c <nrfx_twi_twim_bus_recover+0x424>)
   25cf6:	f240 2247 	movw	r2, #583	; 0x247
   25cfa:	4621      	mov	r1, r4
   25cfc:	480c      	ldr	r0, [pc, #48]	; (25d30 <nrfx_twi_twim_bus_recover+0x428>)
   25cfe:	f006 fc16 	bl	2c52e <assert_print>
   25d02:	f240 2147 	movw	r1, #583	; 0x247
   25d06:	4620      	mov	r0, r4
   25d08:	f006 fc0a 	bl	2c520 <assert_post_action>
   25d0c:	e79f      	b.n	25c4e <nrfx_twi_twim_bus_recover+0x346>
            NRFX_ASSERT(0);
   25d0e:	4d07      	ldr	r5, [pc, #28]	; (25d2c <nrfx_twi_twim_bus_recover+0x424>)
   25d10:	f44f 7213 	mov.w	r2, #588	; 0x24c
   25d14:	4629      	mov	r1, r5
   25d16:	4806      	ldr	r0, [pc, #24]	; (25d30 <nrfx_twi_twim_bus_recover+0x428>)
   25d18:	f006 fc09 	bl	2c52e <assert_print>
   25d1c:	f44f 7113 	mov.w	r1, #588	; 0x24c
   25d20:	4628      	mov	r0, r5
   25d22:	f006 fbfd 	bl	2c520 <assert_post_action>
   25d26:	e796      	b.n	25c56 <nrfx_twi_twim_bus_recover+0x34e>
        return NRFX_ERROR_INTERNAL;
   25d28:	4802      	ldr	r0, [pc, #8]	; (25d34 <nrfx_twi_twim_bus_recover+0x42c>)
   25d2a:	e79d      	b.n	25c68 <nrfx_twi_twim_bus_recover+0x360>
   25d2c:	0003b084 	.word	0x0003b084
   25d30:	00031600 	.word	0x00031600
   25d34:	0bad0001 	.word	0x0bad0001

00025d38 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	const struct device *dev = __device_start;
   25d38:	4b03      	ldr	r3, [pc, #12]	; (25d48 <z_device_state_init+0x10>)

	while (dev < __device_end) {
   25d3a:	e000      	b.n	25d3e <z_device_state_init+0x6>
		z_object_init(dev);
		++dev;
   25d3c:	331c      	adds	r3, #28
	while (dev < __device_end) {
   25d3e:	4a03      	ldr	r2, [pc, #12]	; (25d4c <z_device_state_init+0x14>)
   25d40:	4293      	cmp	r3, r2
   25d42:	d3fb      	bcc.n	25d3c <z_device_state_init+0x4>
	}
}
   25d44:	4770      	bx	lr
   25d46:	bf00      	nop
   25d48:	00030fd4 	.word	0x00030fd4
   25d4c:	000310ec 	.word	0x000310ec

00025d50 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
   25d50:	b570      	push	{r4, r5, r6, lr}
   25d52:	4606      	mov	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   25d54:	4b11      	ldr	r3, [pc, #68]	; (25d9c <z_sys_init_run_level+0x4c>)
   25d56:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   25d5a:	e009      	b.n	25d70 <z_sys_init_run_level+0x20>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
   25d5c:	4240      	negs	r0, r0
   25d5e:	e017      	b.n	25d90 <z_sys_init_run_level+0x40>
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
   25d60:	68eb      	ldr	r3, [r5, #12]
   25d62:	7018      	strb	r0, [r3, #0]
			}
			dev->state->initialized = true;
   25d64:	68ea      	ldr	r2, [r5, #12]
   25d66:	7853      	ldrb	r3, [r2, #1]
   25d68:	f043 0301 	orr.w	r3, r3, #1
   25d6c:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   25d6e:	3408      	adds	r4, #8
   25d70:	1c73      	adds	r3, r6, #1
   25d72:	4a0a      	ldr	r2, [pc, #40]	; (25d9c <z_sys_init_run_level+0x4c>)
   25d74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   25d78:	42a3      	cmp	r3, r4
   25d7a:	d90d      	bls.n	25d98 <z_sys_init_run_level+0x48>
		const struct device *dev = entry->dev;
   25d7c:	6865      	ldr	r5, [r4, #4]
		int rc = entry->init(dev);
   25d7e:	6823      	ldr	r3, [r4, #0]
   25d80:	4628      	mov	r0, r5
   25d82:	4798      	blx	r3
		if (dev != NULL) {
   25d84:	2d00      	cmp	r5, #0
   25d86:	d0f2      	beq.n	25d6e <z_sys_init_run_level+0x1e>
			if (rc != 0) {
   25d88:	2800      	cmp	r0, #0
   25d8a:	d0eb      	beq.n	25d64 <z_sys_init_run_level+0x14>
				if (rc < 0) {
   25d8c:	2800      	cmp	r0, #0
   25d8e:	dbe5      	blt.n	25d5c <z_sys_init_run_level+0xc>
				if (rc > UINT8_MAX) {
   25d90:	28ff      	cmp	r0, #255	; 0xff
   25d92:	dde5      	ble.n	25d60 <z_sys_init_run_level+0x10>
					rc = UINT8_MAX;
   25d94:	20ff      	movs	r0, #255	; 0xff
   25d96:	e7e3      	b.n	25d60 <z_sys_init_run_level+0x10>
		}
	}
}
   25d98:	bd70      	pop	{r4, r5, r6, pc}
   25d9a:	bf00      	nop
   25d9c:	0003bc70 	.word	0x0003bc70

00025da0 <z_device_get_all_static>:
#include <syscalls/device_is_ready_mrsh.c>
#endif /* CONFIG_USERSPACE */

size_t z_device_get_all_static(struct device const **devices)
{
	*devices = __device_start;
   25da0:	4a04      	ldr	r2, [pc, #16]	; (25db4 <z_device_get_all_static+0x14>)
   25da2:	6002      	str	r2, [r0, #0]
	return __device_end - __device_start;
   25da4:	4b04      	ldr	r3, [pc, #16]	; (25db8 <z_device_get_all_static+0x18>)
   25da6:	1a9b      	subs	r3, r3, r2
   25da8:	109b      	asrs	r3, r3, #2
}
   25daa:	4804      	ldr	r0, [pc, #16]	; (25dbc <z_device_get_all_static+0x1c>)
   25dac:	fb03 f000 	mul.w	r0, r3, r0
   25db0:	4770      	bx	lr
   25db2:	bf00      	nop
   25db4:	00030fd4 	.word	0x00030fd4
   25db8:	000310ec 	.word	0x000310ec
   25dbc:	b6db6db7 	.word	0xb6db6db7

00025dc0 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   25dc0:	4b01      	ldr	r3, [pc, #4]	; (25dc8 <z_impl_z_errno+0x8>)
   25dc2:	6898      	ldr	r0, [r3, #8]
}
   25dc4:	3070      	adds	r0, #112	; 0x70
   25dc6:	4770      	bx	lr
   25dc8:	200046a4 	.word	0x200046a4

00025dcc <reason_to_str>:
	return thread_name;
}

static const char *reason_to_str(unsigned int reason)
{
	switch (reason) {
   25dcc:	2804      	cmp	r0, #4
   25dce:	d80c      	bhi.n	25dea <reason_to_str+0x1e>
   25dd0:	e8df f000 	tbb	[pc, r0]
   25dd4:	07050d03 	.word	0x07050d03
   25dd8:	09          	.byte	0x09
   25dd9:	00          	.byte	0x00
   25dda:	4806      	ldr	r0, [pc, #24]	; (25df4 <reason_to_str+0x28>)
   25ddc:	4770      	bx	lr
	case K_ERR_CPU_EXCEPTION:
		return "CPU exception";
	case K_ERR_SPURIOUS_IRQ:
		return "Unhandled interrupt";
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
   25dde:	4806      	ldr	r0, [pc, #24]	; (25df8 <reason_to_str+0x2c>)
   25de0:	4770      	bx	lr
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
   25de2:	4806      	ldr	r0, [pc, #24]	; (25dfc <reason_to_str+0x30>)
   25de4:	4770      	bx	lr
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
   25de6:	4806      	ldr	r0, [pc, #24]	; (25e00 <reason_to_str+0x34>)
   25de8:	4770      	bx	lr
	default:
		return "Unknown error";
   25dea:	4806      	ldr	r0, [pc, #24]	; (25e04 <reason_to_str+0x38>)
   25dec:	4770      	bx	lr
		return "Unhandled interrupt";
   25dee:	4806      	ldr	r0, [pc, #24]	; (25e08 <reason_to_str+0x3c>)
	}
}
   25df0:	4770      	bx	lr
   25df2:	bf00      	nop
   25df4:	0003bcd8 	.word	0x0003bcd8
   25df8:	0003bcac 	.word	0x0003bcac
   25dfc:	0003bcbc 	.word	0x0003bcbc
   25e00:	0003bcc8 	.word	0x0003bcc8
   25e04:	0003bc88 	.word	0x0003bc88
   25e08:	0003bc98 	.word	0x0003bc98

00025e0c <thread_name_get>:
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   25e0c:	b130      	cbz	r0, 25e1c <thread_name_get+0x10>
{
   25e0e:	b508      	push	{r3, lr}
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   25e10:	f00a fd85 	bl	3091e <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   25e14:	b120      	cbz	r0, 25e20 <thread_name_get+0x14>
   25e16:	7803      	ldrb	r3, [r0, #0]
   25e18:	b123      	cbz	r3, 25e24 <thread_name_get+0x18>
}
   25e1a:	bd08      	pop	{r3, pc}
		thread_name = "unknown";
   25e1c:	4802      	ldr	r0, [pc, #8]	; (25e28 <thread_name_get+0x1c>)
}
   25e1e:	4770      	bx	lr
		thread_name = "unknown";
   25e20:	4801      	ldr	r0, [pc, #4]	; (25e28 <thread_name_get+0x1c>)
   25e22:	e7fa      	b.n	25e1a <thread_name_get+0xe>
   25e24:	4800      	ldr	r0, [pc, #0]	; (25e28 <thread_name_get+0x1c>)
	return thread_name;
   25e26:	e7f8      	b.n	25e1a <thread_name_get+0xe>
   25e28:	0003bce8 	.word	0x0003bce8

00025e2c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   25e2c:	b5f0      	push	{r4, r5, r6, r7, lr}
   25e2e:	b083      	sub	sp, #12
   25e30:	4604      	mov	r4, r0
   25e32:	460e      	mov	r6, r1
	__asm__ volatile(
   25e34:	f04f 0340 	mov.w	r3, #64	; 0x40
   25e38:	f3ef 8711 	mrs	r7, BASEPRI
   25e3c:	f383 8812 	msr	BASEPRI_MAX, r3
   25e40:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   25e44:	f002 ffce 	bl	28de4 <z_impl_z_current_get>
   25e48:	4605      	mov	r5, r0
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   25e4a:	4620      	mov	r0, r4
   25e4c:	f7ff ffbe 	bl	25dcc <reason_to_str>
   25e50:	4603      	mov	r3, r0
   25e52:	2200      	movs	r2, #0
   25e54:	9200      	str	r2, [sp, #0]
   25e56:	4622      	mov	r2, r4
   25e58:	2145      	movs	r1, #69	; 0x45
   25e5a:	4818      	ldr	r0, [pc, #96]	; (25ebc <z_fatal_error+0x90>)
   25e5c:	f006 fb76 	bl	2c54c <z_log_minimal_printk>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   25e60:	b11e      	cbz	r6, 25e6a <z_fatal_error+0x3e>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   25e62:	69f3      	ldr	r3, [r6, #28]
   25e64:	f3c3 0308 	ubfx	r3, r3, #0, #9
   25e68:	b9bb      	cbnz	r3, 25e9a <z_fatal_error+0x6e>
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   25e6a:	4628      	mov	r0, r5
   25e6c:	f7ff ffce 	bl	25e0c <thread_name_get>
   25e70:	4603      	mov	r3, r0
   25e72:	462a      	mov	r2, r5
   25e74:	2145      	movs	r1, #69	; 0x45
   25e76:	4812      	ldr	r0, [pc, #72]	; (25ec0 <z_fatal_error+0x94>)
   25e78:	f006 fb68 	bl	2c54c <z_log_minimal_printk>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
   25e7c:	4631      	mov	r1, r6
   25e7e:	4620      	mov	r0, r4
   25e80:	f7fc f9f4 	bl	2226c <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
   25e84:	2c04      	cmp	r4, #4
   25e86:	d00d      	beq.n	25ea4 <z_fatal_error+0x78>
	__asm__ volatile(
   25e88:	f387 8811 	msr	BASEPRI, r7
   25e8c:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   25e90:	4628      	mov	r0, r5
   25e92:	f7f2 ff19 	bl	18cc8 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   25e96:	b003      	add	sp, #12
   25e98:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("Fault during interrupt handling\n");
   25e9a:	2145      	movs	r1, #69	; 0x45
   25e9c:	4809      	ldr	r0, [pc, #36]	; (25ec4 <z_fatal_error+0x98>)
   25e9e:	f006 fb55 	bl	2c54c <z_log_minimal_printk>
   25ea2:	e7e2      	b.n	25e6a <z_fatal_error+0x3e>
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
   25ea4:	4c08      	ldr	r4, [pc, #32]	; (25ec8 <z_fatal_error+0x9c>)
   25ea6:	2293      	movs	r2, #147	; 0x93
   25ea8:	4621      	mov	r1, r4
   25eaa:	4808      	ldr	r0, [pc, #32]	; (25ecc <z_fatal_error+0xa0>)
   25eac:	f006 fb3f 	bl	2c52e <assert_print>
   25eb0:	2193      	movs	r1, #147	; 0x93
   25eb2:	4620      	mov	r0, r4
   25eb4:	f006 fb34 	bl	2c520 <assert_post_action>
   25eb8:	e7e6      	b.n	25e88 <z_fatal_error+0x5c>
   25eba:	bf00      	nop
   25ebc:	0003bcf0 	.word	0x0003bcf0
   25ec0:	0003bd48 	.word	0x0003bd48
   25ec4:	0003bd20 	.word	0x0003bd20
   25ec8:	0003bd68 	.word	0x0003bd68
   25ecc:	00031600 	.word	0x00031600

00025ed0 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
   25ed0:	b510      	push	{r4, lr}
   25ed2:	b086      	sub	sp, #24
	struct k_thread *thread = &z_idle_threads[i];
   25ed4:	4c11      	ldr	r4, [pc, #68]	; (25f1c <init_idle_thread+0x4c>)
   25ed6:	23d0      	movs	r3, #208	; 0xd0
   25ed8:	fb03 4400 	mla	r4, r3, r0, r4
	k_thread_stack_t *stack = z_idle_stacks[i];
   25edc:	eb00 0c40 	add.w	ip, r0, r0, lsl #1
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   25ee0:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   25ee4:	4b0e      	ldr	r3, [pc, #56]	; (25f20 <init_idle_thread+0x50>)
   25ee6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
	z_setup_new_thread(thread, stack,
   25eea:	2300      	movs	r3, #0
   25eec:	9305      	str	r3, [sp, #20]
   25eee:	2201      	movs	r2, #1
   25ef0:	9204      	str	r2, [sp, #16]
   25ef2:	220f      	movs	r2, #15
   25ef4:	9203      	str	r2, [sp, #12]
   25ef6:	9302      	str	r3, [sp, #8]
   25ef8:	9301      	str	r3, [sp, #4]
   25efa:	9000      	str	r0, [sp, #0]
   25efc:	4b09      	ldr	r3, [pc, #36]	; (25f24 <init_idle_thread+0x54>)
   25efe:	f44f 72a0 	mov.w	r2, #320	; 0x140
   25f02:	4909      	ldr	r1, [pc, #36]	; (25f28 <init_idle_thread+0x58>)
   25f04:	eb01 11cc 	add.w	r1, r1, ip, lsl #7
   25f08:	4620      	mov	r0, r4
   25f0a:	f000 fac5 	bl	26498 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   25f0e:	7b63      	ldrb	r3, [r4, #13]
   25f10:	f023 0304 	bic.w	r3, r3, #4
   25f14:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   25f16:	b006      	add	sp, #24
   25f18:	bd10      	pop	{r4, pc}
   25f1a:	bf00      	nop
   25f1c:	200025d0 	.word	0x200025d0
   25f20:	200046a4 	.word	0x200046a4
   25f24:	000266f5 	.word	0x000266f5
   25f28:	20006a00 	.word	0x20006a00

00025f2c <bg_thread_main>:
{
   25f2c:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   25f2e:	4b0a      	ldr	r3, [pc, #40]	; (25f58 <bg_thread_main+0x2c>)
   25f30:	2201      	movs	r2, #1
   25f32:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   25f34:	2002      	movs	r0, #2
   25f36:	f7ff ff0b 	bl	25d50 <z_sys_init_run_level>
	boot_banner();
   25f3a:	f004 fa41 	bl	2a3c0 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   25f3e:	2003      	movs	r0, #3
   25f40:	f7ff ff06 	bl	25d50 <z_sys_init_run_level>
	z_init_static_threads();
   25f44:	f000 fb40 	bl	265c8 <z_init_static_threads>
	main();
   25f48:	f7ef f922 	bl	15190 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   25f4c:	4a03      	ldr	r2, [pc, #12]	; (25f5c <bg_thread_main+0x30>)
   25f4e:	7b13      	ldrb	r3, [r2, #12]
   25f50:	f023 0301 	bic.w	r3, r3, #1
   25f54:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   25f56:	bd08      	pop	{r3, pc}
   25f58:	20004713 	.word	0x20004713
   25f5c:	200026a0 	.word	0x200026a0

00025f60 <switch_to_main_thread>:
	return stack_ptr;
}

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
   25f60:	b508      	push	{r3, lr}
   25f62:	4601      	mov	r1, r0
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   25f64:	4a01      	ldr	r2, [pc, #4]	; (25f6c <switch_to_main_thread+0xc>)
   25f66:	4802      	ldr	r0, [pc, #8]	; (25f70 <switch_to_main_thread+0x10>)
   25f68:	f7f2 fb58 	bl	1861c <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   25f6c:	00025f2d 	.word	0x00025f2d
   25f70:	200026a0 	.word	0x200026a0

00025f74 <z_bss_zero>:
{
   25f74:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
   25f76:	4803      	ldr	r0, [pc, #12]	; (25f84 <z_bss_zero+0x10>)
   25f78:	4a03      	ldr	r2, [pc, #12]	; (25f88 <z_bss_zero+0x14>)
   25f7a:	1a12      	subs	r2, r2, r0
   25f7c:	2100      	movs	r1, #0
   25f7e:	f00a fc8e 	bl	3089e <z_early_memset>
}
   25f82:	bd08      	pop	{r3, pc}
   25f84:	20001040 	.word	0x20001040
   25f88:	20004714 	.word	0x20004714

00025f8c <z_init_cpu>:
{
   25f8c:	b510      	push	{r4, lr}
   25f8e:	4604      	mov	r4, r0
	init_idle_thread(id);
   25f90:	f7ff ff9e 	bl	25ed0 <init_idle_thread>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
   25f94:	490b      	ldr	r1, [pc, #44]	; (25fc4 <z_init_cpu+0x38>)
   25f96:	23d0      	movs	r3, #208	; 0xd0
   25f98:	fb03 1104 	mla	r1, r3, r4, r1
   25f9c:	4a0a      	ldr	r2, [pc, #40]	; (25fc8 <z_init_cpu+0x3c>)
   25f9e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   25fa2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   25fa6:	60d9      	str	r1, [r3, #12]
	_kernel.cpus[id].id = id;
   25fa8:	751c      	strb	r4, [r3, #20]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   25faa:	eb04 1104 	add.w	r1, r4, r4, lsl #4
   25fae:	4b07      	ldr	r3, [pc, #28]	; (25fcc <z_init_cpu+0x40>)
   25fb0:	eb03 13c1 	add.w	r3, r3, r1, lsl #7
   25fb4:	f503 6308 	add.w	r3, r3, #2176	; 0x880
	_kernel.cpus[id].irq_stack =
   25fb8:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   25fbc:	eb02 0484 	add.w	r4, r2, r4, lsl #2
   25fc0:	6063      	str	r3, [r4, #4]
}
   25fc2:	bd10      	pop	{r4, pc}
   25fc4:	200025d0 	.word	0x200025d0
   25fc8:	200046a4 	.word	0x200046a4
   25fcc:	20006b80 	.word	0x20006b80

00025fd0 <prepare_multithreading>:
{
   25fd0:	b570      	push	{r4, r5, r6, lr}
   25fd2:	b086      	sub	sp, #24
	z_sched_init();
   25fd4:	f002 fd8a 	bl	28aec <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
   25fd8:	4d10      	ldr	r5, [pc, #64]	; (2601c <prepare_multithreading+0x4c>)
   25fda:	4b11      	ldr	r3, [pc, #68]	; (26020 <prepare_multithreading+0x50>)
   25fdc:	621d      	str	r5, [r3, #32]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   25fde:	4b11      	ldr	r3, [pc, #68]	; (26024 <prepare_multithreading+0x54>)
   25fe0:	9305      	str	r3, [sp, #20]
   25fe2:	2301      	movs	r3, #1
   25fe4:	9304      	str	r3, [sp, #16]
   25fe6:	2400      	movs	r4, #0
   25fe8:	9403      	str	r4, [sp, #12]
   25fea:	9402      	str	r4, [sp, #8]
   25fec:	9401      	str	r4, [sp, #4]
   25fee:	9400      	str	r4, [sp, #0]
   25ff0:	4b0d      	ldr	r3, [pc, #52]	; (26028 <prepare_multithreading+0x58>)
   25ff2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   25ff6:	490d      	ldr	r1, [pc, #52]	; (2602c <prepare_multithreading+0x5c>)
   25ff8:	4628      	mov	r0, r5
   25ffa:	f000 fa4d 	bl	26498 <z_setup_new_thread>
   25ffe:	4606      	mov	r6, r0
   26000:	7b6b      	ldrb	r3, [r5, #13]
   26002:	f023 0304 	bic.w	r3, r3, #4
   26006:	736b      	strb	r3, [r5, #13]
	z_ready_thread(&z_main_thread);
   26008:	4628      	mov	r0, r5
   2600a:	f002 f953 	bl	282b4 <z_ready_thread>
	z_init_cpu(0);
   2600e:	4620      	mov	r0, r4
   26010:	f7ff ffbc 	bl	25f8c <z_init_cpu>
}
   26014:	4630      	mov	r0, r6
   26016:	b006      	add	sp, #24
   26018:	bd70      	pop	{r4, r5, r6, pc}
   2601a:	bf00      	nop
   2601c:	200026a0 	.word	0x200026a0
   26020:	200046a4 	.word	0x200046a4
   26024:	0003bd8c 	.word	0x0003bd8c
   26028:	00025f2d 	.word	0x00025f2d
   2602c:	20006580 	.word	0x20006580

00026030 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   26030:	b500      	push	{lr}
   26032:	b0b5      	sub	sp, #212	; 0xd4
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
   26034:	4b1e      	ldr	r3, [pc, #120]	; (260b0 <z_cstart+0x80>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   26036:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   2603a:	4c1e      	ldr	r4, [pc, #120]	; (260b4 <z_cstart+0x84>)
   2603c:	6963      	ldr	r3, [r4, #20]
   2603e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   26042:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   26044:	23e0      	movs	r3, #224	; 0xe0
   26046:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
   2604a:	2320      	movs	r3, #32
   2604c:	77e3      	strb	r3, [r4, #31]
   2604e:	2500      	movs	r5, #0
   26050:	7625      	strb	r5, [r4, #24]
   26052:	7665      	strb	r5, [r4, #25]
   26054:	76a5      	strb	r5, [r4, #26]
   26056:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   2605a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2605c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   26060:	6263      	str	r3, [r4, #36]	; 0x24
   26062:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   26066:	f7f2 fd9b 	bl	18ba0 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   2606a:	f7f2 f88f 	bl	1818c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   2606e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   26072:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   26074:	62e3      	str	r3, [r4, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   26076:	f7f2 ff23 	bl	18ec0 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   2607a:	f7f2 fe3f 	bl	18cfc <z_arm_configure_static_mpu_regions>
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
   2607e:	2401      	movs	r4, #1
   26080:	f88d 400d 	strb.w	r4, [sp, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
   26084:	f88d 400c 	strb.w	r4, [sp, #12]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
   26088:	951d      	str	r5, [sp, #116]	; 0x74
	dummy_thread->stack_info.size = 0U;
   2608a:	951e      	str	r5, [sp, #120]	; 0x78
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
   2608c:	4668      	mov	r0, sp
   2608e:	f004 f97b 	bl	2a388 <k_thread_system_pool_assign>
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
   26092:	4b09      	ldr	r3, [pc, #36]	; (260b8 <z_cstart+0x88>)
   26094:	f8c3 d008 	str.w	sp, [r3, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   26098:	f7ff fe4e 	bl	25d38 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   2609c:	4628      	mov	r0, r5
   2609e:	f7ff fe57 	bl	25d50 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   260a2:	4620      	mov	r0, r4
   260a4:	f7ff fe54 	bl	25d50 <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
   260a8:	f7ff ff92 	bl	25fd0 <prepare_multithreading>
   260ac:	f7ff ff58 	bl	25f60 <switch_to_main_thread>
   260b0:	20007400 	.word	0x20007400
   260b4:	e000ed00 	.word	0xe000ed00
   260b8:	200046a4 	.word	0x200046a4

000260bc <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   260bc:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   260be:	4c0d      	ldr	r4, [pc, #52]	; (260f4 <statics_init+0x38>)
   260c0:	e008      	b.n	260d4 <statics_init+0x18>
   260c2:	4b0d      	ldr	r3, [pc, #52]	; (260f8 <statics_init+0x3c>)
   260c4:	429c      	cmp	r4, r3
   260c6:	d213      	bcs.n	260f0 <statics_init+0x34>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   260c8:	68a2      	ldr	r2, [r4, #8]
   260ca:	6861      	ldr	r1, [r4, #4]
   260cc:	4620      	mov	r0, r4
   260ce:	f00a fbee 	bl	308ae <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   260d2:	3418      	adds	r4, #24
   260d4:	4b08      	ldr	r3, [pc, #32]	; (260f8 <statics_init+0x3c>)
   260d6:	429c      	cmp	r4, r3
   260d8:	d9f3      	bls.n	260c2 <statics_init+0x6>
   260da:	4d08      	ldr	r5, [pc, #32]	; (260fc <statics_init+0x40>)
   260dc:	2218      	movs	r2, #24
   260de:	4629      	mov	r1, r5
   260e0:	4807      	ldr	r0, [pc, #28]	; (26100 <statics_init+0x44>)
   260e2:	f006 fa24 	bl	2c52e <assert_print>
   260e6:	2118      	movs	r1, #24
   260e8:	4628      	mov	r0, r5
   260ea:	f006 fa19 	bl	2c520 <assert_post_action>
   260ee:	e7e8      	b.n	260c2 <statics_init+0x6>
		}
	}
	return 0;
}
   260f0:	2000      	movs	r0, #0
   260f2:	bd38      	pop	{r3, r4, r5, pc}
   260f4:	20000ea0 	.word	0x20000ea0
   260f8:	20000eb8 	.word	0x20000eb8
   260fc:	0003bd98 	.word	0x0003bd98
   26100:	00031600 	.word	0x00031600

00026104 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   26104:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26108:	b085      	sub	sp, #20
   2610a:	4680      	mov	r8, r0
   2610c:	468b      	mov	fp, r1
   2610e:	9203      	str	r2, [sp, #12]
   26110:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
   26114:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   26116:	4648      	mov	r0, r9
   26118:	4621      	mov	r1, r4
   2611a:	f00a fd54 	bl	30bc6 <sys_clock_timeout_end_calc>
   2611e:	4607      	mov	r7, r0
   26120:	468a      	mov	sl, r1
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   26122:	f108 0614 	add.w	r6, r8, #20
	__asm__ volatile(
   26126:	f04f 0340 	mov.w	r3, #64	; 0x40
   2612a:	f3ef 8511 	mrs	r5, BASEPRI
   2612e:	f383 8812 	msr	BASEPRI_MAX, r3
   26132:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26136:	4630      	mov	r0, r6
   26138:	f000 fab4 	bl	266a4 <z_spin_lock_valid>
   2613c:	b160      	cbz	r0, 26158 <k_heap_aligned_alloc+0x54>
	z_spin_lock_set_owner(l);
   2613e:	4630      	mov	r0, r6
   26140:	f000 fad0 	bl	266e4 <z_spin_lock_set_owner>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   26144:	f3ef 8305 	mrs	r3, IPSR

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   26148:	b113      	cbz	r3, 26150 <k_heap_aligned_alloc+0x4c>
   2614a:	ea54 0309 	orrs.w	r3, r4, r9
   2614e:	d10d      	bne.n	2616c <k_heap_aligned_alloc+0x68>

	bool blocked_alloc = false;
   26150:	f04f 0900 	mov.w	r9, #0
	void *ret = NULL;
   26154:	464c      	mov	r4, r9

	while (ret == NULL) {
   26156:	e02b      	b.n	261b0 <k_heap_aligned_alloc+0xac>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26158:	228e      	movs	r2, #142	; 0x8e
   2615a:	4931      	ldr	r1, [pc, #196]	; (26220 <k_heap_aligned_alloc+0x11c>)
   2615c:	4831      	ldr	r0, [pc, #196]	; (26224 <k_heap_aligned_alloc+0x120>)
   2615e:	f006 f9e6 	bl	2c52e <assert_print>
   26162:	218e      	movs	r1, #142	; 0x8e
   26164:	482e      	ldr	r0, [pc, #184]	; (26220 <k_heap_aligned_alloc+0x11c>)
   26166:	f006 f9db 	bl	2c520 <assert_post_action>
   2616a:	e7e8      	b.n	2613e <k_heap_aligned_alloc+0x3a>
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2616c:	4c2e      	ldr	r4, [pc, #184]	; (26228 <k_heap_aligned_alloc+0x124>)
   2616e:	2249      	movs	r2, #73	; 0x49
   26170:	4621      	mov	r1, r4
   26172:	482c      	ldr	r0, [pc, #176]	; (26224 <k_heap_aligned_alloc+0x120>)
   26174:	f006 f9db 	bl	2c52e <assert_print>
   26178:	2149      	movs	r1, #73	; 0x49
   2617a:	4620      	mov	r0, r4
   2617c:	f006 f9d0 	bl	2c520 <assert_post_action>
   26180:	e7e6      	b.n	26150 <k_heap_aligned_alloc+0x4c>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   26182:	9000      	str	r0, [sp, #0]
   26184:	9101      	str	r1, [sp, #4]
   26186:	f108 020c 	add.w	r2, r8, #12
   2618a:	4629      	mov	r1, r5
   2618c:	4630      	mov	r0, r6
   2618e:	f002 fa21 	bl	285d4 <z_pend_curr>
   26192:	f04f 0340 	mov.w	r3, #64	; 0x40
   26196:	f3ef 8511 	mrs	r5, BASEPRI
   2619a:	f383 8812 	msr	BASEPRI_MAX, r3
   2619e:	f3bf 8f6f 	isb	sy
   261a2:	4630      	mov	r0, r6
   261a4:	f000 fa7e 	bl	266a4 <z_spin_lock_valid>
   261a8:	b1c8      	cbz	r0, 261de <k_heap_aligned_alloc+0xda>
	z_spin_lock_set_owner(l);
   261aa:	4630      	mov	r0, r6
   261ac:	f000 fa9a 	bl	266e4 <z_spin_lock_set_owner>
	while (ret == NULL) {
   261b0:	b9fc      	cbnz	r4, 261f2 <k_heap_aligned_alloc+0xee>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   261b2:	9a03      	ldr	r2, [sp, #12]
   261b4:	4659      	mov	r1, fp
   261b6:	4640      	mov	r0, r8
   261b8:	f7ef ffd8 	bl	1616c <sys_heap_aligned_alloc>
   261bc:	4604      	mov	r4, r0
		now = sys_clock_tick_get();
   261be:	f003 f9e9 	bl	29594 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   261c2:	b9b4      	cbnz	r4, 261f2 <k_heap_aligned_alloc+0xee>
		    (ret != NULL) || ((end - now) <= 0)) {
   261c4:	1a38      	subs	r0, r7, r0
   261c6:	eb6a 0101 	sbc.w	r1, sl, r1
   261ca:	2801      	cmp	r0, #1
   261cc:	f171 0300 	sbcs.w	r3, r1, #0
   261d0:	db0f      	blt.n	261f2 <k_heap_aligned_alloc+0xee>
		if (!blocked_alloc) {
   261d2:	f1b9 0f00 	cmp.w	r9, #0
   261d6:	d1d4      	bne.n	26182 <k_heap_aligned_alloc+0x7e>
			blocked_alloc = true;
   261d8:	f04f 0901 	mov.w	r9, #1
   261dc:	e7d1      	b.n	26182 <k_heap_aligned_alloc+0x7e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   261de:	228e      	movs	r2, #142	; 0x8e
   261e0:	490f      	ldr	r1, [pc, #60]	; (26220 <k_heap_aligned_alloc+0x11c>)
   261e2:	4810      	ldr	r0, [pc, #64]	; (26224 <k_heap_aligned_alloc+0x120>)
   261e4:	f006 f9a3 	bl	2c52e <assert_print>
   261e8:	218e      	movs	r1, #142	; 0x8e
   261ea:	480d      	ldr	r0, [pc, #52]	; (26220 <k_heap_aligned_alloc+0x11c>)
   261ec:	f006 f998 	bl	2c520 <assert_post_action>
   261f0:	e7db      	b.n	261aa <k_heap_aligned_alloc+0xa6>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   261f2:	4630      	mov	r0, r6
   261f4:	f000 fa66 	bl	266c4 <z_spin_unlock_valid>
   261f8:	b138      	cbz	r0, 2620a <k_heap_aligned_alloc+0x106>
	__asm__ volatile(
   261fa:	f385 8811 	msr	BASEPRI, r5
   261fe:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   26202:	4620      	mov	r0, r4
   26204:	b005      	add	sp, #20
   26206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2620a:	4e05      	ldr	r6, [pc, #20]	; (26220 <k_heap_aligned_alloc+0x11c>)
   2620c:	22b9      	movs	r2, #185	; 0xb9
   2620e:	4631      	mov	r1, r6
   26210:	4804      	ldr	r0, [pc, #16]	; (26224 <k_heap_aligned_alloc+0x120>)
   26212:	f006 f98c 	bl	2c52e <assert_print>
   26216:	21b9      	movs	r1, #185	; 0xb9
   26218:	4630      	mov	r0, r6
   2621a:	f006 f981 	bl	2c520 <assert_post_action>
   2621e:	e7ec      	b.n	261fa <k_heap_aligned_alloc+0xf6>
   26220:	000390f0 	.word	0x000390f0
   26224:	00031600 	.word	0x00031600
   26228:	0003bd98 	.word	0x0003bd98

0002622c <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   2622c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26230:	4604      	mov	r4, r0
   26232:	460e      	mov	r6, r1
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   26234:	f100 0514 	add.w	r5, r0, #20
	__asm__ volatile(
   26238:	f04f 0340 	mov.w	r3, #64	; 0x40
   2623c:	f3ef 8711 	mrs	r7, BASEPRI
   26240:	f383 8812 	msr	BASEPRI_MAX, r3
   26244:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26248:	4628      	mov	r0, r5
   2624a:	f000 fa2b 	bl	266a4 <z_spin_lock_valid>
   2624e:	b188      	cbz	r0, 26274 <k_heap_free+0x48>
	z_spin_lock_set_owner(l);
   26250:	4628      	mov	r0, r5
   26252:	f000 fa47 	bl	266e4 <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
   26256:	4631      	mov	r1, r6
   26258:	4620      	mov	r0, r4
   2625a:	f7ef ff49 	bl	160f0 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   2625e:	f104 000c 	add.w	r0, r4, #12
   26262:	f00a fc77 	bl	30b54 <z_unpend_all>
   26266:	b188      	cbz	r0, 2628c <k_heap_free+0x60>
		z_reschedule(&h->lock, key);
   26268:	4639      	mov	r1, r7
   2626a:	4628      	mov	r0, r5
   2626c:	f001 fd8e 	bl	27d8c <z_reschedule>
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   26270:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26274:	f8df 8040 	ldr.w	r8, [pc, #64]	; 262b8 <k_heap_free+0x8c>
   26278:	228e      	movs	r2, #142	; 0x8e
   2627a:	4641      	mov	r1, r8
   2627c:	480d      	ldr	r0, [pc, #52]	; (262b4 <k_heap_free+0x88>)
   2627e:	f006 f956 	bl	2c52e <assert_print>
   26282:	218e      	movs	r1, #142	; 0x8e
   26284:	4640      	mov	r0, r8
   26286:	f006 f94b 	bl	2c520 <assert_post_action>
   2628a:	e7e1      	b.n	26250 <k_heap_free+0x24>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2628c:	4628      	mov	r0, r5
   2628e:	f000 fa19 	bl	266c4 <z_spin_unlock_valid>
   26292:	b120      	cbz	r0, 2629e <k_heap_free+0x72>
	__asm__ volatile(
   26294:	f387 8811 	msr	BASEPRI, r7
   26298:	f3bf 8f6f 	isb	sy
   2629c:	e7e8      	b.n	26270 <k_heap_free+0x44>
   2629e:	4c06      	ldr	r4, [pc, #24]	; (262b8 <k_heap_free+0x8c>)
   262a0:	22b9      	movs	r2, #185	; 0xb9
   262a2:	4621      	mov	r1, r4
   262a4:	4803      	ldr	r0, [pc, #12]	; (262b4 <k_heap_free+0x88>)
   262a6:	f006 f942 	bl	2c52e <assert_print>
   262aa:	21b9      	movs	r1, #185	; 0xb9
   262ac:	4620      	mov	r0, r4
   262ae:	f006 f937 	bl	2c520 <assert_post_action>
   262b2:	e7ef      	b.n	26294 <k_heap_free+0x68>
   262b4:	00031600 	.word	0x00031600
   262b8:	000390f0 	.word	0x000390f0

000262bc <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
   262bc:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   262be:	4c0e      	ldr	r4, [pc, #56]	; (262f8 <init_mem_slab_module+0x3c>)
	int rc = 0;
   262c0:	2500      	movs	r5, #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   262c2:	e008      	b.n	262d6 <init_mem_slab_module+0x1a>
   262c4:	4b0d      	ldr	r3, [pc, #52]	; (262fc <init_mem_slab_module+0x40>)
   262c6:	429c      	cmp	r4, r3
   262c8:	d213      	bcs.n	262f2 <init_mem_slab_module+0x36>
		rc = create_free_list(slab);
   262ca:	4620      	mov	r0, r4
   262cc:	f00a faf7 	bl	308be <create_free_list>
		if (rc < 0) {
   262d0:	1e05      	subs	r5, r0, #0
   262d2:	db0e      	blt.n	262f2 <init_mem_slab_module+0x36>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   262d4:	3420      	adds	r4, #32
   262d6:	4b09      	ldr	r3, [pc, #36]	; (262fc <init_mem_slab_module+0x40>)
   262d8:	429c      	cmp	r4, r3
   262da:	d9f3      	bls.n	262c4 <init_mem_slab_module+0x8>
   262dc:	4e08      	ldr	r6, [pc, #32]	; (26300 <init_mem_slab_module+0x44>)
   262de:	223d      	movs	r2, #61	; 0x3d
   262e0:	4631      	mov	r1, r6
   262e2:	4808      	ldr	r0, [pc, #32]	; (26304 <init_mem_slab_module+0x48>)
   262e4:	f006 f923 	bl	2c52e <assert_print>
   262e8:	213d      	movs	r1, #61	; 0x3d
   262ea:	4630      	mov	r0, r6
   262ec:	f006 f918 	bl	2c520 <assert_post_action>
   262f0:	e7e8      	b.n	262c4 <init_mem_slab_module+0x8>
		z_object_init(slab);
	}

out:
	return rc;
}
   262f2:	4628      	mov	r0, r5
   262f4:	bd70      	pop	{r4, r5, r6, pc}
   262f6:	bf00      	nop
   262f8:	20000e40 	.word	0x20000e40
   262fc:	20000ea0 	.word	0x20000ea0
   26300:	0003bdbc 	.word	0x0003bdbc
   26304:	00031600 	.word	0x00031600

00026308 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   26308:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2630c:	b082      	sub	sp, #8
   2630e:	4604      	mov	r4, r0
   26310:	460e      	mov	r6, r1
   26312:	4690      	mov	r8, r2
   26314:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
   26316:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2631a:	f04f 0340 	mov.w	r3, #64	; 0x40
   2631e:	f3ef 8711 	mrs	r7, BASEPRI
   26322:	f383 8812 	msr	BASEPRI_MAX, r3
   26326:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2632a:	4628      	mov	r0, r5
   2632c:	f000 f9ba 	bl	266a4 <z_spin_lock_valid>
   26330:	b1c0      	cbz	r0, 26364 <k_mem_slab_alloc+0x5c>
	z_spin_lock_set_owner(l);
   26332:	4628      	mov	r0, r5
   26334:	f000 f9d6 	bl	266e4 <z_spin_lock_set_owner>
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   26338:	69a1      	ldr	r1, [r4, #24]
   2633a:	b1f9      	cbz	r1, 2637c <k_mem_slab_alloc+0x74>
		/* take a free block */
		*mem = slab->free_list;
   2633c:	6031      	str	r1, [r6, #0]
		slab->free_list = *(char **)(slab->free_list);
   2633e:	69a3      	ldr	r3, [r4, #24]
   26340:	681b      	ldr	r3, [r3, #0]
   26342:	61a3      	str	r3, [r4, #24]
		slab->num_used++;
   26344:	69e3      	ldr	r3, [r4, #28]
   26346:	3301      	adds	r3, #1
   26348:	61e3      	str	r3, [r4, #28]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   2634a:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2634c:	4628      	mov	r0, r5
   2634e:	f000 f9b9 	bl	266c4 <z_spin_unlock_valid>
   26352:	b360      	cbz	r0, 263ae <k_mem_slab_alloc+0xa6>
	__asm__ volatile(
   26354:	f387 8811 	msr	BASEPRI, r7
   26358:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
   2635c:	4620      	mov	r0, r4
   2635e:	b002      	add	sp, #8
   26360:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26364:	f8df a064 	ldr.w	sl, [pc, #100]	; 263cc <k_mem_slab_alloc+0xc4>
   26368:	228e      	movs	r2, #142	; 0x8e
   2636a:	4651      	mov	r1, sl
   2636c:	4815      	ldr	r0, [pc, #84]	; (263c4 <k_mem_slab_alloc+0xbc>)
   2636e:	f006 f8de 	bl	2c52e <assert_print>
   26372:	218e      	movs	r1, #142	; 0x8e
   26374:	4650      	mov	r0, sl
   26376:	f006 f8d3 	bl	2c520 <assert_post_action>
   2637a:	e7da      	b.n	26332 <k_mem_slab_alloc+0x2a>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   2637c:	ea59 0308 	orrs.w	r3, r9, r8
   26380:	d104      	bne.n	2638c <k_mem_slab_alloc+0x84>
		*mem = NULL;
   26382:	2300      	movs	r3, #0
   26384:	6033      	str	r3, [r6, #0]
		result = -ENOMEM;
   26386:	f06f 040b 	mvn.w	r4, #11
   2638a:	e7df      	b.n	2634c <k_mem_slab_alloc+0x44>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   2638c:	f8cd 8000 	str.w	r8, [sp]
   26390:	f8cd 9004 	str.w	r9, [sp, #4]
   26394:	4622      	mov	r2, r4
   26396:	4639      	mov	r1, r7
   26398:	4628      	mov	r0, r5
   2639a:	f002 f91b 	bl	285d4 <z_pend_curr>
		if (result == 0) {
   2639e:	4604      	mov	r4, r0
   263a0:	2800      	cmp	r0, #0
   263a2:	d1db      	bne.n	2635c <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
   263a4:	4b08      	ldr	r3, [pc, #32]	; (263c8 <k_mem_slab_alloc+0xc0>)
   263a6:	689b      	ldr	r3, [r3, #8]
   263a8:	695b      	ldr	r3, [r3, #20]
   263aa:	6033      	str	r3, [r6, #0]
		return result;
   263ac:	e7d6      	b.n	2635c <k_mem_slab_alloc+0x54>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   263ae:	4d07      	ldr	r5, [pc, #28]	; (263cc <k_mem_slab_alloc+0xc4>)
   263b0:	22b9      	movs	r2, #185	; 0xb9
   263b2:	4629      	mov	r1, r5
   263b4:	4803      	ldr	r0, [pc, #12]	; (263c4 <k_mem_slab_alloc+0xbc>)
   263b6:	f006 f8ba 	bl	2c52e <assert_print>
   263ba:	21b9      	movs	r1, #185	; 0xb9
   263bc:	4628      	mov	r0, r5
   263be:	f006 f8af 	bl	2c520 <assert_post_action>
   263c2:	e7c7      	b.n	26354 <k_mem_slab_alloc+0x4c>
   263c4:	00031600 	.word	0x00031600
   263c8:	200046a4 	.word	0x200046a4
   263cc:	000390f0 	.word	0x000390f0

000263d0 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   263d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   263d4:	4604      	mov	r4, r0
   263d6:	460d      	mov	r5, r1
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
   263d8:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   263dc:	f04f 0340 	mov.w	r3, #64	; 0x40
   263e0:	f3ef 8711 	mrs	r7, BASEPRI
   263e4:	f383 8812 	msr	BASEPRI_MAX, r3
   263e8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   263ec:	4630      	mov	r0, r6
   263ee:	f000 f959 	bl	266a4 <z_spin_lock_valid>
   263f2:	b1b0      	cbz	r0, 26422 <k_mem_slab_free+0x52>
	z_spin_lock_set_owner(l);
   263f4:	4630      	mov	r0, r6
   263f6:	f000 f975 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   263fa:	69a3      	ldr	r3, [r4, #24]
   263fc:	b1eb      	cbz	r3, 2643a <k_mem_slab_free+0x6a>
			z_ready_thread(pending_thread);
			z_reschedule(&slab->lock, key);
			return;
		}
	}
	**(char ***) mem = slab->free_list;
   263fe:	682b      	ldr	r3, [r5, #0]
   26400:	69a2      	ldr	r2, [r4, #24]
   26402:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   26404:	682b      	ldr	r3, [r5, #0]
   26406:	61a3      	str	r3, [r4, #24]
	slab->num_used--;
   26408:	69e3      	ldr	r3, [r4, #28]
   2640a:	3b01      	subs	r3, #1
   2640c:	61e3      	str	r3, [r4, #28]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2640e:	4630      	mov	r0, r6
   26410:	f000 f958 	bl	266c4 <z_spin_unlock_valid>
   26414:	b310      	cbz	r0, 2645c <k_mem_slab_free+0x8c>
	__asm__ volatile(
   26416:	f387 8811 	msr	BASEPRI, r7
   2641a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   2641e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26422:	f8df 8054 	ldr.w	r8, [pc, #84]	; 26478 <k_mem_slab_free+0xa8>
   26426:	228e      	movs	r2, #142	; 0x8e
   26428:	4641      	mov	r1, r8
   2642a:	4812      	ldr	r0, [pc, #72]	; (26474 <k_mem_slab_free+0xa4>)
   2642c:	f006 f87f 	bl	2c52e <assert_print>
   26430:	218e      	movs	r1, #142	; 0x8e
   26432:	4640      	mov	r0, r8
   26434:	f006 f874 	bl	2c520 <assert_post_action>
   26438:	e7dc      	b.n	263f4 <k_mem_slab_free+0x24>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   2643a:	4620      	mov	r0, r4
   2643c:	f002 fb04 	bl	28a48 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   26440:	2800      	cmp	r0, #0
   26442:	d0dc      	beq.n	263fe <k_mem_slab_free+0x2e>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   26444:	682a      	ldr	r2, [r5, #0]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   26446:	2100      	movs	r1, #0
   26448:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   2644c:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   2644e:	f001 ff31 	bl	282b4 <z_ready_thread>
			z_reschedule(&slab->lock, key);
   26452:	4639      	mov	r1, r7
   26454:	4630      	mov	r0, r6
   26456:	f001 fc99 	bl	27d8c <z_reschedule>
			return;
   2645a:	e7e0      	b.n	2641e <k_mem_slab_free+0x4e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2645c:	4c06      	ldr	r4, [pc, #24]	; (26478 <k_mem_slab_free+0xa8>)
   2645e:	22b9      	movs	r2, #185	; 0xb9
   26460:	4621      	mov	r1, r4
   26462:	4804      	ldr	r0, [pc, #16]	; (26474 <k_mem_slab_free+0xa4>)
   26464:	f006 f863 	bl	2c52e <assert_print>
   26468:	21b9      	movs	r1, #185	; 0xb9
   2646a:	4620      	mov	r0, r4
   2646c:	f006 f858 	bl	2c520 <assert_post_action>
   26470:	e7d1      	b.n	26416 <k_mem_slab_free+0x46>
   26472:	bf00      	nop
   26474:	00031600 	.word	0x00031600
   26478:	000390f0 	.word	0x000390f0

0002647c <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
   2647c:	b508      	push	{r3, lr}
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2647e:	ea53 0102 	orrs.w	r1, r3, r2
   26482:	d102      	bne.n	2648a <schedule_new_thread+0xe>
	z_impl_k_thread_start(thread);
   26484:	f00a fa4d 	bl	30922 <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
   26488:	bd08      	pop	{r3, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   2648a:	4902      	ldr	r1, [pc, #8]	; (26494 <schedule_new_thread+0x18>)
   2648c:	3018      	adds	r0, #24
   2648e:	f002 fe2d 	bl	290ec <z_add_timeout>
   26492:	e7f9      	b.n	26488 <schedule_new_thread+0xc>
   26494:	000283c9 	.word	0x000283c9

00026498 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   26498:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2649c:	b085      	sub	sp, #20
   2649e:	4604      	mov	r4, r0
   264a0:	460e      	mov	r6, r1
   264a2:	4615      	mov	r5, r2
   264a4:	461f      	mov	r7, r3
   264a6:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
	char *stack_ptr;

	Z_ASSERT_VALID_PRIO(prio, entry);
   264aa:	f1b8 0f0f 	cmp.w	r8, #15
   264ae:	d02c      	beq.n	2650a <z_setup_new_thread+0x72>
   264b0:	f108 0310 	add.w	r3, r8, #16
   264b4:	2b1e      	cmp	r3, #30
   264b6:	d82c      	bhi.n	26512 <z_setup_new_thread+0x7a>
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   264b8:	f104 0358 	add.w	r3, r4, #88	; 0x58
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   264bc:	65a3      	str	r3, [r4, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
   264be:	65e3      	str	r3, [r4, #92]	; 0x5c
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->join_queue);

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
   264c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
   264c2:	2204      	movs	r2, #4
   264c4:	4641      	mov	r1, r8
   264c6:	4620      	mov	r0, r4
   264c8:	f00a fa2f 	bl	3092a <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
   264cc:	462a      	mov	r2, r5
   264ce:	4631      	mov	r1, r6
   264d0:	4620      	mov	r0, r4
   264d2:	f00a fa0b 	bl	308ec <setup_thread_stack>
   264d6:	4605      	mov	r5, r0
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   264d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   264da:	9302      	str	r3, [sp, #8]
   264dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   264de:	9301      	str	r3, [sp, #4]
   264e0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   264e2:	9300      	str	r3, [sp, #0]
   264e4:	463b      	mov	r3, r7
   264e6:	4602      	mov	r2, r0
   264e8:	4631      	mov	r1, r6
   264ea:	4620      	mov	r0, r4
   264ec:	f7f1 ffea 	bl	184c4 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
   264f0:	2300      	movs	r3, #0
   264f2:	6563      	str	r3, [r4, #84]	; 0x54
		new_thread->base.cpu_mask = -1; /* allow all cpus */
	}
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   264f4:	4b0f      	ldr	r3, [pc, #60]	; (26534 <z_setup_new_thread+0x9c>)
   264f6:	689b      	ldr	r3, [r3, #8]
   264f8:	b1cb      	cbz	r3, 2652e <z_setup_new_thread+0x96>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   264fa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   264fe:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
#endif

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);

	return stack_ptr;
}
   26502:	4628      	mov	r0, r5
   26504:	b005      	add	sp, #20
   26506:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	Z_ASSERT_VALID_PRIO(prio, entry);
   2650a:	4b0b      	ldr	r3, [pc, #44]	; (26538 <z_setup_new_thread+0xa0>)
   2650c:	429f      	cmp	r7, r3
   2650e:	d1cf      	bne.n	264b0 <z_setup_new_thread+0x18>
   26510:	e7d2      	b.n	264b8 <z_setup_new_thread+0x20>
   26512:	f8df 902c 	ldr.w	r9, [pc, #44]	; 26540 <z_setup_new_thread+0xa8>
   26516:	f44f 7206 	mov.w	r2, #536	; 0x218
   2651a:	4649      	mov	r1, r9
   2651c:	4807      	ldr	r0, [pc, #28]	; (2653c <z_setup_new_thread+0xa4>)
   2651e:	f006 f806 	bl	2c52e <assert_print>
   26522:	f44f 7106 	mov.w	r1, #536	; 0x218
   26526:	4648      	mov	r0, r9
   26528:	f005 fffa 	bl	2c520 <assert_post_action>
   2652c:	e7c4      	b.n	264b8 <z_setup_new_thread+0x20>
		new_thread->resource_pool = NULL;
   2652e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
		return stack_ptr;
   26532:	e7e6      	b.n	26502 <z_setup_new_thread+0x6a>
   26534:	200046a4 	.word	0x200046a4
   26538:	000266f5 	.word	0x000266f5
   2653c:	00031600 	.word	0x00031600
   26540:	0003bde4 	.word	0x0003bde4

00026544 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, uint32_t options, k_timeout_t delay)
{
   26544:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26548:	b086      	sub	sp, #24
   2654a:	4604      	mov	r4, r0
   2654c:	460d      	mov	r5, r1
   2654e:	4616      	mov	r6, r2
   26550:	461f      	mov	r7, r3
   26552:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
   26556:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
   2655a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   2655e:	b9db      	cbnz	r3, 26598 <z_impl_k_thread_create+0x54>

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   26560:	2300      	movs	r3, #0
   26562:	9305      	str	r3, [sp, #20]
   26564:	9b12      	ldr	r3, [sp, #72]	; 0x48
   26566:	9304      	str	r3, [sp, #16]
   26568:	9b11      	ldr	r3, [sp, #68]	; 0x44
   2656a:	9303      	str	r3, [sp, #12]
   2656c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2656e:	9302      	str	r3, [sp, #8]
   26570:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   26572:	9301      	str	r3, [sp, #4]
   26574:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   26576:	9300      	str	r3, [sp, #0]
   26578:	463b      	mov	r3, r7
   2657a:	4632      	mov	r2, r6
   2657c:	4629      	mov	r1, r5
   2657e:	4620      	mov	r0, r4
   26580:	f7ff ff8a 	bl	26498 <z_setup_new_thread>
			  prio, options, NULL);

	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   26584:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   26588:	bf08      	it	eq
   2658a:	f1b9 3fff 	cmpeq.w	r9, #4294967295	; 0xffffffff
   2658e:	d111      	bne.n	265b4 <z_impl_k_thread_create+0x70>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
   26590:	4620      	mov	r0, r4
   26592:	b006      	add	sp, #24
   26594:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   26598:	f8df a028 	ldr.w	sl, [pc, #40]	; 265c4 <z_impl_k_thread_create+0x80>
   2659c:	f240 2287 	movw	r2, #647	; 0x287
   265a0:	4651      	mov	r1, sl
   265a2:	4807      	ldr	r0, [pc, #28]	; (265c0 <z_impl_k_thread_create+0x7c>)
   265a4:	f005 ffc3 	bl	2c52e <assert_print>
   265a8:	f240 2187 	movw	r1, #647	; 0x287
   265ac:	4650      	mov	r0, sl
   265ae:	f005 ffb7 	bl	2c520 <assert_post_action>
   265b2:	e7d5      	b.n	26560 <z_impl_k_thread_create+0x1c>
		schedule_new_thread(new_thread, delay);
   265b4:	464a      	mov	r2, r9
   265b6:	4643      	mov	r3, r8
   265b8:	4620      	mov	r0, r4
   265ba:	f7ff ff5f 	bl	2647c <schedule_new_thread>
   265be:	e7e7      	b.n	26590 <z_impl_k_thread_create+0x4c>
   265c0:	00031600 	.word	0x00031600
   265c4:	0003bde4 	.word	0x0003bde4

000265c8 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   265c8:	b530      	push	{r4, r5, lr}
   265ca:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   265cc:	4c31      	ldr	r4, [pc, #196]	; (26694 <z_init_static_threads+0xcc>)
   265ce:	e017      	b.n	26600 <z_init_static_threads+0x38>
   265d0:	4b31      	ldr	r3, [pc, #196]	; (26698 <z_init_static_threads+0xd0>)
   265d2:	429c      	cmp	r4, r3
   265d4:	d224      	bcs.n	26620 <z_init_static_threads+0x58>
		z_setup_new_thread(
   265d6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   265d8:	9305      	str	r3, [sp, #20]
   265da:	6a23      	ldr	r3, [r4, #32]
   265dc:	9304      	str	r3, [sp, #16]
   265de:	69e3      	ldr	r3, [r4, #28]
   265e0:	9303      	str	r3, [sp, #12]
   265e2:	69a3      	ldr	r3, [r4, #24]
   265e4:	9302      	str	r3, [sp, #8]
   265e6:	6963      	ldr	r3, [r4, #20]
   265e8:	9301      	str	r3, [sp, #4]
   265ea:	6923      	ldr	r3, [r4, #16]
   265ec:	9300      	str	r3, [sp, #0]
   265ee:	68e3      	ldr	r3, [r4, #12]
   265f0:	68a2      	ldr	r2, [r4, #8]
   265f2:	6861      	ldr	r1, [r4, #4]
   265f4:	6820      	ldr	r0, [r4, #0]
   265f6:	f7ff ff4f 	bl	26498 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
   265fa:	6823      	ldr	r3, [r4, #0]
   265fc:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   265fe:	3430      	adds	r4, #48	; 0x30
   26600:	4b25      	ldr	r3, [pc, #148]	; (26698 <z_init_static_threads+0xd0>)
   26602:	429c      	cmp	r4, r3
   26604:	d9e4      	bls.n	265d0 <z_init_static_threads+0x8>
   26606:	4d25      	ldr	r5, [pc, #148]	; (2669c <z_init_static_threads+0xd4>)
   26608:	f240 22ee 	movw	r2, #750	; 0x2ee
   2660c:	4629      	mov	r1, r5
   2660e:	4824      	ldr	r0, [pc, #144]	; (266a0 <z_init_static_threads+0xd8>)
   26610:	f005 ff8d 	bl	2c52e <assert_print>
   26614:	f240 21ee 	movw	r1, #750	; 0x2ee
   26618:	4628      	mov	r0, r5
   2661a:	f005 ff81 	bl	2c520 <assert_post_action>
   2661e:	e7d7      	b.n	265d0 <z_init_static_threads+0x8>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   26620:	f001 fbf0 	bl	27e04 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   26624:	4c1b      	ldr	r4, [pc, #108]	; (26694 <z_init_static_threads+0xcc>)
   26626:	e000      	b.n	2662a <z_init_static_threads+0x62>
   26628:	3430      	adds	r4, #48	; 0x30
   2662a:	4b1b      	ldr	r3, [pc, #108]	; (26698 <z_init_static_threads+0xd0>)
   2662c:	429c      	cmp	r4, r3
   2662e:	d81f      	bhi.n	26670 <z_init_static_threads+0xa8>
   26630:	4b19      	ldr	r3, [pc, #100]	; (26698 <z_init_static_threads+0xd0>)
   26632:	429c      	cmp	r4, r3
   26634:	d229      	bcs.n	2668a <z_init_static_threads+0xc2>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   26636:	6a60      	ldr	r0, [r4, #36]	; 0x24
   26638:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   2663c:	d0f4      	beq.n	26628 <z_init_static_threads+0x60>
			schedule_new_thread(thread_data->init_thread,
   2663e:	6825      	ldr	r5, [r4, #0]
					    K_MSEC(thread_data->init_delay));
   26640:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   26644:	17c1      	asrs	r1, r0, #31
   26646:	03c9      	lsls	r1, r1, #15
   26648:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
   2664c:	03c0      	lsls	r0, r0, #15
   2664e:	f240 33e7 	movw	r3, #999	; 0x3e7
   26652:	18c0      	adds	r0, r0, r3
   26654:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   26658:	f04f 0300 	mov.w	r3, #0
   2665c:	f141 0100 	adc.w	r1, r1, #0
   26660:	f7da faba 	bl	bd8 <__aeabi_uldivmod>
   26664:	4602      	mov	r2, r0
   26666:	460b      	mov	r3, r1
			schedule_new_thread(thread_data->init_thread,
   26668:	4628      	mov	r0, r5
   2666a:	f7ff ff07 	bl	2647c <schedule_new_thread>
   2666e:	e7db      	b.n	26628 <z_init_static_threads+0x60>
	_FOREACH_STATIC_THREAD(thread_data) {
   26670:	4d0a      	ldr	r5, [pc, #40]	; (2669c <z_init_static_threads+0xd4>)
   26672:	f240 320d 	movw	r2, #781	; 0x30d
   26676:	4629      	mov	r1, r5
   26678:	4809      	ldr	r0, [pc, #36]	; (266a0 <z_init_static_threads+0xd8>)
   2667a:	f005 ff58 	bl	2c52e <assert_print>
   2667e:	f240 310d 	movw	r1, #781	; 0x30d
   26682:	4628      	mov	r0, r5
   26684:	f005 ff4c 	bl	2c520 <assert_post_action>
   26688:	e7d2      	b.n	26630 <z_init_static_threads+0x68>
		}
	}
	k_sched_unlock();
   2668a:	f002 f8cf 	bl	2882c <k_sched_unlock>
}
   2668e:	b007      	add	sp, #28
   26690:	bd30      	pop	{r4, r5, pc}
   26692:	bf00      	nop
   26694:	20000e40 	.word	0x20000e40
   26698:	20000e40 	.word	0x20000e40
   2669c:	0003bde4 	.word	0x0003bde4
   266a0:	00031600 	.word	0x00031600

000266a4 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
   266a4:	6803      	ldr	r3, [r0, #0]

	if (thread_cpu != 0U) {
   266a6:	b13b      	cbz	r3, 266b8 <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3U) == _current_cpu->id) {
   266a8:	f003 0303 	and.w	r3, r3, #3
   266ac:	4a04      	ldr	r2, [pc, #16]	; (266c0 <z_spin_lock_valid+0x1c>)
   266ae:	7d12      	ldrb	r2, [r2, #20]
   266b0:	4293      	cmp	r3, r2
   266b2:	d003      	beq.n	266bc <z_spin_lock_valid+0x18>
			return false;
		}
	}
	return true;
   266b4:	2001      	movs	r0, #1
   266b6:	4770      	bx	lr
   266b8:	2001      	movs	r0, #1
   266ba:	4770      	bx	lr
			return false;
   266bc:	2000      	movs	r0, #0
}
   266be:	4770      	bx	lr
   266c0:	200046a4 	.word	0x200046a4

000266c4 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   266c4:	6801      	ldr	r1, [r0, #0]
   266c6:	4a06      	ldr	r2, [pc, #24]	; (266e0 <z_spin_unlock_valid+0x1c>)
   266c8:	7d13      	ldrb	r3, [r2, #20]
   266ca:	6892      	ldr	r2, [r2, #8]
   266cc:	4313      	orrs	r3, r2
   266ce:	4299      	cmp	r1, r3
   266d0:	d103      	bne.n	266da <z_spin_unlock_valid+0x16>
		return false;
	}
	l->thread_cpu = 0;
   266d2:	2300      	movs	r3, #0
   266d4:	6003      	str	r3, [r0, #0]
	return true;
   266d6:	2001      	movs	r0, #1
   266d8:	4770      	bx	lr
		return false;
   266da:	2000      	movs	r0, #0
}
   266dc:	4770      	bx	lr
   266de:	bf00      	nop
   266e0:	200046a4 	.word	0x200046a4

000266e4 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
   266e4:	4a02      	ldr	r2, [pc, #8]	; (266f0 <z_spin_lock_set_owner+0xc>)
   266e6:	7d13      	ldrb	r3, [r2, #20]
   266e8:	6892      	ldr	r2, [r2, #8]
   266ea:	4313      	orrs	r3, r2
   266ec:	6003      	str	r3, [r0, #0]
}
   266ee:	4770      	bx	lr
   266f0:	200046a4 	.word	0x200046a4

000266f4 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   266f4:	b508      	push	{r3, lr}
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
   266f6:	4b14      	ldr	r3, [pc, #80]	; (26748 <idle+0x54>)
   266f8:	689b      	ldr	r3, [r3, #8]
   266fa:	f993 300e 	ldrsb.w	r3, [r3, #14]
   266fe:	2b00      	cmp	r3, #0
   26700:	da0c      	bge.n	2671c <idle+0x28>
   26702:	4c12      	ldr	r4, [pc, #72]	; (2674c <idle+0x58>)
   26704:	2227      	movs	r2, #39	; 0x27
   26706:	4621      	mov	r1, r4
   26708:	4811      	ldr	r0, [pc, #68]	; (26750 <idle+0x5c>)
   2670a:	f005 ff10 	bl	2c52e <assert_print>
   2670e:	2127      	movs	r1, #39	; 0x27
   26710:	4620      	mov	r0, r4
   26712:	f005 ff05 	bl	2c520 <assert_post_action>
   26716:	e001      	b.n	2671c <idle+0x28>
	arch_cpu_idle();
   26718:	f7f1 fd3e 	bl	18198 <arch_cpu_idle>
	__asm__ volatile(
   2671c:	f04f 0240 	mov.w	r2, #64	; 0x40
   26720:	f3ef 8311 	mrs	r3, BASEPRI
   26724:	f382 8812 	msr	BASEPRI_MAX, r2
   26728:	f3bf 8f6f 	isb	sy
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   2672c:	f002 fdf0 	bl	29310 <z_get_next_timeout_expiry>
   26730:	4b05      	ldr	r3, [pc, #20]	; (26748 <idle+0x54>)
   26732:	61d8      	str	r0, [r3, #28]
	return !z_sys_post_kernel;
   26734:	4b07      	ldr	r3, [pc, #28]	; (26754 <idle+0x60>)
   26736:	781b      	ldrb	r3, [r3, #0]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   26738:	2b00      	cmp	r3, #0
   2673a:	d0ed      	beq.n	26718 <idle+0x24>
   2673c:	f7f0 ff54 	bl	175e8 <pm_system_suspend>
   26740:	2800      	cmp	r0, #0
   26742:	d1eb      	bne.n	2671c <idle+0x28>
   26744:	e7e8      	b.n	26718 <idle+0x24>
   26746:	bf00      	nop
   26748:	200046a4 	.word	0x200046a4
   2674c:	0003be08 	.word	0x0003be08
   26750:	00031600 	.word	0x00031600
   26754:	20004713 	.word	0x20004713

00026758 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
   26758:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2675c:	b082      	sub	sp, #8
   2675e:	4604      	mov	r4, r0
   26760:	4688      	mov	r8, r1
   26762:	4616      	mov	r6, r2
   26764:	461d      	mov	r5, r3
   26766:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2676a:	b113      	cbz	r3, 26772 <z_impl_k_msgq_put+0x1a>
   2676c:	ea55 0302 	orrs.w	r3, r5, r2
   26770:	d126      	bne.n	267c0 <z_impl_k_msgq_put+0x68>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   26772:	f104 0708 	add.w	r7, r4, #8
   26776:	f04f 0340 	mov.w	r3, #64	; 0x40
   2677a:	f3ef 8911 	mrs	r9, BASEPRI
   2677e:	f383 8812 	msr	BASEPRI_MAX, r3
   26782:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26786:	4638      	mov	r0, r7
   26788:	f7ff ff8c 	bl	266a4 <z_spin_lock_valid>
   2678c:	b318      	cbz	r0, 267d6 <z_impl_k_msgq_put+0x7e>
	z_spin_lock_set_owner(l);
   2678e:	4638      	mov	r0, r7
   26790:	f7ff ffa8 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
   26794:	6a62      	ldr	r2, [r4, #36]	; 0x24
   26796:	6923      	ldr	r3, [r4, #16]
   26798:	429a      	cmp	r2, r3
   2679a:	d328      	bcc.n	267ee <z_impl_k_msgq_put+0x96>
#ifdef CONFIG_POLL
			handle_poll_events(msgq, K_POLL_STATE_MSGQ_DATA_AVAILABLE);
#endif /* CONFIG_POLL */
		}
		result = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2679c:	ea55 0306 	orrs.w	r3, r5, r6
   267a0:	d153      	bne.n	2684a <z_impl_k_msgq_put+0xf2>
		/* don't wait for message space to become available */
		result = -ENOMSG;
   267a2:	f06f 0422 	mvn.w	r4, #34	; 0x22
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   267a6:	4638      	mov	r0, r7
   267a8:	f7ff ff8c 	bl	266c4 <z_spin_unlock_valid>
   267ac:	2800      	cmp	r0, #0
   267ae:	d059      	beq.n	26864 <z_impl_k_msgq_put+0x10c>
	__asm__ volatile(
   267b0:	f389 8811 	msr	BASEPRI, r9
   267b4:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   267b8:	4620      	mov	r0, r4
   267ba:	b002      	add	sp, #8
   267bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   267c0:	4f2e      	ldr	r7, [pc, #184]	; (2687c <z_impl_k_msgq_put+0x124>)
   267c2:	2276      	movs	r2, #118	; 0x76
   267c4:	4639      	mov	r1, r7
   267c6:	482e      	ldr	r0, [pc, #184]	; (26880 <z_impl_k_msgq_put+0x128>)
   267c8:	f005 feb1 	bl	2c52e <assert_print>
   267cc:	2176      	movs	r1, #118	; 0x76
   267ce:	4638      	mov	r0, r7
   267d0:	f005 fea6 	bl	2c520 <assert_post_action>
   267d4:	e7cd      	b.n	26772 <z_impl_k_msgq_put+0x1a>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   267d6:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 26888 <z_impl_k_msgq_put+0x130>
   267da:	228e      	movs	r2, #142	; 0x8e
   267dc:	4651      	mov	r1, sl
   267de:	4828      	ldr	r0, [pc, #160]	; (26880 <z_impl_k_msgq_put+0x128>)
   267e0:	f005 fea5 	bl	2c52e <assert_print>
   267e4:	218e      	movs	r1, #142	; 0x8e
   267e6:	4650      	mov	r0, sl
   267e8:	f005 fe9a 	bl	2c520 <assert_post_action>
   267ec:	e7cf      	b.n	2678e <z_impl_k_msgq_put+0x36>
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   267ee:	4620      	mov	r0, r4
   267f0:	f002 f92a 	bl	28a48 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   267f4:	4605      	mov	r5, r0
   267f6:	b178      	cbz	r0, 26818 <z_impl_k_msgq_put+0xc0>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   267f8:	68e2      	ldr	r2, [r4, #12]
   267fa:	4641      	mov	r1, r8
   267fc:	6940      	ldr	r0, [r0, #20]
   267fe:	f00a fb32 	bl	30e66 <memcpy>
   26802:	2400      	movs	r4, #0
   26804:	f8c5 4088 	str.w	r4, [r5, #136]	; 0x88
			z_ready_thread(pending_thread);
   26808:	4628      	mov	r0, r5
   2680a:	f001 fd53 	bl	282b4 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   2680e:	4649      	mov	r1, r9
   26810:	4638      	mov	r0, r7
   26812:	f001 fabb 	bl	27d8c <z_reschedule>
			return 0;
   26816:	e7cf      	b.n	267b8 <z_impl_k_msgq_put+0x60>
   26818:	68e2      	ldr	r2, [r4, #12]
   2681a:	4641      	mov	r1, r8
   2681c:	6a20      	ldr	r0, [r4, #32]
   2681e:	f00a fb22 	bl	30e66 <memcpy>
			msgq->write_ptr += msgq->msg_size;
   26822:	68e2      	ldr	r2, [r4, #12]
   26824:	6a23      	ldr	r3, [r4, #32]
   26826:	4413      	add	r3, r2
   26828:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   2682a:	69a2      	ldr	r2, [r4, #24]
   2682c:	4293      	cmp	r3, r2
   2682e:	d009      	beq.n	26844 <z_impl_k_msgq_put+0xec>
			msgq->used_msgs++;
   26830:	6a63      	ldr	r3, [r4, #36]	; 0x24
   26832:	3301      	adds	r3, #1
   26834:	6263      	str	r3, [r4, #36]	; 0x24
	z_handle_obj_poll_events(&msgq->poll_events, state);
   26836:	2110      	movs	r1, #16
   26838:	f104 0028 	add.w	r0, r4, #40	; 0x28
   2683c:	f00a fa51 	bl	30ce2 <z_handle_obj_poll_events>
		result = 0;
   26840:	2400      	movs	r4, #0
   26842:	e7b0      	b.n	267a6 <z_impl_k_msgq_put+0x4e>
				msgq->write_ptr = msgq->buffer_start;
   26844:	6963      	ldr	r3, [r4, #20]
   26846:	6223      	str	r3, [r4, #32]
   26848:	e7f2      	b.n	26830 <z_impl_k_msgq_put+0xd8>
		_current->base.swap_data = (void *) data;
   2684a:	4b0e      	ldr	r3, [pc, #56]	; (26884 <z_impl_k_msgq_put+0x12c>)
   2684c:	689b      	ldr	r3, [r3, #8]
   2684e:	f8c3 8014 	str.w	r8, [r3, #20]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26852:	9600      	str	r6, [sp, #0]
   26854:	9501      	str	r5, [sp, #4]
   26856:	4622      	mov	r2, r4
   26858:	4649      	mov	r1, r9
   2685a:	4638      	mov	r0, r7
   2685c:	f001 feba 	bl	285d4 <z_pend_curr>
   26860:	4604      	mov	r4, r0
		return result;
   26862:	e7a9      	b.n	267b8 <z_impl_k_msgq_put+0x60>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26864:	4d08      	ldr	r5, [pc, #32]	; (26888 <z_impl_k_msgq_put+0x130>)
   26866:	22b9      	movs	r2, #185	; 0xb9
   26868:	4629      	mov	r1, r5
   2686a:	4805      	ldr	r0, [pc, #20]	; (26880 <z_impl_k_msgq_put+0x128>)
   2686c:	f005 fe5f 	bl	2c52e <assert_print>
   26870:	21b9      	movs	r1, #185	; 0xb9
   26872:	4628      	mov	r0, r5
   26874:	f005 fe54 	bl	2c520 <assert_post_action>
   26878:	e79a      	b.n	267b0 <z_impl_k_msgq_put+0x58>
   2687a:	bf00      	nop
   2687c:	0003be2c 	.word	0x0003be2c
   26880:	00031600 	.word	0x00031600
   26884:	200046a4 	.word	0x200046a4
   26888:	000390f0 	.word	0x000390f0

0002688c <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   2688c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26890:	b082      	sub	sp, #8
   26892:	4604      	mov	r4, r0
   26894:	4688      	mov	r8, r1
   26896:	4616      	mov	r6, r2
   26898:	461d      	mov	r5, r3
   2689a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2689e:	b113      	cbz	r3, 268a6 <z_impl_k_msgq_get+0x1a>
   268a0:	ea55 0302 	orrs.w	r3, r5, r2
   268a4:	d143      	bne.n	2692e <z_impl_k_msgq_get+0xa2>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   268a6:	f104 0708 	add.w	r7, r4, #8
	__asm__ volatile(
   268aa:	f04f 0340 	mov.w	r3, #64	; 0x40
   268ae:	f3ef 8911 	mrs	r9, BASEPRI
   268b2:	f383 8812 	msr	BASEPRI_MAX, r3
   268b6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   268ba:	4638      	mov	r0, r7
   268bc:	f7ff fef2 	bl	266a4 <z_spin_lock_valid>
   268c0:	2800      	cmp	r0, #0
   268c2:	d03f      	beq.n	26944 <z_impl_k_msgq_get+0xb8>
	z_spin_lock_set_owner(l);
   268c4:	4638      	mov	r0, r7
   268c6:	f7ff ff0d 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
   268ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
   268cc:	2b00      	cmp	r3, #0
   268ce:	d04b      	beq.n	26968 <z_impl_k_msgq_get+0xdc>
   268d0:	68e2      	ldr	r2, [r4, #12]
   268d2:	69e1      	ldr	r1, [r4, #28]
   268d4:	4640      	mov	r0, r8
   268d6:	f00a fac6 	bl	30e66 <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   268da:	68e2      	ldr	r2, [r4, #12]
   268dc:	69e3      	ldr	r3, [r4, #28]
   268de:	4413      	add	r3, r2
   268e0:	61e3      	str	r3, [r4, #28]
		if (msgq->read_ptr == msgq->buffer_end) {
   268e2:	69a2      	ldr	r2, [r4, #24]
   268e4:	4293      	cmp	r3, r2
   268e6:	d039      	beq.n	2695c <z_impl_k_msgq_get+0xd0>
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;
   268e8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   268ea:	3b01      	subs	r3, #1
   268ec:	6263      	str	r3, [r4, #36]	; 0x24

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   268ee:	4620      	mov	r0, r4
   268f0:	f002 f8aa 	bl	28a48 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   268f4:	4605      	mov	r5, r0
   268f6:	2800      	cmp	r0, #0
   268f8:	d054      	beq.n	269a4 <z_impl_k_msgq_get+0x118>
   268fa:	68e2      	ldr	r2, [r4, #12]
   268fc:	6941      	ldr	r1, [r0, #20]
   268fe:	6a20      	ldr	r0, [r4, #32]
   26900:	f00a fab1 	bl	30e66 <memcpy>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   26904:	68e2      	ldr	r2, [r4, #12]
   26906:	6a23      	ldr	r3, [r4, #32]
   26908:	4413      	add	r3, r2
   2690a:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   2690c:	69a2      	ldr	r2, [r4, #24]
   2690e:	4293      	cmp	r3, r2
   26910:	d027      	beq.n	26962 <z_impl_k_msgq_get+0xd6>
				msgq->write_ptr = msgq->buffer_start;
			}
			msgq->used_msgs++;
   26912:	6a63      	ldr	r3, [r4, #36]	; 0x24
   26914:	3301      	adds	r3, #1
   26916:	6263      	str	r3, [r4, #36]	; 0x24
   26918:	2400      	movs	r4, #0
   2691a:	f8c5 4088 	str.w	r4, [r5, #136]	; 0x88

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   2691e:	4628      	mov	r0, r5
   26920:	f001 fcc8 	bl	282b4 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   26924:	4649      	mov	r1, r9
   26926:	4638      	mov	r0, r7
   26928:	f001 fa30 	bl	27d8c <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
   2692c:	e029      	b.n	26982 <z_impl_k_msgq_get+0xf6>
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2692e:	4f24      	ldr	r7, [pc, #144]	; (269c0 <z_impl_k_msgq_get+0x134>)
   26930:	22d0      	movs	r2, #208	; 0xd0
   26932:	4639      	mov	r1, r7
   26934:	4823      	ldr	r0, [pc, #140]	; (269c4 <z_impl_k_msgq_get+0x138>)
   26936:	f005 fdfa 	bl	2c52e <assert_print>
   2693a:	21d0      	movs	r1, #208	; 0xd0
   2693c:	4638      	mov	r0, r7
   2693e:	f005 fdef 	bl	2c520 <assert_post_action>
   26942:	e7b0      	b.n	268a6 <z_impl_k_msgq_get+0x1a>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26944:	f8df a084 	ldr.w	sl, [pc, #132]	; 269cc <z_impl_k_msgq_get+0x140>
   26948:	228e      	movs	r2, #142	; 0x8e
   2694a:	4651      	mov	r1, sl
   2694c:	481d      	ldr	r0, [pc, #116]	; (269c4 <z_impl_k_msgq_get+0x138>)
   2694e:	f005 fdee 	bl	2c52e <assert_print>
   26952:	218e      	movs	r1, #142	; 0x8e
   26954:	4650      	mov	r0, sl
   26956:	f005 fde3 	bl	2c520 <assert_post_action>
   2695a:	e7b3      	b.n	268c4 <z_impl_k_msgq_get+0x38>
			msgq->read_ptr = msgq->buffer_start;
   2695c:	6963      	ldr	r3, [r4, #20]
   2695e:	61e3      	str	r3, [r4, #28]
   26960:	e7c2      	b.n	268e8 <z_impl_k_msgq_get+0x5c>
				msgq->write_ptr = msgq->buffer_start;
   26962:	6963      	ldr	r3, [r4, #20]
   26964:	6223      	str	r3, [r4, #32]
   26966:	e7d4      	b.n	26912 <z_impl_k_msgq_get+0x86>
		}
		result = 0;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   26968:	ea55 0306 	orrs.w	r3, r5, r6
   2696c:	d10d      	bne.n	2698a <z_impl_k_msgq_get+0xfe>
		/* don't wait for a message to become available */
		result = -ENOMSG;
   2696e:	f06f 0422 	mvn.w	r4, #34	; 0x22
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26972:	4638      	mov	r0, r7
   26974:	f7ff fea6 	bl	266c4 <z_spin_unlock_valid>
   26978:	b1b0      	cbz	r0, 269a8 <z_impl_k_msgq_get+0x11c>
	__asm__ volatile(
   2697a:	f389 8811 	msr	BASEPRI, r9
   2697e:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   26982:	4620      	mov	r0, r4
   26984:	b002      	add	sp, #8
   26986:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		_current->base.swap_data = data;
   2698a:	4b0f      	ldr	r3, [pc, #60]	; (269c8 <z_impl_k_msgq_get+0x13c>)
   2698c:	689b      	ldr	r3, [r3, #8]
   2698e:	f8c3 8014 	str.w	r8, [r3, #20]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26992:	9600      	str	r6, [sp, #0]
   26994:	9501      	str	r5, [sp, #4]
   26996:	4622      	mov	r2, r4
   26998:	4649      	mov	r1, r9
   2699a:	4638      	mov	r0, r7
   2699c:	f001 fe1a 	bl	285d4 <z_pend_curr>
   269a0:	4604      	mov	r4, r0
		return result;
   269a2:	e7ee      	b.n	26982 <z_impl_k_msgq_get+0xf6>
		result = 0;
   269a4:	2400      	movs	r4, #0
   269a6:	e7e4      	b.n	26972 <z_impl_k_msgq_get+0xe6>
   269a8:	4d08      	ldr	r5, [pc, #32]	; (269cc <z_impl_k_msgq_get+0x140>)
   269aa:	22b9      	movs	r2, #185	; 0xb9
   269ac:	4629      	mov	r1, r5
   269ae:	4805      	ldr	r0, [pc, #20]	; (269c4 <z_impl_k_msgq_get+0x138>)
   269b0:	f005 fdbd 	bl	2c52e <assert_print>
   269b4:	21b9      	movs	r1, #185	; 0xb9
   269b6:	4628      	mov	r0, r5
   269b8:	f005 fdb2 	bl	2c520 <assert_post_action>
   269bc:	e7dd      	b.n	2697a <z_impl_k_msgq_get+0xee>
   269be:	bf00      	nop
   269c0:	0003be2c 	.word	0x0003be2c
   269c4:	00031600 	.word	0x00031600
   269c8:	200046a4 	.word	0x200046a4
   269cc:	000390f0 	.word	0x000390f0

000269d0 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   269d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   269d4:	b083      	sub	sp, #12
   269d6:	4604      	mov	r4, r0
   269d8:	4616      	mov	r6, r2
   269da:	461d      	mov	r5, r3
   269dc:	f3ef 8105 	mrs	r1, IPSR
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
   269e0:	2900      	cmp	r1, #0
   269e2:	d12a      	bne.n	26a3a <z_impl_k_mutex_lock+0x6a>
	__asm__ volatile(
   269e4:	f04f 0340 	mov.w	r3, #64	; 0x40
   269e8:	f3ef 8711 	mrs	r7, BASEPRI
   269ec:	f383 8812 	msr	BASEPRI_MAX, r3
   269f0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   269f4:	486c      	ldr	r0, [pc, #432]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   269f6:	f7ff fe55 	bl	266a4 <z_spin_lock_valid>
   269fa:	b348      	cbz	r0, 26a50 <z_impl_k_mutex_lock+0x80>
	z_spin_lock_set_owner(l);
   269fc:	486a      	ldr	r0, [pc, #424]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   269fe:	f7ff fe71 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   26a02:	68e1      	ldr	r1, [r4, #12]
   26a04:	2900      	cmp	r1, #0
   26a06:	d12f      	bne.n	26a68 <z_impl_k_mutex_lock+0x98>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
   26a08:	2900      	cmp	r1, #0
   26a0a:	d174      	bne.n	26af6 <z_impl_k_mutex_lock+0x126>
   26a0c:	4b67      	ldr	r3, [pc, #412]	; (26bac <z_impl_k_mutex_lock+0x1dc>)
   26a0e:	689b      	ldr	r3, [r3, #8]
   26a10:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   26a14:	6123      	str	r3, [r4, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
   26a16:	3101      	adds	r1, #1
   26a18:	60e1      	str	r1, [r4, #12]
		mutex->owner = _current;
   26a1a:	4b64      	ldr	r3, [pc, #400]	; (26bac <z_impl_k_mutex_lock+0x1dc>)
   26a1c:	689b      	ldr	r3, [r3, #8]
   26a1e:	60a3      	str	r3, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26a20:	4861      	ldr	r0, [pc, #388]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26a22:	f7ff fe4f 	bl	266c4 <z_spin_unlock_valid>
   26a26:	2800      	cmp	r0, #0
   26a28:	d067      	beq.n	26afa <z_impl_k_mutex_lock+0x12a>
	__asm__ volatile(
   26a2a:	f387 8811 	msr	BASEPRI, r7
   26a2e:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
   26a32:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   26a34:	b003      	add	sp, #12
   26a36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
   26a3a:	4f5d      	ldr	r7, [pc, #372]	; (26bb0 <z_impl_k_mutex_lock+0x1e0>)
   26a3c:	2265      	movs	r2, #101	; 0x65
   26a3e:	4639      	mov	r1, r7
   26a40:	485c      	ldr	r0, [pc, #368]	; (26bb4 <z_impl_k_mutex_lock+0x1e4>)
   26a42:	f005 fd74 	bl	2c52e <assert_print>
   26a46:	2165      	movs	r1, #101	; 0x65
   26a48:	4638      	mov	r0, r7
   26a4a:	f005 fd69 	bl	2c520 <assert_post_action>
   26a4e:	e7c9      	b.n	269e4 <z_impl_k_mutex_lock+0x14>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26a50:	f8df 8164 	ldr.w	r8, [pc, #356]	; 26bb8 <z_impl_k_mutex_lock+0x1e8>
   26a54:	228e      	movs	r2, #142	; 0x8e
   26a56:	4641      	mov	r1, r8
   26a58:	4856      	ldr	r0, [pc, #344]	; (26bb4 <z_impl_k_mutex_lock+0x1e4>)
   26a5a:	f005 fd68 	bl	2c52e <assert_print>
   26a5e:	218e      	movs	r1, #142	; 0x8e
   26a60:	4640      	mov	r0, r8
   26a62:	f005 fd5d 	bl	2c520 <assert_post_action>
   26a66:	e7c9      	b.n	269fc <z_impl_k_mutex_lock+0x2c>
	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   26a68:	68a2      	ldr	r2, [r4, #8]
   26a6a:	4b50      	ldr	r3, [pc, #320]	; (26bac <z_impl_k_mutex_lock+0x1dc>)
   26a6c:	689b      	ldr	r3, [r3, #8]
   26a6e:	429a      	cmp	r2, r3
   26a70:	d0ca      	beq.n	26a08 <z_impl_k_mutex_lock+0x38>
	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   26a72:	ea55 0106 	orrs.w	r1, r5, r6
   26a76:	bf0c      	ite	eq
   26a78:	f04f 0801 	moveq.w	r8, #1
   26a7c:	f04f 0800 	movne.w	r8, #0
   26a80:	d046      	beq.n	26b10 <z_impl_k_mutex_lock+0x140>
					    mutex->owner->base.prio);
   26a82:	f992 900e 	ldrsb.w	r9, [r2, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
   26a86:	4649      	mov	r1, r9
   26a88:	f993 000e 	ldrsb.w	r0, [r3, #14]
   26a8c:	f009 ff73 	bl	30976 <new_prio_for_inheritance>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   26a90:	4581      	cmp	r9, r0
   26a92:	dc53      	bgt.n	26b3c <z_impl_k_mutex_lock+0x16c>
	bool resched = false;
   26a94:	f04f 0900 	mov.w	r9, #0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   26a98:	9600      	str	r6, [sp, #0]
   26a9a:	9501      	str	r5, [sp, #4]
   26a9c:	4622      	mov	r2, r4
   26a9e:	4639      	mov	r1, r7
   26aa0:	4841      	ldr	r0, [pc, #260]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26aa2:	f001 fd97 	bl	285d4 <z_pend_curr>
	if (got_mutex == 0) {
   26aa6:	2800      	cmp	r0, #0
   26aa8:	d0c4      	beq.n	26a34 <z_impl_k_mutex_lock+0x64>
	__asm__ volatile(
   26aaa:	f04f 0340 	mov.w	r3, #64	; 0x40
   26aae:	f3ef 8511 	mrs	r5, BASEPRI
   26ab2:	f383 8812 	msr	BASEPRI_MAX, r3
   26ab6:	f3bf 8f6f 	isb	sy
   26aba:	483b      	ldr	r0, [pc, #236]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26abc:	f7ff fdf2 	bl	266a4 <z_spin_lock_valid>
   26ac0:	2800      	cmp	r0, #0
   26ac2:	d041      	beq.n	26b48 <z_impl_k_mutex_lock+0x178>
	z_spin_lock_set_owner(l);
   26ac4:	4838      	ldr	r0, [pc, #224]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26ac6:	f7ff fe0d 	bl	266e4 <z_spin_lock_set_owner>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   26aca:	6823      	ldr	r3, [r4, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26acc:	429c      	cmp	r4, r3
   26ace:	d046      	beq.n	26b5e <z_impl_k_mutex_lock+0x18e>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   26ad0:	2b00      	cmp	r3, #0
   26ad2:	d044      	beq.n	26b5e <z_impl_k_mutex_lock+0x18e>
   26ad4:	6921      	ldr	r1, [r4, #16]
   26ad6:	f993 000e 	ldrsb.w	r0, [r3, #14]
   26ada:	f009 ff4c 	bl	30976 <new_prio_for_inheritance>
   26ade:	4601      	mov	r1, r0
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   26ae0:	4620      	mov	r0, r4
   26ae2:	f009 ff53 	bl	3098c <adjust_owner_prio>
   26ae6:	2800      	cmp	r0, #0
   26ae8:	d13b      	bne.n	26b62 <z_impl_k_mutex_lock+0x192>
   26aea:	f1b9 0f00 	cmp.w	r9, #0
   26aee:	d03a      	beq.n	26b66 <z_impl_k_mutex_lock+0x196>
   26af0:	f04f 0801 	mov.w	r8, #1
   26af4:	e037      	b.n	26b66 <z_impl_k_mutex_lock+0x196>
					_current->base.prio :
   26af6:	6923      	ldr	r3, [r4, #16]
   26af8:	e78c      	b.n	26a14 <z_impl_k_mutex_lock+0x44>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26afa:	4c2f      	ldr	r4, [pc, #188]	; (26bb8 <z_impl_k_mutex_lock+0x1e8>)
   26afc:	22b9      	movs	r2, #185	; 0xb9
   26afe:	4621      	mov	r1, r4
   26b00:	482c      	ldr	r0, [pc, #176]	; (26bb4 <z_impl_k_mutex_lock+0x1e4>)
   26b02:	f005 fd14 	bl	2c52e <assert_print>
   26b06:	21b9      	movs	r1, #185	; 0xb9
   26b08:	4620      	mov	r0, r4
   26b0a:	f005 fd09 	bl	2c520 <assert_post_action>
   26b0e:	e78c      	b.n	26a2a <z_impl_k_mutex_lock+0x5a>
   26b10:	4825      	ldr	r0, [pc, #148]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26b12:	f7ff fdd7 	bl	266c4 <z_spin_unlock_valid>
   26b16:	b130      	cbz	r0, 26b26 <z_impl_k_mutex_lock+0x156>
	__asm__ volatile(
   26b18:	f387 8811 	msr	BASEPRI, r7
   26b1c:	f3bf 8f6f 	isb	sy
		return -EBUSY;
   26b20:	f06f 000f 	mvn.w	r0, #15
   26b24:	e786      	b.n	26a34 <z_impl_k_mutex_lock+0x64>
   26b26:	4c24      	ldr	r4, [pc, #144]	; (26bb8 <z_impl_k_mutex_lock+0x1e8>)
   26b28:	22b9      	movs	r2, #185	; 0xb9
   26b2a:	4621      	mov	r1, r4
   26b2c:	4821      	ldr	r0, [pc, #132]	; (26bb4 <z_impl_k_mutex_lock+0x1e4>)
   26b2e:	f005 fcfe 	bl	2c52e <assert_print>
   26b32:	21b9      	movs	r1, #185	; 0xb9
   26b34:	4620      	mov	r0, r4
   26b36:	f005 fcf3 	bl	2c520 <assert_post_action>
   26b3a:	e7ed      	b.n	26b18 <z_impl_k_mutex_lock+0x148>
		resched = adjust_owner_prio(mutex, new_prio);
   26b3c:	4601      	mov	r1, r0
   26b3e:	4620      	mov	r0, r4
   26b40:	f009 ff24 	bl	3098c <adjust_owner_prio>
   26b44:	4681      	mov	r9, r0
   26b46:	e7a7      	b.n	26a98 <z_impl_k_mutex_lock+0xc8>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26b48:	4e1b      	ldr	r6, [pc, #108]	; (26bb8 <z_impl_k_mutex_lock+0x1e8>)
   26b4a:	228e      	movs	r2, #142	; 0x8e
   26b4c:	4631      	mov	r1, r6
   26b4e:	4819      	ldr	r0, [pc, #100]	; (26bb4 <z_impl_k_mutex_lock+0x1e4>)
   26b50:	f005 fced 	bl	2c52e <assert_print>
   26b54:	218e      	movs	r1, #142	; 0x8e
   26b56:	4630      	mov	r0, r6
   26b58:	f005 fce2 	bl	2c520 <assert_post_action>
   26b5c:	e7b2      	b.n	26ac4 <z_impl_k_mutex_lock+0xf4>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   26b5e:	6921      	ldr	r1, [r4, #16]
   26b60:	e7be      	b.n	26ae0 <z_impl_k_mutex_lock+0x110>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   26b62:	f04f 0801 	mov.w	r8, #1
	if (resched) {
   26b66:	f1b8 0f00 	cmp.w	r8, #0
   26b6a:	d006      	beq.n	26b7a <z_impl_k_mutex_lock+0x1aa>
		z_reschedule(&lock, key);
   26b6c:	4629      	mov	r1, r5
   26b6e:	480e      	ldr	r0, [pc, #56]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26b70:	f001 f90c 	bl	27d8c <z_reschedule>
	return -EAGAIN;
   26b74:	f06f 000a 	mvn.w	r0, #10
   26b78:	e75c      	b.n	26a34 <z_impl_k_mutex_lock+0x64>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26b7a:	480b      	ldr	r0, [pc, #44]	; (26ba8 <z_impl_k_mutex_lock+0x1d8>)
   26b7c:	f7ff fda2 	bl	266c4 <z_spin_unlock_valid>
   26b80:	b130      	cbz	r0, 26b90 <z_impl_k_mutex_lock+0x1c0>
   26b82:	f385 8811 	msr	BASEPRI, r5
   26b86:	f3bf 8f6f 	isb	sy
   26b8a:	f06f 000a 	mvn.w	r0, #10
   26b8e:	e751      	b.n	26a34 <z_impl_k_mutex_lock+0x64>
   26b90:	4c09      	ldr	r4, [pc, #36]	; (26bb8 <z_impl_k_mutex_lock+0x1e8>)
   26b92:	22b9      	movs	r2, #185	; 0xb9
   26b94:	4621      	mov	r1, r4
   26b96:	4807      	ldr	r0, [pc, #28]	; (26bb4 <z_impl_k_mutex_lock+0x1e4>)
   26b98:	f005 fcc9 	bl	2c52e <assert_print>
   26b9c:	21b9      	movs	r1, #185	; 0xb9
   26b9e:	4620      	mov	r0, r4
   26ba0:	f005 fcbe 	bl	2c520 <assert_post_action>
   26ba4:	e7ed      	b.n	26b82 <z_impl_k_mutex_lock+0x1b2>
   26ba6:	bf00      	nop
   26ba8:	200046d4 	.word	0x200046d4
   26bac:	200046a4 	.word	0x200046a4
   26bb0:	0003be50 	.word	0x0003be50
   26bb4:	00031600 	.word	0x00031600
   26bb8:	000390f0 	.word	0x000390f0

00026bbc <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   26bbc:	b570      	push	{r4, r5, r6, lr}
   26bbe:	4604      	mov	r4, r0
   26bc0:	f3ef 8305 	mrs	r3, IPSR
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
   26bc4:	b97b      	cbnz	r3, 26be6 <z_impl_k_mutex_unlock+0x2a>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   26bc6:	68a3      	ldr	r3, [r4, #8]
   26bc8:	2b00      	cmp	r3, #0
   26bca:	d06a      	beq.n	26ca2 <z_impl_k_mutex_unlock+0xe6>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   26bcc:	4a38      	ldr	r2, [pc, #224]	; (26cb0 <z_impl_k_mutex_unlock+0xf4>)
   26bce:	6892      	ldr	r2, [r2, #8]
   26bd0:	4293      	cmp	r3, r2
   26bd2:	d169      	bne.n	26ca8 <z_impl_k_mutex_unlock+0xec>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   26bd4:	68e3      	ldr	r3, [r4, #12]
   26bd6:	b18b      	cbz	r3, 26bfc <z_impl_k_mutex_unlock+0x40>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   26bd8:	68e3      	ldr	r3, [r4, #12]
   26bda:	2b01      	cmp	r3, #1
   26bdc:	d919      	bls.n	26c12 <z_impl_k_mutex_unlock+0x56>
		mutex->lock_count--;
   26bde:	3b01      	subs	r3, #1
   26be0:	60e3      	str	r3, [r4, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
   26be2:	2000      	movs	r0, #0
}
   26be4:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
   26be6:	4d33      	ldr	r5, [pc, #204]	; (26cb4 <z_impl_k_mutex_unlock+0xf8>)
   26be8:	22c7      	movs	r2, #199	; 0xc7
   26bea:	4629      	mov	r1, r5
   26bec:	4832      	ldr	r0, [pc, #200]	; (26cb8 <z_impl_k_mutex_unlock+0xfc>)
   26bee:	f005 fc9e 	bl	2c52e <assert_print>
   26bf2:	21c7      	movs	r1, #199	; 0xc7
   26bf4:	4628      	mov	r0, r5
   26bf6:	f005 fc93 	bl	2c520 <assert_post_action>
   26bfa:	e7e4      	b.n	26bc6 <z_impl_k_mutex_unlock+0xa>
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   26bfc:	4d2d      	ldr	r5, [pc, #180]	; (26cb4 <z_impl_k_mutex_unlock+0xf8>)
   26bfe:	22df      	movs	r2, #223	; 0xdf
   26c00:	4629      	mov	r1, r5
   26c02:	482d      	ldr	r0, [pc, #180]	; (26cb8 <z_impl_k_mutex_unlock+0xfc>)
   26c04:	f005 fc93 	bl	2c52e <assert_print>
   26c08:	21df      	movs	r1, #223	; 0xdf
   26c0a:	4628      	mov	r0, r5
   26c0c:	f005 fc88 	bl	2c520 <assert_post_action>
   26c10:	e7e2      	b.n	26bd8 <z_impl_k_mutex_unlock+0x1c>
	__asm__ volatile(
   26c12:	f04f 0340 	mov.w	r3, #64	; 0x40
   26c16:	f3ef 8511 	mrs	r5, BASEPRI
   26c1a:	f383 8812 	msr	BASEPRI_MAX, r3
   26c1e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26c22:	4826      	ldr	r0, [pc, #152]	; (26cbc <z_impl_k_mutex_unlock+0x100>)
   26c24:	f7ff fd3e 	bl	266a4 <z_spin_lock_valid>
   26c28:	b1c8      	cbz	r0, 26c5e <z_impl_k_mutex_unlock+0xa2>
	z_spin_lock_set_owner(l);
   26c2a:	4824      	ldr	r0, [pc, #144]	; (26cbc <z_impl_k_mutex_unlock+0x100>)
   26c2c:	f7ff fd5a 	bl	266e4 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   26c30:	6921      	ldr	r1, [r4, #16]
   26c32:	4620      	mov	r0, r4
   26c34:	f009 feaa 	bl	3098c <adjust_owner_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   26c38:	4620      	mov	r0, r4
   26c3a:	f001 ff05 	bl	28a48 <z_unpend_first_thread>
	mutex->owner = new_owner;
   26c3e:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   26c40:	b1c0      	cbz	r0, 26c74 <z_impl_k_mutex_unlock+0xb8>
		mutex->owner_orig_prio = new_owner->base.prio;
   26c42:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26c46:	6123      	str	r3, [r4, #16]
   26c48:	2400      	movs	r4, #0
   26c4a:	f8c0 4088 	str.w	r4, [r0, #136]	; 0x88
		z_ready_thread(new_owner);
   26c4e:	f001 fb31 	bl	282b4 <z_ready_thread>
		z_reschedule(&lock, key);
   26c52:	4629      	mov	r1, r5
   26c54:	4819      	ldr	r0, [pc, #100]	; (26cbc <z_impl_k_mutex_unlock+0x100>)
   26c56:	f001 f899 	bl	27d8c <z_reschedule>
	return 0;
   26c5a:	4620      	mov	r0, r4
   26c5c:	e7c2      	b.n	26be4 <z_impl_k_mutex_unlock+0x28>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26c5e:	4e18      	ldr	r6, [pc, #96]	; (26cc0 <z_impl_k_mutex_unlock+0x104>)
   26c60:	228e      	movs	r2, #142	; 0x8e
   26c62:	4631      	mov	r1, r6
   26c64:	4814      	ldr	r0, [pc, #80]	; (26cb8 <z_impl_k_mutex_unlock+0xfc>)
   26c66:	f005 fc62 	bl	2c52e <assert_print>
   26c6a:	218e      	movs	r1, #142	; 0x8e
   26c6c:	4630      	mov	r0, r6
   26c6e:	f005 fc57 	bl	2c520 <assert_post_action>
   26c72:	e7da      	b.n	26c2a <z_impl_k_mutex_unlock+0x6e>
		mutex->lock_count = 0U;
   26c74:	2300      	movs	r3, #0
   26c76:	60e3      	str	r3, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26c78:	4810      	ldr	r0, [pc, #64]	; (26cbc <z_impl_k_mutex_unlock+0x100>)
   26c7a:	f7ff fd23 	bl	266c4 <z_spin_unlock_valid>
   26c7e:	b128      	cbz	r0, 26c8c <z_impl_k_mutex_unlock+0xd0>
	__asm__ volatile(
   26c80:	f385 8811 	msr	BASEPRI, r5
   26c84:	f3bf 8f6f 	isb	sy
	return 0;
   26c88:	2000      	movs	r0, #0
   26c8a:	e7ab      	b.n	26be4 <z_impl_k_mutex_unlock+0x28>
   26c8c:	4c0c      	ldr	r4, [pc, #48]	; (26cc0 <z_impl_k_mutex_unlock+0x104>)
   26c8e:	22b9      	movs	r2, #185	; 0xb9
   26c90:	4621      	mov	r1, r4
   26c92:	4809      	ldr	r0, [pc, #36]	; (26cb8 <z_impl_k_mutex_unlock+0xfc>)
   26c94:	f005 fc4b 	bl	2c52e <assert_print>
   26c98:	21b9      	movs	r1, #185	; 0xb9
   26c9a:	4620      	mov	r0, r4
   26c9c:	f005 fc40 	bl	2c520 <assert_post_action>
   26ca0:	e7ee      	b.n	26c80 <z_impl_k_mutex_unlock+0xc4>
		return -EINVAL;
   26ca2:	f06f 0015 	mvn.w	r0, #21
   26ca6:	e79d      	b.n	26be4 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   26ca8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26cac:	e79a      	b.n	26be4 <z_impl_k_mutex_unlock+0x28>
   26cae:	bf00      	nop
   26cb0:	200046a4 	.word	0x200046a4
   26cb4:	0003be50 	.word	0x0003be50
   26cb8:	00031600 	.word	0x00031600
   26cbc:	200046d4 	.word	0x200046d4
   26cc0:	000390f0 	.word	0x000390f0

00026cc4 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
   26cc4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26cc8:	4604      	mov	r4, r0
   26cca:	460e      	mov	r6, r1
   26ccc:	4615      	mov	r5, r2
   26cce:	4698      	mov	r8, r3
   26cd0:	f89d a028 	ldrb.w	sl, [sp, #40]	; 0x28
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   26cd4:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
   26cd8:	f04f 0340 	mov.w	r3, #64	; 0x40
   26cdc:	f3ef 8911 	mrs	r9, BASEPRI
   26ce0:	f383 8812 	msr	BASEPRI_MAX, r3
   26ce4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26ce8:	4638      	mov	r0, r7
   26cea:	f7ff fcdb 	bl	266a4 <z_spin_lock_valid>
   26cee:	b360      	cbz	r0, 26d4a <queue_insert+0x86>
	z_spin_lock_set_owner(l);
   26cf0:	4638      	mov	r0, r7
   26cf2:	f7ff fcf7 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
   26cf6:	f1ba 0f00 	cmp.w	sl, #0
   26cfa:	d000      	beq.n	26cfe <queue_insert+0x3a>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
   26cfc:	6866      	ldr	r6, [r4, #4]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   26cfe:	f104 000c 	add.w	r0, r4, #12
   26d02:	f001 fea1 	bl	28a48 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
   26d06:	bb60      	cbnz	r0, 26d62 <queue_insert+0x9e>

		return 0;
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   26d08:	f1b8 0f00 	cmp.w	r8, #0
   26d0c:	d132      	bne.n	26d74 <queue_insert+0xb0>
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   26d0e:	2300      	movs	r3, #0
   26d10:	602b      	str	r3, [r5, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   26d12:	2e00      	cmp	r6, #0
   26d14:	d04e      	beq.n	26db4 <queue_insert+0xf0>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   26d16:	6833      	ldr	r3, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   26d18:	f033 0303 	bics.w	r3, r3, #3
   26d1c:	d056      	beq.n	26dcc <queue_insert+0x108>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26d1e:	682a      	ldr	r2, [r5, #0]
   26d20:	f002 0203 	and.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   26d24:	4313      	orrs	r3, r2
   26d26:	602b      	str	r3, [r5, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26d28:	6833      	ldr	r3, [r6, #0]
   26d2a:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   26d2e:	431d      	orrs	r5, r3
   26d30:	6035      	str	r5, [r6, #0]
	z_handle_obj_poll_events(&queue->poll_events, state);
   26d32:	2104      	movs	r1, #4
   26d34:	f104 0014 	add.w	r0, r4, #20
   26d38:	f009 ffd3 	bl	30ce2 <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
   26d3c:	4649      	mov	r1, r9
   26d3e:	4638      	mov	r0, r7
   26d40:	f001 f824 	bl	27d8c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
   26d44:	2000      	movs	r0, #0
}
   26d46:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26d4a:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 26df0 <queue_insert+0x12c>
   26d4e:	228e      	movs	r2, #142	; 0x8e
   26d50:	4659      	mov	r1, fp
   26d52:	4826      	ldr	r0, [pc, #152]	; (26dec <queue_insert+0x128>)
   26d54:	f005 fbeb 	bl	2c52e <assert_print>
   26d58:	218e      	movs	r1, #142	; 0x8e
   26d5a:	4658      	mov	r0, fp
   26d5c:	f005 fbe0 	bl	2c520 <assert_post_action>
   26d60:	e7c6      	b.n	26cf0 <queue_insert+0x2c>
		prepare_thread_to_run(first_pending_thread, data);
   26d62:	4629      	mov	r1, r5
   26d64:	f009 fe24 	bl	309b0 <prepare_thread_to_run>
		z_reschedule(&queue->lock, key);
   26d68:	4649      	mov	r1, r9
   26d6a:	4638      	mov	r0, r7
   26d6c:	f001 f80e 	bl	27d8c <z_reschedule>
		return 0;
   26d70:	2000      	movs	r0, #0
   26d72:	e7e8      	b.n	26d46 <queue_insert+0x82>
	return z_thread_aligned_alloc(0, size);
   26d74:	2108      	movs	r1, #8
   26d76:	2000      	movs	r0, #0
   26d78:	f003 fb0c 	bl	2a394 <z_thread_aligned_alloc>
		if (anode == NULL) {
   26d7c:	b120      	cbz	r0, 26d88 <queue_insert+0xc4>
		anode->data = data;
   26d7e:	6045      	str	r5, [r0, #4]
	node->next_and_flags = flags;
   26d80:	2201      	movs	r2, #1
   26d82:	6002      	str	r2, [r0, #0]
		data = anode;
   26d84:	4605      	mov	r5, r0
   26d86:	e7c4      	b.n	26d12 <queue_insert+0x4e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26d88:	4638      	mov	r0, r7
   26d8a:	f7ff fc9b 	bl	266c4 <z_spin_unlock_valid>
   26d8e:	b130      	cbz	r0, 26d9e <queue_insert+0xda>
	__asm__ volatile(
   26d90:	f389 8811 	msr	BASEPRI, r9
   26d94:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   26d98:	f06f 000b 	mvn.w	r0, #11
   26d9c:	e7d3      	b.n	26d46 <queue_insert+0x82>
   26d9e:	4c14      	ldr	r4, [pc, #80]	; (26df0 <queue_insert+0x12c>)
   26da0:	22b9      	movs	r2, #185	; 0xb9
   26da2:	4621      	mov	r1, r4
   26da4:	4811      	ldr	r0, [pc, #68]	; (26dec <queue_insert+0x128>)
   26da6:	f005 fbc2 	bl	2c52e <assert_print>
   26daa:	21b9      	movs	r1, #185	; 0xb9
   26dac:	4620      	mov	r0, r4
   26dae:	f005 fbb7 	bl	2c520 <assert_post_action>
   26db2:	e7ed      	b.n	26d90 <queue_insert+0xcc>
	return list->head;
   26db4:	6822      	ldr	r2, [r4, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26db6:	682b      	ldr	r3, [r5, #0]
   26db8:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   26dbc:	4313      	orrs	r3, r2
   26dbe:	602b      	str	r3, [r5, #0]
	list->head = node;
   26dc0:	6025      	str	r5, [r4, #0]
	return list->tail;
   26dc2:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_PREPEND(sflist, sfnode)
   26dc4:	2b00      	cmp	r3, #0
   26dc6:	d1b4      	bne.n	26d32 <queue_insert+0x6e>
	list->tail = node;
   26dc8:	6065      	str	r5, [r4, #4]
}
   26dca:	e7b2      	b.n	26d32 <queue_insert+0x6e>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26dcc:	682b      	ldr	r3, [r5, #0]
   26dce:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   26dd2:	602b      	str	r3, [r5, #0]
	return list->tail;
   26dd4:	6862      	ldr	r2, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   26dd6:	b132      	cbz	r2, 26de6 <queue_insert+0x122>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26dd8:	6813      	ldr	r3, [r2, #0]
   26dda:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   26dde:	432b      	orrs	r3, r5
   26de0:	6013      	str	r3, [r2, #0]
	list->tail = node;
   26de2:	6065      	str	r5, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   26de4:	e7a5      	b.n	26d32 <queue_insert+0x6e>
	list->tail = node;
   26de6:	6065      	str	r5, [r4, #4]
	list->head = node;
   26de8:	6025      	str	r5, [r4, #0]
}
   26dea:	e7a2      	b.n	26d32 <queue_insert+0x6e>
   26dec:	00031600 	.word	0x00031600
   26df0:	000390f0 	.word	0x000390f0

00026df4 <k_queue_append_list>:
int k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, append_list, queue);

	/* invalid head or tail of list */
	CHECKIF(head == NULL || tail == NULL) {
   26df4:	2900      	cmp	r1, #0
   26df6:	d04b      	beq.n	26e90 <k_queue_append_list+0x9c>
{
   26df8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   26dfc:	4606      	mov	r6, r0
   26dfe:	4617      	mov	r7, r2
   26e00:	460c      	mov	r4, r1
	CHECKIF(head == NULL || tail == NULL) {
   26e02:	2a00      	cmp	r2, #0
   26e04:	d047      	beq.n	26e96 <k_queue_append_list+0xa2>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, -EINVAL);

		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   26e06:	f100 0808 	add.w	r8, r0, #8
	__asm__ volatile(
   26e0a:	f04f 0340 	mov.w	r3, #64	; 0x40
   26e0e:	f3ef 8911 	mrs	r9, BASEPRI
   26e12:	f383 8812 	msr	BASEPRI_MAX, r3
   26e16:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26e1a:	4640      	mov	r0, r8
   26e1c:	f7ff fc42 	bl	266a4 <z_spin_lock_valid>
   26e20:	b140      	cbz	r0, 26e34 <k_queue_append_list+0x40>
	z_spin_lock_set_owner(l);
   26e22:	4640      	mov	r0, r8
   26e24:	f7ff fc5e 	bl	266e4 <z_spin_lock_set_owner>
	struct k_thread *thread = NULL;

	if (head != NULL) {
		thread = z_unpend_first_thread(&queue->wait_q);
   26e28:	f106 050c 	add.w	r5, r6, #12
   26e2c:	4628      	mov	r0, r5
   26e2e:	f001 fe0b 	bl	28a48 <z_unpend_first_thread>
   26e32:	e011      	b.n	26e58 <k_queue_append_list+0x64>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26e34:	4d19      	ldr	r5, [pc, #100]	; (26e9c <k_queue_append_list+0xa8>)
   26e36:	228e      	movs	r2, #142	; 0x8e
   26e38:	4629      	mov	r1, r5
   26e3a:	4819      	ldr	r0, [pc, #100]	; (26ea0 <k_queue_append_list+0xac>)
   26e3c:	f005 fb77 	bl	2c52e <assert_print>
   26e40:	218e      	movs	r1, #142	; 0x8e
   26e42:	4628      	mov	r0, r5
   26e44:	f005 fb6c 	bl	2c520 <assert_post_action>
   26e48:	e7eb      	b.n	26e22 <k_queue_append_list+0x2e>
	}

	while ((head != NULL) && (thread != NULL)) {
		prepare_thread_to_run(thread, head);
   26e4a:	4621      	mov	r1, r4
   26e4c:	f009 fdb0 	bl	309b0 <prepare_thread_to_run>
		head = *(void **)head;
   26e50:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
   26e52:	4628      	mov	r0, r5
   26e54:	f001 fdf8 	bl	28a48 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   26e58:	b10c      	cbz	r4, 26e5e <k_queue_append_list+0x6a>
   26e5a:	2800      	cmp	r0, #0
   26e5c:	d1f5      	bne.n	26e4a <k_queue_append_list+0x56>
	}

	if (head != NULL) {
   26e5e:	b14c      	cbz	r4, 26e74 <k_queue_append_list+0x80>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   26e60:	b144      	cbz	r4, 26e74 <k_queue_append_list+0x80>
   26e62:	b13f      	cbz	r7, 26e74 <k_queue_append_list+0x80>
	return list->tail;
   26e64:	6872      	ldr	r2, [r6, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   26e66:	b18a      	cbz	r2, 26e8c <k_queue_append_list+0x98>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26e68:	6813      	ldr	r3, [r2, #0]
   26e6a:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   26e6e:	431c      	orrs	r4, r3
   26e70:	6014      	str	r4, [r2, #0]
	list->tail = node;
   26e72:	6077      	str	r7, [r6, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   26e74:	2104      	movs	r1, #4
   26e76:	f106 0014 	add.w	r0, r6, #20
   26e7a:	f009 ff32 	bl	30ce2 <z_handle_obj_poll_events>
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, append_list, queue, 0);

	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
   26e7e:	4649      	mov	r1, r9
   26e80:	4640      	mov	r0, r8
   26e82:	f000 ff83 	bl	27d8c <z_reschedule>
	return 0;
   26e86:	2000      	movs	r0, #0
}
   26e88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	list->head = node;
   26e8c:	6034      	str	r4, [r6, #0]
}
   26e8e:	e7f0      	b.n	26e72 <k_queue_append_list+0x7e>
		return -EINVAL;
   26e90:	f06f 0015 	mvn.w	r0, #21
}
   26e94:	4770      	bx	lr
		return -EINVAL;
   26e96:	f06f 0015 	mvn.w	r0, #21
   26e9a:	e7f5      	b.n	26e88 <k_queue_append_list+0x94>
   26e9c:	000390f0 	.word	0x000390f0
   26ea0:	00031600 	.word	0x00031600

00026ea4 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   26ea4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   26ea8:	b083      	sub	sp, #12
   26eaa:	4604      	mov	r4, r0
   26eac:	4690      	mov	r8, r2
   26eae:	461f      	mov	r7, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   26eb0:	f100 0508 	add.w	r5, r0, #8
   26eb4:	f04f 0340 	mov.w	r3, #64	; 0x40
   26eb8:	f3ef 8611 	mrs	r6, BASEPRI
   26ebc:	f383 8812 	msr	BASEPRI_MAX, r3
   26ec0:	f3bf 8f6f 	isb	sy
   26ec4:	4628      	mov	r0, r5
   26ec6:	f7ff fbed 	bl	266a4 <z_spin_lock_valid>
   26eca:	b1d8      	cbz	r0, 26f04 <z_impl_k_queue_get+0x60>
	z_spin_lock_set_owner(l);
   26ecc:	4628      	mov	r0, r5
   26ece:	f7ff fc09 	bl	266e4 <z_spin_lock_set_owner>
	return list->head;
   26ed2:	6820      	ldr	r0, [r4, #0]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   26ed4:	b378      	cbz	r0, 26f36 <z_impl_k_queue_get+0x92>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   26ed6:	6803      	ldr	r3, [r0, #0]
   26ed8:	f023 0303 	bic.w	r3, r3, #3
	list->head = node;
   26edc:	6023      	str	r3, [r4, #0]
	return list->tail;
   26ede:	6862      	ldr	r2, [r4, #4]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   26ee0:	4290      	cmp	r0, r2
   26ee2:	d01b      	beq.n	26f1c <z_impl_k_queue_get+0x78>
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   26ee4:	2101      	movs	r1, #1
   26ee6:	f009 fd6b 	bl	309c0 <z_queue_node_peek>
   26eea:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26eec:	4628      	mov	r0, r5
   26eee:	f7ff fbe9 	bl	266c4 <z_spin_unlock_valid>
   26ef2:	b1a8      	cbz	r0, 26f20 <z_impl_k_queue_get+0x7c>
	__asm__ volatile(
   26ef4:	f386 8811 	msr	BASEPRI, r6
   26ef8:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   26efc:	4620      	mov	r0, r4
   26efe:	b003      	add	sp, #12
   26f00:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26f04:	f8df 9084 	ldr.w	r9, [pc, #132]	; 26f8c <z_impl_k_queue_get+0xe8>
   26f08:	228e      	movs	r2, #142	; 0x8e
   26f0a:	4649      	mov	r1, r9
   26f0c:	481e      	ldr	r0, [pc, #120]	; (26f88 <z_impl_k_queue_get+0xe4>)
   26f0e:	f005 fb0e 	bl	2c52e <assert_print>
   26f12:	218e      	movs	r1, #142	; 0x8e
   26f14:	4648      	mov	r0, r9
   26f16:	f005 fb03 	bl	2c520 <assert_post_action>
   26f1a:	e7d7      	b.n	26ecc <z_impl_k_queue_get+0x28>
	list->tail = node;
   26f1c:	6063      	str	r3, [r4, #4]
}
   26f1e:	e7e1      	b.n	26ee4 <z_impl_k_queue_get+0x40>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26f20:	4d1a      	ldr	r5, [pc, #104]	; (26f8c <z_impl_k_queue_get+0xe8>)
   26f22:	22b9      	movs	r2, #185	; 0xb9
   26f24:	4629      	mov	r1, r5
   26f26:	4818      	ldr	r0, [pc, #96]	; (26f88 <z_impl_k_queue_get+0xe4>)
   26f28:	f005 fb01 	bl	2c52e <assert_print>
   26f2c:	21b9      	movs	r1, #185	; 0xb9
   26f2e:	4628      	mov	r0, r5
   26f30:	f005 faf6 	bl	2c520 <assert_post_action>
   26f34:	e7de      	b.n	26ef4 <z_impl_k_queue_get+0x50>
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   26f36:	ea57 0308 	orrs.w	r3, r7, r8
   26f3a:	d00d      	beq.n	26f58 <z_impl_k_queue_get+0xb4>
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   26f3c:	f8cd 8000 	str.w	r8, [sp]
   26f40:	9701      	str	r7, [sp, #4]
   26f42:	f104 020c 	add.w	r2, r4, #12
   26f46:	4631      	mov	r1, r6
   26f48:	4628      	mov	r0, r5
   26f4a:	f001 fb43 	bl	285d4 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   26f4e:	b9c0      	cbnz	r0, 26f82 <z_impl_k_queue_get+0xde>
   26f50:	4b0f      	ldr	r3, [pc, #60]	; (26f90 <z_impl_k_queue_get+0xec>)
   26f52:	689b      	ldr	r3, [r3, #8]
   26f54:	695c      	ldr	r4, [r3, #20]
   26f56:	e7d1      	b.n	26efc <z_impl_k_queue_get+0x58>
   26f58:	4628      	mov	r0, r5
   26f5a:	f7ff fbb3 	bl	266c4 <z_spin_unlock_valid>
   26f5e:	b128      	cbz	r0, 26f6c <z_impl_k_queue_get+0xc8>
   26f60:	f386 8811 	msr	BASEPRI, r6
   26f64:	f3bf 8f6f 	isb	sy
		return NULL;
   26f68:	2400      	movs	r4, #0
   26f6a:	e7c7      	b.n	26efc <z_impl_k_queue_get+0x58>
   26f6c:	4c07      	ldr	r4, [pc, #28]	; (26f8c <z_impl_k_queue_get+0xe8>)
   26f6e:	22b9      	movs	r2, #185	; 0xb9
   26f70:	4621      	mov	r1, r4
   26f72:	4805      	ldr	r0, [pc, #20]	; (26f88 <z_impl_k_queue_get+0xe4>)
   26f74:	f005 fadb 	bl	2c52e <assert_print>
   26f78:	21b9      	movs	r1, #185	; 0xb9
   26f7a:	4620      	mov	r0, r4
   26f7c:	f005 fad0 	bl	2c520 <assert_post_action>
   26f80:	e7ee      	b.n	26f60 <z_impl_k_queue_get+0xbc>
	return (ret != 0) ? NULL : _current->base.swap_data;
   26f82:	2400      	movs	r4, #0
   26f84:	e7ba      	b.n	26efc <z_impl_k_queue_get+0x58>
   26f86:	bf00      	nop
   26f88:	00031600 	.word	0x00031600
   26f8c:	000390f0 	.word	0x000390f0
   26f90:	200046a4 	.word	0x200046a4

00026f94 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   26f94:	b570      	push	{r4, r5, r6, lr}
   26f96:	4604      	mov	r4, r0
	__asm__ volatile(
   26f98:	f04f 0340 	mov.w	r3, #64	; 0x40
   26f9c:	f3ef 8511 	mrs	r5, BASEPRI
   26fa0:	f383 8812 	msr	BASEPRI_MAX, r3
   26fa4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26fa8:	4817      	ldr	r0, [pc, #92]	; (27008 <z_impl_k_sem_give+0x74>)
   26faa:	f7ff fb7b 	bl	266a4 <z_spin_lock_valid>
   26fae:	b180      	cbz	r0, 26fd2 <z_impl_k_sem_give+0x3e>
	z_spin_lock_set_owner(l);
   26fb0:	4815      	ldr	r0, [pc, #84]	; (27008 <z_impl_k_sem_give+0x74>)
   26fb2:	f7ff fb97 	bl	266e4 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   26fb6:	4620      	mov	r0, r4
   26fb8:	f001 fd46 	bl	28a48 <z_unpend_first_thread>

	if (thread != NULL) {
   26fbc:	b1a0      	cbz	r0, 26fe8 <z_impl_k_sem_give+0x54>
   26fbe:	2200      	movs	r2, #0
   26fc0:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   26fc4:	f001 f976 	bl	282b4 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   26fc8:	4629      	mov	r1, r5
   26fca:	480f      	ldr	r0, [pc, #60]	; (27008 <z_impl_k_sem_give+0x74>)
   26fcc:	f000 fede 	bl	27d8c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   26fd0:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26fd2:	4e0e      	ldr	r6, [pc, #56]	; (2700c <z_impl_k_sem_give+0x78>)
   26fd4:	228e      	movs	r2, #142	; 0x8e
   26fd6:	4631      	mov	r1, r6
   26fd8:	480d      	ldr	r0, [pc, #52]	; (27010 <z_impl_k_sem_give+0x7c>)
   26fda:	f005 faa8 	bl	2c52e <assert_print>
   26fde:	218e      	movs	r1, #142	; 0x8e
   26fe0:	4630      	mov	r0, r6
   26fe2:	f005 fa9d 	bl	2c520 <assert_post_action>
   26fe6:	e7e3      	b.n	26fb0 <z_impl_k_sem_give+0x1c>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   26fe8:	68a3      	ldr	r3, [r4, #8]
   26fea:	68e2      	ldr	r2, [r4, #12]
   26fec:	4293      	cmp	r3, r2
   26fee:	d008      	beq.n	27002 <z_impl_k_sem_give+0x6e>
   26ff0:	2201      	movs	r2, #1
   26ff2:	4413      	add	r3, r2
   26ff4:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   26ff6:	2102      	movs	r1, #2
   26ff8:	f104 0010 	add.w	r0, r4, #16
   26ffc:	f009 fe71 	bl	30ce2 <z_handle_obj_poll_events>
}
   27000:	e7e2      	b.n	26fc8 <z_impl_k_sem_give+0x34>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   27002:	2200      	movs	r2, #0
   27004:	e7f5      	b.n	26ff2 <z_impl_k_sem_give+0x5e>
   27006:	bf00      	nop
   27008:	200046d8 	.word	0x200046d8
   2700c:	000390f0 	.word	0x000390f0
   27010:	00031600 	.word	0x00031600

00027014 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   27014:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27018:	b082      	sub	sp, #8
   2701a:	4604      	mov	r4, r0
   2701c:	4617      	mov	r7, r2
   2701e:	461d      	mov	r5, r3
   27020:	f3ef 8105 	mrs	r1, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
   27024:	b111      	cbz	r1, 2702c <z_impl_k_sem_take+0x18>
   27026:	ea55 0302 	orrs.w	r3, r5, r2
   2702a:	d11e      	bne.n	2706a <z_impl_k_sem_take+0x56>
   2702c:	f04f 0340 	mov.w	r3, #64	; 0x40
   27030:	f3ef 8611 	mrs	r6, BASEPRI
   27034:	f383 8812 	msr	BASEPRI_MAX, r3
   27038:	f3bf 8f6f 	isb	sy
   2703c:	482c      	ldr	r0, [pc, #176]	; (270f0 <z_impl_k_sem_take+0xdc>)
   2703e:	f7ff fb31 	bl	266a4 <z_spin_lock_valid>
   27042:	b1e8      	cbz	r0, 27080 <z_impl_k_sem_take+0x6c>
	z_spin_lock_set_owner(l);
   27044:	482a      	ldr	r0, [pc, #168]	; (270f0 <z_impl_k_sem_take+0xdc>)
   27046:	f7ff fb4d 	bl	266e4 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   2704a:	68a1      	ldr	r1, [r4, #8]
   2704c:	b379      	cbz	r1, 270ae <z_impl_k_sem_take+0x9a>
		sem->count--;
   2704e:	3901      	subs	r1, #1
   27050:	60a1      	str	r1, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27052:	4827      	ldr	r0, [pc, #156]	; (270f0 <z_impl_k_sem_take+0xdc>)
   27054:	f7ff fb36 	bl	266c4 <z_spin_unlock_valid>
   27058:	b1f0      	cbz	r0, 27098 <z_impl_k_sem_take+0x84>
	__asm__ volatile(
   2705a:	f386 8811 	msr	BASEPRI, r6
   2705e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   27062:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   27064:	b002      	add	sp, #8
   27066:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT(((arch_is_in_isr() == false) ||
   2706a:	4e22      	ldr	r6, [pc, #136]	; (270f4 <z_impl_k_sem_take+0xe0>)
   2706c:	2279      	movs	r2, #121	; 0x79
   2706e:	4631      	mov	r1, r6
   27070:	4821      	ldr	r0, [pc, #132]	; (270f8 <z_impl_k_sem_take+0xe4>)
   27072:	f005 fa5c 	bl	2c52e <assert_print>
   27076:	2179      	movs	r1, #121	; 0x79
   27078:	4630      	mov	r0, r6
   2707a:	f005 fa51 	bl	2c520 <assert_post_action>
   2707e:	e7d5      	b.n	2702c <z_impl_k_sem_take+0x18>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27080:	f8df 8078 	ldr.w	r8, [pc, #120]	; 270fc <z_impl_k_sem_take+0xe8>
   27084:	228e      	movs	r2, #142	; 0x8e
   27086:	4641      	mov	r1, r8
   27088:	481b      	ldr	r0, [pc, #108]	; (270f8 <z_impl_k_sem_take+0xe4>)
   2708a:	f005 fa50 	bl	2c52e <assert_print>
   2708e:	218e      	movs	r1, #142	; 0x8e
   27090:	4640      	mov	r0, r8
   27092:	f005 fa45 	bl	2c520 <assert_post_action>
   27096:	e7d5      	b.n	27044 <z_impl_k_sem_take+0x30>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27098:	4c18      	ldr	r4, [pc, #96]	; (270fc <z_impl_k_sem_take+0xe8>)
   2709a:	22b9      	movs	r2, #185	; 0xb9
   2709c:	4621      	mov	r1, r4
   2709e:	4816      	ldr	r0, [pc, #88]	; (270f8 <z_impl_k_sem_take+0xe4>)
   270a0:	f005 fa45 	bl	2c52e <assert_print>
   270a4:	21b9      	movs	r1, #185	; 0xb9
   270a6:	4620      	mov	r0, r4
   270a8:	f005 fa3a 	bl	2c520 <assert_post_action>
   270ac:	e7d5      	b.n	2705a <z_impl_k_sem_take+0x46>
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   270ae:	ea55 0307 	orrs.w	r3, r5, r7
   270b2:	d007      	beq.n	270c4 <z_impl_k_sem_take+0xb0>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   270b4:	9700      	str	r7, [sp, #0]
   270b6:	9501      	str	r5, [sp, #4]
   270b8:	4622      	mov	r2, r4
   270ba:	4631      	mov	r1, r6
   270bc:	480c      	ldr	r0, [pc, #48]	; (270f0 <z_impl_k_sem_take+0xdc>)
   270be:	f001 fa89 	bl	285d4 <z_pend_curr>
	return ret;
   270c2:	e7cf      	b.n	27064 <z_impl_k_sem_take+0x50>
   270c4:	480a      	ldr	r0, [pc, #40]	; (270f0 <z_impl_k_sem_take+0xdc>)
   270c6:	f7ff fafd 	bl	266c4 <z_spin_unlock_valid>
   270ca:	b130      	cbz	r0, 270da <z_impl_k_sem_take+0xc6>
   270cc:	f386 8811 	msr	BASEPRI, r6
   270d0:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   270d4:	f06f 000f 	mvn.w	r0, #15
   270d8:	e7c4      	b.n	27064 <z_impl_k_sem_take+0x50>
   270da:	4c08      	ldr	r4, [pc, #32]	; (270fc <z_impl_k_sem_take+0xe8>)
   270dc:	22b9      	movs	r2, #185	; 0xb9
   270de:	4621      	mov	r1, r4
   270e0:	4805      	ldr	r0, [pc, #20]	; (270f8 <z_impl_k_sem_take+0xe4>)
   270e2:	f005 fa24 	bl	2c52e <assert_print>
   270e6:	21b9      	movs	r1, #185	; 0xb9
   270e8:	4620      	mov	r0, r4
   270ea:	f005 fa19 	bl	2c520 <assert_post_action>
   270ee:	e7ed      	b.n	270cc <z_impl_k_sem_take+0xb8>
   270f0:	200046d8 	.word	0x200046d8
   270f4:	0003be74 	.word	0x0003be74
   270f8:	00031600 	.word	0x00031600
   270fc:	000390f0 	.word	0x000390f0

00027100 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   27100:	b510      	push	{r4, lr}
   27102:	b084      	sub	sp, #16
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
   27104:	4b08      	ldr	r3, [pc, #32]	; (27128 <k_sys_work_q_init+0x28>)
   27106:	9302      	str	r3, [sp, #8]
   27108:	2400      	movs	r4, #0
   2710a:	f88d 400c 	strb.w	r4, [sp, #12]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   2710e:	ab02      	add	r3, sp, #8
   27110:	9300      	str	r3, [sp, #0]
   27112:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   27116:	f44f 6200 	mov.w	r2, #2048	; 0x800
   2711a:	4904      	ldr	r1, [pc, #16]	; (2712c <k_sys_work_q_init+0x2c>)
   2711c:	4804      	ldr	r0, [pc, #16]	; (27130 <k_sys_work_q_init+0x30>)
   2711e:	f000 fabf 	bl	276a0 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   27122:	4620      	mov	r0, r4
   27124:	b004      	add	sp, #16
   27126:	bd10      	pop	{r4, pc}
   27128:	0003be94 	.word	0x0003be94
   2712c:	20007400 	.word	0x20007400
   27130:	20002770 	.word	0x20002770

00027134 <submit_to_queue_locked>:
 * @retval -EINVAL if no queue is provided
 * @retval -ENODEV if the queue is not started
 */
static int submit_to_queue_locked(struct k_work *work,
				  struct k_work_q **queuep)
{
   27134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27136:	460d      	mov	r5, r1
	return (*flagp & BIT(bit)) != 0U;
   27138:	68c3      	ldr	r3, [r0, #12]
	int ret = 0;

	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2713a:	f013 0f02 	tst.w	r3, #2
   2713e:	d16e      	bne.n	2721e <submit_to_queue_locked+0xea>
   27140:	4604      	mov	r4, r0
		/* Disallowed */
		ret = -EBUSY;
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   27142:	f013 0f04 	tst.w	r3, #4
   27146:	d16f      	bne.n	27228 <submit_to_queue_locked+0xf4>
		/* Not currently queued */
		ret = 1;

		/* If no queue specified resubmit to last queue.
		 */
		if (*queuep == NULL) {
   27148:	680b      	ldr	r3, [r1, #0]
   2714a:	2b00      	cmp	r3, #0
   2714c:	d03d      	beq.n	271ca <submit_to_queue_locked+0x96>
	return (*flagp & BIT(bit)) != 0U;
   2714e:	68e3      	ldr	r3, [r4, #12]

		/* If the work is currently running we have to use the
		 * queue it's running on to prevent handler
		 * re-entrancy.
		 */
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   27150:	f013 0f01 	tst.w	r3, #1
   27154:	d049      	beq.n	271ea <submit_to_queue_locked+0xb6>
			__ASSERT_NO_MSG(work->queue != NULL);
   27156:	68a3      	ldr	r3, [r4, #8]
   27158:	2b00      	cmp	r3, #0
   2715a:	d039      	beq.n	271d0 <submit_to_queue_locked+0x9c>
			*queuep = work->queue;
   2715c:	68a3      	ldr	r3, [r4, #8]
   2715e:	602b      	str	r3, [r5, #0]
			ret = 2;
   27160:	2702      	movs	r7, #2
		}

		int rc = queue_submit_locked(*queuep, work);
   27162:	682e      	ldr	r6, [r5, #0]
	if (queue == NULL) {
   27164:	2e00      	cmp	r6, #0
   27166:	d04e      	beq.n	27206 <submit_to_queue_locked+0xd2>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   27168:	4b30      	ldr	r3, [pc, #192]	; (2722c <submit_to_queue_locked+0xf8>)
   2716a:	689b      	ldr	r3, [r3, #8]
   2716c:	42b3      	cmp	r3, r6
   2716e:	d03e      	beq.n	271ee <submit_to_queue_locked+0xba>
   27170:	2300      	movs	r3, #0
   27172:	461a      	mov	r2, r3
	return (*flagp & BIT(bit)) != 0U;
   27174:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
   27178:	f3c3 0180 	ubfx	r1, r3, #2, #1
   2717c:	f3c3 00c0 	ubfx	r0, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   27180:	f013 0f01 	tst.w	r3, #1
   27184:	d042      	beq.n	2720c <submit_to_queue_locked+0xd8>
	} else if (draining && !chained) {
   27186:	b109      	cbz	r1, 2718c <submit_to_queue_locked+0x58>
   27188:	2a00      	cmp	r2, #0
   2718a:	d042      	beq.n	27212 <submit_to_queue_locked+0xde>
	} else if (plugged && !draining) {
   2718c:	b108      	cbz	r0, 27192 <submit_to_queue_locked+0x5e>
   2718e:	2900      	cmp	r1, #0
   27190:	d042      	beq.n	27218 <submit_to_queue_locked+0xe4>
	parent->next = child;
   27192:	2300      	movs	r3, #0
   27194:	6023      	str	r3, [r4, #0]
	return list->tail;
   27196:	f8d6 30d4 	ldr.w	r3, [r6, #212]	; 0xd4
Z_GENLIST_APPEND(slist, snode)
   2719a:	b37b      	cbz	r3, 271fc <submit_to_queue_locked+0xc8>
	parent->next = child;
   2719c:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2719e:	f8c6 40d4 	str.w	r4, [r6, #212]	; 0xd4
	if (queue != NULL) {
   271a2:	b12e      	cbz	r6, 271b0 <submit_to_queue_locked+0x7c>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   271a4:	2200      	movs	r2, #0
   271a6:	4611      	mov	r1, r2
   271a8:	f106 00d8 	add.w	r0, r6, #216	; 0xd8
   271ac:	f001 fec8 	bl	28f40 <z_sched_wake>
		ret = 1;
   271b0:	2001      	movs	r0, #1

		if (rc < 0) {
   271b2:	2800      	cmp	r0, #0
   271b4:	db06      	blt.n	271c4 <submit_to_queue_locked+0x90>
	*flagp |= BIT(bit);
   271b6:	68e3      	ldr	r3, [r4, #12]
   271b8:	f043 0304 	orr.w	r3, r3, #4
   271bc:	60e3      	str	r3, [r4, #12]
			ret = rc;
		} else {
			flag_set(&work->flags, K_WORK_QUEUED_BIT);
			work->queue = *queuep;
   271be:	682b      	ldr	r3, [r5, #0]
   271c0:	60a3      	str	r3, [r4, #8]
   271c2:	4638      	mov	r0, r7
		}
	} else {
		/* Already queued, do nothing. */
	}

	if (ret <= 0) {
   271c4:	2800      	cmp	r0, #0
   271c6:	dc2e      	bgt.n	27226 <submit_to_queue_locked+0xf2>
   271c8:	e02b      	b.n	27222 <submit_to_queue_locked+0xee>
			*queuep = work->queue;
   271ca:	6883      	ldr	r3, [r0, #8]
   271cc:	600b      	str	r3, [r1, #0]
   271ce:	e7be      	b.n	2714e <submit_to_queue_locked+0x1a>
			__ASSERT_NO_MSG(work->queue != NULL);
   271d0:	4e17      	ldr	r6, [pc, #92]	; (27230 <submit_to_queue_locked+0xfc>)
   271d2:	f44f 72a7 	mov.w	r2, #334	; 0x14e
   271d6:	4631      	mov	r1, r6
   271d8:	4816      	ldr	r0, [pc, #88]	; (27234 <submit_to_queue_locked+0x100>)
   271da:	f005 f9a8 	bl	2c52e <assert_print>
   271de:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   271e2:	4630      	mov	r0, r6
   271e4:	f005 f99c 	bl	2c520 <assert_post_action>
   271e8:	e7b8      	b.n	2715c <submit_to_queue_locked+0x28>
		ret = 1;
   271ea:	2701      	movs	r7, #1
   271ec:	e7b9      	b.n	27162 <submit_to_queue_locked+0x2e>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   271ee:	f009 fb8d 	bl	3090c <k_is_in_isr>
   271f2:	b908      	cbnz	r0, 271f8 <submit_to_queue_locked+0xc4>
   271f4:	2301      	movs	r3, #1
   271f6:	e7bc      	b.n	27172 <submit_to_queue_locked+0x3e>
   271f8:	2300      	movs	r3, #0
   271fa:	e7ba      	b.n	27172 <submit_to_queue_locked+0x3e>
   271fc:	f8c6 40d4 	str.w	r4, [r6, #212]	; 0xd4
	list->head = node;
   27200:	f8c6 40d0 	str.w	r4, [r6, #208]	; 0xd0
}
   27204:	e7cd      	b.n	271a2 <submit_to_queue_locked+0x6e>
		return -EINVAL;
   27206:	f06f 0015 	mvn.w	r0, #21
   2720a:	e7d2      	b.n	271b2 <submit_to_queue_locked+0x7e>
		ret = -ENODEV;
   2720c:	f06f 0012 	mvn.w	r0, #18
   27210:	e7cf      	b.n	271b2 <submit_to_queue_locked+0x7e>
		ret = -EBUSY;
   27212:	f06f 000f 	mvn.w	r0, #15
   27216:	e7cc      	b.n	271b2 <submit_to_queue_locked+0x7e>
		ret = -EBUSY;
   27218:	f06f 000f 	mvn.w	r0, #15
   2721c:	e7c9      	b.n	271b2 <submit_to_queue_locked+0x7e>
		ret = -EBUSY;
   2721e:	f06f 000f 	mvn.w	r0, #15
		*queuep = NULL;
   27222:	2300      	movs	r3, #0
   27224:	602b      	str	r3, [r5, #0]
	}

	return ret;
}
   27226:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int ret = 0;
   27228:	2000      	movs	r0, #0
   2722a:	e7fa      	b.n	27222 <submit_to_queue_locked+0xee>
   2722c:	200046a4 	.word	0x200046a4
   27230:	0003bea0 	.word	0x0003bea0
   27234:	00031600 	.word	0x00031600

00027238 <work_timeout>:
 * Invoked by timeout infrastructure.
 * Takes and releases work lock.
 * Conditionally reschedules.
 */
static void work_timeout(struct _timeout *to)
{
   27238:	b5f0      	push	{r4, r5, r6, r7, lr}
   2723a:	b083      	sub	sp, #12
   2723c:	4604      	mov	r4, r0
	struct k_work_delayable *dw
		= CONTAINER_OF(to, struct k_work_delayable, timeout);
	struct k_work *wp = &dw->work;
   2723e:	f1a0 0610 	sub.w	r6, r0, #16
	__asm__ volatile(
   27242:	f04f 0340 	mov.w	r3, #64	; 0x40
   27246:	f3ef 8511 	mrs	r5, BASEPRI
   2724a:	f383 8812 	msr	BASEPRI_MAX, r3
   2724e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27252:	481c      	ldr	r0, [pc, #112]	; (272c4 <work_timeout+0x8c>)
   27254:	f7ff fa26 	bl	266a4 <z_spin_lock_valid>
   27258:	b1b8      	cbz	r0, 2728a <work_timeout+0x52>
	z_spin_lock_set_owner(l);
   2725a:	481a      	ldr	r0, [pc, #104]	; (272c4 <work_timeout+0x8c>)
   2725c:	f7ff fa42 	bl	266e4 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_work_q *queue = NULL;
   27260:	2300      	movs	r3, #0
   27262:	9301      	str	r3, [sp, #4]
	return (*flagp & BIT(bit)) != 0U;
   27264:	f854 3c04 	ldr.w	r3, [r4, #-4]
	*flagp &= ~BIT(bit);
   27268:	f023 0208 	bic.w	r2, r3, #8
   2726c:	f844 2c04 	str.w	r2, [r4, #-4]
	 * notified of new work at the next reschedule point.
	 *
	 * If not successful there is no notification that the work has been
	 * abandoned.  Sorry.
	 */
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   27270:	f013 0f08 	tst.w	r3, #8
   27274:	d114      	bne.n	272a0 <work_timeout+0x68>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27276:	4813      	ldr	r0, [pc, #76]	; (272c4 <work_timeout+0x8c>)
   27278:	f7ff fa24 	bl	266c4 <z_spin_unlock_valid>
   2727c:	b1b8      	cbz	r0, 272ae <work_timeout+0x76>
	__asm__ volatile(
   2727e:	f385 8811 	msr	BASEPRI, r5
   27282:	f3bf 8f6f 	isb	sy
		queue = dw->queue;
		(void)submit_to_queue_locked(wp, &queue);
	}

	k_spin_unlock(&lock, key);
}
   27286:	b003      	add	sp, #12
   27288:	bdf0      	pop	{r4, r5, r6, r7, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2728a:	4f0f      	ldr	r7, [pc, #60]	; (272c8 <work_timeout+0x90>)
   2728c:	228e      	movs	r2, #142	; 0x8e
   2728e:	4639      	mov	r1, r7
   27290:	480e      	ldr	r0, [pc, #56]	; (272cc <work_timeout+0x94>)
   27292:	f005 f94c 	bl	2c52e <assert_print>
   27296:	218e      	movs	r1, #142	; 0x8e
   27298:	4638      	mov	r0, r7
   2729a:	f005 f941 	bl	2c520 <assert_post_action>
   2729e:	e7dc      	b.n	2725a <work_timeout+0x22>
		queue = dw->queue;
   272a0:	69a3      	ldr	r3, [r4, #24]
   272a2:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   272a4:	a901      	add	r1, sp, #4
   272a6:	4630      	mov	r0, r6
   272a8:	f7ff ff44 	bl	27134 <submit_to_queue_locked>
   272ac:	e7e3      	b.n	27276 <work_timeout+0x3e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   272ae:	4c06      	ldr	r4, [pc, #24]	; (272c8 <work_timeout+0x90>)
   272b0:	22b9      	movs	r2, #185	; 0xb9
   272b2:	4621      	mov	r1, r4
   272b4:	4805      	ldr	r0, [pc, #20]	; (272cc <work_timeout+0x94>)
   272b6:	f005 f93a 	bl	2c52e <assert_print>
   272ba:	21b9      	movs	r1, #185	; 0xb9
   272bc:	4620      	mov	r0, r4
   272be:	f005 f92f 	bl	2c520 <assert_post_action>
   272c2:	e7dc      	b.n	2727e <work_timeout+0x46>
   272c4:	200046dc 	.word	0x200046dc
   272c8:	000390f0 	.word	0x000390f0
   272cc:	00031600 	.word	0x00031600

000272d0 <cancel_sync_locked>:
{
   272d0:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
   272d2:	68c5      	ldr	r5, [r0, #12]
   272d4:	f015 0f02 	tst.w	r5, #2
   272d8:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (ret) {
   272dc:	d101      	bne.n	272e2 <cancel_sync_locked+0x12>
}
   272de:	4628      	mov	r0, r5
   272e0:	bd70      	pop	{r4, r5, r6, pc}
   272e2:	4604      	mov	r4, r0
   272e4:	460e      	mov	r6, r1
	k_sem_init(&canceler->sem, 0, 1);
   272e6:	f101 0008 	add.w	r0, r1, #8
	return z_impl_k_sem_init(sem, initial_count, limit);
   272ea:	2201      	movs	r2, #1
   272ec:	2100      	movs	r1, #0
   272ee:	f009 fb9a 	bl	30a26 <z_impl_k_sem_init>
	canceler->work = work;
   272f2:	6074      	str	r4, [r6, #4]
	parent->next = child;
   272f4:	2300      	movs	r3, #0
   272f6:	6033      	str	r3, [r6, #0]
	return list->tail;
   272f8:	4b05      	ldr	r3, [pc, #20]	; (27310 <cancel_sync_locked+0x40>)
   272fa:	685b      	ldr	r3, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
   272fc:	b11b      	cbz	r3, 27306 <cancel_sync_locked+0x36>
	parent->next = child;
   272fe:	601e      	str	r6, [r3, #0]
	list->tail = node;
   27300:	4b03      	ldr	r3, [pc, #12]	; (27310 <cancel_sync_locked+0x40>)
   27302:	605e      	str	r6, [r3, #4]
}
   27304:	e7eb      	b.n	272de <cancel_sync_locked+0xe>
   27306:	4b02      	ldr	r3, [pc, #8]	; (27310 <cancel_sync_locked+0x40>)
   27308:	605e      	str	r6, [r3, #4]
	list->head = node;
   2730a:	601e      	str	r6, [r3, #0]
}
   2730c:	e7e7      	b.n	272de <cancel_sync_locked+0xe>
   2730e:	bf00      	nop
   27310:	200046e0 	.word	0x200046e0

00027314 <schedule_for_queue_locked>:
 * @retval 1 to indicate successfully scheduled.
 */
static int schedule_for_queue_locked(struct k_work_q **queuep,
				     struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   27314:	b508      	push	{r3, lr}
   27316:	4684      	mov	ip, r0
   27318:	4608      	mov	r0, r1
	int ret = 1;
	struct k_work *work = &dwork->work;

	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2731a:	ea53 0102 	orrs.w	r1, r3, r2
   2731e:	d00c      	beq.n	2733a <schedule_for_queue_locked+0x26>
	*flagp |= BIT(bit);
   27320:	68c1      	ldr	r1, [r0, #12]
   27322:	f041 0108 	orr.w	r1, r1, #8
   27326:	60c1      	str	r1, [r0, #12]
		return submit_to_queue_locked(work, queuep);
	}

	flag_set(&work->flags, K_WORK_DELAYED_BIT);
	dwork->queue = *queuep;
   27328:	f8dc 1000 	ldr.w	r1, [ip]
   2732c:	6281      	str	r1, [r0, #40]	; 0x28

	/* Add timeout */
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   2732e:	4905      	ldr	r1, [pc, #20]	; (27344 <schedule_for_queue_locked+0x30>)
   27330:	3010      	adds	r0, #16
   27332:	f001 fedb 	bl	290ec <z_add_timeout>

	return ret;
   27336:	2001      	movs	r0, #1
}
   27338:	bd08      	pop	{r3, pc}
		return submit_to_queue_locked(work, queuep);
   2733a:	4661      	mov	r1, ip
   2733c:	f7ff fefa 	bl	27134 <submit_to_queue_locked>
   27340:	e7fa      	b.n	27338 <schedule_for_queue_locked+0x24>
   27342:	bf00      	nop
   27344:	00027239 	.word	0x00027239

00027348 <finalize_cancel_locked>:
{
   27348:	b570      	push	{r4, r5, r6, lr}
   2734a:	4605      	mov	r5, r0
	*flagp &= ~BIT(bit);
   2734c:	68c3      	ldr	r3, [r0, #12]
   2734e:	f023 0302 	bic.w	r3, r3, #2
   27352:	60c3      	str	r3, [r0, #12]
	return list->head;
   27354:	4b1a      	ldr	r3, [pc, #104]	; (273c0 <finalize_cancel_locked+0x78>)
   27356:	681b      	ldr	r3, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   27358:	b1fb      	cbz	r3, 2739a <finalize_cancel_locked+0x52>
   2735a:	461c      	mov	r4, r3
Z_GENLIST_PEEK_NEXT(slist, snode)
   2735c:	b103      	cbz	r3, 27360 <finalize_cancel_locked+0x18>
	return node->next;
   2735e:	681c      	ldr	r4, [r3, #0]
   27360:	2600      	movs	r6, #0
   27362:	e01f      	b.n	273a4 <finalize_cancel_locked+0x5c>
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   27364:	461a      	mov	r2, r3
Z_GENLIST_REMOVE(slist, snode)
   27366:	b166      	cbz	r6, 27382 <finalize_cancel_locked+0x3a>
	return node->next;
   27368:	6819      	ldr	r1, [r3, #0]
	parent->next = child;
   2736a:	6031      	str	r1, [r6, #0]
	return list->tail;
   2736c:	4914      	ldr	r1, [pc, #80]	; (273c0 <finalize_cancel_locked+0x78>)
   2736e:	6849      	ldr	r1, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   27370:	428b      	cmp	r3, r1
   27372:	d00f      	beq.n	27394 <finalize_cancel_locked+0x4c>
	parent->next = child;
   27374:	2100      	movs	r1, #0
   27376:	6011      	str	r1, [r2, #0]
			k_sem_give(&wc->sem);
   27378:	f103 0008 	add.w	r0, r3, #8
	z_impl_k_sem_give(sem);
   2737c:	f7ff fe0a 	bl	26f94 <z_impl_k_sem_give>
}
   27380:	e015      	b.n	273ae <finalize_cancel_locked+0x66>
	return node->next;
   27382:	6818      	ldr	r0, [r3, #0]
	list->head = node;
   27384:	490e      	ldr	r1, [pc, #56]	; (273c0 <finalize_cancel_locked+0x78>)
   27386:	6008      	str	r0, [r1, #0]
	return list->tail;
   27388:	6849      	ldr	r1, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   2738a:	428b      	cmp	r3, r1
   2738c:	d1f2      	bne.n	27374 <finalize_cancel_locked+0x2c>
	list->tail = node;
   2738e:	490c      	ldr	r1, [pc, #48]	; (273c0 <finalize_cancel_locked+0x78>)
   27390:	6048      	str	r0, [r1, #4]
}
   27392:	e7ef      	b.n	27374 <finalize_cancel_locked+0x2c>
	list->tail = node;
   27394:	490a      	ldr	r1, [pc, #40]	; (273c0 <finalize_cancel_locked+0x78>)
   27396:	604e      	str	r6, [r1, #4]
}
   27398:	e7ec      	b.n	27374 <finalize_cancel_locked+0x2c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   2739a:	461c      	mov	r4, r3
   2739c:	e7e0      	b.n	27360 <finalize_cancel_locked+0x18>
   2739e:	4622      	mov	r2, r4
   273a0:	4623      	mov	r3, r4
   273a2:	4614      	mov	r4, r2
   273a4:	b153      	cbz	r3, 273bc <finalize_cancel_locked+0x74>
		if (wc->work == work) {
   273a6:	685a      	ldr	r2, [r3, #4]
   273a8:	42aa      	cmp	r2, r5
   273aa:	d0db      	beq.n	27364 <finalize_cancel_locked+0x1c>
			prev = &wc->node;
   273ac:	461e      	mov	r6, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   273ae:	2c00      	cmp	r4, #0
   273b0:	d0f5      	beq.n	2739e <finalize_cancel_locked+0x56>
   273b2:	4622      	mov	r2, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
   273b4:	2c00      	cmp	r4, #0
   273b6:	d0f3      	beq.n	273a0 <finalize_cancel_locked+0x58>
	return node->next;
   273b8:	6822      	ldr	r2, [r4, #0]
   273ba:	e7f1      	b.n	273a0 <finalize_cancel_locked+0x58>
}
   273bc:	bd70      	pop	{r4, r5, r6, pc}
   273be:	bf00      	nop
   273c0:	200046e0 	.word	0x200046e0

000273c4 <work_queue_main>:
{
   273c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   273c8:	b084      	sub	sp, #16
   273ca:	4605      	mov	r5, r0
	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
   273cc:	e021      	b.n	27412 <work_queue_main+0x4e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   273ce:	4c64      	ldr	r4, [pc, #400]	; (27560 <work_queue_main+0x19c>)
   273d0:	228e      	movs	r2, #142	; 0x8e
   273d2:	4621      	mov	r1, r4
   273d4:	4863      	ldr	r0, [pc, #396]	; (27564 <work_queue_main+0x1a0>)
   273d6:	f005 f8aa 	bl	2c52e <assert_print>
   273da:	218e      	movs	r1, #142	; 0x8e
   273dc:	4620      	mov	r0, r4
   273de:	f005 f89f 	bl	2c520 <assert_post_action>
   273e2:	e023      	b.n	2742c <work_queue_main+0x68>
	return (*flagp & BIT(bit)) != 0U;
   273e4:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
	*flagp &= ~BIT(bit);
   273e8:	f023 0204 	bic.w	r2, r3, #4
   273ec:	f8c5 20e8 	str.w	r2, [r5, #232]	; 0xe8
		} else if (flag_test_and_clear(&queue->flags,
   273f0:	f013 0f04 	tst.w	r3, #4
   273f4:	d175      	bne.n	274e2 <work_queue_main+0x11e>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   273f6:	2300      	movs	r3, #0
   273f8:	9302      	str	r3, [sp, #8]
   273fa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   273fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   27402:	e9cd 2300 	strd	r2, r3, [sp]
   27406:	f105 02d8 	add.w	r2, r5, #216	; 0xd8
   2740a:	4631      	mov	r1, r6
   2740c:	4856      	ldr	r0, [pc, #344]	; (27568 <work_queue_main+0x1a4>)
   2740e:	f001 fdf9 	bl	29004 <z_sched_wait>
	__asm__ volatile(
   27412:	f04f 0340 	mov.w	r3, #64	; 0x40
   27416:	f3ef 8611 	mrs	r6, BASEPRI
   2741a:	f383 8812 	msr	BASEPRI_MAX, r3
   2741e:	f3bf 8f6f 	isb	sy
   27422:	4851      	ldr	r0, [pc, #324]	; (27568 <work_queue_main+0x1a4>)
   27424:	f7ff f93e 	bl	266a4 <z_spin_lock_valid>
   27428:	2800      	cmp	r0, #0
   2742a:	d0d0      	beq.n	273ce <work_queue_main+0xa>
	z_spin_lock_set_owner(l);
   2742c:	484e      	ldr	r0, [pc, #312]	; (27568 <work_queue_main+0x1a4>)
   2742e:	f7ff f959 	bl	266e4 <z_spin_lock_set_owner>
	return list->head;
   27432:	f8d5 40d0 	ldr.w	r4, [r5, #208]	; 0xd0
Z_GENLIST_GET(slist, snode)
   27436:	2c00      	cmp	r4, #0
   27438:	d0d4      	beq.n	273e4 <work_queue_main+0x20>
	return node->next;
   2743a:	6823      	ldr	r3, [r4, #0]
	list->head = node;
   2743c:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	return list->tail;
   27440:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   27444:	4294      	cmp	r4, r2
   27446:	d049      	beq.n	274dc <work_queue_main+0x118>
	*flagp |= BIT(bit);
   27448:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
   2744c:	f043 0302 	orr.w	r3, r3, #2
   27450:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
   27454:	68e3      	ldr	r3, [r4, #12]
   27456:	f043 0301 	orr.w	r3, r3, #1
   2745a:	60e3      	str	r3, [r4, #12]
	*flagp &= ~BIT(bit);
   2745c:	f023 0304 	bic.w	r3, r3, #4
   27460:	60e3      	str	r3, [r4, #12]
			handler = work->handler;
   27462:	6867      	ldr	r7, [r4, #4]
		if (work == NULL) {
   27464:	2c00      	cmp	r4, #0
   27466:	d0c6      	beq.n	273f6 <work_queue_main+0x32>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27468:	483f      	ldr	r0, [pc, #252]	; (27568 <work_queue_main+0x1a4>)
   2746a:	f7ff f92b 	bl	266c4 <z_spin_unlock_valid>
   2746e:	2800      	cmp	r0, #0
   27470:	d042      	beq.n	274f8 <work_queue_main+0x134>
	__asm__ volatile(
   27472:	f386 8811 	msr	BASEPRI, r6
   27476:	f3bf 8f6f 	isb	sy
		__ASSERT_NO_MSG(handler != NULL);
   2747a:	2f00      	cmp	r7, #0
   2747c:	d048      	beq.n	27510 <work_queue_main+0x14c>
		handler(work);
   2747e:	4620      	mov	r0, r4
   27480:	47b8      	blx	r7
	__asm__ volatile(
   27482:	f04f 0340 	mov.w	r3, #64	; 0x40
   27486:	f3ef 8611 	mrs	r6, BASEPRI
   2748a:	f383 8812 	msr	BASEPRI_MAX, r3
   2748e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27492:	4835      	ldr	r0, [pc, #212]	; (27568 <work_queue_main+0x1a4>)
   27494:	f7ff f906 	bl	266a4 <z_spin_lock_valid>
   27498:	2800      	cmp	r0, #0
   2749a:	d046      	beq.n	2752a <work_queue_main+0x166>
	z_spin_lock_set_owner(l);
   2749c:	4832      	ldr	r0, [pc, #200]	; (27568 <work_queue_main+0x1a4>)
   2749e:	f7ff f921 	bl	266e4 <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
   274a2:	68e3      	ldr	r3, [r4, #12]
   274a4:	f023 0301 	bic.w	r3, r3, #1
   274a8:	60e3      	str	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   274aa:	f013 0f02 	tst.w	r3, #2
   274ae:	d147      	bne.n	27540 <work_queue_main+0x17c>
	*flagp &= ~BIT(bit);
   274b0:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
   274b4:	f023 0302 	bic.w	r3, r3, #2
   274b8:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
	return (*flagp & BIT(bit)) != 0U;
   274bc:	f3c3 2400 	ubfx	r4, r3, #8, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   274c0:	4829      	ldr	r0, [pc, #164]	; (27568 <work_queue_main+0x1a4>)
   274c2:	f7ff f8ff 	bl	266c4 <z_spin_unlock_valid>
   274c6:	2800      	cmp	r0, #0
   274c8:	d03e      	beq.n	27548 <work_queue_main+0x184>
	__asm__ volatile(
   274ca:	f386 8811 	msr	BASEPRI, r6
   274ce:	f3bf 8f6f 	isb	sy
		if (yield) {
   274d2:	2c00      	cmp	r4, #0
   274d4:	d19d      	bne.n	27412 <work_queue_main+0x4e>
	z_impl_k_yield();
   274d6:	f001 fb15 	bl	28b04 <z_impl_k_yield>
}
   274da:	e79a      	b.n	27412 <work_queue_main+0x4e>
	list->tail = node;
   274dc:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
}
   274e0:	e7b2      	b.n	27448 <work_queue_main+0x84>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   274e2:	f105 07e0 	add.w	r7, r5, #224	; 0xe0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   274e6:	2200      	movs	r2, #0
   274e8:	2101      	movs	r1, #1
   274ea:	4638      	mov	r0, r7
   274ec:	f001 fd28 	bl	28f40 <z_sched_wake>
   274f0:	2800      	cmp	r0, #0
   274f2:	d1f8      	bne.n	274e6 <work_queue_main+0x122>
		k_work_handler_t handler = NULL;
   274f4:	2700      	movs	r7, #0
   274f6:	e7b5      	b.n	27464 <work_queue_main+0xa0>
   274f8:	f8df 8064 	ldr.w	r8, [pc, #100]	; 27560 <work_queue_main+0x19c>
   274fc:	22b9      	movs	r2, #185	; 0xb9
   274fe:	4641      	mov	r1, r8
   27500:	4818      	ldr	r0, [pc, #96]	; (27564 <work_queue_main+0x1a0>)
   27502:	f005 f814 	bl	2c52e <assert_print>
   27506:	21b9      	movs	r1, #185	; 0xb9
   27508:	4640      	mov	r0, r8
   2750a:	f005 f809 	bl	2c520 <assert_post_action>
   2750e:	e7b0      	b.n	27472 <work_queue_main+0xae>
		__ASSERT_NO_MSG(handler != NULL);
   27510:	4e16      	ldr	r6, [pc, #88]	; (2756c <work_queue_main+0x1a8>)
   27512:	f240 229b 	movw	r2, #667	; 0x29b
   27516:	4631      	mov	r1, r6
   27518:	4812      	ldr	r0, [pc, #72]	; (27564 <work_queue_main+0x1a0>)
   2751a:	f005 f808 	bl	2c52e <assert_print>
   2751e:	f240 219b 	movw	r1, #667	; 0x29b
   27522:	4630      	mov	r0, r6
   27524:	f004 fffc 	bl	2c520 <assert_post_action>
   27528:	e7a9      	b.n	2747e <work_queue_main+0xba>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2752a:	4f0d      	ldr	r7, [pc, #52]	; (27560 <work_queue_main+0x19c>)
   2752c:	228e      	movs	r2, #142	; 0x8e
   2752e:	4639      	mov	r1, r7
   27530:	480c      	ldr	r0, [pc, #48]	; (27564 <work_queue_main+0x1a0>)
   27532:	f004 fffc 	bl	2c52e <assert_print>
   27536:	218e      	movs	r1, #142	; 0x8e
   27538:	4638      	mov	r0, r7
   2753a:	f004 fff1 	bl	2c520 <assert_post_action>
   2753e:	e7ad      	b.n	2749c <work_queue_main+0xd8>
			finalize_cancel_locked(work);
   27540:	4620      	mov	r0, r4
   27542:	f7ff ff01 	bl	27348 <finalize_cancel_locked>
   27546:	e7b3      	b.n	274b0 <work_queue_main+0xec>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27548:	4f05      	ldr	r7, [pc, #20]	; (27560 <work_queue_main+0x19c>)
   2754a:	22b9      	movs	r2, #185	; 0xb9
   2754c:	4639      	mov	r1, r7
   2754e:	4805      	ldr	r0, [pc, #20]	; (27564 <work_queue_main+0x1a0>)
   27550:	f004 ffed 	bl	2c52e <assert_print>
   27554:	21b9      	movs	r1, #185	; 0xb9
   27556:	4638      	mov	r0, r7
   27558:	f004 ffe2 	bl	2c520 <assert_post_action>
   2755c:	e7b5      	b.n	274ca <work_queue_main+0x106>
   2755e:	bf00      	nop
   27560:	000390f0 	.word	0x000390f0
   27564:	00031600 	.word	0x00031600
   27568:	200046dc 	.word	0x200046dc
   2756c:	0003bea0 	.word	0x0003bea0

00027570 <k_work_init>:
{
   27570:	b570      	push	{r4, r5, r6, lr}
   27572:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(work != NULL);
   27574:	4604      	mov	r4, r0
   27576:	b138      	cbz	r0, 27588 <k_work_init+0x18>
	__ASSERT_NO_MSG(handler != NULL);
   27578:	b18d      	cbz	r5, 2759e <k_work_init+0x2e>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   2757a:	2300      	movs	r3, #0
   2757c:	6023      	str	r3, [r4, #0]
   2757e:	6063      	str	r3, [r4, #4]
   27580:	60a3      	str	r3, [r4, #8]
   27582:	60e3      	str	r3, [r4, #12]
   27584:	6065      	str	r5, [r4, #4]
}
   27586:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(work != NULL);
   27588:	4e0a      	ldr	r6, [pc, #40]	; (275b4 <k_work_init+0x44>)
   2758a:	2289      	movs	r2, #137	; 0x89
   2758c:	4631      	mov	r1, r6
   2758e:	480a      	ldr	r0, [pc, #40]	; (275b8 <k_work_init+0x48>)
   27590:	f004 ffcd 	bl	2c52e <assert_print>
   27594:	2189      	movs	r1, #137	; 0x89
   27596:	4630      	mov	r0, r6
   27598:	f004 ffc2 	bl	2c520 <assert_post_action>
   2759c:	e7ec      	b.n	27578 <k_work_init+0x8>
	__ASSERT_NO_MSG(handler != NULL);
   2759e:	4e05      	ldr	r6, [pc, #20]	; (275b4 <k_work_init+0x44>)
   275a0:	228a      	movs	r2, #138	; 0x8a
   275a2:	4631      	mov	r1, r6
   275a4:	4804      	ldr	r0, [pc, #16]	; (275b8 <k_work_init+0x48>)
   275a6:	f004 ffc2 	bl	2c52e <assert_print>
   275aa:	218a      	movs	r1, #138	; 0x8a
   275ac:	4630      	mov	r0, r6
   275ae:	f004 ffb7 	bl	2c520 <assert_post_action>
   275b2:	e7e2      	b.n	2757a <k_work_init+0xa>
   275b4:	0003bea0 	.word	0x0003bea0
   275b8:	00031600 	.word	0x00031600

000275bc <z_work_submit_to_queue>:
{
   275bc:	b570      	push	{r4, r5, r6, lr}
   275be:	b082      	sub	sp, #8
   275c0:	9001      	str	r0, [sp, #4]
	__ASSERT_NO_MSG(work != NULL);
   275c2:	460c      	mov	r4, r1
   275c4:	b1f9      	cbz	r1, 27606 <z_work_submit_to_queue+0x4a>
	__asm__ volatile(
   275c6:	f04f 0340 	mov.w	r3, #64	; 0x40
   275ca:	f3ef 8611 	mrs	r6, BASEPRI
   275ce:	f383 8812 	msr	BASEPRI_MAX, r3
   275d2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   275d6:	481d      	ldr	r0, [pc, #116]	; (2764c <z_work_submit_to_queue+0x90>)
   275d8:	f7ff f864 	bl	266a4 <z_spin_lock_valid>
   275dc:	b300      	cbz	r0, 27620 <z_work_submit_to_queue+0x64>
	z_spin_lock_set_owner(l);
   275de:	4d1b      	ldr	r5, [pc, #108]	; (2764c <z_work_submit_to_queue+0x90>)
   275e0:	4628      	mov	r0, r5
   275e2:	f7ff f87f 	bl	266e4 <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
   275e6:	a901      	add	r1, sp, #4
   275e8:	4620      	mov	r0, r4
   275ea:	f7ff fda3 	bl	27134 <submit_to_queue_locked>
   275ee:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   275f0:	4628      	mov	r0, r5
   275f2:	f7ff f867 	bl	266c4 <z_spin_unlock_valid>
   275f6:	b1f0      	cbz	r0, 27636 <z_work_submit_to_queue+0x7a>
	__asm__ volatile(
   275f8:	f386 8811 	msr	BASEPRI, r6
   275fc:	f3bf 8f6f 	isb	sy
}
   27600:	4620      	mov	r0, r4
   27602:	b002      	add	sp, #8
   27604:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(work != NULL);
   27606:	4d12      	ldr	r5, [pc, #72]	; (27650 <z_work_submit_to_queue+0x94>)
   27608:	f44f 72ba 	mov.w	r2, #372	; 0x174
   2760c:	4629      	mov	r1, r5
   2760e:	4811      	ldr	r0, [pc, #68]	; (27654 <z_work_submit_to_queue+0x98>)
   27610:	f004 ff8d 	bl	2c52e <assert_print>
   27614:	f44f 71ba 	mov.w	r1, #372	; 0x174
   27618:	4628      	mov	r0, r5
   2761a:	f004 ff81 	bl	2c520 <assert_post_action>
   2761e:	e7d2      	b.n	275c6 <z_work_submit_to_queue+0xa>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27620:	4d0d      	ldr	r5, [pc, #52]	; (27658 <z_work_submit_to_queue+0x9c>)
   27622:	228e      	movs	r2, #142	; 0x8e
   27624:	4629      	mov	r1, r5
   27626:	480b      	ldr	r0, [pc, #44]	; (27654 <z_work_submit_to_queue+0x98>)
   27628:	f004 ff81 	bl	2c52e <assert_print>
   2762c:	218e      	movs	r1, #142	; 0x8e
   2762e:	4628      	mov	r0, r5
   27630:	f004 ff76 	bl	2c520 <assert_post_action>
   27634:	e7d3      	b.n	275de <z_work_submit_to_queue+0x22>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27636:	4d08      	ldr	r5, [pc, #32]	; (27658 <z_work_submit_to_queue+0x9c>)
   27638:	22b9      	movs	r2, #185	; 0xb9
   2763a:	4629      	mov	r1, r5
   2763c:	4805      	ldr	r0, [pc, #20]	; (27654 <z_work_submit_to_queue+0x98>)
   2763e:	f004 ff76 	bl	2c52e <assert_print>
   27642:	21b9      	movs	r1, #185	; 0xb9
   27644:	4628      	mov	r0, r5
   27646:	f004 ff6b 	bl	2c520 <assert_post_action>
   2764a:	e7d5      	b.n	275f8 <z_work_submit_to_queue+0x3c>
   2764c:	200046dc 	.word	0x200046dc
   27650:	0003bea0 	.word	0x0003bea0
   27654:	00031600 	.word	0x00031600
   27658:	000390f0 	.word	0x000390f0

0002765c <k_work_submit>:
{
   2765c:	b508      	push	{r3, lr}
   2765e:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
   27660:	4801      	ldr	r0, [pc, #4]	; (27668 <k_work_submit+0xc>)
   27662:	f009 fa3d 	bl	30ae0 <k_work_submit_to_queue>
}
   27666:	bd08      	pop	{r3, pc}
   27668:	20002770 	.word	0x20002770

0002766c <k_work_queue_init>:
{
   2766c:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(queue != NULL);
   2766e:	4604      	mov	r4, r0
   27670:	b128      	cbz	r0, 2767e <k_work_queue_init+0x12>
	*queue = (struct k_work_q) {
   27672:	22f0      	movs	r2, #240	; 0xf0
   27674:	2100      	movs	r1, #0
   27676:	4620      	mov	r0, r4
   27678:	f009 fc16 	bl	30ea8 <memset>
}
   2767c:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(queue != NULL);
   2767e:	4d06      	ldr	r5, [pc, #24]	; (27698 <k_work_queue_init+0x2c>)
   27680:	f240 22b9 	movw	r2, #697	; 0x2b9
   27684:	4629      	mov	r1, r5
   27686:	4805      	ldr	r0, [pc, #20]	; (2769c <k_work_queue_init+0x30>)
   27688:	f004 ff51 	bl	2c52e <assert_print>
   2768c:	f240 21b9 	movw	r1, #697	; 0x2b9
   27690:	4628      	mov	r0, r5
   27692:	f004 ff45 	bl	2c520 <assert_post_action>
   27696:	e7ec      	b.n	27672 <k_work_queue_init+0x6>
   27698:	0003bea0 	.word	0x0003bea0
   2769c:	00031600 	.word	0x00031600

000276a0 <k_work_queue_start>:
{
   276a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   276a4:	b089      	sub	sp, #36	; 0x24
   276a6:	460d      	mov	r5, r1
   276a8:	4617      	mov	r7, r2
   276aa:	4698      	mov	r8, r3
   276ac:	9e10      	ldr	r6, [sp, #64]	; 0x40
	__ASSERT_NO_MSG(queue);
   276ae:	4604      	mov	r4, r0
   276b0:	2800      	cmp	r0, #0
   276b2:	d03e      	beq.n	27732 <k_work_queue_start+0x92>
	__ASSERT_NO_MSG(stack);
   276b4:	2d00      	cmp	r5, #0
   276b6:	d04a      	beq.n	2774e <k_work_queue_start+0xae>
	return (*flagp & BIT(bit)) != 0U;
   276b8:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
   276bc:	f013 0f01 	tst.w	r3, #1
   276c0:	d153      	bne.n	2776a <k_work_queue_start+0xca>
	list->head = NULL;
   276c2:	2300      	movs	r3, #0
   276c4:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	list->tail = NULL;
   276c8:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
   276cc:	f104 03d8 	add.w	r3, r4, #216	; 0xd8
	list->head = (sys_dnode_t *)list;
   276d0:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
	list->tail = (sys_dnode_t *)list;
   276d4:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
   276d8:	f104 03e0 	add.w	r3, r4, #224	; 0xe0
	list->head = (sys_dnode_t *)list;
   276dc:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
	list->tail = (sys_dnode_t *)list;
   276e0:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	if ((cfg != NULL) && cfg->no_yield) {
   276e4:	2e00      	cmp	r6, #0
   276e6:	d04e      	beq.n	27786 <k_work_queue_start+0xe6>
   276e8:	7933      	ldrb	r3, [r6, #4]
   276ea:	2b00      	cmp	r3, #0
   276ec:	d14d      	bne.n	2778a <k_work_queue_start+0xea>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   276ee:	2301      	movs	r3, #1
	*flagp = flags;
   276f0:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   276f4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   276f8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   276fc:	e9cd 2306 	strd	r2, r3, [sp, #24]
   27700:	2200      	movs	r2, #0
   27702:	9204      	str	r2, [sp, #16]
   27704:	f8cd 800c 	str.w	r8, [sp, #12]
   27708:	9202      	str	r2, [sp, #8]
   2770a:	9201      	str	r2, [sp, #4]
   2770c:	9400      	str	r4, [sp, #0]
   2770e:	4b20      	ldr	r3, [pc, #128]	; (27790 <k_work_queue_start+0xf0>)
   27710:	463a      	mov	r2, r7
   27712:	4629      	mov	r1, r5
   27714:	4620      	mov	r0, r4
   27716:	f7fe ff15 	bl	26544 <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
   2771a:	b126      	cbz	r6, 27726 <k_work_queue_start+0x86>
   2771c:	6831      	ldr	r1, [r6, #0]
   2771e:	b111      	cbz	r1, 27726 <k_work_queue_start+0x86>
	return z_impl_k_thread_name_set(thread, str);
   27720:	4620      	mov	r0, r4
   27722:	f009 f8f9 	bl	30918 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   27726:	4620      	mov	r0, r4
   27728:	f009 f8fb 	bl	30922 <z_impl_k_thread_start>
}
   2772c:	b009      	add	sp, #36	; 0x24
   2772e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__ASSERT_NO_MSG(queue);
   27732:	f8df 9064 	ldr.w	r9, [pc, #100]	; 27798 <k_work_queue_start+0xf8>
   27736:	f44f 7232 	mov.w	r2, #712	; 0x2c8
   2773a:	4649      	mov	r1, r9
   2773c:	4815      	ldr	r0, [pc, #84]	; (27794 <k_work_queue_start+0xf4>)
   2773e:	f004 fef6 	bl	2c52e <assert_print>
   27742:	f44f 7132 	mov.w	r1, #712	; 0x2c8
   27746:	4648      	mov	r0, r9
   27748:	f004 feea 	bl	2c520 <assert_post_action>
   2774c:	e7b2      	b.n	276b4 <k_work_queue_start+0x14>
	__ASSERT_NO_MSG(stack);
   2774e:	f8df 9048 	ldr.w	r9, [pc, #72]	; 27798 <k_work_queue_start+0xf8>
   27752:	f240 22c9 	movw	r2, #713	; 0x2c9
   27756:	4649      	mov	r1, r9
   27758:	480e      	ldr	r0, [pc, #56]	; (27794 <k_work_queue_start+0xf4>)
   2775a:	f004 fee8 	bl	2c52e <assert_print>
   2775e:	f240 21c9 	movw	r1, #713	; 0x2c9
   27762:	4648      	mov	r0, r9
   27764:	f004 fedc 	bl	2c520 <assert_post_action>
   27768:	e7a6      	b.n	276b8 <k_work_queue_start+0x18>
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
   2776a:	f8df 902c 	ldr.w	r9, [pc, #44]	; 27798 <k_work_queue_start+0xf8>
   2776e:	f240 22ca 	movw	r2, #714	; 0x2ca
   27772:	4649      	mov	r1, r9
   27774:	4807      	ldr	r0, [pc, #28]	; (27794 <k_work_queue_start+0xf4>)
   27776:	f004 feda 	bl	2c52e <assert_print>
   2777a:	f240 21ca 	movw	r1, #714	; 0x2ca
   2777e:	4648      	mov	r0, r9
   27780:	f004 fece 	bl	2c520 <assert_post_action>
   27784:	e79d      	b.n	276c2 <k_work_queue_start+0x22>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   27786:	2301      	movs	r3, #1
   27788:	e7b2      	b.n	276f0 <k_work_queue_start+0x50>
		flags |= K_WORK_QUEUE_NO_YIELD;
   2778a:	f240 1301 	movw	r3, #257	; 0x101
   2778e:	e7af      	b.n	276f0 <k_work_queue_start+0x50>
   27790:	000273c5 	.word	0x000273c5
   27794:	00031600 	.word	0x00031600
   27798:	0003bea0 	.word	0x0003bea0

0002779c <k_work_init_delayable>:
{
   2779c:	b570      	push	{r4, r5, r6, lr}
   2779e:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(dwork != NULL);
   277a0:	4605      	mov	r5, r0
   277a2:	b150      	cbz	r0, 277ba <k_work_init_delayable+0x1e>
	__ASSERT_NO_MSG(handler != NULL);
   277a4:	b1b4      	cbz	r4, 277d4 <k_work_init_delayable+0x38>
	*dwork = (struct k_work_delayable){
   277a6:	2230      	movs	r2, #48	; 0x30
   277a8:	2100      	movs	r1, #0
   277aa:	4628      	mov	r0, r5
   277ac:	f009 fb7c 	bl	30ea8 <memset>
   277b0:	606c      	str	r4, [r5, #4]
   277b2:	f44f 7380 	mov.w	r3, #256	; 0x100
   277b6:	60eb      	str	r3, [r5, #12]
}
   277b8:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(dwork != NULL);
   277ba:	4e0d      	ldr	r6, [pc, #52]	; (277f0 <k_work_init_delayable+0x54>)
   277bc:	f44f 7250 	mov.w	r2, #832	; 0x340
   277c0:	4631      	mov	r1, r6
   277c2:	480c      	ldr	r0, [pc, #48]	; (277f4 <k_work_init_delayable+0x58>)
   277c4:	f004 feb3 	bl	2c52e <assert_print>
   277c8:	f44f 7150 	mov.w	r1, #832	; 0x340
   277cc:	4630      	mov	r0, r6
   277ce:	f004 fea7 	bl	2c520 <assert_post_action>
   277d2:	e7e7      	b.n	277a4 <k_work_init_delayable+0x8>
	__ASSERT_NO_MSG(handler != NULL);
   277d4:	4e06      	ldr	r6, [pc, #24]	; (277f0 <k_work_init_delayable+0x54>)
   277d6:	f240 3241 	movw	r2, #833	; 0x341
   277da:	4631      	mov	r1, r6
   277dc:	4805      	ldr	r0, [pc, #20]	; (277f4 <k_work_init_delayable+0x58>)
   277de:	f004 fea6 	bl	2c52e <assert_print>
   277e2:	f240 3141 	movw	r1, #833	; 0x341
   277e6:	4630      	mov	r0, r6
   277e8:	f004 fe9a 	bl	2c520 <assert_post_action>
   277ec:	e7db      	b.n	277a6 <k_work_init_delayable+0xa>
   277ee:	bf00      	nop
   277f0:	0003bea0 	.word	0x0003bea0
   277f4:	00031600 	.word	0x00031600

000277f8 <k_work_delayable_busy_get>:
{
   277f8:	b570      	push	{r4, r5, r6, lr}
   277fa:	4604      	mov	r4, r0
	__asm__ volatile(
   277fc:	f04f 0340 	mov.w	r3, #64	; 0x40
   27800:	f3ef 8611 	mrs	r6, BASEPRI
   27804:	f383 8812 	msr	BASEPRI_MAX, r3
   27808:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2780c:	4815      	ldr	r0, [pc, #84]	; (27864 <k_work_delayable_busy_get+0x6c>)
   2780e:	f7fe ff49 	bl	266a4 <z_spin_lock_valid>
   27812:	b180      	cbz	r0, 27836 <k_work_delayable_busy_get+0x3e>
	z_spin_lock_set_owner(l);
   27814:	4d13      	ldr	r5, [pc, #76]	; (27864 <k_work_delayable_busy_get+0x6c>)
   27816:	4628      	mov	r0, r5
   27818:	f7fe ff64 	bl	266e4 <z_spin_lock_set_owner>
	return *flagp;
   2781c:	68e4      	ldr	r4, [r4, #12]
	return flags_get(&dwork->work.flags) & K_WORK_MASK;
   2781e:	f004 040f 	and.w	r4, r4, #15
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27822:	4628      	mov	r0, r5
   27824:	f7fe ff4e 	bl	266c4 <z_spin_unlock_valid>
   27828:	b180      	cbz	r0, 2784c <k_work_delayable_busy_get+0x54>
	__asm__ volatile(
   2782a:	f386 8811 	msr	BASEPRI, r6
   2782e:	f3bf 8f6f 	isb	sy
}
   27832:	4620      	mov	r0, r4
   27834:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27836:	4d0c      	ldr	r5, [pc, #48]	; (27868 <k_work_delayable_busy_get+0x70>)
   27838:	228e      	movs	r2, #142	; 0x8e
   2783a:	4629      	mov	r1, r5
   2783c:	480b      	ldr	r0, [pc, #44]	; (2786c <k_work_delayable_busy_get+0x74>)
   2783e:	f004 fe76 	bl	2c52e <assert_print>
   27842:	218e      	movs	r1, #142	; 0x8e
   27844:	4628      	mov	r0, r5
   27846:	f004 fe6b 	bl	2c520 <assert_post_action>
   2784a:	e7e3      	b.n	27814 <k_work_delayable_busy_get+0x1c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2784c:	4d06      	ldr	r5, [pc, #24]	; (27868 <k_work_delayable_busy_get+0x70>)
   2784e:	22b9      	movs	r2, #185	; 0xb9
   27850:	4629      	mov	r1, r5
   27852:	4806      	ldr	r0, [pc, #24]	; (2786c <k_work_delayable_busy_get+0x74>)
   27854:	f004 fe6b 	bl	2c52e <assert_print>
   27858:	21b9      	movs	r1, #185	; 0xb9
   2785a:	4628      	mov	r0, r5
   2785c:	f004 fe60 	bl	2c520 <assert_post_action>
   27860:	e7e3      	b.n	2782a <k_work_delayable_busy_get+0x32>
   27862:	bf00      	nop
   27864:	200046dc 	.word	0x200046dc
   27868:	000390f0 	.word	0x000390f0
   2786c:	00031600 	.word	0x00031600

00027870 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
   27870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27874:	b082      	sub	sp, #8
   27876:	9001      	str	r0, [sp, #4]
   27878:	4617      	mov	r7, r2
   2787a:	461d      	mov	r5, r3
	__ASSERT_NO_MSG(dwork != NULL);
   2787c:	460c      	mov	r4, r1
   2787e:	b1f9      	cbz	r1, 278c0 <k_work_schedule_for_queue+0x50>
	__asm__ volatile(
   27880:	f04f 0340 	mov.w	r3, #64	; 0x40
   27884:	f3ef 8611 	mrs	r6, BASEPRI
   27888:	f383 8812 	msr	BASEPRI_MAX, r3
   2788c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27890:	4821      	ldr	r0, [pc, #132]	; (27918 <k_work_schedule_for_queue+0xa8>)
   27892:	f7fe ff07 	bl	266a4 <z_spin_lock_valid>
   27896:	b300      	cbz	r0, 278da <k_work_schedule_for_queue+0x6a>
	z_spin_lock_set_owner(l);
   27898:	481f      	ldr	r0, [pc, #124]	; (27918 <k_work_schedule_for_queue+0xa8>)
   2789a:	f7fe ff23 	bl	266e4 <z_spin_lock_set_owner>
	return *flagp;
   2789e:	68e1      	ldr	r1, [r4, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   278a0:	f011 0f0e 	tst.w	r1, #14
   278a4:	d025      	beq.n	278f2 <k_work_schedule_for_queue+0x82>
	int ret = 0;
   278a6:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   278a8:	481b      	ldr	r0, [pc, #108]	; (27918 <k_work_schedule_for_queue+0xa8>)
   278aa:	f7fe ff0b 	bl	266c4 <z_spin_unlock_valid>
   278ae:	b340      	cbz	r0, 27902 <k_work_schedule_for_queue+0x92>
	__asm__ volatile(
   278b0:	f386 8811 	msr	BASEPRI, r6
   278b4:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   278b8:	4620      	mov	r0, r4
   278ba:	b002      	add	sp, #8
   278bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(dwork != NULL);
   278c0:	4e16      	ldr	r6, [pc, #88]	; (2791c <k_work_schedule_for_queue+0xac>)
   278c2:	f240 32b7 	movw	r2, #951	; 0x3b7
   278c6:	4631      	mov	r1, r6
   278c8:	4815      	ldr	r0, [pc, #84]	; (27920 <k_work_schedule_for_queue+0xb0>)
   278ca:	f004 fe30 	bl	2c52e <assert_print>
   278ce:	f240 31b7 	movw	r1, #951	; 0x3b7
   278d2:	4630      	mov	r0, r6
   278d4:	f004 fe24 	bl	2c520 <assert_post_action>
   278d8:	e7d2      	b.n	27880 <k_work_schedule_for_queue+0x10>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   278da:	f8df 8048 	ldr.w	r8, [pc, #72]	; 27924 <k_work_schedule_for_queue+0xb4>
   278de:	228e      	movs	r2, #142	; 0x8e
   278e0:	4641      	mov	r1, r8
   278e2:	480f      	ldr	r0, [pc, #60]	; (27920 <k_work_schedule_for_queue+0xb0>)
   278e4:	f004 fe23 	bl	2c52e <assert_print>
   278e8:	218e      	movs	r1, #142	; 0x8e
   278ea:	4640      	mov	r0, r8
   278ec:	f004 fe18 	bl	2c520 <assert_post_action>
   278f0:	e7d2      	b.n	27898 <k_work_schedule_for_queue+0x28>
		ret = schedule_for_queue_locked(&queue, dwork, delay);
   278f2:	463a      	mov	r2, r7
   278f4:	462b      	mov	r3, r5
   278f6:	4621      	mov	r1, r4
   278f8:	a801      	add	r0, sp, #4
   278fa:	f7ff fd0b 	bl	27314 <schedule_for_queue_locked>
   278fe:	4604      	mov	r4, r0
   27900:	e7d2      	b.n	278a8 <k_work_schedule_for_queue+0x38>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27902:	4d08      	ldr	r5, [pc, #32]	; (27924 <k_work_schedule_for_queue+0xb4>)
   27904:	22b9      	movs	r2, #185	; 0xb9
   27906:	4629      	mov	r1, r5
   27908:	4805      	ldr	r0, [pc, #20]	; (27920 <k_work_schedule_for_queue+0xb0>)
   2790a:	f004 fe10 	bl	2c52e <assert_print>
   2790e:	21b9      	movs	r1, #185	; 0xb9
   27910:	4628      	mov	r0, r5
   27912:	f004 fe05 	bl	2c520 <assert_post_action>
   27916:	e7cb      	b.n	278b0 <k_work_schedule_for_queue+0x40>
   27918:	200046dc 	.word	0x200046dc
   2791c:	0003bea0 	.word	0x0003bea0
   27920:	00031600 	.word	0x00031600
   27924:	000390f0 	.word	0x000390f0

00027928 <k_work_schedule>:

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
   27928:	b508      	push	{r3, lr}
   2792a:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
   2792c:	4801      	ldr	r0, [pc, #4]	; (27934 <k_work_schedule+0xc>)
   2792e:	f7ff ff9f 	bl	27870 <k_work_schedule_for_queue>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule, dwork, delay, ret);

	return ret;
}
   27932:	bd08      	pop	{r3, pc}
   27934:	20002770 	.word	0x20002770

00027938 <k_work_reschedule_for_queue>:

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
   27938:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2793c:	b082      	sub	sp, #8
   2793e:	9001      	str	r0, [sp, #4]
   27940:	4616      	mov	r6, r2
   27942:	461d      	mov	r5, r3
	__ASSERT_NO_MSG(dwork != NULL);
   27944:	460c      	mov	r4, r1
   27946:	b341      	cbz	r1, 2799a <k_work_reschedule_for_queue+0x62>
	__asm__ volatile(
   27948:	f04f 0340 	mov.w	r3, #64	; 0x40
   2794c:	f3ef 8711 	mrs	r7, BASEPRI
   27950:	f383 8812 	msr	BASEPRI_MAX, r3
   27954:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27958:	4824      	ldr	r0, [pc, #144]	; (279ec <k_work_reschedule_for_queue+0xb4>)
   2795a:	f7fe fea3 	bl	266a4 <z_spin_lock_valid>
   2795e:	b348      	cbz	r0, 279b4 <k_work_reschedule_for_queue+0x7c>
	z_spin_lock_set_owner(l);
   27960:	4822      	ldr	r0, [pc, #136]	; (279ec <k_work_reschedule_for_queue+0xb4>)
   27962:	f7fe febf 	bl	266e4 <z_spin_lock_set_owner>
	return (*flagp & BIT(bit)) != 0U;
   27966:	68e3      	ldr	r3, [r4, #12]
	*flagp &= ~BIT(bit);
   27968:	f023 0208 	bic.w	r2, r3, #8
   2796c:	60e2      	str	r2, [r4, #12]
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   2796e:	f013 0f08 	tst.w	r3, #8
   27972:	d12b      	bne.n	279cc <k_work_reschedule_for_queue+0x94>

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);

	/* Schedule the work item with the new parameters. */
	ret = schedule_for_queue_locked(&queue, dwork, delay);
   27974:	4632      	mov	r2, r6
   27976:	462b      	mov	r3, r5
   27978:	4621      	mov	r1, r4
   2797a:	a801      	add	r0, sp, #4
   2797c:	f7ff fcca 	bl	27314 <schedule_for_queue_locked>
   27980:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27982:	481a      	ldr	r0, [pc, #104]	; (279ec <k_work_reschedule_for_queue+0xb4>)
   27984:	f7fe fe9e 	bl	266c4 <z_spin_unlock_valid>
   27988:	b328      	cbz	r0, 279d6 <k_work_reschedule_for_queue+0x9e>
	__asm__ volatile(
   2798a:	f387 8811 	msr	BASEPRI, r7
   2798e:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   27992:	4620      	mov	r0, r4
   27994:	b002      	add	sp, #8
   27996:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(dwork != NULL);
   2799a:	4f15      	ldr	r7, [pc, #84]	; (279f0 <k_work_reschedule_for_queue+0xb8>)
   2799c:	f240 32db 	movw	r2, #987	; 0x3db
   279a0:	4639      	mov	r1, r7
   279a2:	4814      	ldr	r0, [pc, #80]	; (279f4 <k_work_reschedule_for_queue+0xbc>)
   279a4:	f004 fdc3 	bl	2c52e <assert_print>
   279a8:	f240 31db 	movw	r1, #987	; 0x3db
   279ac:	4638      	mov	r0, r7
   279ae:	f004 fdb7 	bl	2c520 <assert_post_action>
   279b2:	e7c9      	b.n	27948 <k_work_reschedule_for_queue+0x10>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   279b4:	f8df 8040 	ldr.w	r8, [pc, #64]	; 279f8 <k_work_reschedule_for_queue+0xc0>
   279b8:	228e      	movs	r2, #142	; 0x8e
   279ba:	4641      	mov	r1, r8
   279bc:	480d      	ldr	r0, [pc, #52]	; (279f4 <k_work_reschedule_for_queue+0xbc>)
   279be:	f004 fdb6 	bl	2c52e <assert_print>
   279c2:	218e      	movs	r1, #142	; 0x8e
   279c4:	4640      	mov	r0, r8
   279c6:	f004 fdab 	bl	2c520 <assert_post_action>
   279ca:	e7c9      	b.n	27960 <k_work_reschedule_for_queue+0x28>
		z_abort_timeout(&dwork->timeout);
   279cc:	f104 0010 	add.w	r0, r4, #16
   279d0:	f001 fc56 	bl	29280 <z_abort_timeout>
		ret = true;
   279d4:	e7ce      	b.n	27974 <k_work_reschedule_for_queue+0x3c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   279d6:	4d08      	ldr	r5, [pc, #32]	; (279f8 <k_work_reschedule_for_queue+0xc0>)
   279d8:	22b9      	movs	r2, #185	; 0xb9
   279da:	4629      	mov	r1, r5
   279dc:	4805      	ldr	r0, [pc, #20]	; (279f4 <k_work_reschedule_for_queue+0xbc>)
   279de:	f004 fda6 	bl	2c52e <assert_print>
   279e2:	21b9      	movs	r1, #185	; 0xb9
   279e4:	4628      	mov	r0, r5
   279e6:	f004 fd9b 	bl	2c520 <assert_post_action>
   279ea:	e7ce      	b.n	2798a <k_work_reschedule_for_queue+0x52>
   279ec:	200046dc 	.word	0x200046dc
   279f0:	0003bea0 	.word	0x0003bea0
   279f4:	00031600 	.word	0x00031600
   279f8:	000390f0 	.word	0x000390f0

000279fc <k_work_reschedule>:

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   279fc:	b508      	push	{r3, lr}
   279fe:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
   27a00:	4801      	ldr	r0, [pc, #4]	; (27a08 <k_work_reschedule+0xc>)
   27a02:	f7ff ff99 	bl	27938 <k_work_reschedule_for_queue>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule, dwork, delay, ret);

	return ret;
}
   27a06:	bd08      	pop	{r3, pc}
   27a08:	20002770 	.word	0x20002770

00027a0c <k_work_cancel_delayable>:

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
   27a0c:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(dwork != NULL);
   27a0e:	4604      	mov	r4, r0
   27a10:	b1e8      	cbz	r0, 27a4e <k_work_cancel_delayable+0x42>
	__asm__ volatile(
   27a12:	f04f 0340 	mov.w	r3, #64	; 0x40
   27a16:	f3ef 8611 	mrs	r6, BASEPRI
   27a1a:	f383 8812 	msr	BASEPRI_MAX, r3
   27a1e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27a22:	481c      	ldr	r0, [pc, #112]	; (27a94 <k_work_cancel_delayable+0x88>)
   27a24:	f7fe fe3e 	bl	266a4 <z_spin_lock_valid>
   27a28:	b1f0      	cbz	r0, 27a68 <k_work_cancel_delayable+0x5c>
	z_spin_lock_set_owner(l);
   27a2a:	4d1a      	ldr	r5, [pc, #104]	; (27a94 <k_work_cancel_delayable+0x88>)
   27a2c:	4628      	mov	r0, r5
   27a2e:	f7fe fe59 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable, dwork);

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = cancel_delayable_async_locked(dwork);
   27a32:	4620      	mov	r0, r4
   27a34:	f009 f843 	bl	30abe <cancel_delayable_async_locked>
   27a38:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27a3a:	4628      	mov	r0, r5
   27a3c:	f7fe fe42 	bl	266c4 <z_spin_unlock_valid>
   27a40:	b1e8      	cbz	r0, 27a7e <k_work_cancel_delayable+0x72>
	__asm__ volatile(
   27a42:	f386 8811 	msr	BASEPRI, r6
   27a46:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
   27a4a:	4620      	mov	r0, r4
   27a4c:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(dwork != NULL);
   27a4e:	4d12      	ldr	r5, [pc, #72]	; (27a98 <k_work_cancel_delayable+0x8c>)
   27a50:	f240 32fd 	movw	r2, #1021	; 0x3fd
   27a54:	4629      	mov	r1, r5
   27a56:	4811      	ldr	r0, [pc, #68]	; (27a9c <k_work_cancel_delayable+0x90>)
   27a58:	f004 fd69 	bl	2c52e <assert_print>
   27a5c:	f240 31fd 	movw	r1, #1021	; 0x3fd
   27a60:	4628      	mov	r0, r5
   27a62:	f004 fd5d 	bl	2c520 <assert_post_action>
   27a66:	e7d4      	b.n	27a12 <k_work_cancel_delayable+0x6>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27a68:	4d0d      	ldr	r5, [pc, #52]	; (27aa0 <k_work_cancel_delayable+0x94>)
   27a6a:	228e      	movs	r2, #142	; 0x8e
   27a6c:	4629      	mov	r1, r5
   27a6e:	480b      	ldr	r0, [pc, #44]	; (27a9c <k_work_cancel_delayable+0x90>)
   27a70:	f004 fd5d 	bl	2c52e <assert_print>
   27a74:	218e      	movs	r1, #142	; 0x8e
   27a76:	4628      	mov	r0, r5
   27a78:	f004 fd52 	bl	2c520 <assert_post_action>
   27a7c:	e7d5      	b.n	27a2a <k_work_cancel_delayable+0x1e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27a7e:	4d08      	ldr	r5, [pc, #32]	; (27aa0 <k_work_cancel_delayable+0x94>)
   27a80:	22b9      	movs	r2, #185	; 0xb9
   27a82:	4629      	mov	r1, r5
   27a84:	4805      	ldr	r0, [pc, #20]	; (27a9c <k_work_cancel_delayable+0x90>)
   27a86:	f004 fd52 	bl	2c52e <assert_print>
   27a8a:	21b9      	movs	r1, #185	; 0xb9
   27a8c:	4628      	mov	r0, r5
   27a8e:	f004 fd47 	bl	2c520 <assert_post_action>
   27a92:	e7d6      	b.n	27a42 <k_work_cancel_delayable+0x36>
   27a94:	200046dc 	.word	0x200046dc
   27a98:	0003bea0 	.word	0x0003bea0
   27a9c:	00031600 	.word	0x00031600
   27aa0:	000390f0 	.word	0x000390f0

00027aa4 <k_work_cancel_delayable_sync>:

bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
				  struct k_work_sync *sync)
{
   27aa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27aa8:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(dwork != NULL);
   27aaa:	4605      	mov	r5, r0
   27aac:	2800      	cmp	r0, #0
   27aae:	d02c      	beq.n	27b0a <k_work_cancel_delayable_sync+0x66>
	__ASSERT_NO_MSG(sync != NULL);
   27ab0:	2c00      	cmp	r4, #0
   27ab2:	d037      	beq.n	27b24 <k_work_cancel_delayable_sync+0x80>
	__ASSERT_NO_MSG(!k_is_in_isr());
   27ab4:	f008 ff2a 	bl	3090c <k_is_in_isr>
   27ab8:	2800      	cmp	r0, #0
   27aba:	d140      	bne.n	27b3e <k_work_cancel_delayable_sync+0x9a>
	__asm__ volatile(
   27abc:	f04f 0340 	mov.w	r3, #64	; 0x40
   27ac0:	f3ef 8711 	mrs	r7, BASEPRI
   27ac4:	f383 8812 	msr	BASEPRI_MAX, r3
   27ac8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27acc:	4837      	ldr	r0, [pc, #220]	; (27bac <k_work_cancel_delayable_sync+0x108>)
   27ace:	f7fe fde9 	bl	266a4 <z_spin_lock_valid>
   27ad2:	2800      	cmp	r0, #0
   27ad4:	d040      	beq.n	27b58 <k_work_cancel_delayable_sync+0xb4>
	z_spin_lock_set_owner(l);
   27ad6:	4835      	ldr	r0, [pc, #212]	; (27bac <k_work_cancel_delayable_sync+0x108>)
   27ad8:	f7fe fe04 	bl	266e4 <z_spin_lock_set_owner>
	return *flagp;
   27adc:	68eb      	ldr	r3, [r5, #12]
	return flags_get(&dwork->work.flags) & K_WORK_MASK;
   27ade:	f003 030f 	and.w	r3, r3, #15

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);

	struct z_work_canceller *canceller = &sync->canceller;
	k_spinlock_key_t key = k_spin_lock(&lock);
	bool pending = (work_delayable_busy_get_locked(dwork) != 0U);
   27ae2:	2b00      	cmp	r3, #0
   27ae4:	bf14      	ite	ne
   27ae6:	2601      	movne	r6, #1
   27ae8:	2600      	moveq	r6, #0
	bool need_wait = false;

	if (pending) {
   27aea:	d140      	bne.n	27b6e <k_work_cancel_delayable_sync+0xca>
	bool need_wait = false;
   27aec:	2500      	movs	r5, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27aee:	482f      	ldr	r0, [pc, #188]	; (27bac <k_work_cancel_delayable_sync+0x108>)
   27af0:	f7fe fde8 	bl	266c4 <z_spin_unlock_valid>
   27af4:	2800      	cmp	r0, #0
   27af6:	d043      	beq.n	27b80 <k_work_cancel_delayable_sync+0xdc>
	__asm__ volatile(
   27af8:	f387 8811 	msr	BASEPRI, r7
   27afc:	f3bf 8f6f 	isb	sy
		need_wait = cancel_sync_locked(&dwork->work, canceller);
	}

	k_spin_unlock(&lock, key);

	if (need_wait) {
   27b00:	2d00      	cmp	r5, #0
   27b02:	d149      	bne.n	27b98 <k_work_cancel_delayable_sync+0xf4>
		k_sem_take(&canceller->sem, K_FOREVER);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);
	return pending;
}
   27b04:	4630      	mov	r0, r6
   27b06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(dwork != NULL);
   27b0a:	4e29      	ldr	r6, [pc, #164]	; (27bb0 <k_work_cancel_delayable_sync+0x10c>)
   27b0c:	f240 420e 	movw	r2, #1038	; 0x40e
   27b10:	4631      	mov	r1, r6
   27b12:	4828      	ldr	r0, [pc, #160]	; (27bb4 <k_work_cancel_delayable_sync+0x110>)
   27b14:	f004 fd0b 	bl	2c52e <assert_print>
   27b18:	f240 410e 	movw	r1, #1038	; 0x40e
   27b1c:	4630      	mov	r0, r6
   27b1e:	f004 fcff 	bl	2c520 <assert_post_action>
   27b22:	e7c5      	b.n	27ab0 <k_work_cancel_delayable_sync+0xc>
	__ASSERT_NO_MSG(sync != NULL);
   27b24:	4e22      	ldr	r6, [pc, #136]	; (27bb0 <k_work_cancel_delayable_sync+0x10c>)
   27b26:	f240 420f 	movw	r2, #1039	; 0x40f
   27b2a:	4631      	mov	r1, r6
   27b2c:	4821      	ldr	r0, [pc, #132]	; (27bb4 <k_work_cancel_delayable_sync+0x110>)
   27b2e:	f004 fcfe 	bl	2c52e <assert_print>
   27b32:	f240 410f 	movw	r1, #1039	; 0x40f
   27b36:	4630      	mov	r0, r6
   27b38:	f004 fcf2 	bl	2c520 <assert_post_action>
   27b3c:	e7ba      	b.n	27ab4 <k_work_cancel_delayable_sync+0x10>
	__ASSERT_NO_MSG(!k_is_in_isr());
   27b3e:	4e1c      	ldr	r6, [pc, #112]	; (27bb0 <k_work_cancel_delayable_sync+0x10c>)
   27b40:	f44f 6282 	mov.w	r2, #1040	; 0x410
   27b44:	4631      	mov	r1, r6
   27b46:	481b      	ldr	r0, [pc, #108]	; (27bb4 <k_work_cancel_delayable_sync+0x110>)
   27b48:	f004 fcf1 	bl	2c52e <assert_print>
   27b4c:	f44f 6182 	mov.w	r1, #1040	; 0x410
   27b50:	4630      	mov	r0, r6
   27b52:	f004 fce5 	bl	2c520 <assert_post_action>
   27b56:	e7b1      	b.n	27abc <k_work_cancel_delayable_sync+0x18>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27b58:	4e17      	ldr	r6, [pc, #92]	; (27bb8 <k_work_cancel_delayable_sync+0x114>)
   27b5a:	228e      	movs	r2, #142	; 0x8e
   27b5c:	4631      	mov	r1, r6
   27b5e:	4815      	ldr	r0, [pc, #84]	; (27bb4 <k_work_cancel_delayable_sync+0x110>)
   27b60:	f004 fce5 	bl	2c52e <assert_print>
   27b64:	218e      	movs	r1, #142	; 0x8e
   27b66:	4630      	mov	r0, r6
   27b68:	f004 fcda 	bl	2c520 <assert_post_action>
   27b6c:	e7b3      	b.n	27ad6 <k_work_cancel_delayable_sync+0x32>
		(void)cancel_delayable_async_locked(dwork);
   27b6e:	4628      	mov	r0, r5
   27b70:	f008 ffa5 	bl	30abe <cancel_delayable_async_locked>
		need_wait = cancel_sync_locked(&dwork->work, canceller);
   27b74:	4621      	mov	r1, r4
   27b76:	4628      	mov	r0, r5
   27b78:	f7ff fbaa 	bl	272d0 <cancel_sync_locked>
   27b7c:	4605      	mov	r5, r0
   27b7e:	e7b6      	b.n	27aee <k_work_cancel_delayable_sync+0x4a>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27b80:	f8df 8034 	ldr.w	r8, [pc, #52]	; 27bb8 <k_work_cancel_delayable_sync+0x114>
   27b84:	22b9      	movs	r2, #185	; 0xb9
   27b86:	4641      	mov	r1, r8
   27b88:	480a      	ldr	r0, [pc, #40]	; (27bb4 <k_work_cancel_delayable_sync+0x110>)
   27b8a:	f004 fcd0 	bl	2c52e <assert_print>
   27b8e:	21b9      	movs	r1, #185	; 0xb9
   27b90:	4640      	mov	r0, r8
   27b92:	f004 fcc5 	bl	2c520 <assert_post_action>
   27b96:	e7af      	b.n	27af8 <k_work_cancel_delayable_sync+0x54>
		k_sem_take(&canceller->sem, K_FOREVER);
   27b98:	f104 0008 	add.w	r0, r4, #8
	return z_impl_k_sem_take(sem, timeout);
   27b9c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   27ba0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   27ba4:	f7ff fa36 	bl	27014 <z_impl_k_sem_take>
   27ba8:	e7ac      	b.n	27b04 <k_work_cancel_delayable_sync+0x60>
   27baa:	bf00      	nop
   27bac:	200046dc 	.word	0x200046dc
   27bb0:	0003bea0 	.word	0x0003bea0
   27bb4:	00031600 	.word	0x00031600
   27bb8:	000390f0 	.word	0x000390f0

00027bbc <pended_on_thread>:
}
#include <syscalls/k_thread_resume_mrsh.c>
#endif

static _wait_q_t *pended_on_thread(struct k_thread *thread)
{
   27bbc:	b538      	push	{r3, r4, r5, lr}
   27bbe:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread->base.pended_on);
   27bc0:	6883      	ldr	r3, [r0, #8]
   27bc2:	b10b      	cbz	r3, 27bc8 <pended_on_thread+0xc>

	return thread->base.pended_on;
}
   27bc4:	68a0      	ldr	r0, [r4, #8]
   27bc6:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(thread->base.pended_on);
   27bc8:	4d06      	ldr	r5, [pc, #24]	; (27be4 <pended_on_thread+0x28>)
   27bca:	f44f 7235 	mov.w	r2, #724	; 0x2d4
   27bce:	4629      	mov	r1, r5
   27bd0:	4805      	ldr	r0, [pc, #20]	; (27be8 <pended_on_thread+0x2c>)
   27bd2:	f004 fcac 	bl	2c52e <assert_print>
   27bd6:	f44f 7135 	mov.w	r1, #724	; 0x2d4
   27bda:	4628      	mov	r0, r5
   27bdc:	f004 fca0 	bl	2c520 <assert_post_action>
   27be0:	e7f0      	b.n	27bc4 <pended_on_thread+0x8>
   27be2:	bf00      	nop
   27be4:	0003bec4 	.word	0x0003bec4
   27be8:	00031600 	.word	0x00031600

00027bec <add_thread_timeout>:
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   27bec:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   27bf0:	bf08      	it	eq
   27bf2:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   27bf6:	d100      	bne.n	27bfa <add_thread_timeout+0xe>
   27bf8:	4770      	bx	lr
{
   27bfa:	b508      	push	{r3, lr}
   27bfc:	4902      	ldr	r1, [pc, #8]	; (27c08 <add_thread_timeout+0x1c>)
   27bfe:	3018      	adds	r0, #24
   27c00:	f001 fa74 	bl	290ec <z_add_timeout>
		z_add_thread_timeout(thread, timeout);
	}
}
   27c04:	bd08      	pop	{r3, pc}
   27c06:	bf00      	nop
   27c08:	000283c9 	.word	0x000283c9

00027c0c <z_reset_time_slice>:
{
   27c0c:	b510      	push	{r4, lr}
	int ret = slice_ticks;
   27c0e:	4b07      	ldr	r3, [pc, #28]	; (27c2c <z_reset_time_slice+0x20>)
   27c10:	681c      	ldr	r4, [r3, #0]
	if (slice_time(curr) != 0) {
   27c12:	b904      	cbnz	r4, 27c16 <z_reset_time_slice+0xa>
}
   27c14:	bd10      	pop	{r4, pc}
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
   27c16:	f7f9 ff29 	bl	21a6c <sys_clock_elapsed>
   27c1a:	4404      	add	r4, r0
   27c1c:	4b04      	ldr	r3, [pc, #16]	; (27c30 <z_reset_time_slice+0x24>)
   27c1e:	611c      	str	r4, [r3, #16]
		z_set_timeout_expiry(slice_time(curr), false);
   27c20:	2100      	movs	r1, #0
   27c22:	4b02      	ldr	r3, [pc, #8]	; (27c2c <z_reset_time_slice+0x20>)
   27c24:	6818      	ldr	r0, [r3, #0]
   27c26:	f001 fbb3 	bl	29390 <z_set_timeout_expiry>
}
   27c2a:	e7f3      	b.n	27c14 <z_reset_time_slice+0x8>
   27c2c:	200046f4 	.word	0x200046f4
   27c30:	200046a4 	.word	0x200046a4

00027c34 <k_sched_time_slice_set>:
{
   27c34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27c38:	4604      	mov	r4, r0
   27c3a:	460d      	mov	r5, r1
	LOCKED(&sched_spinlock) {
   27c3c:	2700      	movs	r7, #0
	__asm__ volatile(
   27c3e:	f04f 0340 	mov.w	r3, #64	; 0x40
   27c42:	f3ef 8611 	mrs	r6, BASEPRI
   27c46:	f383 8812 	msr	BASEPRI_MAX, r3
   27c4a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27c4e:	4825      	ldr	r0, [pc, #148]	; (27ce4 <k_sched_time_slice_set+0xb0>)
   27c50:	f7fe fd28 	bl	266a4 <z_spin_lock_valid>
   27c54:	b118      	cbz	r0, 27c5e <k_sched_time_slice_set+0x2a>
	z_spin_lock_set_owner(l);
   27c56:	4823      	ldr	r0, [pc, #140]	; (27ce4 <k_sched_time_slice_set+0xb0>)
   27c58:	f7fe fd44 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   27c5c:	e01e      	b.n	27c9c <k_sched_time_slice_set+0x68>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27c5e:	f8df 8098 	ldr.w	r8, [pc, #152]	; 27cf8 <k_sched_time_slice_set+0xc4>
   27c62:	228e      	movs	r2, #142	; 0x8e
   27c64:	4641      	mov	r1, r8
   27c66:	4820      	ldr	r0, [pc, #128]	; (27ce8 <k_sched_time_slice_set+0xb4>)
   27c68:	f004 fc61 	bl	2c52e <assert_print>
   27c6c:	218e      	movs	r1, #142	; 0x8e
   27c6e:	4640      	mov	r0, r8
   27c70:	f004 fc56 	bl	2c520 <assert_post_action>
   27c74:	e7ef      	b.n	27c56 <k_sched_time_slice_set+0x22>
			slice_ticks = MAX(2, slice_ticks);
   27c76:	2802      	cmp	r0, #2
   27c78:	bfb8      	it	lt
   27c7a:	2002      	movlt	r0, #2
   27c7c:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   27c7e:	4b1b      	ldr	r3, [pc, #108]	; (27cec <k_sched_time_slice_set+0xb8>)
   27c80:	601d      	str	r5, [r3, #0]
		z_reset_time_slice(_current);
   27c82:	4b1b      	ldr	r3, [pc, #108]	; (27cf0 <k_sched_time_slice_set+0xbc>)
   27c84:	6898      	ldr	r0, [r3, #8]
   27c86:	f7ff ffc1 	bl	27c0c <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27c8a:	4816      	ldr	r0, [pc, #88]	; (27ce4 <k_sched_time_slice_set+0xb0>)
   27c8c:	f7fe fd1a 	bl	266c4 <z_spin_unlock_valid>
   27c90:	b1d0      	cbz	r0, 27cc8 <k_sched_time_slice_set+0x94>
	__asm__ volatile(
   27c92:	f386 8811 	msr	BASEPRI, r6
   27c96:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   27c9a:	2701      	movs	r7, #1
   27c9c:	b9ff      	cbnz	r7, 27cde <k_sched_time_slice_set+0xaa>
		_current_cpu->slice_ticks = 0;
   27c9e:	4b14      	ldr	r3, [pc, #80]	; (27cf0 <k_sched_time_slice_set+0xbc>)
   27ca0:	2200      	movs	r2, #0
   27ca2:	611a      	str	r2, [r3, #16]
			return (uint32_t)((t * to_hz + off) / from_hz);
   27ca4:	0c61      	lsrs	r1, r4, #17
   27ca6:	03e3      	lsls	r3, r4, #15
   27ca8:	f240 30e7 	movw	r0, #999	; 0x3e7
   27cac:	1818      	adds	r0, r3, r0
   27cae:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   27cb2:	f04f 0300 	mov.w	r3, #0
   27cb6:	f141 0100 	adc.w	r1, r1, #0
   27cba:	f7d8 ff8d 	bl	bd8 <__aeabi_uldivmod>
		slice_ticks = k_ms_to_ticks_ceil32(slice);
   27cbe:	4b0d      	ldr	r3, [pc, #52]	; (27cf4 <k_sched_time_slice_set+0xc0>)
   27cc0:	6018      	str	r0, [r3, #0]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   27cc2:	2c00      	cmp	r4, #0
   27cc4:	dcd7      	bgt.n	27c76 <k_sched_time_slice_set+0x42>
   27cc6:	e7da      	b.n	27c7e <k_sched_time_slice_set+0x4a>
   27cc8:	4f0b      	ldr	r7, [pc, #44]	; (27cf8 <k_sched_time_slice_set+0xc4>)
   27cca:	22b9      	movs	r2, #185	; 0xb9
   27ccc:	4639      	mov	r1, r7
   27cce:	4806      	ldr	r0, [pc, #24]	; (27ce8 <k_sched_time_slice_set+0xb4>)
   27cd0:	f004 fc2d 	bl	2c52e <assert_print>
   27cd4:	21b9      	movs	r1, #185	; 0xb9
   27cd6:	4638      	mov	r0, r7
   27cd8:	f004 fc22 	bl	2c520 <assert_post_action>
   27cdc:	e7d9      	b.n	27c92 <k_sched_time_slice_set+0x5e>
}
   27cde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   27ce2:	bf00      	nop
   27ce4:	200046ec 	.word	0x200046ec
   27ce8:	00031600 	.word	0x00031600
   27cec:	200046f0 	.word	0x200046f0
   27cf0:	200046a4 	.word	0x200046a4
   27cf4:	200046f4 	.word	0x200046f4
   27cf8:	000390f0 	.word	0x000390f0

00027cfc <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   27cfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27cfe:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
   27d00:	2500      	movs	r5, #0
	__asm__ volatile(
   27d02:	f04f 0340 	mov.w	r3, #64	; 0x40
   27d06:	f3ef 8611 	mrs	r6, BASEPRI
   27d0a:	f383 8812 	msr	BASEPRI_MAX, r3
   27d0e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27d12:	481b      	ldr	r0, [pc, #108]	; (27d80 <z_unpend_thread_no_timeout+0x84>)
   27d14:	f7fe fcc6 	bl	266a4 <z_spin_lock_valid>
   27d18:	b118      	cbz	r0, 27d22 <z_unpend_thread_no_timeout+0x26>
	z_spin_lock_set_owner(l);
   27d1a:	4819      	ldr	r0, [pc, #100]	; (27d80 <z_unpend_thread_no_timeout+0x84>)
   27d1c:	f7fe fce2 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   27d20:	e00f      	b.n	27d42 <z_unpend_thread_no_timeout+0x46>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27d22:	4f18      	ldr	r7, [pc, #96]	; (27d84 <z_unpend_thread_no_timeout+0x88>)
   27d24:	228e      	movs	r2, #142	; 0x8e
   27d26:	4639      	mov	r1, r7
   27d28:	4817      	ldr	r0, [pc, #92]	; (27d88 <z_unpend_thread_no_timeout+0x8c>)
   27d2a:	f004 fc00 	bl	2c52e <assert_print>
   27d2e:	218e      	movs	r1, #142	; 0x8e
   27d30:	4638      	mov	r0, r7
   27d32:	f004 fbf5 	bl	2c520 <assert_post_action>
   27d36:	e7f0      	b.n	27d1a <z_unpend_thread_no_timeout+0x1e>
	__asm__ volatile(
   27d38:	f386 8811 	msr	BASEPRI, r6
   27d3c:	f3bf 8f6f 	isb	sy
   27d40:	2501      	movs	r5, #1
   27d42:	b9dd      	cbnz	r5, 27d7c <z_unpend_thread_no_timeout+0x80>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   27d44:	4620      	mov	r0, r4
   27d46:	f7ff ff39 	bl	27bbc <pended_on_thread>
   27d4a:	4621      	mov	r1, r4
   27d4c:	f000 f8bc 	bl	27ec8 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27d50:	7b63      	ldrb	r3, [r4, #13]
   27d52:	f023 0302 	bic.w	r3, r3, #2
   27d56:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   27d58:	2300      	movs	r3, #0
   27d5a:	60a3      	str	r3, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27d5c:	4808      	ldr	r0, [pc, #32]	; (27d80 <z_unpend_thread_no_timeout+0x84>)
   27d5e:	f7fe fcb1 	bl	266c4 <z_spin_unlock_valid>
   27d62:	2800      	cmp	r0, #0
   27d64:	d1e8      	bne.n	27d38 <z_unpend_thread_no_timeout+0x3c>
   27d66:	4d07      	ldr	r5, [pc, #28]	; (27d84 <z_unpend_thread_no_timeout+0x88>)
   27d68:	22b9      	movs	r2, #185	; 0xb9
   27d6a:	4629      	mov	r1, r5
   27d6c:	4806      	ldr	r0, [pc, #24]	; (27d88 <z_unpend_thread_no_timeout+0x8c>)
   27d6e:	f004 fbde 	bl	2c52e <assert_print>
   27d72:	21b9      	movs	r1, #185	; 0xb9
   27d74:	4628      	mov	r0, r5
   27d76:	f004 fbd3 	bl	2c520 <assert_post_action>
   27d7a:	e7dd      	b.n	27d38 <z_unpend_thread_no_timeout+0x3c>
		unpend_thread_no_timeout(thread);
	}
}
   27d7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   27d7e:	bf00      	nop
   27d80:	200046ec 	.word	0x200046ec
   27d84:	000390f0 	.word	0x000390f0
   27d88:	00031600 	.word	0x00031600

00027d8c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   27d8c:	b538      	push	{r3, r4, r5, lr}
	if (resched(key.key) && need_swap()) {
   27d8e:	460c      	mov	r4, r1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   27d90:	b921      	cbnz	r1, 27d9c <z_reschedule+0x10>
   27d92:	f3ef 8305 	mrs	r3, IPSR
   27d96:	b913      	cbnz	r3, 27d9e <z_reschedule+0x12>
   27d98:	2101      	movs	r1, #1
   27d9a:	e000      	b.n	27d9e <z_reschedule+0x12>
   27d9c:	2100      	movs	r1, #0
	if (resched(key.key) && need_swap()) {
   27d9e:	f011 0f01 	tst.w	r1, #1
   27da2:	d016      	beq.n	27dd2 <z_reschedule+0x46>
	new_thread = _kernel.ready_q.cache;
   27da4:	4b14      	ldr	r3, [pc, #80]	; (27df8 <z_reschedule+0x6c>)
   27da6:	6a1a      	ldr	r2, [r3, #32]
	return new_thread != _current;
   27da8:	689b      	ldr	r3, [r3, #8]
	if (resched(key.key) && need_swap()) {
   27daa:	429a      	cmp	r2, r3
   27dac:	d011      	beq.n	27dd2 <z_reschedule+0x46>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27dae:	f7fe fc89 	bl	266c4 <z_spin_unlock_valid>
   27db2:	b118      	cbz	r0, 27dbc <z_reschedule+0x30>
	ret = arch_swap(key);
   27db4:	4620      	mov	r0, r4
   27db6:	f7f0 fb0f 	bl	183d8 <arch_swap>
		z_swap(lock, key);
   27dba:	e011      	b.n	27de0 <z_reschedule+0x54>
   27dbc:	4d0f      	ldr	r5, [pc, #60]	; (27dfc <z_reschedule+0x70>)
   27dbe:	22d0      	movs	r2, #208	; 0xd0
   27dc0:	4629      	mov	r1, r5
   27dc2:	480f      	ldr	r0, [pc, #60]	; (27e00 <z_reschedule+0x74>)
   27dc4:	f004 fbb3 	bl	2c52e <assert_print>
   27dc8:	21d0      	movs	r1, #208	; 0xd0
   27dca:	4628      	mov	r0, r5
   27dcc:	f004 fba8 	bl	2c520 <assert_post_action>
   27dd0:	e7f0      	b.n	27db4 <z_reschedule+0x28>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27dd2:	f7fe fc77 	bl	266c4 <z_spin_unlock_valid>
   27dd6:	b120      	cbz	r0, 27de2 <z_reschedule+0x56>
   27dd8:	f384 8811 	msr	BASEPRI, r4
   27ddc:	f3bf 8f6f 	isb	sy
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
   27de0:	bd38      	pop	{r3, r4, r5, pc}
   27de2:	4d06      	ldr	r5, [pc, #24]	; (27dfc <z_reschedule+0x70>)
   27de4:	22b9      	movs	r2, #185	; 0xb9
   27de6:	4629      	mov	r1, r5
   27de8:	4805      	ldr	r0, [pc, #20]	; (27e00 <z_reschedule+0x74>)
   27dea:	f004 fba0 	bl	2c52e <assert_print>
   27dee:	21b9      	movs	r1, #185	; 0xb9
   27df0:	4628      	mov	r0, r5
   27df2:	f004 fb95 	bl	2c520 <assert_post_action>
   27df6:	e7ef      	b.n	27dd8 <z_reschedule+0x4c>
   27df8:	200046a4 	.word	0x200046a4
   27dfc:	000390f0 	.word	0x000390f0
   27e00:	00031600 	.word	0x00031600

00027e04 <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
   27e04:	b570      	push	{r4, r5, r6, lr}
	LOCKED(&sched_spinlock) {
   27e06:	2400      	movs	r4, #0
	__asm__ volatile(
   27e08:	f04f 0340 	mov.w	r3, #64	; 0x40
   27e0c:	f3ef 8511 	mrs	r5, BASEPRI
   27e10:	f383 8812 	msr	BASEPRI_MAX, r3
   27e14:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27e18:	4826      	ldr	r0, [pc, #152]	; (27eb4 <k_sched_lock+0xb0>)
   27e1a:	f7fe fc43 	bl	266a4 <z_spin_lock_valid>
   27e1e:	b118      	cbz	r0, 27e28 <k_sched_lock+0x24>
	z_spin_lock_set_owner(l);
   27e20:	4824      	ldr	r0, [pc, #144]	; (27eb4 <k_sched_lock+0xb0>)
   27e22:	f7fe fc5f 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   27e26:	e01d      	b.n	27e64 <k_sched_lock+0x60>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27e28:	4e23      	ldr	r6, [pc, #140]	; (27eb8 <k_sched_lock+0xb4>)
   27e2a:	228e      	movs	r2, #142	; 0x8e
   27e2c:	4631      	mov	r1, r6
   27e2e:	4823      	ldr	r0, [pc, #140]	; (27ebc <k_sched_lock+0xb8>)
   27e30:	f004 fb7d 	bl	2c52e <assert_print>
   27e34:	218e      	movs	r1, #142	; 0x8e
   27e36:	4630      	mov	r0, r6
   27e38:	f004 fb72 	bl	2c520 <assert_post_action>
   27e3c:	e7f0      	b.n	27e20 <k_sched_lock+0x1c>
	__ASSERT(_current->base.sched_locked != 1U, "");
   27e3e:	4b20      	ldr	r3, [pc, #128]	; (27ec0 <k_sched_lock+0xbc>)
   27e40:	689b      	ldr	r3, [r3, #8]
   27e42:	7bdb      	ldrb	r3, [r3, #15]
   27e44:	2b01      	cmp	r3, #1
   27e46:	d01d      	beq.n	27e84 <k_sched_lock+0x80>
	--_current->base.sched_locked;
   27e48:	4b1d      	ldr	r3, [pc, #116]	; (27ec0 <k_sched_lock+0xbc>)
   27e4a:	689a      	ldr	r2, [r3, #8]
   27e4c:	7bd3      	ldrb	r3, [r2, #15]
   27e4e:	3b01      	subs	r3, #1
   27e50:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27e52:	4818      	ldr	r0, [pc, #96]	; (27eb4 <k_sched_lock+0xb0>)
   27e54:	f7fe fc36 	bl	266c4 <z_spin_unlock_valid>
   27e58:	b1f8      	cbz	r0, 27e9a <k_sched_lock+0x96>
	__asm__ volatile(
   27e5a:	f385 8811 	msr	BASEPRI, r5
   27e5e:	f3bf 8f6f 	isb	sy
   27e62:	2401      	movs	r4, #1
   27e64:	bb24      	cbnz	r4, 27eb0 <k_sched_lock+0xac>
   27e66:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   27e6a:	2b00      	cmp	r3, #0
   27e6c:	d0e7      	beq.n	27e3e <k_sched_lock+0x3a>
   27e6e:	4c15      	ldr	r4, [pc, #84]	; (27ec4 <k_sched_lock+0xc0>)
   27e70:	22fd      	movs	r2, #253	; 0xfd
   27e72:	4621      	mov	r1, r4
   27e74:	4811      	ldr	r0, [pc, #68]	; (27ebc <k_sched_lock+0xb8>)
   27e76:	f004 fb5a 	bl	2c52e <assert_print>
   27e7a:	21fd      	movs	r1, #253	; 0xfd
   27e7c:	4620      	mov	r0, r4
   27e7e:	f004 fb4f 	bl	2c520 <assert_post_action>
   27e82:	e7dc      	b.n	27e3e <k_sched_lock+0x3a>
	__ASSERT(_current->base.sched_locked != 1U, "");
   27e84:	4c0f      	ldr	r4, [pc, #60]	; (27ec4 <k_sched_lock+0xc0>)
   27e86:	22fe      	movs	r2, #254	; 0xfe
   27e88:	4621      	mov	r1, r4
   27e8a:	480c      	ldr	r0, [pc, #48]	; (27ebc <k_sched_lock+0xb8>)
   27e8c:	f004 fb4f 	bl	2c52e <assert_print>
   27e90:	21fe      	movs	r1, #254	; 0xfe
   27e92:	4620      	mov	r0, r4
   27e94:	f004 fb44 	bl	2c520 <assert_post_action>
   27e98:	e7d6      	b.n	27e48 <k_sched_lock+0x44>
   27e9a:	4c07      	ldr	r4, [pc, #28]	; (27eb8 <k_sched_lock+0xb4>)
   27e9c:	22b9      	movs	r2, #185	; 0xb9
   27e9e:	4621      	mov	r1, r4
   27ea0:	4806      	ldr	r0, [pc, #24]	; (27ebc <k_sched_lock+0xb8>)
   27ea2:	f004 fb44 	bl	2c52e <assert_print>
   27ea6:	21b9      	movs	r1, #185	; 0xb9
   27ea8:	4620      	mov	r0, r4
   27eaa:	f004 fb39 	bl	2c520 <assert_post_action>
   27eae:	e7d4      	b.n	27e5a <k_sched_lock+0x56>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   27eb0:	bd70      	pop	{r4, r5, r6, pc}
   27eb2:	bf00      	nop
   27eb4:	200046ec 	.word	0x200046ec
   27eb8:	000390f0 	.word	0x000390f0
   27ebc:	00031600 	.word	0x00031600
   27ec0:	200046a4 	.word	0x200046a4
   27ec4:	0003bee8 	.word	0x0003bee8

00027ec8 <z_priq_dumb_remove>:
#endif
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
   27ec8:	b538      	push	{r3, r4, r5, lr}
   27eca:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   27ecc:	4b0b      	ldr	r3, [pc, #44]	; (27efc <z_priq_dumb_remove+0x34>)
   27ece:	4299      	cmp	r1, r3
   27ed0:	d007      	beq.n	27ee2 <z_priq_dumb_remove+0x1a>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   27ed2:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
   27ed4:	6823      	ldr	r3, [r4, #0]

	prev->next = next;
   27ed6:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   27ed8:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   27eda:	2300      	movs	r3, #0
   27edc:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
   27ede:	6063      	str	r3, [r4, #4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   27ee0:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   27ee2:	4d07      	ldr	r5, [pc, #28]	; (27f00 <z_priq_dumb_remove+0x38>)
   27ee4:	f240 4262 	movw	r2, #1122	; 0x462
   27ee8:	4629      	mov	r1, r5
   27eea:	4806      	ldr	r0, [pc, #24]	; (27f04 <z_priq_dumb_remove+0x3c>)
   27eec:	f004 fb1f 	bl	2c52e <assert_print>
   27ef0:	f240 4162 	movw	r1, #1122	; 0x462
   27ef4:	4628      	mov	r0, r5
   27ef6:	f004 fb13 	bl	2c520 <assert_post_action>
   27efa:	e7ea      	b.n	27ed2 <z_priq_dumb_remove+0xa>
   27efc:	200025d0 	.word	0x200025d0
   27f00:	0003bec4 	.word	0x0003bec4
   27f04:	00031600 	.word	0x00031600

00027f08 <z_unpend_thread>:
{
   27f08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27f0a:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
   27f0c:	2500      	movs	r5, #0
	__asm__ volatile(
   27f0e:	f04f 0340 	mov.w	r3, #64	; 0x40
   27f12:	f3ef 8611 	mrs	r6, BASEPRI
   27f16:	f383 8812 	msr	BASEPRI_MAX, r3
   27f1a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27f1e:	481d      	ldr	r0, [pc, #116]	; (27f94 <z_unpend_thread+0x8c>)
   27f20:	f7fe fbc0 	bl	266a4 <z_spin_lock_valid>
   27f24:	b118      	cbz	r0, 27f2e <z_unpend_thread+0x26>
	z_spin_lock_set_owner(l);
   27f26:	481b      	ldr	r0, [pc, #108]	; (27f94 <z_unpend_thread+0x8c>)
   27f28:	f7fe fbdc 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   27f2c:	e00f      	b.n	27f4e <z_unpend_thread+0x46>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27f2e:	4f1a      	ldr	r7, [pc, #104]	; (27f98 <z_unpend_thread+0x90>)
   27f30:	228e      	movs	r2, #142	; 0x8e
   27f32:	4639      	mov	r1, r7
   27f34:	4819      	ldr	r0, [pc, #100]	; (27f9c <z_unpend_thread+0x94>)
   27f36:	f004 fafa 	bl	2c52e <assert_print>
   27f3a:	218e      	movs	r1, #142	; 0x8e
   27f3c:	4638      	mov	r0, r7
   27f3e:	f004 faef 	bl	2c520 <assert_post_action>
   27f42:	e7f0      	b.n	27f26 <z_unpend_thread+0x1e>
	__asm__ volatile(
   27f44:	f386 8811 	msr	BASEPRI, r6
   27f48:	f3bf 8f6f 	isb	sy
   27f4c:	2501      	movs	r5, #1
   27f4e:	b9dd      	cbnz	r5, 27f88 <z_unpend_thread+0x80>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   27f50:	4620      	mov	r0, r4
   27f52:	f7ff fe33 	bl	27bbc <pended_on_thread>
   27f56:	4621      	mov	r1, r4
   27f58:	f7ff ffb6 	bl	27ec8 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27f5c:	7b63      	ldrb	r3, [r4, #13]
   27f5e:	f023 0302 	bic.w	r3, r3, #2
   27f62:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   27f64:	2300      	movs	r3, #0
   27f66:	60a3      	str	r3, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27f68:	480a      	ldr	r0, [pc, #40]	; (27f94 <z_unpend_thread+0x8c>)
   27f6a:	f7fe fbab 	bl	266c4 <z_spin_unlock_valid>
   27f6e:	2800      	cmp	r0, #0
   27f70:	d1e8      	bne.n	27f44 <z_unpend_thread+0x3c>
   27f72:	4d09      	ldr	r5, [pc, #36]	; (27f98 <z_unpend_thread+0x90>)
   27f74:	22b9      	movs	r2, #185	; 0xb9
   27f76:	4629      	mov	r1, r5
   27f78:	4808      	ldr	r0, [pc, #32]	; (27f9c <z_unpend_thread+0x94>)
   27f7a:	f004 fad8 	bl	2c52e <assert_print>
   27f7e:	21b9      	movs	r1, #185	; 0xb9
   27f80:	4628      	mov	r0, r5
   27f82:	f004 facd 	bl	2c520 <assert_post_action>
   27f86:	e7dd      	b.n	27f44 <z_unpend_thread+0x3c>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   27f88:	f104 0018 	add.w	r0, r4, #24
   27f8c:	f001 f978 	bl	29280 <z_abort_timeout>
}
   27f90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   27f92:	bf00      	nop
   27f94:	200046ec 	.word	0x200046ec
   27f98:	000390f0 	.word	0x000390f0
   27f9c:	00031600 	.word	0x00031600

00027fa0 <update_cache>:
{
   27fa0:	b538      	push	{r3, r4, r5, lr}
   27fa2:	4604      	mov	r4, r0
	return _priq_run_best(curr_cpu_runq());
   27fa4:	4817      	ldr	r0, [pc, #92]	; (28004 <update_cache+0x64>)
   27fa6:	f008 fdce 	bl	30b46 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   27faa:	4605      	mov	r5, r0
   27fac:	b188      	cbz	r0, 27fd2 <update_cache+0x32>
	if (preempt_ok != 0) {
   27fae:	b9f4      	cbnz	r4, 27fee <update_cache+0x4e>
	__ASSERT(_current != NULL, "");
   27fb0:	4b15      	ldr	r3, [pc, #84]	; (28008 <update_cache+0x68>)
   27fb2:	689b      	ldr	r3, [r3, #8]
   27fb4:	b183      	cbz	r3, 27fd8 <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
   27fb6:	4b14      	ldr	r3, [pc, #80]	; (28008 <update_cache+0x68>)
   27fb8:	689b      	ldr	r3, [r3, #8]
	uint8_t state = thread->base.thread_state;
   27fba:	7b5a      	ldrb	r2, [r3, #13]
   27fbc:	f012 0f1f 	tst.w	r2, #31
   27fc0:	d115      	bne.n	27fee <update_cache+0x4e>
	return node->next != NULL;
   27fc2:	69aa      	ldr	r2, [r5, #24]
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   27fc4:	b99a      	cbnz	r2, 27fee <update_cache+0x4e>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   27fc6:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
   27fc8:	2a7f      	cmp	r2, #127	; 0x7f
   27fca:	d910      	bls.n	27fee <update_cache+0x4e>
		_kernel.ready_q.cache = _current;
   27fcc:	4a0e      	ldr	r2, [pc, #56]	; (28008 <update_cache+0x68>)
   27fce:	6213      	str	r3, [r2, #32]
   27fd0:	e016      	b.n	28000 <update_cache+0x60>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   27fd2:	4b0d      	ldr	r3, [pc, #52]	; (28008 <update_cache+0x68>)
   27fd4:	68dd      	ldr	r5, [r3, #12]
   27fd6:	e7ea      	b.n	27fae <update_cache+0xe>
	__ASSERT(_current != NULL, "");
   27fd8:	4c0c      	ldr	r4, [pc, #48]	; (2800c <update_cache+0x6c>)
   27fda:	2289      	movs	r2, #137	; 0x89
   27fdc:	4621      	mov	r1, r4
   27fde:	480c      	ldr	r0, [pc, #48]	; (28010 <update_cache+0x70>)
   27fe0:	f004 faa5 	bl	2c52e <assert_print>
   27fe4:	2189      	movs	r1, #137	; 0x89
   27fe6:	4620      	mov	r0, r4
   27fe8:	f004 fa9a 	bl	2c520 <assert_post_action>
   27fec:	e7e3      	b.n	27fb6 <update_cache+0x16>
		if (thread != _current) {
   27fee:	4b06      	ldr	r3, [pc, #24]	; (28008 <update_cache+0x68>)
   27ff0:	689b      	ldr	r3, [r3, #8]
   27ff2:	42ab      	cmp	r3, r5
   27ff4:	d002      	beq.n	27ffc <update_cache+0x5c>
			z_reset_time_slice(thread);
   27ff6:	4628      	mov	r0, r5
   27ff8:	f7ff fe08 	bl	27c0c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   27ffc:	4b02      	ldr	r3, [pc, #8]	; (28008 <update_cache+0x68>)
   27ffe:	621d      	str	r5, [r3, #32]
}
   28000:	bd38      	pop	{r3, r4, r5, pc}
   28002:	bf00      	nop
   28004:	200046c8 	.word	0x200046c8
   28008:	200046a4 	.word	0x200046a4
   2800c:	0003bec4 	.word	0x0003bec4
   28010:	00031600 	.word	0x00031600

00028014 <move_thread_to_end_of_prio_q>:
{
   28014:	b538      	push	{r3, r4, r5, lr}
   28016:	4605      	mov	r5, r0
	return (thread->base.thread_state & state) != 0U;
   28018:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
   2801a:	f990 300d 	ldrsb.w	r3, [r0, #13]
   2801e:	2b00      	cmp	r3, #0
   28020:	db2b      	blt.n	2807a <move_thread_to_end_of_prio_q+0x66>
	thread->base.thread_state |= _THREAD_QUEUED;
   28022:	7b6b      	ldrb	r3, [r5, #13]
   28024:	f063 037f 	orn	r3, r3, #127	; 0x7f
   28028:	736b      	strb	r3, [r5, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2802a:	4b21      	ldr	r3, [pc, #132]	; (280b0 <move_thread_to_end_of_prio_q+0x9c>)
   2802c:	429d      	cmp	r5, r3
   2802e:	d02c      	beq.n	2808a <move_thread_to_end_of_prio_q+0x76>
	return list->head == list;
   28030:	4b20      	ldr	r3, [pc, #128]	; (280b4 <move_thread_to_end_of_prio_q+0xa0>)
   28032:	f853 4f24 	ldr.w	r4, [r3, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28036:	429c      	cmp	r4, r3
   28038:	d038      	beq.n	280ac <move_thread_to_end_of_prio_q+0x98>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2803a:	b16c      	cbz	r4, 28058 <move_thread_to_end_of_prio_q+0x44>
		if (z_sched_prio_cmp(thread, t) > 0) {
   2803c:	4621      	mov	r1, r4
   2803e:	4628      	mov	r0, r5
   28040:	f008 fd62 	bl	30b08 <z_sched_prio_cmp>
   28044:	2800      	cmp	r0, #0
   28046:	dc2b      	bgt.n	280a0 <move_thread_to_end_of_prio_q+0x8c>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   28048:	b134      	cbz	r4, 28058 <move_thread_to_end_of_prio_q+0x44>
	return (node == list->tail) ? NULL : node->next;
   2804a:	4b1a      	ldr	r3, [pc, #104]	; (280b4 <move_thread_to_end_of_prio_q+0xa0>)
   2804c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2804e:	429c      	cmp	r4, r3
   28050:	d002      	beq.n	28058 <move_thread_to_end_of_prio_q+0x44>
   28052:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28054:	2c00      	cmp	r4, #0
   28056:	d1f0      	bne.n	2803a <move_thread_to_end_of_prio_q+0x26>
	sys_dnode_t *const tail = list->tail;
   28058:	4b16      	ldr	r3, [pc, #88]	; (280b4 <move_thread_to_end_of_prio_q+0xa0>)
   2805a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	node->next = list;
   2805c:	f103 0124 	add.w	r1, r3, #36	; 0x24
   28060:	6029      	str	r1, [r5, #0]
	node->prev = tail;
   28062:	606a      	str	r2, [r5, #4]
	tail->next = node;
   28064:	6015      	str	r5, [r2, #0]
	list->tail = node;
   28066:	629d      	str	r5, [r3, #40]	; 0x28
	update_cache(thread == _current);
   28068:	4b12      	ldr	r3, [pc, #72]	; (280b4 <move_thread_to_end_of_prio_q+0xa0>)
   2806a:	6898      	ldr	r0, [r3, #8]
   2806c:	42a8      	cmp	r0, r5
   2806e:	bf14      	ite	ne
   28070:	2000      	movne	r0, #0
   28072:	2001      	moveq	r0, #1
   28074:	f7ff ff94 	bl	27fa0 <update_cache>
}
   28078:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
   2807a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   2807e:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
   28080:	4601      	mov	r1, r0
   28082:	480d      	ldr	r0, [pc, #52]	; (280b8 <move_thread_to_end_of_prio_q+0xa4>)
   28084:	f7ff ff20 	bl	27ec8 <z_priq_dumb_remove>
}
   28088:	e7cb      	b.n	28022 <move_thread_to_end_of_prio_q+0xe>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2808a:	4c0c      	ldr	r4, [pc, #48]	; (280bc <move_thread_to_end_of_prio_q+0xa8>)
   2808c:	22ba      	movs	r2, #186	; 0xba
   2808e:	4621      	mov	r1, r4
   28090:	480b      	ldr	r0, [pc, #44]	; (280c0 <move_thread_to_end_of_prio_q+0xac>)
   28092:	f004 fa4c 	bl	2c52e <assert_print>
   28096:	21ba      	movs	r1, #186	; 0xba
   28098:	4620      	mov	r0, r4
   2809a:	f004 fa41 	bl	2c520 <assert_post_action>
   2809e:	e7c7      	b.n	28030 <move_thread_to_end_of_prio_q+0x1c>
	sys_dnode_t *const prev = successor->prev;
   280a0:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
   280a2:	606b      	str	r3, [r5, #4]
	node->next = successor;
   280a4:	602c      	str	r4, [r5, #0]
	prev->next = node;
   280a6:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   280a8:	6065      	str	r5, [r4, #4]
}
   280aa:	e7dd      	b.n	28068 <move_thread_to_end_of_prio_q+0x54>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   280ac:	2400      	movs	r4, #0
   280ae:	e7c4      	b.n	2803a <move_thread_to_end_of_prio_q+0x26>
   280b0:	200025d0 	.word	0x200025d0
   280b4:	200046a4 	.word	0x200046a4
   280b8:	200046c8 	.word	0x200046c8
   280bc:	0003bec4 	.word	0x0003bec4
   280c0:	00031600 	.word	0x00031600

000280c4 <slice_expired_locked>:
{
   280c4:	b538      	push	{r3, r4, r5, lr}
   280c6:	4604      	mov	r4, r0
	struct k_thread *curr = _current;
   280c8:	4b07      	ldr	r3, [pc, #28]	; (280e8 <slice_expired_locked+0x24>)
   280ca:	689d      	ldr	r5, [r3, #8]
	uint8_t state = thread->base.thread_state;
   280cc:	7b6b      	ldrb	r3, [r5, #13]
	if (!z_is_thread_prevented_from_running(curr)) {
   280ce:	f013 0f1f 	tst.w	r3, #31
   280d2:	d004      	beq.n	280de <slice_expired_locked+0x1a>
	z_reset_time_slice(curr);
   280d4:	4628      	mov	r0, r5
   280d6:	f7ff fd99 	bl	27c0c <z_reset_time_slice>
}
   280da:	4620      	mov	r0, r4
   280dc:	bd38      	pop	{r3, r4, r5, pc}
		move_thread_to_end_of_prio_q(curr);
   280de:	4628      	mov	r0, r5
   280e0:	f7ff ff98 	bl	28014 <move_thread_to_end_of_prio_q>
   280e4:	e7f6      	b.n	280d4 <slice_expired_locked+0x10>
   280e6:	bf00      	nop
   280e8:	200046a4 	.word	0x200046a4

000280ec <z_time_slice>:
{
   280ec:	b570      	push	{r4, r5, r6, lr}
   280ee:	4604      	mov	r4, r0
	__asm__ volatile(
   280f0:	f04f 0340 	mov.w	r3, #64	; 0x40
   280f4:	f3ef 8511 	mrs	r5, BASEPRI
   280f8:	f383 8812 	msr	BASEPRI_MAX, r3
   280fc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28100:	483a      	ldr	r0, [pc, #232]	; (281ec <z_time_slice+0x100>)
   28102:	f7fe facf 	bl	266a4 <z_spin_lock_valid>
   28106:	b310      	cbz	r0, 2814e <z_time_slice+0x62>
	z_spin_lock_set_owner(l);
   28108:	4838      	ldr	r0, [pc, #224]	; (281ec <z_time_slice+0x100>)
   2810a:	f7fe faeb 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   2810e:	462b      	mov	r3, r5
	if (pending_current == _current) {
   28110:	4a37      	ldr	r2, [pc, #220]	; (281f0 <z_time_slice+0x104>)
   28112:	6892      	ldr	r2, [r2, #8]
   28114:	4937      	ldr	r1, [pc, #220]	; (281f4 <z_time_slice+0x108>)
   28116:	6809      	ldr	r1, [r1, #0]
   28118:	428a      	cmp	r2, r1
   2811a:	d023      	beq.n	28164 <z_time_slice+0x78>
	pending_current = NULL;
   2811c:	4935      	ldr	r1, [pc, #212]	; (281f4 <z_time_slice+0x108>)
   2811e:	2000      	movs	r0, #0
   28120:	6008      	str	r0, [r1, #0]
	int ret = slice_ticks;
   28122:	4935      	ldr	r1, [pc, #212]	; (281f8 <z_time_slice+0x10c>)
   28124:	6809      	ldr	r1, [r1, #0]
	if (slice_time(_current) && sliceable(_current)) {
   28126:	2900      	cmp	r1, #0
   28128:	d048      	beq.n	281bc <z_time_slice+0xd0>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   2812a:	89d1      	ldrh	r1, [r2, #14]
		&& !z_is_idle_thread_object(thread);
   2812c:	297f      	cmp	r1, #127	; 0x7f
   2812e:	d830      	bhi.n	28192 <z_time_slice+0xa6>
   28130:	7b51      	ldrb	r1, [r2, #13]
		&& !z_is_thread_prevented_from_running(thread)
   28132:	f011 0f1f 	tst.w	r1, #31
   28136:	d136      	bne.n	281a6 <z_time_slice+0xba>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   28138:	f992 000e 	ldrsb.w	r0, [r2, #14]
   2813c:	492f      	ldr	r1, [pc, #188]	; (281fc <z_time_slice+0x110>)
   2813e:	6809      	ldr	r1, [r1, #0]
   28140:	4288      	cmp	r0, r1
   28142:	db32      	blt.n	281aa <z_time_slice+0xbe>
		&& !z_is_idle_thread_object(thread);
   28144:	492e      	ldr	r1, [pc, #184]	; (28200 <z_time_slice+0x114>)
   28146:	428a      	cmp	r2, r1
   28148:	d031      	beq.n	281ae <z_time_slice+0xc2>
   2814a:	2201      	movs	r2, #1
   2814c:	e022      	b.n	28194 <z_time_slice+0xa8>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2814e:	4e2d      	ldr	r6, [pc, #180]	; (28204 <z_time_slice+0x118>)
   28150:	228e      	movs	r2, #142	; 0x8e
   28152:	4631      	mov	r1, r6
   28154:	482c      	ldr	r0, [pc, #176]	; (28208 <z_time_slice+0x11c>)
   28156:	f004 f9ea 	bl	2c52e <assert_print>
   2815a:	218e      	movs	r1, #142	; 0x8e
   2815c:	4630      	mov	r0, r6
   2815e:	f004 f9df 	bl	2c520 <assert_post_action>
   28162:	e7d1      	b.n	28108 <z_time_slice+0x1c>
		z_reset_time_slice(_current);
   28164:	4610      	mov	r0, r2
   28166:	f7ff fd51 	bl	27c0c <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2816a:	4820      	ldr	r0, [pc, #128]	; (281ec <z_time_slice+0x100>)
   2816c:	f7fe faaa 	bl	266c4 <z_spin_unlock_valid>
   28170:	b120      	cbz	r0, 2817c <z_time_slice+0x90>
	__asm__ volatile(
   28172:	f385 8811 	msr	BASEPRI, r5
   28176:	f3bf 8f6f 	isb	sy
		return;
   2817a:	e02b      	b.n	281d4 <z_time_slice+0xe8>
   2817c:	4c21      	ldr	r4, [pc, #132]	; (28204 <z_time_slice+0x118>)
   2817e:	22b9      	movs	r2, #185	; 0xb9
   28180:	4621      	mov	r1, r4
   28182:	4821      	ldr	r0, [pc, #132]	; (28208 <z_time_slice+0x11c>)
   28184:	f004 f9d3 	bl	2c52e <assert_print>
   28188:	21b9      	movs	r1, #185	; 0xb9
   2818a:	4620      	mov	r0, r4
   2818c:	f004 f9c8 	bl	2c520 <assert_post_action>
   28190:	e7ef      	b.n	28172 <z_time_slice+0x86>
		&& !z_is_idle_thread_object(thread);
   28192:	2200      	movs	r2, #0
	if (slice_time(_current) && sliceable(_current)) {
   28194:	b192      	cbz	r2, 281bc <z_time_slice+0xd0>
		if (ticks >= _current_cpu->slice_ticks) {
   28196:	4a16      	ldr	r2, [pc, #88]	; (281f0 <z_time_slice+0x104>)
   28198:	6910      	ldr	r0, [r2, #16]
   2819a:	42a0      	cmp	r0, r4
   2819c:	dd09      	ble.n	281b2 <z_time_slice+0xc6>
			_current_cpu->slice_ticks -= ticks;
   2819e:	1b00      	subs	r0, r0, r4
   281a0:	4a13      	ldr	r2, [pc, #76]	; (281f0 <z_time_slice+0x104>)
   281a2:	6110      	str	r0, [r2, #16]
   281a4:	e00d      	b.n	281c2 <z_time_slice+0xd6>
		&& !z_is_idle_thread_object(thread);
   281a6:	2200      	movs	r2, #0
   281a8:	e7f4      	b.n	28194 <z_time_slice+0xa8>
   281aa:	2200      	movs	r2, #0
   281ac:	e7f2      	b.n	28194 <z_time_slice+0xa8>
   281ae:	2200      	movs	r2, #0
   281b0:	e7f0      	b.n	28194 <z_time_slice+0xa8>
			key = slice_expired_locked(key);
   281b2:	4628      	mov	r0, r5
   281b4:	f7ff ff86 	bl	280c4 <slice_expired_locked>
   281b8:	4603      	mov	r3, r0
   281ba:	e002      	b.n	281c2 <z_time_slice+0xd6>
		_current_cpu->slice_ticks = 0;
   281bc:	4a0c      	ldr	r2, [pc, #48]	; (281f0 <z_time_slice+0x104>)
   281be:	2100      	movs	r1, #0
   281c0:	6111      	str	r1, [r2, #16]
	k_spin_unlock(&sched_spinlock, key);
   281c2:	461c      	mov	r4, r3
   281c4:	4809      	ldr	r0, [pc, #36]	; (281ec <z_time_slice+0x100>)
   281c6:	f7fe fa7d 	bl	266c4 <z_spin_unlock_valid>
   281ca:	b120      	cbz	r0, 281d6 <z_time_slice+0xea>
   281cc:	f384 8811 	msr	BASEPRI, r4
   281d0:	f3bf 8f6f 	isb	sy
}
   281d4:	bd70      	pop	{r4, r5, r6, pc}
   281d6:	4d0b      	ldr	r5, [pc, #44]	; (28204 <z_time_slice+0x118>)
   281d8:	22b9      	movs	r2, #185	; 0xb9
   281da:	4629      	mov	r1, r5
   281dc:	480a      	ldr	r0, [pc, #40]	; (28208 <z_time_slice+0x11c>)
   281de:	f004 f9a6 	bl	2c52e <assert_print>
   281e2:	21b9      	movs	r1, #185	; 0xb9
   281e4:	4628      	mov	r0, r5
   281e6:	f004 f99b 	bl	2c520 <assert_post_action>
   281ea:	e7ef      	b.n	281cc <z_time_slice+0xe0>
   281ec:	200046ec 	.word	0x200046ec
   281f0:	200046a4 	.word	0x200046a4
   281f4:	200046e8 	.word	0x200046e8
   281f8:	200046f4 	.word	0x200046f4
   281fc:	200046f0 	.word	0x200046f0
   28200:	200025d0 	.word	0x200025d0
   28204:	000390f0 	.word	0x000390f0
   28208:	00031600 	.word	0x00031600

0002820c <ready_thread>:
{
   2820c:	b538      	push	{r3, r4, r5, lr}
	return (thread->base.thread_state & state) != 0U;
   2820e:	7b43      	ldrb	r3, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   28210:	f990 200d 	ldrsb.w	r2, [r0, #13]
   28214:	2a00      	cmp	r2, #0
   28216:	db30      	blt.n	2827a <ready_thread+0x6e>
   28218:	4604      	mov	r4, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2821a:	f013 0f1f 	tst.w	r3, #31
   2821e:	d105      	bne.n	2822c <ready_thread+0x20>
	return node->next != NULL;
   28220:	6982      	ldr	r2, [r0, #24]
   28222:	b10a      	cbz	r2, 28228 <ready_thread+0x1c>
   28224:	2200      	movs	r2, #0
   28226:	e002      	b.n	2822e <ready_thread+0x22>
   28228:	2201      	movs	r2, #1
   2822a:	e000      	b.n	2822e <ready_thread+0x22>
   2822c:	2200      	movs	r2, #0
   2822e:	b322      	cbz	r2, 2827a <ready_thread+0x6e>
	thread->base.thread_state |= _THREAD_QUEUED;
   28230:	f063 037f 	orn	r3, r3, #127	; 0x7f
   28234:	7363      	strb	r3, [r4, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   28236:	4b1b      	ldr	r3, [pc, #108]	; (282a4 <ready_thread+0x98>)
   28238:	429c      	cmp	r4, r3
   2823a:	d01f      	beq.n	2827c <ready_thread+0x70>
	return list->head == list;
   2823c:	4b1a      	ldr	r3, [pc, #104]	; (282a8 <ready_thread+0x9c>)
   2823e:	f853 5f24 	ldr.w	r5, [r3, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28242:	429d      	cmp	r5, r3
   28244:	d02b      	beq.n	2829e <ready_thread+0x92>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28246:	b16d      	cbz	r5, 28264 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
   28248:	4629      	mov	r1, r5
   2824a:	4620      	mov	r0, r4
   2824c:	f008 fc5c 	bl	30b08 <z_sched_prio_cmp>
   28250:	2800      	cmp	r0, #0
   28252:	dc1e      	bgt.n	28292 <ready_thread+0x86>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   28254:	b135      	cbz	r5, 28264 <ready_thread+0x58>
	return (node == list->tail) ? NULL : node->next;
   28256:	4b14      	ldr	r3, [pc, #80]	; (282a8 <ready_thread+0x9c>)
   28258:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2825a:	429d      	cmp	r5, r3
   2825c:	d002      	beq.n	28264 <ready_thread+0x58>
   2825e:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28260:	2d00      	cmp	r5, #0
   28262:	d1f0      	bne.n	28246 <ready_thread+0x3a>
	sys_dnode_t *const tail = list->tail;
   28264:	4b10      	ldr	r3, [pc, #64]	; (282a8 <ready_thread+0x9c>)
   28266:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	node->next = list;
   28268:	f103 0124 	add.w	r1, r3, #36	; 0x24
   2826c:	6021      	str	r1, [r4, #0]
	node->prev = tail;
   2826e:	6062      	str	r2, [r4, #4]
	tail->next = node;
   28270:	6014      	str	r4, [r2, #0]
	list->tail = node;
   28272:	629c      	str	r4, [r3, #40]	; 0x28
		update_cache(0);
   28274:	2000      	movs	r0, #0
   28276:	f7ff fe93 	bl	27fa0 <update_cache>
}
   2827a:	bd38      	pop	{r3, r4, r5, pc}
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2827c:	4d0b      	ldr	r5, [pc, #44]	; (282ac <ready_thread+0xa0>)
   2827e:	22ba      	movs	r2, #186	; 0xba
   28280:	4629      	mov	r1, r5
   28282:	480b      	ldr	r0, [pc, #44]	; (282b0 <ready_thread+0xa4>)
   28284:	f004 f953 	bl	2c52e <assert_print>
   28288:	21ba      	movs	r1, #186	; 0xba
   2828a:	4628      	mov	r0, r5
   2828c:	f004 f948 	bl	2c520 <assert_post_action>
   28290:	e7d4      	b.n	2823c <ready_thread+0x30>
	sys_dnode_t *const prev = successor->prev;
   28292:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
   28294:	6063      	str	r3, [r4, #4]
	node->next = successor;
   28296:	6025      	str	r5, [r4, #0]
	prev->next = node;
   28298:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   2829a:	606c      	str	r4, [r5, #4]
}
   2829c:	e7ea      	b.n	28274 <ready_thread+0x68>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2829e:	2500      	movs	r5, #0
   282a0:	e7d1      	b.n	28246 <ready_thread+0x3a>
   282a2:	bf00      	nop
   282a4:	200025d0 	.word	0x200025d0
   282a8:	200046a4 	.word	0x200046a4
   282ac:	0003bec4 	.word	0x0003bec4
   282b0:	00031600 	.word	0x00031600

000282b4 <z_ready_thread>:
{
   282b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   282b6:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
   282b8:	2400      	movs	r4, #0
	__asm__ volatile(
   282ba:	f04f 0340 	mov.w	r3, #64	; 0x40
   282be:	f3ef 8611 	mrs	r6, BASEPRI
   282c2:	f383 8812 	msr	BASEPRI_MAX, r3
   282c6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   282ca:	4819      	ldr	r0, [pc, #100]	; (28330 <z_ready_thread+0x7c>)
   282cc:	f7fe f9ea 	bl	266a4 <z_spin_lock_valid>
   282d0:	b118      	cbz	r0, 282da <z_ready_thread+0x26>
	z_spin_lock_set_owner(l);
   282d2:	4817      	ldr	r0, [pc, #92]	; (28330 <z_ready_thread+0x7c>)
   282d4:	f7fe fa06 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   282d8:	e013      	b.n	28302 <z_ready_thread+0x4e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   282da:	4f16      	ldr	r7, [pc, #88]	; (28334 <z_ready_thread+0x80>)
   282dc:	228e      	movs	r2, #142	; 0x8e
   282de:	4639      	mov	r1, r7
   282e0:	4815      	ldr	r0, [pc, #84]	; (28338 <z_ready_thread+0x84>)
   282e2:	f004 f924 	bl	2c52e <assert_print>
   282e6:	218e      	movs	r1, #142	; 0x8e
   282e8:	4638      	mov	r0, r7
   282ea:	f004 f919 	bl	2c520 <assert_post_action>
   282ee:	e7f0      	b.n	282d2 <z_ready_thread+0x1e>
			ready_thread(thread);
   282f0:	4628      	mov	r0, r5
   282f2:	f7ff ff8b 	bl	2820c <ready_thread>
   282f6:	e00a      	b.n	2830e <z_ready_thread+0x5a>
	__asm__ volatile(
   282f8:	f386 8811 	msr	BASEPRI, r6
   282fc:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   28300:	2401      	movs	r4, #1
   28302:	b9a4      	cbnz	r4, 2832e <z_ready_thread+0x7a>
		if (!thread_active_elsewhere(thread)) {
   28304:	4628      	mov	r0, r5
   28306:	f008 fbfd 	bl	30b04 <thread_active_elsewhere>
   2830a:	2800      	cmp	r0, #0
   2830c:	d0f0      	beq.n	282f0 <z_ready_thread+0x3c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2830e:	4808      	ldr	r0, [pc, #32]	; (28330 <z_ready_thread+0x7c>)
   28310:	f7fe f9d8 	bl	266c4 <z_spin_unlock_valid>
   28314:	2800      	cmp	r0, #0
   28316:	d1ef      	bne.n	282f8 <z_ready_thread+0x44>
   28318:	4c06      	ldr	r4, [pc, #24]	; (28334 <z_ready_thread+0x80>)
   2831a:	22b9      	movs	r2, #185	; 0xb9
   2831c:	4621      	mov	r1, r4
   2831e:	4806      	ldr	r0, [pc, #24]	; (28338 <z_ready_thread+0x84>)
   28320:	f004 f905 	bl	2c52e <assert_print>
   28324:	21b9      	movs	r1, #185	; 0xb9
   28326:	4620      	mov	r0, r4
   28328:	f004 f8fa 	bl	2c520 <assert_post_action>
   2832c:	e7e4      	b.n	282f8 <z_ready_thread+0x44>
}
   2832e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   28330:	200046ec 	.word	0x200046ec
   28334:	000390f0 	.word	0x000390f0
   28338:	00031600 	.word	0x00031600

0002833c <z_sched_start>:
{
   2833c:	b570      	push	{r4, r5, r6, lr}
   2833e:	4604      	mov	r4, r0
	__asm__ volatile(
   28340:	f04f 0340 	mov.w	r3, #64	; 0x40
   28344:	f3ef 8511 	mrs	r5, BASEPRI
   28348:	f383 8812 	msr	BASEPRI_MAX, r3
   2834c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28350:	481a      	ldr	r0, [pc, #104]	; (283bc <z_sched_start+0x80>)
   28352:	f7fe f9a7 	bl	266a4 <z_spin_lock_valid>
   28356:	b188      	cbz	r0, 2837c <z_sched_start+0x40>
	z_spin_lock_set_owner(l);
   28358:	4818      	ldr	r0, [pc, #96]	; (283bc <z_sched_start+0x80>)
   2835a:	f7fe f9c3 	bl	266e4 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   2835e:	7b63      	ldrb	r3, [r4, #13]
	if (z_has_thread_started(thread)) {
   28360:	f013 0f04 	tst.w	r3, #4
   28364:	d015      	beq.n	28392 <z_sched_start+0x56>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   28366:	f023 0304 	bic.w	r3, r3, #4
   2836a:	7363      	strb	r3, [r4, #13]
	ready_thread(thread);
   2836c:	4620      	mov	r0, r4
   2836e:	f7ff ff4d 	bl	2820c <ready_thread>
	z_reschedule(&sched_spinlock, key);
   28372:	4629      	mov	r1, r5
   28374:	4811      	ldr	r0, [pc, #68]	; (283bc <z_sched_start+0x80>)
   28376:	f7ff fd09 	bl	27d8c <z_reschedule>
}
   2837a:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2837c:	4e10      	ldr	r6, [pc, #64]	; (283c0 <z_sched_start+0x84>)
   2837e:	228e      	movs	r2, #142	; 0x8e
   28380:	4631      	mov	r1, r6
   28382:	4810      	ldr	r0, [pc, #64]	; (283c4 <z_sched_start+0x88>)
   28384:	f004 f8d3 	bl	2c52e <assert_print>
   28388:	218e      	movs	r1, #142	; 0x8e
   2838a:	4630      	mov	r0, r6
   2838c:	f004 f8c8 	bl	2c520 <assert_post_action>
   28390:	e7e2      	b.n	28358 <z_sched_start+0x1c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28392:	480a      	ldr	r0, [pc, #40]	; (283bc <z_sched_start+0x80>)
   28394:	f7fe f996 	bl	266c4 <z_spin_unlock_valid>
   28398:	b120      	cbz	r0, 283a4 <z_sched_start+0x68>
	__asm__ volatile(
   2839a:	f385 8811 	msr	BASEPRI, r5
   2839e:	f3bf 8f6f 	isb	sy
		return;
   283a2:	e7ea      	b.n	2837a <z_sched_start+0x3e>
   283a4:	4c06      	ldr	r4, [pc, #24]	; (283c0 <z_sched_start+0x84>)
   283a6:	22b9      	movs	r2, #185	; 0xb9
   283a8:	4621      	mov	r1, r4
   283aa:	4806      	ldr	r0, [pc, #24]	; (283c4 <z_sched_start+0x88>)
   283ac:	f004 f8bf 	bl	2c52e <assert_print>
   283b0:	21b9      	movs	r1, #185	; 0xb9
   283b2:	4620      	mov	r0, r4
   283b4:	f004 f8b4 	bl	2c520 <assert_post_action>
   283b8:	e7ef      	b.n	2839a <z_sched_start+0x5e>
   283ba:	bf00      	nop
   283bc:	200046ec 	.word	0x200046ec
   283c0:	000390f0 	.word	0x000390f0
   283c4:	00031600 	.word	0x00031600

000283c8 <z_thread_timeout>:
{
   283c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   283cc:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   283ce:	f1a0 0618 	sub.w	r6, r0, #24
	LOCKED(&sched_spinlock) {
   283d2:	2500      	movs	r5, #0
	__asm__ volatile(
   283d4:	f04f 0340 	mov.w	r3, #64	; 0x40
   283d8:	f3ef 8711 	mrs	r7, BASEPRI
   283dc:	f383 8812 	msr	BASEPRI_MAX, r3
   283e0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   283e4:	4826      	ldr	r0, [pc, #152]	; (28480 <z_thread_timeout+0xb8>)
   283e6:	f7fe f95d 	bl	266a4 <z_spin_lock_valid>
   283ea:	b118      	cbz	r0, 283f4 <z_thread_timeout+0x2c>
	z_spin_lock_set_owner(l);
   283ec:	4824      	ldr	r0, [pc, #144]	; (28480 <z_thread_timeout+0xb8>)
   283ee:	f7fe f979 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   283f2:	e021      	b.n	28438 <z_thread_timeout+0x70>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   283f4:	f8df 8090 	ldr.w	r8, [pc, #144]	; 28488 <z_thread_timeout+0xc0>
   283f8:	228e      	movs	r2, #142	; 0x8e
   283fa:	4641      	mov	r1, r8
   283fc:	4821      	ldr	r0, [pc, #132]	; (28484 <z_thread_timeout+0xbc>)
   283fe:	f004 f896 	bl	2c52e <assert_print>
   28402:	218e      	movs	r1, #142	; 0x8e
   28404:	4640      	mov	r0, r8
   28406:	f004 f88b 	bl	2c520 <assert_post_action>
   2840a:	e7ef      	b.n	283ec <z_thread_timeout+0x24>
   2840c:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   28410:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   28414:	f804 3c0b 	strb.w	r3, [r4, #-11]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   28418:	f023 0310 	bic.w	r3, r3, #16
   2841c:	f804 3c0b 	strb.w	r3, [r4, #-11]
			ready_thread(thread);
   28420:	4630      	mov	r0, r6
   28422:	f7ff fef3 	bl	2820c <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28426:	4816      	ldr	r0, [pc, #88]	; (28480 <z_thread_timeout+0xb8>)
   28428:	f7fe f94c 	bl	266c4 <z_spin_unlock_valid>
   2842c:	b1d8      	cbz	r0, 28466 <z_thread_timeout+0x9e>
	__asm__ volatile(
   2842e:	f387 8811 	msr	BASEPRI, r7
   28432:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   28436:	2501      	movs	r5, #1
   28438:	bb05      	cbnz	r5, 2847c <z_thread_timeout+0xb4>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
   2843a:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
		if (!killed) {
   2843e:	f013 0f28 	tst.w	r3, #40	; 0x28
   28442:	d1f0      	bne.n	28426 <z_thread_timeout+0x5e>
			if (thread->base.pended_on != NULL) {
   28444:	f854 3c10 	ldr.w	r3, [r4, #-16]
   28448:	2b00      	cmp	r3, #0
   2844a:	d0df      	beq.n	2840c <z_thread_timeout+0x44>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   2844c:	4630      	mov	r0, r6
   2844e:	f7ff fbb5 	bl	27bbc <pended_on_thread>
   28452:	4631      	mov	r1, r6
   28454:	f7ff fd38 	bl	27ec8 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   28458:	7b73      	ldrb	r3, [r6, #13]
   2845a:	f023 0302 	bic.w	r3, r3, #2
   2845e:	7373      	strb	r3, [r6, #13]
	thread->base.pended_on = NULL;
   28460:	2300      	movs	r3, #0
   28462:	60b3      	str	r3, [r6, #8]
}
   28464:	e7d2      	b.n	2840c <z_thread_timeout+0x44>
   28466:	4d08      	ldr	r5, [pc, #32]	; (28488 <z_thread_timeout+0xc0>)
   28468:	22b9      	movs	r2, #185	; 0xb9
   2846a:	4629      	mov	r1, r5
   2846c:	4805      	ldr	r0, [pc, #20]	; (28484 <z_thread_timeout+0xbc>)
   2846e:	f004 f85e 	bl	2c52e <assert_print>
   28472:	21b9      	movs	r1, #185	; 0xb9
   28474:	4628      	mov	r0, r5
   28476:	f004 f853 	bl	2c520 <assert_post_action>
   2847a:	e7d8      	b.n	2842e <z_thread_timeout+0x66>
}
   2847c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   28480:	200046ec 	.word	0x200046ec
   28484:	00031600 	.word	0x00031600
   28488:	000390f0 	.word	0x000390f0

0002848c <unready_thread>:
{
   2848c:	b510      	push	{r4, lr}
   2848e:	4604      	mov	r4, r0
	return (thread->base.thread_state & state) != 0U;
   28490:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
   28492:	f990 300d 	ldrsb.w	r3, [r0, #13]
   28496:	2b00      	cmp	r3, #0
   28498:	db08      	blt.n	284ac <unready_thread+0x20>
	update_cache(thread == _current);
   2849a:	4b08      	ldr	r3, [pc, #32]	; (284bc <unready_thread+0x30>)
   2849c:	6898      	ldr	r0, [r3, #8]
   2849e:	42a0      	cmp	r0, r4
   284a0:	bf14      	ite	ne
   284a2:	2000      	movne	r0, #0
   284a4:	2001      	moveq	r0, #1
   284a6:	f7ff fd7b 	bl	27fa0 <update_cache>
}
   284aa:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
   284ac:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   284b0:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
   284b2:	4601      	mov	r1, r0
   284b4:	4802      	ldr	r0, [pc, #8]	; (284c0 <unready_thread+0x34>)
   284b6:	f7ff fd07 	bl	27ec8 <z_priq_dumb_remove>
}
   284ba:	e7ee      	b.n	2849a <unready_thread+0xe>
   284bc:	200046a4 	.word	0x200046a4
   284c0:	200046c8 	.word	0x200046c8

000284c4 <add_to_waitq_locked>:
{
   284c4:	b570      	push	{r4, r5, r6, lr}
   284c6:	4605      	mov	r5, r0
   284c8:	460e      	mov	r6, r1
	unready_thread(thread);
   284ca:	f7ff ffdf 	bl	2848c <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   284ce:	7b6b      	ldrb	r3, [r5, #13]
   284d0:	f043 0302 	orr.w	r3, r3, #2
   284d4:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
   284d6:	b1ce      	cbz	r6, 2850c <add_to_waitq_locked+0x48>
		thread->base.pended_on = wait_q;
   284d8:	60ae      	str	r6, [r5, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   284da:	4b16      	ldr	r3, [pc, #88]	; (28534 <add_to_waitq_locked+0x70>)
   284dc:	429d      	cmp	r5, r3
   284de:	d016      	beq.n	2850e <add_to_waitq_locked+0x4a>
	return list->head == list;
   284e0:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   284e2:	42a6      	cmp	r6, r4
   284e4:	d024      	beq.n	28530 <add_to_waitq_locked+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   284e6:	b164      	cbz	r4, 28502 <add_to_waitq_locked+0x3e>
		if (z_sched_prio_cmp(thread, t) > 0) {
   284e8:	4621      	mov	r1, r4
   284ea:	4628      	mov	r0, r5
   284ec:	f008 fb0c 	bl	30b08 <z_sched_prio_cmp>
   284f0:	2800      	cmp	r0, #0
   284f2:	dc17      	bgt.n	28524 <add_to_waitq_locked+0x60>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   284f4:	b12c      	cbz	r4, 28502 <add_to_waitq_locked+0x3e>
	return (node == list->tail) ? NULL : node->next;
   284f6:	6873      	ldr	r3, [r6, #4]
   284f8:	429c      	cmp	r4, r3
   284fa:	d002      	beq.n	28502 <add_to_waitq_locked+0x3e>
   284fc:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   284fe:	2c00      	cmp	r4, #0
   28500:	d1f1      	bne.n	284e6 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
   28502:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   28504:	602e      	str	r6, [r5, #0]
	node->prev = tail;
   28506:	606b      	str	r3, [r5, #4]
	tail->next = node;
   28508:	601d      	str	r5, [r3, #0]
	list->tail = node;
   2850a:	6075      	str	r5, [r6, #4]
}
   2850c:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2850e:	4c0a      	ldr	r4, [pc, #40]	; (28538 <add_to_waitq_locked+0x74>)
   28510:	22ba      	movs	r2, #186	; 0xba
   28512:	4621      	mov	r1, r4
   28514:	4809      	ldr	r0, [pc, #36]	; (2853c <add_to_waitq_locked+0x78>)
   28516:	f004 f80a 	bl	2c52e <assert_print>
   2851a:	21ba      	movs	r1, #186	; 0xba
   2851c:	4620      	mov	r0, r4
   2851e:	f003 ffff 	bl	2c520 <assert_post_action>
   28522:	e7dd      	b.n	284e0 <add_to_waitq_locked+0x1c>
	sys_dnode_t *const prev = successor->prev;
   28524:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
   28526:	606b      	str	r3, [r5, #4]
	node->next = successor;
   28528:	602c      	str	r4, [r5, #0]
	prev->next = node;
   2852a:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   2852c:	6065      	str	r5, [r4, #4]
}
   2852e:	e7ed      	b.n	2850c <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28530:	2400      	movs	r4, #0
   28532:	e7d8      	b.n	284e6 <add_to_waitq_locked+0x22>
   28534:	200025d0 	.word	0x200025d0
   28538:	0003bec4 	.word	0x0003bec4
   2853c:	00031600 	.word	0x00031600

00028540 <pend>:
{
   28540:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28544:	4605      	mov	r5, r0
   28546:	460e      	mov	r6, r1
   28548:	4691      	mov	r9, r2
   2854a:	4698      	mov	r8, r3
	LOCKED(&sched_spinlock) {
   2854c:	2400      	movs	r4, #0
	__asm__ volatile(
   2854e:	f04f 0340 	mov.w	r3, #64	; 0x40
   28552:	f3ef 8711 	mrs	r7, BASEPRI
   28556:	f383 8812 	msr	BASEPRI_MAX, r3
   2855a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2855e:	481a      	ldr	r0, [pc, #104]	; (285c8 <pend+0x88>)
   28560:	f7fe f8a0 	bl	266a4 <z_spin_lock_valid>
   28564:	b118      	cbz	r0, 2856e <pend+0x2e>
	z_spin_lock_set_owner(l);
   28566:	4818      	ldr	r0, [pc, #96]	; (285c8 <pend+0x88>)
   28568:	f7fe f8bc 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   2856c:	e010      	b.n	28590 <pend+0x50>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2856e:	f8df a060 	ldr.w	sl, [pc, #96]	; 285d0 <pend+0x90>
   28572:	228e      	movs	r2, #142	; 0x8e
   28574:	4651      	mov	r1, sl
   28576:	4815      	ldr	r0, [pc, #84]	; (285cc <pend+0x8c>)
   28578:	f003 ffd9 	bl	2c52e <assert_print>
   2857c:	218e      	movs	r1, #142	; 0x8e
   2857e:	4650      	mov	r0, sl
   28580:	f003 ffce 	bl	2c520 <assert_post_action>
   28584:	e7ef      	b.n	28566 <pend+0x26>
	__asm__ volatile(
   28586:	f387 8811 	msr	BASEPRI, r7
   2858a:	f3bf 8f6f 	isb	sy
   2858e:	2401      	movs	r4, #1
   28590:	b99c      	cbnz	r4, 285ba <pend+0x7a>
		add_to_waitq_locked(thread, wait_q);
   28592:	4631      	mov	r1, r6
   28594:	4628      	mov	r0, r5
   28596:	f7ff ff95 	bl	284c4 <add_to_waitq_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2859a:	480b      	ldr	r0, [pc, #44]	; (285c8 <pend+0x88>)
   2859c:	f7fe f892 	bl	266c4 <z_spin_unlock_valid>
   285a0:	2800      	cmp	r0, #0
   285a2:	d1f0      	bne.n	28586 <pend+0x46>
   285a4:	4c0a      	ldr	r4, [pc, #40]	; (285d0 <pend+0x90>)
   285a6:	22b9      	movs	r2, #185	; 0xb9
   285a8:	4621      	mov	r1, r4
   285aa:	4808      	ldr	r0, [pc, #32]	; (285cc <pend+0x8c>)
   285ac:	f003 ffbf 	bl	2c52e <assert_print>
   285b0:	21b9      	movs	r1, #185	; 0xb9
   285b2:	4620      	mov	r0, r4
   285b4:	f003 ffb4 	bl	2c520 <assert_post_action>
   285b8:	e7e5      	b.n	28586 <pend+0x46>
	add_thread_timeout(thread, timeout);
   285ba:	464a      	mov	r2, r9
   285bc:	4643      	mov	r3, r8
   285be:	4628      	mov	r0, r5
   285c0:	f7ff fb14 	bl	27bec <add_thread_timeout>
}
   285c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   285c8:	200046ec 	.word	0x200046ec
   285cc:	00031600 	.word	0x00031600
   285d0:	000390f0 	.word	0x000390f0

000285d4 <z_pend_curr>:
{
   285d4:	b538      	push	{r3, r4, r5, lr}
   285d6:	4605      	mov	r5, r0
   285d8:	460c      	mov	r4, r1
   285da:	4611      	mov	r1, r2
	pending_current = _current;
   285dc:	4b0d      	ldr	r3, [pc, #52]	; (28614 <z_pend_curr+0x40>)
   285de:	6898      	ldr	r0, [r3, #8]
   285e0:	4b0d      	ldr	r3, [pc, #52]	; (28618 <z_pend_curr+0x44>)
   285e2:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   285e4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   285e8:	f7ff ffaa 	bl	28540 <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   285ec:	4628      	mov	r0, r5
   285ee:	f7fe f869 	bl	266c4 <z_spin_unlock_valid>
   285f2:	b118      	cbz	r0, 285fc <z_pend_curr+0x28>
   285f4:	4620      	mov	r0, r4
   285f6:	f7ef feef 	bl	183d8 <arch_swap>
}
   285fa:	bd38      	pop	{r3, r4, r5, pc}
   285fc:	4d07      	ldr	r5, [pc, #28]	; (2861c <z_pend_curr+0x48>)
   285fe:	22d0      	movs	r2, #208	; 0xd0
   28600:	4629      	mov	r1, r5
   28602:	4807      	ldr	r0, [pc, #28]	; (28620 <z_pend_curr+0x4c>)
   28604:	f003 ff93 	bl	2c52e <assert_print>
   28608:	21d0      	movs	r1, #208	; 0xd0
   2860a:	4628      	mov	r0, r5
   2860c:	f003 ff88 	bl	2c520 <assert_post_action>
   28610:	e7f0      	b.n	285f4 <z_pend_curr+0x20>
   28612:	bf00      	nop
   28614:	200046a4 	.word	0x200046a4
   28618:	200046e8 	.word	0x200046e8
   2861c:	000390f0 	.word	0x000390f0
   28620:	00031600 	.word	0x00031600

00028624 <z_set_prio>:
{
   28624:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28628:	4604      	mov	r4, r0
   2862a:	460e      	mov	r6, r1
	LOCKED(&sched_spinlock) {
   2862c:	2500      	movs	r5, #0
	__asm__ volatile(
   2862e:	f04f 0340 	mov.w	r3, #64	; 0x40
   28632:	f3ef 8811 	mrs	r8, BASEPRI
   28636:	f383 8812 	msr	BASEPRI_MAX, r3
   2863a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2863e:	483f      	ldr	r0, [pc, #252]	; (2873c <z_set_prio+0x118>)
   28640:	f7fe f830 	bl	266a4 <z_spin_lock_valid>
   28644:	b120      	cbz	r0, 28650 <z_set_prio+0x2c>
	z_spin_lock_set_owner(l);
   28646:	483d      	ldr	r0, [pc, #244]	; (2873c <z_set_prio+0x118>)
   28648:	f7fe f84c 	bl	266e4 <z_spin_lock_set_owner>
	bool need_sched = 0;
   2864c:	2700      	movs	r7, #0
	return k;
   2864e:	e018      	b.n	28682 <z_set_prio+0x5e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28650:	4f3b      	ldr	r7, [pc, #236]	; (28740 <z_set_prio+0x11c>)
   28652:	228e      	movs	r2, #142	; 0x8e
   28654:	4639      	mov	r1, r7
   28656:	483b      	ldr	r0, [pc, #236]	; (28744 <z_set_prio+0x120>)
   28658:	f003 ff69 	bl	2c52e <assert_print>
   2865c:	218e      	movs	r1, #142	; 0x8e
   2865e:	4638      	mov	r0, r7
   28660:	f003 ff5e 	bl	2c520 <assert_post_action>
   28664:	e7ef      	b.n	28646 <z_set_prio+0x22>
		if (need_sched) {
   28666:	f013 0701 	ands.w	r7, r3, #1
   2866a:	d116      	bne.n	2869a <z_set_prio+0x76>
			thread->base.prio = prio;
   2866c:	73a6      	strb	r6, [r4, #14]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2866e:	4833      	ldr	r0, [pc, #204]	; (2873c <z_set_prio+0x118>)
   28670:	f7fe f828 	bl	266c4 <z_spin_unlock_valid>
   28674:	2800      	cmp	r0, #0
   28676:	d052      	beq.n	2871e <z_set_prio+0xfa>
	__asm__ volatile(
   28678:	f388 8811 	msr	BASEPRI, r8
   2867c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   28680:	2501      	movs	r5, #1
   28682:	462b      	mov	r3, r5
   28684:	2d00      	cmp	r5, #0
   28686:	d155      	bne.n	28734 <z_set_prio+0x110>
	uint8_t state = thread->base.thread_state;
   28688:	7b62      	ldrb	r2, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   2868a:	f012 0f1f 	tst.w	r2, #31
   2868e:	d1ea      	bne.n	28666 <z_set_prio+0x42>
	return node->next != NULL;
   28690:	69a1      	ldr	r1, [r4, #24]
   28692:	2900      	cmp	r1, #0
   28694:	d1e7      	bne.n	28666 <z_set_prio+0x42>
   28696:	2301      	movs	r3, #1
   28698:	e7e5      	b.n	28666 <z_set_prio+0x42>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   2869a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   2869e:	7362      	strb	r2, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
   286a0:	4621      	mov	r1, r4
   286a2:	4829      	ldr	r0, [pc, #164]	; (28748 <z_set_prio+0x124>)
   286a4:	f7ff fc10 	bl	27ec8 <z_priq_dumb_remove>
				thread->base.prio = prio;
   286a8:	73a6      	strb	r6, [r4, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   286aa:	7b63      	ldrb	r3, [r4, #13]
   286ac:	f063 037f 	orn	r3, r3, #127	; 0x7f
   286b0:	7363      	strb	r3, [r4, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   286b2:	4b26      	ldr	r3, [pc, #152]	; (2874c <z_set_prio+0x128>)
   286b4:	429c      	cmp	r4, r3
   286b6:	d01f      	beq.n	286f8 <z_set_prio+0xd4>
	return list->head == list;
   286b8:	4b25      	ldr	r3, [pc, #148]	; (28750 <z_set_prio+0x12c>)
   286ba:	f853 5f24 	ldr.w	r5, [r3, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   286be:	429d      	cmp	r5, r3
   286c0:	d02b      	beq.n	2871a <z_set_prio+0xf6>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   286c2:	b16d      	cbz	r5, 286e0 <z_set_prio+0xbc>
		if (z_sched_prio_cmp(thread, t) > 0) {
   286c4:	4629      	mov	r1, r5
   286c6:	4620      	mov	r0, r4
   286c8:	f008 fa1e 	bl	30b08 <z_sched_prio_cmp>
   286cc:	2800      	cmp	r0, #0
   286ce:	dc1e      	bgt.n	2870e <z_set_prio+0xea>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   286d0:	b135      	cbz	r5, 286e0 <z_set_prio+0xbc>
	return (node == list->tail) ? NULL : node->next;
   286d2:	4b1f      	ldr	r3, [pc, #124]	; (28750 <z_set_prio+0x12c>)
   286d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   286d6:	429d      	cmp	r5, r3
   286d8:	d002      	beq.n	286e0 <z_set_prio+0xbc>
   286da:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   286dc:	2d00      	cmp	r5, #0
   286de:	d1f0      	bne.n	286c2 <z_set_prio+0x9e>
	sys_dnode_t *const tail = list->tail;
   286e0:	4b1b      	ldr	r3, [pc, #108]	; (28750 <z_set_prio+0x12c>)
   286e2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	node->next = list;
   286e4:	f103 0124 	add.w	r1, r3, #36	; 0x24
   286e8:	6021      	str	r1, [r4, #0]
	node->prev = tail;
   286ea:	6062      	str	r2, [r4, #4]
	tail->next = node;
   286ec:	6014      	str	r4, [r2, #0]
	list->tail = node;
   286ee:	629c      	str	r4, [r3, #40]	; 0x28
			update_cache(1);
   286f0:	2001      	movs	r0, #1
   286f2:	f7ff fc55 	bl	27fa0 <update_cache>
   286f6:	e7ba      	b.n	2866e <z_set_prio+0x4a>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   286f8:	4d16      	ldr	r5, [pc, #88]	; (28754 <z_set_prio+0x130>)
   286fa:	22ba      	movs	r2, #186	; 0xba
   286fc:	4629      	mov	r1, r5
   286fe:	4811      	ldr	r0, [pc, #68]	; (28744 <z_set_prio+0x120>)
   28700:	f003 ff15 	bl	2c52e <assert_print>
   28704:	21ba      	movs	r1, #186	; 0xba
   28706:	4628      	mov	r0, r5
   28708:	f003 ff0a 	bl	2c520 <assert_post_action>
   2870c:	e7d4      	b.n	286b8 <z_set_prio+0x94>
	sys_dnode_t *const prev = successor->prev;
   2870e:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
   28710:	6063      	str	r3, [r4, #4]
	node->next = successor;
   28712:	6025      	str	r5, [r4, #0]
	prev->next = node;
   28714:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   28716:	606c      	str	r4, [r5, #4]
}
   28718:	e7ea      	b.n	286f0 <z_set_prio+0xcc>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2871a:	2500      	movs	r5, #0
   2871c:	e7d1      	b.n	286c2 <z_set_prio+0x9e>
   2871e:	4d08      	ldr	r5, [pc, #32]	; (28740 <z_set_prio+0x11c>)
   28720:	22b9      	movs	r2, #185	; 0xb9
   28722:	4629      	mov	r1, r5
   28724:	4807      	ldr	r0, [pc, #28]	; (28744 <z_set_prio+0x120>)
   28726:	f003 ff02 	bl	2c52e <assert_print>
   2872a:	21b9      	movs	r1, #185	; 0xb9
   2872c:	4628      	mov	r0, r5
   2872e:	f003 fef7 	bl	2c520 <assert_post_action>
   28732:	e7a1      	b.n	28678 <z_set_prio+0x54>
}
   28734:	4638      	mov	r0, r7
   28736:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2873a:	bf00      	nop
   2873c:	200046ec 	.word	0x200046ec
   28740:	000390f0 	.word	0x000390f0
   28744:	00031600 	.word	0x00031600
   28748:	200046c8 	.word	0x200046c8
   2874c:	200025d0 	.word	0x200025d0
   28750:	200046a4 	.word	0x200046a4
   28754:	0003bec4 	.word	0x0003bec4

00028758 <z_impl_k_thread_suspend>:
{
   28758:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2875a:	4604      	mov	r4, r0
   2875c:	3018      	adds	r0, #24
   2875e:	f000 fd8f 	bl	29280 <z_abort_timeout>
	LOCKED(&sched_spinlock) {
   28762:	2500      	movs	r5, #0
	__asm__ volatile(
   28764:	f04f 0340 	mov.w	r3, #64	; 0x40
   28768:	f3ef 8611 	mrs	r6, BASEPRI
   2876c:	f383 8812 	msr	BASEPRI_MAX, r3
   28770:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28774:	4828      	ldr	r0, [pc, #160]	; (28818 <z_impl_k_thread_suspend+0xc0>)
   28776:	f7fd ff95 	bl	266a4 <z_spin_lock_valid>
   2877a:	b118      	cbz	r0, 28784 <z_impl_k_thread_suspend+0x2c>
	z_spin_lock_set_owner(l);
   2877c:	4826      	ldr	r0, [pc, #152]	; (28818 <z_impl_k_thread_suspend+0xc0>)
   2877e:	f7fd ffb1 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   28782:	e017      	b.n	287b4 <z_impl_k_thread_suspend+0x5c>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28784:	4f25      	ldr	r7, [pc, #148]	; (2881c <z_impl_k_thread_suspend+0xc4>)
   28786:	228e      	movs	r2, #142	; 0x8e
   28788:	4639      	mov	r1, r7
   2878a:	4825      	ldr	r0, [pc, #148]	; (28820 <z_impl_k_thread_suspend+0xc8>)
   2878c:	f003 fecf 	bl	2c52e <assert_print>
   28790:	218e      	movs	r1, #142	; 0x8e
   28792:	4638      	mov	r0, r7
   28794:	f003 fec4 	bl	2c520 <assert_post_action>
   28798:	e7f0      	b.n	2877c <z_impl_k_thread_suspend+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   2879a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   2879e:	7362      	strb	r2, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
   287a0:	4621      	mov	r1, r4
   287a2:	4820      	ldr	r0, [pc, #128]	; (28824 <z_impl_k_thread_suspend+0xcc>)
   287a4:	f7ff fb90 	bl	27ec8 <z_priq_dumb_remove>
}
   287a8:	e00a      	b.n	287c0 <z_impl_k_thread_suspend+0x68>
	__asm__ volatile(
   287aa:	f386 8811 	msr	BASEPRI, r6
   287ae:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   287b2:	2501      	movs	r5, #1
   287b4:	bb05      	cbnz	r5, 287f8 <z_impl_k_thread_suspend+0xa0>
	return (thread->base.thread_state & state) != 0U;
   287b6:	7b62      	ldrb	r2, [r4, #13]
		if (z_is_thread_queued(thread)) {
   287b8:	f994 300d 	ldrsb.w	r3, [r4, #13]
   287bc:	2b00      	cmp	r3, #0
   287be:	dbec      	blt.n	2879a <z_impl_k_thread_suspend+0x42>
	thread->base.thread_state |= _THREAD_SUSPENDED;
   287c0:	7b63      	ldrb	r3, [r4, #13]
   287c2:	f043 0310 	orr.w	r3, r3, #16
   287c6:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   287c8:	4b17      	ldr	r3, [pc, #92]	; (28828 <z_impl_k_thread_suspend+0xd0>)
   287ca:	6898      	ldr	r0, [r3, #8]
   287cc:	42a0      	cmp	r0, r4
   287ce:	bf14      	ite	ne
   287d0:	2000      	movne	r0, #0
   287d2:	2001      	moveq	r0, #1
   287d4:	f7ff fbe4 	bl	27fa0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   287d8:	480f      	ldr	r0, [pc, #60]	; (28818 <z_impl_k_thread_suspend+0xc0>)
   287da:	f7fd ff73 	bl	266c4 <z_spin_unlock_valid>
   287de:	2800      	cmp	r0, #0
   287e0:	d1e3      	bne.n	287aa <z_impl_k_thread_suspend+0x52>
   287e2:	4d0e      	ldr	r5, [pc, #56]	; (2881c <z_impl_k_thread_suspend+0xc4>)
   287e4:	22b9      	movs	r2, #185	; 0xb9
   287e6:	4629      	mov	r1, r5
   287e8:	480d      	ldr	r0, [pc, #52]	; (28820 <z_impl_k_thread_suspend+0xc8>)
   287ea:	f003 fea0 	bl	2c52e <assert_print>
   287ee:	21b9      	movs	r1, #185	; 0xb9
   287f0:	4628      	mov	r0, r5
   287f2:	f003 fe95 	bl	2c520 <assert_post_action>
   287f6:	e7d8      	b.n	287aa <z_impl_k_thread_suspend+0x52>
	if (thread == _current) {
   287f8:	4b0b      	ldr	r3, [pc, #44]	; (28828 <z_impl_k_thread_suspend+0xd0>)
   287fa:	689b      	ldr	r3, [r3, #8]
   287fc:	42a3      	cmp	r3, r4
   287fe:	d000      	beq.n	28802 <z_impl_k_thread_suspend+0xaa>
}
   28800:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__asm__ volatile(
   28802:	f04f 0340 	mov.w	r3, #64	; 0x40
   28806:	f3ef 8011 	mrs	r0, BASEPRI
   2880a:	f383 8812 	msr	BASEPRI_MAX, r3
   2880e:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   28812:	f008 f983 	bl	30b1c <z_reschedule_irqlock>
   28816:	e7f3      	b.n	28800 <z_impl_k_thread_suspend+0xa8>
   28818:	200046ec 	.word	0x200046ec
   2881c:	000390f0 	.word	0x000390f0
   28820:	00031600 	.word	0x00031600
   28824:	200046c8 	.word	0x200046c8
   28828:	200046a4 	.word	0x200046a4

0002882c <k_sched_unlock>:
{
   2882c:	b570      	push	{r4, r5, r6, lr}
	LOCKED(&sched_spinlock) {
   2882e:	2400      	movs	r4, #0
   28830:	f04f 0340 	mov.w	r3, #64	; 0x40
   28834:	f3ef 8511 	mrs	r5, BASEPRI
   28838:	f383 8812 	msr	BASEPRI_MAX, r3
   2883c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28840:	482f      	ldr	r0, [pc, #188]	; (28900 <k_sched_unlock+0xd4>)
   28842:	f7fd ff2f 	bl	266a4 <z_spin_lock_valid>
   28846:	b118      	cbz	r0, 28850 <k_sched_unlock+0x24>
	z_spin_lock_set_owner(l);
   28848:	482d      	ldr	r0, [pc, #180]	; (28900 <k_sched_unlock+0xd4>)
   2884a:	f7fd ff4b 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   2884e:	e029      	b.n	288a4 <k_sched_unlock+0x78>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28850:	4e2c      	ldr	r6, [pc, #176]	; (28904 <k_sched_unlock+0xd8>)
   28852:	228e      	movs	r2, #142	; 0x8e
   28854:	4631      	mov	r1, r6
   28856:	482c      	ldr	r0, [pc, #176]	; (28908 <k_sched_unlock+0xdc>)
   28858:	f003 fe69 	bl	2c52e <assert_print>
   2885c:	218e      	movs	r1, #142	; 0x8e
   2885e:	4630      	mov	r0, r6
   28860:	f003 fe5e 	bl	2c520 <assert_post_action>
   28864:	e7f0      	b.n	28848 <k_sched_unlock+0x1c>
		__ASSERT(_current->base.sched_locked != 0U, "");
   28866:	4c29      	ldr	r4, [pc, #164]	; (2890c <k_sched_unlock+0xe0>)
   28868:	f240 32d6 	movw	r2, #982	; 0x3d6
   2886c:	4621      	mov	r1, r4
   2886e:	4826      	ldr	r0, [pc, #152]	; (28908 <k_sched_unlock+0xdc>)
   28870:	f003 fe5d 	bl	2c52e <assert_print>
   28874:	f240 31d6 	movw	r1, #982	; 0x3d6
   28878:	4620      	mov	r0, r4
   2887a:	f003 fe51 	bl	2c520 <assert_post_action>
   2887e:	e017      	b.n	288b0 <k_sched_unlock+0x84>
		__ASSERT(!arch_is_in_isr(), "");
   28880:	4c22      	ldr	r4, [pc, #136]	; (2890c <k_sched_unlock+0xe0>)
   28882:	f240 32d7 	movw	r2, #983	; 0x3d7
   28886:	4621      	mov	r1, r4
   28888:	481f      	ldr	r0, [pc, #124]	; (28908 <k_sched_unlock+0xdc>)
   2888a:	f003 fe50 	bl	2c52e <assert_print>
   2888e:	f240 31d7 	movw	r1, #983	; 0x3d7
   28892:	4620      	mov	r0, r4
   28894:	f003 fe44 	bl	2c520 <assert_post_action>
   28898:	e00e      	b.n	288b8 <k_sched_unlock+0x8c>
	__asm__ volatile(
   2889a:	f385 8811 	msr	BASEPRI, r5
   2889e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   288a2:	2401      	movs	r4, #1
   288a4:	bb04      	cbnz	r4, 288e8 <k_sched_unlock+0xbc>
		__ASSERT(_current->base.sched_locked != 0U, "");
   288a6:	4b1a      	ldr	r3, [pc, #104]	; (28910 <k_sched_unlock+0xe4>)
   288a8:	689b      	ldr	r3, [r3, #8]
   288aa:	7bdb      	ldrb	r3, [r3, #15]
   288ac:	2b00      	cmp	r3, #0
   288ae:	d0da      	beq.n	28866 <k_sched_unlock+0x3a>
   288b0:	f3ef 8305 	mrs	r3, IPSR
		__ASSERT(!arch_is_in_isr(), "");
   288b4:	2b00      	cmp	r3, #0
   288b6:	d1e3      	bne.n	28880 <k_sched_unlock+0x54>
		++_current->base.sched_locked;
   288b8:	4b15      	ldr	r3, [pc, #84]	; (28910 <k_sched_unlock+0xe4>)
   288ba:	689a      	ldr	r2, [r3, #8]
   288bc:	7bd3      	ldrb	r3, [r2, #15]
   288be:	3301      	adds	r3, #1
   288c0:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   288c2:	2000      	movs	r0, #0
   288c4:	f7ff fb6c 	bl	27fa0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   288c8:	480d      	ldr	r0, [pc, #52]	; (28900 <k_sched_unlock+0xd4>)
   288ca:	f7fd fefb 	bl	266c4 <z_spin_unlock_valid>
   288ce:	2800      	cmp	r0, #0
   288d0:	d1e3      	bne.n	2889a <k_sched_unlock+0x6e>
   288d2:	4c0c      	ldr	r4, [pc, #48]	; (28904 <k_sched_unlock+0xd8>)
   288d4:	22b9      	movs	r2, #185	; 0xb9
   288d6:	4621      	mov	r1, r4
   288d8:	480b      	ldr	r0, [pc, #44]	; (28908 <k_sched_unlock+0xdc>)
   288da:	f003 fe28 	bl	2c52e <assert_print>
   288de:	21b9      	movs	r1, #185	; 0xb9
   288e0:	4620      	mov	r0, r4
   288e2:	f003 fe1d 	bl	2c520 <assert_post_action>
   288e6:	e7d8      	b.n	2889a <k_sched_unlock+0x6e>
	__asm__ volatile(
   288e8:	f04f 0340 	mov.w	r3, #64	; 0x40
   288ec:	f3ef 8011 	mrs	r0, BASEPRI
   288f0:	f383 8812 	msr	BASEPRI_MAX, r3
   288f4:	f3bf 8f6f 	isb	sy
   288f8:	f008 f910 	bl	30b1c <z_reschedule_irqlock>
}
   288fc:	bd70      	pop	{r4, r5, r6, pc}
   288fe:	bf00      	nop
   28900:	200046ec 	.word	0x200046ec
   28904:	000390f0 	.word	0x000390f0
   28908:	00031600 	.word	0x00031600
   2890c:	0003bec4 	.word	0x0003bec4
   28910:	200046a4 	.word	0x200046a4

00028914 <end_thread>:
static void end_thread(struct k_thread *thread)
{
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
   28914:	7b43      	ldrb	r3, [r0, #13]
   28916:	f013 0f08 	tst.w	r3, #8
   2891a:	d143      	bne.n	289a4 <end_thread+0x90>
{
   2891c:	b570      	push	{r4, r5, r6, lr}
   2891e:	4605      	mov	r5, r0
		thread->base.thread_state |= _THREAD_DEAD;
   28920:	f043 0308 	orr.w	r3, r3, #8
   28924:	7343      	strb	r3, [r0, #13]
		thread->base.thread_state &= ~_THREAD_ABORTING;
   28926:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   2892a:	7343      	strb	r3, [r0, #13]
		if (z_is_thread_queued(thread)) {
   2892c:	f013 0f80 	tst.w	r3, #128	; 0x80
   28930:	d12c      	bne.n	2898c <end_thread+0x78>
			dequeue_thread(thread);
		}
		if (thread->base.pended_on != NULL) {
   28932:	68ab      	ldr	r3, [r5, #8]
   28934:	b15b      	cbz	r3, 2894e <end_thread+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   28936:	4628      	mov	r0, r5
   28938:	f7ff f940 	bl	27bbc <pended_on_thread>
   2893c:	4629      	mov	r1, r5
   2893e:	f7ff fac3 	bl	27ec8 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   28942:	7b6b      	ldrb	r3, [r5, #13]
   28944:	f023 0302 	bic.w	r3, r3, #2
   28948:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
   2894a:	2300      	movs	r3, #0
   2894c:	60ab      	str	r3, [r5, #8]
   2894e:	f105 0018 	add.w	r0, r5, #24
   28952:	f000 fc95 	bl	29280 <z_abort_timeout>
			unpend_thread_no_timeout(thread);
		}
		(void)z_abort_thread_timeout(thread);
		unpend_all(&thread->join_queue);
   28956:	3558      	adds	r5, #88	; 0x58
	return list->head == list;
   28958:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2895a:	42ac      	cmp	r4, r5
   2895c:	d01e      	beq.n	2899c <end_thread+0x88>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   2895e:	b1ec      	cbz	r4, 2899c <end_thread+0x88>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   28960:	4620      	mov	r0, r4
   28962:	f7ff f92b 	bl	27bbc <pended_on_thread>
   28966:	4621      	mov	r1, r4
   28968:	f7ff faae 	bl	27ec8 <z_priq_dumb_remove>
   2896c:	7b63      	ldrb	r3, [r4, #13]
   2896e:	f023 0302 	bic.w	r3, r3, #2
   28972:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   28974:	2600      	movs	r6, #0
   28976:	60a6      	str	r6, [r4, #8]
   28978:	f104 0018 	add.w	r0, r4, #24
   2897c:	f000 fc80 	bl	29280 <z_abort_timeout>
   28980:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
		ready_thread(thread);
   28984:	4620      	mov	r0, r4
   28986:	f7ff fc41 	bl	2820c <ready_thread>
   2898a:	e7e5      	b.n	28958 <end_thread+0x44>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   2898c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   28990:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
   28992:	4601      	mov	r1, r0
   28994:	4804      	ldr	r0, [pc, #16]	; (289a8 <end_thread+0x94>)
   28996:	f7ff fa97 	bl	27ec8 <z_priq_dumb_remove>
}
   2899a:	e7ca      	b.n	28932 <end_thread+0x1e>
		update_cache(1);
   2899c:	2001      	movs	r0, #1
   2899e:	f7ff faff 	bl	27fa0 <update_cache>
		z_thread_perms_all_clear(thread);
		z_object_uninit(thread->stack_obj);
		z_object_uninit(thread);
#endif
	}
}
   289a2:	bd70      	pop	{r4, r5, r6, pc}
   289a4:	4770      	bx	lr
   289a6:	bf00      	nop
   289a8:	200046c8 	.word	0x200046c8

000289ac <z_unpend1_no_timeout>:
{
   289ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   289ae:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
   289b0:	2500      	movs	r5, #0
   289b2:	f04f 0340 	mov.w	r3, #64	; 0x40
   289b6:	f3ef 8711 	mrs	r7, BASEPRI
   289ba:	f383 8812 	msr	BASEPRI_MAX, r3
   289be:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   289c2:	481e      	ldr	r0, [pc, #120]	; (28a3c <z_unpend1_no_timeout+0x90>)
   289c4:	f7fd fe6e 	bl	266a4 <z_spin_lock_valid>
   289c8:	b120      	cbz	r0, 289d4 <z_unpend1_no_timeout+0x28>
	z_spin_lock_set_owner(l);
   289ca:	481c      	ldr	r0, [pc, #112]	; (28a3c <z_unpend1_no_timeout+0x90>)
   289cc:	f7fd fe8a 	bl	266e4 <z_spin_lock_set_owner>
	struct k_thread *thread = NULL;
   289d0:	2400      	movs	r4, #0
	return k;
   289d2:	e013      	b.n	289fc <z_unpend1_no_timeout+0x50>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   289d4:	4c1a      	ldr	r4, [pc, #104]	; (28a40 <z_unpend1_no_timeout+0x94>)
   289d6:	228e      	movs	r2, #142	; 0x8e
   289d8:	4621      	mov	r1, r4
   289da:	481a      	ldr	r0, [pc, #104]	; (28a44 <z_unpend1_no_timeout+0x98>)
   289dc:	f003 fda7 	bl	2c52e <assert_print>
   289e0:	218e      	movs	r1, #142	; 0x8e
   289e2:	4620      	mov	r0, r4
   289e4:	f003 fd9c 	bl	2c520 <assert_post_action>
   289e8:	e7ef      	b.n	289ca <z_unpend1_no_timeout+0x1e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   289ea:	4814      	ldr	r0, [pc, #80]	; (28a3c <z_unpend1_no_timeout+0x90>)
   289ec:	f7fd fe6a 	bl	266c4 <z_spin_unlock_valid>
   289f0:	b1b8      	cbz	r0, 28a22 <z_unpend1_no_timeout+0x76>
	__asm__ volatile(
   289f2:	f387 8811 	msr	BASEPRI, r7
   289f6:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   289fa:	2501      	movs	r5, #1
   289fc:	b9e5      	cbnz	r5, 28a38 <z_unpend1_no_timeout+0x8c>
		thread = _priq_wait_best(&wait_q->waitq);
   289fe:	4630      	mov	r0, r6
   28a00:	f008 f8a1 	bl	30b46 <z_priq_dumb_best>
		if (thread != NULL) {
   28a04:	4604      	mov	r4, r0
   28a06:	2800      	cmp	r0, #0
   28a08:	d0ef      	beq.n	289ea <z_unpend1_no_timeout+0x3e>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   28a0a:	f7ff f8d7 	bl	27bbc <pended_on_thread>
   28a0e:	4621      	mov	r1, r4
   28a10:	f7ff fa5a 	bl	27ec8 <z_priq_dumb_remove>
   28a14:	7b63      	ldrb	r3, [r4, #13]
   28a16:	f023 0302 	bic.w	r3, r3, #2
   28a1a:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   28a1c:	2300      	movs	r3, #0
   28a1e:	60a3      	str	r3, [r4, #8]
}
   28a20:	e7e3      	b.n	289ea <z_unpend1_no_timeout+0x3e>
   28a22:	4d07      	ldr	r5, [pc, #28]	; (28a40 <z_unpend1_no_timeout+0x94>)
   28a24:	22b9      	movs	r2, #185	; 0xb9
   28a26:	4629      	mov	r1, r5
   28a28:	4806      	ldr	r0, [pc, #24]	; (28a44 <z_unpend1_no_timeout+0x98>)
   28a2a:	f003 fd80 	bl	2c52e <assert_print>
   28a2e:	21b9      	movs	r1, #185	; 0xb9
   28a30:	4628      	mov	r0, r5
   28a32:	f003 fd75 	bl	2c520 <assert_post_action>
   28a36:	e7dc      	b.n	289f2 <z_unpend1_no_timeout+0x46>
}
   28a38:	4620      	mov	r0, r4
   28a3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   28a3c:	200046ec 	.word	0x200046ec
   28a40:	000390f0 	.word	0x000390f0
   28a44:	00031600 	.word	0x00031600

00028a48 <z_unpend_first_thread>:
{
   28a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28a4a:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
   28a4c:	2500      	movs	r5, #0
	__asm__ volatile(
   28a4e:	f04f 0340 	mov.w	r3, #64	; 0x40
   28a52:	f3ef 8711 	mrs	r7, BASEPRI
   28a56:	f383 8812 	msr	BASEPRI_MAX, r3
   28a5a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28a5e:	4820      	ldr	r0, [pc, #128]	; (28ae0 <z_unpend_first_thread+0x98>)
   28a60:	f7fd fe20 	bl	266a4 <z_spin_lock_valid>
   28a64:	b120      	cbz	r0, 28a70 <z_unpend_first_thread+0x28>
	z_spin_lock_set_owner(l);
   28a66:	481e      	ldr	r0, [pc, #120]	; (28ae0 <z_unpend_first_thread+0x98>)
   28a68:	f7fd fe3c 	bl	266e4 <z_spin_lock_set_owner>
	struct k_thread *thread = NULL;
   28a6c:	2400      	movs	r4, #0
	return k;
   28a6e:	e013      	b.n	28a98 <z_unpend_first_thread+0x50>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28a70:	4c1c      	ldr	r4, [pc, #112]	; (28ae4 <z_unpend_first_thread+0x9c>)
   28a72:	228e      	movs	r2, #142	; 0x8e
   28a74:	4621      	mov	r1, r4
   28a76:	481c      	ldr	r0, [pc, #112]	; (28ae8 <z_unpend_first_thread+0xa0>)
   28a78:	f003 fd59 	bl	2c52e <assert_print>
   28a7c:	218e      	movs	r1, #142	; 0x8e
   28a7e:	4620      	mov	r0, r4
   28a80:	f003 fd4e 	bl	2c520 <assert_post_action>
   28a84:	e7ef      	b.n	28a66 <z_unpend_first_thread+0x1e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28a86:	4816      	ldr	r0, [pc, #88]	; (28ae0 <z_unpend_first_thread+0x98>)
   28a88:	f7fd fe1c 	bl	266c4 <z_spin_unlock_valid>
   28a8c:	b1d8      	cbz	r0, 28ac6 <z_unpend_first_thread+0x7e>
	__asm__ volatile(
   28a8e:	f387 8811 	msr	BASEPRI, r7
   28a92:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   28a96:	2501      	movs	r5, #1
   28a98:	bb05      	cbnz	r5, 28adc <z_unpend_first_thread+0x94>
		thread = _priq_wait_best(&wait_q->waitq);
   28a9a:	4630      	mov	r0, r6
   28a9c:	f008 f853 	bl	30b46 <z_priq_dumb_best>
		if (thread != NULL) {
   28aa0:	4604      	mov	r4, r0
   28aa2:	2800      	cmp	r0, #0
   28aa4:	d0ef      	beq.n	28a86 <z_unpend_first_thread+0x3e>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   28aa6:	f7ff f889 	bl	27bbc <pended_on_thread>
   28aaa:	4621      	mov	r1, r4
   28aac:	f7ff fa0c 	bl	27ec8 <z_priq_dumb_remove>
   28ab0:	7b63      	ldrb	r3, [r4, #13]
   28ab2:	f023 0302 	bic.w	r3, r3, #2
   28ab6:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   28ab8:	2300      	movs	r3, #0
   28aba:	60a3      	str	r3, [r4, #8]
   28abc:	f104 0018 	add.w	r0, r4, #24
   28ac0:	f000 fbde 	bl	29280 <z_abort_timeout>
   28ac4:	e7df      	b.n	28a86 <z_unpend_first_thread+0x3e>
   28ac6:	4d07      	ldr	r5, [pc, #28]	; (28ae4 <z_unpend_first_thread+0x9c>)
   28ac8:	22b9      	movs	r2, #185	; 0xb9
   28aca:	4629      	mov	r1, r5
   28acc:	4806      	ldr	r0, [pc, #24]	; (28ae8 <z_unpend_first_thread+0xa0>)
   28ace:	f003 fd2e 	bl	2c52e <assert_print>
   28ad2:	21b9      	movs	r1, #185	; 0xb9
   28ad4:	4628      	mov	r0, r5
   28ad6:	f003 fd23 	bl	2c520 <assert_post_action>
   28ada:	e7d8      	b.n	28a8e <z_unpend_first_thread+0x46>
}
   28adc:	4620      	mov	r0, r4
   28ade:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   28ae0:	200046ec 	.word	0x200046ec
   28ae4:	000390f0 	.word	0x000390f0
   28ae8:	00031600 	.word	0x00031600

00028aec <z_sched_init>:
{
   28aec:	b508      	push	{r3, lr}
	init_ready_q(&_kernel.ready_q);
   28aee:	4804      	ldr	r0, [pc, #16]	; (28b00 <z_sched_init+0x14>)
   28af0:	f008 f840 	bl	30b74 <init_ready_q>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   28af4:	2100      	movs	r1, #0
   28af6:	4608      	mov	r0, r1
   28af8:	f7ff f89c 	bl	27c34 <k_sched_time_slice_set>
}
   28afc:	bd08      	pop	{r3, pc}
   28afe:	bf00      	nop
   28b00:	200046c4 	.word	0x200046c4

00028b04 <z_impl_k_yield>:
{
   28b04:	b570      	push	{r4, r5, r6, lr}
   28b06:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   28b0a:	2b00      	cmp	r3, #0
   28b0c:	d148      	bne.n	28ba0 <z_impl_k_yield+0x9c>
	__asm__ volatile(
   28b0e:	f04f 0340 	mov.w	r3, #64	; 0x40
   28b12:	f3ef 8611 	mrs	r6, BASEPRI
   28b16:	f383 8812 	msr	BASEPRI_MAX, r3
   28b1a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28b1e:	483b      	ldr	r0, [pc, #236]	; (28c0c <z_impl_k_yield+0x108>)
   28b20:	f7fd fdc0 	bl	266a4 <z_spin_lock_valid>
   28b24:	2800      	cmp	r0, #0
   28b26:	d048      	beq.n	28bba <z_impl_k_yield+0xb6>
	z_spin_lock_set_owner(l);
   28b28:	4838      	ldr	r0, [pc, #224]	; (28c0c <z_impl_k_yield+0x108>)
   28b2a:	f7fd fddb 	bl	266e4 <z_spin_lock_set_owner>
		dequeue_thread(_current);
   28b2e:	4c38      	ldr	r4, [pc, #224]	; (28c10 <z_impl_k_yield+0x10c>)
   28b30:	68a1      	ldr	r1, [r4, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   28b32:	7b4b      	ldrb	r3, [r1, #13]
   28b34:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   28b38:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
   28b3a:	f104 0024 	add.w	r0, r4, #36	; 0x24
   28b3e:	f7ff f9c3 	bl	27ec8 <z_priq_dumb_remove>
	queue_thread(_current);
   28b42:	68a5      	ldr	r5, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   28b44:	7b6b      	ldrb	r3, [r5, #13]
   28b46:	f063 037f 	orn	r3, r3, #127	; 0x7f
   28b4a:	736b      	strb	r3, [r5, #13]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   28b4c:	4b31      	ldr	r3, [pc, #196]	; (28c14 <z_impl_k_yield+0x110>)
   28b4e:	429d      	cmp	r5, r3
   28b50:	d03e      	beq.n	28bd0 <z_impl_k_yield+0xcc>
	return list->head == list;
   28b52:	4b2f      	ldr	r3, [pc, #188]	; (28c10 <z_impl_k_yield+0x10c>)
   28b54:	f853 4f24 	ldr.w	r4, [r3, #36]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28b58:	429c      	cmp	r4, r3
   28b5a:	d04a      	beq.n	28bf2 <z_impl_k_yield+0xee>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28b5c:	b16c      	cbz	r4, 28b7a <z_impl_k_yield+0x76>
		if (z_sched_prio_cmp(thread, t) > 0) {
   28b5e:	4621      	mov	r1, r4
   28b60:	4628      	mov	r0, r5
   28b62:	f007 ffd1 	bl	30b08 <z_sched_prio_cmp>
   28b66:	2800      	cmp	r0, #0
   28b68:	dc3d      	bgt.n	28be6 <z_impl_k_yield+0xe2>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   28b6a:	b134      	cbz	r4, 28b7a <z_impl_k_yield+0x76>
	return (node == list->tail) ? NULL : node->next;
   28b6c:	4b28      	ldr	r3, [pc, #160]	; (28c10 <z_impl_k_yield+0x10c>)
   28b6e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28b70:	429c      	cmp	r4, r3
   28b72:	d002      	beq.n	28b7a <z_impl_k_yield+0x76>
   28b74:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28b76:	2c00      	cmp	r4, #0
   28b78:	d1f0      	bne.n	28b5c <z_impl_k_yield+0x58>
	sys_dnode_t *const tail = list->tail;
   28b7a:	4b25      	ldr	r3, [pc, #148]	; (28c10 <z_impl_k_yield+0x10c>)
   28b7c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	node->next = list;
   28b7e:	f103 0124 	add.w	r1, r3, #36	; 0x24
   28b82:	6029      	str	r1, [r5, #0]
	node->prev = tail;
   28b84:	606a      	str	r2, [r5, #4]
	tail->next = node;
   28b86:	6015      	str	r5, [r2, #0]
	list->tail = node;
   28b88:	629d      	str	r5, [r3, #40]	; 0x28
	update_cache(1);
   28b8a:	2001      	movs	r0, #1
   28b8c:	f7ff fa08 	bl	27fa0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28b90:	481e      	ldr	r0, [pc, #120]	; (28c0c <z_impl_k_yield+0x108>)
   28b92:	f7fd fd97 	bl	266c4 <z_spin_unlock_valid>
   28b96:	b370      	cbz	r0, 28bf6 <z_impl_k_yield+0xf2>
   28b98:	4630      	mov	r0, r6
   28b9a:	f7ef fc1d 	bl	183d8 <arch_swap>
}
   28b9e:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(!arch_is_in_isr(), "");
   28ba0:	4c1d      	ldr	r4, [pc, #116]	; (28c18 <z_impl_k_yield+0x114>)
   28ba2:	f240 525d 	movw	r2, #1373	; 0x55d
   28ba6:	4621      	mov	r1, r4
   28ba8:	481c      	ldr	r0, [pc, #112]	; (28c1c <z_impl_k_yield+0x118>)
   28baa:	f003 fcc0 	bl	2c52e <assert_print>
   28bae:	f240 515d 	movw	r1, #1373	; 0x55d
   28bb2:	4620      	mov	r0, r4
   28bb4:	f003 fcb4 	bl	2c520 <assert_post_action>
   28bb8:	e7a9      	b.n	28b0e <z_impl_k_yield+0xa>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28bba:	4c19      	ldr	r4, [pc, #100]	; (28c20 <z_impl_k_yield+0x11c>)
   28bbc:	228e      	movs	r2, #142	; 0x8e
   28bbe:	4621      	mov	r1, r4
   28bc0:	4816      	ldr	r0, [pc, #88]	; (28c1c <z_impl_k_yield+0x118>)
   28bc2:	f003 fcb4 	bl	2c52e <assert_print>
   28bc6:	218e      	movs	r1, #142	; 0x8e
   28bc8:	4620      	mov	r0, r4
   28bca:	f003 fca9 	bl	2c520 <assert_post_action>
   28bce:	e7ab      	b.n	28b28 <z_impl_k_yield+0x24>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   28bd0:	4c11      	ldr	r4, [pc, #68]	; (28c18 <z_impl_k_yield+0x114>)
   28bd2:	22ba      	movs	r2, #186	; 0xba
   28bd4:	4621      	mov	r1, r4
   28bd6:	4811      	ldr	r0, [pc, #68]	; (28c1c <z_impl_k_yield+0x118>)
   28bd8:	f003 fca9 	bl	2c52e <assert_print>
   28bdc:	21ba      	movs	r1, #186	; 0xba
   28bde:	4620      	mov	r0, r4
   28be0:	f003 fc9e 	bl	2c520 <assert_post_action>
   28be4:	e7b5      	b.n	28b52 <z_impl_k_yield+0x4e>
	sys_dnode_t *const prev = successor->prev;
   28be6:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
   28be8:	606b      	str	r3, [r5, #4]
	node->next = successor;
   28bea:	602c      	str	r4, [r5, #0]
	prev->next = node;
   28bec:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   28bee:	6065      	str	r5, [r4, #4]
}
   28bf0:	e7cb      	b.n	28b8a <z_impl_k_yield+0x86>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28bf2:	2400      	movs	r4, #0
   28bf4:	e7b2      	b.n	28b5c <z_impl_k_yield+0x58>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28bf6:	4c0a      	ldr	r4, [pc, #40]	; (28c20 <z_impl_k_yield+0x11c>)
   28bf8:	22d0      	movs	r2, #208	; 0xd0
   28bfa:	4621      	mov	r1, r4
   28bfc:	4807      	ldr	r0, [pc, #28]	; (28c1c <z_impl_k_yield+0x118>)
   28bfe:	f003 fc96 	bl	2c52e <assert_print>
   28c02:	21d0      	movs	r1, #208	; 0xd0
   28c04:	4620      	mov	r0, r4
   28c06:	f003 fc8b 	bl	2c520 <assert_post_action>
   28c0a:	e7c5      	b.n	28b98 <z_impl_k_yield+0x94>
   28c0c:	200046ec 	.word	0x200046ec
   28c10:	200046a4 	.word	0x200046a4
   28c14:	200025d0 	.word	0x200025d0
   28c18:	0003bec4 	.word	0x0003bec4
   28c1c:	00031600 	.word	0x00031600
   28c20:	000390f0 	.word	0x000390f0

00028c24 <z_tick_sleep>:
{
   28c24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   28c28:	4604      	mov	r4, r0
   28c2a:	460e      	mov	r6, r1
   28c2c:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   28c30:	2b00      	cmp	r3, #0
   28c32:	d14d      	bne.n	28cd0 <z_tick_sleep+0xac>
	if (ticks == 0) {
   28c34:	ea54 0306 	orrs.w	r3, r4, r6
   28c38:	d057      	beq.n	28cea <z_tick_sleep+0xc6>
	if (Z_TICK_ABS(ticks) <= 0) {
   28c3a:	f06f 0301 	mvn.w	r3, #1
   28c3e:	1b1b      	subs	r3, r3, r4
   28c40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   28c44:	eb62 0206 	sbc.w	r2, r2, r6
   28c48:	2b01      	cmp	r3, #1
   28c4a:	f172 0300 	sbcs.w	r3, r2, #0
   28c4e:	db50      	blt.n	28cf2 <z_tick_sleep+0xce>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   28c50:	f06f 0501 	mvn.w	r5, #1
   28c54:	1b2d      	subs	r5, r5, r4
   28c56:	f04f 0340 	mov.w	r3, #64	; 0x40
   28c5a:	f3ef 8911 	mrs	r9, BASEPRI
   28c5e:	f383 8812 	msr	BASEPRI_MAX, r3
   28c62:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28c66:	4836      	ldr	r0, [pc, #216]	; (28d40 <z_tick_sleep+0x11c>)
   28c68:	f7fd fd1c 	bl	266a4 <z_spin_lock_valid>
   28c6c:	2800      	cmp	r0, #0
   28c6e:	d044      	beq.n	28cfa <z_tick_sleep+0xd6>
	z_spin_lock_set_owner(l);
   28c70:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 28d40 <z_tick_sleep+0x11c>
   28c74:	4640      	mov	r0, r8
   28c76:	f7fd fd35 	bl	266e4 <z_spin_lock_set_owner>
	pending_current = _current;
   28c7a:	4f32      	ldr	r7, [pc, #200]	; (28d44 <z_tick_sleep+0x120>)
   28c7c:	68b8      	ldr	r0, [r7, #8]
   28c7e:	4b32      	ldr	r3, [pc, #200]	; (28d48 <z_tick_sleep+0x124>)
   28c80:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   28c82:	f7ff fc03 	bl	2848c <unready_thread>
	z_add_thread_timeout(_current, timeout);
   28c86:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   28c88:	4622      	mov	r2, r4
   28c8a:	4633      	mov	r3, r6
   28c8c:	492f      	ldr	r1, [pc, #188]	; (28d4c <z_tick_sleep+0x128>)
   28c8e:	3018      	adds	r0, #24
   28c90:	f000 fa2c 	bl	290ec <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   28c94:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   28c96:	7b53      	ldrb	r3, [r2, #13]
   28c98:	f043 0310 	orr.w	r3, r3, #16
   28c9c:	7353      	strb	r3, [r2, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28c9e:	4640      	mov	r0, r8
   28ca0:	f7fd fd10 	bl	266c4 <z_spin_unlock_valid>
   28ca4:	b3a0      	cbz	r0, 28d10 <z_tick_sleep+0xec>
   28ca6:	4648      	mov	r0, r9
   28ca8:	f7ef fb96 	bl	183d8 <arch_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   28cac:	4b25      	ldr	r3, [pc, #148]	; (28d44 <z_tick_sleep+0x120>)
   28cae:	689b      	ldr	r3, [r3, #8]
	return (thread->base.thread_state & state) != 0U;
   28cb0:	7b5b      	ldrb	r3, [r3, #13]
   28cb2:	f013 0f10 	tst.w	r3, #16
   28cb6:	d136      	bne.n	28d26 <z_tick_sleep+0x102>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   28cb8:	f007 ff77 	bl	30baa <sys_clock_tick_get_32>
   28cbc:	1a28      	subs	r0, r5, r0
   28cbe:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   28cc2:	2801      	cmp	r0, #1
   28cc4:	f173 0300 	sbcs.w	r3, r3, #0
   28cc8:	da00      	bge.n	28ccc <z_tick_sleep+0xa8>
	return 0;
   28cca:	2000      	movs	r0, #0
}
   28ccc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__ASSERT(!arch_is_in_isr(), "");
   28cd0:	4d1f      	ldr	r5, [pc, #124]	; (28d50 <z_tick_sleep+0x12c>)
   28cd2:	f240 5279 	movw	r2, #1401	; 0x579
   28cd6:	4629      	mov	r1, r5
   28cd8:	481e      	ldr	r0, [pc, #120]	; (28d54 <z_tick_sleep+0x130>)
   28cda:	f003 fc28 	bl	2c52e <assert_print>
   28cde:	f240 5179 	movw	r1, #1401	; 0x579
   28ce2:	4628      	mov	r0, r5
   28ce4:	f003 fc1c 	bl	2c520 <assert_post_action>
   28ce8:	e7a4      	b.n	28c34 <z_tick_sleep+0x10>
	z_impl_k_yield();
   28cea:	f7ff ff0b 	bl	28b04 <z_impl_k_yield>
		return 0;
   28cee:	2000      	movs	r0, #0
   28cf0:	e7ec      	b.n	28ccc <z_tick_sleep+0xa8>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   28cf2:	f007 ff5a 	bl	30baa <sys_clock_tick_get_32>
   28cf6:	1905      	adds	r5, r0, r4
   28cf8:	e7ad      	b.n	28c56 <z_tick_sleep+0x32>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28cfa:	4f17      	ldr	r7, [pc, #92]	; (28d58 <z_tick_sleep+0x134>)
   28cfc:	228e      	movs	r2, #142	; 0x8e
   28cfe:	4639      	mov	r1, r7
   28d00:	4814      	ldr	r0, [pc, #80]	; (28d54 <z_tick_sleep+0x130>)
   28d02:	f003 fc14 	bl	2c52e <assert_print>
   28d06:	218e      	movs	r1, #142	; 0x8e
   28d08:	4638      	mov	r0, r7
   28d0a:	f003 fc09 	bl	2c520 <assert_post_action>
   28d0e:	e7af      	b.n	28c70 <z_tick_sleep+0x4c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28d10:	4c11      	ldr	r4, [pc, #68]	; (28d58 <z_tick_sleep+0x134>)
   28d12:	22d0      	movs	r2, #208	; 0xd0
   28d14:	4621      	mov	r1, r4
   28d16:	480f      	ldr	r0, [pc, #60]	; (28d54 <z_tick_sleep+0x130>)
   28d18:	f003 fc09 	bl	2c52e <assert_print>
   28d1c:	21d0      	movs	r1, #208	; 0xd0
   28d1e:	4620      	mov	r0, r4
   28d20:	f003 fbfe 	bl	2c520 <assert_post_action>
   28d24:	e7bf      	b.n	28ca6 <z_tick_sleep+0x82>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   28d26:	4c0a      	ldr	r4, [pc, #40]	; (28d50 <z_tick_sleep+0x12c>)
   28d28:	f240 529a 	movw	r2, #1434	; 0x59a
   28d2c:	4621      	mov	r1, r4
   28d2e:	4809      	ldr	r0, [pc, #36]	; (28d54 <z_tick_sleep+0x130>)
   28d30:	f003 fbfd 	bl	2c52e <assert_print>
   28d34:	f240 519a 	movw	r1, #1434	; 0x59a
   28d38:	4620      	mov	r0, r4
   28d3a:	f003 fbf1 	bl	2c520 <assert_post_action>
   28d3e:	e7bb      	b.n	28cb8 <z_tick_sleep+0x94>
   28d40:	200046ec 	.word	0x200046ec
   28d44:	200046a4 	.word	0x200046a4
   28d48:	200046e8 	.word	0x200046e8
   28d4c:	000283c9 	.word	0x000283c9
   28d50:	0003bec4 	.word	0x0003bec4
   28d54:	00031600 	.word	0x00031600
   28d58:	000390f0 	.word	0x000390f0

00028d5c <z_impl_k_sleep>:
{
   28d5c:	b570      	push	{r4, r5, r6, lr}
   28d5e:	4605      	mov	r5, r0
   28d60:	460c      	mov	r4, r1
   28d62:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   28d66:	bb13      	cbnz	r3, 28dae <z_impl_k_sleep+0x52>
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   28d68:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   28d6c:	bf08      	it	eq
   28d6e:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
   28d72:	d029      	beq.n	28dc8 <z_impl_k_sleep+0x6c>
	ticks = z_tick_sleep(ticks);
   28d74:	4628      	mov	r0, r5
   28d76:	4621      	mov	r1, r4
   28d78:	f7ff ff54 	bl	28c24 <z_tick_sleep>
   28d7c:	4684      	mov	ip, r0
	int32_t ret = k_ticks_to_ms_floor64(ticks);
   28d7e:	17c2      	asrs	r2, r0, #31
			return ((t * to_hz + off) / from_hz);
   28d80:	0151      	lsls	r1, r2, #5
   28d82:	ea41 61d0 	orr.w	r1, r1, r0, lsr #27
   28d86:	0143      	lsls	r3, r0, #5
   28d88:	1a1b      	subs	r3, r3, r0
   28d8a:	eb61 0102 	sbc.w	r1, r1, r2
   28d8e:	0088      	lsls	r0, r1, #2
   28d90:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
   28d94:	009b      	lsls	r3, r3, #2
   28d96:	eb13 030c 	adds.w	r3, r3, ip
   28d9a:	eb42 0000 	adc.w	r0, r2, r0
   28d9e:	00c0      	lsls	r0, r0, #3
   28da0:	ea40 7053 	orr.w	r0, r0, r3, lsr #29
   28da4:	f3c3 3310 	ubfx	r3, r3, #12, #17
   28da8:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
}
   28dac:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(!arch_is_in_isr(), "");
   28dae:	4e0a      	ldr	r6, [pc, #40]	; (28dd8 <z_impl_k_sleep+0x7c>)
   28db0:	f240 52a9 	movw	r2, #1449	; 0x5a9
   28db4:	4631      	mov	r1, r6
   28db6:	4809      	ldr	r0, [pc, #36]	; (28ddc <z_impl_k_sleep+0x80>)
   28db8:	f003 fbb9 	bl	2c52e <assert_print>
   28dbc:	f240 51a9 	movw	r1, #1449	; 0x5a9
   28dc0:	4630      	mov	r0, r6
   28dc2:	f003 fbad 	bl	2c520 <assert_post_action>
   28dc6:	e7cf      	b.n	28d68 <z_impl_k_sleep+0xc>
		k_thread_suspend(_current);
   28dc8:	4b05      	ldr	r3, [pc, #20]	; (28de0 <z_impl_k_sleep+0x84>)
   28dca:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   28dcc:	f7ff fcc4 	bl	28758 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
   28dd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28dd4:	e7ea      	b.n	28dac <z_impl_k_sleep+0x50>
   28dd6:	bf00      	nop
   28dd8:	0003bec4 	.word	0x0003bec4
   28ddc:	00031600 	.word	0x00031600
   28de0:	200046a4 	.word	0x200046a4

00028de4 <z_impl_z_current_get>:
}
   28de4:	4b01      	ldr	r3, [pc, #4]	; (28dec <z_impl_z_current_get+0x8>)
   28de6:	6898      	ldr	r0, [r3, #8]
   28de8:	4770      	bx	lr
   28dea:	bf00      	nop
   28dec:	200046a4 	.word	0x200046a4

00028df0 <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
   28df0:	b570      	push	{r4, r5, r6, lr}
   28df2:	4604      	mov	r4, r0
   28df4:	f04f 0340 	mov.w	r3, #64	; 0x40
   28df8:	f3ef 8511 	mrs	r5, BASEPRI
   28dfc:	f383 8812 	msr	BASEPRI_MAX, r3
   28e00:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28e04:	4849      	ldr	r0, [pc, #292]	; (28f2c <z_thread_abort+0x13c>)
   28e06:	f7fd fc4d 	bl	266a4 <z_spin_lock_valid>
   28e0a:	b1d8      	cbz	r0, 28e44 <z_thread_abort+0x54>
	z_spin_lock_set_owner(l);
   28e0c:	4847      	ldr	r0, [pc, #284]	; (28f2c <z_thread_abort+0x13c>)
   28e0e:	f7fd fc69 	bl	266e4 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
   28e12:	7b23      	ldrb	r3, [r4, #12]
   28e14:	f013 0f01 	tst.w	r3, #1
   28e18:	d11f      	bne.n	28e5a <z_thread_abort+0x6a>
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
		return;
	}

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   28e1a:	7b63      	ldrb	r3, [r4, #13]
   28e1c:	f013 0f08 	tst.w	r3, #8
   28e20:	d141      	bne.n	28ea6 <z_thread_abort+0xb6>
			z_swap(&sched_spinlock, key);
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
   28e22:	4620      	mov	r0, r4
   28e24:	f7ff fd76 	bl	28914 <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
   28e28:	4b41      	ldr	r3, [pc, #260]	; (28f30 <z_thread_abort+0x140>)
   28e2a:	689b      	ldr	r3, [r3, #8]
   28e2c:	42a3      	cmp	r3, r4
   28e2e:	d04e      	beq.n	28ece <z_thread_abort+0xde>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28e30:	483e      	ldr	r0, [pc, #248]	; (28f2c <z_thread_abort+0x13c>)
   28e32:	f7fd fc47 	bl	266c4 <z_spin_unlock_valid>
   28e36:	2800      	cmp	r0, #0
   28e38:	d06c      	beq.n	28f14 <z_thread_abort+0x124>
	__asm__ volatile(
   28e3a:	f385 8811 	msr	BASEPRI, r5
   28e3e:	f3bf 8f6f 	isb	sy
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   28e42:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28e44:	4e3b      	ldr	r6, [pc, #236]	; (28f34 <z_thread_abort+0x144>)
   28e46:	228e      	movs	r2, #142	; 0x8e
   28e48:	4631      	mov	r1, r6
   28e4a:	483b      	ldr	r0, [pc, #236]	; (28f38 <z_thread_abort+0x148>)
   28e4c:	f003 fb6f 	bl	2c52e <assert_print>
   28e50:	218e      	movs	r1, #142	; 0x8e
   28e52:	4630      	mov	r0, r6
   28e54:	f003 fb64 	bl	2c520 <assert_post_action>
   28e58:	e7d8      	b.n	28e0c <z_thread_abort+0x1c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28e5a:	4834      	ldr	r0, [pc, #208]	; (28f2c <z_thread_abort+0x13c>)
   28e5c:	f7fd fc32 	bl	266c4 <z_spin_unlock_valid>
   28e60:	b1b0      	cbz	r0, 28e90 <z_thread_abort+0xa0>
   28e62:	f385 8811 	msr	BASEPRI, r5
   28e66:	f3bf 8f6f 	isb	sy
		__ASSERT(false, "aborting essential thread %p", thread);
   28e6a:	4c34      	ldr	r4, [pc, #208]	; (28f3c <z_thread_abort+0x14c>)
   28e6c:	f240 62b5 	movw	r2, #1717	; 0x6b5
   28e70:	4621      	mov	r1, r4
   28e72:	4831      	ldr	r0, [pc, #196]	; (28f38 <z_thread_abort+0x148>)
   28e74:	f003 fb5b 	bl	2c52e <assert_print>
   28e78:	f240 61b5 	movw	r1, #1717	; 0x6b5
   28e7c:	4620      	mov	r0, r4
   28e7e:	f003 fb4f 	bl	2c520 <assert_post_action>
		k_panic();
   28e82:	4040      	eors	r0, r0
   28e84:	f380 8811 	msr	BASEPRI, r0
   28e88:	f04f 0004 	mov.w	r0, #4
   28e8c:	df02      	svc	2
		return;
   28e8e:	e7d8      	b.n	28e42 <z_thread_abort+0x52>
   28e90:	4c28      	ldr	r4, [pc, #160]	; (28f34 <z_thread_abort+0x144>)
   28e92:	22b9      	movs	r2, #185	; 0xb9
   28e94:	4621      	mov	r1, r4
   28e96:	4828      	ldr	r0, [pc, #160]	; (28f38 <z_thread_abort+0x148>)
   28e98:	f003 fb49 	bl	2c52e <assert_print>
   28e9c:	21b9      	movs	r1, #185	; 0xb9
   28e9e:	4620      	mov	r0, r4
   28ea0:	f003 fb3e 	bl	2c520 <assert_post_action>
   28ea4:	e7dd      	b.n	28e62 <z_thread_abort+0x72>
   28ea6:	4821      	ldr	r0, [pc, #132]	; (28f2c <z_thread_abort+0x13c>)
   28ea8:	f7fd fc0c 	bl	266c4 <z_spin_unlock_valid>
   28eac:	b120      	cbz	r0, 28eb8 <z_thread_abort+0xc8>
   28eae:	f385 8811 	msr	BASEPRI, r5
   28eb2:	f3bf 8f6f 	isb	sy
		return;
   28eb6:	e7c4      	b.n	28e42 <z_thread_abort+0x52>
   28eb8:	4c1e      	ldr	r4, [pc, #120]	; (28f34 <z_thread_abort+0x144>)
   28eba:	22b9      	movs	r2, #185	; 0xb9
   28ebc:	4621      	mov	r1, r4
   28ebe:	481e      	ldr	r0, [pc, #120]	; (28f38 <z_thread_abort+0x148>)
   28ec0:	f003 fb35 	bl	2c52e <assert_print>
   28ec4:	21b9      	movs	r1, #185	; 0xb9
   28ec6:	4620      	mov	r0, r4
   28ec8:	f003 fb2a 	bl	2c520 <assert_post_action>
   28ecc:	e7ef      	b.n	28eae <z_thread_abort+0xbe>
   28ece:	f3ef 8305 	mrs	r3, IPSR
	if (thread == _current && !arch_is_in_isr()) {
   28ed2:	2b00      	cmp	r3, #0
   28ed4:	d1ac      	bne.n	28e30 <z_thread_abort+0x40>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28ed6:	4815      	ldr	r0, [pc, #84]	; (28f2c <z_thread_abort+0x13c>)
   28ed8:	f7fd fbf4 	bl	266c4 <z_spin_unlock_valid>
   28edc:	b178      	cbz	r0, 28efe <z_thread_abort+0x10e>
   28ede:	4628      	mov	r0, r5
   28ee0:	f7ef fa7a 	bl	183d8 <arch_swap>
		__ASSERT(false, "aborted _current back from dead");
   28ee4:	4c15      	ldr	r4, [pc, #84]	; (28f3c <z_thread_abort+0x14c>)
   28ee6:	f240 62e4 	movw	r2, #1764	; 0x6e4
   28eea:	4621      	mov	r1, r4
   28eec:	4812      	ldr	r0, [pc, #72]	; (28f38 <z_thread_abort+0x148>)
   28eee:	f003 fb1e 	bl	2c52e <assert_print>
   28ef2:	f240 61e4 	movw	r1, #1764	; 0x6e4
   28ef6:	4620      	mov	r0, r4
   28ef8:	f003 fb12 	bl	2c520 <assert_post_action>
   28efc:	e798      	b.n	28e30 <z_thread_abort+0x40>
   28efe:	4c0d      	ldr	r4, [pc, #52]	; (28f34 <z_thread_abort+0x144>)
   28f00:	22d0      	movs	r2, #208	; 0xd0
   28f02:	4621      	mov	r1, r4
   28f04:	480c      	ldr	r0, [pc, #48]	; (28f38 <z_thread_abort+0x148>)
   28f06:	f003 fb12 	bl	2c52e <assert_print>
   28f0a:	21d0      	movs	r1, #208	; 0xd0
   28f0c:	4620      	mov	r0, r4
   28f0e:	f003 fb07 	bl	2c520 <assert_post_action>
   28f12:	e7e4      	b.n	28ede <z_thread_abort+0xee>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28f14:	4c07      	ldr	r4, [pc, #28]	; (28f34 <z_thread_abort+0x144>)
   28f16:	22b9      	movs	r2, #185	; 0xb9
   28f18:	4621      	mov	r1, r4
   28f1a:	4807      	ldr	r0, [pc, #28]	; (28f38 <z_thread_abort+0x148>)
   28f1c:	f003 fb07 	bl	2c52e <assert_print>
   28f20:	21b9      	movs	r1, #185	; 0xb9
   28f22:	4620      	mov	r0, r4
   28f24:	f003 fafc 	bl	2c520 <assert_post_action>
   28f28:	e787      	b.n	28e3a <z_thread_abort+0x4a>
   28f2a:	bf00      	nop
   28f2c:	200046ec 	.word	0x200046ec
   28f30:	200046a4 	.word	0x200046a4
   28f34:	000390f0 	.word	0x000390f0
   28f38:	00031600 	.word	0x00031600
   28f3c:	0003bec4 	.word	0x0003bec4

00028f40 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
   28f40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   28f44:	4605      	mov	r5, r0
   28f46:	460f      	mov	r7, r1
   28f48:	4690      	mov	r8, r2
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
   28f4a:	2400      	movs	r4, #0
	__asm__ volatile(
   28f4c:	f04f 0340 	mov.w	r3, #64	; 0x40
   28f50:	f3ef 8611 	mrs	r6, BASEPRI
   28f54:	f383 8812 	msr	BASEPRI_MAX, r3
   28f58:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28f5c:	4826      	ldr	r0, [pc, #152]	; (28ff8 <z_sched_wake+0xb8>)
   28f5e:	f7fd fba1 	bl	266a4 <z_spin_lock_valid>
   28f62:	b128      	cbz	r0, 28f70 <z_sched_wake+0x30>
	z_spin_lock_set_owner(l);
   28f64:	4824      	ldr	r0, [pc, #144]	; (28ff8 <z_sched_wake+0xb8>)
   28f66:	f7fd fbbd 	bl	266e4 <z_spin_lock_set_owner>
	bool ret = false;
   28f6a:	f04f 0900 	mov.w	r9, #0
	return k;
   28f6e:	e014      	b.n	28f9a <z_sched_wake+0x5a>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28f70:	f8df 908c 	ldr.w	r9, [pc, #140]	; 29000 <z_sched_wake+0xc0>
   28f74:	228e      	movs	r2, #142	; 0x8e
   28f76:	4649      	mov	r1, r9
   28f78:	4820      	ldr	r0, [pc, #128]	; (28ffc <z_sched_wake+0xbc>)
   28f7a:	f003 fad8 	bl	2c52e <assert_print>
   28f7e:	218e      	movs	r1, #142	; 0x8e
   28f80:	4648      	mov	r0, r9
   28f82:	f003 facd 	bl	2c520 <assert_post_action>
   28f86:	e7ed      	b.n	28f64 <z_sched_wake+0x24>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28f88:	481b      	ldr	r0, [pc, #108]	; (28ff8 <z_sched_wake+0xb8>)
   28f8a:	f7fd fb9b 	bl	266c4 <z_spin_unlock_valid>
   28f8e:	b320      	cbz	r0, 28fda <z_sched_wake+0x9a>
	__asm__ volatile(
   28f90:	f386 8811 	msr	BASEPRI, r6
   28f94:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   28f98:	2401      	movs	r4, #1
   28f9a:	bb4c      	cbnz	r4, 28ff0 <z_sched_wake+0xb0>
		thread = _priq_wait_best(&wait_q->waitq);
   28f9c:	4628      	mov	r0, r5
   28f9e:	f007 fdd2 	bl	30b46 <z_priq_dumb_best>

		if (thread != NULL) {
   28fa2:	4604      	mov	r4, r0
   28fa4:	2800      	cmp	r0, #0
   28fa6:	d0ef      	beq.n	28f88 <z_sched_wake+0x48>
   28fa8:	f8c0 7088 	str.w	r7, [r0, #136]	; 0x88
	thread->base.swap_data = data;
   28fac:	f8c0 8014 	str.w	r8, [r0, #20]
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   28fb0:	f7fe fe04 	bl	27bbc <pended_on_thread>
   28fb4:	4621      	mov	r1, r4
   28fb6:	f7fe ff87 	bl	27ec8 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   28fba:	7b63      	ldrb	r3, [r4, #13]
   28fbc:	f023 0302 	bic.w	r3, r3, #2
   28fc0:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   28fc2:	2300      	movs	r3, #0
   28fc4:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
   28fc6:	f104 0018 	add.w	r0, r4, #24
   28fca:	f000 f959 	bl	29280 <z_abort_timeout>
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
   28fce:	4620      	mov	r0, r4
   28fd0:	f7ff f91c 	bl	2820c <ready_thread>
			ret = true;
   28fd4:	f04f 0901 	mov.w	r9, #1
   28fd8:	e7d6      	b.n	28f88 <z_sched_wake+0x48>
   28fda:	4c09      	ldr	r4, [pc, #36]	; (29000 <z_sched_wake+0xc0>)
   28fdc:	22b9      	movs	r2, #185	; 0xb9
   28fde:	4621      	mov	r1, r4
   28fe0:	4806      	ldr	r0, [pc, #24]	; (28ffc <z_sched_wake+0xbc>)
   28fe2:	f003 faa4 	bl	2c52e <assert_print>
   28fe6:	21b9      	movs	r1, #185	; 0xb9
   28fe8:	4620      	mov	r0, r4
   28fea:	f003 fa99 	bl	2c520 <assert_post_action>
   28fee:	e7cf      	b.n	28f90 <z_sched_wake+0x50>
		}
	}

	return ret;
}
   28ff0:	4648      	mov	r0, r9
   28ff2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   28ff6:	bf00      	nop
   28ff8:	200046ec 	.word	0x200046ec
   28ffc:	00031600 	.word	0x00031600
   29000:	000390f0 	.word	0x000390f0

00029004 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   29004:	b510      	push	{r4, lr}
   29006:	b082      	sub	sp, #8
   29008:	9c06      	ldr	r4, [sp, #24]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   2900a:	ed9d 7b04 	vldr	d7, [sp, #16]
   2900e:	ed8d 7b00 	vstr	d7, [sp]
   29012:	f7ff fadf 	bl	285d4 <z_pend_curr>

	if (data != NULL) {
   29016:	b11c      	cbz	r4, 29020 <z_sched_wait+0x1c>
		*data = _current->base.swap_data;
   29018:	4b02      	ldr	r3, [pc, #8]	; (29024 <z_sched_wait+0x20>)
   2901a:	689b      	ldr	r3, [r3, #8]
   2901c:	695b      	ldr	r3, [r3, #20]
   2901e:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   29020:	b002      	add	sp, #8
   29022:	bd10      	pop	{r4, pc}
   29024:	200046a4 	.word	0x200046a4

00029028 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   29028:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
   2902a:	4806      	ldr	r0, [pc, #24]	; (29044 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
   2902c:	4a06      	ldr	r2, [pc, #24]	; (29048 <z_data_copy+0x20>)
   2902e:	1a12      	subs	r2, r2, r0
   29030:	4906      	ldr	r1, [pc, #24]	; (2904c <z_data_copy+0x24>)
   29032:	f007 fc38 	bl	308a6 <z_early_memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
   29036:	4a06      	ldr	r2, [pc, #24]	; (29050 <z_data_copy+0x28>)
   29038:	4906      	ldr	r1, [pc, #24]	; (29054 <z_data_copy+0x2c>)
   2903a:	4807      	ldr	r0, [pc, #28]	; (29058 <z_data_copy+0x30>)
   2903c:	f007 fc33 	bl	308a6 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   29040:	bd08      	pop	{r3, pc}
   29042:	bf00      	nop
   29044:	20000000 	.word	0x20000000
   29048:	2000103c 	.word	0x2000103c
   2904c:	0003c5c8 	.word	0x0003c5c8
   29050:	00000000 	.word	0x00000000
   29054:	0003c5c8 	.word	0x0003c5c8
   29058:	20000000 	.word	0x20000000

0002905c <first>:
	return list->head == list;
   2905c:	4b03      	ldr	r3, [pc, #12]	; (2906c <first+0x10>)
   2905e:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29060:	4298      	cmp	r0, r3
   29062:	d000      	beq.n	29066 <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
   29064:	4770      	bx	lr
   29066:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
   29068:	e7fc      	b.n	29064 <first+0x8>
   2906a:	bf00      	nop
   2906c:	20000dec 	.word	0x20000dec

00029070 <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   29070:	b130      	cbz	r0, 29080 <next+0x10>
	return (node == list->tail) ? NULL : node->next;
   29072:	4a04      	ldr	r2, [pc, #16]	; (29084 <next+0x14>)
   29074:	6852      	ldr	r2, [r2, #4]
   29076:	4290      	cmp	r0, r2
   29078:	d001      	beq.n	2907e <next+0xe>
   2907a:	6800      	ldr	r0, [r0, #0]
   2907c:	4770      	bx	lr
   2907e:	2000      	movs	r0, #0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
   29080:	4770      	bx	lr
   29082:	bf00      	nop
   29084:	20000dec 	.word	0x20000dec

00029088 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
   29088:	b508      	push	{r3, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   2908a:	4b04      	ldr	r3, [pc, #16]	; (2909c <elapsed+0x14>)
   2908c:	681b      	ldr	r3, [r3, #0]
   2908e:	b10b      	cbz	r3, 29094 <elapsed+0xc>
   29090:	2000      	movs	r0, #0
}
   29092:	bd08      	pop	{r3, pc}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   29094:	f7f8 fcea 	bl	21a6c <sys_clock_elapsed>
   29098:	e7fb      	b.n	29092 <elapsed+0xa>
   2909a:	bf00      	nop
   2909c:	200046f8 	.word	0x200046f8

000290a0 <next_timeout>:

static int32_t next_timeout(void)
{
   290a0:	b510      	push	{r4, lr}
	struct _timeout *to = first();
   290a2:	f7ff ffdb 	bl	2905c <first>
   290a6:	4604      	mov	r4, r0
	int32_t ticks_elapsed = elapsed();
   290a8:	f7ff ffee 	bl	29088 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
   290ac:	b17c      	cbz	r4, 290ce <next_timeout+0x2e>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   290ae:	6923      	ldr	r3, [r4, #16]
   290b0:	6962      	ldr	r2, [r4, #20]
   290b2:	1a1b      	subs	r3, r3, r0
   290b4:	eb62 70e0 	sbc.w	r0, r2, r0, asr #31
	if ((to == NULL) ||
   290b8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   290bc:	f170 0200 	sbcs.w	r2, r0, #0
   290c0:	da08      	bge.n	290d4 <next_timeout+0x34>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
   290c2:	2800      	cmp	r0, #0
   290c4:	db01      	blt.n	290ca <next_timeout+0x2a>
   290c6:	4618      	mov	r0, r3
   290c8:	e006      	b.n	290d8 <next_timeout+0x38>
   290ca:	2300      	movs	r3, #0
   290cc:	e7fb      	b.n	290c6 <next_timeout+0x26>
		ret = MAX_WAIT;
   290ce:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   290d2:	e001      	b.n	290d8 <next_timeout+0x38>
   290d4:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   290d8:	4b03      	ldr	r3, [pc, #12]	; (290e8 <next_timeout+0x48>)
   290da:	691b      	ldr	r3, [r3, #16]
   290dc:	b113      	cbz	r3, 290e4 <next_timeout+0x44>
   290de:	4283      	cmp	r3, r0
   290e0:	da00      	bge.n	290e4 <next_timeout+0x44>
		ret = _current_cpu->slice_ticks;
   290e2:	4618      	mov	r0, r3
	}
#endif
	return ret;
}
   290e4:	bd10      	pop	{r4, pc}
   290e6:	bf00      	nop
   290e8:	200046a4 	.word	0x200046a4

000290ec <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   290ec:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   290f0:	bf08      	it	eq
   290f2:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   290f6:	f000 80b3 	beq.w	29260 <z_add_timeout+0x174>
{
   290fa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   290fe:	4604      	mov	r4, r0
   29100:	460f      	mov	r7, r1
   29102:	4692      	mov	sl, r2
   29104:	461d      	mov	r5, r3
	return node->next != NULL;
   29106:	6803      	ldr	r3, [r0, #0]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   29108:	b153      	cbz	r3, 29120 <z_add_timeout+0x34>
   2910a:	f8df 816c 	ldr.w	r8, [pc, #364]	; 29278 <z_add_timeout+0x18c>
   2910e:	2263      	movs	r2, #99	; 0x63
   29110:	4641      	mov	r1, r8
   29112:	4854      	ldr	r0, [pc, #336]	; (29264 <z_add_timeout+0x178>)
   29114:	f003 fa0b 	bl	2c52e <assert_print>
   29118:	2163      	movs	r1, #99	; 0x63
   2911a:	4640      	mov	r0, r8
   2911c:	f003 fa00 	bl	2c520 <assert_post_action>
	to->fn = fn;
   29120:	60a7      	str	r7, [r4, #8]

	LOCKED(&timeout_lock) {
   29122:	f04f 0800 	mov.w	r8, #0
	__asm__ volatile(
   29126:	f04f 0340 	mov.w	r3, #64	; 0x40
   2912a:	f3ef 8711 	mrs	r7, BASEPRI
   2912e:	f383 8812 	msr	BASEPRI_MAX, r3
   29132:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29136:	484c      	ldr	r0, [pc, #304]	; (29268 <z_add_timeout+0x17c>)
   29138:	f7fd fab4 	bl	266a4 <z_spin_lock_valid>
   2913c:	b118      	cbz	r0, 29146 <z_add_timeout+0x5a>
	z_spin_lock_set_owner(l);
   2913e:	484a      	ldr	r0, [pc, #296]	; (29268 <z_add_timeout+0x17c>)
   29140:	f7fd fad0 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   29144:	e033      	b.n	291ae <z_add_timeout+0xc2>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29146:	f8df 9134 	ldr.w	r9, [pc, #308]	; 2927c <z_add_timeout+0x190>
   2914a:	228e      	movs	r2, #142	; 0x8e
   2914c:	4649      	mov	r1, r9
   2914e:	4845      	ldr	r0, [pc, #276]	; (29264 <z_add_timeout+0x178>)
   29150:	f003 f9ed 	bl	2c52e <assert_print>
   29154:	218e      	movs	r1, #142	; 0x8e
   29156:	4648      	mov	r0, r9
   29158:	f003 f9e2 	bl	2c520 <assert_post_action>
   2915c:	e7ef      	b.n	2913e <z_add_timeout+0x52>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;

			to->dticks = MAX(1, ticks);
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   2915e:	f11a 0801 	adds.w	r8, sl, #1
   29162:	f145 0900 	adc.w	r9, r5, #0
   29166:	f7ff ff8f 	bl	29088 <elapsed>
   2916a:	eb18 0300 	adds.w	r3, r8, r0
   2916e:	eb49 70e0 	adc.w	r0, r9, r0, asr #31
   29172:	6123      	str	r3, [r4, #16]
   29174:	6160      	str	r0, [r4, #20]
   29176:	e03d      	b.n	291f4 <z_add_timeout+0x108>
		}

		for (t = first(); t != NULL; t = next(t)) {
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
   29178:	1a51      	subs	r1, r2, r1
   2917a:	eb66 0303 	sbc.w	r3, r6, r3
   2917e:	6101      	str	r1, [r0, #16]
   29180:	6143      	str	r3, [r0, #20]
	sys_dnode_t *const prev = successor->prev;
   29182:	6843      	ldr	r3, [r0, #4]
	node->prev = prev;
   29184:	6063      	str	r3, [r4, #4]
	node->next = successor;
   29186:	6020      	str	r0, [r4, #0]
	prev->next = node;
   29188:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   2918a:	6044      	str	r4, [r0, #4]
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
   2918c:	2800      	cmp	r0, #0
   2918e:	d045      	beq.n	2921c <z_add_timeout+0x130>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   29190:	f7ff ff64 	bl	2905c <first>
   29194:	4284      	cmp	r4, r0
   29196:	d048      	beq.n	2922a <z_add_timeout+0x13e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29198:	4833      	ldr	r0, [pc, #204]	; (29268 <z_add_timeout+0x17c>)
   2919a:	f7fd fa93 	bl	266c4 <z_spin_unlock_valid>
   2919e:	2800      	cmp	r0, #0
   291a0:	d050      	beq.n	29244 <z_add_timeout+0x158>
	__asm__ volatile(
   291a2:	f387 8811 	msr	BASEPRI, r7
   291a6:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   291aa:	f04f 0801 	mov.w	r8, #1
   291ae:	f1b8 0f00 	cmp.w	r8, #0
   291b2:	d153      	bne.n	2925c <z_add_timeout+0x170>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   291b4:	4653      	mov	r3, sl
   291b6:	f06f 0101 	mvn.w	r1, #1
   291ba:	ebb1 010a 	subs.w	r1, r1, sl
   291be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   291c2:	eb60 0205 	sbc.w	r2, r0, r5
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   291c6:	2a00      	cmp	r2, #0
   291c8:	dbc9      	blt.n	2915e <z_add_timeout+0x72>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   291ca:	4a28      	ldr	r2, [pc, #160]	; (2926c <z_add_timeout+0x180>)
   291cc:	6811      	ldr	r1, [r2, #0]
   291ce:	6852      	ldr	r2, [r2, #4]
   291d0:	185b      	adds	r3, r3, r1
   291d2:	eb42 0205 	adc.w	r2, r2, r5
   291d6:	f06f 0101 	mvn.w	r1, #1
   291da:	1acb      	subs	r3, r1, r3
   291dc:	eb60 0202 	sbc.w	r2, r0, r2
			to->dticks = MAX(1, ticks);
   291e0:	4618      	mov	r0, r3
   291e2:	4611      	mov	r1, r2
   291e4:	2b01      	cmp	r3, #1
   291e6:	f172 0300 	sbcs.w	r3, r2, #0
   291ea:	da01      	bge.n	291f0 <z_add_timeout+0x104>
   291ec:	2001      	movs	r0, #1
   291ee:	2100      	movs	r1, #0
   291f0:	6120      	str	r0, [r4, #16]
   291f2:	6161      	str	r1, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
   291f4:	f7ff ff32 	bl	2905c <first>
   291f8:	2800      	cmp	r0, #0
   291fa:	d0c7      	beq.n	2918c <z_add_timeout+0xa0>
			if (t->dticks > to->dticks) {
   291fc:	6902      	ldr	r2, [r0, #16]
   291fe:	6946      	ldr	r6, [r0, #20]
   29200:	6921      	ldr	r1, [r4, #16]
   29202:	6963      	ldr	r3, [r4, #20]
   29204:	4291      	cmp	r1, r2
   29206:	eb73 0c06 	sbcs.w	ip, r3, r6
   2920a:	dbb5      	blt.n	29178 <z_add_timeout+0x8c>
			to->dticks -= t->dticks;
   2920c:	1a89      	subs	r1, r1, r2
   2920e:	eb63 0306 	sbc.w	r3, r3, r6
   29212:	6121      	str	r1, [r4, #16]
   29214:	6163      	str	r3, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
   29216:	f7ff ff2b 	bl	29070 <next>
   2921a:	e7ed      	b.n	291f8 <z_add_timeout+0x10c>
	sys_dnode_t *const tail = list->tail;
   2921c:	4b14      	ldr	r3, [pc, #80]	; (29270 <z_add_timeout+0x184>)
   2921e:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   29220:	6023      	str	r3, [r4, #0]
	node->prev = tail;
   29222:	6062      	str	r2, [r4, #4]
	tail->next = node;
   29224:	6014      	str	r4, [r2, #0]
	list->tail = node;
   29226:	605c      	str	r4, [r3, #4]
}
   29228:	e7b2      	b.n	29190 <z_add_timeout+0xa4>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   2922a:	f7ff ff39 	bl	290a0 <next_timeout>

			if (next_time == 0 ||
   2922e:	4603      	mov	r3, r0
   29230:	b118      	cbz	r0, 2923a <z_add_timeout+0x14e>
			    _current_cpu->slice_ticks != next_time) {
   29232:	4a10      	ldr	r2, [pc, #64]	; (29274 <z_add_timeout+0x188>)
   29234:	6912      	ldr	r2, [r2, #16]
			if (next_time == 0 ||
   29236:	4282      	cmp	r2, r0
   29238:	d0ae      	beq.n	29198 <z_add_timeout+0xac>
				sys_clock_set_timeout(next_time, false);
   2923a:	2100      	movs	r1, #0
   2923c:	4618      	mov	r0, r3
   2923e:	f7f8 fbe3 	bl	21a08 <sys_clock_set_timeout>
   29242:	e7a9      	b.n	29198 <z_add_timeout+0xac>
   29244:	f8df 8034 	ldr.w	r8, [pc, #52]	; 2927c <z_add_timeout+0x190>
   29248:	22b9      	movs	r2, #185	; 0xb9
   2924a:	4641      	mov	r1, r8
   2924c:	4805      	ldr	r0, [pc, #20]	; (29264 <z_add_timeout+0x178>)
   2924e:	f003 f96e 	bl	2c52e <assert_print>
   29252:	21b9      	movs	r1, #185	; 0xb9
   29254:	4640      	mov	r0, r8
   29256:	f003 f963 	bl	2c520 <assert_post_action>
   2925a:	e7a2      	b.n	291a2 <z_add_timeout+0xb6>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   2925c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   29260:	4770      	bx	lr
   29262:	bf00      	nop
   29264:	00031600 	.word	0x00031600
   29268:	200046fc 	.word	0x200046fc
   2926c:	20002860 	.word	0x20002860
   29270:	20000dec 	.word	0x20000dec
   29274:	200046a4 	.word	0x200046a4
   29278:	0003bf14 	.word	0x0003bf14
   2927c:	000390f0 	.word	0x000390f0

00029280 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
   29280:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29284:	4605      	mov	r5, r0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
   29286:	2400      	movs	r4, #0
	__asm__ volatile(
   29288:	f04f 0340 	mov.w	r3, #64	; 0x40
   2928c:	f3ef 8711 	mrs	r7, BASEPRI
   29290:	f383 8812 	msr	BASEPRI_MAX, r3
   29294:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29298:	481a      	ldr	r0, [pc, #104]	; (29304 <z_abort_timeout+0x84>)
   2929a:	f7fd fa03 	bl	266a4 <z_spin_lock_valid>
   2929e:	b128      	cbz	r0, 292ac <z_abort_timeout+0x2c>
	z_spin_lock_set_owner(l);
   292a0:	4818      	ldr	r0, [pc, #96]	; (29304 <z_abort_timeout+0x84>)
   292a2:	f7fd fa1f 	bl	266e4 <z_spin_lock_set_owner>
	int ret = -EINVAL;
   292a6:	f06f 0815 	mvn.w	r8, #21
	return k;
   292aa:	e013      	b.n	292d4 <z_abort_timeout+0x54>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   292ac:	4e16      	ldr	r6, [pc, #88]	; (29308 <z_abort_timeout+0x88>)
   292ae:	228e      	movs	r2, #142	; 0x8e
   292b0:	4631      	mov	r1, r6
   292b2:	4816      	ldr	r0, [pc, #88]	; (2930c <z_abort_timeout+0x8c>)
   292b4:	f003 f93b 	bl	2c52e <assert_print>
   292b8:	218e      	movs	r1, #142	; 0x8e
   292ba:	4630      	mov	r0, r6
   292bc:	f003 f930 	bl	2c520 <assert_post_action>
   292c0:	e7ee      	b.n	292a0 <z_abort_timeout+0x20>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   292c2:	4810      	ldr	r0, [pc, #64]	; (29304 <z_abort_timeout+0x84>)
   292c4:	f7fd f9fe 	bl	266c4 <z_spin_unlock_valid>
   292c8:	b170      	cbz	r0, 292e8 <z_abort_timeout+0x68>
	__asm__ volatile(
   292ca:	f387 8811 	msr	BASEPRI, r7
   292ce:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   292d2:	2401      	movs	r4, #1
   292d4:	4626      	mov	r6, r4
   292d6:	b994      	cbnz	r4, 292fe <z_abort_timeout+0x7e>
	return node->next != NULL;
   292d8:	682b      	ldr	r3, [r5, #0]
		if (sys_dnode_is_linked(&to->node)) {
   292da:	2b00      	cmp	r3, #0
   292dc:	d0f1      	beq.n	292c2 <z_abort_timeout+0x42>
			remove_timeout(to);
   292de:	4628      	mov	r0, r5
   292e0:	f007 fc4c 	bl	30b7c <remove_timeout>
			ret = 0;
   292e4:	46b0      	mov	r8, r6
   292e6:	e7ec      	b.n	292c2 <z_abort_timeout+0x42>
   292e8:	4c07      	ldr	r4, [pc, #28]	; (29308 <z_abort_timeout+0x88>)
   292ea:	22b9      	movs	r2, #185	; 0xb9
   292ec:	4621      	mov	r1, r4
   292ee:	4807      	ldr	r0, [pc, #28]	; (2930c <z_abort_timeout+0x8c>)
   292f0:	f003 f91d 	bl	2c52e <assert_print>
   292f4:	21b9      	movs	r1, #185	; 0xb9
   292f6:	4620      	mov	r0, r4
   292f8:	f003 f912 	bl	2c520 <assert_post_action>
   292fc:	e7e5      	b.n	292ca <z_abort_timeout+0x4a>
		}
	}

	return ret;
}
   292fe:	4640      	mov	r0, r8
   29300:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29304:	200046fc 	.word	0x200046fc
   29308:	000390f0 	.word	0x000390f0
   2930c:	00031600 	.word	0x00031600

00029310 <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
   29310:	b570      	push	{r4, r5, r6, lr}
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
   29312:	2500      	movs	r5, #0
	__asm__ volatile(
   29314:	f04f 0340 	mov.w	r3, #64	; 0x40
   29318:	f3ef 8611 	mrs	r6, BASEPRI
   2931c:	f383 8812 	msr	BASEPRI_MAX, r3
   29320:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29324:	4817      	ldr	r0, [pc, #92]	; (29384 <z_get_next_timeout_expiry+0x74>)
   29326:	f7fd f9bd 	bl	266a4 <z_spin_lock_valid>
   2932a:	b128      	cbz	r0, 29338 <z_get_next_timeout_expiry+0x28>
	z_spin_lock_set_owner(l);
   2932c:	4815      	ldr	r0, [pc, #84]	; (29384 <z_get_next_timeout_expiry+0x74>)
   2932e:	f7fd f9d9 	bl	266e4 <z_spin_lock_set_owner>
	int32_t ret = (int32_t) K_TICKS_FOREVER;
   29332:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	return k;
   29336:	e00f      	b.n	29358 <z_get_next_timeout_expiry+0x48>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29338:	4c13      	ldr	r4, [pc, #76]	; (29388 <z_get_next_timeout_expiry+0x78>)
   2933a:	228e      	movs	r2, #142	; 0x8e
   2933c:	4621      	mov	r1, r4
   2933e:	4813      	ldr	r0, [pc, #76]	; (2938c <z_get_next_timeout_expiry+0x7c>)
   29340:	f003 f8f5 	bl	2c52e <assert_print>
   29344:	218e      	movs	r1, #142	; 0x8e
   29346:	4620      	mov	r0, r4
   29348:	f003 f8ea 	bl	2c520 <assert_post_action>
   2934c:	e7ee      	b.n	2932c <z_get_next_timeout_expiry+0x1c>
	__asm__ volatile(
   2934e:	f386 8811 	msr	BASEPRI, r6
   29352:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   29356:	2501      	movs	r5, #1
   29358:	b995      	cbnz	r5, 29380 <z_get_next_timeout_expiry+0x70>
		ret = next_timeout();
   2935a:	f7ff fea1 	bl	290a0 <next_timeout>
   2935e:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29360:	4808      	ldr	r0, [pc, #32]	; (29384 <z_get_next_timeout_expiry+0x74>)
   29362:	f7fd f9af 	bl	266c4 <z_spin_unlock_valid>
   29366:	2800      	cmp	r0, #0
   29368:	d1f1      	bne.n	2934e <z_get_next_timeout_expiry+0x3e>
   2936a:	4d07      	ldr	r5, [pc, #28]	; (29388 <z_get_next_timeout_expiry+0x78>)
   2936c:	22b9      	movs	r2, #185	; 0xb9
   2936e:	4629      	mov	r1, r5
   29370:	4806      	ldr	r0, [pc, #24]	; (2938c <z_get_next_timeout_expiry+0x7c>)
   29372:	f003 f8dc 	bl	2c52e <assert_print>
   29376:	21b9      	movs	r1, #185	; 0xb9
   29378:	4628      	mov	r0, r5
   2937a:	f003 f8d1 	bl	2c520 <assert_post_action>
   2937e:	e7e6      	b.n	2934e <z_get_next_timeout_expiry+0x3e>
	}
	return ret;
}
   29380:	4620      	mov	r0, r4
   29382:	bd70      	pop	{r4, r5, r6, pc}
   29384:	200046fc 	.word	0x200046fc
   29388:	000390f0 	.word	0x000390f0
   2938c:	00031600 	.word	0x00031600

00029390 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
   29390:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29394:	4606      	mov	r6, r0
   29396:	4688      	mov	r8, r1
	LOCKED(&timeout_lock) {
   29398:	2500      	movs	r5, #0
	__asm__ volatile(
   2939a:	f04f 0340 	mov.w	r3, #64	; 0x40
   2939e:	f3ef 8711 	mrs	r7, BASEPRI
   293a2:	f383 8812 	msr	BASEPRI_MAX, r3
   293a6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   293aa:	4820      	ldr	r0, [pc, #128]	; (2942c <z_set_timeout_expiry+0x9c>)
   293ac:	f7fd f97a 	bl	266a4 <z_spin_lock_valid>
   293b0:	b118      	cbz	r0, 293ba <z_set_timeout_expiry+0x2a>
	z_spin_lock_set_owner(l);
   293b2:	481e      	ldr	r0, [pc, #120]	; (2942c <z_set_timeout_expiry+0x9c>)
   293b4:	f7fd f996 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   293b8:	e019      	b.n	293ee <z_set_timeout_expiry+0x5e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   293ba:	4c1d      	ldr	r4, [pc, #116]	; (29430 <z_set_timeout_expiry+0xa0>)
   293bc:	228e      	movs	r2, #142	; 0x8e
   293be:	4621      	mov	r1, r4
   293c0:	481c      	ldr	r0, [pc, #112]	; (29434 <z_set_timeout_expiry+0xa4>)
   293c2:	f003 f8b4 	bl	2c52e <assert_print>
   293c6:	218e      	movs	r1, #142	; 0x8e
   293c8:	4620      	mov	r0, r4
   293ca:	f003 f8a9 	bl	2c520 <assert_post_action>
   293ce:	e7f0      	b.n	293b2 <z_set_timeout_expiry+0x22>
		int next_to = next_timeout();
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
   293d0:	2401      	movs	r4, #1
		bool sooner = (next_to == K_TICKS_FOREVER)
   293d2:	f004 0401 	and.w	r4, r4, #1
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   293d6:	2801      	cmp	r0, #1
   293d8:	dd00      	ble.n	293dc <z_set_timeout_expiry+0x4c>
   293da:	b99c      	cbnz	r4, 29404 <z_set_timeout_expiry+0x74>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   293dc:	4813      	ldr	r0, [pc, #76]	; (2942c <z_set_timeout_expiry+0x9c>)
   293de:	f7fd f971 	bl	266c4 <z_spin_unlock_valid>
   293e2:	b1b0      	cbz	r0, 29412 <z_set_timeout_expiry+0x82>
	__asm__ volatile(
   293e4:	f387 8811 	msr	BASEPRI, r7
   293e8:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   293ec:	2501      	movs	r5, #1
   293ee:	462c      	mov	r4, r5
   293f0:	b9d5      	cbnz	r5, 29428 <z_set_timeout_expiry+0x98>
		int next_to = next_timeout();
   293f2:	f7ff fe55 	bl	290a0 <next_timeout>
			      || (ticks <= next_to);
   293f6:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   293fa:	d0e9      	beq.n	293d0 <z_set_timeout_expiry+0x40>
   293fc:	42b0      	cmp	r0, r6
   293fe:	dbe8      	blt.n	293d2 <z_set_timeout_expiry+0x42>
   29400:	2401      	movs	r4, #1
   29402:	e7e6      	b.n	293d2 <z_set_timeout_expiry+0x42>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   29404:	4641      	mov	r1, r8
   29406:	42b0      	cmp	r0, r6
   29408:	bfa8      	it	ge
   2940a:	4630      	movge	r0, r6
   2940c:	f7f8 fafc 	bl	21a08 <sys_clock_set_timeout>
   29410:	e7e4      	b.n	293dc <z_set_timeout_expiry+0x4c>
   29412:	4c07      	ldr	r4, [pc, #28]	; (29430 <z_set_timeout_expiry+0xa0>)
   29414:	22b9      	movs	r2, #185	; 0xb9
   29416:	4621      	mov	r1, r4
   29418:	4806      	ldr	r0, [pc, #24]	; (29434 <z_set_timeout_expiry+0xa4>)
   2941a:	f003 f888 	bl	2c52e <assert_print>
   2941e:	21b9      	movs	r1, #185	; 0xb9
   29420:	4620      	mov	r0, r4
   29422:	f003 f87d 	bl	2c520 <assert_post_action>
   29426:	e7dd      	b.n	293e4 <z_set_timeout_expiry+0x54>
		}
	}
}
   29428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2942c:	200046fc 	.word	0x200046fc
   29430:	000390f0 	.word	0x000390f0
   29434:	00031600 	.word	0x00031600

00029438 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
   29438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2943a:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   2943c:	f7fe fe56 	bl	280ec <z_time_slice>
	__asm__ volatile(
   29440:	f04f 0340 	mov.w	r3, #64	; 0x40
   29444:	f3ef 8511 	mrs	r5, BASEPRI
   29448:	f383 8812 	msr	BASEPRI_MAX, r3
   2944c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29450:	484b      	ldr	r0, [pc, #300]	; (29580 <sys_clock_announce+0x148>)
   29452:	f7fd f927 	bl	266a4 <z_spin_lock_valid>
   29456:	b128      	cbz	r0, 29464 <sys_clock_announce+0x2c>
	z_spin_lock_set_owner(l);
   29458:	4849      	ldr	r0, [pc, #292]	; (29580 <sys_clock_announce+0x148>)
   2945a:	f7fd f943 	bl	266e4 <z_spin_lock_set_owner>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
   2945e:	4b49      	ldr	r3, [pc, #292]	; (29584 <sys_clock_announce+0x14c>)
   29460:	601c      	str	r4, [r3, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
   29462:	e01c      	b.n	2949e <sys_clock_announce+0x66>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29464:	4e48      	ldr	r6, [pc, #288]	; (29588 <sys_clock_announce+0x150>)
   29466:	228e      	movs	r2, #142	; 0x8e
   29468:	4631      	mov	r1, r6
   2946a:	4848      	ldr	r0, [pc, #288]	; (2958c <sys_clock_announce+0x154>)
   2946c:	f003 f85f 	bl	2c52e <assert_print>
   29470:	218e      	movs	r1, #142	; 0x8e
   29472:	4630      	mov	r0, r6
   29474:	f003 f854 	bl	2c520 <assert_post_action>
   29478:	e7ee      	b.n	29458 <sys_clock_announce+0x20>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2947a:	4f43      	ldr	r7, [pc, #268]	; (29588 <sys_clock_announce+0x150>)
   2947c:	22b9      	movs	r2, #185	; 0xb9
   2947e:	4639      	mov	r1, r7
   29480:	4842      	ldr	r0, [pc, #264]	; (2958c <sys_clock_announce+0x154>)
   29482:	f003 f854 	bl	2c52e <assert_print>
   29486:	21b9      	movs	r1, #185	; 0xb9
   29488:	4638      	mov	r0, r7
   2948a:	f003 f849 	bl	2c520 <assert_post_action>
   2948e:	e028      	b.n	294e2 <sys_clock_announce+0xaa>
	z_spin_lock_set_owner(l);
   29490:	483b      	ldr	r0, [pc, #236]	; (29580 <sys_clock_announce+0x148>)
   29492:	f7fd f927 	bl	266e4 <z_spin_lock_set_owner>
		remove_timeout(t);

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
   29496:	4a3b      	ldr	r2, [pc, #236]	; (29584 <sys_clock_announce+0x14c>)
   29498:	6813      	ldr	r3, [r2, #0]
   2949a:	1b9b      	subs	r3, r3, r6
   2949c:	6013      	str	r3, [r2, #0]
	while (first() != NULL && first()->dticks <= announce_remaining) {
   2949e:	f7ff fddd 	bl	2905c <first>
   294a2:	4604      	mov	r4, r0
   294a4:	2800      	cmp	r0, #0
   294a6:	d03b      	beq.n	29520 <sys_clock_announce+0xe8>
   294a8:	6906      	ldr	r6, [r0, #16]
   294aa:	6942      	ldr	r2, [r0, #20]
   294ac:	4b35      	ldr	r3, [pc, #212]	; (29584 <sys_clock_announce+0x14c>)
   294ae:	681b      	ldr	r3, [r3, #0]
   294b0:	17d9      	asrs	r1, r3, #31
   294b2:	42b3      	cmp	r3, r6
   294b4:	eb71 0302 	sbcs.w	r3, r1, r2
   294b8:	db32      	blt.n	29520 <sys_clock_announce+0xe8>
		curr_tick += dt;
   294ba:	4a35      	ldr	r2, [pc, #212]	; (29590 <sys_clock_announce+0x158>)
   294bc:	6813      	ldr	r3, [r2, #0]
   294be:	6851      	ldr	r1, [r2, #4]
   294c0:	199b      	adds	r3, r3, r6
   294c2:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
   294c6:	6013      	str	r3, [r2, #0]
   294c8:	6051      	str	r1, [r2, #4]
		t->dticks = 0;
   294ca:	2200      	movs	r2, #0
   294cc:	2300      	movs	r3, #0
   294ce:	e9c4 2304 	strd	r2, r3, [r4, #16]
		remove_timeout(t);
   294d2:	4620      	mov	r0, r4
   294d4:	f007 fb52 	bl	30b7c <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   294d8:	4829      	ldr	r0, [pc, #164]	; (29580 <sys_clock_announce+0x148>)
   294da:	f7fd f8f3 	bl	266c4 <z_spin_unlock_valid>
   294de:	2800      	cmp	r0, #0
   294e0:	d0cb      	beq.n	2947a <sys_clock_announce+0x42>
	__asm__ volatile(
   294e2:	f385 8811 	msr	BASEPRI, r5
   294e6:	f3bf 8f6f 	isb	sy
		t->fn(t);
   294ea:	68a3      	ldr	r3, [r4, #8]
   294ec:	4620      	mov	r0, r4
   294ee:	4798      	blx	r3
	__asm__ volatile(
   294f0:	f04f 0340 	mov.w	r3, #64	; 0x40
   294f4:	f3ef 8511 	mrs	r5, BASEPRI
   294f8:	f383 8812 	msr	BASEPRI_MAX, r3
   294fc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29500:	481f      	ldr	r0, [pc, #124]	; (29580 <sys_clock_announce+0x148>)
   29502:	f7fd f8cf 	bl	266a4 <z_spin_lock_valid>
   29506:	2800      	cmp	r0, #0
   29508:	d1c2      	bne.n	29490 <sys_clock_announce+0x58>
   2950a:	4c1f      	ldr	r4, [pc, #124]	; (29588 <sys_clock_announce+0x150>)
   2950c:	228e      	movs	r2, #142	; 0x8e
   2950e:	4621      	mov	r1, r4
   29510:	481e      	ldr	r0, [pc, #120]	; (2958c <sys_clock_announce+0x154>)
   29512:	f003 f80c 	bl	2c52e <assert_print>
   29516:	218e      	movs	r1, #142	; 0x8e
   29518:	4620      	mov	r0, r4
   2951a:	f003 f801 	bl	2c520 <assert_post_action>
   2951e:	e7b7      	b.n	29490 <sys_clock_announce+0x58>
	}

	if (first() != NULL) {
   29520:	b144      	cbz	r4, 29534 <sys_clock_announce+0xfc>
		first()->dticks -= announce_remaining;
   29522:	4b18      	ldr	r3, [pc, #96]	; (29584 <sys_clock_announce+0x14c>)
   29524:	6819      	ldr	r1, [r3, #0]
   29526:	6923      	ldr	r3, [r4, #16]
   29528:	6962      	ldr	r2, [r4, #20]
   2952a:	1a5b      	subs	r3, r3, r1
   2952c:	eb62 72e1 	sbc.w	r2, r2, r1, asr #31
   29530:	6123      	str	r3, [r4, #16]
   29532:	6162      	str	r2, [r4, #20]
	}

	curr_tick += announce_remaining;
   29534:	4a16      	ldr	r2, [pc, #88]	; (29590 <sys_clock_announce+0x158>)
   29536:	4e13      	ldr	r6, [pc, #76]	; (29584 <sys_clock_announce+0x14c>)
   29538:	6830      	ldr	r0, [r6, #0]
   2953a:	6813      	ldr	r3, [r2, #0]
   2953c:	6851      	ldr	r1, [r2, #4]
   2953e:	181b      	adds	r3, r3, r0
   29540:	eb41 71e0 	adc.w	r1, r1, r0, asr #31
   29544:	6013      	str	r3, [r2, #0]
   29546:	6051      	str	r1, [r2, #4]
	announce_remaining = 0;
   29548:	2400      	movs	r4, #0
   2954a:	6034      	str	r4, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
   2954c:	f7ff fda8 	bl	290a0 <next_timeout>
   29550:	4621      	mov	r1, r4
   29552:	f7f8 fa59 	bl	21a08 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29556:	480a      	ldr	r0, [pc, #40]	; (29580 <sys_clock_announce+0x148>)
   29558:	f7fd f8b4 	bl	266c4 <z_spin_unlock_valid>
   2955c:	b120      	cbz	r0, 29568 <sys_clock_announce+0x130>
	__asm__ volatile(
   2955e:	f385 8811 	msr	BASEPRI, r5
   29562:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   29566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29568:	4c07      	ldr	r4, [pc, #28]	; (29588 <sys_clock_announce+0x150>)
   2956a:	22b9      	movs	r2, #185	; 0xb9
   2956c:	4621      	mov	r1, r4
   2956e:	4807      	ldr	r0, [pc, #28]	; (2958c <sys_clock_announce+0x154>)
   29570:	f002 ffdd 	bl	2c52e <assert_print>
   29574:	21b9      	movs	r1, #185	; 0xb9
   29576:	4620      	mov	r0, r4
   29578:	f002 ffd2 	bl	2c520 <assert_post_action>
   2957c:	e7ef      	b.n	2955e <sys_clock_announce+0x126>
   2957e:	bf00      	nop
   29580:	200046fc 	.word	0x200046fc
   29584:	200046f8 	.word	0x200046f8
   29588:	000390f0 	.word	0x000390f0
   2958c:	00031600 	.word	0x00031600
   29590:	20002860 	.word	0x20002860

00029594 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   29594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
   29596:	2700      	movs	r7, #0
	__asm__ volatile(
   29598:	f04f 0340 	mov.w	r3, #64	; 0x40
   2959c:	f3ef 8611 	mrs	r6, BASEPRI
   295a0:	f383 8812 	msr	BASEPRI_MAX, r3
   295a4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   295a8:	481a      	ldr	r0, [pc, #104]	; (29614 <sys_clock_tick_get+0x80>)
   295aa:	f7fd f87b 	bl	266a4 <z_spin_lock_valid>
   295ae:	b128      	cbz	r0, 295bc <sys_clock_tick_get+0x28>
	z_spin_lock_set_owner(l);
   295b0:	4818      	ldr	r0, [pc, #96]	; (29614 <sys_clock_tick_get+0x80>)
   295b2:	f7fd f897 	bl	266e4 <z_spin_lock_set_owner>
	uint64_t t = 0U;
   295b6:	2400      	movs	r4, #0
   295b8:	4625      	mov	r5, r4
	return k;
   295ba:	e00f      	b.n	295dc <sys_clock_tick_get+0x48>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   295bc:	4c16      	ldr	r4, [pc, #88]	; (29618 <sys_clock_tick_get+0x84>)
   295be:	228e      	movs	r2, #142	; 0x8e
   295c0:	4621      	mov	r1, r4
   295c2:	4816      	ldr	r0, [pc, #88]	; (2961c <sys_clock_tick_get+0x88>)
   295c4:	f002 ffb3 	bl	2c52e <assert_print>
   295c8:	218e      	movs	r1, #142	; 0x8e
   295ca:	4620      	mov	r0, r4
   295cc:	f002 ffa8 	bl	2c520 <assert_post_action>
   295d0:	e7ee      	b.n	295b0 <sys_clock_tick_get+0x1c>
	__asm__ volatile(
   295d2:	f386 8811 	msr	BASEPRI, r6
   295d6:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   295da:	2701      	movs	r7, #1
   295dc:	b9bf      	cbnz	r7, 2960e <sys_clock_tick_get+0x7a>
		t = curr_tick + elapsed();
   295de:	f7ff fd53 	bl	29088 <elapsed>
   295e2:	4a0f      	ldr	r2, [pc, #60]	; (29620 <sys_clock_tick_get+0x8c>)
   295e4:	6814      	ldr	r4, [r2, #0]
   295e6:	6855      	ldr	r5, [r2, #4]
   295e8:	1904      	adds	r4, r0, r4
   295ea:	eb45 75e0 	adc.w	r5, r5, r0, asr #31
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   295ee:	4809      	ldr	r0, [pc, #36]	; (29614 <sys_clock_tick_get+0x80>)
   295f0:	f7fd f868 	bl	266c4 <z_spin_unlock_valid>
   295f4:	2800      	cmp	r0, #0
   295f6:	d1ec      	bne.n	295d2 <sys_clock_tick_get+0x3e>
   295f8:	4f07      	ldr	r7, [pc, #28]	; (29618 <sys_clock_tick_get+0x84>)
   295fa:	22b9      	movs	r2, #185	; 0xb9
   295fc:	4639      	mov	r1, r7
   295fe:	4807      	ldr	r0, [pc, #28]	; (2961c <sys_clock_tick_get+0x88>)
   29600:	f002 ff95 	bl	2c52e <assert_print>
   29604:	21b9      	movs	r1, #185	; 0xb9
   29606:	4638      	mov	r0, r7
   29608:	f002 ff8a 	bl	2c520 <assert_post_action>
   2960c:	e7e1      	b.n	295d2 <sys_clock_tick_get+0x3e>
	}
	return t;
}
   2960e:	4620      	mov	r0, r4
   29610:	4629      	mov	r1, r5
   29612:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29614:	200046fc 	.word	0x200046fc
   29618:	000390f0 	.word	0x000390f0
   2961c:	00031600 	.word	0x00031600
   29620:	20002860 	.word	0x20002860

00029624 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   29624:	b570      	push	{r4, r5, r6, lr}
   29626:	4604      	mov	r4, r0
	__asm__ volatile(
   29628:	f04f 0340 	mov.w	r3, #64	; 0x40
   2962c:	f3ef 8611 	mrs	r6, BASEPRI
   29630:	f383 8812 	msr	BASEPRI_MAX, r3
   29634:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29638:	485b      	ldr	r0, [pc, #364]	; (297a8 <z_timer_expiration_handler+0x184>)
   2963a:	f7fd f833 	bl	266a4 <z_spin_lock_valid>
   2963e:	2800      	cmp	r0, #0
   29640:	d049      	beq.n	296d6 <z_timer_expiration_handler+0xb2>
	z_spin_lock_set_owner(l);
   29642:	4859      	ldr	r0, [pc, #356]	; (297a8 <z_timer_expiration_handler+0x184>)
   29644:	f7fd f84e 	bl	266e4 <z_spin_lock_set_owner>
	return k;
   29648:	4635      	mov	r5, r6

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2964a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   2964c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2964e:	ea52 0103 	orrs.w	r1, r2, r3
   29652:	d005      	beq.n	29660 <z_timer_expiration_handler+0x3c>
   29654:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   29658:	bf08      	it	eq
   2965a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   2965e:	d145      	bne.n	296ec <z_timer_expiration_handler+0xc8>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
   29660:	6b23      	ldr	r3, [r4, #48]	; 0x30
   29662:	3301      	adds	r3, #1
   29664:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   29666:	6a23      	ldr	r3, [r4, #32]
   29668:	b1db      	cbz	r3, 296a2 <z_timer_expiration_handler+0x7e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2966a:	484f      	ldr	r0, [pc, #316]	; (297a8 <z_timer_expiration_handler+0x184>)
   2966c:	f7fd f82a 	bl	266c4 <z_spin_unlock_valid>
   29670:	2800      	cmp	r0, #0
   29672:	d064      	beq.n	2973e <z_timer_expiration_handler+0x11a>
	__asm__ volatile(
   29674:	f386 8811 	msr	BASEPRI, r6
   29678:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   2967c:	6a23      	ldr	r3, [r4, #32]
   2967e:	4620      	mov	r0, r4
   29680:	4798      	blx	r3
	__asm__ volatile(
   29682:	f04f 0340 	mov.w	r3, #64	; 0x40
   29686:	f3ef 8511 	mrs	r5, BASEPRI
   2968a:	f383 8812 	msr	BASEPRI_MAX, r3
   2968e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29692:	4845      	ldr	r0, [pc, #276]	; (297a8 <z_timer_expiration_handler+0x184>)
   29694:	f7fd f806 	bl	266a4 <z_spin_lock_valid>
   29698:	2800      	cmp	r0, #0
   2969a:	d05b      	beq.n	29754 <z_timer_expiration_handler+0x130>
	z_spin_lock_set_owner(l);
   2969c:	4842      	ldr	r0, [pc, #264]	; (297a8 <z_timer_expiration_handler+0x184>)
   2969e:	f7fd f821 	bl	266e4 <z_spin_lock_set_owner>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   296a2:	f104 0318 	add.w	r3, r4, #24
	return list->head == list;
   296a6:	69a4      	ldr	r4, [r4, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   296a8:	42a3      	cmp	r3, r4
   296aa:	d05e      	beq.n	2976a <z_timer_expiration_handler+0x146>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   296ac:	2c00      	cmp	r4, #0
   296ae:	d05c      	beq.n	2976a <z_timer_expiration_handler+0x146>
		k_spin_unlock(&lock, key);
		return;
	}

	z_unpend_thread_no_timeout(thread);
   296b0:	4620      	mov	r0, r4
   296b2:	f7fe fb23 	bl	27cfc <z_unpend_thread_no_timeout>
   296b6:	2300      	movs	r3, #0
   296b8:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   296bc:	483a      	ldr	r0, [pc, #232]	; (297a8 <z_timer_expiration_handler+0x184>)
   296be:	f7fd f801 	bl	266c4 <z_spin_unlock_valid>
   296c2:	2800      	cmp	r0, #0
   296c4:	d065      	beq.n	29792 <z_timer_expiration_handler+0x16e>
	__asm__ volatile(
   296c6:	f385 8811 	msr	BASEPRI, r5
   296ca:	f3bf 8f6f 	isb	sy

	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
   296ce:	4620      	mov	r0, r4
   296d0:	f7fe fdf0 	bl	282b4 <z_ready_thread>
}
   296d4:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   296d6:	4d35      	ldr	r5, [pc, #212]	; (297ac <z_timer_expiration_handler+0x188>)
   296d8:	228e      	movs	r2, #142	; 0x8e
   296da:	4629      	mov	r1, r5
   296dc:	4834      	ldr	r0, [pc, #208]	; (297b0 <z_timer_expiration_handler+0x18c>)
   296de:	f002 ff26 	bl	2c52e <assert_print>
   296e2:	218e      	movs	r1, #142	; 0x8e
   296e4:	4628      	mov	r0, r5
   296e6:	f002 ff1b 	bl	2c520 <assert_post_action>
   296ea:	e7aa      	b.n	29642 <z_timer_expiration_handler+0x1e>
	return z_impl_k_uptime_ticks();
   296ec:	f007 fa61 	bl	30bb2 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
   296f0:	3001      	adds	r0, #1
   296f2:	f141 0100 	adc.w	r1, r1, #0
   296f6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   296f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   296fa:	18c0      	adds	r0, r0, r3
   296fc:	eb41 0102 	adc.w	r1, r1, r2
   29700:	2801      	cmp	r0, #1
   29702:	f171 0300 	sbcs.w	r3, r1, #0
   29706:	da08      	bge.n	2971a <z_timer_expiration_handler+0xf6>
   29708:	f06f 0201 	mvn.w	r2, #1
   2970c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   29710:	4928      	ldr	r1, [pc, #160]	; (297b4 <z_timer_expiration_handler+0x190>)
   29712:	4620      	mov	r0, r4
   29714:	f7ff fcea 	bl	290ec <z_add_timeout>
   29718:	e7a2      	b.n	29660 <z_timer_expiration_handler+0x3c>
   2971a:	f007 fa4a 	bl	30bb2 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
   2971e:	3001      	adds	r0, #1
   29720:	f141 0300 	adc.w	r3, r1, #0
   29724:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   29726:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   29728:	1880      	adds	r0, r0, r2
   2972a:	eb43 0301 	adc.w	r3, r3, r1
   2972e:	f06f 0201 	mvn.w	r2, #1
   29732:	1a12      	subs	r2, r2, r0
   29734:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   29738:	eb61 0303 	sbc.w	r3, r1, r3
   2973c:	e7e8      	b.n	29710 <z_timer_expiration_handler+0xec>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2973e:	4d1b      	ldr	r5, [pc, #108]	; (297ac <z_timer_expiration_handler+0x188>)
   29740:	22b9      	movs	r2, #185	; 0xb9
   29742:	4629      	mov	r1, r5
   29744:	481a      	ldr	r0, [pc, #104]	; (297b0 <z_timer_expiration_handler+0x18c>)
   29746:	f002 fef2 	bl	2c52e <assert_print>
   2974a:	21b9      	movs	r1, #185	; 0xb9
   2974c:	4628      	mov	r0, r5
   2974e:	f002 fee7 	bl	2c520 <assert_post_action>
   29752:	e78f      	b.n	29674 <z_timer_expiration_handler+0x50>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29754:	4e15      	ldr	r6, [pc, #84]	; (297ac <z_timer_expiration_handler+0x188>)
   29756:	228e      	movs	r2, #142	; 0x8e
   29758:	4631      	mov	r1, r6
   2975a:	4815      	ldr	r0, [pc, #84]	; (297b0 <z_timer_expiration_handler+0x18c>)
   2975c:	f002 fee7 	bl	2c52e <assert_print>
   29760:	218e      	movs	r1, #142	; 0x8e
   29762:	4630      	mov	r0, r6
   29764:	f002 fedc 	bl	2c520 <assert_post_action>
   29768:	e798      	b.n	2969c <z_timer_expiration_handler+0x78>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2976a:	480f      	ldr	r0, [pc, #60]	; (297a8 <z_timer_expiration_handler+0x184>)
   2976c:	f7fc ffaa 	bl	266c4 <z_spin_unlock_valid>
   29770:	b120      	cbz	r0, 2977c <z_timer_expiration_handler+0x158>
   29772:	f385 8811 	msr	BASEPRI, r5
   29776:	f3bf 8f6f 	isb	sy
		return;
   2977a:	e7ab      	b.n	296d4 <z_timer_expiration_handler+0xb0>
   2977c:	4c0b      	ldr	r4, [pc, #44]	; (297ac <z_timer_expiration_handler+0x188>)
   2977e:	22b9      	movs	r2, #185	; 0xb9
   29780:	4621      	mov	r1, r4
   29782:	480b      	ldr	r0, [pc, #44]	; (297b0 <z_timer_expiration_handler+0x18c>)
   29784:	f002 fed3 	bl	2c52e <assert_print>
   29788:	21b9      	movs	r1, #185	; 0xb9
   2978a:	4620      	mov	r0, r4
   2978c:	f002 fec8 	bl	2c520 <assert_post_action>
   29790:	e7ef      	b.n	29772 <z_timer_expiration_handler+0x14e>
   29792:	4e06      	ldr	r6, [pc, #24]	; (297ac <z_timer_expiration_handler+0x188>)
   29794:	22b9      	movs	r2, #185	; 0xb9
   29796:	4631      	mov	r1, r6
   29798:	4805      	ldr	r0, [pc, #20]	; (297b0 <z_timer_expiration_handler+0x18c>)
   2979a:	f002 fec8 	bl	2c52e <assert_print>
   2979e:	21b9      	movs	r1, #185	; 0xb9
   297a0:	4630      	mov	r0, r6
   297a2:	f002 febd 	bl	2c520 <assert_post_action>
   297a6:	e78e      	b.n	296c6 <z_timer_expiration_handler+0xa2>
   297a8:	20004700 	.word	0x20004700
   297ac:	000390f0 	.word	0x000390f0
   297b0:	00031600 	.word	0x00031600
   297b4:	00029625 	.word	0x00029625

000297b8 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   297b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   297bc:	9f06      	ldr	r7, [sp, #24]
   297be:	f8dd 801c 	ldr.w	r8, [sp, #28]
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   297c2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   297c6:	bf08      	it	eq
   297c8:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   297cc:	d02f      	beq.n	2982e <z_impl_k_timer_start+0x76>
   297ce:	4605      	mov	r5, r0
   297d0:	4614      	mov	r4, r2
   297d2:	461e      	mov	r6, r3
   297d4:	4611      	mov	r1, r2
   297d6:	4618      	mov	r0, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   297d8:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   297dc:	bf08      	it	eq
   297de:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
   297e2:	d00d      	beq.n	29800 <z_impl_k_timer_start+0x48>
   297e4:	ea57 0c08 	orrs.w	ip, r7, r8
   297e8:	d00a      	beq.n	29800 <z_impl_k_timer_start+0x48>
	    Z_TICK_ABS(period.ticks) < 0) {
   297ea:	f06f 0c01 	mvn.w	ip, #1
   297ee:	ebbc 0c07 	subs.w	ip, ip, r7
   297f2:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   297f6:	eb6c 0c08 	sbc.w	ip, ip, r8
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   297fa:	f1bc 0f00 	cmp.w	ip, #0
   297fe:	db18      	blt.n	29832 <z_impl_k_timer_start+0x7a>
		period.ticks = MAX(period.ticks - 1, 1);
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   29800:	f06f 0301 	mvn.w	r3, #1
   29804:	1a5b      	subs	r3, r3, r1
   29806:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2980a:	eb63 0300 	sbc.w	r3, r3, r0
   2980e:	2b00      	cmp	r3, #0
   29810:	db1a      	blt.n	29848 <z_impl_k_timer_start+0x90>
		duration.ticks = MAX(duration.ticks - 1, 0);
	}

	(void)z_abort_timeout(&timer->timeout);
   29812:	4628      	mov	r0, r5
   29814:	f7ff fd34 	bl	29280 <z_abort_timeout>
	timer->period = period;
   29818:	62af      	str	r7, [r5, #40]	; 0x28
   2981a:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
	timer->status = 0U;
   2981e:	2300      	movs	r3, #0
   29820:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   29822:	4622      	mov	r2, r4
   29824:	4633      	mov	r3, r6
   29826:	490e      	ldr	r1, [pc, #56]	; (29860 <z_impl_k_timer_start+0xa8>)
   29828:	4628      	mov	r0, r5
   2982a:	f7ff fc5f 	bl	290ec <z_add_timeout>
		     duration);
}
   2982e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		period.ticks = MAX(period.ticks - 1, 1);
   29832:	2f02      	cmp	r7, #2
   29834:	f178 0300 	sbcs.w	r3, r8, #0
   29838:	da02      	bge.n	29840 <z_impl_k_timer_start+0x88>
   2983a:	2702      	movs	r7, #2
   2983c:	f04f 0800 	mov.w	r8, #0
   29840:	3f01      	subs	r7, #1
   29842:	f148 38ff 	adc.w	r8, r8, #4294967295	; 0xffffffff
   29846:	e7db      	b.n	29800 <z_impl_k_timer_start+0x48>
		duration.ticks = MAX(duration.ticks - 1, 0);
   29848:	460c      	mov	r4, r1
   2984a:	4606      	mov	r6, r0
   2984c:	2901      	cmp	r1, #1
   2984e:	f170 0300 	sbcs.w	r3, r0, #0
   29852:	da01      	bge.n	29858 <z_impl_k_timer_start+0xa0>
   29854:	2401      	movs	r4, #1
   29856:	2600      	movs	r6, #0
   29858:	3c01      	subs	r4, #1
   2985a:	f146 36ff 	adc.w	r6, r6, #4294967295	; 0xffffffff
   2985e:	e7d8      	b.n	29812 <z_impl_k_timer_start+0x5a>
   29860:	00029625 	.word	0x00029625

00029864 <clear_event_registrations>:

/* must be called with interrupts locked */
static inline void clear_event_registrations(struct k_poll_event *events,
					      int num_events,
					      k_spinlock_key_t key)
{
   29864:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29868:	4606      	mov	r6, r0
   2986a:	4615      	mov	r5, r2
	while (num_events--) {
   2986c:	e026      	b.n	298bc <clear_event_registrations+0x58>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   2986e:	6923      	ldr	r3, [r4, #16]
   29870:	2b00      	cmp	r3, #0
   29872:	d049      	beq.n	29908 <clear_event_registrations+0xa4>
	return node->next != NULL;
   29874:	f856 3008 	ldr.w	r3, [r6, r8]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   29878:	b133      	cbz	r3, 29888 <clear_event_registrations+0x24>
	sys_dnode_t *const prev = node->prev;
   2987a:	6862      	ldr	r2, [r4, #4]
	prev->next = next;
   2987c:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   2987e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   29880:	2300      	movs	r3, #0
   29882:	f846 3008 	str.w	r3, [r6, r8]
	node->prev = NULL;
   29886:	6063      	str	r3, [r4, #4]
   29888:	484d      	ldr	r0, [pc, #308]	; (299c0 <clear_event_registrations+0x15c>)
   2988a:	f7fc ff1b 	bl	266c4 <z_spin_unlock_valid>
   2988e:	2800      	cmp	r0, #0
   29890:	d07e      	beq.n	29990 <clear_event_registrations+0x12c>
   29892:	f385 8811 	msr	BASEPRI, r5
   29896:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2989a:	f04f 0340 	mov.w	r3, #64	; 0x40
   2989e:	f3ef 8511 	mrs	r5, BASEPRI
   298a2:	f383 8812 	msr	BASEPRI_MAX, r3
   298a6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   298aa:	4845      	ldr	r0, [pc, #276]	; (299c0 <clear_event_registrations+0x15c>)
   298ac:	f7fc fefa 	bl	266a4 <z_spin_lock_valid>
   298b0:	2800      	cmp	r0, #0
   298b2:	d078      	beq.n	299a6 <clear_event_registrations+0x142>
	z_spin_lock_set_owner(l);
   298b4:	4842      	ldr	r0, [pc, #264]	; (299c0 <clear_event_registrations+0x15c>)
   298b6:	f7fc ff15 	bl	266e4 <z_spin_lock_set_owner>
	while (num_events--) {
   298ba:	4639      	mov	r1, r7
   298bc:	1e4f      	subs	r7, r1, #1
   298be:	2900      	cmp	r1, #0
   298c0:	d07c      	beq.n	299bc <clear_event_registrations+0x158>
		clear_event_registration(&events[num_events]);
   298c2:	eb07 0487 	add.w	r4, r7, r7, lsl #2
   298c6:	ea4f 0884 	mov.w	r8, r4, lsl #2
   298ca:	eb06 0484 	add.w	r4, r6, r4, lsl #2
	event->poller = NULL;
   298ce:	2300      	movs	r3, #0
   298d0:	60a3      	str	r3, [r4, #8]
	switch (event->type) {
   298d2:	7b63      	ldrb	r3, [r4, #13]
   298d4:	f003 031f 	and.w	r3, r3, #31
   298d8:	2b08      	cmp	r3, #8
   298da:	d84e      	bhi.n	2997a <clear_event_registrations+0x116>
   298dc:	a201      	add	r2, pc, #4	; (adr r2, 298e4 <clear_event_registrations+0x80>)
   298de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   298e2:	bf00      	nop
   298e4:	00029889 	.word	0x00029889
   298e8:	0002993f 	.word	0x0002993f
   298ec:	0002986f 	.word	0x0002986f
   298f0:	0002997b 	.word	0x0002997b
   298f4:	00029921 	.word	0x00029921
   298f8:	0002997b 	.word	0x0002997b
   298fc:	0002997b 	.word	0x0002997b
   29900:	0002997b 	.word	0x0002997b
   29904:	0002995d 	.word	0x0002995d
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   29908:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 299c8 <clear_event_registrations+0x164>
   2990c:	22a9      	movs	r2, #169	; 0xa9
   2990e:	4649      	mov	r1, r9
   29910:	482c      	ldr	r0, [pc, #176]	; (299c4 <clear_event_registrations+0x160>)
   29912:	f002 fe0c 	bl	2c52e <assert_print>
   29916:	21a9      	movs	r1, #169	; 0xa9
   29918:	4648      	mov	r0, r9
   2991a:	f002 fe01 	bl	2c520 <assert_post_action>
   2991e:	e7a9      	b.n	29874 <clear_event_registrations+0x10>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   29920:	6923      	ldr	r3, [r4, #16]
   29922:	2b00      	cmp	r3, #0
   29924:	d1a6      	bne.n	29874 <clear_event_registrations+0x10>
   29926:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 299c8 <clear_event_registrations+0x164>
   2992a:	22ad      	movs	r2, #173	; 0xad
   2992c:	4649      	mov	r1, r9
   2992e:	4825      	ldr	r0, [pc, #148]	; (299c4 <clear_event_registrations+0x160>)
   29930:	f002 fdfd 	bl	2c52e <assert_print>
   29934:	21ad      	movs	r1, #173	; 0xad
   29936:	4648      	mov	r0, r9
   29938:	f002 fdf2 	bl	2c520 <assert_post_action>
   2993c:	e79a      	b.n	29874 <clear_event_registrations+0x10>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   2993e:	6923      	ldr	r3, [r4, #16]
   29940:	2b00      	cmp	r3, #0
   29942:	d197      	bne.n	29874 <clear_event_registrations+0x10>
   29944:	f8df 9080 	ldr.w	r9, [pc, #128]	; 299c8 <clear_event_registrations+0x164>
   29948:	22b1      	movs	r2, #177	; 0xb1
   2994a:	4649      	mov	r1, r9
   2994c:	481d      	ldr	r0, [pc, #116]	; (299c4 <clear_event_registrations+0x160>)
   2994e:	f002 fdee 	bl	2c52e <assert_print>
   29952:	21b1      	movs	r1, #177	; 0xb1
   29954:	4648      	mov	r0, r9
   29956:	f002 fde3 	bl	2c520 <assert_post_action>
   2995a:	e78b      	b.n	29874 <clear_event_registrations+0x10>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
   2995c:	6923      	ldr	r3, [r4, #16]
   2995e:	2b00      	cmp	r3, #0
   29960:	d188      	bne.n	29874 <clear_event_registrations+0x10>
   29962:	f8df 9064 	ldr.w	r9, [pc, #100]	; 299c8 <clear_event_registrations+0x164>
   29966:	22b5      	movs	r2, #181	; 0xb5
   29968:	4649      	mov	r1, r9
   2996a:	4816      	ldr	r0, [pc, #88]	; (299c4 <clear_event_registrations+0x160>)
   2996c:	f002 fddf 	bl	2c52e <assert_print>
   29970:	21b5      	movs	r1, #181	; 0xb5
   29972:	4648      	mov	r0, r9
   29974:	f002 fdd4 	bl	2c520 <assert_post_action>
   29978:	e77c      	b.n	29874 <clear_event_registrations+0x10>
		__ASSERT(false, "invalid event type\n");
   2997a:	4c13      	ldr	r4, [pc, #76]	; (299c8 <clear_event_registrations+0x164>)
   2997c:	22bc      	movs	r2, #188	; 0xbc
   2997e:	4621      	mov	r1, r4
   29980:	4810      	ldr	r0, [pc, #64]	; (299c4 <clear_event_registrations+0x160>)
   29982:	f002 fdd4 	bl	2c52e <assert_print>
   29986:	21bc      	movs	r1, #188	; 0xbc
   29988:	4620      	mov	r0, r4
   2998a:	f002 fdc9 	bl	2c520 <assert_post_action>
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   2998e:	e77b      	b.n	29888 <clear_event_registrations+0x24>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29990:	4c0e      	ldr	r4, [pc, #56]	; (299cc <clear_event_registrations+0x168>)
   29992:	22b9      	movs	r2, #185	; 0xb9
   29994:	4621      	mov	r1, r4
   29996:	480b      	ldr	r0, [pc, #44]	; (299c4 <clear_event_registrations+0x160>)
   29998:	f002 fdc9 	bl	2c52e <assert_print>
   2999c:	21b9      	movs	r1, #185	; 0xb9
   2999e:	4620      	mov	r0, r4
   299a0:	f002 fdbe 	bl	2c520 <assert_post_action>
   299a4:	e775      	b.n	29892 <clear_event_registrations+0x2e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   299a6:	4c09      	ldr	r4, [pc, #36]	; (299cc <clear_event_registrations+0x168>)
   299a8:	228e      	movs	r2, #142	; 0x8e
   299aa:	4621      	mov	r1, r4
   299ac:	4805      	ldr	r0, [pc, #20]	; (299c4 <clear_event_registrations+0x160>)
   299ae:	f002 fdbe 	bl	2c52e <assert_print>
   299b2:	218e      	movs	r1, #142	; 0x8e
   299b4:	4620      	mov	r0, r4
   299b6:	f002 fdb3 	bl	2c520 <assert_post_action>
   299ba:	e77b      	b.n	298b4 <clear_event_registrations+0x50>
		k_spin_unlock(&lock, key);
		key = k_spin_lock(&lock);
	}
}
   299bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   299c0:	20004704 	.word	0x20004704
   299c4:	00031600 	.word	0x00031600
   299c8:	0003bf38 	.word	0x0003bf38
   299cc:	000390f0 	.word	0x000390f0

000299d0 <signal_poller>:

	return events_registered;
}

static int signal_poller(struct k_poll_event *event, uint32_t state)
{
   299d0:	b570      	push	{r4, r5, r6, lr}
   299d2:	460d      	mov	r5, r1
	struct k_thread *thread = poller_thread(event->poller);
   299d4:	6880      	ldr	r0, [r0, #8]
   299d6:	f007 f949 	bl	30c6c <poller_thread>

	__ASSERT(thread != NULL, "poller should have a thread\n");
   299da:	4604      	mov	r4, r0
   299dc:	b1d8      	cbz	r0, 29a16 <signal_poller+0x46>
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
   299de:	7b63      	ldrb	r3, [r4, #13]

	if (!z_is_thread_pending(thread)) {
   299e0:	f013 0f02 	tst.w	r3, #2
   299e4:	d030      	beq.n	29a48 <signal_poller+0x78>
	return thread->base.timeout.dticks == _EXPIRED;
   299e6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   299e8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
		return 0;
	}

	if (z_is_thread_timeout_expired(thread)) {
   299ea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   299ee:	bf08      	it	eq
   299f0:	f112 0f02 	cmneq.w	r2, #2
   299f4:	d02a      	beq.n	29a4c <signal_poller+0x7c>
		return -EAGAIN;
	}

	z_unpend_thread(thread);
   299f6:	4620      	mov	r0, r4
   299f8:	f7fe fa86 	bl	27f08 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   299fc:	2d08      	cmp	r5, #8
   299fe:	d015      	beq.n	29a2c <signal_poller+0x5c>
   29a00:	2300      	movs	r3, #0
   29a02:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
	uint8_t state = thread->base.thread_state;
   29a06:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   29a08:	f013 0f1f 	tst.w	r3, #31
   29a0c:	d113      	bne.n	29a36 <signal_poller+0x66>
	return node->next != NULL;
   29a0e:	69a3      	ldr	r3, [r4, #24]
   29a10:	b17b      	cbz	r3, 29a32 <signal_poller+0x62>
   29a12:	2300      	movs	r3, #0
   29a14:	e010      	b.n	29a38 <signal_poller+0x68>
	__ASSERT(thread != NULL, "poller should have a thread\n");
   29a16:	4e0f      	ldr	r6, [pc, #60]	; (29a54 <signal_poller+0x84>)
   29a18:	22f9      	movs	r2, #249	; 0xf9
   29a1a:	4631      	mov	r1, r6
   29a1c:	480e      	ldr	r0, [pc, #56]	; (29a58 <signal_poller+0x88>)
   29a1e:	f002 fd86 	bl	2c52e <assert_print>
   29a22:	21f9      	movs	r1, #249	; 0xf9
   29a24:	4630      	mov	r0, r6
   29a26:	f002 fd7b 	bl	2c520 <assert_post_action>
   29a2a:	e7d8      	b.n	299de <signal_poller+0xe>
	arch_thread_return_value_set(thread,
   29a2c:	f06f 0303 	mvn.w	r3, #3
   29a30:	e7e7      	b.n	29a02 <signal_poller+0x32>
   29a32:	2301      	movs	r3, #1
   29a34:	e000      	b.n	29a38 <signal_poller+0x68>
   29a36:	2300      	movs	r3, #0
		state == K_POLL_STATE_CANCELLED ? -EINTR : 0);

	if (!z_is_thread_ready(thread)) {
   29a38:	b90b      	cbnz	r3, 29a3e <signal_poller+0x6e>
		return 0;
   29a3a:	2000      	movs	r0, #0
   29a3c:	e005      	b.n	29a4a <signal_poller+0x7a>
	}

	z_ready_thread(thread);
   29a3e:	4620      	mov	r0, r4
   29a40:	f7fe fc38 	bl	282b4 <z_ready_thread>

	return 0;
   29a44:	2000      	movs	r0, #0
   29a46:	e000      	b.n	29a4a <signal_poller+0x7a>
		return 0;
   29a48:	2000      	movs	r0, #0
}
   29a4a:	bd70      	pop	{r4, r5, r6, pc}
		return -EAGAIN;
   29a4c:	f06f 000a 	mvn.w	r0, #10
   29a50:	e7fb      	b.n	29a4a <signal_poller+0x7a>
   29a52:	bf00      	nop
   29a54:	0003bf38 	.word	0x0003bf38
   29a58:	00031600 	.word	0x00031600

00029a5c <register_event>:
{
   29a5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29a60:	4604      	mov	r4, r0
   29a62:	460d      	mov	r5, r1
	switch (event->type) {
   29a64:	7b43      	ldrb	r3, [r0, #13]
   29a66:	f003 031f 	and.w	r3, r3, #31
   29a6a:	2b08      	cmp	r3, #8
   29a6c:	f200 813c 	bhi.w	29ce8 <register_event+0x28c>
   29a70:	e8df f013 	tbh	[pc, r3, lsl #1]
   29a74:	00a30144 	.word	0x00a30144
   29a78:	013a0009 	.word	0x013a0009
   29a7c:	013a0056 	.word	0x013a0056
   29a80:	013a013a 	.word	0x013a013a
   29a84:	00ed      	.short	0x00ed
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   29a86:	6903      	ldr	r3, [r0, #16]
   29a88:	2b00      	cmp	r3, #0
   29a8a:	d030      	beq.n	29aee <register_event+0x92>
		add_event(&event->sem->poll_events, event, poller);
   29a8c:	6927      	ldr	r7, [r4, #16]
   29a8e:	f107 0610 	add.w	r6, r7, #16
	return list->head == list;
   29a92:	693b      	ldr	r3, [r7, #16]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   29a94:	429e      	cmp	r6, r3
   29a96:	d035      	beq.n	29b04 <register_event+0xa8>
   29a98:	6873      	ldr	r3, [r6, #4]
	if ((pending == NULL) ||
   29a9a:	2b00      	cmp	r3, #0
   29a9c:	d032      	beq.n	29b04 <register_event+0xa8>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   29a9e:	6898      	ldr	r0, [r3, #8]
   29aa0:	f007 f8e4 	bl	30c6c <poller_thread>
   29aa4:	4681      	mov	r9, r0
   29aa6:	4628      	mov	r0, r5
   29aa8:	f007 f8e0 	bl	30c6c <poller_thread>
   29aac:	4680      	mov	r8, r0
   29aae:	4601      	mov	r1, r0
   29ab0:	4648      	mov	r0, r9
   29ab2:	f007 f829 	bl	30b08 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   29ab6:	2800      	cmp	r0, #0
   29ab8:	dc24      	bgt.n	29b04 <register_event+0xa8>
	return list->head == list;
   29aba:	693f      	ldr	r7, [r7, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29abc:	42be      	cmp	r6, r7
   29abe:	d02d      	beq.n	29b1c <register_event+0xc0>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29ac0:	b17f      	cbz	r7, 29ae2 <register_event+0x86>
		if (z_sched_prio_cmp(poller_thread(poller),
   29ac2:	68b8      	ldr	r0, [r7, #8]
   29ac4:	f007 f8d2 	bl	30c6c <poller_thread>
   29ac8:	4601      	mov	r1, r0
   29aca:	4640      	mov	r0, r8
   29acc:	f007 f81c 	bl	30b08 <z_sched_prio_cmp>
   29ad0:	2800      	cmp	r0, #0
   29ad2:	dc1d      	bgt.n	29b10 <register_event+0xb4>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   29ad4:	b12f      	cbz	r7, 29ae2 <register_event+0x86>
	return (node == list->tail) ? NULL : node->next;
   29ad6:	6873      	ldr	r3, [r6, #4]
   29ad8:	429f      	cmp	r7, r3
   29ada:	d002      	beq.n	29ae2 <register_event+0x86>
   29adc:	683f      	ldr	r7, [r7, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29ade:	2f00      	cmp	r7, #0
   29ae0:	d1ee      	bne.n	29ac0 <register_event+0x64>
	sys_dnode_t *const tail = list->tail;
   29ae2:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29ae4:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29ae6:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29ae8:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29aea:	6074      	str	r4, [r6, #4]
}
   29aec:	e106      	b.n	29cfc <register_event+0x2a0>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   29aee:	4e85      	ldr	r6, [pc, #532]	; (29d04 <register_event+0x2a8>)
   29af0:	2286      	movs	r2, #134	; 0x86
   29af2:	4631      	mov	r1, r6
   29af4:	4884      	ldr	r0, [pc, #528]	; (29d08 <register_event+0x2ac>)
   29af6:	f002 fd1a 	bl	2c52e <assert_print>
   29afa:	2186      	movs	r1, #134	; 0x86
   29afc:	4630      	mov	r0, r6
   29afe:	f002 fd0f 	bl	2c520 <assert_post_action>
   29b02:	e7c3      	b.n	29a8c <register_event+0x30>
	sys_dnode_t *const tail = list->tail;
   29b04:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29b06:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29b08:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29b0a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29b0c:	6074      	str	r4, [r6, #4]
		return;
   29b0e:	e0f5      	b.n	29cfc <register_event+0x2a0>
	sys_dnode_t *const prev = successor->prev;
   29b10:	687b      	ldr	r3, [r7, #4]
	node->prev = prev;
   29b12:	6063      	str	r3, [r4, #4]
	node->next = successor;
   29b14:	6027      	str	r7, [r4, #0]
	prev->next = node;
   29b16:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   29b18:	607c      	str	r4, [r7, #4]
			return;
   29b1a:	e0ef      	b.n	29cfc <register_event+0x2a0>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29b1c:	2700      	movs	r7, #0
   29b1e:	e7cf      	b.n	29ac0 <register_event+0x64>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   29b20:	6903      	ldr	r3, [r0, #16]
   29b22:	2b00      	cmp	r3, #0
   29b24:	d030      	beq.n	29b88 <register_event+0x12c>
		add_event(&event->queue->poll_events, event, poller);
   29b26:	6927      	ldr	r7, [r4, #16]
   29b28:	f107 0614 	add.w	r6, r7, #20
	return list->head == list;
   29b2c:	697b      	ldr	r3, [r7, #20]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   29b2e:	429e      	cmp	r6, r3
   29b30:	d035      	beq.n	29b9e <register_event+0x142>
   29b32:	6873      	ldr	r3, [r6, #4]
	if ((pending == NULL) ||
   29b34:	2b00      	cmp	r3, #0
   29b36:	d032      	beq.n	29b9e <register_event+0x142>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   29b38:	6898      	ldr	r0, [r3, #8]
   29b3a:	f007 f897 	bl	30c6c <poller_thread>
   29b3e:	4681      	mov	r9, r0
   29b40:	4628      	mov	r0, r5
   29b42:	f007 f893 	bl	30c6c <poller_thread>
   29b46:	4680      	mov	r8, r0
   29b48:	4601      	mov	r1, r0
   29b4a:	4648      	mov	r0, r9
   29b4c:	f006 ffdc 	bl	30b08 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   29b50:	2800      	cmp	r0, #0
   29b52:	dc24      	bgt.n	29b9e <register_event+0x142>
	return list->head == list;
   29b54:	697f      	ldr	r7, [r7, #20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29b56:	42be      	cmp	r6, r7
   29b58:	d02d      	beq.n	29bb6 <register_event+0x15a>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29b5a:	b17f      	cbz	r7, 29b7c <register_event+0x120>
		if (z_sched_prio_cmp(poller_thread(poller),
   29b5c:	68b8      	ldr	r0, [r7, #8]
   29b5e:	f007 f885 	bl	30c6c <poller_thread>
   29b62:	4601      	mov	r1, r0
   29b64:	4640      	mov	r0, r8
   29b66:	f006 ffcf 	bl	30b08 <z_sched_prio_cmp>
   29b6a:	2800      	cmp	r0, #0
   29b6c:	dc1d      	bgt.n	29baa <register_event+0x14e>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   29b6e:	b12f      	cbz	r7, 29b7c <register_event+0x120>
	return (node == list->tail) ? NULL : node->next;
   29b70:	6873      	ldr	r3, [r6, #4]
   29b72:	429f      	cmp	r7, r3
   29b74:	d002      	beq.n	29b7c <register_event+0x120>
   29b76:	683f      	ldr	r7, [r7, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29b78:	2f00      	cmp	r7, #0
   29b7a:	d1ee      	bne.n	29b5a <register_event+0xfe>
	sys_dnode_t *const tail = list->tail;
   29b7c:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29b7e:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29b80:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29b82:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29b84:	6074      	str	r4, [r6, #4]
}
   29b86:	e0b9      	b.n	29cfc <register_event+0x2a0>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   29b88:	4e5e      	ldr	r6, [pc, #376]	; (29d04 <register_event+0x2a8>)
   29b8a:	228a      	movs	r2, #138	; 0x8a
   29b8c:	4631      	mov	r1, r6
   29b8e:	485e      	ldr	r0, [pc, #376]	; (29d08 <register_event+0x2ac>)
   29b90:	f002 fccd 	bl	2c52e <assert_print>
   29b94:	218a      	movs	r1, #138	; 0x8a
   29b96:	4630      	mov	r0, r6
   29b98:	f002 fcc2 	bl	2c520 <assert_post_action>
   29b9c:	e7c3      	b.n	29b26 <register_event+0xca>
	sys_dnode_t *const tail = list->tail;
   29b9e:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29ba0:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29ba2:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29ba4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29ba6:	6074      	str	r4, [r6, #4]
		return;
   29ba8:	e0a8      	b.n	29cfc <register_event+0x2a0>
	sys_dnode_t *const prev = successor->prev;
   29baa:	687b      	ldr	r3, [r7, #4]
	node->prev = prev;
   29bac:	6063      	str	r3, [r4, #4]
	node->next = successor;
   29bae:	6027      	str	r7, [r4, #0]
	prev->next = node;
   29bb0:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   29bb2:	607c      	str	r4, [r7, #4]
			return;
   29bb4:	e0a2      	b.n	29cfc <register_event+0x2a0>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29bb6:	2700      	movs	r7, #0
   29bb8:	e7cf      	b.n	29b5a <register_event+0xfe>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   29bba:	6903      	ldr	r3, [r0, #16]
   29bbc:	b373      	cbz	r3, 29c1c <register_event+0x1c0>
		add_event(&event->signal->poll_events, event, poller);
   29bbe:	6926      	ldr	r6, [r4, #16]
	return list->head == list;
   29bc0:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   29bc2:	429e      	cmp	r6, r3
   29bc4:	d035      	beq.n	29c32 <register_event+0x1d6>
   29bc6:	6873      	ldr	r3, [r6, #4]
	if ((pending == NULL) ||
   29bc8:	2b00      	cmp	r3, #0
   29bca:	d032      	beq.n	29c32 <register_event+0x1d6>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   29bcc:	6898      	ldr	r0, [r3, #8]
   29bce:	f007 f84d 	bl	30c6c <poller_thread>
   29bd2:	4607      	mov	r7, r0
   29bd4:	4628      	mov	r0, r5
   29bd6:	f007 f849 	bl	30c6c <poller_thread>
   29bda:	4680      	mov	r8, r0
   29bdc:	4601      	mov	r1, r0
   29bde:	4638      	mov	r0, r7
   29be0:	f006 ff92 	bl	30b08 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   29be4:	2800      	cmp	r0, #0
   29be6:	dc24      	bgt.n	29c32 <register_event+0x1d6>
	return list->head == list;
   29be8:	6837      	ldr	r7, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29bea:	42be      	cmp	r6, r7
   29bec:	d02d      	beq.n	29c4a <register_event+0x1ee>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29bee:	b17f      	cbz	r7, 29c10 <register_event+0x1b4>
		if (z_sched_prio_cmp(poller_thread(poller),
   29bf0:	68b8      	ldr	r0, [r7, #8]
   29bf2:	f007 f83b 	bl	30c6c <poller_thread>
   29bf6:	4601      	mov	r1, r0
   29bf8:	4640      	mov	r0, r8
   29bfa:	f006 ff85 	bl	30b08 <z_sched_prio_cmp>
   29bfe:	2800      	cmp	r0, #0
   29c00:	dc1d      	bgt.n	29c3e <register_event+0x1e2>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   29c02:	b12f      	cbz	r7, 29c10 <register_event+0x1b4>
	return (node == list->tail) ? NULL : node->next;
   29c04:	6873      	ldr	r3, [r6, #4]
   29c06:	429f      	cmp	r7, r3
   29c08:	d002      	beq.n	29c10 <register_event+0x1b4>
   29c0a:	683f      	ldr	r7, [r7, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29c0c:	2f00      	cmp	r7, #0
   29c0e:	d1ee      	bne.n	29bee <register_event+0x192>
	sys_dnode_t *const tail = list->tail;
   29c10:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29c12:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29c14:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29c16:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29c18:	6074      	str	r4, [r6, #4]
}
   29c1a:	e06f      	b.n	29cfc <register_event+0x2a0>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   29c1c:	4e39      	ldr	r6, [pc, #228]	; (29d04 <register_event+0x2a8>)
   29c1e:	228e      	movs	r2, #142	; 0x8e
   29c20:	4631      	mov	r1, r6
   29c22:	4839      	ldr	r0, [pc, #228]	; (29d08 <register_event+0x2ac>)
   29c24:	f002 fc83 	bl	2c52e <assert_print>
   29c28:	218e      	movs	r1, #142	; 0x8e
   29c2a:	4630      	mov	r0, r6
   29c2c:	f002 fc78 	bl	2c520 <assert_post_action>
   29c30:	e7c5      	b.n	29bbe <register_event+0x162>
	sys_dnode_t *const tail = list->tail;
   29c32:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29c34:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29c36:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29c38:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29c3a:	6074      	str	r4, [r6, #4]
		return;
   29c3c:	e05e      	b.n	29cfc <register_event+0x2a0>
	sys_dnode_t *const prev = successor->prev;
   29c3e:	687b      	ldr	r3, [r7, #4]
	node->prev = prev;
   29c40:	6063      	str	r3, [r4, #4]
	node->next = successor;
   29c42:	6027      	str	r7, [r4, #0]
	prev->next = node;
   29c44:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   29c46:	607c      	str	r4, [r7, #4]
			return;
   29c48:	e058      	b.n	29cfc <register_event+0x2a0>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29c4a:	2700      	movs	r7, #0
   29c4c:	e7cf      	b.n	29bee <register_event+0x192>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
   29c4e:	6903      	ldr	r3, [r0, #16]
   29c50:	2b00      	cmp	r3, #0
   29c52:	d030      	beq.n	29cb6 <register_event+0x25a>
		add_event(&event->msgq->poll_events, event, poller);
   29c54:	6927      	ldr	r7, [r4, #16]
   29c56:	f107 0628 	add.w	r6, r7, #40	; 0x28
	return list->head == list;
   29c5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   29c5c:	429e      	cmp	r6, r3
   29c5e:	d035      	beq.n	29ccc <register_event+0x270>
   29c60:	6873      	ldr	r3, [r6, #4]
	if ((pending == NULL) ||
   29c62:	2b00      	cmp	r3, #0
   29c64:	d032      	beq.n	29ccc <register_event+0x270>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   29c66:	6898      	ldr	r0, [r3, #8]
   29c68:	f007 f800 	bl	30c6c <poller_thread>
   29c6c:	4681      	mov	r9, r0
   29c6e:	4628      	mov	r0, r5
   29c70:	f006 fffc 	bl	30c6c <poller_thread>
   29c74:	4680      	mov	r8, r0
   29c76:	4601      	mov	r1, r0
   29c78:	4648      	mov	r0, r9
   29c7a:	f006 ff45 	bl	30b08 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   29c7e:	2800      	cmp	r0, #0
   29c80:	dc24      	bgt.n	29ccc <register_event+0x270>
	return list->head == list;
   29c82:	6abf      	ldr	r7, [r7, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29c84:	42be      	cmp	r6, r7
   29c86:	d02d      	beq.n	29ce4 <register_event+0x288>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29c88:	b17f      	cbz	r7, 29caa <register_event+0x24e>
		if (z_sched_prio_cmp(poller_thread(poller),
   29c8a:	68b8      	ldr	r0, [r7, #8]
   29c8c:	f006 ffee 	bl	30c6c <poller_thread>
   29c90:	4601      	mov	r1, r0
   29c92:	4640      	mov	r0, r8
   29c94:	f006 ff38 	bl	30b08 <z_sched_prio_cmp>
   29c98:	2800      	cmp	r0, #0
   29c9a:	dc1d      	bgt.n	29cd8 <register_event+0x27c>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   29c9c:	b12f      	cbz	r7, 29caa <register_event+0x24e>
	return (node == list->tail) ? NULL : node->next;
   29c9e:	6873      	ldr	r3, [r6, #4]
   29ca0:	429f      	cmp	r7, r3
   29ca2:	d002      	beq.n	29caa <register_event+0x24e>
   29ca4:	683f      	ldr	r7, [r7, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29ca6:	2f00      	cmp	r7, #0
   29ca8:	d1ee      	bne.n	29c88 <register_event+0x22c>
	sys_dnode_t *const tail = list->tail;
   29caa:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29cac:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29cae:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29cb0:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29cb2:	6074      	str	r4, [r6, #4]
}
   29cb4:	e022      	b.n	29cfc <register_event+0x2a0>
		__ASSERT(event->msgq != NULL, "invalid message queue\n");
   29cb6:	4e13      	ldr	r6, [pc, #76]	; (29d04 <register_event+0x2a8>)
   29cb8:	2292      	movs	r2, #146	; 0x92
   29cba:	4631      	mov	r1, r6
   29cbc:	4812      	ldr	r0, [pc, #72]	; (29d08 <register_event+0x2ac>)
   29cbe:	f002 fc36 	bl	2c52e <assert_print>
   29cc2:	2192      	movs	r1, #146	; 0x92
   29cc4:	4630      	mov	r0, r6
   29cc6:	f002 fc2b 	bl	2c520 <assert_post_action>
   29cca:	e7c3      	b.n	29c54 <register_event+0x1f8>
	sys_dnode_t *const tail = list->tail;
   29ccc:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   29cce:	6026      	str	r6, [r4, #0]
	node->prev = tail;
   29cd0:	6063      	str	r3, [r4, #4]
	tail->next = node;
   29cd2:	601c      	str	r4, [r3, #0]
	list->tail = node;
   29cd4:	6074      	str	r4, [r6, #4]
		return;
   29cd6:	e011      	b.n	29cfc <register_event+0x2a0>
	sys_dnode_t *const prev = successor->prev;
   29cd8:	687b      	ldr	r3, [r7, #4]
	node->prev = prev;
   29cda:	6063      	str	r3, [r4, #4]
	node->next = successor;
   29cdc:	6027      	str	r7, [r4, #0]
	prev->next = node;
   29cde:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   29ce0:	607c      	str	r4, [r7, #4]
			return;
   29ce2:	e00b      	b.n	29cfc <register_event+0x2a0>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   29ce4:	2700      	movs	r7, #0
   29ce6:	e7cf      	b.n	29c88 <register_event+0x22c>
		__ASSERT(false, "invalid event type\n");
   29ce8:	4e06      	ldr	r6, [pc, #24]	; (29d04 <register_event+0x2a8>)
   29cea:	2299      	movs	r2, #153	; 0x99
   29cec:	4631      	mov	r1, r6
   29cee:	4806      	ldr	r0, [pc, #24]	; (29d08 <register_event+0x2ac>)
   29cf0:	f002 fc1d 	bl	2c52e <assert_print>
   29cf4:	2199      	movs	r1, #153	; 0x99
   29cf6:	4630      	mov	r0, r6
   29cf8:	f002 fc12 	bl	2c520 <assert_post_action>
	event->poller = poller;
   29cfc:	60a5      	str	r5, [r4, #8]
}
   29cfe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   29d02:	bf00      	nop
   29d04:	0003bf38 	.word	0x0003bf38
   29d08:	00031600 	.word	0x00031600

00029d0c <register_events>:
{
   29d0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29d10:	b083      	sub	sp, #12
   29d12:	4680      	mov	r8, r0
   29d14:	460f      	mov	r7, r1
   29d16:	4691      	mov	r9, r2
   29d18:	469b      	mov	fp, r3
	for (int ii = 0; ii < num_events; ii++) {
   29d1a:	2500      	movs	r5, #0
	int events_registered = 0;
   29d1c:	9501      	str	r5, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
   29d1e:	e048      	b.n	29db2 <register_events+0xa6>
   29d20:	4c4c      	ldr	r4, [pc, #304]	; (29e54 <register_events+0x148>)
   29d22:	228e      	movs	r2, #142	; 0x8e
   29d24:	4621      	mov	r1, r4
   29d26:	484c      	ldr	r0, [pc, #304]	; (29e58 <register_events+0x14c>)
   29d28:	f002 fc01 	bl	2c52e <assert_print>
   29d2c:	218e      	movs	r1, #142	; 0x8e
   29d2e:	4620      	mov	r0, r4
   29d30:	f002 fbf6 	bl	2c520 <assert_post_action>
   29d34:	e04c      	b.n	29dd0 <register_events+0xc4>
		if (k_sem_count_get(event->sem) > 0U) {
   29d36:	6923      	ldr	r3, [r4, #16]
	return sem->count;
   29d38:	689b      	ldr	r3, [r3, #8]
   29d3a:	b313      	cbz	r3, 29d82 <register_events+0x76>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   29d3c:	f04f 0a02 	mov.w	sl, #2
			return true;
   29d40:	2301      	movs	r3, #1
   29d42:	e01e      	b.n	29d82 <register_events+0x76>
		if (!k_queue_is_empty(event->queue)) {
   29d44:	6923      	ldr	r3, [r4, #16]
	return list->head;
   29d46:	681b      	ldr	r3, [r3, #0]
   29d48:	b1db      	cbz	r3, 29d82 <register_events+0x76>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   29d4a:	f04f 0a04 	mov.w	sl, #4
			return true;
   29d4e:	2301      	movs	r3, #1
   29d50:	e017      	b.n	29d82 <register_events+0x76>
		if (event->signal->signaled != 0U) {
   29d52:	6923      	ldr	r3, [r4, #16]
   29d54:	689b      	ldr	r3, [r3, #8]
   29d56:	b1a3      	cbz	r3, 29d82 <register_events+0x76>
			*state = K_POLL_STATE_SIGNALED;
   29d58:	f04f 0a01 	mov.w	sl, #1
			return true;
   29d5c:	4653      	mov	r3, sl
   29d5e:	e010      	b.n	29d82 <register_events+0x76>
		if (event->msgq->used_msgs > 0) {
   29d60:	6923      	ldr	r3, [r4, #16]
   29d62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   29d64:	b16b      	cbz	r3, 29d82 <register_events+0x76>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
   29d66:	f04f 0a10 	mov.w	sl, #16
			return true;
   29d6a:	2301      	movs	r3, #1
   29d6c:	e009      	b.n	29d82 <register_events+0x76>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
   29d6e:	225c      	movs	r2, #92	; 0x5c
   29d70:	493a      	ldr	r1, [pc, #232]	; (29e5c <register_events+0x150>)
   29d72:	4839      	ldr	r0, [pc, #228]	; (29e58 <register_events+0x14c>)
   29d74:	f002 fbdb 	bl	2c52e <assert_print>
   29d78:	215c      	movs	r1, #92	; 0x5c
   29d7a:	4838      	ldr	r0, [pc, #224]	; (29e5c <register_events+0x150>)
   29d7c:	f002 fbd0 	bl	2c520 <assert_post_action>
	return false;
   29d80:	2300      	movs	r3, #0
		if (is_condition_met(&events[ii], &state)) {
   29d82:	2b00      	cmp	r3, #0
   29d84:	d048      	beq.n	29e18 <register_events+0x10c>
	event->poller = NULL;
   29d86:	2100      	movs	r1, #0
   29d88:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   29d8a:	68e3      	ldr	r3, [r4, #12]
   29d8c:	f3c3 3245 	ubfx	r2, r3, #13, #6
   29d90:	ea4a 0202 	orr.w	r2, sl, r2
   29d94:	f362 3352 	bfi	r3, r2, #13, #6
   29d98:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
   29d9a:	f889 1000 	strb.w	r1, [r9]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29d9e:	4830      	ldr	r0, [pc, #192]	; (29e60 <register_events+0x154>)
   29da0:	f7fc fc90 	bl	266c4 <z_spin_unlock_valid>
   29da4:	2800      	cmp	r0, #0
   29da6:	d046      	beq.n	29e36 <register_events+0x12a>
	__asm__ volatile(
   29da8:	f386 8811 	msr	BASEPRI, r6
   29dac:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   29db0:	3501      	adds	r5, #1
   29db2:	42bd      	cmp	r5, r7
   29db4:	da4a      	bge.n	29e4c <register_events+0x140>
	__asm__ volatile(
   29db6:	f04f 0340 	mov.w	r3, #64	; 0x40
   29dba:	f3ef 8611 	mrs	r6, BASEPRI
   29dbe:	f383 8812 	msr	BASEPRI_MAX, r3
   29dc2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29dc6:	4826      	ldr	r0, [pc, #152]	; (29e60 <register_events+0x154>)
   29dc8:	f7fc fc6c 	bl	266a4 <z_spin_lock_valid>
   29dcc:	2800      	cmp	r0, #0
   29dce:	d0a7      	beq.n	29d20 <register_events+0x14>
	z_spin_lock_set_owner(l);
   29dd0:	4823      	ldr	r0, [pc, #140]	; (29e60 <register_events+0x154>)
   29dd2:	f7fc fc87 	bl	266e4 <z_spin_lock_set_owner>
		if (is_condition_met(&events[ii], &state)) {
   29dd6:	eb05 0485 	add.w	r4, r5, r5, lsl #2
   29dda:	eb08 0484 	add.w	r4, r8, r4, lsl #2
	switch (event->type) {
   29dde:	7b63      	ldrb	r3, [r4, #13]
   29de0:	f003 031f 	and.w	r3, r3, #31
   29de4:	2b08      	cmp	r3, #8
   29de6:	d8c2      	bhi.n	29d6e <register_events+0x62>
   29de8:	a201      	add	r2, pc, #4	; (adr r2, 29df0 <register_events+0xe4>)
   29dea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   29dee:	bf00      	nop
   29df0:	00029e15 	.word	0x00029e15
   29df4:	00029d53 	.word	0x00029d53
   29df8:	00029d37 	.word	0x00029d37
   29dfc:	00029d6f 	.word	0x00029d6f
   29e00:	00029d45 	.word	0x00029d45
   29e04:	00029d6f 	.word	0x00029d6f
   29e08:	00029d6f 	.word	0x00029d6f
   29e0c:	00029d6f 	.word	0x00029d6f
   29e10:	00029d61 	.word	0x00029d61
   29e14:	2300      	movs	r3, #0
   29e16:	e7b4      	b.n	29d82 <register_events+0x76>
		} else if (!just_check && poller->is_polling) {
   29e18:	f1bb 0f00 	cmp.w	fp, #0
   29e1c:	d1bf      	bne.n	29d9e <register_events+0x92>
   29e1e:	f899 3000 	ldrb.w	r3, [r9]
   29e22:	2b00      	cmp	r3, #0
   29e24:	d0bb      	beq.n	29d9e <register_events+0x92>
			register_event(&events[ii], poller);
   29e26:	4649      	mov	r1, r9
   29e28:	4620      	mov	r0, r4
   29e2a:	f7ff fe17 	bl	29a5c <register_event>
			events_registered += 1;
   29e2e:	9b01      	ldr	r3, [sp, #4]
   29e30:	3301      	adds	r3, #1
   29e32:	9301      	str	r3, [sp, #4]
   29e34:	e7b3      	b.n	29d9e <register_events+0x92>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29e36:	4c07      	ldr	r4, [pc, #28]	; (29e54 <register_events+0x148>)
   29e38:	22b9      	movs	r2, #185	; 0xb9
   29e3a:	4621      	mov	r1, r4
   29e3c:	4806      	ldr	r0, [pc, #24]	; (29e58 <register_events+0x14c>)
   29e3e:	f002 fb76 	bl	2c52e <assert_print>
   29e42:	21b9      	movs	r1, #185	; 0xb9
   29e44:	4620      	mov	r0, r4
   29e46:	f002 fb6b 	bl	2c520 <assert_post_action>
   29e4a:	e7ad      	b.n	29da8 <register_events+0x9c>
}
   29e4c:	9801      	ldr	r0, [sp, #4]
   29e4e:	b003      	add	sp, #12
   29e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29e54:	000390f0 	.word	0x000390f0
   29e58:	00031600 	.word	0x00031600
   29e5c:	0003bf38 	.word	0x0003bf38
   29e60:	20004704 	.word	0x20004704

00029e64 <z_impl_k_poll>:

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   29e64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   29e68:	b082      	sub	sp, #8
   29e6a:	4604      	mov	r4, r0
   29e6c:	4688      	mov	r8, r1
   29e6e:	4617      	mov	r7, r2
   29e70:	461e      	mov	r6, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
   29e72:	4b70      	ldr	r3, [pc, #448]	; (2a034 <z_impl_k_poll+0x1d0>)
   29e74:	689d      	ldr	r5, [r3, #8]
   29e76:	f105 0960 	add.w	r9, r5, #96	; 0x60

	poller->is_polling = true;
   29e7a:	2301      	movs	r3, #1
   29e7c:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
	poller->mode = MODE_POLL;
   29e80:	f885 3061 	strb.w	r3, [r5, #97]	; 0x61
   29e84:	f3ef 8305 	mrs	r3, IPSR

	__ASSERT(!arch_is_in_isr(), "");
   29e88:	2b00      	cmp	r3, #0
   29e8a:	d156      	bne.n	29f3a <z_impl_k_poll+0xd6>
	__ASSERT(events != NULL, "NULL events\n");
   29e8c:	2c00      	cmp	r4, #0
   29e8e:	d062      	beq.n	29f56 <z_impl_k_poll+0xf2>
	__ASSERT(num_events >= 0, "<0 events\n");
   29e90:	f1b8 0f00 	cmp.w	r8, #0
   29e94:	db6d      	blt.n	29f72 <z_impl_k_poll+0x10e>

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
   29e96:	ea56 0307 	orrs.w	r3, r6, r7
   29e9a:	bf0c      	ite	eq
   29e9c:	2301      	moveq	r3, #1
   29e9e:	2300      	movne	r3, #0
   29ea0:	464a      	mov	r2, r9
   29ea2:	4641      	mov	r1, r8
   29ea4:	4620      	mov	r0, r4
   29ea6:	f7ff ff31 	bl	29d0c <register_events>
   29eaa:	4680      	mov	r8, r0
   29eac:	f04f 0340 	mov.w	r3, #64	; 0x40
   29eb0:	f3ef 8a11 	mrs	sl, BASEPRI
   29eb4:	f383 8812 	msr	BASEPRI_MAX, r3
   29eb8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29ebc:	485e      	ldr	r0, [pc, #376]	; (2a038 <z_impl_k_poll+0x1d4>)
   29ebe:	f7fc fbf1 	bl	266a4 <z_spin_lock_valid>
   29ec2:	2800      	cmp	r0, #0
   29ec4:	d063      	beq.n	29f8e <z_impl_k_poll+0x12a>
	z_spin_lock_set_owner(l);
   29ec6:	485c      	ldr	r0, [pc, #368]	; (2a038 <z_impl_k_poll+0x1d4>)
   29ec8:	f7fc fc0c 	bl	266e4 <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
   29ecc:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
   29ed0:	2b00      	cmp	r3, #0
   29ed2:	d068      	beq.n	29fa6 <z_impl_k_poll+0x142>
		SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, 0);

		return 0;
	}

	poller->is_polling = false;
   29ed4:	2300      	movs	r3, #0
   29ed6:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   29eda:	ea56 0307 	orrs.w	r3, r6, r7
   29ede:	d07c      	beq.n	29fda <z_impl_k_poll+0x176>
		return -EAGAIN;
	}

	static _wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);

	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   29ee0:	f8df 9154 	ldr.w	r9, [pc, #340]	; 2a038 <z_impl_k_poll+0x1d4>
   29ee4:	9700      	str	r7, [sp, #0]
   29ee6:	9601      	str	r6, [sp, #4]
   29ee8:	4a54      	ldr	r2, [pc, #336]	; (2a03c <z_impl_k_poll+0x1d8>)
   29eea:	4651      	mov	r1, sl
   29eec:	4648      	mov	r0, r9
   29eee:	f7fe fb71 	bl	285d4 <z_pend_curr>
   29ef2:	4605      	mov	r5, r0
   29ef4:	f04f 0340 	mov.w	r3, #64	; 0x40
   29ef8:	f3ef 8611 	mrs	r6, BASEPRI
   29efc:	f383 8812 	msr	BASEPRI_MAX, r3
   29f00:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29f04:	4648      	mov	r0, r9
   29f06:	f7fc fbcd 	bl	266a4 <z_spin_lock_valid>
   29f0a:	2800      	cmp	r0, #0
   29f0c:	d07b      	beq.n	2a006 <z_impl_k_poll+0x1a2>
	z_spin_lock_set_owner(l);
   29f0e:	4f4a      	ldr	r7, [pc, #296]	; (2a038 <z_impl_k_poll+0x1d4>)
   29f10:	4638      	mov	r0, r7
   29f12:	f7fc fbe7 	bl	266e4 <z_spin_lock_set_owner>
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
   29f16:	4632      	mov	r2, r6
   29f18:	4641      	mov	r1, r8
   29f1a:	4620      	mov	r0, r4
   29f1c:	f7ff fca2 	bl	29864 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29f20:	4638      	mov	r0, r7
   29f22:	f7fc fbcf 	bl	266c4 <z_spin_unlock_valid>
   29f26:	2800      	cmp	r0, #0
   29f28:	d078      	beq.n	2a01c <z_impl_k_poll+0x1b8>
	__asm__ volatile(
   29f2a:	f386 8811 	msr	BASEPRI, r6
   29f2e:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
   29f32:	4628      	mov	r0, r5
   29f34:	b002      	add	sp, #8
   29f36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	__ASSERT(!arch_is_in_isr(), "");
   29f3a:	f8df a10c 	ldr.w	sl, [pc, #268]	; 2a048 <z_impl_k_poll+0x1e4>
   29f3e:	f44f 728d 	mov.w	r2, #282	; 0x11a
   29f42:	4651      	mov	r1, sl
   29f44:	483e      	ldr	r0, [pc, #248]	; (2a040 <z_impl_k_poll+0x1dc>)
   29f46:	f002 faf2 	bl	2c52e <assert_print>
   29f4a:	f44f 718d 	mov.w	r1, #282	; 0x11a
   29f4e:	4650      	mov	r0, sl
   29f50:	f002 fae6 	bl	2c520 <assert_post_action>
   29f54:	e79a      	b.n	29e8c <z_impl_k_poll+0x28>
	__ASSERT(events != NULL, "NULL events\n");
   29f56:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 2a048 <z_impl_k_poll+0x1e4>
   29f5a:	f240 121b 	movw	r2, #283	; 0x11b
   29f5e:	4651      	mov	r1, sl
   29f60:	4837      	ldr	r0, [pc, #220]	; (2a040 <z_impl_k_poll+0x1dc>)
   29f62:	f002 fae4 	bl	2c52e <assert_print>
   29f66:	f240 111b 	movw	r1, #283	; 0x11b
   29f6a:	4650      	mov	r0, sl
   29f6c:	f002 fad8 	bl	2c520 <assert_post_action>
   29f70:	e78e      	b.n	29e90 <z_impl_k_poll+0x2c>
	__ASSERT(num_events >= 0, "<0 events\n");
   29f72:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 2a048 <z_impl_k_poll+0x1e4>
   29f76:	f44f 728e 	mov.w	r2, #284	; 0x11c
   29f7a:	4651      	mov	r1, sl
   29f7c:	4830      	ldr	r0, [pc, #192]	; (2a040 <z_impl_k_poll+0x1dc>)
   29f7e:	f002 fad6 	bl	2c52e <assert_print>
   29f82:	f44f 718e 	mov.w	r1, #284	; 0x11c
   29f86:	4650      	mov	r0, sl
   29f88:	f002 faca 	bl	2c520 <assert_post_action>
   29f8c:	e783      	b.n	29e96 <z_impl_k_poll+0x32>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29f8e:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 2a044 <z_impl_k_poll+0x1e0>
   29f92:	228e      	movs	r2, #142	; 0x8e
   29f94:	4649      	mov	r1, r9
   29f96:	482a      	ldr	r0, [pc, #168]	; (2a040 <z_impl_k_poll+0x1dc>)
   29f98:	f002 fac9 	bl	2c52e <assert_print>
   29f9c:	218e      	movs	r1, #142	; 0x8e
   29f9e:	4648      	mov	r0, r9
   29fa0:	f002 fabe 	bl	2c520 <assert_post_action>
   29fa4:	e78f      	b.n	29ec6 <z_impl_k_poll+0x62>
		clear_event_registrations(events, events_registered, key);
   29fa6:	4652      	mov	r2, sl
   29fa8:	4641      	mov	r1, r8
   29faa:	4620      	mov	r0, r4
   29fac:	f7ff fc5a 	bl	29864 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29fb0:	4821      	ldr	r0, [pc, #132]	; (2a038 <z_impl_k_poll+0x1d4>)
   29fb2:	f7fc fb87 	bl	266c4 <z_spin_unlock_valid>
   29fb6:	b128      	cbz	r0, 29fc4 <z_impl_k_poll+0x160>
   29fb8:	f38a 8811 	msr	BASEPRI, sl
   29fbc:	f3bf 8f6f 	isb	sy
		return 0;
   29fc0:	2500      	movs	r5, #0
   29fc2:	e7b6      	b.n	29f32 <z_impl_k_poll+0xce>
   29fc4:	4c1f      	ldr	r4, [pc, #124]	; (2a044 <z_impl_k_poll+0x1e0>)
   29fc6:	22b9      	movs	r2, #185	; 0xb9
   29fc8:	4621      	mov	r1, r4
   29fca:	481d      	ldr	r0, [pc, #116]	; (2a040 <z_impl_k_poll+0x1dc>)
   29fcc:	f002 faaf 	bl	2c52e <assert_print>
   29fd0:	21b9      	movs	r1, #185	; 0xb9
   29fd2:	4620      	mov	r0, r4
   29fd4:	f002 faa4 	bl	2c520 <assert_post_action>
   29fd8:	e7ee      	b.n	29fb8 <z_impl_k_poll+0x154>
   29fda:	4817      	ldr	r0, [pc, #92]	; (2a038 <z_impl_k_poll+0x1d4>)
   29fdc:	f7fc fb72 	bl	266c4 <z_spin_unlock_valid>
   29fe0:	b130      	cbz	r0, 29ff0 <z_impl_k_poll+0x18c>
   29fe2:	f38a 8811 	msr	BASEPRI, sl
   29fe6:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   29fea:	f06f 050a 	mvn.w	r5, #10
   29fee:	e7a0      	b.n	29f32 <z_impl_k_poll+0xce>
   29ff0:	4c14      	ldr	r4, [pc, #80]	; (2a044 <z_impl_k_poll+0x1e0>)
   29ff2:	22b9      	movs	r2, #185	; 0xb9
   29ff4:	4621      	mov	r1, r4
   29ff6:	4812      	ldr	r0, [pc, #72]	; (2a040 <z_impl_k_poll+0x1dc>)
   29ff8:	f002 fa99 	bl	2c52e <assert_print>
   29ffc:	21b9      	movs	r1, #185	; 0xb9
   29ffe:	4620      	mov	r0, r4
   2a000:	f002 fa8e 	bl	2c520 <assert_post_action>
   2a004:	e7ed      	b.n	29fe2 <z_impl_k_poll+0x17e>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2a006:	4f0f      	ldr	r7, [pc, #60]	; (2a044 <z_impl_k_poll+0x1e0>)
   2a008:	228e      	movs	r2, #142	; 0x8e
   2a00a:	4639      	mov	r1, r7
   2a00c:	480c      	ldr	r0, [pc, #48]	; (2a040 <z_impl_k_poll+0x1dc>)
   2a00e:	f002 fa8e 	bl	2c52e <assert_print>
   2a012:	218e      	movs	r1, #142	; 0x8e
   2a014:	4638      	mov	r0, r7
   2a016:	f002 fa83 	bl	2c520 <assert_post_action>
   2a01a:	e778      	b.n	29f0e <z_impl_k_poll+0xaa>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2a01c:	4c09      	ldr	r4, [pc, #36]	; (2a044 <z_impl_k_poll+0x1e0>)
   2a01e:	22b9      	movs	r2, #185	; 0xb9
   2a020:	4621      	mov	r1, r4
   2a022:	4807      	ldr	r0, [pc, #28]	; (2a040 <z_impl_k_poll+0x1dc>)
   2a024:	f002 fa83 	bl	2c52e <assert_print>
   2a028:	21b9      	movs	r1, #185	; 0xb9
   2a02a:	4620      	mov	r0, r4
   2a02c:	f002 fa78 	bl	2c520 <assert_post_action>
   2a030:	e77b      	b.n	29f2a <z_impl_k_poll+0xc6>
   2a032:	bf00      	nop
   2a034:	200046a4 	.word	0x200046a4
   2a038:	20004704 	.word	0x20004704
   2a03c:	20000df4 	.word	0x20000df4
   2a040:	00031600 	.word	0x00031600
   2a044:	000390f0 	.word	0x000390f0
   2a048:	0003bf38 	.word	0x0003bf38

0002a04c <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
   2a04c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a04e:	4604      	mov	r4, r0
   2a050:	460d      	mov	r5, r1
	__asm__ volatile(
   2a052:	f04f 0340 	mov.w	r3, #64	; 0x40
   2a056:	f3ef 8611 	mrs	r6, BASEPRI
   2a05a:	f383 8812 	msr	BASEPRI_MAX, r3
   2a05e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2a062:	481f      	ldr	r0, [pc, #124]	; (2a0e0 <z_impl_k_poll_signal_raise+0x94>)
   2a064:	f7fc fb1e 	bl	266a4 <z_spin_lock_valid>
   2a068:	b1d0      	cbz	r0, 2a0a0 <z_impl_k_poll_signal_raise+0x54>
	z_spin_lock_set_owner(l);
   2a06a:	481d      	ldr	r0, [pc, #116]	; (2a0e0 <z_impl_k_poll_signal_raise+0x94>)
   2a06c:	f7fc fb3a 	bl	266e4 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
   2a070:	60e5      	str	r5, [r4, #12]
	sig->signaled = 1U;
   2a072:	2301      	movs	r3, #1
   2a074:	60a3      	str	r3, [r4, #8]
	return list->head == list;
   2a076:	6820      	ldr	r0, [r4, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   2a078:	4284      	cmp	r4, r0
   2a07a:	d01c      	beq.n	2a0b6 <z_impl_k_poll_signal_raise+0x6a>
	sys_dnode_t *const prev = node->prev;
   2a07c:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;
   2a07e:	6803      	ldr	r3, [r0, #0]
	prev->next = next;
   2a080:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   2a082:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2a084:	2300      	movs	r3, #0
   2a086:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   2a088:	6043      	str	r3, [r0, #4]

	poll_event = (struct k_poll_event *)sys_dlist_get(&sig->poll_events);
	if (poll_event == NULL) {
   2a08a:	b1a0      	cbz	r0, 2a0b6 <z_impl_k_poll_signal_raise+0x6a>
		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   2a08c:	2101      	movs	r1, #1
   2a08e:	f006 fe06 	bl	30c9e <signal_poll_event>
   2a092:	4604      	mov	r4, r0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
   2a094:	4631      	mov	r1, r6
   2a096:	4812      	ldr	r0, [pc, #72]	; (2a0e0 <z_impl_k_poll_signal_raise+0x94>)
   2a098:	f7fd fe78 	bl	27d8c <z_reschedule>
	return rc;
}
   2a09c:	4620      	mov	r0, r4
   2a09e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2a0a0:	4f10      	ldr	r7, [pc, #64]	; (2a0e4 <z_impl_k_poll_signal_raise+0x98>)
   2a0a2:	228e      	movs	r2, #142	; 0x8e
   2a0a4:	4639      	mov	r1, r7
   2a0a6:	4810      	ldr	r0, [pc, #64]	; (2a0e8 <z_impl_k_poll_signal_raise+0x9c>)
   2a0a8:	f002 fa41 	bl	2c52e <assert_print>
   2a0ac:	218e      	movs	r1, #142	; 0x8e
   2a0ae:	4638      	mov	r0, r7
   2a0b0:	f002 fa36 	bl	2c520 <assert_post_action>
   2a0b4:	e7d9      	b.n	2a06a <z_impl_k_poll_signal_raise+0x1e>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2a0b6:	480a      	ldr	r0, [pc, #40]	; (2a0e0 <z_impl_k_poll_signal_raise+0x94>)
   2a0b8:	f7fc fb04 	bl	266c4 <z_spin_unlock_valid>
   2a0bc:	b128      	cbz	r0, 2a0ca <z_impl_k_poll_signal_raise+0x7e>
	__asm__ volatile(
   2a0be:	f386 8811 	msr	BASEPRI, r6
   2a0c2:	f3bf 8f6f 	isb	sy
		return 0;
   2a0c6:	2400      	movs	r4, #0
   2a0c8:	e7e8      	b.n	2a09c <z_impl_k_poll_signal_raise+0x50>
   2a0ca:	4c06      	ldr	r4, [pc, #24]	; (2a0e4 <z_impl_k_poll_signal_raise+0x98>)
   2a0cc:	22b9      	movs	r2, #185	; 0xb9
   2a0ce:	4621      	mov	r1, r4
   2a0d0:	4805      	ldr	r0, [pc, #20]	; (2a0e8 <z_impl_k_poll_signal_raise+0x9c>)
   2a0d2:	f002 fa2c 	bl	2c52e <assert_print>
   2a0d6:	21b9      	movs	r1, #185	; 0xb9
   2a0d8:	4620      	mov	r0, r4
   2a0da:	f002 fa21 	bl	2c520 <assert_post_action>
   2a0de:	e7ee      	b.n	2a0be <z_impl_k_poll_signal_raise+0x72>
   2a0e0:	20004704 	.word	0x20004704
   2a0e4:	000390f0 	.word	0x000390f0
   2a0e8:	00031600 	.word	0x00031600

0002a0ec <k_event_post_internal>:
	return match != 0;
}

static void k_event_post_internal(struct k_event *event, uint32_t events,
				  uint32_t events_mask)
{
   2a0ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2a0f0:	4607      	mov	r7, r0
   2a0f2:	460c      	mov	r4, r1
   2a0f4:	4616      	mov	r6, r2
	k_spinlock_key_t  key;
	struct k_thread  *thread;
	unsigned int      wait_condition;
	struct k_thread  *head = NULL;

	key = k_spin_lock(&event->lock);
   2a0f6:	f100 080c 	add.w	r8, r0, #12
	__asm__ volatile(
   2a0fa:	f04f 0340 	mov.w	r3, #64	; 0x40
   2a0fe:	f3ef 8911 	mrs	r9, BASEPRI
   2a102:	f383 8812 	msr	BASEPRI_MAX, r3
   2a106:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2a10a:	4640      	mov	r0, r8
   2a10c:	f7fc faca 	bl	266a4 <z_spin_lock_valid>
   2a110:	b168      	cbz	r0, 2a12e <k_event_post_internal+0x42>
	z_spin_lock_set_owner(l);
   2a112:	4640      	mov	r0, r8
   2a114:	f7fc fae6 	bl	266e4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_event, post, event, events,
					events_mask);

	events = (event->events & ~events_mask) |
   2a118:	68bb      	ldr	r3, [r7, #8]
   2a11a:	405c      	eors	r4, r3
   2a11c:	4034      	ands	r4, r6
   2a11e:	ea83 0604 	eor.w	r6, r3, r4
		 (events & events_mask);
	event->events = events;
   2a122:	60be      	str	r6, [r7, #8]
	return list->head == list;
   2a124:	683c      	ldr	r4, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2a126:	42a7      	cmp	r7, r4
   2a128:	d01e      	beq.n	2a168 <k_event_post_internal+0x7c>
	 * 1. Create a linked list of threads to unpend.
	 * 2. Unpend each of the threads in the linked list
	 * 3. Ready each of the threads in the linked list
	 */

	_WAIT_Q_FOR_EACH(&event->wait_q, thread) {
   2a12a:	2500      	movs	r5, #0
   2a12c:	e00f      	b.n	2a14e <k_event_post_internal+0x62>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2a12e:	4d1a      	ldr	r5, [pc, #104]	; (2a198 <k_event_post_internal+0xac>)
   2a130:	228e      	movs	r2, #142	; 0x8e
   2a132:	4629      	mov	r1, r5
   2a134:	4819      	ldr	r0, [pc, #100]	; (2a19c <k_event_post_internal+0xb0>)
   2a136:	f002 f9fa 	bl	2c52e <assert_print>
   2a13a:	218e      	movs	r1, #142	; 0x8e
   2a13c:	4628      	mov	r0, r5
   2a13e:	f002 f9ef 	bl	2c520 <assert_post_action>
   2a142:	e7e6      	b.n	2a112 <k_event_post_internal+0x26>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2a144:	b11c      	cbz	r4, 2a14e <k_event_post_internal+0x62>
	return (node == list->tail) ? NULL : node->next;
   2a146:	687b      	ldr	r3, [r7, #4]
   2a148:	429c      	cmp	r4, r3
   2a14a:	d00f      	beq.n	2a16c <k_event_post_internal+0x80>
   2a14c:	6824      	ldr	r4, [r4, #0]
   2a14e:	b17c      	cbz	r4, 2a170 <k_event_post_internal+0x84>
		wait_condition = thread->event_options & K_EVENT_WAIT_MASK;
   2a150:	6ee2      	ldr	r2, [r4, #108]	; 0x6c

		if (are_wait_conditions_met(thread->events, events,
   2a152:	f002 0201 	and.w	r2, r2, #1
   2a156:	4631      	mov	r1, r6
   2a158:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   2a15a:	f006 fdda 	bl	30d12 <are_wait_conditions_met>
   2a15e:	2800      	cmp	r0, #0
   2a160:	d0f0      	beq.n	2a144 <k_event_post_internal+0x58>
			/*
			 * The wait conditions have been satisfied. Add this
			 * thread to the list of threads to unpend.
			 */

			thread->next_event_link = head;
   2a162:	6665      	str	r5, [r4, #100]	; 0x64
			head = thread;
   2a164:	4625      	mov	r5, r4
   2a166:	e7ed      	b.n	2a144 <k_event_post_internal+0x58>
	_WAIT_Q_FOR_EACH(&event->wait_q, thread) {
   2a168:	2400      	movs	r4, #0
   2a16a:	e7de      	b.n	2a12a <k_event_post_internal+0x3e>
   2a16c:	2400      	movs	r4, #0
   2a16e:	e7ee      	b.n	2a14e <k_event_post_internal+0x62>
		}


	}

	if (head != NULL) {
   2a170:	b165      	cbz	r5, 2a18c <k_event_post_internal+0xa0>
		thread = head;
		do {
			z_unpend_thread(thread);
   2a172:	4628      	mov	r0, r5
   2a174:	f7fd fec8 	bl	27f08 <z_unpend_thread>
   2a178:	2300      	movs	r3, #0
   2a17a:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
			arch_thread_return_value_set(thread, 0);
			thread->events = events;
   2a17e:	66ae      	str	r6, [r5, #104]	; 0x68
			z_ready_thread(thread);
   2a180:	4628      	mov	r0, r5
   2a182:	f7fe f897 	bl	282b4 <z_ready_thread>
			thread = thread->next_event_link;
   2a186:	6e6d      	ldr	r5, [r5, #100]	; 0x64
		} while (thread != NULL);
   2a188:	2d00      	cmp	r5, #0
   2a18a:	d1f2      	bne.n	2a172 <k_event_post_internal+0x86>
	}

	z_reschedule(&event->lock, key);
   2a18c:	4649      	mov	r1, r9
   2a18e:	4640      	mov	r0, r8
   2a190:	f7fd fdfc 	bl	27d8c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, post, event, events,
				       events_mask);
}
   2a194:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2a198:	000390f0 	.word	0x000390f0
   2a19c:	00031600 	.word	0x00031600

0002a1a0 <k_event_wait_internal>:
#include <syscalls/k_event_set_masked_mrsh.c>
#endif

static uint32_t k_event_wait_internal(struct k_event *event, uint32_t events,
				      unsigned int options, k_timeout_t timeout)
{
   2a1a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a1a4:	b085      	sub	sp, #20
   2a1a6:	4605      	mov	r5, r0
   2a1a8:	460c      	mov	r4, r1
   2a1aa:	4616      	mov	r6, r2
   2a1ac:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
   2a1b0:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
   2a1b2:	f3ef 8305 	mrs	r3, IPSR
	uint32_t  rv = 0;
	unsigned int  wait_condition;
	struct k_thread  *thread;

	__ASSERT(((arch_is_in_isr() == false) ||
   2a1b6:	b113      	cbz	r3, 2a1be <k_event_wait_internal+0x1e>
   2a1b8:	ea57 0308 	orrs.w	r3, r7, r8
   2a1bc:	d104      	bne.n	2a1c8 <k_event_wait_internal+0x28>
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_event, wait, event, events,
					options, timeout);

	if (events == 0) {
   2a1be:	b97c      	cbnz	r4, 2a1e0 <k_event_wait_internal+0x40>
out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, wait, event,
				       events, rv & events);

	return rv & events;
}
   2a1c0:	4620      	mov	r0, r4
   2a1c2:	b005      	add	sp, #20
   2a1c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT(((arch_is_in_isr() == false) ||
   2a1c8:	f8df 9104 	ldr.w	r9, [pc, #260]	; 2a2d0 <k_event_wait_internal+0x130>
   2a1cc:	22c8      	movs	r2, #200	; 0xc8
   2a1ce:	4649      	mov	r1, r9
   2a1d0:	483d      	ldr	r0, [pc, #244]	; (2a2c8 <k_event_wait_internal+0x128>)
   2a1d2:	f002 f9ac 	bl	2c52e <assert_print>
   2a1d6:	21c8      	movs	r1, #200	; 0xc8
   2a1d8:	4648      	mov	r0, r9
   2a1da:	f002 f9a1 	bl	2c520 <assert_post_action>
   2a1de:	e7ee      	b.n	2a1be <k_event_wait_internal+0x1e>
	wait_condition = options & K_EVENT_WAIT_MASK;
   2a1e0:	f006 0301 	and.w	r3, r6, #1
   2a1e4:	9303      	str	r3, [sp, #12]
	return z_impl_z_current_get();
   2a1e6:	f7fe fdfd 	bl	28de4 <z_impl_z_current_get>
   2a1ea:	9002      	str	r0, [sp, #8]
	k_spinlock_key_t  key = k_spin_lock(&event->lock);
   2a1ec:	f105 090c 	add.w	r9, r5, #12
   2a1f0:	f04f 0340 	mov.w	r3, #64	; 0x40
   2a1f4:	f3ef 8b11 	mrs	fp, BASEPRI
   2a1f8:	f383 8812 	msr	BASEPRI_MAX, r3
   2a1fc:	f3bf 8f6f 	isb	sy
   2a200:	4648      	mov	r0, r9
   2a202:	f7fc fa4f 	bl	266a4 <z_spin_lock_valid>
   2a206:	b318      	cbz	r0, 2a250 <k_event_wait_internal+0xb0>
	z_spin_lock_set_owner(l);
   2a208:	4648      	mov	r0, r9
   2a20a:	f7fc fa6b 	bl	266e4 <z_spin_lock_set_owner>
	if (options & K_EVENT_WAIT_RESET) {
   2a20e:	f016 0f02 	tst.w	r6, #2
   2a212:	d001      	beq.n	2a218 <k_event_wait_internal+0x78>
		event->events = 0;
   2a214:	2300      	movs	r3, #0
   2a216:	60ab      	str	r3, [r5, #8]
	if (are_wait_conditions_met(events, event->events, wait_condition)) {
   2a218:	f8d5 a008 	ldr.w	sl, [r5, #8]
   2a21c:	9a03      	ldr	r2, [sp, #12]
   2a21e:	4651      	mov	r1, sl
   2a220:	4620      	mov	r0, r4
   2a222:	f006 fd76 	bl	30d12 <are_wait_conditions_met>
   2a226:	b9f8      	cbnz	r0, 2a268 <k_event_wait_internal+0xc8>
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2a228:	ea57 0308 	orrs.w	r3, r7, r8
   2a22c:	d030      	beq.n	2a290 <k_event_wait_internal+0xf0>
	thread->events = events;
   2a22e:	9b02      	ldr	r3, [sp, #8]
   2a230:	669c      	str	r4, [r3, #104]	; 0x68
	thread->event_options = options;
   2a232:	66de      	str	r6, [r3, #108]	; 0x6c
	if (z_pend_curr(&event->lock, key, &event->wait_q, timeout) == 0) {
   2a234:	f8cd 8000 	str.w	r8, [sp]
   2a238:	9701      	str	r7, [sp, #4]
   2a23a:	462a      	mov	r2, r5
   2a23c:	4659      	mov	r1, fp
   2a23e:	4648      	mov	r0, r9
   2a240:	f7fe f9c8 	bl	285d4 <z_pend_curr>
   2a244:	2800      	cmp	r0, #0
   2a246:	d13b      	bne.n	2a2c0 <k_event_wait_internal+0x120>
		rv = thread->events;
   2a248:	9b02      	ldr	r3, [sp, #8]
   2a24a:	f8d3 a068 	ldr.w	sl, [r3, #104]	; 0x68
   2a24e:	e029      	b.n	2a2a4 <k_event_wait_internal+0x104>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2a250:	f8df a078 	ldr.w	sl, [pc, #120]	; 2a2cc <k_event_wait_internal+0x12c>
   2a254:	228e      	movs	r2, #142	; 0x8e
   2a256:	4651      	mov	r1, sl
   2a258:	481b      	ldr	r0, [pc, #108]	; (2a2c8 <k_event_wait_internal+0x128>)
   2a25a:	f002 f968 	bl	2c52e <assert_print>
   2a25e:	218e      	movs	r1, #142	; 0x8e
   2a260:	4650      	mov	r0, sl
   2a262:	f002 f95d 	bl	2c520 <assert_post_action>
   2a266:	e7cf      	b.n	2a208 <k_event_wait_internal+0x68>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2a268:	4648      	mov	r0, r9
   2a26a:	f7fc fa2b 	bl	266c4 <z_spin_unlock_valid>
   2a26e:	b120      	cbz	r0, 2a27a <k_event_wait_internal+0xda>
	__asm__ volatile(
   2a270:	f38b 8811 	msr	BASEPRI, fp
   2a274:	f3bf 8f6f 	isb	sy
		goto out;
   2a278:	e014      	b.n	2a2a4 <k_event_wait_internal+0x104>
   2a27a:	4d14      	ldr	r5, [pc, #80]	; (2a2cc <k_event_wait_internal+0x12c>)
   2a27c:	22b9      	movs	r2, #185	; 0xb9
   2a27e:	4629      	mov	r1, r5
   2a280:	4811      	ldr	r0, [pc, #68]	; (2a2c8 <k_event_wait_internal+0x128>)
   2a282:	f002 f954 	bl	2c52e <assert_print>
   2a286:	21b9      	movs	r1, #185	; 0xb9
   2a288:	4628      	mov	r0, r5
   2a28a:	f002 f949 	bl	2c520 <assert_post_action>
   2a28e:	e7ef      	b.n	2a270 <k_event_wait_internal+0xd0>
   2a290:	4648      	mov	r0, r9
   2a292:	f7fc fa17 	bl	266c4 <z_spin_unlock_valid>
   2a296:	b140      	cbz	r0, 2a2aa <k_event_wait_internal+0x10a>
   2a298:	f38b 8811 	msr	BASEPRI, fp
   2a29c:	f3bf 8f6f 	isb	sy
	uint32_t  rv = 0;
   2a2a0:	f04f 0a00 	mov.w	sl, #0
	return rv & events;
   2a2a4:	ea04 040a 	and.w	r4, r4, sl
   2a2a8:	e78a      	b.n	2a1c0 <k_event_wait_internal+0x20>
   2a2aa:	4d08      	ldr	r5, [pc, #32]	; (2a2cc <k_event_wait_internal+0x12c>)
   2a2ac:	22b9      	movs	r2, #185	; 0xb9
   2a2ae:	4629      	mov	r1, r5
   2a2b0:	4805      	ldr	r0, [pc, #20]	; (2a2c8 <k_event_wait_internal+0x128>)
   2a2b2:	f002 f93c 	bl	2c52e <assert_print>
   2a2b6:	21b9      	movs	r1, #185	; 0xb9
   2a2b8:	4628      	mov	r0, r5
   2a2ba:	f002 f931 	bl	2c520 <assert_post_action>
   2a2be:	e7eb      	b.n	2a298 <k_event_wait_internal+0xf8>
	uint32_t  rv = 0;
   2a2c0:	f04f 0a00 	mov.w	sl, #0
   2a2c4:	e7ee      	b.n	2a2a4 <k_event_wait_internal+0x104>
   2a2c6:	bf00      	nop
   2a2c8:	00031600 	.word	0x00031600
   2a2cc:	000390f0 	.word	0x000390f0
   2a2d0:	0003bf5c 	.word	0x0003bf5c

0002a2d4 <z_heap_aligned_alloc>:
#include <string.h>
#include <zephyr/sys/math_extras.h>
#include <zephyr/sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
   2a2d4:	b570      	push	{r4, r5, r6, lr}
   2a2d6:	b082      	sub	sp, #8
   2a2d8:	4606      	mov	r6, r0
   2a2da:	460c      	mov	r4, r1
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   2a2dc:	2300      	movs	r3, #0
   2a2de:	3204      	adds	r2, #4
   2a2e0:	d21c      	bcs.n	2a31c <z_heap_aligned_alloc+0x48>
	 * Adjust the size to make room for our heap reference.
	 * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).
	 * This allows for storing the heap pointer right below the aligned
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
   2a2e2:	b9eb      	cbnz	r3, 2a320 <z_heap_aligned_alloc+0x4c>
		return NULL;
	}
	__align = align | sizeof(heap_ref);

	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   2a2e4:	2000      	movs	r0, #0
   2a2e6:	2100      	movs	r1, #0
   2a2e8:	e9cd 0100 	strd	r0, r1, [sp]
   2a2ec:	f044 0104 	orr.w	r1, r4, #4
   2a2f0:	4630      	mov	r0, r6
   2a2f2:	f7fb ff07 	bl	26104 <k_heap_aligned_alloc>
	if (mem == NULL) {
   2a2f6:	4605      	mov	r5, r0
   2a2f8:	b198      	cbz	r0, 2a322 <z_heap_aligned_alloc+0x4e>
		return NULL;
	}

	heap_ref = mem;
	*heap_ref = heap;
   2a2fa:	f845 6b04 	str.w	r6, [r5], #4
	mem = ++heap_ref;
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
   2a2fe:	b184      	cbz	r4, 2a322 <z_heap_aligned_alloc+0x4e>
   2a300:	3c01      	subs	r4, #1
   2a302:	4225      	tst	r5, r4
   2a304:	d00d      	beq.n	2a322 <z_heap_aligned_alloc+0x4e>
   2a306:	4c08      	ldr	r4, [pc, #32]	; (2a328 <z_heap_aligned_alloc+0x54>)
   2a308:	2225      	movs	r2, #37	; 0x25
   2a30a:	4621      	mov	r1, r4
   2a30c:	4807      	ldr	r0, [pc, #28]	; (2a32c <z_heap_aligned_alloc+0x58>)
   2a30e:	f002 f90e 	bl	2c52e <assert_print>
   2a312:	2125      	movs	r1, #37	; 0x25
   2a314:	4620      	mov	r0, r4
   2a316:	f002 f903 	bl	2c520 <assert_post_action>
   2a31a:	e002      	b.n	2a322 <z_heap_aligned_alloc+0x4e>
   2a31c:	2301      	movs	r3, #1
   2a31e:	e7e0      	b.n	2a2e2 <z_heap_aligned_alloc+0xe>
		return NULL;
   2a320:	2500      	movs	r5, #0
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
}
   2a322:	4628      	mov	r0, r5
   2a324:	b002      	add	sp, #8
   2a326:	bd70      	pop	{r4, r5, r6, pc}
   2a328:	0003bf80 	.word	0x0003bf80
   2a32c:	00031600 	.word	0x00031600

0002a330 <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   2a330:	b570      	push	{r4, r5, r6, lr}
   2a332:	4604      	mov	r4, r0
   2a334:	460d      	mov	r5, r1
	__ASSERT(align / sizeof(void *) >= 1
   2a336:	2803      	cmp	r0, #3
   2a338:	d902      	bls.n	2a340 <k_aligned_alloc+0x10>
   2a33a:	f010 0f03 	tst.w	r0, #3
   2a33e:	d009      	beq.n	2a354 <k_aligned_alloc+0x24>
   2a340:	4e0e      	ldr	r6, [pc, #56]	; (2a37c <k_aligned_alloc+0x4c>)
   2a342:	2242      	movs	r2, #66	; 0x42
   2a344:	4631      	mov	r1, r6
   2a346:	480e      	ldr	r0, [pc, #56]	; (2a380 <k_aligned_alloc+0x50>)
   2a348:	f002 f8f1 	bl	2c52e <assert_print>
   2a34c:	2142      	movs	r1, #66	; 0x42
   2a34e:	4630      	mov	r0, r6
   2a350:	f002 f8e6 	bl	2c520 <assert_post_action>
		&& (align % sizeof(void *)) == 0,
		"align must be a multiple of sizeof(void *)");

	__ASSERT((align & (align - 1)) == 0,
   2a354:	1e63      	subs	r3, r4, #1
   2a356:	4223      	tst	r3, r4
   2a358:	d105      	bne.n	2a366 <k_aligned_alloc+0x36>
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   2a35a:	462a      	mov	r2, r5
   2a35c:	4621      	mov	r1, r4
   2a35e:	4809      	ldr	r0, [pc, #36]	; (2a384 <k_aligned_alloc+0x54>)
   2a360:	f7ff ffb8 	bl	2a2d4 <z_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP, ret);

	return ret;
}
   2a364:	bd70      	pop	{r4, r5, r6, pc}
	__ASSERT((align & (align - 1)) == 0,
   2a366:	4e05      	ldr	r6, [pc, #20]	; (2a37c <k_aligned_alloc+0x4c>)
   2a368:	2246      	movs	r2, #70	; 0x46
   2a36a:	4631      	mov	r1, r6
   2a36c:	4804      	ldr	r0, [pc, #16]	; (2a380 <k_aligned_alloc+0x50>)
   2a36e:	f002 f8de 	bl	2c52e <assert_print>
   2a372:	2146      	movs	r1, #70	; 0x46
   2a374:	4630      	mov	r0, r6
   2a376:	f002 f8d3 	bl	2c520 <assert_post_action>
   2a37a:	e7ee      	b.n	2a35a <k_aligned_alloc+0x2a>
   2a37c:	0003bf80 	.word	0x0003bf80
   2a380:	00031600 	.word	0x00031600
   2a384:	20000ea0 	.word	0x20000ea0

0002a388 <k_thread_system_pool_assign>:
	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
	thread->resource_pool = _SYSTEM_HEAP;
   2a388:	4b01      	ldr	r3, [pc, #4]	; (2a390 <k_thread_system_pool_assign+0x8>)
   2a38a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
}
   2a38e:	4770      	bx	lr
   2a390:	20000ea0 	.word	0x20000ea0

0002a394 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   2a394:	b538      	push	{r3, r4, r5, lr}
   2a396:	4604      	mov	r4, r0
   2a398:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   2a39a:	f006 fab7 	bl	3090c <k_is_in_isr>
   2a39e:	b948      	cbnz	r0, 2a3b4 <z_thread_aligned_alloc+0x20>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   2a3a0:	4b05      	ldr	r3, [pc, #20]	; (2a3b8 <z_thread_aligned_alloc+0x24>)
   2a3a2:	689b      	ldr	r3, [r3, #8]
   2a3a4:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
	}

	if (heap != NULL) {
   2a3a8:	b118      	cbz	r0, 2a3b2 <z_thread_aligned_alloc+0x1e>
		ret = z_heap_aligned_alloc(heap, align, size);
   2a3aa:	462a      	mov	r2, r5
   2a3ac:	4621      	mov	r1, r4
   2a3ae:	f7ff ff91 	bl	2a2d4 <z_heap_aligned_alloc>
	} else {
		ret = NULL;
	}

	return ret;
}
   2a3b2:	bd38      	pop	{r3, r4, r5, pc}
		heap = _SYSTEM_HEAP;
   2a3b4:	4801      	ldr	r0, [pc, #4]	; (2a3bc <z_thread_aligned_alloc+0x28>)
   2a3b6:	e7f7      	b.n	2a3a8 <z_thread_aligned_alloc+0x14>
   2a3b8:	200046a4 	.word	0x200046a4
   2a3bc:	20000ea0 	.word	0x20000ea0

0002a3c0 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
   2a3c0:	b508      	push	{r3, lr}
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   2a3c2:	4a03      	ldr	r2, [pc, #12]	; (2a3d0 <boot_banner+0x10>)
   2a3c4:	4903      	ldr	r1, [pc, #12]	; (2a3d4 <boot_banner+0x14>)
   2a3c6:	4804      	ldr	r0, [pc, #16]	; (2a3d8 <boot_banner+0x18>)
   2a3c8:	f001 fe0e 	bl	2bfe8 <printk>
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
   2a3cc:	bd08      	pop	{r3, pc}
   2a3ce:	bf00      	nop
   2a3d0:	00039828 	.word	0x00039828
   2a3d4:	0003bfa4 	.word	0x0003bfa4
   2a3d8:	0003bfb4 	.word	0x0003bfb4

0002a3dc <ocrypto_ecdh_p256_public_key>:
   2a3dc:	b530      	push	{r4, r5, lr}
   2a3de:	b099      	sub	sp, #100	; 0x64
   2a3e0:	4605      	mov	r5, r0
   2a3e2:	4668      	mov	r0, sp
   2a3e4:	f000 f828 	bl	2a438 <ocrypto_sc_p256_from32bytes>
   2a3e8:	4669      	mov	r1, sp
   2a3ea:	4604      	mov	r4, r0
   2a3ec:	a808      	add	r0, sp, #32
   2a3ee:	f000 fa53 	bl	2a898 <ocrypto_curve_p256_scalarmult_base>
   2a3f2:	a908      	add	r1, sp, #32
   2a3f4:	4304      	orrs	r4, r0
   2a3f6:	4628      	mov	r0, r5
   2a3f8:	f000 f98a 	bl	2a710 <ocrypto_curve_p256_to64bytes>
   2a3fc:	4620      	mov	r0, r4
   2a3fe:	b019      	add	sp, #100	; 0x64
   2a400:	bd30      	pop	{r4, r5, pc}
   2a402:	bf00      	nop

0002a404 <ocrypto_ecdh_p256_common_secret>:
   2a404:	b570      	push	{r4, r5, r6, lr}
   2a406:	b098      	sub	sp, #96	; 0x60
   2a408:	4605      	mov	r5, r0
   2a40a:	4668      	mov	r0, sp
   2a40c:	4616      	mov	r6, r2
   2a40e:	f000 f813 	bl	2a438 <ocrypto_sc_p256_from32bytes>
   2a412:	4631      	mov	r1, r6
   2a414:	4604      	mov	r4, r0
   2a416:	a808      	add	r0, sp, #32
   2a418:	f000 f946 	bl	2a6a8 <ocrypto_curve_p256_from64bytes>
   2a41c:	a908      	add	r1, sp, #32
   2a41e:	466a      	mov	r2, sp
   2a420:	4304      	orrs	r4, r0
   2a422:	4608      	mov	r0, r1
   2a424:	f000 f982 	bl	2a72c <ocrypto_curve_p256_scalarmult>
   2a428:	a908      	add	r1, sp, #32
   2a42a:	4304      	orrs	r4, r0
   2a42c:	4628      	mov	r0, r5
   2a42e:	f000 f96d 	bl	2a70c <ocrypto_curve_p256_to32bytes>
   2a432:	4620      	mov	r0, r4
   2a434:	b018      	add	sp, #96	; 0x60
   2a436:	bd70      	pop	{r4, r5, r6, pc}

0002a438 <ocrypto_sc_p256_from32bytes>:
   2a438:	b570      	push	{r4, r5, r6, lr}
   2a43a:	680b      	ldr	r3, [r1, #0]
   2a43c:	4e12      	ldr	r6, [pc, #72]	; (2a488 <ocrypto_sc_p256_from32bytes+0x50>)
   2a43e:	ba1b      	rev	r3, r3
   2a440:	61c3      	str	r3, [r0, #28]
   2a442:	684b      	ldr	r3, [r1, #4]
   2a444:	ba1b      	rev	r3, r3
   2a446:	6183      	str	r3, [r0, #24]
   2a448:	688b      	ldr	r3, [r1, #8]
   2a44a:	ba1b      	rev	r3, r3
   2a44c:	6143      	str	r3, [r0, #20]
   2a44e:	68cb      	ldr	r3, [r1, #12]
   2a450:	ba1b      	rev	r3, r3
   2a452:	6103      	str	r3, [r0, #16]
   2a454:	690b      	ldr	r3, [r1, #16]
   2a456:	ba1b      	rev	r3, r3
   2a458:	60c3      	str	r3, [r0, #12]
   2a45a:	694b      	ldr	r3, [r1, #20]
   2a45c:	ba1b      	rev	r3, r3
   2a45e:	6083      	str	r3, [r0, #8]
   2a460:	698b      	ldr	r3, [r1, #24]
   2a462:	ba1b      	rev	r3, r3
   2a464:	6043      	str	r3, [r0, #4]
   2a466:	69cb      	ldr	r3, [r1, #28]
   2a468:	ba1b      	rev	r3, r3
   2a46a:	4632      	mov	r2, r6
   2a46c:	6003      	str	r3, [r0, #0]
   2a46e:	4601      	mov	r1, r0
   2a470:	4604      	mov	r4, r0
   2a472:	f7d6 fd2b 	bl	ecc <ocrypto_bigint_sub256>
   2a476:	4631      	mov	r1, r6
   2a478:	4605      	mov	r5, r0
   2a47a:	4602      	mov	r2, r0
   2a47c:	4620      	mov	r0, r4
   2a47e:	f7d6 fd45 	bl	f0c <ocrypto_bigint_cadd256>
   2a482:	1e68      	subs	r0, r5, #1
   2a484:	bd70      	pop	{r4, r5, r6, pc}
   2a486:	bf00      	nop
   2a488:	0003bfdc 	.word	0x0003bfdc

0002a48c <p256_zdblu>:
   2a48c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a490:	b088      	sub	sp, #32
   2a492:	460c      	mov	r4, r1
   2a494:	4606      	mov	r6, r0
   2a496:	f102 0120 	add.w	r1, r2, #32
   2a49a:	4668      	mov	r0, sp
   2a49c:	f106 0720 	add.w	r7, r6, #32
   2a4a0:	4690      	mov	r8, r2
   2a4a2:	f7d7 f829 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a4a6:	466a      	mov	r2, sp
   2a4a8:	4669      	mov	r1, sp
   2a4aa:	4668      	mov	r0, sp
   2a4ac:	f7d6 ff36 	bl	131c <ocrypto_mod_p256_add>
   2a4b0:	4669      	mov	r1, sp
   2a4b2:	4638      	mov	r0, r7
   2a4b4:	f7d7 f820 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a4b8:	463a      	mov	r2, r7
   2a4ba:	4639      	mov	r1, r7
   2a4bc:	4638      	mov	r0, r7
   2a4be:	f104 0520 	add.w	r5, r4, #32
   2a4c2:	f7d6 ff2b 	bl	131c <ocrypto_mod_p256_add>
   2a4c6:	466a      	mov	r2, sp
   2a4c8:	4669      	mov	r1, sp
   2a4ca:	4668      	mov	r0, sp
   2a4cc:	f7d6 ff26 	bl	131c <ocrypto_mod_p256_add>
   2a4d0:	4641      	mov	r1, r8
   2a4d2:	4628      	mov	r0, r5
   2a4d4:	f7d7 f810 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a4d8:	466a      	mov	r2, sp
   2a4da:	4641      	mov	r1, r8
   2a4dc:	4630      	mov	r0, r6
   2a4de:	f7d6 fff3 	bl	14c8 <ocrypto_mod_p256_mul>
   2a4e2:	462a      	mov	r2, r5
   2a4e4:	4629      	mov	r1, r5
   2a4e6:	4668      	mov	r0, sp
   2a4e8:	f7d6 ff18 	bl	131c <ocrypto_mod_p256_add>
   2a4ec:	462a      	mov	r2, r5
   2a4ee:	4669      	mov	r1, sp
   2a4f0:	4668      	mov	r0, sp
   2a4f2:	f7d6 ff13 	bl	131c <ocrypto_mod_p256_add>
   2a4f6:	4a12      	ldr	r2, [pc, #72]	; (2a540 <p256_zdblu+0xb4>)
   2a4f8:	4669      	mov	r1, sp
   2a4fa:	4668      	mov	r0, sp
   2a4fc:	f7d6 ff0e 	bl	131c <ocrypto_mod_p256_add>
   2a500:	4669      	mov	r1, sp
   2a502:	4620      	mov	r0, r4
   2a504:	f7d6 fff8 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a508:	4632      	mov	r2, r6
   2a50a:	4621      	mov	r1, r4
   2a50c:	4620      	mov	r0, r4
   2a50e:	f7d6 ff43 	bl	1398 <ocrypto_mod_p256_sub>
   2a512:	4632      	mov	r2, r6
   2a514:	4621      	mov	r1, r4
   2a516:	4620      	mov	r0, r4
   2a518:	f7d6 ff3e 	bl	1398 <ocrypto_mod_p256_sub>
   2a51c:	4622      	mov	r2, r4
   2a51e:	4631      	mov	r1, r6
   2a520:	4628      	mov	r0, r5
   2a522:	f7d6 ff39 	bl	1398 <ocrypto_mod_p256_sub>
   2a526:	466a      	mov	r2, sp
   2a528:	4629      	mov	r1, r5
   2a52a:	4628      	mov	r0, r5
   2a52c:	f7d6 ffcc 	bl	14c8 <ocrypto_mod_p256_mul>
   2a530:	463a      	mov	r2, r7
   2a532:	4629      	mov	r1, r5
   2a534:	4628      	mov	r0, r5
   2a536:	f7d6 ff2f 	bl	1398 <ocrypto_mod_p256_sub>
   2a53a:	b008      	add	sp, #32
   2a53c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a540:	0003c07c 	.word	0x0003c07c

0002a544 <p256_zaddc>:
   2a544:	b5f0      	push	{r4, r5, r6, r7, lr}
   2a546:	b099      	sub	sp, #100	; 0x64
   2a548:	4604      	mov	r4, r0
   2a54a:	460d      	mov	r5, r1
   2a54c:	460a      	mov	r2, r1
   2a54e:	4601      	mov	r1, r0
   2a550:	4668      	mov	r0, sp
   2a552:	f7d6 ff21 	bl	1398 <ocrypto_mod_p256_sub>
   2a556:	4669      	mov	r1, sp
   2a558:	4668      	mov	r0, sp
   2a55a:	f7d6 ffcd 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a55e:	466a      	mov	r2, sp
   2a560:	4621      	mov	r1, r4
   2a562:	a808      	add	r0, sp, #32
   2a564:	f105 0620 	add.w	r6, r5, #32
   2a568:	f104 0720 	add.w	r7, r4, #32
   2a56c:	f7d6 ffac 	bl	14c8 <ocrypto_mod_p256_mul>
   2a570:	466a      	mov	r2, sp
   2a572:	4629      	mov	r1, r5
   2a574:	4668      	mov	r0, sp
   2a576:	f7d6 ffa7 	bl	14c8 <ocrypto_mod_p256_mul>
   2a57a:	4632      	mov	r2, r6
   2a57c:	4639      	mov	r1, r7
   2a57e:	a810      	add	r0, sp, #64	; 0x40
   2a580:	f7d6 fecc 	bl	131c <ocrypto_mod_p256_add>
   2a584:	4632      	mov	r2, r6
   2a586:	4639      	mov	r1, r7
   2a588:	4630      	mov	r0, r6
   2a58a:	f7d6 ff05 	bl	1398 <ocrypto_mod_p256_sub>
   2a58e:	4631      	mov	r1, r6
   2a590:	4628      	mov	r0, r5
   2a592:	f7d6 ffb1 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a596:	466a      	mov	r2, sp
   2a598:	a908      	add	r1, sp, #32
   2a59a:	4620      	mov	r0, r4
   2a59c:	f7d6 febe 	bl	131c <ocrypto_mod_p256_add>
   2a5a0:	4622      	mov	r2, r4
   2a5a2:	4629      	mov	r1, r5
   2a5a4:	4628      	mov	r0, r5
   2a5a6:	f7d6 fef7 	bl	1398 <ocrypto_mod_p256_sub>
   2a5aa:	466a      	mov	r2, sp
   2a5ac:	a908      	add	r1, sp, #32
   2a5ae:	4668      	mov	r0, sp
   2a5b0:	f7d6 fef2 	bl	1398 <ocrypto_mod_p256_sub>
   2a5b4:	466a      	mov	r2, sp
   2a5b6:	4639      	mov	r1, r7
   2a5b8:	4638      	mov	r0, r7
   2a5ba:	f7d6 ff85 	bl	14c8 <ocrypto_mod_p256_mul>
   2a5be:	462a      	mov	r2, r5
   2a5c0:	a908      	add	r1, sp, #32
   2a5c2:	4668      	mov	r0, sp
   2a5c4:	f7d6 fee8 	bl	1398 <ocrypto_mod_p256_sub>
   2a5c8:	466a      	mov	r2, sp
   2a5ca:	4631      	mov	r1, r6
   2a5cc:	4630      	mov	r0, r6
   2a5ce:	f7d6 ff7b 	bl	14c8 <ocrypto_mod_p256_mul>
   2a5d2:	463a      	mov	r2, r7
   2a5d4:	4631      	mov	r1, r6
   2a5d6:	4630      	mov	r0, r6
   2a5d8:	f7d6 fede 	bl	1398 <ocrypto_mod_p256_sub>
   2a5dc:	a910      	add	r1, sp, #64	; 0x40
   2a5de:	4668      	mov	r0, sp
   2a5e0:	f7d6 ff8a 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a5e4:	4622      	mov	r2, r4
   2a5e6:	4669      	mov	r1, sp
   2a5e8:	4620      	mov	r0, r4
   2a5ea:	f7d6 fed5 	bl	1398 <ocrypto_mod_p256_sub>
   2a5ee:	a908      	add	r1, sp, #32
   2a5f0:	4622      	mov	r2, r4
   2a5f2:	4608      	mov	r0, r1
   2a5f4:	f7d6 fed0 	bl	1398 <ocrypto_mod_p256_sub>
   2a5f8:	a910      	add	r1, sp, #64	; 0x40
   2a5fa:	aa08      	add	r2, sp, #32
   2a5fc:	4608      	mov	r0, r1
   2a5fe:	f7d6 ff63 	bl	14c8 <ocrypto_mod_p256_mul>
   2a602:	463a      	mov	r2, r7
   2a604:	a910      	add	r1, sp, #64	; 0x40
   2a606:	4638      	mov	r0, r7
   2a608:	f7d6 fec6 	bl	1398 <ocrypto_mod_p256_sub>
   2a60c:	b019      	add	sp, #100	; 0x64
   2a60e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002a610 <p256_zaddu>:
   2a610:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a614:	b088      	sub	sp, #32
   2a616:	460c      	mov	r4, r1
   2a618:	4605      	mov	r5, r0
   2a61a:	4690      	mov	r8, r2
   2a61c:	460a      	mov	r2, r1
   2a61e:	4601      	mov	r1, r0
   2a620:	4668      	mov	r0, sp
   2a622:	f7d6 feb9 	bl	1398 <ocrypto_mod_p256_sub>
   2a626:	4669      	mov	r1, sp
   2a628:	4668      	mov	r0, sp
   2a62a:	f7d6 ff65 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a62e:	466a      	mov	r2, sp
   2a630:	4629      	mov	r1, r5
   2a632:	4628      	mov	r0, r5
   2a634:	f104 0620 	add.w	r6, r4, #32
   2a638:	f7d6 ff46 	bl	14c8 <ocrypto_mod_p256_mul>
   2a63c:	f105 0720 	add.w	r7, r5, #32
   2a640:	466a      	mov	r2, sp
   2a642:	4621      	mov	r1, r4
   2a644:	4668      	mov	r0, sp
   2a646:	f7d6 ff3f 	bl	14c8 <ocrypto_mod_p256_mul>
   2a64a:	4632      	mov	r2, r6
   2a64c:	4639      	mov	r1, r7
   2a64e:	4630      	mov	r0, r6
   2a650:	f7d6 fea2 	bl	1398 <ocrypto_mod_p256_sub>
   2a654:	4631      	mov	r1, r6
   2a656:	4620      	mov	r0, r4
   2a658:	f7d6 ff4e 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a65c:	462a      	mov	r2, r5
   2a65e:	4621      	mov	r1, r4
   2a660:	4620      	mov	r0, r4
   2a662:	f7d6 fe99 	bl	1398 <ocrypto_mod_p256_sub>
   2a666:	466a      	mov	r2, sp
   2a668:	4621      	mov	r1, r4
   2a66a:	4620      	mov	r0, r4
   2a66c:	f7d6 fe94 	bl	1398 <ocrypto_mod_p256_sub>
   2a670:	466a      	mov	r2, sp
   2a672:	4629      	mov	r1, r5
   2a674:	4640      	mov	r0, r8
   2a676:	f7d6 fe8f 	bl	1398 <ocrypto_mod_p256_sub>
   2a67a:	4642      	mov	r2, r8
   2a67c:	4639      	mov	r1, r7
   2a67e:	4638      	mov	r0, r7
   2a680:	f7d6 ff22 	bl	14c8 <ocrypto_mod_p256_mul>
   2a684:	4622      	mov	r2, r4
   2a686:	4629      	mov	r1, r5
   2a688:	4668      	mov	r0, sp
   2a68a:	f7d6 fe85 	bl	1398 <ocrypto_mod_p256_sub>
   2a68e:	466a      	mov	r2, sp
   2a690:	4631      	mov	r1, r6
   2a692:	4630      	mov	r0, r6
   2a694:	f7d6 ff18 	bl	14c8 <ocrypto_mod_p256_mul>
   2a698:	463a      	mov	r2, r7
   2a69a:	4631      	mov	r1, r6
   2a69c:	4630      	mov	r0, r6
   2a69e:	f7d6 fe7b 	bl	1398 <ocrypto_mod_p256_sub>
   2a6a2:	b008      	add	sp, #32
   2a6a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002a6a8 <ocrypto_curve_p256_from64bytes>:
   2a6a8:	b570      	push	{r4, r5, r6, lr}
   2a6aa:	f100 0620 	add.w	r6, r0, #32
   2a6ae:	b090      	sub	sp, #64	; 0x40
   2a6b0:	460d      	mov	r5, r1
   2a6b2:	4604      	mov	r4, r0
   2a6b4:	f000 f914 	bl	2a8e0 <ocrypto_mod_p256_from_bytes>
   2a6b8:	f105 0120 	add.w	r1, r5, #32
   2a6bc:	4630      	mov	r0, r6
   2a6be:	f000 f90f 	bl	2a8e0 <ocrypto_mod_p256_from_bytes>
   2a6c2:	4621      	mov	r1, r4
   2a6c4:	a808      	add	r0, sp, #32
   2a6c6:	f7d6 ff17 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a6ca:	a908      	add	r1, sp, #32
   2a6cc:	4608      	mov	r0, r1
   2a6ce:	4a0d      	ldr	r2, [pc, #52]	; (2a704 <ocrypto_curve_p256_from64bytes+0x5c>)
   2a6d0:	f7d6 fe24 	bl	131c <ocrypto_mod_p256_add>
   2a6d4:	a908      	add	r1, sp, #32
   2a6d6:	4622      	mov	r2, r4
   2a6d8:	4608      	mov	r0, r1
   2a6da:	f7d6 fef5 	bl	14c8 <ocrypto_mod_p256_mul>
   2a6de:	a908      	add	r1, sp, #32
   2a6e0:	4a09      	ldr	r2, [pc, #36]	; (2a708 <ocrypto_curve_p256_from64bytes+0x60>)
   2a6e2:	4608      	mov	r0, r1
   2a6e4:	f7d6 fe1a 	bl	131c <ocrypto_mod_p256_add>
   2a6e8:	4631      	mov	r1, r6
   2a6ea:	4668      	mov	r0, sp
   2a6ec:	f7d6 ff04 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a6f0:	2220      	movs	r2, #32
   2a6f2:	4669      	mov	r1, sp
   2a6f4:	eb0d 0002 	add.w	r0, sp, r2
   2a6f8:	f7d6 fde2 	bl	12c0 <ocrypto_constant_time_equal>
   2a6fc:	3801      	subs	r0, #1
   2a6fe:	b010      	add	sp, #64	; 0x40
   2a700:	bd70      	pop	{r4, r5, r6, pc}
   2a702:	bf00      	nop
   2a704:	0003c07c 	.word	0x0003c07c
   2a708:	0003c09c 	.word	0x0003c09c

0002a70c <ocrypto_curve_p256_to32bytes>:
   2a70c:	f000 b902 	b.w	2a914 <ocrypto_mod_p256_to_bytes>

0002a710 <ocrypto_curve_p256_to64bytes>:
   2a710:	b538      	push	{r3, r4, r5, lr}
   2a712:	4604      	mov	r4, r0
   2a714:	460d      	mov	r5, r1
   2a716:	f000 f8fd 	bl	2a914 <ocrypto_mod_p256_to_bytes>
   2a71a:	f105 0120 	add.w	r1, r5, #32
   2a71e:	f104 0020 	add.w	r0, r4, #32
   2a722:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2a726:	f000 b8f5 	b.w	2a914 <ocrypto_mod_p256_to_bytes>
   2a72a:	bf00      	nop

0002a72c <ocrypto_curve_p256_scalarmult>:
   2a72c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2a730:	4613      	mov	r3, r2
   2a732:	b0bb      	sub	sp, #236	; 0xec
   2a734:	4a54      	ldr	r2, [pc, #336]	; (2a888 <ocrypto_curve_p256_scalarmult+0x15c>)
   2a736:	4688      	mov	r8, r1
   2a738:	4607      	mov	r7, r0
   2a73a:	4619      	mov	r1, r3
   2a73c:	a812      	add	r0, sp, #72	; 0x48
   2a73e:	f7d6 fbc5 	bl	ecc <ocrypto_bigint_sub256>
   2a742:	4952      	ldr	r1, [pc, #328]	; (2a88c <ocrypto_curve_p256_scalarmult+0x160>)
   2a744:	4602      	mov	r2, r0
   2a746:	a812      	add	r0, sp, #72	; 0x48
   2a748:	f7d6 fbe0 	bl	f0c <ocrypto_bigint_cadd256>
   2a74c:	9d19      	ldr	r5, [sp, #100]	; 0x64
   2a74e:	494e      	ldr	r1, [pc, #312]	; (2a888 <ocrypto_curve_p256_scalarmult+0x15c>)
   2a750:	ea00 75d5 	and.w	r5, r0, r5, lsr #31
   2a754:	4606      	mov	r6, r0
   2a756:	f1c5 0201 	rsb	r2, r5, #1
   2a75a:	a812      	add	r0, sp, #72	; 0x48
   2a75c:	f7d6 fbd6 	bl	f0c <ocrypto_bigint_cadd256>
   2a760:	9b19      	ldr	r3, [sp, #100]	; 0x64
   2a762:	4642      	mov	r2, r8
   2a764:	ea6f 0903 	mvn.w	r9, r3
   2a768:	a92a      	add	r1, sp, #168	; 0xa8
   2a76a:	a81a      	add	r0, sp, #104	; 0x68
   2a76c:	f7ff fe8e 	bl	2a48c <p256_zdblu>
   2a770:	ea4f 79d9 	mov.w	r9, r9, lsr #31
   2a774:	a922      	add	r1, sp, #136	; 0x88
   2a776:	f1c9 0201 	rsb	r2, r9, #1
   2a77a:	4608      	mov	r0, r1
   2a77c:	f000 f892 	bl	2a8a4 <ocrypto_mod_p256_cneg>
   2a780:	f1c6 0601 	rsb	r6, r6, #1
   2a784:	24fe      	movs	r4, #254	; 0xfe
   2a786:	aa02      	add	r2, sp, #8
   2a788:	a91a      	add	r1, sp, #104	; 0x68
   2a78a:	a82a      	add	r0, sp, #168	; 0xa8
   2a78c:	f7ff ff40 	bl	2a610 <p256_zaddu>
   2a790:	1162      	asrs	r2, r4, #5
   2a792:	ab3a      	add	r3, sp, #232	; 0xe8
   2a794:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   2a798:	f004 011f 	and.w	r1, r4, #31
   2a79c:	f852 3ca0 	ldr.w	r3, [r2, #-160]
   2a7a0:	40cb      	lsrs	r3, r1
   2a7a2:	464a      	mov	r2, r9
   2a7a4:	f003 0901 	and.w	r9, r3, #1
   2a7a8:	ea89 0202 	eor.w	r2, r9, r2
   2a7ac:	a92a      	add	r1, sp, #168	; 0xa8
   2a7ae:	a81a      	add	r0, sp, #104	; 0x68
   2a7b0:	9201      	str	r2, [sp, #4]
   2a7b2:	f7d6 fc07 	bl	fc4 <ocrypto_bigint_cswap256>
   2a7b6:	9a01      	ldr	r2, [sp, #4]
   2a7b8:	a932      	add	r1, sp, #200	; 0xc8
   2a7ba:	a822      	add	r0, sp, #136	; 0x88
   2a7bc:	f7d6 fc02 	bl	fc4 <ocrypto_bigint_cswap256>
   2a7c0:	3c01      	subs	r4, #1
   2a7c2:	a92a      	add	r1, sp, #168	; 0xa8
   2a7c4:	a81a      	add	r0, sp, #104	; 0x68
   2a7c6:	f7ff febd 	bl	2a544 <p256_zaddc>
   2a7ca:	1c63      	adds	r3, r4, #1
   2a7cc:	d1db      	bne.n	2a786 <ocrypto_curve_p256_scalarmult+0x5a>
   2a7ce:	f1c9 0201 	rsb	r2, r9, #1
   2a7d2:	a922      	add	r1, sp, #136	; 0x88
   2a7d4:	a80a      	add	r0, sp, #40	; 0x28
   2a7d6:	f000 f865 	bl	2a8a4 <ocrypto_mod_p256_cneg>
   2a7da:	ea85 0509 	eor.w	r5, r5, r9
   2a7de:	aa02      	add	r2, sp, #8
   2a7e0:	a91a      	add	r1, sp, #104	; 0x68
   2a7e2:	a82a      	add	r0, sp, #168	; 0xa8
   2a7e4:	f7ff ff14 	bl	2a610 <p256_zaddu>
   2a7e8:	a92a      	add	r1, sp, #168	; 0xa8
   2a7ea:	462a      	mov	r2, r5
   2a7ec:	a81a      	add	r0, sp, #104	; 0x68
   2a7ee:	f7d6 fbe9 	bl	fc4 <ocrypto_bigint_cswap256>
   2a7f2:	462a      	mov	r2, r5
   2a7f4:	a932      	add	r1, sp, #200	; 0xc8
   2a7f6:	a822      	add	r0, sp, #136	; 0x88
   2a7f8:	f7d6 fbe4 	bl	fc4 <ocrypto_bigint_cswap256>
   2a7fc:	a90a      	add	r1, sp, #40	; 0x28
   2a7fe:	aa02      	add	r2, sp, #8
   2a800:	4608      	mov	r0, r1
   2a802:	f7d6 fe61 	bl	14c8 <ocrypto_mod_p256_mul>
   2a806:	a90a      	add	r1, sp, #40	; 0x28
   2a808:	4608      	mov	r0, r1
   2a80a:	f000 f89d 	bl	2a948 <ocrypto_mod_p256_inv>
   2a80e:	a90a      	add	r1, sp, #40	; 0x28
   2a810:	f107 0420 	add.w	r4, r7, #32
   2a814:	f108 0220 	add.w	r2, r8, #32
   2a818:	4608      	mov	r0, r1
   2a81a:	f7d6 fe55 	bl	14c8 <ocrypto_mod_p256_mul>
   2a81e:	a922      	add	r1, sp, #136	; 0x88
   2a820:	aa0a      	add	r2, sp, #40	; 0x28
   2a822:	4620      	mov	r0, r4
   2a824:	f7d6 fe50 	bl	14c8 <ocrypto_mod_p256_mul>
   2a828:	aa0a      	add	r2, sp, #40	; 0x28
   2a82a:	a91a      	add	r1, sp, #104	; 0x68
   2a82c:	a802      	add	r0, sp, #8
   2a82e:	f7d6 fe4b 	bl	14c8 <ocrypto_mod_p256_mul>
   2a832:	a902      	add	r1, sp, #8
   2a834:	4608      	mov	r0, r1
   2a836:	f7d6 fe5f 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a83a:	aa1a      	add	r2, sp, #104	; 0x68
   2a83c:	a902      	add	r1, sp, #8
   2a83e:	a80a      	add	r0, sp, #40	; 0x28
   2a840:	f7d6 fe42 	bl	14c8 <ocrypto_mod_p256_mul>
   2a844:	4621      	mov	r1, r4
   2a846:	a802      	add	r0, sp, #8
   2a848:	f7d6 fe56 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a84c:	aa0a      	add	r2, sp, #40	; 0x28
   2a84e:	a902      	add	r1, sp, #8
   2a850:	4610      	mov	r0, r2
   2a852:	f7d6 fda1 	bl	1398 <ocrypto_mod_p256_sub>
   2a856:	4a0e      	ldr	r2, [pc, #56]	; (2a890 <ocrypto_curve_p256_scalarmult+0x164>)
   2a858:	a90a      	add	r1, sp, #40	; 0x28
   2a85a:	a802      	add	r0, sp, #8
   2a85c:	f7d6 fd9c 	bl	1398 <ocrypto_mod_p256_sub>
   2a860:	4620      	mov	r0, r4
   2a862:	2120      	movs	r1, #32
   2a864:	f7d6 fd40 	bl	12e8 <ocrypto_constant_time_is_zero>
   2a868:	a90a      	add	r1, sp, #40	; 0x28
   2a86a:	4243      	negs	r3, r0
   2a86c:	4602      	mov	r2, r0
   2a86e:	a802      	add	r0, sp, #8
   2a870:	431e      	orrs	r6, r3
   2a872:	f7d6 fba7 	bl	fc4 <ocrypto_bigint_cswap256>
   2a876:	4638      	mov	r0, r7
   2a878:	4a06      	ldr	r2, [pc, #24]	; (2a894 <ocrypto_curve_p256_scalarmult+0x168>)
   2a87a:	a902      	add	r1, sp, #8
   2a87c:	f7d6 fe24 	bl	14c8 <ocrypto_mod_p256_mul>
   2a880:	4630      	mov	r0, r6
   2a882:	b03b      	add	sp, #236	; 0xec
   2a884:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2a888:	0003c0bc 	.word	0x0003c0bc
   2a88c:	0003c03c 	.word	0x0003c03c
   2a890:	0003c09c 	.word	0x0003c09c
   2a894:	0003c05c 	.word	0x0003c05c

0002a898 <ocrypto_curve_p256_scalarmult_base>:
   2a898:	460a      	mov	r2, r1
   2a89a:	4901      	ldr	r1, [pc, #4]	; (2a8a0 <ocrypto_curve_p256_scalarmult_base+0x8>)
   2a89c:	f7ff bf46 	b.w	2a72c <ocrypto_curve_p256_scalarmult>
   2a8a0:	0003bffc 	.word	0x0003bffc

0002a8a4 <ocrypto_mod_p256_cneg>:
   2a8a4:	b570      	push	{r4, r5, r6, lr}
   2a8a6:	b088      	sub	sp, #32
   2a8a8:	4604      	mov	r4, r0
   2a8aa:	460d      	mov	r5, r1
   2a8ac:	4616      	mov	r6, r2
   2a8ae:	2100      	movs	r1, #0
   2a8b0:	2220      	movs	r2, #32
   2a8b2:	4668      	mov	r0, sp
   2a8b4:	f006 faf8 	bl	30ea8 <memset>
   2a8b8:	2300      	movs	r3, #0
   2a8ba:	4629      	mov	r1, r5
   2a8bc:	2220      	movs	r2, #32
   2a8be:	4620      	mov	r0, r4
   2a8c0:	9300      	str	r3, [sp, #0]
   2a8c2:	f006 fad0 	bl	30e66 <memcpy>
   2a8c6:	462a      	mov	r2, r5
   2a8c8:	4669      	mov	r1, sp
   2a8ca:	4668      	mov	r0, sp
   2a8cc:	f7d6 fd64 	bl	1398 <ocrypto_mod_p256_sub>
   2a8d0:	4632      	mov	r2, r6
   2a8d2:	4669      	mov	r1, sp
   2a8d4:	4620      	mov	r0, r4
   2a8d6:	f7d6 fb75 	bl	fc4 <ocrypto_bigint_cswap256>
   2a8da:	b008      	add	sp, #32
   2a8dc:	bd70      	pop	{r4, r5, r6, pc}
   2a8de:	bf00      	nop

0002a8e0 <ocrypto_mod_p256_from_bytes>:
   2a8e0:	680b      	ldr	r3, [r1, #0]
   2a8e2:	ba1b      	rev	r3, r3
   2a8e4:	61c3      	str	r3, [r0, #28]
   2a8e6:	684b      	ldr	r3, [r1, #4]
   2a8e8:	ba1b      	rev	r3, r3
   2a8ea:	6183      	str	r3, [r0, #24]
   2a8ec:	688b      	ldr	r3, [r1, #8]
   2a8ee:	ba1b      	rev	r3, r3
   2a8f0:	6143      	str	r3, [r0, #20]
   2a8f2:	68cb      	ldr	r3, [r1, #12]
   2a8f4:	ba1b      	rev	r3, r3
   2a8f6:	6103      	str	r3, [r0, #16]
   2a8f8:	690b      	ldr	r3, [r1, #16]
   2a8fa:	ba1b      	rev	r3, r3
   2a8fc:	60c3      	str	r3, [r0, #12]
   2a8fe:	694b      	ldr	r3, [r1, #20]
   2a900:	ba1b      	rev	r3, r3
   2a902:	6083      	str	r3, [r0, #8]
   2a904:	698b      	ldr	r3, [r1, #24]
   2a906:	ba1b      	rev	r3, r3
   2a908:	6043      	str	r3, [r0, #4]
   2a90a:	69cb      	ldr	r3, [r1, #28]
   2a90c:	ba1b      	rev	r3, r3
   2a90e:	6003      	str	r3, [r0, #0]
   2a910:	4770      	bx	lr
   2a912:	bf00      	nop

0002a914 <ocrypto_mod_p256_to_bytes>:
   2a914:	69cb      	ldr	r3, [r1, #28]
   2a916:	ba1b      	rev	r3, r3
   2a918:	6003      	str	r3, [r0, #0]
   2a91a:	698b      	ldr	r3, [r1, #24]
   2a91c:	ba1b      	rev	r3, r3
   2a91e:	6043      	str	r3, [r0, #4]
   2a920:	694b      	ldr	r3, [r1, #20]
   2a922:	ba1b      	rev	r3, r3
   2a924:	6083      	str	r3, [r0, #8]
   2a926:	690b      	ldr	r3, [r1, #16]
   2a928:	ba1b      	rev	r3, r3
   2a92a:	60c3      	str	r3, [r0, #12]
   2a92c:	68cb      	ldr	r3, [r1, #12]
   2a92e:	ba1b      	rev	r3, r3
   2a930:	6103      	str	r3, [r0, #16]
   2a932:	688b      	ldr	r3, [r1, #8]
   2a934:	ba1b      	rev	r3, r3
   2a936:	6143      	str	r3, [r0, #20]
   2a938:	684b      	ldr	r3, [r1, #4]
   2a93a:	ba1b      	rev	r3, r3
   2a93c:	6183      	str	r3, [r0, #24]
   2a93e:	680b      	ldr	r3, [r1, #0]
   2a940:	ba1b      	rev	r3, r3
   2a942:	61c3      	str	r3, [r0, #28]
   2a944:	4770      	bx	lr
   2a946:	bf00      	nop

0002a948 <ocrypto_mod_p256_inv>:
   2a948:	b570      	push	{r4, r5, r6, lr}
   2a94a:	b098      	sub	sp, #96	; 0x60
   2a94c:	460d      	mov	r5, r1
   2a94e:	4606      	mov	r6, r0
   2a950:	a810      	add	r0, sp, #64	; 0x40
   2a952:	f7d6 fdd1 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a956:	462a      	mov	r2, r5
   2a958:	a910      	add	r1, sp, #64	; 0x40
   2a95a:	4668      	mov	r0, sp
   2a95c:	f7d6 fdb4 	bl	14c8 <ocrypto_mod_p256_mul>
   2a960:	4669      	mov	r1, sp
   2a962:	a810      	add	r0, sp, #64	; 0x40
   2a964:	f7d6 fdc8 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a968:	a910      	add	r1, sp, #64	; 0x40
   2a96a:	4608      	mov	r0, r1
   2a96c:	f7d6 fdc4 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a970:	466a      	mov	r2, sp
   2a972:	a910      	add	r1, sp, #64	; 0x40
   2a974:	a808      	add	r0, sp, #32
   2a976:	f7d6 fda7 	bl	14c8 <ocrypto_mod_p256_mul>
   2a97a:	a908      	add	r1, sp, #32
   2a97c:	a810      	add	r0, sp, #64	; 0x40
   2a97e:	f7d6 fdbb 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a982:	a910      	add	r1, sp, #64	; 0x40
   2a984:	4608      	mov	r0, r1
   2a986:	f7d6 fdb7 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a98a:	a910      	add	r1, sp, #64	; 0x40
   2a98c:	4608      	mov	r0, r1
   2a98e:	f7d6 fdb3 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a992:	a910      	add	r1, sp, #64	; 0x40
   2a994:	4608      	mov	r0, r1
   2a996:	f7d6 fdaf 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a99a:	a910      	add	r1, sp, #64	; 0x40
   2a99c:	aa08      	add	r2, sp, #32
   2a99e:	4608      	mov	r0, r1
   2a9a0:	f7d6 fd92 	bl	14c8 <ocrypto_mod_p256_mul>
   2a9a4:	a910      	add	r1, sp, #64	; 0x40
   2a9a6:	4608      	mov	r0, r1
   2a9a8:	f7d6 fda6 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a9ac:	a910      	add	r1, sp, #64	; 0x40
   2a9ae:	4608      	mov	r0, r1
   2a9b0:	f7d6 fda2 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a9b4:	a910      	add	r1, sp, #64	; 0x40
   2a9b6:	466a      	mov	r2, sp
   2a9b8:	a808      	add	r0, sp, #32
   2a9ba:	f7d6 fd85 	bl	14c8 <ocrypto_mod_p256_mul>
   2a9be:	2405      	movs	r4, #5
   2a9c0:	a908      	add	r1, sp, #32
   2a9c2:	a810      	add	r0, sp, #64	; 0x40
   2a9c4:	f7d6 fd98 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a9c8:	a910      	add	r1, sp, #64	; 0x40
   2a9ca:	4608      	mov	r0, r1
   2a9cc:	f7d6 fd94 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a9d0:	3c01      	subs	r4, #1
   2a9d2:	a910      	add	r1, sp, #64	; 0x40
   2a9d4:	d1f5      	bne.n	2a9c2 <ocrypto_mod_p256_inv+0x7a>
   2a9d6:	aa08      	add	r2, sp, #32
   2a9d8:	4608      	mov	r0, r1
   2a9da:	f7d6 fd75 	bl	14c8 <ocrypto_mod_p256_mul>
   2a9de:	2405      	movs	r4, #5
   2a9e0:	a910      	add	r1, sp, #64	; 0x40
   2a9e2:	4608      	mov	r0, r1
   2a9e4:	f7d6 fd88 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a9e8:	a910      	add	r1, sp, #64	; 0x40
   2a9ea:	4608      	mov	r0, r1
   2a9ec:	f7d6 fd84 	bl	14f8 <ocrypto_mod_p256_sqr>
   2a9f0:	3c01      	subs	r4, #1
   2a9f2:	d1f5      	bne.n	2a9e0 <ocrypto_mod_p256_inv+0x98>
   2a9f4:	a910      	add	r1, sp, #64	; 0x40
   2a9f6:	aa08      	add	r2, sp, #32
   2a9f8:	4608      	mov	r0, r1
   2a9fa:	f7d6 fd65 	bl	14c8 <ocrypto_mod_p256_mul>
   2a9fe:	a910      	add	r1, sp, #64	; 0x40
   2aa00:	a808      	add	r0, sp, #32
   2aa02:	f7d6 fd79 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa06:	a908      	add	r1, sp, #32
   2aa08:	4608      	mov	r0, r1
   2aa0a:	f7d6 fd75 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa0e:	a908      	add	r1, sp, #32
   2aa10:	466a      	mov	r2, sp
   2aa12:	4668      	mov	r0, sp
   2aa14:	f7d6 fd58 	bl	14c8 <ocrypto_mod_p256_mul>
   2aa18:	2410      	movs	r4, #16
   2aa1a:	4669      	mov	r1, sp
   2aa1c:	a810      	add	r0, sp, #64	; 0x40
   2aa1e:	f7d6 fd6b 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa22:	a910      	add	r1, sp, #64	; 0x40
   2aa24:	4608      	mov	r0, r1
   2aa26:	f7d6 fd67 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa2a:	3c01      	subs	r4, #1
   2aa2c:	a910      	add	r1, sp, #64	; 0x40
   2aa2e:	d1f5      	bne.n	2aa1c <ocrypto_mod_p256_inv+0xd4>
   2aa30:	462a      	mov	r2, r5
   2aa32:	4608      	mov	r0, r1
   2aa34:	f7d6 fd48 	bl	14c8 <ocrypto_mod_p256_mul>
   2aa38:	2440      	movs	r4, #64	; 0x40
   2aa3a:	a910      	add	r1, sp, #64	; 0x40
   2aa3c:	4608      	mov	r0, r1
   2aa3e:	f7d6 fd5b 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa42:	a910      	add	r1, sp, #64	; 0x40
   2aa44:	4608      	mov	r0, r1
   2aa46:	f7d6 fd57 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa4a:	3c01      	subs	r4, #1
   2aa4c:	d1f5      	bne.n	2aa3a <ocrypto_mod_p256_inv+0xf2>
   2aa4e:	a910      	add	r1, sp, #64	; 0x40
   2aa50:	466a      	mov	r2, sp
   2aa52:	4608      	mov	r0, r1
   2aa54:	f7d6 fd38 	bl	14c8 <ocrypto_mod_p256_mul>
   2aa58:	2410      	movs	r4, #16
   2aa5a:	a910      	add	r1, sp, #64	; 0x40
   2aa5c:	4608      	mov	r0, r1
   2aa5e:	f7d6 fd4b 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa62:	a910      	add	r1, sp, #64	; 0x40
   2aa64:	4608      	mov	r0, r1
   2aa66:	f7d6 fd47 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa6a:	3c01      	subs	r4, #1
   2aa6c:	d1f5      	bne.n	2aa5a <ocrypto_mod_p256_inv+0x112>
   2aa6e:	a910      	add	r1, sp, #64	; 0x40
   2aa70:	466a      	mov	r2, sp
   2aa72:	4608      	mov	r0, r1
   2aa74:	f7d6 fd28 	bl	14c8 <ocrypto_mod_p256_mul>
   2aa78:	2410      	movs	r4, #16
   2aa7a:	a910      	add	r1, sp, #64	; 0x40
   2aa7c:	4608      	mov	r0, r1
   2aa7e:	f7d6 fd3b 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa82:	a910      	add	r1, sp, #64	; 0x40
   2aa84:	4608      	mov	r0, r1
   2aa86:	f7d6 fd37 	bl	14f8 <ocrypto_mod_p256_sqr>
   2aa8a:	3c01      	subs	r4, #1
   2aa8c:	d1f5      	bne.n	2aa7a <ocrypto_mod_p256_inv+0x132>
   2aa8e:	a910      	add	r1, sp, #64	; 0x40
   2aa90:	aa08      	add	r2, sp, #32
   2aa92:	4608      	mov	r0, r1
   2aa94:	f7d6 fd18 	bl	14c8 <ocrypto_mod_p256_mul>
   2aa98:	462a      	mov	r2, r5
   2aa9a:	a910      	add	r1, sp, #64	; 0x40
   2aa9c:	4630      	mov	r0, r6
   2aa9e:	f7d6 fd13 	bl	14c8 <ocrypto_mod_p256_mul>
   2aaa2:	b018      	add	sp, #96	; 0x60
   2aaa4:	bd70      	pop	{r4, r5, r6, pc}
   2aaa6:	bf00      	nop

0002aaa8 <cexpf>:
   2aaa8:	b508      	push	{r3, lr}
   2aaaa:	ed2d 8b04 	vpush	{d8-d9}
   2aaae:	eeb0 9a40 	vmov.f32	s18, s0
   2aab2:	eef0 8a60 	vmov.f32	s17, s1
   2aab6:	f006 f9ae 	bl	30e16 <crealf>
   2aaba:	eef0 0a68 	vmov.f32	s1, s17
   2aabe:	eeb0 8a40 	vmov.f32	s16, s0
   2aac2:	eeb0 0a49 	vmov.f32	s0, s18
   2aac6:	f006 f9a3 	bl	30e10 <cimagf>
   2aaca:	eeb0 9a40 	vmov.f32	s18, s0
   2aace:	eeb0 0a48 	vmov.f32	s0, s16
   2aad2:	f000 f8a7 	bl	2ac24 <expf>
   2aad6:	eef0 8a40 	vmov.f32	s17, s0
   2aada:	eeb0 0a49 	vmov.f32	s0, s18
   2aade:	f000 f85b 	bl	2ab98 <sinf>
   2aae2:	ee20 8a28 	vmul.f32	s16, s0, s17
   2aae6:	eeb0 0a49 	vmov.f32	s0, s18
   2aaea:	f000 f811 	bl	2ab10 <cosf>
   2aaee:	eddf 7a07 	vldr	s15, [pc, #28]	; 2ab0c <cexpf+0x64>
   2aaf2:	ee68 7a27 	vmul.f32	s15, s16, s15
   2aaf6:	eeb0 7a40 	vmov.f32	s14, s0
   2aafa:	eee7 7a28 	vfma.f32	s15, s14, s17
   2aafe:	eef0 0a48 	vmov.f32	s1, s16
   2ab02:	ecbd 8b04 	vpop	{d8-d9}
   2ab06:	eeb0 0a67 	vmov.f32	s0, s15
   2ab0a:	bd08      	pop	{r3, pc}
   2ab0c:	00000000 	.word	0x00000000

0002ab10 <cosf>:
   2ab10:	ee10 3a10 	vmov	r3, s0
   2ab14:	b507      	push	{r0, r1, r2, lr}
   2ab16:	4a1e      	ldr	r2, [pc, #120]	; (2ab90 <cosf+0x80>)
   2ab18:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2ab1c:	4293      	cmp	r3, r2
   2ab1e:	dc06      	bgt.n	2ab2e <cosf+0x1e>
   2ab20:	eddf 0a1c 	vldr	s1, [pc, #112]	; 2ab94 <cosf+0x84>
   2ab24:	b003      	add	sp, #12
   2ab26:	f85d eb04 	ldr.w	lr, [sp], #4
   2ab2a:	f000 bbab 	b.w	2b284 <__kernel_cosf>
   2ab2e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2ab32:	db04      	blt.n	2ab3e <cosf+0x2e>
   2ab34:	ee30 0a40 	vsub.f32	s0, s0, s0
   2ab38:	b003      	add	sp, #12
   2ab3a:	f85d fb04 	ldr.w	pc, [sp], #4
   2ab3e:	4668      	mov	r0, sp
   2ab40:	f000 fa64 	bl	2b00c <__ieee754_rem_pio2f>
   2ab44:	f000 0003 	and.w	r0, r0, #3
   2ab48:	2801      	cmp	r0, #1
   2ab4a:	d009      	beq.n	2ab60 <cosf+0x50>
   2ab4c:	2802      	cmp	r0, #2
   2ab4e:	d010      	beq.n	2ab72 <cosf+0x62>
   2ab50:	b9b0      	cbnz	r0, 2ab80 <cosf+0x70>
   2ab52:	eddd 0a01 	vldr	s1, [sp, #4]
   2ab56:	ed9d 0a00 	vldr	s0, [sp]
   2ab5a:	f000 fb93 	bl	2b284 <__kernel_cosf>
   2ab5e:	e7eb      	b.n	2ab38 <cosf+0x28>
   2ab60:	eddd 0a01 	vldr	s1, [sp, #4]
   2ab64:	ed9d 0a00 	vldr	s0, [sp]
   2ab68:	f000 fe60 	bl	2b82c <__kernel_sinf>
   2ab6c:	eeb1 0a40 	vneg.f32	s0, s0
   2ab70:	e7e2      	b.n	2ab38 <cosf+0x28>
   2ab72:	eddd 0a01 	vldr	s1, [sp, #4]
   2ab76:	ed9d 0a00 	vldr	s0, [sp]
   2ab7a:	f000 fb83 	bl	2b284 <__kernel_cosf>
   2ab7e:	e7f5      	b.n	2ab6c <cosf+0x5c>
   2ab80:	eddd 0a01 	vldr	s1, [sp, #4]
   2ab84:	ed9d 0a00 	vldr	s0, [sp]
   2ab88:	2001      	movs	r0, #1
   2ab8a:	f000 fe4f 	bl	2b82c <__kernel_sinf>
   2ab8e:	e7d3      	b.n	2ab38 <cosf+0x28>
   2ab90:	3f490fd8 	.word	0x3f490fd8
   2ab94:	00000000 	.word	0x00000000

0002ab98 <sinf>:
   2ab98:	ee10 3a10 	vmov	r3, s0
   2ab9c:	b507      	push	{r0, r1, r2, lr}
   2ab9e:	4a1f      	ldr	r2, [pc, #124]	; (2ac1c <sinf+0x84>)
   2aba0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2aba4:	4293      	cmp	r3, r2
   2aba6:	dc07      	bgt.n	2abb8 <sinf+0x20>
   2aba8:	eddf 0a1d 	vldr	s1, [pc, #116]	; 2ac20 <sinf+0x88>
   2abac:	2000      	movs	r0, #0
   2abae:	b003      	add	sp, #12
   2abb0:	f85d eb04 	ldr.w	lr, [sp], #4
   2abb4:	f000 be3a 	b.w	2b82c <__kernel_sinf>
   2abb8:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2abbc:	db04      	blt.n	2abc8 <sinf+0x30>
   2abbe:	ee30 0a40 	vsub.f32	s0, s0, s0
   2abc2:	b003      	add	sp, #12
   2abc4:	f85d fb04 	ldr.w	pc, [sp], #4
   2abc8:	4668      	mov	r0, sp
   2abca:	f000 fa1f 	bl	2b00c <__ieee754_rem_pio2f>
   2abce:	f000 0003 	and.w	r0, r0, #3
   2abd2:	2801      	cmp	r0, #1
   2abd4:	d00a      	beq.n	2abec <sinf+0x54>
   2abd6:	2802      	cmp	r0, #2
   2abd8:	d00f      	beq.n	2abfa <sinf+0x62>
   2abda:	b9c0      	cbnz	r0, 2ac0e <sinf+0x76>
   2abdc:	eddd 0a01 	vldr	s1, [sp, #4]
   2abe0:	ed9d 0a00 	vldr	s0, [sp]
   2abe4:	2001      	movs	r0, #1
   2abe6:	f000 fe21 	bl	2b82c <__kernel_sinf>
   2abea:	e7ea      	b.n	2abc2 <sinf+0x2a>
   2abec:	eddd 0a01 	vldr	s1, [sp, #4]
   2abf0:	ed9d 0a00 	vldr	s0, [sp]
   2abf4:	f000 fb46 	bl	2b284 <__kernel_cosf>
   2abf8:	e7e3      	b.n	2abc2 <sinf+0x2a>
   2abfa:	eddd 0a01 	vldr	s1, [sp, #4]
   2abfe:	ed9d 0a00 	vldr	s0, [sp]
   2ac02:	2001      	movs	r0, #1
   2ac04:	f000 fe12 	bl	2b82c <__kernel_sinf>
   2ac08:	eeb1 0a40 	vneg.f32	s0, s0
   2ac0c:	e7d9      	b.n	2abc2 <sinf+0x2a>
   2ac0e:	eddd 0a01 	vldr	s1, [sp, #4]
   2ac12:	ed9d 0a00 	vldr	s0, [sp]
   2ac16:	f000 fb35 	bl	2b284 <__kernel_cosf>
   2ac1a:	e7f5      	b.n	2ac08 <sinf+0x70>
   2ac1c:	3f490fd8 	.word	0x3f490fd8
   2ac20:	00000000 	.word	0x00000000

0002ac24 <expf>:
   2ac24:	b508      	push	{r3, lr}
   2ac26:	ed2d 8b02 	vpush	{d8}
   2ac2a:	eef0 8a40 	vmov.f32	s17, s0
   2ac2e:	f000 f889 	bl	2ad44 <__ieee754_expf>
   2ac32:	4b16      	ldr	r3, [pc, #88]	; (2ac8c <expf+0x68>)
   2ac34:	f993 3000 	ldrsb.w	r3, [r3]
   2ac38:	3301      	adds	r3, #1
   2ac3a:	eeb0 8a40 	vmov.f32	s16, s0
   2ac3e:	d011      	beq.n	2ac64 <expf+0x40>
   2ac40:	eeb0 0a68 	vmov.f32	s0, s17
   2ac44:	f006 f8f2 	bl	30e2c <finitef>
   2ac48:	b160      	cbz	r0, 2ac64 <expf+0x40>
   2ac4a:	eddf 7a11 	vldr	s15, [pc, #68]	; 2ac90 <expf+0x6c>
   2ac4e:	eef4 8ae7 	vcmpe.f32	s17, s15
   2ac52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ac56:	dd0a      	ble.n	2ac6e <expf+0x4a>
   2ac58:	f001 fe67 	bl	2c92a <__errno>
   2ac5c:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 2ac94 <expf+0x70>
   2ac60:	2322      	movs	r3, #34	; 0x22
   2ac62:	6003      	str	r3, [r0, #0]
   2ac64:	eeb0 0a48 	vmov.f32	s0, s16
   2ac68:	ecbd 8b02 	vpop	{d8}
   2ac6c:	bd08      	pop	{r3, pc}
   2ac6e:	eddf 7a0a 	vldr	s15, [pc, #40]	; 2ac98 <expf+0x74>
   2ac72:	eef4 8ae7 	vcmpe.f32	s17, s15
   2ac76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ac7a:	d5f3      	bpl.n	2ac64 <expf+0x40>
   2ac7c:	f001 fe55 	bl	2c92a <__errno>
   2ac80:	2322      	movs	r3, #34	; 0x22
   2ac82:	ed9f 8a06 	vldr	s16, [pc, #24]	; 2ac9c <expf+0x78>
   2ac86:	6003      	str	r3, [r0, #0]
   2ac88:	e7ec      	b.n	2ac64 <expf+0x40>
   2ac8a:	bf00      	nop
   2ac8c:	20000dfc 	.word	0x20000dfc
   2ac90:	42b17180 	.word	0x42b17180
   2ac94:	7f800000 	.word	0x7f800000
   2ac98:	c2cff1b5 	.word	0xc2cff1b5
   2ac9c:	00000000 	.word	0x00000000

0002aca0 <hypotf>:
   2aca0:	b508      	push	{r3, lr}
   2aca2:	ed2d 8b04 	vpush	{d8-d9}
   2aca6:	eeb0 9a40 	vmov.f32	s18, s0
   2acaa:	eef0 8a60 	vmov.f32	s17, s1
   2acae:	f000 f91b 	bl	2aee8 <__ieee754_hypotf>
   2acb2:	4b0f      	ldr	r3, [pc, #60]	; (2acf0 <hypotf+0x50>)
   2acb4:	f993 3000 	ldrsb.w	r3, [r3]
   2acb8:	3301      	adds	r3, #1
   2acba:	eeb0 8a40 	vmov.f32	s16, s0
   2acbe:	d012      	beq.n	2ace6 <hypotf+0x46>
   2acc0:	f006 f8b4 	bl	30e2c <finitef>
   2acc4:	b978      	cbnz	r0, 2ace6 <hypotf+0x46>
   2acc6:	eeb0 0a49 	vmov.f32	s0, s18
   2acca:	f006 f8af 	bl	30e2c <finitef>
   2acce:	b150      	cbz	r0, 2ace6 <hypotf+0x46>
   2acd0:	eeb0 0a68 	vmov.f32	s0, s17
   2acd4:	f006 f8aa 	bl	30e2c <finitef>
   2acd8:	b128      	cbz	r0, 2ace6 <hypotf+0x46>
   2acda:	f001 fe26 	bl	2c92a <__errno>
   2acde:	ed9f 8a05 	vldr	s16, [pc, #20]	; 2acf4 <hypotf+0x54>
   2ace2:	2322      	movs	r3, #34	; 0x22
   2ace4:	6003      	str	r3, [r0, #0]
   2ace6:	eeb0 0a48 	vmov.f32	s0, s16
   2acea:	ecbd 8b04 	vpop	{d8-d9}
   2acee:	bd08      	pop	{r3, pc}
   2acf0:	20000dfc 	.word	0x20000dfc
   2acf4:	7f800000 	.word	0x7f800000

0002acf8 <sqrtf>:
   2acf8:	b508      	push	{r3, lr}
   2acfa:	ed2d 8b02 	vpush	{d8}
   2acfe:	eeb0 8a40 	vmov.f32	s16, s0
   2ad02:	f006 f889 	bl	30e18 <__ieee754_sqrtf>
   2ad06:	4b0d      	ldr	r3, [pc, #52]	; (2ad3c <sqrtf+0x44>)
   2ad08:	f993 3000 	ldrsb.w	r3, [r3]
   2ad0c:	3301      	adds	r3, #1
   2ad0e:	d011      	beq.n	2ad34 <sqrtf+0x3c>
   2ad10:	eeb4 8a48 	vcmp.f32	s16, s16
   2ad14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ad18:	d60c      	bvs.n	2ad34 <sqrtf+0x3c>
   2ad1a:	eddf 8a09 	vldr	s17, [pc, #36]	; 2ad40 <sqrtf+0x48>
   2ad1e:	eeb4 8ae8 	vcmpe.f32	s16, s17
   2ad22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ad26:	d505      	bpl.n	2ad34 <sqrtf+0x3c>
   2ad28:	f001 fdff 	bl	2c92a <__errno>
   2ad2c:	ee88 0aa8 	vdiv.f32	s0, s17, s17
   2ad30:	2321      	movs	r3, #33	; 0x21
   2ad32:	6003      	str	r3, [r0, #0]
   2ad34:	ecbd 8b02 	vpop	{d8}
   2ad38:	bd08      	pop	{r3, pc}
   2ad3a:	bf00      	nop
   2ad3c:	20000dfc 	.word	0x20000dfc
   2ad40:	00000000 	.word	0x00000000

0002ad44 <__ieee754_expf>:
   2ad44:	ee10 2a10 	vmov	r2, s0
   2ad48:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
   2ad4c:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   2ad50:	d902      	bls.n	2ad58 <__ieee754_expf+0x14>
   2ad52:	ee30 0a00 	vadd.f32	s0, s0, s0
   2ad56:	4770      	bx	lr
   2ad58:	ea4f 73d2 	mov.w	r3, r2, lsr #31
   2ad5c:	d106      	bne.n	2ad6c <__ieee754_expf+0x28>
   2ad5e:	eddf 7a50 	vldr	s15, [pc, #320]	; 2aea0 <__ieee754_expf+0x15c>
   2ad62:	2b00      	cmp	r3, #0
   2ad64:	bf18      	it	ne
   2ad66:	eeb0 0a67 	vmovne.f32	s0, s15
   2ad6a:	4770      	bx	lr
   2ad6c:	484d      	ldr	r0, [pc, #308]	; (2aea4 <__ieee754_expf+0x160>)
   2ad6e:	4282      	cmp	r2, r0
   2ad70:	dd04      	ble.n	2ad7c <__ieee754_expf+0x38>
   2ad72:	ed9f 0a4d 	vldr	s0, [pc, #308]	; 2aea8 <__ieee754_expf+0x164>
   2ad76:	ee20 0a00 	vmul.f32	s0, s0, s0
   2ad7a:	4770      	bx	lr
   2ad7c:	2a00      	cmp	r2, #0
   2ad7e:	da03      	bge.n	2ad88 <__ieee754_expf+0x44>
   2ad80:	4a4a      	ldr	r2, [pc, #296]	; (2aeac <__ieee754_expf+0x168>)
   2ad82:	4291      	cmp	r1, r2
   2ad84:	f200 8088 	bhi.w	2ae98 <__ieee754_expf+0x154>
   2ad88:	4a49      	ldr	r2, [pc, #292]	; (2aeb0 <__ieee754_expf+0x16c>)
   2ad8a:	4291      	cmp	r1, r2
   2ad8c:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   2ad90:	d952      	bls.n	2ae38 <__ieee754_expf+0xf4>
   2ad92:	4a48      	ldr	r2, [pc, #288]	; (2aeb4 <__ieee754_expf+0x170>)
   2ad94:	4291      	cmp	r1, r2
   2ad96:	ea4f 0283 	mov.w	r2, r3, lsl #2
   2ad9a:	d834      	bhi.n	2ae06 <__ieee754_expf+0xc2>
   2ad9c:	4946      	ldr	r1, [pc, #280]	; (2aeb8 <__ieee754_expf+0x174>)
   2ad9e:	4411      	add	r1, r2
   2ada0:	ed91 7a00 	vldr	s14, [r1]
   2ada4:	4945      	ldr	r1, [pc, #276]	; (2aebc <__ieee754_expf+0x178>)
   2ada6:	440a      	add	r2, r1
   2ada8:	edd2 7a00 	vldr	s15, [r2]
   2adac:	ee30 7a47 	vsub.f32	s14, s0, s14
   2adb0:	f1c3 0201 	rsb	r2, r3, #1
   2adb4:	1ad2      	subs	r2, r2, r3
   2adb6:	ee37 0a67 	vsub.f32	s0, s14, s15
   2adba:	ee20 6a00 	vmul.f32	s12, s0, s0
   2adbe:	ed9f 5a40 	vldr	s10, [pc, #256]	; 2aec0 <__ieee754_expf+0x17c>
   2adc2:	eddf 6a40 	vldr	s13, [pc, #256]	; 2aec4 <__ieee754_expf+0x180>
   2adc6:	eee6 6a05 	vfma.f32	s13, s12, s10
   2adca:	ed9f 5a3f 	vldr	s10, [pc, #252]	; 2aec8 <__ieee754_expf+0x184>
   2adce:	eea6 5a86 	vfma.f32	s10, s13, s12
   2add2:	eddf 6a3e 	vldr	s13, [pc, #248]	; 2aecc <__ieee754_expf+0x188>
   2add6:	eee5 6a06 	vfma.f32	s13, s10, s12
   2adda:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 2aed0 <__ieee754_expf+0x18c>
   2adde:	eea6 5a86 	vfma.f32	s10, s13, s12
   2ade2:	eef0 6a40 	vmov.f32	s13, s0
   2ade6:	eee5 6a46 	vfms.f32	s13, s10, s12
   2adea:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
   2adee:	ee20 5a26 	vmul.f32	s10, s0, s13
   2adf2:	bb92      	cbnz	r2, 2ae5a <__ieee754_expf+0x116>
   2adf4:	ee76 6ac6 	vsub.f32	s13, s13, s12
   2adf8:	eec5 7a26 	vdiv.f32	s15, s10, s13
   2adfc:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2ae00:	ee35 0ac0 	vsub.f32	s0, s11, s0
   2ae04:	4770      	bx	lr
   2ae06:	4b33      	ldr	r3, [pc, #204]	; (2aed4 <__ieee754_expf+0x190>)
   2ae08:	ed9f 7a33 	vldr	s14, [pc, #204]	; 2aed8 <__ieee754_expf+0x194>
   2ae0c:	eddf 6a33 	vldr	s13, [pc, #204]	; 2aedc <__ieee754_expf+0x198>
   2ae10:	4413      	add	r3, r2
   2ae12:	edd3 7a00 	vldr	s15, [r3]
   2ae16:	eee0 7a07 	vfma.f32	s15, s0, s14
   2ae1a:	eeb0 7a40 	vmov.f32	s14, s0
   2ae1e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2ae22:	ee17 2a90 	vmov	r2, s15
   2ae26:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2ae2a:	eea7 7ae6 	vfms.f32	s14, s15, s13
   2ae2e:	eddf 6a2c 	vldr	s13, [pc, #176]	; 2aee0 <__ieee754_expf+0x19c>
   2ae32:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2ae36:	e7be      	b.n	2adb6 <__ieee754_expf+0x72>
   2ae38:	f1b1 5f46 	cmp.w	r1, #830472192	; 0x31800000
   2ae3c:	d20b      	bcs.n	2ae56 <__ieee754_expf+0x112>
   2ae3e:	eddf 6a1a 	vldr	s13, [pc, #104]	; 2aea8 <__ieee754_expf+0x164>
   2ae42:	ee70 6a26 	vadd.f32	s13, s0, s13
   2ae46:	eef4 6ae5 	vcmpe.f32	s13, s11
   2ae4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2ae4e:	dd02      	ble.n	2ae56 <__ieee754_expf+0x112>
   2ae50:	ee30 0a25 	vadd.f32	s0, s0, s11
   2ae54:	4770      	bx	lr
   2ae56:	2200      	movs	r2, #0
   2ae58:	e7af      	b.n	2adba <__ieee754_expf+0x76>
   2ae5a:	ee76 6a66 	vsub.f32	s13, s12, s13
   2ae5e:	f112 0f7d 	cmn.w	r2, #125	; 0x7d
   2ae62:	ee85 0a26 	vdiv.f32	s0, s10, s13
   2ae66:	bfb8      	it	lt
   2ae68:	3264      	addlt	r2, #100	; 0x64
   2ae6a:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2ae6e:	ee37 0ac7 	vsub.f32	s0, s15, s14
   2ae72:	ee75 7ac0 	vsub.f32	s15, s11, s0
   2ae76:	ee17 3a90 	vmov	r3, s15
   2ae7a:	bfab      	itete	ge
   2ae7c:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
   2ae80:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
   2ae84:	ee00 3a10 	vmovge	s0, r3
   2ae88:	eddf 7a16 	vldrlt	s15, [pc, #88]	; 2aee4 <__ieee754_expf+0x1a0>
   2ae8c:	bfbc      	itt	lt
   2ae8e:	ee00 3a10 	vmovlt	s0, r3
   2ae92:	ee20 0a27 	vmullt.f32	s0, s0, s15
   2ae96:	4770      	bx	lr
   2ae98:	ed9f 0a01 	vldr	s0, [pc, #4]	; 2aea0 <__ieee754_expf+0x15c>
   2ae9c:	4770      	bx	lr
   2ae9e:	bf00      	nop
   2aea0:	00000000 	.word	0x00000000
   2aea4:	42b17217 	.word	0x42b17217
   2aea8:	7149f2ca 	.word	0x7149f2ca
   2aeac:	42cff1b5 	.word	0x42cff1b5
   2aeb0:	3eb17218 	.word	0x3eb17218
   2aeb4:	3f851591 	.word	0x3f851591
   2aeb8:	0003c0e4 	.word	0x0003c0e4
   2aebc:	0003c0ec 	.word	0x0003c0ec
   2aec0:	3331bb4c 	.word	0x3331bb4c
   2aec4:	b5ddea0e 	.word	0xb5ddea0e
   2aec8:	388ab355 	.word	0x388ab355
   2aecc:	bb360b61 	.word	0xbb360b61
   2aed0:	3e2aaaab 	.word	0x3e2aaaab
   2aed4:	0003c0dc 	.word	0x0003c0dc
   2aed8:	3fb8aa3b 	.word	0x3fb8aa3b
   2aedc:	3f317180 	.word	0x3f317180
   2aee0:	3717f7d1 	.word	0x3717f7d1
   2aee4:	0d800000 	.word	0x0d800000

0002aee8 <__ieee754_hypotf>:
   2aee8:	b513      	push	{r0, r1, r4, lr}
   2aeea:	ed8d 0a00 	vstr	s0, [sp]
   2aeee:	edcd 0a01 	vstr	s1, [sp, #4]
   2aef2:	9b00      	ldr	r3, [sp, #0]
   2aef4:	9a01      	ldr	r2, [sp, #4]
   2aef6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2aefa:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
   2aefe:	4293      	cmp	r3, r2
   2af00:	bfbe      	ittt	lt
   2af02:	4619      	movlt	r1, r3
   2af04:	4613      	movlt	r3, r2
   2af06:	460a      	movlt	r2, r1
   2af08:	1a99      	subs	r1, r3, r2
   2af0a:	f1b1 6f70 	cmp.w	r1, #251658240	; 0xf000000
   2af0e:	ee00 3a10 	vmov	s0, r3
   2af12:	ee06 2a90 	vmov	s13, r2
   2af16:	dd03      	ble.n	2af20 <__ieee754_hypotf+0x38>
   2af18:	ee30 0a26 	vadd.f32	s0, s0, s13
   2af1c:	b002      	add	sp, #8
   2af1e:	bd10      	pop	{r4, pc}
   2af20:	f1b3 4fb1 	cmp.w	r3, #1484783616	; 0x58800000
   2af24:	dd48      	ble.n	2afb8 <__ieee754_hypotf+0xd0>
   2af26:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2af2a:	db0c      	blt.n	2af46 <__ieee754_hypotf+0x5e>
   2af2c:	bf14      	ite	ne
   2af2e:	ee30 0a26 	vaddne.f32	s0, s0, s13
   2af32:	ed9f 0a33 	vldreq	s0, [pc, #204]	; 2b000 <__ieee754_hypotf+0x118>
   2af36:	eddf 7a32 	vldr	s15, [pc, #200]	; 2b000 <__ieee754_hypotf+0x118>
   2af3a:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2af3e:	bf08      	it	eq
   2af40:	eeb0 0a67 	vmoveq.f32	s0, s15
   2af44:	e7ea      	b.n	2af1c <__ieee754_hypotf+0x34>
   2af46:	f103 435e 	add.w	r3, r3, #3724541952	; 0xde000000
   2af4a:	f102 425e 	add.w	r2, r2, #3724541952	; 0xde000000
   2af4e:	ee00 3a10 	vmov	s0, r3
   2af52:	ee06 2a90 	vmov	s13, r2
   2af56:	2444      	movs	r4, #68	; 0x44
   2af58:	f1b2 5f1a 	cmp.w	r2, #645922816	; 0x26800000
   2af5c:	da0b      	bge.n	2af76 <__ieee754_hypotf+0x8e>
   2af5e:	2a00      	cmp	r2, #0
   2af60:	d0dc      	beq.n	2af1c <__ieee754_hypotf+0x34>
   2af62:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   2af66:	da29      	bge.n	2afbc <__ieee754_hypotf+0xd4>
   2af68:	eddf 7a26 	vldr	s15, [pc, #152]	; 2b004 <__ieee754_hypotf+0x11c>
   2af6c:	ee66 6aa7 	vmul.f32	s13, s13, s15
   2af70:	ee20 0a27 	vmul.f32	s0, s0, s15
   2af74:	3c7e      	subs	r4, #126	; 0x7e
   2af76:	ee30 6a66 	vsub.f32	s12, s0, s13
   2af7a:	4923      	ldr	r1, [pc, #140]	; (2b008 <__ieee754_hypotf+0x120>)
   2af7c:	eef4 6ac6 	vcmpe.f32	s13, s12
   2af80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2af84:	d524      	bpl.n	2afd0 <__ieee754_hypotf+0xe8>
   2af86:	400b      	ands	r3, r1
   2af88:	ee07 3a90 	vmov	s15, r3
   2af8c:	ee30 7a27 	vadd.f32	s14, s0, s15
   2af90:	ee30 0a67 	vsub.f32	s0, s0, s15
   2af94:	ee20 0a47 	vnmul.f32	s0, s0, s14
   2af98:	eea6 0ae6 	vfms.f32	s0, s13, s13
   2af9c:	ee97 0aa7 	vfnms.f32	s0, s15, s15
   2afa0:	f005 ff3a 	bl	30e18 <__ieee754_sqrtf>
   2afa4:	2c00      	cmp	r4, #0
   2afa6:	d0b9      	beq.n	2af1c <__ieee754_hypotf+0x34>
   2afa8:	05e4      	lsls	r4, r4, #23
   2afaa:	f104 547e 	add.w	r4, r4, #1065353216	; 0x3f800000
   2afae:	ee07 4a90 	vmov	s15, r4
   2afb2:	ee20 0a27 	vmul.f32	s0, s0, s15
   2afb6:	e7b1      	b.n	2af1c <__ieee754_hypotf+0x34>
   2afb8:	2400      	movs	r4, #0
   2afba:	e7cd      	b.n	2af58 <__ieee754_hypotf+0x70>
   2afbc:	f103 5308 	add.w	r3, r3, #570425344	; 0x22000000
   2afc0:	f102 5208 	add.w	r2, r2, #570425344	; 0x22000000
   2afc4:	ee00 3a10 	vmov	s0, r3
   2afc8:	ee06 2a90 	vmov	s13, r2
   2afcc:	3c44      	subs	r4, #68	; 0x44
   2afce:	e7d2      	b.n	2af76 <__ieee754_hypotf+0x8e>
   2afd0:	f503 0300 	add.w	r3, r3, #8388608	; 0x800000
   2afd4:	ee05 3a10 	vmov	s10, r3
   2afd8:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
   2afdc:	ee90 5a24 	vfnms.f32	s10, s0, s9
   2afe0:	400a      	ands	r2, r1
   2afe2:	ee07 2a10 	vmov	s14, r2
   2afe6:	ee07 3a90 	vmov	s15, r3
   2afea:	ee76 5ac7 	vsub.f32	s11, s13, s14
   2afee:	ee26 0a85 	vmul.f32	s0, s13, s10
   2aff2:	eea5 0aa7 	vfma.f32	s0, s11, s15
   2aff6:	ee96 0a46 	vfnma.f32	s0, s12, s12
   2affa:	ee97 0a27 	vfnms.f32	s0, s14, s15
   2affe:	e7cf      	b.n	2afa0 <__ieee754_hypotf+0xb8>
   2b000:	7f800000 	.word	0x7f800000
   2b004:	7e800000 	.word	0x7e800000
   2b008:	fffff000 	.word	0xfffff000

0002b00c <__ieee754_rem_pio2f>:
   2b00c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b00e:	ee10 6a10 	vmov	r6, s0
   2b012:	4b8e      	ldr	r3, [pc, #568]	; (2b24c <__ieee754_rem_pio2f+0x240>)
   2b014:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
   2b018:	429d      	cmp	r5, r3
   2b01a:	b087      	sub	sp, #28
   2b01c:	eef0 7a40 	vmov.f32	s15, s0
   2b020:	4604      	mov	r4, r0
   2b022:	dc05      	bgt.n	2b030 <__ieee754_rem_pio2f+0x24>
   2b024:	2300      	movs	r3, #0
   2b026:	ed80 0a00 	vstr	s0, [r0]
   2b02a:	6043      	str	r3, [r0, #4]
   2b02c:	2000      	movs	r0, #0
   2b02e:	e01a      	b.n	2b066 <__ieee754_rem_pio2f+0x5a>
   2b030:	4b87      	ldr	r3, [pc, #540]	; (2b250 <__ieee754_rem_pio2f+0x244>)
   2b032:	429d      	cmp	r5, r3
   2b034:	dc46      	bgt.n	2b0c4 <__ieee754_rem_pio2f+0xb8>
   2b036:	2e00      	cmp	r6, #0
   2b038:	ed9f 0a86 	vldr	s0, [pc, #536]	; 2b254 <__ieee754_rem_pio2f+0x248>
   2b03c:	4b86      	ldr	r3, [pc, #536]	; (2b258 <__ieee754_rem_pio2f+0x24c>)
   2b03e:	f025 050f 	bic.w	r5, r5, #15
   2b042:	dd1f      	ble.n	2b084 <__ieee754_rem_pio2f+0x78>
   2b044:	429d      	cmp	r5, r3
   2b046:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2b04a:	d00e      	beq.n	2b06a <__ieee754_rem_pio2f+0x5e>
   2b04c:	ed9f 7a83 	vldr	s14, [pc, #524]	; 2b25c <__ieee754_rem_pio2f+0x250>
   2b050:	ee37 0ac7 	vsub.f32	s0, s15, s14
   2b054:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2b058:	ed80 0a00 	vstr	s0, [r0]
   2b05c:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b060:	2001      	movs	r0, #1
   2b062:	edc4 7a01 	vstr	s15, [r4, #4]
   2b066:	b007      	add	sp, #28
   2b068:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b06a:	ed9f 0a7d 	vldr	s0, [pc, #500]	; 2b260 <__ieee754_rem_pio2f+0x254>
   2b06e:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 2b264 <__ieee754_rem_pio2f+0x258>
   2b072:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2b076:	ee77 6ac7 	vsub.f32	s13, s15, s14
   2b07a:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2b07e:	edc0 6a00 	vstr	s13, [r0]
   2b082:	e7eb      	b.n	2b05c <__ieee754_rem_pio2f+0x50>
   2b084:	429d      	cmp	r5, r3
   2b086:	ee77 7a80 	vadd.f32	s15, s15, s0
   2b08a:	d00e      	beq.n	2b0aa <__ieee754_rem_pio2f+0x9e>
   2b08c:	ed9f 7a73 	vldr	s14, [pc, #460]	; 2b25c <__ieee754_rem_pio2f+0x250>
   2b090:	ee37 0a87 	vadd.f32	s0, s15, s14
   2b094:	ee77 7ac0 	vsub.f32	s15, s15, s0
   2b098:	ed80 0a00 	vstr	s0, [r0]
   2b09c:	ee77 7a87 	vadd.f32	s15, s15, s14
   2b0a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2b0a4:	edc4 7a01 	vstr	s15, [r4, #4]
   2b0a8:	e7dd      	b.n	2b066 <__ieee754_rem_pio2f+0x5a>
   2b0aa:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 2b260 <__ieee754_rem_pio2f+0x254>
   2b0ae:	ed9f 7a6d 	vldr	s14, [pc, #436]	; 2b264 <__ieee754_rem_pio2f+0x258>
   2b0b2:	ee77 7a80 	vadd.f32	s15, s15, s0
   2b0b6:	ee77 6a87 	vadd.f32	s13, s15, s14
   2b0ba:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2b0be:	edc0 6a00 	vstr	s13, [r0]
   2b0c2:	e7eb      	b.n	2b09c <__ieee754_rem_pio2f+0x90>
   2b0c4:	4b68      	ldr	r3, [pc, #416]	; (2b268 <__ieee754_rem_pio2f+0x25c>)
   2b0c6:	429d      	cmp	r5, r3
   2b0c8:	dc72      	bgt.n	2b1b0 <__ieee754_rem_pio2f+0x1a4>
   2b0ca:	f005 fea8 	bl	30e1e <fabsf>
   2b0ce:	ed9f 7a67 	vldr	s14, [pc, #412]	; 2b26c <__ieee754_rem_pio2f+0x260>
   2b0d2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2b0d6:	eee0 7a07 	vfma.f32	s15, s0, s14
   2b0da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2b0de:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2b0e2:	ee17 0a90 	vmov	r0, s15
   2b0e6:	eddf 7a5b 	vldr	s15, [pc, #364]	; 2b254 <__ieee754_rem_pio2f+0x248>
   2b0ea:	eea7 0a67 	vfms.f32	s0, s14, s15
   2b0ee:	281f      	cmp	r0, #31
   2b0f0:	eddf 7a5a 	vldr	s15, [pc, #360]	; 2b25c <__ieee754_rem_pio2f+0x250>
   2b0f4:	ee67 7a27 	vmul.f32	s15, s14, s15
   2b0f8:	eeb1 6a47 	vneg.f32	s12, s14
   2b0fc:	ee70 6a67 	vsub.f32	s13, s0, s15
   2b100:	ee16 2a90 	vmov	r2, s13
   2b104:	dc1c      	bgt.n	2b140 <__ieee754_rem_pio2f+0x134>
   2b106:	495a      	ldr	r1, [pc, #360]	; (2b270 <__ieee754_rem_pio2f+0x264>)
   2b108:	1e47      	subs	r7, r0, #1
   2b10a:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
   2b10e:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
   2b112:	428b      	cmp	r3, r1
   2b114:	d014      	beq.n	2b140 <__ieee754_rem_pio2f+0x134>
   2b116:	6022      	str	r2, [r4, #0]
   2b118:	ed94 7a00 	vldr	s14, [r4]
   2b11c:	ee30 0a47 	vsub.f32	s0, s0, s14
   2b120:	2e00      	cmp	r6, #0
   2b122:	ee30 0a67 	vsub.f32	s0, s0, s15
   2b126:	ed84 0a01 	vstr	s0, [r4, #4]
   2b12a:	da9c      	bge.n	2b066 <__ieee754_rem_pio2f+0x5a>
   2b12c:	eeb1 7a47 	vneg.f32	s14, s14
   2b130:	eeb1 0a40 	vneg.f32	s0, s0
   2b134:	ed84 7a00 	vstr	s14, [r4]
   2b138:	ed84 0a01 	vstr	s0, [r4, #4]
   2b13c:	4240      	negs	r0, r0
   2b13e:	e792      	b.n	2b066 <__ieee754_rem_pio2f+0x5a>
   2b140:	f3c2 51c7 	ubfx	r1, r2, #23, #8
   2b144:	15eb      	asrs	r3, r5, #23
   2b146:	ebc1 55d5 	rsb	r5, r1, r5, lsr #23
   2b14a:	2d08      	cmp	r5, #8
   2b14c:	dde3      	ble.n	2b116 <__ieee754_rem_pio2f+0x10a>
   2b14e:	eddf 7a44 	vldr	s15, [pc, #272]	; 2b260 <__ieee754_rem_pio2f+0x254>
   2b152:	eddf 5a44 	vldr	s11, [pc, #272]	; 2b264 <__ieee754_rem_pio2f+0x258>
   2b156:	eef0 6a40 	vmov.f32	s13, s0
   2b15a:	eee6 6a27 	vfma.f32	s13, s12, s15
   2b15e:	ee30 0a66 	vsub.f32	s0, s0, s13
   2b162:	eea6 0a27 	vfma.f32	s0, s12, s15
   2b166:	eef0 7a40 	vmov.f32	s15, s0
   2b16a:	eed7 7a25 	vfnms.f32	s15, s14, s11
   2b16e:	ee76 5ae7 	vsub.f32	s11, s13, s15
   2b172:	ee15 2a90 	vmov	r2, s11
   2b176:	f3c2 51c7 	ubfx	r1, r2, #23, #8
   2b17a:	1a5b      	subs	r3, r3, r1
   2b17c:	2b19      	cmp	r3, #25
   2b17e:	dc04      	bgt.n	2b18a <__ieee754_rem_pio2f+0x17e>
   2b180:	edc4 5a00 	vstr	s11, [r4]
   2b184:	eeb0 0a66 	vmov.f32	s0, s13
   2b188:	e7c6      	b.n	2b118 <__ieee754_rem_pio2f+0x10c>
   2b18a:	eddf 5a3a 	vldr	s11, [pc, #232]	; 2b274 <__ieee754_rem_pio2f+0x268>
   2b18e:	eeb0 0a66 	vmov.f32	s0, s13
   2b192:	eea6 0a25 	vfma.f32	s0, s12, s11
   2b196:	ee76 7ac0 	vsub.f32	s15, s13, s0
   2b19a:	eddf 6a37 	vldr	s13, [pc, #220]	; 2b278 <__ieee754_rem_pio2f+0x26c>
   2b19e:	eee6 7a25 	vfma.f32	s15, s12, s11
   2b1a2:	eed7 7a26 	vfnms.f32	s15, s14, s13
   2b1a6:	ee30 7a67 	vsub.f32	s14, s0, s15
   2b1aa:	ed84 7a00 	vstr	s14, [r4]
   2b1ae:	e7b3      	b.n	2b118 <__ieee754_rem_pio2f+0x10c>
   2b1b0:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
   2b1b4:	db06      	blt.n	2b1c4 <__ieee754_rem_pio2f+0x1b8>
   2b1b6:	ee70 7a40 	vsub.f32	s15, s0, s0
   2b1ba:	edc0 7a01 	vstr	s15, [r0, #4]
   2b1be:	edc0 7a00 	vstr	s15, [r0]
   2b1c2:	e733      	b.n	2b02c <__ieee754_rem_pio2f+0x20>
   2b1c4:	15ea      	asrs	r2, r5, #23
   2b1c6:	3a86      	subs	r2, #134	; 0x86
   2b1c8:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
   2b1cc:	ee07 3a90 	vmov	s15, r3
   2b1d0:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2b1d4:	eddf 6a29 	vldr	s13, [pc, #164]	; 2b27c <__ieee754_rem_pio2f+0x270>
   2b1d8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2b1dc:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b1e0:	ed8d 7a03 	vstr	s14, [sp, #12]
   2b1e4:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2b1e8:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   2b1ec:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   2b1f0:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b1f4:	ed8d 7a04 	vstr	s14, [sp, #16]
   2b1f8:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2b1fc:	eef5 7a40 	vcmp.f32	s15, #0.0
   2b200:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b204:	edcd 7a05 	vstr	s15, [sp, #20]
   2b208:	d11e      	bne.n	2b248 <__ieee754_rem_pio2f+0x23c>
   2b20a:	eeb5 7a40 	vcmp.f32	s14, #0.0
   2b20e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b212:	bf14      	ite	ne
   2b214:	2302      	movne	r3, #2
   2b216:	2301      	moveq	r3, #1
   2b218:	4919      	ldr	r1, [pc, #100]	; (2b280 <__ieee754_rem_pio2f+0x274>)
   2b21a:	9101      	str	r1, [sp, #4]
   2b21c:	2102      	movs	r1, #2
   2b21e:	9100      	str	r1, [sp, #0]
   2b220:	a803      	add	r0, sp, #12
   2b222:	4621      	mov	r1, r4
   2b224:	f000 f88e 	bl	2b344 <__kernel_rem_pio2f>
   2b228:	2e00      	cmp	r6, #0
   2b22a:	f6bf af1c 	bge.w	2b066 <__ieee754_rem_pio2f+0x5a>
   2b22e:	edd4 7a00 	vldr	s15, [r4]
   2b232:	eef1 7a67 	vneg.f32	s15, s15
   2b236:	edc4 7a00 	vstr	s15, [r4]
   2b23a:	edd4 7a01 	vldr	s15, [r4, #4]
   2b23e:	eef1 7a67 	vneg.f32	s15, s15
   2b242:	edc4 7a01 	vstr	s15, [r4, #4]
   2b246:	e779      	b.n	2b13c <__ieee754_rem_pio2f+0x130>
   2b248:	2303      	movs	r3, #3
   2b24a:	e7e5      	b.n	2b218 <__ieee754_rem_pio2f+0x20c>
   2b24c:	3f490fd8 	.word	0x3f490fd8
   2b250:	4016cbe3 	.word	0x4016cbe3
   2b254:	3fc90f80 	.word	0x3fc90f80
   2b258:	3fc90fd0 	.word	0x3fc90fd0
   2b25c:	37354443 	.word	0x37354443
   2b260:	37354400 	.word	0x37354400
   2b264:	2e85a308 	.word	0x2e85a308
   2b268:	43490f80 	.word	0x43490f80
   2b26c:	3f22f984 	.word	0x3f22f984
   2b270:	0003c0f4 	.word	0x0003c0f4
   2b274:	2e85a300 	.word	0x2e85a300
   2b278:	248d3132 	.word	0x248d3132
   2b27c:	43800000 	.word	0x43800000
   2b280:	0003c174 	.word	0x0003c174

0002b284 <__kernel_cosf>:
   2b284:	ee10 3a10 	vmov	r3, s0
   2b288:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2b28c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   2b290:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   2b294:	da05      	bge.n	2b2a2 <__kernel_cosf+0x1e>
   2b296:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2b29a:	ee17 2a90 	vmov	r2, s15
   2b29e:	2a00      	cmp	r2, #0
   2b2a0:	d03d      	beq.n	2b31e <__kernel_cosf+0x9a>
   2b2a2:	ee60 5a00 	vmul.f32	s11, s0, s0
   2b2a6:	eddf 7a1f 	vldr	s15, [pc, #124]	; 2b324 <__kernel_cosf+0xa0>
   2b2aa:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 2b328 <__kernel_cosf+0xa4>
   2b2ae:	eddf 6a1f 	vldr	s13, [pc, #124]	; 2b32c <__kernel_cosf+0xa8>
   2b2b2:	4a1f      	ldr	r2, [pc, #124]	; (2b330 <__kernel_cosf+0xac>)
   2b2b4:	eea5 7aa7 	vfma.f32	s14, s11, s15
   2b2b8:	4293      	cmp	r3, r2
   2b2ba:	eddf 7a1e 	vldr	s15, [pc, #120]	; 2b334 <__kernel_cosf+0xb0>
   2b2be:	eee7 7a25 	vfma.f32	s15, s14, s11
   2b2c2:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 2b338 <__kernel_cosf+0xb4>
   2b2c6:	eea7 7aa5 	vfma.f32	s14, s15, s11
   2b2ca:	eddf 7a1c 	vldr	s15, [pc, #112]	; 2b33c <__kernel_cosf+0xb8>
   2b2ce:	eee7 7a25 	vfma.f32	s15, s14, s11
   2b2d2:	eeb0 7a66 	vmov.f32	s14, s13
   2b2d6:	eea7 7aa5 	vfma.f32	s14, s15, s11
   2b2da:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
   2b2de:	ee65 7aa6 	vmul.f32	s15, s11, s13
   2b2e2:	ee67 6a25 	vmul.f32	s13, s14, s11
   2b2e6:	ee20 7ac0 	vnmul.f32	s14, s1, s0
   2b2ea:	eea5 7aa6 	vfma.f32	s14, s11, s13
   2b2ee:	dc04      	bgt.n	2b2fa <__kernel_cosf+0x76>
   2b2f0:	ee37 7ac7 	vsub.f32	s14, s15, s14
   2b2f4:	ee36 0a47 	vsub.f32	s0, s12, s14
   2b2f8:	4770      	bx	lr
   2b2fa:	4a11      	ldr	r2, [pc, #68]	; (2b340 <__kernel_cosf+0xbc>)
   2b2fc:	4293      	cmp	r3, r2
   2b2fe:	bfda      	itte	le
   2b300:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
   2b304:	ee06 3a90 	vmovle	s13, r3
   2b308:	eef5 6a02 	vmovgt.f32	s13, #82	; 0x3e900000  0.2812500
   2b30c:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2b310:	ee36 0a66 	vsub.f32	s0, s12, s13
   2b314:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b318:	ee30 0a67 	vsub.f32	s0, s0, s15
   2b31c:	4770      	bx	lr
   2b31e:	eeb0 0a46 	vmov.f32	s0, s12
   2b322:	4770      	bx	lr
   2b324:	ad47d74e 	.word	0xad47d74e
   2b328:	310f74f6 	.word	0x310f74f6
   2b32c:	3d2aaaab 	.word	0x3d2aaaab
   2b330:	3e999999 	.word	0x3e999999
   2b334:	b493f27c 	.word	0xb493f27c
   2b338:	37d00d01 	.word	0x37d00d01
   2b33c:	bab60b61 	.word	0xbab60b61
   2b340:	3f480000 	.word	0x3f480000

0002b344 <__kernel_rem_pio2f>:
   2b344:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b348:	ed2d 8b04 	vpush	{d8-d9}
   2b34c:	b0d9      	sub	sp, #356	; 0x164
   2b34e:	4688      	mov	r8, r1
   2b350:	9002      	str	r0, [sp, #8]
   2b352:	49ba      	ldr	r1, [pc, #744]	; (2b63c <__kernel_rem_pio2f+0x2f8>)
   2b354:	9866      	ldr	r0, [sp, #408]	; 0x198
   2b356:	9301      	str	r3, [sp, #4]
   2b358:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
   2b35c:	f8dd e19c 	ldr.w	lr, [sp, #412]	; 0x19c
   2b360:	1e59      	subs	r1, r3, #1
   2b362:	1d13      	adds	r3, r2, #4
   2b364:	db27      	blt.n	2b3b6 <__kernel_rem_pio2f+0x72>
   2b366:	f1b2 0b03 	subs.w	fp, r2, #3
   2b36a:	bf48      	it	mi
   2b36c:	f102 0b04 	addmi.w	fp, r2, #4
   2b370:	ea4f 00eb 	mov.w	r0, fp, asr #3
   2b374:	1c45      	adds	r5, r0, #1
   2b376:	00ec      	lsls	r4, r5, #3
   2b378:	1a47      	subs	r7, r0, r1
   2b37a:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b37e:	9403      	str	r4, [sp, #12]
   2b380:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
   2b384:	eb0a 0c01 	add.w	ip, sl, r1
   2b388:	ae1c      	add	r6, sp, #112	; 0x70
   2b38a:	eb0e 0987 	add.w	r9, lr, r7, lsl #2
   2b38e:	2400      	movs	r4, #0
   2b390:	4564      	cmp	r4, ip
   2b392:	dd12      	ble.n	2b3ba <__kernel_rem_pio2f+0x76>
   2b394:	9b01      	ldr	r3, [sp, #4]
   2b396:	ac1c      	add	r4, sp, #112	; 0x70
   2b398:	eb04 0483 	add.w	r4, r4, r3, lsl #2
   2b39c:	f50d 7b88 	add.w	fp, sp, #272	; 0x110
   2b3a0:	f04f 0c00 	mov.w	ip, #0
   2b3a4:	45d4      	cmp	ip, sl
   2b3a6:	dc27      	bgt.n	2b3f8 <__kernel_rem_pio2f+0xb4>
   2b3a8:	f8dd 9008 	ldr.w	r9, [sp, #8]
   2b3ac:	eddf 7aa7 	vldr	s15, [pc, #668]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b3b0:	4627      	mov	r7, r4
   2b3b2:	2600      	movs	r6, #0
   2b3b4:	e016      	b.n	2b3e4 <__kernel_rem_pio2f+0xa0>
   2b3b6:	2000      	movs	r0, #0
   2b3b8:	e7dc      	b.n	2b374 <__kernel_rem_pio2f+0x30>
   2b3ba:	42e7      	cmn	r7, r4
   2b3bc:	bf5d      	ittte	pl
   2b3be:	f859 3024 	ldrpl.w	r3, [r9, r4, lsl #2]
   2b3c2:	ee07 3a90 	vmovpl	s15, r3
   2b3c6:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
   2b3ca:	eef0 7a47 	vmovmi.f32	s15, s14
   2b3ce:	ece6 7a01 	vstmia	r6!, {s15}
   2b3d2:	3401      	adds	r4, #1
   2b3d4:	e7dc      	b.n	2b390 <__kernel_rem_pio2f+0x4c>
   2b3d6:	ecf9 6a01 	vldmia	r9!, {s13}
   2b3da:	ed97 7a00 	vldr	s14, [r7]
   2b3de:	eee6 7a87 	vfma.f32	s15, s13, s14
   2b3e2:	3601      	adds	r6, #1
   2b3e4:	428e      	cmp	r6, r1
   2b3e6:	f1a7 0704 	sub.w	r7, r7, #4
   2b3ea:	ddf4      	ble.n	2b3d6 <__kernel_rem_pio2f+0x92>
   2b3ec:	eceb 7a01 	vstmia	fp!, {s15}
   2b3f0:	f10c 0c01 	add.w	ip, ip, #1
   2b3f4:	3404      	adds	r4, #4
   2b3f6:	e7d5      	b.n	2b3a4 <__kernel_rem_pio2f+0x60>
   2b3f8:	ab08      	add	r3, sp, #32
   2b3fa:	eb03 038a 	add.w	r3, r3, sl, lsl #2
   2b3fe:	eddf 8a92 	vldr	s17, [pc, #584]	; 2b648 <__kernel_rem_pio2f+0x304>
   2b402:	ed9f 9a90 	vldr	s18, [pc, #576]	; 2b644 <__kernel_rem_pio2f+0x300>
   2b406:	9304      	str	r3, [sp, #16]
   2b408:	eb0e 0b80 	add.w	fp, lr, r0, lsl #2
   2b40c:	4656      	mov	r6, sl
   2b40e:	00b3      	lsls	r3, r6, #2
   2b410:	9305      	str	r3, [sp, #20]
   2b412:	ab58      	add	r3, sp, #352	; 0x160
   2b414:	eb03 0086 	add.w	r0, r3, r6, lsl #2
   2b418:	ac08      	add	r4, sp, #32
   2b41a:	ab44      	add	r3, sp, #272	; 0x110
   2b41c:	ed10 0a14 	vldr	s0, [r0, #-80]	; 0xffffffb0
   2b420:	46a4      	mov	ip, r4
   2b422:	eb03 0086 	add.w	r0, r3, r6, lsl #2
   2b426:	4637      	mov	r7, r6
   2b428:	2f00      	cmp	r7, #0
   2b42a:	f1a0 0004 	sub.w	r0, r0, #4
   2b42e:	dc4e      	bgt.n	2b4ce <__kernel_rem_pio2f+0x18a>
   2b430:	4628      	mov	r0, r5
   2b432:	e9cd 1206 	strd	r1, r2, [sp, #24]
   2b436:	f000 fa83 	bl	2b940 <scalbnf>
   2b43a:	eeb0 8a40 	vmov.f32	s16, s0
   2b43e:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
   2b442:	ee28 0a00 	vmul.f32	s0, s16, s0
   2b446:	f000 fa39 	bl	2b8bc <floorf>
   2b44a:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   2b44e:	eea0 8a67 	vfms.f32	s16, s0, s15
   2b452:	2d00      	cmp	r5, #0
   2b454:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
   2b458:	eefd 7ac8 	vcvt.s32.f32	s15, s16
   2b45c:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
   2b460:	ee17 9a90 	vmov	r9, s15
   2b464:	ee38 8a40 	vsub.f32	s16, s16, s0
   2b468:	dd43      	ble.n	2b4f2 <__kernel_rem_pio2f+0x1ae>
   2b46a:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
   2b46e:	ab08      	add	r3, sp, #32
   2b470:	f1c5 0e08 	rsb	lr, r5, #8
   2b474:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
   2b478:	fa47 f00e 	asr.w	r0, r7, lr
   2b47c:	4481      	add	r9, r0
   2b47e:	fa00 f00e 	lsl.w	r0, r0, lr
   2b482:	1a3f      	subs	r7, r7, r0
   2b484:	f1c5 0007 	rsb	r0, r5, #7
   2b488:	f843 702c 	str.w	r7, [r3, ip, lsl #2]
   2b48c:	4107      	asrs	r7, r0
   2b48e:	2f00      	cmp	r7, #0
   2b490:	dd3e      	ble.n	2b510 <__kernel_rem_pio2f+0x1cc>
   2b492:	f04f 0e00 	mov.w	lr, #0
   2b496:	f109 0901 	add.w	r9, r9, #1
   2b49a:	4673      	mov	r3, lr
   2b49c:	4576      	cmp	r6, lr
   2b49e:	dc69      	bgt.n	2b574 <__kernel_rem_pio2f+0x230>
   2b4a0:	2d00      	cmp	r5, #0
   2b4a2:	dd03      	ble.n	2b4ac <__kernel_rem_pio2f+0x168>
   2b4a4:	2d01      	cmp	r5, #1
   2b4a6:	d076      	beq.n	2b596 <__kernel_rem_pio2f+0x252>
   2b4a8:	2d02      	cmp	r5, #2
   2b4aa:	d07f      	beq.n	2b5ac <__kernel_rem_pio2f+0x268>
   2b4ac:	2f02      	cmp	r7, #2
   2b4ae:	d12f      	bne.n	2b510 <__kernel_rem_pio2f+0x1cc>
   2b4b0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2b4b4:	ee30 8a48 	vsub.f32	s16, s0, s16
   2b4b8:	b353      	cbz	r3, 2b510 <__kernel_rem_pio2f+0x1cc>
   2b4ba:	4628      	mov	r0, r5
   2b4bc:	e9cd 1206 	strd	r1, r2, [sp, #24]
   2b4c0:	f000 fa3e 	bl	2b940 <scalbnf>
   2b4c4:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
   2b4c8:	ee38 8a40 	vsub.f32	s16, s16, s0
   2b4cc:	e020      	b.n	2b510 <__kernel_rem_pio2f+0x1cc>
   2b4ce:	ee60 7a28 	vmul.f32	s15, s0, s17
   2b4d2:	3f01      	subs	r7, #1
   2b4d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2b4d8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2b4dc:	eea7 0ac9 	vfms.f32	s0, s15, s18
   2b4e0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2b4e4:	ecac 0a01 	vstmia	ip!, {s0}
   2b4e8:	ed90 0a00 	vldr	s0, [r0]
   2b4ec:	ee37 0a80 	vadd.f32	s0, s15, s0
   2b4f0:	e79a      	b.n	2b428 <__kernel_rem_pio2f+0xe4>
   2b4f2:	d105      	bne.n	2b500 <__kernel_rem_pio2f+0x1bc>
   2b4f4:	1e70      	subs	r0, r6, #1
   2b4f6:	ab08      	add	r3, sp, #32
   2b4f8:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
   2b4fc:	123f      	asrs	r7, r7, #8
   2b4fe:	e7c6      	b.n	2b48e <__kernel_rem_pio2f+0x14a>
   2b500:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2b504:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2b508:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b50c:	da30      	bge.n	2b570 <__kernel_rem_pio2f+0x22c>
   2b50e:	2700      	movs	r7, #0
   2b510:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2b514:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b518:	f040 809a 	bne.w	2b650 <__kernel_rem_pio2f+0x30c>
   2b51c:	1e74      	subs	r4, r6, #1
   2b51e:	46a4      	mov	ip, r4
   2b520:	2000      	movs	r0, #0
   2b522:	45d4      	cmp	ip, sl
   2b524:	da49      	bge.n	2b5ba <__kernel_rem_pio2f+0x276>
   2b526:	2800      	cmp	r0, #0
   2b528:	d078      	beq.n	2b61c <__kernel_rem_pio2f+0x2d8>
   2b52a:	ab08      	add	r3, sp, #32
   2b52c:	3d08      	subs	r5, #8
   2b52e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   2b532:	2b00      	cmp	r3, #0
   2b534:	d07f      	beq.n	2b636 <__kernel_rem_pio2f+0x2f2>
   2b536:	4628      	mov	r0, r5
   2b538:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2b53c:	00a5      	lsls	r5, r4, #2
   2b53e:	f000 f9ff 	bl	2b940 <scalbnf>
   2b542:	aa44      	add	r2, sp, #272	; 0x110
   2b544:	1d2b      	adds	r3, r5, #4
   2b546:	ed9f 7a40 	vldr	s14, [pc, #256]	; 2b648 <__kernel_rem_pio2f+0x304>
   2b54a:	18d1      	adds	r1, r2, r3
   2b54c:	4622      	mov	r2, r4
   2b54e:	2a00      	cmp	r2, #0
   2b550:	f280 80ae 	bge.w	2b6b0 <__kernel_rem_pio2f+0x36c>
   2b554:	4622      	mov	r2, r4
   2b556:	2a00      	cmp	r2, #0
   2b558:	f2c0 80cc 	blt.w	2b6f4 <__kernel_rem_pio2f+0x3b0>
   2b55c:	a944      	add	r1, sp, #272	; 0x110
   2b55e:	eb01 0682 	add.w	r6, r1, r2, lsl #2
   2b562:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 2b640 <__kernel_rem_pio2f+0x2fc>
   2b566:	eddf 7a39 	vldr	s15, [pc, #228]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b56a:	2000      	movs	r0, #0
   2b56c:	1aa1      	subs	r1, r4, r2
   2b56e:	e0b6      	b.n	2b6de <__kernel_rem_pio2f+0x39a>
   2b570:	2702      	movs	r7, #2
   2b572:	e78e      	b.n	2b492 <__kernel_rem_pio2f+0x14e>
   2b574:	6820      	ldr	r0, [r4, #0]
   2b576:	b94b      	cbnz	r3, 2b58c <__kernel_rem_pio2f+0x248>
   2b578:	b118      	cbz	r0, 2b582 <__kernel_rem_pio2f+0x23e>
   2b57a:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
   2b57e:	6020      	str	r0, [r4, #0]
   2b580:	2001      	movs	r0, #1
   2b582:	f10e 0e01 	add.w	lr, lr, #1
   2b586:	3404      	adds	r4, #4
   2b588:	4603      	mov	r3, r0
   2b58a:	e787      	b.n	2b49c <__kernel_rem_pio2f+0x158>
   2b58c:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
   2b590:	6020      	str	r0, [r4, #0]
   2b592:	4618      	mov	r0, r3
   2b594:	e7f5      	b.n	2b582 <__kernel_rem_pio2f+0x23e>
   2b596:	1e74      	subs	r4, r6, #1
   2b598:	a808      	add	r0, sp, #32
   2b59a:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
   2b59e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   2b5a2:	f10d 0c20 	add.w	ip, sp, #32
   2b5a6:	f84c 0024 	str.w	r0, [ip, r4, lsl #2]
   2b5aa:	e77f      	b.n	2b4ac <__kernel_rem_pio2f+0x168>
   2b5ac:	1e74      	subs	r4, r6, #1
   2b5ae:	a808      	add	r0, sp, #32
   2b5b0:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
   2b5b4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   2b5b8:	e7f3      	b.n	2b5a2 <__kernel_rem_pio2f+0x25e>
   2b5ba:	ab08      	add	r3, sp, #32
   2b5bc:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
   2b5c0:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   2b5c4:	4318      	orrs	r0, r3
   2b5c6:	e7ac      	b.n	2b522 <__kernel_rem_pio2f+0x1de>
   2b5c8:	f10c 0c01 	add.w	ip, ip, #1
   2b5cc:	f850 4d04 	ldr.w	r4, [r0, #-4]!
   2b5d0:	2c00      	cmp	r4, #0
   2b5d2:	d0f9      	beq.n	2b5c8 <__kernel_rem_pio2f+0x284>
   2b5d4:	9b05      	ldr	r3, [sp, #20]
   2b5d6:	a858      	add	r0, sp, #352	; 0x160
   2b5d8:	4403      	add	r3, r0
   2b5da:	f1a3 004c 	sub.w	r0, r3, #76	; 0x4c
   2b5de:	9b01      	ldr	r3, [sp, #4]
   2b5e0:	18f4      	adds	r4, r6, r3
   2b5e2:	ab1c      	add	r3, sp, #112	; 0x70
   2b5e4:	1c77      	adds	r7, r6, #1
   2b5e6:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2b5ea:	4466      	add	r6, ip
   2b5ec:	42be      	cmp	r6, r7
   2b5ee:	f6ff af0e 	blt.w	2b40e <__kernel_rem_pio2f+0xca>
   2b5f2:	f85b 3027 	ldr.w	r3, [fp, r7, lsl #2]
   2b5f6:	f8dd e008 	ldr.w	lr, [sp, #8]
   2b5fa:	ee07 3a90 	vmov	s15, r3
   2b5fe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2b602:	f04f 0c00 	mov.w	ip, #0
   2b606:	ece4 7a01 	vstmia	r4!, {s15}
   2b60a:	eddf 7a10 	vldr	s15, [pc, #64]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b60e:	46a1      	mov	r9, r4
   2b610:	458c      	cmp	ip, r1
   2b612:	dd07      	ble.n	2b624 <__kernel_rem_pio2f+0x2e0>
   2b614:	ece0 7a01 	vstmia	r0!, {s15}
   2b618:	3701      	adds	r7, #1
   2b61a:	e7e7      	b.n	2b5ec <__kernel_rem_pio2f+0x2a8>
   2b61c:	9804      	ldr	r0, [sp, #16]
   2b61e:	f04f 0c01 	mov.w	ip, #1
   2b622:	e7d3      	b.n	2b5cc <__kernel_rem_pio2f+0x288>
   2b624:	ecfe 6a01 	vldmia	lr!, {s13}
   2b628:	ed39 7a01 	vldmdb	r9!, {s14}
   2b62c:	f10c 0c01 	add.w	ip, ip, #1
   2b630:	eee6 7a87 	vfma.f32	s15, s13, s14
   2b634:	e7ec      	b.n	2b610 <__kernel_rem_pio2f+0x2cc>
   2b636:	3c01      	subs	r4, #1
   2b638:	e777      	b.n	2b52a <__kernel_rem_pio2f+0x1e6>
   2b63a:	bf00      	nop
   2b63c:	0003c4b8 	.word	0x0003c4b8
   2b640:	0003c48c 	.word	0x0003c48c
   2b644:	43800000 	.word	0x43800000
   2b648:	3b800000 	.word	0x3b800000
   2b64c:	00000000 	.word	0x00000000
   2b650:	9b03      	ldr	r3, [sp, #12]
   2b652:	eeb0 0a48 	vmov.f32	s0, s16
   2b656:	1a98      	subs	r0, r3, r2
   2b658:	f000 f972 	bl	2b940 <scalbnf>
   2b65c:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 2b644 <__kernel_rem_pio2f+0x300>
   2b660:	eeb4 0ac7 	vcmpe.f32	s0, s14
   2b664:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b668:	db19      	blt.n	2b69e <__kernel_rem_pio2f+0x35a>
   2b66a:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 2b648 <__kernel_rem_pio2f+0x304>
   2b66e:	ee60 7a27 	vmul.f32	s15, s0, s15
   2b672:	aa08      	add	r2, sp, #32
   2b674:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2b678:	1c74      	adds	r4, r6, #1
   2b67a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2b67e:	3508      	adds	r5, #8
   2b680:	eea7 0ac7 	vfms.f32	s0, s15, s14
   2b684:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   2b688:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2b68c:	ee10 3a10 	vmov	r3, s0
   2b690:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
   2b694:	ee17 3a90 	vmov	r3, s15
   2b698:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
   2b69c:	e74b      	b.n	2b536 <__kernel_rem_pio2f+0x1f2>
   2b69e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   2b6a2:	aa08      	add	r2, sp, #32
   2b6a4:	ee10 3a10 	vmov	r3, s0
   2b6a8:	4634      	mov	r4, r6
   2b6aa:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
   2b6ae:	e742      	b.n	2b536 <__kernel_rem_pio2f+0x1f2>
   2b6b0:	a808      	add	r0, sp, #32
   2b6b2:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
   2b6b6:	9001      	str	r0, [sp, #4]
   2b6b8:	ee07 0a90 	vmov	s15, r0
   2b6bc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2b6c0:	3a01      	subs	r2, #1
   2b6c2:	ee67 7a80 	vmul.f32	s15, s15, s0
   2b6c6:	ee20 0a07 	vmul.f32	s0, s0, s14
   2b6ca:	ed61 7a01 	vstmdb	r1!, {s15}
   2b6ce:	e73e      	b.n	2b54e <__kernel_rem_pio2f+0x20a>
   2b6d0:	ecfc 6a01 	vldmia	ip!, {s13}
   2b6d4:	ecb6 7a01 	vldmia	r6!, {s14}
   2b6d8:	eee6 7a87 	vfma.f32	s15, s13, s14
   2b6dc:	3001      	adds	r0, #1
   2b6de:	4550      	cmp	r0, sl
   2b6e0:	dc01      	bgt.n	2b6e6 <__kernel_rem_pio2f+0x3a2>
   2b6e2:	4288      	cmp	r0, r1
   2b6e4:	ddf4      	ble.n	2b6d0 <__kernel_rem_pio2f+0x38c>
   2b6e6:	a858      	add	r0, sp, #352	; 0x160
   2b6e8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   2b6ec:	ed41 7a28 	vstr	s15, [r1, #-160]	; 0xffffff60
   2b6f0:	3a01      	subs	r2, #1
   2b6f2:	e730      	b.n	2b556 <__kernel_rem_pio2f+0x212>
   2b6f4:	9a66      	ldr	r2, [sp, #408]	; 0x198
   2b6f6:	2a02      	cmp	r2, #2
   2b6f8:	dc09      	bgt.n	2b70e <__kernel_rem_pio2f+0x3ca>
   2b6fa:	2a00      	cmp	r2, #0
   2b6fc:	dc2a      	bgt.n	2b754 <__kernel_rem_pio2f+0x410>
   2b6fe:	d043      	beq.n	2b788 <__kernel_rem_pio2f+0x444>
   2b700:	f009 0007 	and.w	r0, r9, #7
   2b704:	b059      	add	sp, #356	; 0x164
   2b706:	ecbd 8b04 	vpop	{d8-d9}
   2b70a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2b70e:	9b66      	ldr	r3, [sp, #408]	; 0x198
   2b710:	2b03      	cmp	r3, #3
   2b712:	d1f5      	bne.n	2b700 <__kernel_rem_pio2f+0x3bc>
   2b714:	ab30      	add	r3, sp, #192	; 0xc0
   2b716:	442b      	add	r3, r5
   2b718:	461a      	mov	r2, r3
   2b71a:	4619      	mov	r1, r3
   2b71c:	4620      	mov	r0, r4
   2b71e:	2800      	cmp	r0, #0
   2b720:	f1a1 0104 	sub.w	r1, r1, #4
   2b724:	dc51      	bgt.n	2b7ca <__kernel_rem_pio2f+0x486>
   2b726:	4621      	mov	r1, r4
   2b728:	2901      	cmp	r1, #1
   2b72a:	f1a2 0204 	sub.w	r2, r2, #4
   2b72e:	dc5c      	bgt.n	2b7ea <__kernel_rem_pio2f+0x4a6>
   2b730:	ed5f 7a3a 	vldr	s15, [pc, #-232]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b734:	3304      	adds	r3, #4
   2b736:	2c01      	cmp	r4, #1
   2b738:	dc67      	bgt.n	2b80a <__kernel_rem_pio2f+0x4c6>
   2b73a:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
   2b73e:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
   2b742:	2f00      	cmp	r7, #0
   2b744:	d167      	bne.n	2b816 <__kernel_rem_pio2f+0x4d2>
   2b746:	edc8 6a00 	vstr	s13, [r8]
   2b74a:	ed88 7a01 	vstr	s14, [r8, #4]
   2b74e:	edc8 7a02 	vstr	s15, [r8, #8]
   2b752:	e7d5      	b.n	2b700 <__kernel_rem_pio2f+0x3bc>
   2b754:	aa30      	add	r2, sp, #192	; 0xc0
   2b756:	ed1f 7a43 	vldr	s14, [pc, #-268]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b75a:	4413      	add	r3, r2
   2b75c:	4622      	mov	r2, r4
   2b75e:	2a00      	cmp	r2, #0
   2b760:	da24      	bge.n	2b7ac <__kernel_rem_pio2f+0x468>
   2b762:	b34f      	cbz	r7, 2b7b8 <__kernel_rem_pio2f+0x474>
   2b764:	eef1 7a47 	vneg.f32	s15, s14
   2b768:	edc8 7a00 	vstr	s15, [r8]
   2b76c:	eddd 7a30 	vldr	s15, [sp, #192]	; 0xc0
   2b770:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b774:	aa31      	add	r2, sp, #196	; 0xc4
   2b776:	2301      	movs	r3, #1
   2b778:	429c      	cmp	r4, r3
   2b77a:	da20      	bge.n	2b7be <__kernel_rem_pio2f+0x47a>
   2b77c:	b10f      	cbz	r7, 2b782 <__kernel_rem_pio2f+0x43e>
   2b77e:	eef1 7a67 	vneg.f32	s15, s15
   2b782:	edc8 7a01 	vstr	s15, [r8, #4]
   2b786:	e7bb      	b.n	2b700 <__kernel_rem_pio2f+0x3bc>
   2b788:	aa30      	add	r2, sp, #192	; 0xc0
   2b78a:	ed5f 7a50 	vldr	s15, [pc, #-320]	; 2b64c <__kernel_rem_pio2f+0x308>
   2b78e:	4413      	add	r3, r2
   2b790:	2c00      	cmp	r4, #0
   2b792:	da05      	bge.n	2b7a0 <__kernel_rem_pio2f+0x45c>
   2b794:	b10f      	cbz	r7, 2b79a <__kernel_rem_pio2f+0x456>
   2b796:	eef1 7a67 	vneg.f32	s15, s15
   2b79a:	edc8 7a00 	vstr	s15, [r8]
   2b79e:	e7af      	b.n	2b700 <__kernel_rem_pio2f+0x3bc>
   2b7a0:	ed33 7a01 	vldmdb	r3!, {s14}
   2b7a4:	3c01      	subs	r4, #1
   2b7a6:	ee77 7a87 	vadd.f32	s15, s15, s14
   2b7aa:	e7f1      	b.n	2b790 <__kernel_rem_pio2f+0x44c>
   2b7ac:	ed73 7a01 	vldmdb	r3!, {s15}
   2b7b0:	3a01      	subs	r2, #1
   2b7b2:	ee37 7a27 	vadd.f32	s14, s14, s15
   2b7b6:	e7d2      	b.n	2b75e <__kernel_rem_pio2f+0x41a>
   2b7b8:	eef0 7a47 	vmov.f32	s15, s14
   2b7bc:	e7d4      	b.n	2b768 <__kernel_rem_pio2f+0x424>
   2b7be:	ecb2 7a01 	vldmia	r2!, {s14}
   2b7c2:	3301      	adds	r3, #1
   2b7c4:	ee77 7a87 	vadd.f32	s15, s15, s14
   2b7c8:	e7d6      	b.n	2b778 <__kernel_rem_pio2f+0x434>
   2b7ca:	edd1 7a00 	vldr	s15, [r1]
   2b7ce:	edd1 6a01 	vldr	s13, [r1, #4]
   2b7d2:	ee37 7aa6 	vadd.f32	s14, s15, s13
   2b7d6:	3801      	subs	r0, #1
   2b7d8:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b7dc:	ed81 7a00 	vstr	s14, [r1]
   2b7e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2b7e4:	edc1 7a01 	vstr	s15, [r1, #4]
   2b7e8:	e799      	b.n	2b71e <__kernel_rem_pio2f+0x3da>
   2b7ea:	edd2 7a00 	vldr	s15, [r2]
   2b7ee:	edd2 6a01 	vldr	s13, [r2, #4]
   2b7f2:	ee37 7aa6 	vadd.f32	s14, s15, s13
   2b7f6:	3901      	subs	r1, #1
   2b7f8:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2b7fc:	ed82 7a00 	vstr	s14, [r2]
   2b800:	ee77 7aa6 	vadd.f32	s15, s15, s13
   2b804:	edc2 7a01 	vstr	s15, [r2, #4]
   2b808:	e78e      	b.n	2b728 <__kernel_rem_pio2f+0x3e4>
   2b80a:	ed33 7a01 	vldmdb	r3!, {s14}
   2b80e:	3c01      	subs	r4, #1
   2b810:	ee77 7a87 	vadd.f32	s15, s15, s14
   2b814:	e78f      	b.n	2b736 <__kernel_rem_pio2f+0x3f2>
   2b816:	eef1 6a66 	vneg.f32	s13, s13
   2b81a:	eeb1 7a47 	vneg.f32	s14, s14
   2b81e:	edc8 6a00 	vstr	s13, [r8]
   2b822:	ed88 7a01 	vstr	s14, [r8, #4]
   2b826:	eef1 7a67 	vneg.f32	s15, s15
   2b82a:	e790      	b.n	2b74e <__kernel_rem_pio2f+0x40a>

0002b82c <__kernel_sinf>:
   2b82c:	ee10 3a10 	vmov	r3, s0
   2b830:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2b834:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   2b838:	da04      	bge.n	2b844 <__kernel_sinf+0x18>
   2b83a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   2b83e:	ee17 3a90 	vmov	r3, s15
   2b842:	b35b      	cbz	r3, 2b89c <__kernel_sinf+0x70>
   2b844:	ee20 7a00 	vmul.f32	s14, s0, s0
   2b848:	eddf 7a15 	vldr	s15, [pc, #84]	; 2b8a0 <__kernel_sinf+0x74>
   2b84c:	ed9f 6a15 	vldr	s12, [pc, #84]	; 2b8a4 <__kernel_sinf+0x78>
   2b850:	eea7 6a27 	vfma.f32	s12, s14, s15
   2b854:	eddf 7a14 	vldr	s15, [pc, #80]	; 2b8a8 <__kernel_sinf+0x7c>
   2b858:	eee6 7a07 	vfma.f32	s15, s12, s14
   2b85c:	ed9f 6a13 	vldr	s12, [pc, #76]	; 2b8ac <__kernel_sinf+0x80>
   2b860:	eea7 6a87 	vfma.f32	s12, s15, s14
   2b864:	eddf 7a12 	vldr	s15, [pc, #72]	; 2b8b0 <__kernel_sinf+0x84>
   2b868:	ee60 6a07 	vmul.f32	s13, s0, s14
   2b86c:	eee6 7a07 	vfma.f32	s15, s12, s14
   2b870:	b930      	cbnz	r0, 2b880 <__kernel_sinf+0x54>
   2b872:	ed9f 6a10 	vldr	s12, [pc, #64]	; 2b8b4 <__kernel_sinf+0x88>
   2b876:	eea7 6a27 	vfma.f32	s12, s14, s15
   2b87a:	eea6 0a26 	vfma.f32	s0, s12, s13
   2b87e:	4770      	bx	lr
   2b880:	ee67 7ae6 	vnmul.f32	s15, s15, s13
   2b884:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   2b888:	eee0 7a86 	vfma.f32	s15, s1, s12
   2b88c:	eed7 0a87 	vfnms.f32	s1, s15, s14
   2b890:	eddf 7a09 	vldr	s15, [pc, #36]	; 2b8b8 <__kernel_sinf+0x8c>
   2b894:	eee6 0aa7 	vfma.f32	s1, s13, s15
   2b898:	ee30 0a60 	vsub.f32	s0, s0, s1
   2b89c:	4770      	bx	lr
   2b89e:	bf00      	nop
   2b8a0:	2f2ec9d3 	.word	0x2f2ec9d3
   2b8a4:	b2d72f34 	.word	0xb2d72f34
   2b8a8:	3638ef1b 	.word	0x3638ef1b
   2b8ac:	b9500d01 	.word	0xb9500d01
   2b8b0:	3c088889 	.word	0x3c088889
   2b8b4:	be2aaaab 	.word	0xbe2aaaab
   2b8b8:	3e2aaaab 	.word	0x3e2aaaab

0002b8bc <floorf>:
   2b8bc:	ee10 3a10 	vmov	r3, s0
   2b8c0:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   2b8c4:	3a7f      	subs	r2, #127	; 0x7f
   2b8c6:	2a16      	cmp	r2, #22
   2b8c8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
   2b8cc:	dc2a      	bgt.n	2b924 <floorf+0x68>
   2b8ce:	2a00      	cmp	r2, #0
   2b8d0:	da11      	bge.n	2b8f6 <floorf+0x3a>
   2b8d2:	eddf 7a18 	vldr	s15, [pc, #96]	; 2b934 <floorf+0x78>
   2b8d6:	ee30 0a27 	vadd.f32	s0, s0, s15
   2b8da:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2b8de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b8e2:	dd05      	ble.n	2b8f0 <floorf+0x34>
   2b8e4:	2b00      	cmp	r3, #0
   2b8e6:	da23      	bge.n	2b930 <floorf+0x74>
   2b8e8:	4a13      	ldr	r2, [pc, #76]	; (2b938 <floorf+0x7c>)
   2b8ea:	2900      	cmp	r1, #0
   2b8ec:	bf18      	it	ne
   2b8ee:	4613      	movne	r3, r2
   2b8f0:	ee00 3a10 	vmov	s0, r3
   2b8f4:	4770      	bx	lr
   2b8f6:	4911      	ldr	r1, [pc, #68]	; (2b93c <floorf+0x80>)
   2b8f8:	4111      	asrs	r1, r2
   2b8fa:	420b      	tst	r3, r1
   2b8fc:	d0fa      	beq.n	2b8f4 <floorf+0x38>
   2b8fe:	eddf 7a0d 	vldr	s15, [pc, #52]	; 2b934 <floorf+0x78>
   2b902:	ee30 0a27 	vadd.f32	s0, s0, s15
   2b906:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   2b90a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b90e:	ddef      	ble.n	2b8f0 <floorf+0x34>
   2b910:	2b00      	cmp	r3, #0
   2b912:	bfbe      	ittt	lt
   2b914:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
   2b918:	fa40 f202 	asrlt.w	r2, r0, r2
   2b91c:	189b      	addlt	r3, r3, r2
   2b91e:	ea23 0301 	bic.w	r3, r3, r1
   2b922:	e7e5      	b.n	2b8f0 <floorf+0x34>
   2b924:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
   2b928:	d3e4      	bcc.n	2b8f4 <floorf+0x38>
   2b92a:	ee30 0a00 	vadd.f32	s0, s0, s0
   2b92e:	4770      	bx	lr
   2b930:	2300      	movs	r3, #0
   2b932:	e7dd      	b.n	2b8f0 <floorf+0x34>
   2b934:	7149f2ca 	.word	0x7149f2ca
   2b938:	bf800000 	.word	0xbf800000
   2b93c:	007fffff 	.word	0x007fffff

0002b940 <scalbnf>:
   2b940:	ee10 3a10 	vmov	r3, s0
   2b944:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
   2b948:	d025      	beq.n	2b996 <scalbnf+0x56>
   2b94a:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2b94e:	d302      	bcc.n	2b956 <scalbnf+0x16>
   2b950:	ee30 0a00 	vadd.f32	s0, s0, s0
   2b954:	4770      	bx	lr
   2b956:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
   2b95a:	d122      	bne.n	2b9a2 <scalbnf+0x62>
   2b95c:	4b2a      	ldr	r3, [pc, #168]	; (2ba08 <scalbnf+0xc8>)
   2b95e:	eddf 7a2b 	vldr	s15, [pc, #172]	; 2ba0c <scalbnf+0xcc>
   2b962:	4298      	cmp	r0, r3
   2b964:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b968:	db16      	blt.n	2b998 <scalbnf+0x58>
   2b96a:	ee10 3a10 	vmov	r3, s0
   2b96e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   2b972:	3a19      	subs	r2, #25
   2b974:	4402      	add	r2, r0
   2b976:	2afe      	cmp	r2, #254	; 0xfe
   2b978:	dd15      	ble.n	2b9a6 <scalbnf+0x66>
   2b97a:	ee10 3a10 	vmov	r3, s0
   2b97e:	eddf 7a24 	vldr	s15, [pc, #144]	; 2ba10 <scalbnf+0xd0>
   2b982:	eddf 6a24 	vldr	s13, [pc, #144]	; 2ba14 <scalbnf+0xd4>
   2b986:	2b00      	cmp	r3, #0
   2b988:	eeb0 7a67 	vmov.f32	s14, s15
   2b98c:	bfb8      	it	lt
   2b98e:	eef0 7a66 	vmovlt.f32	s15, s13
   2b992:	ee27 0a27 	vmul.f32	s0, s14, s15
   2b996:	4770      	bx	lr
   2b998:	eddf 7a1f 	vldr	s15, [pc, #124]	; 2ba18 <scalbnf+0xd8>
   2b99c:	ee20 0a27 	vmul.f32	s0, s0, s15
   2b9a0:	4770      	bx	lr
   2b9a2:	0dd2      	lsrs	r2, r2, #23
   2b9a4:	e7e6      	b.n	2b974 <scalbnf+0x34>
   2b9a6:	2a00      	cmp	r2, #0
   2b9a8:	dd06      	ble.n	2b9b8 <scalbnf+0x78>
   2b9aa:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   2b9ae:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   2b9b2:	ee00 3a10 	vmov	s0, r3
   2b9b6:	4770      	bx	lr
   2b9b8:	f112 0f16 	cmn.w	r2, #22
   2b9bc:	da1a      	bge.n	2b9f4 <scalbnf+0xb4>
   2b9be:	f24c 3350 	movw	r3, #50000	; 0xc350
   2b9c2:	4298      	cmp	r0, r3
   2b9c4:	ee10 3a10 	vmov	r3, s0
   2b9c8:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
   2b9cc:	dd0a      	ble.n	2b9e4 <scalbnf+0xa4>
   2b9ce:	ed9f 0a10 	vldr	s0, [pc, #64]	; 2ba10 <scalbnf+0xd0>
   2b9d2:	ed9f 7a10 	vldr	s14, [pc, #64]	; 2ba14 <scalbnf+0xd4>
   2b9d6:	eef0 7a40 	vmov.f32	s15, s0
   2b9da:	2b00      	cmp	r3, #0
   2b9dc:	bf18      	it	ne
   2b9de:	eeb0 0a47 	vmovne.f32	s0, s14
   2b9e2:	e7db      	b.n	2b99c <scalbnf+0x5c>
   2b9e4:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 2ba18 <scalbnf+0xd8>
   2b9e8:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 2ba1c <scalbnf+0xdc>
   2b9ec:	eef0 7a40 	vmov.f32	s15, s0
   2b9f0:	2b00      	cmp	r3, #0
   2b9f2:	e7f3      	b.n	2b9dc <scalbnf+0x9c>
   2b9f4:	3219      	adds	r2, #25
   2b9f6:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   2b9fa:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   2b9fe:	eddf 7a08 	vldr	s15, [pc, #32]	; 2ba20 <scalbnf+0xe0>
   2ba02:	ee07 3a10 	vmov	s14, r3
   2ba06:	e7c4      	b.n	2b992 <scalbnf+0x52>
   2ba08:	ffff3cb0 	.word	0xffff3cb0
   2ba0c:	4c000000 	.word	0x4c000000
   2ba10:	7149f2ca 	.word	0x7149f2ca
   2ba14:	f149f2ca 	.word	0xf149f2ca
   2ba18:	0da24260 	.word	0x0da24260
   2ba1c:	8da24260 	.word	0x8da24260
   2ba20:	33000000 	.word	0x33000000

0002ba24 <bsp_match_received_vital>:
{
   2ba24:	b084      	sub	sp, #16
   2ba26:	b510      	push	{r4, lr}
   2ba28:	4684      	mov	ip, r0
   2ba2a:	a803      	add	r0, sp, #12
   2ba2c:	e880 000e 	stmia.w	r0, {r1, r2, r3}
    switch ( vitals_data.vital )
   2ba30:	f89d 200c 	ldrb.w	r2, [sp, #12]
   2ba34:	2a03      	cmp	r2, #3
   2ba36:	d821      	bhi.n	2ba7c <bsp_match_received_vital+0x58>
   2ba38:	e8df f002 	tbb	[pc, r2]
   2ba3c:	1b120e02 	.word	0x1b120e02
            target_ptr = &vitals->temperature;
   2ba40:	4660      	mov	r0, ip
            size = sizeof(vitals->temperature);
   2ba42:	2204      	movs	r2, #4
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;;
   2ba44:	2400      	movs	r4, #0
   2ba46:	f10d 010d 	add.w	r1, sp, #13
   2ba4a:	f005 fa0c 	bl	30e66 <memcpy>
}
   2ba4e:	4620      	mov	r0, r4
   2ba50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2ba54:	b004      	add	sp, #16
   2ba56:	4770      	bx	lr
            target_ptr = &vitals->respiration;
   2ba58:	f10c 0012 	add.w	r0, ip, #18
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;;
   2ba5c:	2400      	movs	r4, #0
        break;
   2ba5e:	e7f2      	b.n	2ba46 <bsp_match_received_vital+0x22>
            target_ptr = &vitals->heart_rate_raw;
   2ba60:	f10c 000c 	add.w	r0, ip, #12
            vitals->heart_rate_raw_len = BSP_HEART_RATE_READINGS_TO_BUFFER;
   2ba64:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
   2ba68:	f8ac 3010 	strh.w	r3, [ip, #16]
            size = sizeof(vitals->heart_rate_raw);
   2ba6c:	2204      	movs	r2, #4
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;;
   2ba6e:	2400      	movs	r4, #0
        break;
   2ba70:	e7e9      	b.n	2ba46 <bsp_match_received_vital+0x22>
            target_ptr = &vitals->acceleration;
   2ba72:	f10c 0004 	add.w	r0, ip, #4
            size = sizeof(vitals->acceleration);
   2ba76:	2204      	movs	r2, #4
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;;
   2ba78:	2400      	movs	r4, #0
        break;
   2ba7a:	e7e4      	b.n	2ba46 <bsp_match_received_vital+0x22>
    switch ( vitals_data.vital )
   2ba7c:	2200      	movs	r2, #0
   2ba7e:	f10d 000d 	add.w	r0, sp, #13
   2ba82:	f06f 0415 	mvn.w	r4, #21
   2ba86:	e7de      	b.n	2ba46 <bsp_match_received_vital+0x22>

0002ba88 <bsp_vital_prepping_work>:
{
   2ba88:	b530      	push	{r4, r5, lr}
   2ba8a:	b089      	sub	sp, #36	; 0x24
   2ba8c:	4604      	mov	r4, r0
    zephyr_err_t err = bsp_sensor_interface_receive_vital( (void*) &vital_data , K_NO_WAIT );
   2ba8e:	2200      	movs	r2, #0
   2ba90:	2300      	movs	r3, #0
   2ba92:	a803      	add	r0, sp, #12
   2ba94:	f7e8 fd10 	bl	144b8 <bsp_sensor_interface_receive_vital>
    if( (ZEPHYR_ERR_SUCCESS == err) && ( work->vitals_set[vital_data.vital] == false ) )
   2ba98:	b920      	cbnz	r0, 2baa4 <bsp_vital_prepping_work+0x1c>
   2ba9a:	f89d 300c 	ldrb.w	r3, [sp, #12]
   2ba9e:	18e2      	adds	r2, r4, r3
   2baa0:	7c12      	ldrb	r2, [r2, #16]
   2baa2:	b10a      	cbz	r2, 2baa8 <bsp_vital_prepping_work+0x20>
}
   2baa4:	b009      	add	sp, #36	; 0x24
   2baa6:	bd30      	pop	{r4, r5, pc}
        work->vitals_set[vital_data.vital] = true;
   2baa8:	4423      	add	r3, r4
   2baaa:	2501      	movs	r5, #1
   2baac:	741d      	strb	r5, [r3, #16]
        err = bsp_match_received_vital( &work->vitals , vital_data );
   2baae:	ab08      	add	r3, sp, #32
   2bab0:	e913 0003 	ldmdb	r3, {r0, r1}
   2bab4:	9000      	str	r0, [sp, #0]
   2bab6:	f8ad 1004 	strh.w	r1, [sp, #4]
   2baba:	ab03      	add	r3, sp, #12
   2babc:	cb0e      	ldmia	r3, {r1, r2, r3}
   2babe:	f104 0014 	add.w	r0, r4, #20
   2bac2:	f7ff ffaf 	bl	2ba24 <bsp_match_received_vital>
        for (uint8_t idx = 0; (idx < VITALS_VITAL_TYPE_ID_MAX) && (all_set == true); idx++)
   2bac6:	2300      	movs	r3, #0
   2bac8:	e004      	b.n	2bad4 <bsp_vital_prepping_work+0x4c>
            all_set = all_set & work->vitals_set[idx];
   2baca:	18e1      	adds	r1, r4, r3
   2bacc:	7c09      	ldrb	r1, [r1, #16]
   2bace:	400d      	ands	r5, r1
        for (uint8_t idx = 0; (idx < VITALS_VITAL_TYPE_ID_MAX) && (all_set == true); idx++)
   2bad0:	3301      	adds	r3, #1
   2bad2:	b2db      	uxtb	r3, r3
   2bad4:	2b03      	cmp	r3, #3
   2bad6:	d801      	bhi.n	2badc <bsp_vital_prepping_work+0x54>
   2bad8:	2d00      	cmp	r5, #0
   2bada:	d1f6      	bne.n	2baca <bsp_vital_prepping_work+0x42>
        if( true == all_set )
   2badc:	2d00      	cmp	r5, #0
   2bade:	d0e1      	beq.n	2baa4 <bsp_vital_prepping_work+0x1c>
            bsp_vital_submit_vital_reading( work->vitals );
   2bae0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2bae2:	9300      	str	r3, [sp, #0]
   2bae4:	f104 0314 	add.w	r3, r4, #20
   2bae8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   2baea:	f7e7 f925 	bl	12d38 <bsp_vital_submit_vital_reading>
__ssp_bos_icheck3(memset, void *, int)
   2baee:	2300      	movs	r3, #0
   2baf0:	6123      	str	r3, [r4, #16]
   2baf2:	e7d7      	b.n	2baa4 <bsp_vital_prepping_work+0x1c>

0002baf4 <ad469x_spi_write_set_bits>:
{
   2baf4:	b570      	push	{r4, r5, r6, lr}
   2baf6:	b082      	sub	sp, #8
   2baf8:	460e      	mov	r6, r1
   2bafa:	4615      	mov	r5, r2
    ret.data = (ret.data >> 8 ) | ( ret.data << 8 );
   2bafc:	0a04      	lsrs	r4, r0, #8
   2bafe:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
   2bb02:	b284      	uxth	r4, r0
    uint8_t reg_data = 0xff;
   2bb04:	23ff      	movs	r3, #255	; 0xff
   2bb06:	f88d 3007 	strb.w	r3, [sp, #7]
    err = ad469x_spi_read( reg , &reg_data);
   2bb0a:	f10d 0107 	add.w	r1, sp, #7
   2bb0e:	4620      	mov	r0, r4
   2bb10:	f7e7 f968 	bl	12de4 <ad469x_spi_read>
    if ( err == ZEPHYR_ERR_SUCCESS )
   2bb14:	b108      	cbz	r0, 2bb1a <ad469x_spi_write_set_bits+0x26>
}
   2bb16:	b002      	add	sp, #8
   2bb18:	bd70      	pop	{r4, r5, r6, pc}
        reg_data &= ~mask;
   2bb1a:	f89d 1007 	ldrb.w	r1, [sp, #7]
   2bb1e:	ea21 0106 	bic.w	r1, r1, r6
   2bb22:	f88d 1007 	strb.w	r1, [sp, #7]
        reg_data |= data;
   2bb26:	4329      	orrs	r1, r5
   2bb28:	f88d 1007 	strb.w	r1, [sp, #7]
        err = ad469x_spi_write(reg , reg_data);
   2bb2c:	4620      	mov	r0, r4
   2bb2e:	f7e7 f97f 	bl	12e30 <ad469x_spi_write>
    return err;
   2bb32:	e7f0      	b.n	2bb16 <ad469x_spi_write_set_bits+0x22>

0002bb34 <bsp_ad469x_reg_write>:
{
   2bb34:	b508      	push	{r3, lr}
    ret.data = (ret.data >> 8 ) | ( ret.data << 8 );
   2bb36:	0a03      	lsrs	r3, r0, #8
    return ret;
   2bb38:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    reg_addr.readwrite = AD469X_WRITE_REGISTER;
   2bb3c:	f36f 10c7 	bfc	r0, #7, #1
    return ad469x_spi_write(reg_addr, data);
   2bb40:	f7e7 f976 	bl	12e30 <ad469x_spi_write>
}
   2bb44:	bd08      	pop	{r3, pc}

0002bb46 <bsp_ad469x_reg_read>:
{
   2bb46:	b508      	push	{r3, lr}
    ret.data = (ret.data >> 8 ) | ( ret.data << 8 );
   2bb48:	0a03      	lsrs	r3, r0, #8
   2bb4a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
   2bb4e:	b280      	uxth	r0, r0
    return ad469x_spi_read(reg_addr, data);
   2bb50:	f040 0080 	orr.w	r0, r0, #128	; 0x80
   2bb54:	f7e7 f946 	bl	12de4 <ad469x_spi_read>
}
   2bb58:	bd08      	pop	{r3, pc}

0002bb5a <bsp_ad469x_set_reg_access_mode>:
{
   2bb5a:	b508      	push	{r3, lr}
                                     AD469x_REG_IF_CONFIG_C_MB_STRICT(access));
   2bb5c:	0142      	lsls	r2, r0, #5
    return ad469x_spi_write_set_bits(AD469x_REG_IF_CONFIG_C, AD469x_REG_IF_CONFIG_C_MB_STRICT_MASK,
   2bb5e:	f002 0220 	and.w	r2, r2, #32
   2bb62:	2120      	movs	r1, #32
   2bb64:	2010      	movs	r0, #16
   2bb66:	f7ff ffc5 	bl	2baf4 <ad469x_spi_write_set_bits>
}
   2bb6a:	bd08      	pop	{r3, pc}

0002bb6c <bsp_ad469x_init_busy>:
{
   2bb6c:	b508      	push	{r3, lr}
    err = bsp_ad469x_reg_write( AD469x_REG_GPIO_CTRL , reg_val );
   2bb6e:	2101      	movs	r1, #1
   2bb70:	2026      	movs	r0, #38	; 0x26
   2bb72:	f7ff ffdf 	bl	2bb34 <bsp_ad469x_reg_write>
    if( ZEPHYR_ERR_SUCCESS == err )
   2bb76:	b100      	cbz	r0, 2bb7a <bsp_ad469x_init_busy+0xe>
}
   2bb78:	bd08      	pop	{r3, pc}
        err = bsp_ad469x_reg_write( AD469x_REG_GP_MODE , reg_val );
   2bb7a:	210e      	movs	r1, #14
   2bb7c:	2027      	movs	r0, #39	; 0x27
   2bb7e:	f7ff ffd9 	bl	2bb34 <bsp_ad469x_reg_write>
    return err;
   2bb82:	e7f9      	b.n	2bb78 <bsp_ad469x_init_busy+0xc>

0002bb84 <bsp_ad469x_trigger_software_reset>:
{
   2bb84:	b510      	push	{r4, lr}
   2bb86:	b082      	sub	sp, #8
    uint8_t reg_val = 0xFF;
   2bb88:	23ff      	movs	r3, #255	; 0xff
   2bb8a:	f88d 3007 	strb.w	r3, [sp, #7]
    zephyr_err_t err = bsp_ad469x_reg_read(AD469x_REG_SPI_CONFIG_A , &reg_val );
   2bb8e:	f10d 0107 	add.w	r1, sp, #7
   2bb92:	2000      	movs	r0, #0
   2bb94:	f7ff ffd7 	bl	2bb46 <bsp_ad469x_reg_read>
    if( ZEPHYR_ERR_SUCCESS == err )
   2bb98:	4604      	mov	r4, r0
   2bb9a:	b130      	cbz	r0, 2bbaa <bsp_ad469x_trigger_software_reset+0x26>
	return z_impl_k_sleep(timeout);
   2bb9c:	200b      	movs	r0, #11
   2bb9e:	2100      	movs	r1, #0
   2bba0:	f7fd f8dc 	bl	28d5c <z_impl_k_sleep>
}
   2bba4:	4620      	mov	r0, r4
   2bba6:	b002      	add	sp, #8
   2bba8:	bd10      	pop	{r4, pc}
        reg_val = reg_val | ( BSP_AD469X_REG_SPI_CONFIG_A_POS_SW_RST_LSB | BSP_AD469X_REG_SPI_CONFIG_A_POS_SW_SW_RST_MSB );
   2bbaa:	f89d 1007 	ldrb.w	r1, [sp, #7]
   2bbae:	f041 0181 	orr.w	r1, r1, #129	; 0x81
   2bbb2:	f88d 1007 	strb.w	r1, [sp, #7]
        err = bsp_ad469x_reg_write( AD469x_REG_SPI_CONFIG_A , reg_val );
   2bbb6:	f7ff ffbd 	bl	2bb34 <bsp_ad469x_reg_write>
   2bbba:	4604      	mov	r4, r0
   2bbbc:	e7ee      	b.n	2bb9c <bsp_ad469x_trigger_software_reset+0x18>

0002bbbe <bsp_ad469x_start_advanced_sequencer>:
{
   2bbbe:	b508      	push	{r3, lr}
    if (enable_disable == true )
   2bbc0:	b118      	cbz	r0, 2bbca <bsp_ad469x_start_advanced_sequencer+0xc>
        err =  bsp_ad469x_set_channel_sequence( AD469X_ADVANCED_SEQ );
   2bbc2:	2003      	movs	r0, #3
   2bbc4:	f7e7 fb6c 	bl	132a0 <bsp_ad469x_set_channel_sequence>
}
   2bbc8:	bd08      	pop	{r3, pc}
        err =  bsp_ad469x_set_channel_sequence( AD469X_SINGLE_CYCLE );
   2bbca:	2000      	movs	r0, #0
   2bbcc:	f7e7 fb68 	bl	132a0 <bsp_ad469x_set_channel_sequence>
    return err;
   2bbd0:	e7fa      	b.n	2bbc8 <bsp_ad469x_start_advanced_sequencer+0xa>

0002bbd2 <bsp_ad469x_setup_advanced_sequencer>:
{
   2bbd2:	b084      	sub	sp, #16
   2bbd4:	b510      	push	{r4, lr}
   2bbd6:	ac02      	add	r4, sp, #8
   2bbd8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    for (uint8_t idx = 0; (idx < as_settings.slots_used) && (err == ZEPHYR_ERR_SUCCESS); idx++ )
   2bbdc:	2400      	movs	r4, #0
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;
   2bbde:	4620      	mov	r0, r4
    for (uint8_t idx = 0; (idx < as_settings.slots_used) && (err == ZEPHYR_ERR_SUCCESS); idx++ )
   2bbe0:	e007      	b.n	2bbf2 <bsp_ad469x_setup_advanced_sequencer+0x20>
        err = bsp_ad469x_adv_sequence_set_slot( idx , as_settings.slots[idx] );
   2bbe2:	ab02      	add	r3, sp, #8
   2bbe4:	4423      	add	r3, r4
   2bbe6:	7859      	ldrb	r1, [r3, #1]
   2bbe8:	4620      	mov	r0, r4
   2bbea:	f7e7 fbc1 	bl	13370 <bsp_ad469x_adv_sequence_set_slot>
    for (uint8_t idx = 0; (idx < as_settings.slots_used) && (err == ZEPHYR_ERR_SUCCESS); idx++ )
   2bbee:	3401      	adds	r4, #1
   2bbf0:	b2e4      	uxtb	r4, r4
   2bbf2:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2bbf6:	42a3      	cmp	r3, r4
   2bbf8:	d901      	bls.n	2bbfe <bsp_ad469x_setup_advanced_sequencer+0x2c>
   2bbfa:	2800      	cmp	r0, #0
   2bbfc:	d0f1      	beq.n	2bbe2 <bsp_ad469x_setup_advanced_sequencer+0x10>
    if( ZEPHYR_ERR_SUCCESS == err )
   2bbfe:	b118      	cbz	r0, 2bc08 <bsp_ad469x_setup_advanced_sequencer+0x36>
}
   2bc00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2bc04:	b004      	add	sp, #16
   2bc06:	4770      	bx	lr
        err =  bsp_ad469x_adv_sequence_set_num_slots( as_settings.slots_used );
   2bc08:	4618      	mov	r0, r3
   2bc0a:	f7e7 fb8f 	bl	1332c <bsp_ad469x_adv_sequence_set_num_slots>
    return err;
   2bc0e:	e7f7      	b.n	2bc00 <bsp_ad469x_setup_advanced_sequencer+0x2e>

0002bc10 <bsp_ad469x_get_num_slots>:
}
   2bc10:	2006      	movs	r0, #6
   2bc12:	4770      	bx	lr

0002bc14 <bsp_adc_event_to_ch>:
    }
}

static uint8_t bsp_adc_event_to_ch( uint32_t event_flags )
{
   2bc14:	4603      	mov	r3, r0
    uint8_t pos = 0;
   2bc16:	2000      	movs	r0, #0
    while ( pos < ( 8*sizeof(uint32_t) ) )
   2bc18:	281f      	cmp	r0, #31
   2bc1a:	d806      	bhi.n	2bc2a <bsp_adc_event_to_ch+0x16>
    {
        /*If the LSB is set in the event flag*/
        if( 0x1 == (event_flags & 0x01) )
   2bc1c:	f013 0f01 	tst.w	r3, #1
   2bc20:	d103      	bne.n	2bc2a <bsp_adc_event_to_ch+0x16>
        {
            break;
        }
        event_flags = event_flags >> 1;
   2bc22:	085b      	lsrs	r3, r3, #1
        pos++;
   2bc24:	3001      	adds	r0, #1
   2bc26:	b2c0      	uxtb	r0, r0
   2bc28:	e7f6      	b.n	2bc18 <bsp_adc_event_to_ch+0x4>
    }
    return pos;
   2bc2a:	4770      	bx	lr

0002bc2c <bsp_adc_get_number_of_channels>:
{
   2bc2c:	b508      	push	{r3, lr}
    return bsp_ad469x_get_num_slots();
   2bc2e:	f7ff ffef 	bl	2bc10 <bsp_ad469x_get_num_slots>
}
   2bc32:	bd08      	pop	{r3, pc}

0002bc34 <bsp_sensor_interface_afe_enable_cb>:
}
   2bc34:	4770      	bx	lr

0002bc36 <bsp_sensor_interface_output_enable_cb>:
}
   2bc36:	4770      	bx	lr

0002bc38 <bsp_sensor_interface_ppg_cb>:
}
   2bc38:	4770      	bx	lr

0002bc3a <bsp_sensor_interface_pause_sampling>:
{
   2bc3a:	b508      	push	{r3, lr}
    bsp_adc_stop_sampling();
   2bc3c:	f7e7 ff9e 	bl	13b7c <bsp_adc_stop_sampling>
}
   2bc40:	bd08      	pop	{r3, pc}

0002bc42 <bsp_sensor_interface_resume_sampling>:
{
   2bc42:	b508      	push	{r3, lr}
    bsp_adc_resume_sampling();
   2bc44:	f7e7 ffa4 	bl	13b90 <bsp_adc_resume_sampling>
}
   2bc48:	bd08      	pop	{r3, pc}

0002bc4a <bsp_sensor_interface_get_sample_rate>:
{
   2bc4a:	b510      	push	{r4, lr}
   2bc4c:	b082      	sub	sp, #8
    return (uint32_t) k_ticks_to_ms_ceil64(bsp_adc_get_period().ticks);
   2bc4e:	4668      	mov	r0, sp
   2bc50:	f7e7 ff8c 	bl	13b6c <bsp_adc_get_period>
   2bc54:	9b00      	ldr	r3, [sp, #0]
   2bc56:	9c01      	ldr	r4, [sp, #4]
   2bc58:	469c      	mov	ip, r3
   2bc5a:	0160      	lsls	r0, r4, #5
   2bc5c:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
   2bc60:	015b      	lsls	r3, r3, #5
   2bc62:	ebb3 030c 	subs.w	r3, r3, ip
   2bc66:	eb60 0004 	sbc.w	r0, r0, r4
   2bc6a:	0081      	lsls	r1, r0, #2
   2bc6c:	ea41 7193 	orr.w	r1, r1, r3, lsr #30
   2bc70:	009a      	lsls	r2, r3, #2
   2bc72:	eb12 020c 	adds.w	r2, r2, ip
   2bc76:	eb41 0104 	adc.w	r1, r1, r4
   2bc7a:	00cb      	lsls	r3, r1, #3
   2bc7c:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   2bc80:	00d0      	lsls	r0, r2, #3
   2bc82:	f647 72ff 	movw	r2, #32767	; 0x7fff
   2bc86:	1880      	adds	r0, r0, r2
   2bc88:	f143 0300 	adc.w	r3, r3, #0
   2bc8c:	0bc0      	lsrs	r0, r0, #15
}
   2bc8e:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   2bc92:	b002      	add	sp, #8
   2bc94:	bd10      	pop	{r4, pc}

0002bc96 <bsp_lc709204f_compute_crc_byte>:

static uint8_t bsp_lc709204f_compute_crc_byte( uint8_t initial_val , uint8_t data )
{
    uint8_t     ret_val = 0;
    uint16_t    temp_val = (data ^ initial_val) << 0x8;
   2bc96:	4048      	eors	r0, r1
   2bc98:	0200      	lsls	r0, r0, #8

    for( uint8_t idx = 0 ; idx < 8 ; idx++ )
   2bc9a:	2300      	movs	r3, #0
   2bc9c:	e003      	b.n	2bca6 <bsp_lc709204f_compute_crc_byte+0x10>
        /*Check if MSB is set*/
        if( temp_val & 0x8000 )
        {
            temp_val ^= CRC_8_ATM_POLY;
        }
        temp_val = temp_val << 0x1;
   2bc9e:	0040      	lsls	r0, r0, #1
   2bca0:	b280      	uxth	r0, r0
    for( uint8_t idx = 0 ; idx < 8 ; idx++ )
   2bca2:	3301      	adds	r3, #1
   2bca4:	b2db      	uxtb	r3, r3
   2bca6:	2b07      	cmp	r3, #7
   2bca8:	d807      	bhi.n	2bcba <bsp_lc709204f_compute_crc_byte+0x24>
        if( temp_val & 0x8000 )
   2bcaa:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   2bcae:	d0f6      	beq.n	2bc9e <bsp_lc709204f_compute_crc_byte+0x8>
            temp_val ^= CRC_8_ATM_POLY;
   2bcb0:	f480 4003 	eor.w	r0, r0, #33536	; 0x8300
   2bcb4:	f080 0080 	eor.w	r0, r0, #128	; 0x80
   2bcb8:	e7f1      	b.n	2bc9e <bsp_lc709204f_compute_crc_byte+0x8>
    }
    ret_val = (temp_val >> 0x8);

    return ret_val;
   2bcba:	0a00      	lsrs	r0, r0, #8
   2bcbc:	4770      	bx	lr

0002bcbe <bsp_lc709204f_read>:
{
   2bcbe:	b570      	push	{r4, r5, r6, lr}
   2bcc0:	b082      	sub	sp, #8
   2bcc2:	460c      	mov	r4, r1
    bsp_lc709204f_word_t to_read = {
   2bcc4:	f88d 0000 	strb.w	r0, [sp]
            .data = *data,
   2bcc8:	880b      	ldrh	r3, [r1, #0]
    bsp_lc709204f_word_t to_read = {
   2bcca:	f8ad 3002 	strh.w	r3, [sp, #2]
   2bcce:	2300      	movs	r3, #0
   2bcd0:	f88d 3004 	strb.w	r3, [sp, #4]
    zephyr_err_t err = bsp_lc709204f_read_cmd( &to_read);
   2bcd4:	4668      	mov	r0, sp
   2bcd6:	f7e8 fd43 	bl	14760 <bsp_lc709204f_read_cmd>
    if( ZEPHYR_ERR_SUCCESS == err )
   2bcda:	4605      	mov	r5, r0
   2bcdc:	b958      	cbnz	r0, 2bcf6 <bsp_lc709204f_read+0x38>
        if( to_read.crc == bsp_lc709204f_compute_crc(to_read) )
   2bcde:	f89d 6004 	ldrb.w	r6, [sp, #4]
   2bce2:	ab02      	add	r3, sp, #8
   2bce4:	e913 0003 	ldmdb	r3, {r0, r1}
   2bce8:	f7e8 fd50 	bl	1478c <bsp_lc709204f_compute_crc>
   2bcec:	4286      	cmp	r6, r0
   2bcee:	d105      	bne.n	2bcfc <bsp_lc709204f_read+0x3e>
            *data = to_read.data;
   2bcf0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   2bcf4:	8023      	strh	r3, [r4, #0]
}
   2bcf6:	4628      	mov	r0, r5
   2bcf8:	b002      	add	sp, #8
   2bcfa:	bd70      	pop	{r4, r5, r6, pc}
            err = -EILSEQ;
   2bcfc:	f06f 0589 	mvn.w	r5, #137	; 0x89
    return err;
   2bd00:	e7f9      	b.n	2bcf6 <bsp_lc709204f_read+0x38>

0002bd02 <bsp_lc709204f_write>:
{
   2bd02:	b510      	push	{r4, lr}
   2bd04:	b082      	sub	sp, #8
    bsp_lc709204f_word_t to_write = {
   2bd06:	f88d 0000 	strb.w	r0, [sp]
   2bd0a:	f8ad 1002 	strh.w	r1, [sp, #2]
   2bd0e:	2300      	movs	r3, #0
   2bd10:	f88d 3004 	strb.w	r3, [sp, #4]
    to_write.crc = bsp_lc709204f_compute_crc( to_write );
   2bd14:	466c      	mov	r4, sp
   2bd16:	e894 0003 	ldmia.w	r4, {r0, r1}
   2bd1a:	f7e8 fd37 	bl	1478c <bsp_lc709204f_compute_crc>
   2bd1e:	f88d 0004 	strb.w	r0, [sp, #4]
    return bsp_lc709204f_write_cmd(to_write);
   2bd22:	e894 0003 	ldmia.w	r4, {r0, r1}
   2bd26:	f7e8 fcf3 	bl	14710 <bsp_lc709204f_write_cmd>
}
   2bd2a:	b002      	add	sp, #8
   2bd2c:	bd10      	pop	{r4, pc}

0002bd2e <bsp_display_find_font>:
{
   2bd2e:	b500      	push	{lr}
   2bd30:	4686      	mov	lr, r0
    font_tChar_t* matching_idx = (font_tChar_t*) font->chars;
   2bd32:	684a      	ldr	r2, [r1, #4]
    for (uint16_t idx = 0; idx < (uint16_t) font->length; ++idx)
   2bd34:	2300      	movs	r3, #0
    font_tImage_t* ret_val = NULL;
   2bd36:	4618      	mov	r0, r3
    for (uint16_t idx = 0; idx < (uint16_t) font->length; ++idx)
   2bd38:	e002      	b.n	2bd40 <bsp_display_find_font+0x12>
        matching_idx++;
   2bd3a:	3208      	adds	r2, #8
    for (uint16_t idx = 0; idx < (uint16_t) font->length; ++idx)
   2bd3c:	3301      	adds	r3, #1
   2bd3e:	b29b      	uxth	r3, r3
   2bd40:	f8b1 c000 	ldrh.w	ip, [r1]
   2bd44:	459c      	cmp	ip, r3
   2bd46:	d905      	bls.n	2bd54 <bsp_display_find_font+0x26>
        if( (char) matching_idx->code == c )
   2bd48:	f892 c000 	ldrb.w	ip, [r2]
   2bd4c:	45f4      	cmp	ip, lr
   2bd4e:	d1f4      	bne.n	2bd3a <bsp_display_find_font+0xc>
            ret_val = (font_tImage_t*) matching_idx->image;
   2bd50:	6850      	ldr	r0, [r2, #4]
   2bd52:	e7f2      	b.n	2bd3a <bsp_display_find_font+0xc>
}
   2bd54:	f85d fb04 	ldr.w	pc, [sp], #4

0002bd58 <bsp_display_buffer_colour>:
{
   2bd58:	b530      	push	{r4, r5, lr}
    uint8_t lb = 0x00FF & colour.colour;
   2bd5a:	b2d4      	uxtb	r4, r2
    uint8_t ub = (0xFF00 & colour.colour) >> 8;
   2bd5c:	f3c2 2207 	ubfx	r2, r2, #8, #8
    for (uint32_t idx = 0; idx < desc->buf_size; idx += sizeof(uint16_t) )
   2bd60:	2300      	movs	r3, #0
   2bd62:	e00e      	b.n	2bd82 <bsp_display_buffer_colour+0x2a>
        image_buffer[idx] &= lb;
   2bd64:	f810 c003 	ldrb.w	ip, [r0, r3]
   2bd68:	ea04 0c0c 	and.w	ip, r4, ip
   2bd6c:	f800 c003 	strb.w	ip, [r0, r3]
        image_buffer[idx+1] &= ub;
   2bd70:	f103 0e01 	add.w	lr, r3, #1
   2bd74:	f810 c00e 	ldrb.w	ip, [r0, lr]
   2bd78:	ea02 0c0c 	and.w	ip, r2, ip
   2bd7c:	f800 c00e 	strb.w	ip, [r0, lr]
    for (uint32_t idx = 0; idx < desc->buf_size; idx += sizeof(uint16_t) )
   2bd80:	3302      	adds	r3, #2
   2bd82:	680d      	ldr	r5, [r1, #0]
   2bd84:	429d      	cmp	r5, r3
   2bd86:	d8ed      	bhi.n	2bd64 <bsp_display_buffer_colour+0xc>
}
   2bd88:	bd30      	pop	{r4, r5, pc}

0002bd8a <bsp_display_tft_enable_cb>:

static void bsp_display_tft_enable_cb(const zephyr_device_t* port, zephyr_gpio_callback_t* cb, gpio_port_pins_t pins)
{

   2bd8a:	4770      	bx	lr

0002bd8c <bsp_display_blk_cb>:
{
   2bd8c:	b508      	push	{r3, lr}
    bsp_display_backlight_set_brightness(AFL240320A0_DEFAULT_BRIGHTNESS);
   2bd8e:	20fa      	movs	r0, #250	; 0xfa
   2bd90:	f7e6 ff12 	bl	12bb8 <bsp_display_backlight_set_brightness>
}
   2bd94:	bd08      	pop	{r3, pc}

0002bd96 <bsp_display_backlight_fade>:
{
   2bd96:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2bd9a:	ed2d 8b04 	vpush	{d8-d9}
   2bd9e:	b082      	sub	sp, #8
   2bda0:	9000      	str	r0, [sp, #0]
   2bda2:	9101      	str	r1, [sp, #4]
    if( (time.ticks != K_FOREVER.ticks) &&
   2bda4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2bda8:	bf08      	it	eq
   2bdaa:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   2bdae:	d041      	beq.n	2be34 <bsp_display_backlight_fade+0x9e>
   2bdb0:	4610      	mov	r0, r2
   2bdb2:	4619      	mov	r1, r3
        ( start_brightness <= BSP_DISPLAY_MAX_BRIGHTNESS ) &&
   2bdb4:	f8bd 3000 	ldrh.w	r3, [sp]
    if( (time.ticks != K_FOREVER.ticks) &&
   2bdb8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   2bdbc:	d83d      	bhi.n	2be3a <bsp_display_backlight_fade+0xa4>
        ( end_brightness <= BSP_DISPLAY_MAX_BRIGHTNESS ) )
   2bdbe:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        ( start_brightness <= BSP_DISPLAY_MAX_BRIGHTNESS ) &&
   2bdc2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
   2bdc6:	d83b      	bhi.n	2be40 <bsp_display_backlight_fade+0xaa>
        uint64_t time_step = time.ticks / ( BSP_DISPLAY_FADE_STEP.ticks );
   2bdc8:	2221      	movs	r2, #33	; 0x21
   2bdca:	2300      	movs	r3, #0
   2bdcc:	f7d4 feb4 	bl	b38 <__aeabi_ldivmod>
   2bdd0:	4680      	mov	r8, r0
   2bdd2:	460f      	mov	r7, r1
        float    brightness_step = (((float) end_brightness) - ((float) start_brightness)) / ( (float) time_step );
   2bdd4:	eddd 7a01 	vldr	s15, [sp, #4]
   2bdd8:	eeb8 9ae7 	vcvt.f32.s32	s18, s15
   2bddc:	eddd 7a00 	vldr	s15, [sp]
   2bde0:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   2bde4:	ee39 9a48 	vsub.f32	s18, s18, s16
   2bde8:	f7d4 fe60 	bl	aac <__aeabi_ul2f>
   2bdec:	ee07 0a90 	vmov	s15, r0
   2bdf0:	eec9 8a27 	vdiv.f32	s17, s18, s15
        for (uint64_t steps = 0; steps < time_step; steps++ )
   2bdf4:	2400      	movs	r4, #0
   2bdf6:	4626      	mov	r6, r4
    zephyr_err_t err = -EINVAL;
   2bdf8:	f06f 0515 	mvn.w	r5, #21
        for (uint64_t steps = 0; steps < time_step; steps++ )
   2bdfc:	e010      	b.n	2be20 <bsp_display_backlight_fade+0x8a>
            err = bsp_display_backlight_set_brightness( (uint16_t) brightness );
   2bdfe:	eefc 7ac8 	vcvt.u32.f32	s15, s16
   2be02:	ee17 3a90 	vmov	r3, s15
   2be06:	b298      	uxth	r0, r3
   2be08:	f7e6 fed6 	bl	12bb8 <bsp_display_backlight_set_brightness>
   2be0c:	4605      	mov	r5, r0
            brightness = brightness + brightness_step;
   2be0e:	ee38 8a28 	vadd.f32	s16, s16, s17
   2be12:	2021      	movs	r0, #33	; 0x21
   2be14:	2100      	movs	r1, #0
   2be16:	f7fc ffa1 	bl	28d5c <z_impl_k_sleep>
        for (uint64_t steps = 0; steps < time_step; steps++ )
   2be1a:	3401      	adds	r4, #1
   2be1c:	f146 0600 	adc.w	r6, r6, #0
   2be20:	4544      	cmp	r4, r8
   2be22:	eb76 0307 	sbcs.w	r3, r6, r7
   2be26:	d3ea      	bcc.n	2bdfe <bsp_display_backlight_fade+0x68>
}
   2be28:	4628      	mov	r0, r5
   2be2a:	b002      	add	sp, #8
   2be2c:	ecbd 8b04 	vpop	{d8-d9}
   2be30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    zephyr_err_t err = -EINVAL;
   2be34:	f06f 0515 	mvn.w	r5, #21
   2be38:	e7f6      	b.n	2be28 <bsp_display_backlight_fade+0x92>
   2be3a:	f06f 0515 	mvn.w	r5, #21
   2be3e:	e7f3      	b.n	2be28 <bsp_display_backlight_fade+0x92>
   2be40:	f06f 0515 	mvn.w	r5, #21
   2be44:	e7f0      	b.n	2be28 <bsp_display_backlight_fade+0x92>

0002be46 <bsp_display_clear>:
{
   2be46:	b500      	push	{lr}
   2be48:	b083      	sub	sp, #12
    return bsp_display_draw_rectangle( 0 , 0, AFL240320A0_SCREEN_WIDTH , AFL240320A0_SCREEN_HEIGHT , BSP_DISPLAY_COLOUR_BLACK);
   2be4a:	2000      	movs	r0, #0
   2be4c:	f8ad 0000 	strh.w	r0, [sp]
   2be50:	23f0      	movs	r3, #240	; 0xf0
   2be52:	f44f 72a0 	mov.w	r2, #320	; 0x140
   2be56:	4601      	mov	r1, r0
   2be58:	f7e9 f89c 	bl	14f94 <bsp_display_draw_rectangle>
}
   2be5c:	b003      	add	sp, #12
   2be5e:	f85d fb04 	ldr.w	pc, [sp], #4

0002be62 <bsp_display_print_string>:
{
   2be62:	b40f      	push	{r0, r1, r2, r3}
   2be64:	b5f0      	push	{r4, r5, r6, r7, lr}
   2be66:	b083      	sub	sp, #12
   2be68:	ae08      	add	r6, sp, #32
   2be6a:	f856 7b04 	ldr.w	r7, [r6], #4
    const uint16_t str_size = sizeof(char) * 2 * strlen(fmt);
   2be6e:	4638      	mov	r0, r7
   2be70:	f7e0 ff1b 	bl	ccaa <strlen>
   2be74:	0044      	lsls	r4, r0, #1
   2be76:	b2a4      	uxth	r4, r4
    char* string_buffer = k_malloc( str_size );
   2be78:	4620      	mov	r0, r4
   2be7a:	f004 ff92 	bl	30da2 <k_malloc>
   2be7e:	4605      	mov	r5, r0
    va_start(arg, fmt);
   2be80:	9601      	str	r6, [sp, #4]
    vsnprintk( string_buffer , str_size , fmt , arg );
   2be82:	4633      	mov	r3, r6
   2be84:	463a      	mov	r2, r7
   2be86:	4621      	mov	r1, r4
   2be88:	f7e9 fe20 	bl	15acc <vsnprintk>
    err = bsp_display_print_char( string_buffer , strlen(string_buffer) );
   2be8c:	4628      	mov	r0, r5
   2be8e:	f7e0 ff0c 	bl	ccaa <strlen>
   2be92:	b281      	uxth	r1, r0
   2be94:	4628      	mov	r0, r5
   2be96:	f7e8 fe61 	bl	14b5c <bsp_display_print_char>
   2be9a:	4604      	mov	r4, r0
    k_free(string_buffer);
   2be9c:	4628      	mov	r0, r5
   2be9e:	f004 ff77 	bl	30d90 <k_free>
}
   2bea2:	4620      	mov	r0, r4
   2bea4:	b003      	add	sp, #12
   2bea6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   2beaa:	b004      	add	sp, #16
   2beac:	4770      	bx	lr

0002beae <app_adc_work_handler>:

static void app_adc_work_handler(zephyr_k_work_t* calling_work)
{
   2beae:	b508      	push	{r3, lr}
    bsp_resume_sampling();
   2beb0:	f7e6 ff5c 	bl	12d6c <bsp_resume_sampling>
   2beb4:	bd08      	pop	{r3, pc}

0002beb6 <vital_app_transmitting_task>:
{
   2beb6:	b508      	push	{r3, lr}
    if( true == vital_app_event_is_set(VITAL_APP_EVENTS_DATA_WAITING , K_NO_WAIT) )
   2beb8:	2200      	movs	r2, #0
   2beba:	2300      	movs	r3, #0
   2bebc:	2004      	movs	r0, #4
   2bebe:	f7e9 fa57 	bl	15370 <vital_app_event_is_set>
   2bec2:	b110      	cbz	r0, 2beca <vital_app_transmitting_task+0x14>
        err = vital_gatt_update_readings();
   2bec4:	f000 f841 	bl	2bf4a <vital_gatt_update_readings>
}
   2bec8:	bd08      	pop	{r3, pc}
    zephyr_err_t err = -ENODATA;
   2beca:	f06f 003c 	mvn.w	r0, #60	; 0x3c
   2bece:	e7fb      	b.n	2bec8 <vital_app_transmitting_task+0x12>

0002bed0 <advertising_work_handle>:
{
   2bed0:	b508      	push	{r3, lr}
    connectable_adv_start();
   2bed2:	f7e9 fb4f 	bl	15574 <connectable_adv_start>
}
   2bed6:	bd08      	pop	{r3, pc}

0002bed8 <vital_gatt_read_callback>:
static ssize_t vital_gatt_read_callback(struct bt_conn* conn , const struct bt_gatt_attr * attr, void * buf , unsigned short len , unsigned short offset )
{

    return 0;

}
   2bed8:	2000      	movs	r0, #0
   2beda:	4770      	bx	lr

0002bedc <vital_gatt_parse_rx>:


static vital_gatt_rx_config_t vital_gatt_parse_rx( uint8_t* buf , uint16_t len)
{
   2bedc:	b084      	sub	sp, #16
   2bede:	4603      	mov	r3, r0
    vital_gatt_rx_config_t ret_config;
    memset( ret_config.data , 0 , VITAL_GATT_RX_DATA_BUFFER_SIZE);
   2bee0:	2000      	movs	r0, #0
   2bee2:	f8cd 0006 	str.w	r0, [sp, #6]
   2bee6:	f8cd 000a 	str.w	r0, [sp, #10]

    if( len == 3 )
   2beea:	2a03      	cmp	r2, #3
   2beec:	d00e      	beq.n	2bf0c <vital_gatt_parse_rx+0x30>
        ret_config.config_id = buf[0];
        memcpy( &ret_config.data , &buf[1] , VITAL_GATT_RX_DATA_BUFFER_SIZE );
    }
    else
    {
        if( len == 6)
   2beee:	2a06      	cmp	r2, #6
   2bef0:	d121      	bne.n	2bf36 <vital_gatt_parse_rx+0x5a>
        {
            ret_config.config_id = buf[0];
   2bef2:	460a      	mov	r2, r1
   2bef4:	f812 0b01 	ldrb.w	r0, [r2], #1
   2bef8:	f8ad 0004 	strh.w	r0, [sp, #4]
            memcpy( &ret_config.data , &buf[1] , VITAL_GATT_RX_DATA_BUFFER_SIZE );
   2befc:	f8d1 1001 	ldr.w	r1, [r1, #1]
   2bf00:	6852      	ldr	r2, [r2, #4]
   2bf02:	f8cd 1006 	str.w	r1, [sp, #6]
   2bf06:	f8cd 200a 	str.w	r2, [sp, #10]
   2bf0a:	e00b      	b.n	2bf24 <vital_gatt_parse_rx+0x48>
        ret_config.config_id = buf[0];
   2bf0c:	460a      	mov	r2, r1
   2bf0e:	f812 0b01 	ldrb.w	r0, [r2], #1
   2bf12:	f8ad 0004 	strh.w	r0, [sp, #4]
        memcpy( &ret_config.data , &buf[1] , VITAL_GATT_RX_DATA_BUFFER_SIZE );
   2bf16:	f8d1 1001 	ldr.w	r1, [r1, #1]
   2bf1a:	6852      	ldr	r2, [r2, #4]
   2bf1c:	f8cd 1006 	str.w	r1, [sp, #6]
   2bf20:	f8cd 200a 	str.w	r2, [sp, #10]
            memset( ret_config.data , 0xFF , VITAL_GATT_RX_DATA_BUFFER_SIZE);
        }
    }


    return ret_config;
   2bf24:	aa01      	add	r2, sp, #4
   2bf26:	ca03      	ldmia	r2!, {r0, r1}
   2bf28:	6018      	str	r0, [r3, #0]
   2bf2a:	6059      	str	r1, [r3, #4]
   2bf2c:	8812      	ldrh	r2, [r2, #0]
   2bf2e:	811a      	strh	r2, [r3, #8]
   2bf30:	4618      	mov	r0, r3
   2bf32:	b004      	add	sp, #16
   2bf34:	4770      	bx	lr
            ret_config.config_id = 0;
   2bf36:	2200      	movs	r2, #0
   2bf38:	f8ad 2004 	strh.w	r2, [sp, #4]
            memset( ret_config.data , 0xFF , VITAL_GATT_RX_DATA_BUFFER_SIZE);
   2bf3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2bf40:	f8cd 2006 	str.w	r2, [sp, #6]
   2bf44:	f8cd 200a 	str.w	r2, [sp, #10]
   2bf48:	e7ec      	b.n	2bf24 <vital_gatt_parse_rx+0x48>

0002bf4a <vital_gatt_update_readings>:
{
   2bf4a:	b538      	push	{r3, r4, r5, lr}
    for (uint8_t idx = 0; (idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX) ; idx++ )
   2bf4c:	2400      	movs	r4, #0
    zephyr_err_t err = ZEPHYR_ERR_SUCCESS;
   2bf4e:	4625      	mov	r5, r4
    for (uint8_t idx = 0; (idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX) ; idx++ )
   2bf50:	e005      	b.n	2bf5e <vital_gatt_update_readings+0x14>
        err += vital_gatt_update_reading( idx );
   2bf52:	4620      	mov	r0, r4
   2bf54:	f7e9 fd0e 	bl	15974 <vital_gatt_update_reading>
   2bf58:	4405      	add	r5, r0
    for (uint8_t idx = 0; (idx < (uint8_t) VITALS_VITAL_TYPE_ID_MAX) ; idx++ )
   2bf5a:	3401      	adds	r4, #1
   2bf5c:	b2e4      	uxtb	r4, r4
   2bf5e:	2c03      	cmp	r4, #3
   2bf60:	d9f7      	bls.n	2bf52 <vital_gatt_update_readings+0x8>
    if(ZEPHYR_ERR_SUCCESS == err)
   2bf62:	b925      	cbnz	r5, 2bf6e <vital_gatt_update_readings+0x24>
        vital_app_clear_event(VITAL_APP_EVENTS_DATA_WAITING);
   2bf64:	2004      	movs	r0, #4
   2bf66:	f7e9 f9ab 	bl	152c0 <vital_app_clear_event>
}
   2bf6a:	4628      	mov	r0, r5
   2bf6c:	bd38      	pop	{r3, r4, r5, pc}
        err = -EADV;
   2bf6e:	f06f 0543 	mvn.w	r5, #67	; 0x43
    return err;
   2bf72:	e7fa      	b.n	2bf6a <vital_gatt_update_readings+0x20>

0002bf74 <sys_notify_validate>:
	if (notify == NULL) {
   2bf74:	4602      	mov	r2, r0
   2bf76:	b1b0      	cbz	r0, 2bfa6 <sys_notify_validate+0x32>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   2bf78:	6843      	ldr	r3, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   2bf7a:	f003 0303 	and.w	r3, r3, #3
	switch (sys_notify_get_method(notify)) {
   2bf7e:	2b02      	cmp	r3, #2
   2bf80:	d00b      	beq.n	2bf9a <sys_notify_validate+0x26>
   2bf82:	2b03      	cmp	r3, #3
   2bf84:	d004      	beq.n	2bf90 <sys_notify_validate+0x1c>
   2bf86:	2b01      	cmp	r3, #1
   2bf88:	d004      	beq.n	2bf94 <sys_notify_validate+0x20>
   2bf8a:	f06f 0015 	mvn.w	r0, #21
   2bf8e:	4770      	bx	lr
		if (notify->method.callback == NULL) {
   2bf90:	6803      	ldr	r3, [r0, #0]
   2bf92:	b15b      	cbz	r3, 2bfac <sys_notify_validate+0x38>
		notify->result = 0;
   2bf94:	2000      	movs	r0, #0
   2bf96:	6090      	str	r0, [r2, #8]
   2bf98:	4770      	bx	lr
		if (notify->method.signal == NULL) {
   2bf9a:	6803      	ldr	r3, [r0, #0]
   2bf9c:	2b00      	cmp	r3, #0
   2bf9e:	d1f9      	bne.n	2bf94 <sys_notify_validate+0x20>
			rv = -EINVAL;
   2bfa0:	f06f 0015 	mvn.w	r0, #21
}
   2bfa4:	4770      	bx	lr
		return -EINVAL;
   2bfa6:	f06f 0015 	mvn.w	r0, #21
   2bfaa:	4770      	bx	lr
			rv = -EINVAL;
   2bfac:	f06f 0015 	mvn.w	r0, #21
   2bfb0:	4770      	bx	lr

0002bfb2 <arch_printk_char_out>:
}
   2bfb2:	2000      	movs	r0, #0
   2bfb4:	4770      	bx	lr

0002bfb6 <str_out>:
{
   2bfb6:	b410      	push	{r4}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   2bfb8:	680c      	ldr	r4, [r1, #0]
   2bfba:	b154      	cbz	r4, 2bfd2 <str_out+0x1c>
   2bfbc:	688a      	ldr	r2, [r1, #8]
   2bfbe:	684b      	ldr	r3, [r1, #4]
   2bfc0:	429a      	cmp	r2, r3
   2bfc2:	da06      	bge.n	2bfd2 <str_out+0x1c>
	if (ctx->count == ctx->max - 1) {
   2bfc4:	3b01      	subs	r3, #1
   2bfc6:	429a      	cmp	r2, r3
   2bfc8:	d009      	beq.n	2bfde <str_out+0x28>
		ctx->str[ctx->count++] = c;
   2bfca:	1c53      	adds	r3, r2, #1
   2bfcc:	608b      	str	r3, [r1, #8]
   2bfce:	54a0      	strb	r0, [r4, r2]
   2bfd0:	e002      	b.n	2bfd8 <str_out+0x22>
		ctx->count++;
   2bfd2:	688b      	ldr	r3, [r1, #8]
   2bfd4:	3301      	adds	r3, #1
   2bfd6:	608b      	str	r3, [r1, #8]
}
   2bfd8:	f85d 4b04 	ldr.w	r4, [sp], #4
   2bfdc:	4770      	bx	lr
		ctx->str[ctx->count++] = '\0';
   2bfde:	1c53      	adds	r3, r2, #1
   2bfe0:	608b      	str	r3, [r1, #8]
   2bfe2:	2300      	movs	r3, #0
   2bfe4:	54a3      	strb	r3, [r4, r2]
   2bfe6:	e7f7      	b.n	2bfd8 <str_out+0x22>

0002bfe8 <printk>:
{
   2bfe8:	b40f      	push	{r0, r1, r2, r3}
   2bfea:	b500      	push	{lr}
   2bfec:	b083      	sub	sp, #12
   2bfee:	a904      	add	r1, sp, #16
   2bff0:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   2bff4:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
   2bff6:	f7e9 fd5b 	bl	15ab0 <vprintk>
}
   2bffa:	b003      	add	sp, #12
   2bffc:	f85d eb04 	ldr.w	lr, [sp], #4
   2c000:	b004      	add	sp, #16
   2c002:	4770      	bx	lr

0002c004 <snprintk>:
{
   2c004:	b40c      	push	{r2, r3}
   2c006:	b500      	push	{lr}
   2c008:	b083      	sub	sp, #12
   2c00a:	ab04      	add	r3, sp, #16
   2c00c:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   2c010:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   2c012:	f7e9 fd5b 	bl	15acc <vsnprintk>
}
   2c016:	b003      	add	sp, #12
   2c018:	f85d eb04 	ldr.w	lr, [sp], #4
   2c01c:	b002      	add	sp, #8
   2c01e:	4770      	bx	lr

0002c020 <set_state>:
	mgr->flags = (state & ONOFF_STATE_MASK)
   2c020:	f001 0307 	and.w	r3, r1, #7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   2c024:	8b81      	ldrh	r1, [r0, #28]
   2c026:	f021 0107 	bic.w	r1, r1, #7
   2c02a:	4319      	orrs	r1, r3
	mgr->flags = (state & ONOFF_STATE_MASK)
   2c02c:	8381      	strh	r1, [r0, #28]
}
   2c02e:	4770      	bx	lr

0002c030 <notify_monitors>:
{
   2c030:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c034:	4606      	mov	r6, r0
   2c036:	460f      	mov	r7, r1
   2c038:	4690      	mov	r8, r2
	return list->head;
   2c03a:	6881      	ldr	r1, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   2c03c:	b119      	cbz	r1, 2c046 <notify_monitors+0x16>
   2c03e:	460c      	mov	r4, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
   2c040:	b131      	cbz	r1, 2c050 <notify_monitors+0x20>
	return node->next;
   2c042:	680c      	ldr	r4, [r1, #0]
   2c044:	e004      	b.n	2c050 <notify_monitors+0x20>
   2c046:	460c      	mov	r4, r1
   2c048:	e002      	b.n	2c050 <notify_monitors+0x20>
   2c04a:	4623      	mov	r3, r4
   2c04c:	4621      	mov	r1, r4
   2c04e:	461c      	mov	r4, r3
   2c050:	b159      	cbz	r1, 2c06a <notify_monitors+0x3a>
		mon->callback(mgr, mon, state, res);
   2c052:	684d      	ldr	r5, [r1, #4]
   2c054:	4643      	mov	r3, r8
   2c056:	463a      	mov	r2, r7
   2c058:	4630      	mov	r0, r6
   2c05a:	47a8      	blx	r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   2c05c:	2c00      	cmp	r4, #0
   2c05e:	d0f4      	beq.n	2c04a <notify_monitors+0x1a>
   2c060:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
   2c062:	2c00      	cmp	r4, #0
   2c064:	d0f2      	beq.n	2c04c <notify_monitors+0x1c>
	return node->next;
   2c066:	6823      	ldr	r3, [r4, #0]
   2c068:	e7f0      	b.n	2c04c <notify_monitors+0x1c>
}
   2c06a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002c06e <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   2c06e:	8b83      	ldrh	r3, [r0, #28]
	if ((state == ONOFF_STATE_OFF)
   2c070:	f013 0307 	ands.w	r3, r3, #7
   2c074:	d103      	bne.n	2c07e <process_recheck+0x10>
	return list->head;
   2c076:	6802      	ldr	r2, [r0, #0]
	    && !sys_slist_is_empty(&mgr->clients)) {
   2c078:	b10a      	cbz	r2, 2c07e <process_recheck+0x10>
		evt = EVT_START;
   2c07a:	2003      	movs	r0, #3
   2c07c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   2c07e:	2b02      	cmp	r3, #2
   2c080:	d003      	beq.n	2c08a <process_recheck+0x1c>
	} else if ((state == ONOFF_STATE_ERROR)
   2c082:	2b01      	cmp	r3, #1
   2c084:	d006      	beq.n	2c094 <process_recheck+0x26>
	int evt = EVT_NOP;
   2c086:	2000      	movs	r0, #0
   2c088:	4770      	bx	lr
		   && (mgr->refs == 0U)) {
   2c08a:	8bc2      	ldrh	r2, [r0, #30]
   2c08c:	2a00      	cmp	r2, #0
   2c08e:	d1f8      	bne.n	2c082 <process_recheck+0x14>
		evt = EVT_STOP;
   2c090:	2004      	movs	r0, #4
   2c092:	4770      	bx	lr
   2c094:	6803      	ldr	r3, [r0, #0]
		   && !sys_slist_is_empty(&mgr->clients)) {
   2c096:	b10b      	cbz	r3, 2c09c <process_recheck+0x2e>
		evt = EVT_RESET;
   2c098:	2005      	movs	r0, #5
}
   2c09a:	4770      	bx	lr
	int evt = EVT_NOP;
   2c09c:	2000      	movs	r0, #0
   2c09e:	4770      	bx	lr

0002c0a0 <validate_args>:
	if ((mgr == NULL) || (cli == NULL)) {
   2c0a0:	b158      	cbz	r0, 2c0ba <validate_args+0x1a>
{
   2c0a2:	b510      	push	{r4, lr}
   2c0a4:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   2c0a6:	b159      	cbz	r1, 2c0c0 <validate_args+0x20>
	int rv = sys_notify_validate(&cli->notify);
   2c0a8:	1d08      	adds	r0, r1, #4
   2c0aa:	f7ff ff63 	bl	2bf74 <sys_notify_validate>
	if ((rv == 0)
   2c0ae:	b918      	cbnz	r0, 2c0b8 <validate_args+0x18>
	    && ((cli->notify.flags
   2c0b0:	68a3      	ldr	r3, [r4, #8]
   2c0b2:	f033 0303 	bics.w	r3, r3, #3
   2c0b6:	d106      	bne.n	2c0c6 <validate_args+0x26>
}
   2c0b8:	bd10      	pop	{r4, pc}
		return -EINVAL;
   2c0ba:	f06f 0015 	mvn.w	r0, #21
}
   2c0be:	4770      	bx	lr
		return -EINVAL;
   2c0c0:	f06f 0015 	mvn.w	r0, #21
   2c0c4:	e7f8      	b.n	2c0b8 <validate_args+0x18>
		rv = -EINVAL;
   2c0c6:	f06f 0015 	mvn.w	r0, #21
   2c0ca:	e7f5      	b.n	2c0b8 <validate_args+0x18>

0002c0cc <notify_one>:
{
   2c0cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c0d0:	4607      	mov	r7, r0
   2c0d2:	460c      	mov	r4, r1
   2c0d4:	4616      	mov	r6, r2
   2c0d6:	461d      	mov	r5, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   2c0d8:	4619      	mov	r1, r3
   2c0da:	1d20      	adds	r0, r4, #4
   2c0dc:	f7e9 fcac 	bl	15a38 <sys_notify_finalize>
	if (cb) {
   2c0e0:	b128      	cbz	r0, 2c0ee <notify_one+0x22>
   2c0e2:	4680      	mov	r8, r0
		cb(mgr, cli, state, res);
   2c0e4:	462b      	mov	r3, r5
   2c0e6:	4632      	mov	r2, r6
   2c0e8:	4621      	mov	r1, r4
   2c0ea:	4638      	mov	r0, r7
   2c0ec:	47c0      	blx	r8
}
   2c0ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002c0f2 <notify_all>:
{
   2c0f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c0f6:	4680      	mov	r8, r0
   2c0f8:	460c      	mov	r4, r1
   2c0fa:	4617      	mov	r7, r2
   2c0fc:	461e      	mov	r6, r3
	while (!sys_slist_is_empty(list)) {
   2c0fe:	e004      	b.n	2c10a <notify_all+0x18>
		notify_one(mgr, cli, state, res);
   2c100:	4633      	mov	r3, r6
   2c102:	463a      	mov	r2, r7
   2c104:	4640      	mov	r0, r8
   2c106:	f7ff ffe1 	bl	2c0cc <notify_one>
   2c10a:	6821      	ldr	r1, [r4, #0]
	while (!sys_slist_is_empty(list)) {
   2c10c:	b131      	cbz	r1, 2c11c <notify_all+0x2a>
	return node->next;
   2c10e:	680d      	ldr	r5, [r1, #0]
	list->head = node;
   2c110:	6025      	str	r5, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2c112:	6863      	ldr	r3, [r4, #4]
   2c114:	428b      	cmp	r3, r1
   2c116:	d1f3      	bne.n	2c100 <notify_all+0xe>
	list->tail = node;
   2c118:	6065      	str	r5, [r4, #4]
}
   2c11a:	e7f1      	b.n	2c100 <notify_all+0xe>
}
   2c11c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002c120 <onoff_manager_init>:
	if ((mgr == NULL)
   2c120:	b170      	cbz	r0, 2c140 <onoff_manager_init+0x20>
{
   2c122:	b538      	push	{r3, r4, r5, lr}
   2c124:	460c      	mov	r4, r1
   2c126:	4605      	mov	r5, r0
	    || (transitions == NULL)
   2c128:	b169      	cbz	r1, 2c146 <onoff_manager_init+0x26>
	    || (transitions->start == NULL)
   2c12a:	680b      	ldr	r3, [r1, #0]
   2c12c:	b173      	cbz	r3, 2c14c <onoff_manager_init+0x2c>
	    || (transitions->stop == NULL)) {
   2c12e:	684b      	ldr	r3, [r1, #4]
   2c130:	b17b      	cbz	r3, 2c152 <onoff_manager_init+0x32>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   2c132:	2220      	movs	r2, #32
   2c134:	2100      	movs	r1, #0
   2c136:	f004 feb7 	bl	30ea8 <memset>
   2c13a:	612c      	str	r4, [r5, #16]
	return 0;
   2c13c:	2000      	movs	r0, #0
}
   2c13e:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   2c140:	f06f 0015 	mvn.w	r0, #21
}
   2c144:	4770      	bx	lr
		return -EINVAL;
   2c146:	f06f 0015 	mvn.w	r0, #21
   2c14a:	e7f8      	b.n	2c13e <onoff_manager_init+0x1e>
   2c14c:	f06f 0015 	mvn.w	r0, #21
   2c150:	e7f5      	b.n	2c13e <onoff_manager_init+0x1e>
   2c152:	f06f 0015 	mvn.w	r0, #21
   2c156:	e7f2      	b.n	2c13e <onoff_manager_init+0x1e>

0002c158 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   2c158:	b508      	push	{r3, lr}
   2c15a:	4604      	mov	r4, r0
   2c15c:	4608      	mov	r0, r1
   2c15e:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   2c160:	461a      	mov	r2, r3
   2c162:	47a0      	blx	r4
	return z_impl_z_current_get();
   2c164:	f7fc fe3e 	bl	28de4 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   2c168:	f7ec fdae 	bl	18cc8 <z_impl_k_thread_abort>

0002c16c <chunk_mem>:
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   2c16c:	00c9      	lsls	r1, r1, #3
   2c16e:	3104      	adds	r1, #4
}
   2c170:	4408      	add	r0, r1
   2c172:	4770      	bx	lr

0002c174 <free_list_remove_bidx>:
	void *cmem = &buf[c];
   2c174:	ea4f 0cc1 	mov.w	ip, r1, lsl #3
		return ((uint16_t *)cmem)[f];
   2c178:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
   2c17c:	88db      	ldrh	r3, [r3, #6]
	if (next_free_chunk(h, c) == c) {
   2c17e:	4299      	cmp	r1, r3
   2c180:	d00c      	beq.n	2c19c <free_list_remove_bidx+0x28>
   2c182:	4484      	add	ip, r0
   2c184:	f8bc 1004 	ldrh.w	r1, [ip, #4]
		b->next = second;
   2c188:	3204      	adds	r2, #4
   2c18a:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	void *cmem = &buf[c];
   2c18e:	00ca      	lsls	r2, r1, #3
		((uint16_t *)cmem)[f] = val;
   2c190:	3206      	adds	r2, #6
   2c192:	5283      	strh	r3, [r0, r2]
	void *cmem = &buf[c];
   2c194:	00db      	lsls	r3, r3, #3
		((uint16_t *)cmem)[f] = val;
   2c196:	3304      	adds	r3, #4
   2c198:	52c1      	strh	r1, [r0, r3]
}
   2c19a:	4770      	bx	lr
		h->avail_buckets &= ~BIT(bidx);
   2c19c:	2301      	movs	r3, #1
   2c19e:	fa03 f102 	lsl.w	r1, r3, r2
   2c1a2:	68c3      	ldr	r3, [r0, #12]
   2c1a4:	ea23 0301 	bic.w	r3, r3, r1
   2c1a8:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   2c1aa:	3204      	adds	r2, #4
   2c1ac:	2300      	movs	r3, #0
   2c1ae:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
   2c1b2:	4770      	bx	lr

0002c1b4 <free_list_add_bidx>:
{
   2c1b4:	b510      	push	{r4, lr}
	if (b->next == 0U) {
   2c1b6:	1d13      	adds	r3, r2, #4
   2c1b8:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   2c1bc:	b97c      	cbnz	r4, 2c1de <free_list_add_bidx+0x2a>
		h->avail_buckets |= BIT(bidx);
   2c1be:	2301      	movs	r3, #1
   2c1c0:	fa03 f402 	lsl.w	r4, r3, r2
   2c1c4:	68c3      	ldr	r3, [r0, #12]
   2c1c6:	4323      	orrs	r3, r4
   2c1c8:	60c3      	str	r3, [r0, #12]
		b->next = c;
   2c1ca:	3204      	adds	r2, #4
   2c1cc:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
	void *cmem = &buf[c];
   2c1d0:	00cb      	lsls	r3, r1, #3
		((uint16_t *)cmem)[f] = val;
   2c1d2:	1d1a      	adds	r2, r3, #4
   2c1d4:	b289      	uxth	r1, r1
   2c1d6:	5281      	strh	r1, [r0, r2]
   2c1d8:	3306      	adds	r3, #6
   2c1da:	52c1      	strh	r1, [r0, r3]
}
   2c1dc:	bd10      	pop	{r4, pc}
	void *cmem = &buf[c];
   2c1de:	00e2      	lsls	r2, r4, #3
		return ((uint16_t *)cmem)[f];
   2c1e0:	3204      	adds	r2, #4
   2c1e2:	5a83      	ldrh	r3, [r0, r2]
	void *cmem = &buf[c];
   2c1e4:	ea4f 0cc1 	mov.w	ip, r1, lsl #3
		((uint16_t *)cmem)[f] = val;
   2c1e8:	f10c 0e04 	add.w	lr, ip, #4
   2c1ec:	f820 300e 	strh.w	r3, [r0, lr]
   2c1f0:	f10c 0c06 	add.w	ip, ip, #6
   2c1f4:	f820 400c 	strh.w	r4, [r0, ip]
	void *cmem = &buf[c];
   2c1f8:	00db      	lsls	r3, r3, #3
		((uint16_t *)cmem)[f] = val;
   2c1fa:	3306      	adds	r3, #6
   2c1fc:	b289      	uxth	r1, r1
   2c1fe:	52c1      	strh	r1, [r0, r3]
   2c200:	5281      	strh	r1, [r0, r2]
   2c202:	e7eb      	b.n	2c1dc <free_list_add_bidx+0x28>

0002c204 <split_chunks>:
{
   2c204:	b500      	push	{lr}
	void *cmem = &buf[c];
   2c206:	00cb      	lsls	r3, r1, #3
		return ((uint16_t *)cmem)[f];
   2c208:	3302      	adds	r3, #2
   2c20a:	f830 e003 	ldrh.w	lr, [r0, r3]
	chunksz_t lsz = rc - lc;
   2c20e:	eba2 0c01 	sub.w	ip, r2, r1
	chunksz_t rsz = sz0 - lsz;
   2c212:	1a89      	subs	r1, r1, r2
   2c214:	eb01 015e 	add.w	r1, r1, lr, lsr #1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2c218:	ea4f 0e4c 	mov.w	lr, ip, lsl #1
		((uint16_t *)cmem)[f] = val;
   2c21c:	f820 e003 	strh.w	lr, [r0, r3]
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2c220:	ea4f 0e41 	mov.w	lr, r1, lsl #1
	void *cmem = &buf[c];
   2c224:	00d3      	lsls	r3, r2, #3
		((uint16_t *)cmem)[f] = val;
   2c226:	3302      	adds	r3, #2
   2c228:	f820 e003 	strh.w	lr, [r0, r3]
   2c22c:	f820 c032 	strh.w	ip, [r0, r2, lsl #3]
		return ((uint16_t *)cmem)[f];
   2c230:	5ac3      	ldrh	r3, [r0, r3]
	return c + chunk_size(h, c);
   2c232:	eb02 0253 	add.w	r2, r2, r3, lsr #1
		((uint16_t *)cmem)[f] = val;
   2c236:	f820 1032 	strh.w	r1, [r0, r2, lsl #3]
}
   2c23a:	f85d fb04 	ldr.w	pc, [sp], #4

0002c23e <merge_chunks>:
{
   2c23e:	b500      	push	{lr}
	void *cmem = &buf[c];
   2c240:	00c9      	lsls	r1, r1, #3
		return ((uint16_t *)cmem)[f];
   2c242:	3102      	adds	r1, #2
   2c244:	f830 e001 	ldrh.w	lr, [r0, r1]
	void *cmem = &buf[c];
   2c248:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
		return ((uint16_t *)cmem)[f];
   2c24c:	f10c 0c02 	add.w	ip, ip, #2
   2c250:	f830 300c 	ldrh.w	r3, [r0, ip]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   2c254:	085b      	lsrs	r3, r3, #1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   2c256:	eb03 035e 	add.w	r3, r3, lr, lsr #1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2c25a:	ea4f 0e43 	mov.w	lr, r3, lsl #1
		((uint16_t *)cmem)[f] = val;
   2c25e:	f820 e001 	strh.w	lr, [r0, r1]
		return ((uint16_t *)cmem)[f];
   2c262:	f830 100c 	ldrh.w	r1, [r0, ip]
	return c + chunk_size(h, c);
   2c266:	eb02 0251 	add.w	r2, r2, r1, lsr #1
		((uint16_t *)cmem)[f] = val;
   2c26a:	f820 3032 	strh.w	r3, [r0, r2, lsl #3]
}
   2c26e:	f85d fb04 	ldr.w	pc, [sp], #4

0002c272 <mem_to_chunkid>:
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   2c272:	3904      	subs	r1, #4
   2c274:	1a08      	subs	r0, r1, r0
}
   2c276:	08c0      	lsrs	r0, r0, #3
   2c278:	4770      	bx	lr

0002c27a <free_list_remove>:
{
   2c27a:	b508      	push	{r3, lr}
		return ((uint16_t *)cmem)[f];
   2c27c:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
   2c280:	885a      	ldrh	r2, [r3, #2]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   2c282:	0852      	lsrs	r2, r2, #1
	return 31 - __builtin_clz(usable_sz);
   2c284:	fab2 f282 	clz	r2, r2
		free_list_remove_bidx(h, c, bidx);
   2c288:	f1c2 021f 	rsb	r2, r2, #31
   2c28c:	f7ff ff72 	bl	2c174 <free_list_remove_bidx>
}
   2c290:	bd08      	pop	{r3, pc}

0002c292 <free_list_add>:
{
   2c292:	b508      	push	{r3, lr}
		return ((uint16_t *)cmem)[f];
   2c294:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
   2c298:	885a      	ldrh	r2, [r3, #2]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   2c29a:	0852      	lsrs	r2, r2, #1
	return 31 - __builtin_clz(usable_sz);
   2c29c:	fab2 f282 	clz	r2, r2
		free_list_add_bidx(h, c, bidx);
   2c2a0:	f1c2 021f 	rsb	r2, r2, #31
   2c2a4:	f7ff ff86 	bl	2c1b4 <free_list_add_bidx>
}
   2c2a8:	bd08      	pop	{r3, pc}

0002c2aa <free_chunk>:
{
   2c2aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c2ac:	4604      	mov	r4, r0
   2c2ae:	460d      	mov	r5, r1
	void *cmem = &buf[c];
   2c2b0:	00ce      	lsls	r6, r1, #3
		return ((uint16_t *)cmem)[f];
   2c2b2:	1cb7      	adds	r7, r6, #2
   2c2b4:	5bc1      	ldrh	r1, [r0, r7]
	return c + chunk_size(h, c);
   2c2b6:	eb05 0151 	add.w	r1, r5, r1, lsr #1
		return ((uint16_t *)cmem)[f];
   2c2ba:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
   2c2be:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   2c2c0:	f013 0f01 	tst.w	r3, #1
   2c2c4:	d00c      	beq.n	2c2e0 <free_chunk+0x36>
   2c2c6:	5ba1      	ldrh	r1, [r4, r6]
	return c - chunk_field(h, c, LEFT_SIZE);
   2c2c8:	1a69      	subs	r1, r5, r1
		return ((uint16_t *)cmem)[f];
   2c2ca:	eb04 03c1 	add.w	r3, r4, r1, lsl #3
   2c2ce:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   2c2d0:	f013 0f01 	tst.w	r3, #1
   2c2d4:	d00e      	beq.n	2c2f4 <free_chunk+0x4a>
	free_list_add(h, c);
   2c2d6:	4629      	mov	r1, r5
   2c2d8:	4620      	mov	r0, r4
   2c2da:	f7ff ffda 	bl	2c292 <free_list_add>
}
   2c2de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		free_list_remove(h, right_chunk(h, c));
   2c2e0:	f7ff ffcb 	bl	2c27a <free_list_remove>
   2c2e4:	5be2      	ldrh	r2, [r4, r7]
		merge_chunks(h, c, right_chunk(h, c));
   2c2e6:	eb05 0252 	add.w	r2, r5, r2, lsr #1
   2c2ea:	4629      	mov	r1, r5
   2c2ec:	4620      	mov	r0, r4
   2c2ee:	f7ff ffa6 	bl	2c23e <merge_chunks>
   2c2f2:	e7e8      	b.n	2c2c6 <free_chunk+0x1c>
		free_list_remove(h, left_chunk(h, c));
   2c2f4:	4620      	mov	r0, r4
   2c2f6:	f7ff ffc0 	bl	2c27a <free_list_remove>
   2c2fa:	5ba1      	ldrh	r1, [r4, r6]
		merge_chunks(h, left_chunk(h, c), c);
   2c2fc:	462a      	mov	r2, r5
   2c2fe:	1a69      	subs	r1, r5, r1
   2c300:	4620      	mov	r0, r4
   2c302:	f7ff ff9c 	bl	2c23e <merge_chunks>
   2c306:	5ba3      	ldrh	r3, [r4, r6]
	return c - chunk_field(h, c, LEFT_SIZE);
   2c308:	1aed      	subs	r5, r5, r3
   2c30a:	e7e4      	b.n	2c2d6 <free_chunk+0x2c>

0002c30c <alloc_chunk>:
{
   2c30c:	b570      	push	{r4, r5, r6, lr}
	return 31 - __builtin_clz(usable_sz);
   2c30e:	fab1 f381 	clz	r3, r1
	if (b->next) {
   2c312:	f1c3 0423 	rsb	r4, r3, #35	; 0x23
   2c316:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
   2c31a:	b1cd      	cbz	r5, 2c350 <alloc_chunk+0x44>
   2c31c:	f1c3 021f 	rsb	r2, r3, #31
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
   2c320:	f04f 0e03 	mov.w	lr, #3
			chunkid_t c = b->next;
   2c324:	1d14      	adds	r4, r2, #4
   2c326:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
	void *cmem = &buf[c];
   2c32a:	ea4f 0cc4 	mov.w	ip, r4, lsl #3
		return ((uint16_t *)cmem)[f];
   2c32e:	eb00 06c4 	add.w	r6, r0, r4, lsl #3
   2c332:	8876      	ldrh	r6, [r6, #2]
			if (chunk_size(h, c) >= sz) {
   2c334:	ebb1 0f56 	cmp.w	r1, r6, lsr #1
   2c338:	d914      	bls.n	2c364 <alloc_chunk+0x58>
   2c33a:	4484      	add	ip, r0
   2c33c:	f8bc 4006 	ldrh.w	r4, [ip, #6]
			b->next = next_free_chunk(h, c);
   2c340:	1d16      	adds	r6, r2, #4
   2c342:	f840 4026 	str.w	r4, [r0, r6, lsl #2]
		} while (--i && b->next != first);
   2c346:	f1be 0e01 	subs.w	lr, lr, #1
   2c34a:	d001      	beq.n	2c350 <alloc_chunk+0x44>
   2c34c:	42a5      	cmp	r5, r4
   2c34e:	d1e9      	bne.n	2c324 <alloc_chunk+0x18>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   2c350:	68c4      	ldr	r4, [r0, #12]
   2c352:	f1c3 0220 	rsb	r2, r3, #32
   2c356:	2301      	movs	r3, #1
   2c358:	4093      	lsls	r3, r2
   2c35a:	425b      	negs	r3, r3
	if (bmask != 0U) {
   2c35c:	401c      	ands	r4, r3
   2c35e:	d105      	bne.n	2c36c <alloc_chunk+0x60>
}
   2c360:	4620      	mov	r0, r4
   2c362:	bd70      	pop	{r4, r5, r6, pc}
				free_list_remove_bidx(h, c, bi);
   2c364:	4621      	mov	r1, r4
   2c366:	f7ff ff05 	bl	2c174 <free_list_remove_bidx>
				return c;
   2c36a:	e7f9      	b.n	2c360 <alloc_chunk+0x54>
		int minbucket = __builtin_ctz(bmask);
   2c36c:	fa94 f2a4 	rbit	r2, r4
   2c370:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   2c374:	1d13      	adds	r3, r2, #4
   2c376:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   2c37a:	4621      	mov	r1, r4
   2c37c:	f7ff fefa 	bl	2c174 <free_list_remove_bidx>
		return c;
   2c380:	e7ee      	b.n	2c360 <alloc_chunk+0x54>

0002c382 <sys_heap_alloc>:
{
   2c382:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct z_heap *h = heap->heap;
   2c384:	6805      	ldr	r5, [r0, #0]
	if (bytes == 0U || size_too_big(h, bytes)) {
   2c386:	b341      	cbz	r1, 2c3da <sys_heap_alloc+0x58>
   2c388:	460b      	mov	r3, r1
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
   2c38a:	68aa      	ldr	r2, [r5, #8]
   2c38c:	ebb2 0fd1 	cmp.w	r2, r1, lsr #3
   2c390:	d925      	bls.n	2c3de <sys_heap_alloc+0x5c>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   2c392:	330b      	adds	r3, #11
   2c394:	08dc      	lsrs	r4, r3, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   2c396:	4621      	mov	r1, r4
   2c398:	4628      	mov	r0, r5
   2c39a:	f7ff ffb7 	bl	2c30c <alloc_chunk>
	if (c == 0U) {
   2c39e:	4607      	mov	r7, r0
   2c3a0:	b1f8      	cbz	r0, 2c3e2 <sys_heap_alloc+0x60>
	void *cmem = &buf[c];
   2c3a2:	00c6      	lsls	r6, r0, #3
		return ((uint16_t *)cmem)[f];
   2c3a4:	eb05 03c0 	add.w	r3, r5, r0, lsl #3
   2c3a8:	885b      	ldrh	r3, [r3, #2]
	if (chunk_size(h, c) > chunk_sz) {
   2c3aa:	ebb4 0f53 	cmp.w	r4, r3, lsr #1
   2c3ae:	d309      	bcc.n	2c3c4 <sys_heap_alloc+0x42>
	void *cmem = &buf[c];
   2c3b0:	19ab      	adds	r3, r5, r6
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   2c3b2:	885a      	ldrh	r2, [r3, #2]
   2c3b4:	f042 0201 	orr.w	r2, r2, #1
   2c3b8:	805a      	strh	r2, [r3, #2]
	mem = chunk_mem(h, c);
   2c3ba:	4639      	mov	r1, r7
   2c3bc:	4628      	mov	r0, r5
   2c3be:	f7ff fed5 	bl	2c16c <chunk_mem>
}
   2c3c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		split_chunks(h, c, c + chunk_sz);
   2c3c4:	4404      	add	r4, r0
   2c3c6:	4622      	mov	r2, r4
   2c3c8:	4601      	mov	r1, r0
   2c3ca:	4628      	mov	r0, r5
   2c3cc:	f7ff ff1a 	bl	2c204 <split_chunks>
		free_list_add(h, c + chunk_sz);
   2c3d0:	4621      	mov	r1, r4
   2c3d2:	4628      	mov	r0, r5
   2c3d4:	f7ff ff5d 	bl	2c292 <free_list_add>
   2c3d8:	e7ea      	b.n	2c3b0 <sys_heap_alloc+0x2e>
		return NULL;
   2c3da:	2000      	movs	r0, #0
   2c3dc:	e7f1      	b.n	2c3c2 <sys_heap_alloc+0x40>
   2c3de:	2000      	movs	r0, #0
   2c3e0:	e7ef      	b.n	2c3c2 <sys_heap_alloc+0x40>
		return NULL;
   2c3e2:	2000      	movs	r0, #0
   2c3e4:	e7ed      	b.n	2c3c2 <sys_heap_alloc+0x40>

0002c3e6 <_ldiv5>:
{
   2c3e6:	b500      	push	{lr}
	uint32_t v_lo = *v;
   2c3e8:	6802      	ldr	r2, [r0, #0]
   2c3ea:	6841      	ldr	r1, [r0, #4]
	__asm__ ("" : "+r" (m));
   2c3ec:	f04f 3333 	mov.w	r3, #858993459	; 0x33333333
	result += (uint64_t)v_lo * m;
   2c3f0:	fba2 2c03 	umull	r2, ip, r2, r3
   2c3f4:	eb12 0e03 	adds.w	lr, r2, r3
   2c3f8:	eb43 0e0c 	adc.w	lr, r3, ip
	result += (uint64_t)v_lo * m;
   2c3fc:	eb12 020e 	adds.w	r2, r2, lr
   2c400:	f14c 0c00 	adc.w	ip, ip, #0
	result += (uint64_t)v_hi * m;
   2c404:	fba1 1303 	umull	r1, r3, r1, r3
   2c408:	188a      	adds	r2, r1, r2
   2c40a:	eb43 020c 	adc.w	r2, r3, ip
	result += (uint64_t)v_hi * m;
   2c40e:	1889      	adds	r1, r1, r2
   2c410:	f143 0300 	adc.w	r3, r3, #0
	*v = result;
   2c414:	6001      	str	r1, [r0, #0]
   2c416:	6043      	str	r3, [r0, #4]
}
   2c418:	f85d fb04 	ldr.w	pc, [sp], #4

0002c41c <_ldiv10>:
{
   2c41c:	b508      	push	{r3, lr}
	*v >>= 1;
   2c41e:	6802      	ldr	r2, [r0, #0]
   2c420:	6841      	ldr	r1, [r0, #4]
   2c422:	0852      	lsrs	r2, r2, #1
   2c424:	ea42 72c1 	orr.w	r2, r2, r1, lsl #31
   2c428:	0849      	lsrs	r1, r1, #1
   2c42a:	6002      	str	r2, [r0, #0]
   2c42c:	6041      	str	r1, [r0, #4]
	_ldiv5(v);
   2c42e:	f7ff ffda 	bl	2c3e6 <_ldiv5>
}
   2c432:	bd08      	pop	{r3, pc}

0002c434 <_get_digit>:
{
   2c434:	4684      	mov	ip, r0
	if (*digit_count > 0) {
   2c436:	680b      	ldr	r3, [r1, #0]
   2c438:	2b00      	cmp	r3, #0
   2c43a:	dd17      	ble.n	2c46c <_get_digit+0x38>
		--*digit_count;
   2c43c:	3b01      	subs	r3, #1
   2c43e:	600b      	str	r3, [r1, #0]
		*fr *= 10U;
   2c440:	6801      	ldr	r1, [r0, #0]
   2c442:	6843      	ldr	r3, [r0, #4]
   2c444:	0098      	lsls	r0, r3, #2
   2c446:	ea40 7091 	orr.w	r0, r0, r1, lsr #30
   2c44a:	008a      	lsls	r2, r1, #2
   2c44c:	1852      	adds	r2, r2, r1
   2c44e:	eb43 0300 	adc.w	r3, r3, r0
   2c452:	1892      	adds	r2, r2, r2
   2c454:	415b      	adcs	r3, r3
   2c456:	f8cc 2000 	str.w	r2, [ip]
   2c45a:	f8cc 3004 	str.w	r3, [ip, #4]
		rval = ((*fr >> 60) & 0xF) + '0';
   2c45e:	0f18      	lsrs	r0, r3, #28
   2c460:	3030      	adds	r0, #48	; 0x30
		*fr &= (BIT64(60) - 1U);
   2c462:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
   2c466:	f8cc 3004 	str.w	r3, [ip, #4]
   2c46a:	4770      	bx	lr
		rval = '0';
   2c46c:	2030      	movs	r0, #48	; 0x30
}
   2c46e:	4770      	bx	lr

0002c470 <outs>:
{
   2c470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c474:	4607      	mov	r7, r0
   2c476:	460e      	mov	r6, r1
   2c478:	4614      	mov	r4, r2
   2c47a:	4698      	mov	r8, r3
	size_t count = 0;
   2c47c:	2500      	movs	r5, #0
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   2c47e:	e006      	b.n	2c48e <outs+0x1e>
		int rc = out((int)*sp++, ctx);
   2c480:	4631      	mov	r1, r6
   2c482:	f814 0b01 	ldrb.w	r0, [r4], #1
   2c486:	47b8      	blx	r7
		if (rc < 0) {
   2c488:	2800      	cmp	r0, #0
   2c48a:	db09      	blt.n	2c4a0 <outs+0x30>
		++count;
   2c48c:	3501      	adds	r5, #1
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   2c48e:	4544      	cmp	r4, r8
   2c490:	d3f6      	bcc.n	2c480 <outs+0x10>
   2c492:	f1b8 0f00 	cmp.w	r8, #0
   2c496:	d102      	bne.n	2c49e <outs+0x2e>
   2c498:	7823      	ldrb	r3, [r4, #0]
   2c49a:	2b00      	cmp	r3, #0
   2c49c:	d1f0      	bne.n	2c480 <outs+0x10>
	return (int)count;
   2c49e:	4628      	mov	r0, r5
}
   2c4a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002c4a4 <ring_buf_put_claim>:
{
   2c4a4:	b4f0      	push	{r4, r5, r6, r7}
   2c4a6:	4603      	mov	r3, r0
	base = buf->put_base;
   2c4a8:	68c6      	ldr	r6, [r0, #12]
	wrap_size = buf->put_head - base;
   2c4aa:	6845      	ldr	r5, [r0, #4]
   2c4ac:	1ba8      	subs	r0, r5, r6
	if (unlikely(wrap_size >= buf->size)) {
   2c4ae:	69dc      	ldr	r4, [r3, #28]
   2c4b0:	4284      	cmp	r4, r0
   2c4b2:	d914      	bls.n	2c4de <ring_buf_put_claim+0x3a>
	wrap_size = buf->size - wrap_size;
   2c4b4:	1a20      	subs	r0, r4, r0
 *
 * @return Ring buffer free space (in bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return buf->size - (buf->put_head - buf->get_tail);
   2c4b6:	695f      	ldr	r7, [r3, #20]
   2c4b8:	eba5 0c07 	sub.w	ip, r5, r7
   2c4bc:	eba4 040c 	sub.w	r4, r4, ip
	size = MIN(size, free_space);
   2c4c0:	4294      	cmp	r4, r2
   2c4c2:	bf28      	it	cs
   2c4c4:	4614      	movcs	r4, r2
	size = MIN(size, wrap_size);
   2c4c6:	42a0      	cmp	r0, r4
   2c4c8:	bf28      	it	cs
   2c4ca:	4620      	movcs	r0, r4
	*data = &buf->buffer[buf->put_head - base];
   2c4cc:	681a      	ldr	r2, [r3, #0]
   2c4ce:	1bad      	subs	r5, r5, r6
   2c4d0:	4415      	add	r5, r2
   2c4d2:	600d      	str	r5, [r1, #0]
	buf->put_head += size;
   2c4d4:	685a      	ldr	r2, [r3, #4]
   2c4d6:	4402      	add	r2, r0
   2c4d8:	605a      	str	r2, [r3, #4]
}
   2c4da:	bcf0      	pop	{r4, r5, r6, r7}
   2c4dc:	4770      	bx	lr
		wrap_size -= buf->size;
   2c4de:	1b00      	subs	r0, r0, r4
		base += buf->size;
   2c4e0:	4426      	add	r6, r4
   2c4e2:	e7e7      	b.n	2c4b4 <ring_buf_put_claim+0x10>

0002c4e4 <ring_buf_put_finish>:
{
   2c4e4:	b430      	push	{r4, r5}
	finish_space = buf->put_head - buf->put_tail;
   2c4e6:	6844      	ldr	r4, [r0, #4]
   2c4e8:	6883      	ldr	r3, [r0, #8]
   2c4ea:	1ae4      	subs	r4, r4, r3
	if (unlikely(size > finish_space)) {
   2c4ec:	428c      	cmp	r4, r1
   2c4ee:	bf2c      	ite	cs
   2c4f0:	2400      	movcs	r4, #0
   2c4f2:	2401      	movcc	r4, #1
   2c4f4:	b98c      	cbnz	r4, 2c51a <ring_buf_put_finish+0x36>
   2c4f6:	4602      	mov	r2, r0
	buf->put_tail += size;
   2c4f8:	4419      	add	r1, r3
   2c4fa:	6081      	str	r1, [r0, #8]
	buf->put_head = buf->put_tail;
   2c4fc:	6041      	str	r1, [r0, #4]
	wrap_size = buf->put_tail - buf->put_base;
   2c4fe:	68c3      	ldr	r3, [r0, #12]
   2c500:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   2c502:	69c5      	ldr	r5, [r0, #28]
   2c504:	428d      	cmp	r5, r1
   2c506:	bf8c      	ite	hi
   2c508:	2000      	movhi	r0, #0
   2c50a:	2001      	movls	r0, #1
   2c50c:	b908      	cbnz	r0, 2c512 <ring_buf_put_finish+0x2e>
}
   2c50e:	bc30      	pop	{r4, r5}
   2c510:	4770      	bx	lr
		buf->put_base += buf->size;
   2c512:	442b      	add	r3, r5
   2c514:	60d3      	str	r3, [r2, #12]
	return 0;
   2c516:	4620      	mov	r0, r4
   2c518:	e7f9      	b.n	2c50e <ring_buf_put_finish+0x2a>
		return -EINVAL;
   2c51a:	f06f 0015 	mvn.w	r0, #21
   2c51e:	e7f6      	b.n	2c50e <ring_buf_put_finish+0x2a>

0002c520 <assert_post_action>:
	if (k_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   2c520:	4040      	eors	r0, r0
   2c522:	f380 8811 	msr	BASEPRI, r0
   2c526:	f04f 0004 	mov.w	r0, #4
   2c52a:	df02      	svc	2
}
   2c52c:	4770      	bx	lr

0002c52e <assert_print>:

void assert_print(const char *fmt, ...)
{
   2c52e:	b40f      	push	{r0, r1, r2, r3}
   2c530:	b500      	push	{lr}
   2c532:	b083      	sub	sp, #12
   2c534:	a904      	add	r1, sp, #16
   2c536:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   2c53a:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
   2c53c:	f7e9 fab8 	bl	15ab0 <vprintk>

	va_end(ap);
}
   2c540:	b003      	add	sp, #12
   2c542:	f85d eb04 	ldr.w	lr, [sp], #4
   2c546:	b004      	add	sp, #16
   2c548:	4770      	bx	lr

0002c54a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
   2c54a:	4770      	bx	lr

0002c54c <z_log_minimal_printk>:
{
   2c54c:	b40f      	push	{r0, r1, r2, r3}
   2c54e:	b500      	push	{lr}
   2c550:	b083      	sub	sp, #12
   2c552:	a904      	add	r1, sp, #16
   2c554:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   2c558:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
   2c55a:	f7e9 faa9 	bl	15ab0 <vprintk>
}
   2c55e:	b003      	add	sp, #12
   2c560:	f85d eb04 	ldr.w	lr, [sp], #4
   2c564:	b004      	add	sp, #16
   2c566:	4770      	bx	lr

0002c568 <pm_policy_state_lock_is_active>:
			return (atomic_get(&substate_lock_t[i].lock) != 0);
		}
	}

	return false;
}
   2c568:	2000      	movs	r0, #0
   2c56a:	4770      	bx	lr

0002c56c <pm_device_state_get>:
}

int pm_device_state_get(const struct device *dev,
			enum pm_device_state *state)
{
	struct pm_device *pm = dev->pm;
   2c56c:	6983      	ldr	r3, [r0, #24]

	if (pm == NULL) {
   2c56e:	b11b      	cbz	r3, 2c578 <pm_device_state_get+0xc>
		return -ENOSYS;
	}

	*state = pm->state;
   2c570:	7a1b      	ldrb	r3, [r3, #8]
   2c572:	700b      	strb	r3, [r1, #0]

	return 0;
   2c574:	2000      	movs	r0, #0
   2c576:	4770      	bx	lr
		return -ENOSYS;
   2c578:	f06f 0057 	mvn.w	r0, #87	; 0x57
}
   2c57c:	4770      	bx	lr

0002c57e <pm_device_is_busy>:
	return false;
}

bool pm_device_is_busy(const struct device *dev)
{
	struct pm_device *pm = dev->pm;
   2c57e:	6983      	ldr	r3, [r0, #24]

	if (pm == NULL) {
   2c580:	b13b      	cbz	r3, 2c592 <pm_device_is_busy+0x14>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2c582:	f3bf 8f5b 	dmb	ish
   2c586:	6858      	ldr	r0, [r3, #4]
   2c588:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2c58c:	f000 0001 	and.w	r0, r0, #1
		return false;
	}

	return atomic_test_bit(&pm->flags, PM_DEVICE_FLAG_BUSY);
   2c590:	4770      	bx	lr
		return false;
   2c592:	2000      	movs	r0, #0
}
   2c594:	4770      	bx	lr

0002c596 <pm_device_wakeup_is_enabled>:
	return atomic_cas(&pm->flags, flags, new_flags);
}

bool pm_device_wakeup_is_enabled(const struct device *dev)
{
	struct pm_device *pm = dev->pm;
   2c596:	6983      	ldr	r3, [r0, #24]

	if (pm == NULL) {
   2c598:	b13b      	cbz	r3, 2c5aa <pm_device_wakeup_is_enabled+0x14>
   2c59a:	f3bf 8f5b 	dmb	ish
   2c59e:	6858      	ldr	r0, [r3, #4]
   2c5a0:	f3bf 8f5b 	dmb	ish
   2c5a4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
		return false;
	}

	return atomic_test_bit(&pm->flags,
   2c5a8:	4770      	bx	lr
		return false;
   2c5aa:	2000      	movs	r0, #0
			       PM_DEVICE_FLAG_WS_ENABLED);
}
   2c5ac:	4770      	bx	lr

0002c5ae <pm_device_state_is_locked>:
	}
}

bool pm_device_state_is_locked(const struct device *dev)
{
	struct pm_device *pm = dev->pm;
   2c5ae:	6983      	ldr	r3, [r0, #24]

	if (pm == NULL) {
   2c5b0:	b13b      	cbz	r3, 2c5c2 <pm_device_state_is_locked+0x14>
   2c5b2:	f3bf 8f5b 	dmb	ish
   2c5b6:	6858      	ldr	r0, [r3, #4]
   2c5b8:	f3bf 8f5b 	dmb	ish
   2c5bc:	f3c0 1040 	ubfx	r0, r0, #5, #1
		return false;
	}

	return atomic_test_bit(&pm->flags,
   2c5c0:	4770      	bx	lr
		return false;
   2c5c2:	2000      	movs	r0, #0
			       PM_DEVICE_FLAG_STATE_LOCKED);
}
   2c5c4:	4770      	bx	lr

0002c5c6 <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
   2c5c6:	428b      	cmp	r3, r1
   2c5c8:	d808      	bhi.n	2c5dc <_copy+0x16>
{
   2c5ca:	b510      	push	{r4, lr}
   2c5cc:	4694      	mov	ip, r2
   2c5ce:	461c      	mov	r4, r3
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2c5d0:	461a      	mov	r2, r3
   2c5d2:	4661      	mov	r1, ip
   2c5d4:	f004 fc47 	bl	30e66 <memcpy>
		(void)memcpy(to, from, from_len);
		return from_len;
   2c5d8:	4620      	mov	r0, r4
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   2c5da:	bd10      	pop	{r4, pc}
		return TC_CRYPTO_FAIL;
   2c5dc:	2000      	movs	r0, #0
}
   2c5de:	4770      	bx	lr

0002c5e0 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
   2c5e0:	b508      	push	{r3, lr}
__ssp_bos_icheck3(memset, void *, int)
   2c5e2:	f004 fc61 	bl	30ea8 <memset>
	(void)memset(to, val, len);
}
   2c5e6:	bd08      	pop	{r3, pc}

0002c5e8 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   2c5e8:	09c3      	lsrs	r3, r0, #7
   2c5ea:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   2c5ee:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   2c5f2:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   2c5f6:	b2c0      	uxtb	r0, r0
   2c5f8:	4770      	bx	lr

0002c5fa <gf_double>:
 */
void gf_double(uint8_t *out, uint8_t *in)
{

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);
   2c5fa:	460b      	mov	r3, r1

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   2c5fc:	f913 2b0f 	ldrsb.w	r2, [r3], #15
   2c600:	2a00      	cmp	r2, #0
   2c602:	db04      	blt.n	2c60e <gf_double+0x14>
   2c604:	f04f 0c00 	mov.w	ip, #0

	out += (TC_AES_BLOCK_SIZE - 1);
   2c608:	f100 020f 	add.w	r2, r0, #15
   2c60c:	e006      	b.n	2c61c <gf_double+0x22>
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   2c60e:	f04f 0c87 	mov.w	ip, #135	; 0x87
   2c612:	e7f9      	b.n	2c608 <gf_double+0xe>
	for (;;) {
		*out-- = (*x << 1) ^ carry;
		if (x == in) {
			break;
		}
		carry = *x-- >> 7;
   2c614:	f813 0901 	ldrb.w	r0, [r3], #-1
   2c618:	ea4f 1cd0 	mov.w	ip, r0, lsr #7
		*out-- = (*x << 1) ^ carry;
   2c61c:	7818      	ldrb	r0, [r3, #0]
   2c61e:	ea8c 0040 	eor.w	r0, ip, r0, lsl #1
   2c622:	f802 0901 	strb.w	r0, [r2], #-1
		if (x == in) {
   2c626:	428b      	cmp	r3, r1
   2c628:	d1f4      	bne.n	2c614 <gf_double+0x1a>
	}
}
   2c62a:	4770      	bx	lr

0002c62c <tc_cmac_erase>:
	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
	if (s == (TCCmacState_t) 0) {
   2c62c:	b130      	cbz	r0, 2c63c <tc_cmac_erase+0x10>
{
   2c62e:	b508      	push	{r3, lr}
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   2c630:	2258      	movs	r2, #88	; 0x58
   2c632:	2100      	movs	r1, #0
   2c634:	f7ff ffd4 	bl	2c5e0 <_set>

	return TC_CRYPTO_SUCCESS;
   2c638:	2001      	movs	r0, #1
}
   2c63a:	bd08      	pop	{r3, pc}
		return TC_CRYPTO_FAIL;
   2c63c:	2000      	movs	r0, #0
}
   2c63e:	4770      	bx	lr

0002c640 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   2c640:	b1a0      	cbz	r0, 2c66c <tc_cmac_init+0x2c>
{
   2c642:	b510      	push	{r4, lr}
   2c644:	4604      	mov	r4, r0
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   2c646:	2210      	movs	r2, #16
   2c648:	2100      	movs	r1, #0
   2c64a:	f7ff ffc9 	bl	2c5e0 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   2c64e:	2210      	movs	r2, #16
   2c650:	2100      	movs	r1, #0
   2c652:	f104 0030 	add.w	r0, r4, #48	; 0x30
   2c656:	f7ff ffc3 	bl	2c5e0 <_set>
	s->leftover_offset = 0;
   2c65a:	2300      	movs	r3, #0
   2c65c:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   2c65e:	2200      	movs	r2, #0
   2c660:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   2c664:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50

	return TC_CRYPTO_SUCCESS;
   2c668:	2001      	movs	r0, #1
}
   2c66a:	bd10      	pop	{r4, pc}
		return TC_CRYPTO_FAIL;
   2c66c:	2000      	movs	r0, #0
}
   2c66e:	4770      	bx	lr

0002c670 <tc_cmac_setup>:
	if (s == (TCCmacState_t) 0 ||
   2c670:	b338      	cbz	r0, 2c6c2 <tc_cmac_setup+0x52>
{
   2c672:	b570      	push	{r4, r5, r6, lr}
   2c674:	460d      	mov	r5, r1
   2c676:	4616      	mov	r6, r2
   2c678:	4604      	mov	r4, r0
	if (s == (TCCmacState_t) 0 ||
   2c67a:	b321      	cbz	r1, 2c6c6 <tc_cmac_setup+0x56>
	_set(s, 0, sizeof(*s));
   2c67c:	2258      	movs	r2, #88	; 0x58
   2c67e:	2100      	movs	r1, #0
   2c680:	f7ff ffae 	bl	2c5e0 <_set>
	s->sched = sched;
   2c684:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   2c686:	4629      	mov	r1, r5
   2c688:	4630      	mov	r0, r6
   2c68a:	f7eb f9ab 	bl	179e4 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   2c68e:	2210      	movs	r2, #16
   2c690:	2100      	movs	r1, #0
   2c692:	4620      	mov	r0, r4
   2c694:	f7ff ffa4 	bl	2c5e0 <_set>
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   2c698:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2c69a:	4621      	mov	r1, r4
   2c69c:	4620      	mov	r0, r4
   2c69e:	f7eb fa03 	bl	17aa8 <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   2c6a2:	f104 0510 	add.w	r5, r4, #16
   2c6a6:	4621      	mov	r1, r4
   2c6a8:	4628      	mov	r0, r5
   2c6aa:	f7ff ffa6 	bl	2c5fa <gf_double>
	gf_double (s->K2, s->K1);
   2c6ae:	4629      	mov	r1, r5
   2c6b0:	f104 0020 	add.w	r0, r4, #32
   2c6b4:	f7ff ffa1 	bl	2c5fa <gf_double>
	tc_cmac_init(s);
   2c6b8:	4620      	mov	r0, r4
   2c6ba:	f7ff ffc1 	bl	2c640 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   2c6be:	2001      	movs	r0, #1
}
   2c6c0:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   2c6c2:	2000      	movs	r0, #0
}
   2c6c4:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   2c6c6:	2000      	movs	r0, #0
   2c6c8:	e7fa      	b.n	2c6c0 <tc_cmac_setup+0x50>

0002c6ca <tc_cmac_update>:
int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   2c6ca:	2800      	cmp	r0, #0
   2c6cc:	d064      	beq.n	2c798 <tc_cmac_update+0xce>
{
   2c6ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c6d2:	460d      	mov	r5, r1
   2c6d4:	4616      	mov	r6, r2
   2c6d6:	4604      	mov	r4, r0
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   2c6d8:	2a00      	cmp	r2, #0
   2c6da:	d05f      	beq.n	2c79c <tc_cmac_update+0xd2>
		return  TC_CRYPTO_SUCCESS;
	}
	if (data == (const uint8_t *) 0) {
   2c6dc:	2900      	cmp	r1, #0
   2c6de:	d060      	beq.n	2c7a2 <tc_cmac_update+0xd8>
		return TC_CRYPTO_FAIL;
	}

	if (s->countdown == 0) {
   2c6e0:	6d03      	ldr	r3, [r0, #80]	; 0x50
   2c6e2:	6d42      	ldr	r2, [r0, #84]	; 0x54
   2c6e4:	ea53 0102 	orrs.w	r1, r3, r2
   2c6e8:	d05d      	beq.n	2c7a6 <tc_cmac_update+0xdc>
		return TC_CRYPTO_FAIL;
	}

	s->countdown--;
   2c6ea:	3b01      	subs	r3, #1
   2c6ec:	f142 32ff 	adc.w	r2, r2, #4294967295	; 0xffffffff
   2c6f0:	6503      	str	r3, [r0, #80]	; 0x50
   2c6f2:	6542      	str	r2, [r0, #84]	; 0x54

	if (s->leftover_offset > 0) {
   2c6f4:	6c47      	ldr	r7, [r0, #68]	; 0x44
   2c6f6:	2f00      	cmp	r7, #0
   2c6f8:	d03d      	beq.n	2c776 <tc_cmac_update+0xac>
		/* last data added to s didn't end on a TC_AES_BLOCK_SIZE byte boundary */
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   2c6fa:	f1c7 0810 	rsb	r8, r7, #16

		if (data_length < remaining_space) {
   2c6fe:	4546      	cmp	r6, r8
   2c700:	d30d      	bcc.n	2c71e <tc_cmac_update+0x54>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
			s->leftover_offset += data_length;
			return TC_CRYPTO_SUCCESS;
		}
		/* leftover block is now full; encrypt it first */
		_copy(&s->leftover[s->leftover_offset],
   2c702:	f107 0030 	add.w	r0, r7, #48	; 0x30
   2c706:	4643      	mov	r3, r8
   2c708:	462a      	mov	r2, r5
   2c70a:	4641      	mov	r1, r8
   2c70c:	4420      	add	r0, r4
   2c70e:	f7ff ff5a 	bl	2c5c6 <_copy>
		      remaining_space,
		      data,
		      remaining_space);
		data_length -= remaining_space;
   2c712:	3f10      	subs	r7, #16
   2c714:	443e      	add	r6, r7
		data += remaining_space;
   2c716:	4445      	add	r5, r8
		s->leftover_offset = 0;
   2c718:	2300      	movs	r3, #0
   2c71a:	6463      	str	r3, [r4, #68]	; 0x44

		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2c71c:	e013      	b.n	2c746 <tc_cmac_update+0x7c>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   2c71e:	f107 0030 	add.w	r0, r7, #48	; 0x30
   2c722:	4633      	mov	r3, r6
   2c724:	462a      	mov	r2, r5
   2c726:	4631      	mov	r1, r6
   2c728:	4420      	add	r0, r4
   2c72a:	f7ff ff4c 	bl	2c5c6 <_copy>
			s->leftover_offset += data_length;
   2c72e:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2c730:	4433      	add	r3, r6
   2c732:	6463      	str	r3, [r4, #68]	; 0x44
			return TC_CRYPTO_SUCCESS;
   2c734:	2001      	movs	r0, #1
   2c736:	e032      	b.n	2c79e <tc_cmac_update+0xd4>
			s->iv[i] ^= s->leftover[i];
   2c738:	18e2      	adds	r2, r4, r3
   2c73a:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
   2c73e:	5ce1      	ldrb	r1, [r4, r3]
   2c740:	404a      	eors	r2, r1
   2c742:	54e2      	strb	r2, [r4, r3]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2c744:	3301      	adds	r3, #1
   2c746:	2b0f      	cmp	r3, #15
   2c748:	d9f6      	bls.n	2c738 <tc_cmac_update+0x6e>
		}
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   2c74a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2c74c:	4621      	mov	r1, r4
   2c74e:	4620      	mov	r0, r4
   2c750:	f7eb f9aa 	bl	17aa8 <tc_aes_encrypt>
   2c754:	e00f      	b.n	2c776 <tc_cmac_update+0xac>
	}

	/* CBC encrypt each (except the last) of the data blocks */
	while (data_length > TC_AES_BLOCK_SIZE) {
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
			s->iv[i] ^= data[i];
   2c756:	5ce8      	ldrb	r0, [r5, r3]
   2c758:	f814 c003 	ldrb.w	ip, [r4, r3]
   2c75c:	ea80 000c 	eor.w	r0, r0, ip
   2c760:	54e0      	strb	r0, [r4, r3]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2c762:	3301      	adds	r3, #1
   2c764:	2b0f      	cmp	r3, #15
   2c766:	d9f6      	bls.n	2c756 <tc_cmac_update+0x8c>
		}
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   2c768:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2c76a:	4621      	mov	r1, r4
   2c76c:	4620      	mov	r0, r4
   2c76e:	f7eb f99b 	bl	17aa8 <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   2c772:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   2c774:	3e10      	subs	r6, #16
	while (data_length > TC_AES_BLOCK_SIZE) {
   2c776:	2e10      	cmp	r6, #16
   2c778:	d901      	bls.n	2c77e <tc_cmac_update+0xb4>
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2c77a:	2300      	movs	r3, #0
   2c77c:	e7f2      	b.n	2c764 <tc_cmac_update+0x9a>
	}

	if (data_length > 0) {
   2c77e:	b90e      	cbnz	r6, 2c784 <tc_cmac_update+0xba>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   2c780:	2001      	movs	r0, #1
   2c782:	e00c      	b.n	2c79e <tc_cmac_update+0xd4>
		_copy(s->leftover, data_length, data, data_length);
   2c784:	4633      	mov	r3, r6
   2c786:	462a      	mov	r2, r5
   2c788:	4631      	mov	r1, r6
   2c78a:	f104 0030 	add.w	r0, r4, #48	; 0x30
   2c78e:	f7ff ff1a 	bl	2c5c6 <_copy>
		s->leftover_offset = data_length;
   2c792:	6466      	str	r6, [r4, #68]	; 0x44
	return TC_CRYPTO_SUCCESS;
   2c794:	2001      	movs	r0, #1
   2c796:	e002      	b.n	2c79e <tc_cmac_update+0xd4>
		return TC_CRYPTO_FAIL;
   2c798:	2000      	movs	r0, #0
}
   2c79a:	4770      	bx	lr
		return  TC_CRYPTO_SUCCESS;
   2c79c:	2001      	movs	r0, #1
}
   2c79e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TC_CRYPTO_FAIL;
   2c7a2:	2000      	movs	r0, #0
   2c7a4:	e7fb      	b.n	2c79e <tc_cmac_update+0xd4>
		return TC_CRYPTO_FAIL;
   2c7a6:	2000      	movs	r0, #0
   2c7a8:	e7f9      	b.n	2c79e <tc_cmac_update+0xd4>

0002c7aa <tc_cmac_final>:
{
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   2c7aa:	b370      	cbz	r0, 2c80a <tc_cmac_final+0x60>
{
   2c7ac:	b538      	push	{r3, r4, r5, lr}
   2c7ae:	460c      	mov	r4, r1
   2c7b0:	4605      	mov	r5, r0
	if (tag == (uint8_t *) 0 ||
   2c7b2:	b361      	cbz	r1, 2c80e <tc_cmac_final+0x64>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   2c7b4:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   2c7b6:	2a10      	cmp	r2, #16
   2c7b8:	d102      	bne.n	2c7c0 <tc_cmac_final+0x16>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   2c7ba:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2c7bc:	2300      	movs	r3, #0
   2c7be:	e018      	b.n	2c7f2 <tc_cmac_final+0x48>
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   2c7c0:	f102 0030 	add.w	r0, r2, #48	; 0x30
   2c7c4:	f1c2 0210 	rsb	r2, r2, #16
   2c7c8:	2100      	movs	r1, #0
   2c7ca:	4420      	add	r0, r4
   2c7cc:	f7ff ff08 	bl	2c5e0 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   2c7d0:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2c7d2:	4423      	add	r3, r4
   2c7d4:	2280      	movs	r2, #128	; 0x80
   2c7d6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   2c7da:	f104 0120 	add.w	r1, r4, #32
   2c7de:	e7ed      	b.n	2c7bc <tc_cmac_final+0x12>
		s->iv[i] ^= s->leftover[i] ^ k[i];
   2c7e0:	18e2      	adds	r2, r4, r3
   2c7e2:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
   2c7e6:	5cc8      	ldrb	r0, [r1, r3]
   2c7e8:	4050      	eors	r0, r2
   2c7ea:	5ce2      	ldrb	r2, [r4, r3]
   2c7ec:	4042      	eors	r2, r0
   2c7ee:	54e2      	strb	r2, [r4, r3]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2c7f0:	3301      	adds	r3, #1
   2c7f2:	2b0f      	cmp	r3, #15
   2c7f4:	d9f4      	bls.n	2c7e0 <tc_cmac_final+0x36>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   2c7f6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2c7f8:	4621      	mov	r1, r4
   2c7fa:	4628      	mov	r0, r5
   2c7fc:	f7eb f954 	bl	17aa8 <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   2c800:	4620      	mov	r0, r4
   2c802:	f7ff ff13 	bl	2c62c <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   2c806:	2001      	movs	r0, #1
}
   2c808:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   2c80a:	2000      	movs	r0, #0
}
   2c80c:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   2c80e:	2000      	movs	r0, #0
   2c810:	e7fa      	b.n	2c808 <tc_cmac_final+0x5e>

0002c812 <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   2c812:	b538      	push	{r3, r4, r5, lr}
   2c814:	4604      	mov	r4, r0

	if (esf != NULL) {
   2c816:	460d      	mov	r5, r1
   2c818:	b111      	cbz	r1, 2c820 <z_arm_fatal_error+0xe>
		esf_dump(esf);
   2c81a:	4608      	mov	r0, r1
   2c81c:	f7eb fcd4 	bl	181c8 <esf_dump>
	}
	z_fatal_error(reason, esf);
   2c820:	4629      	mov	r1, r5
   2c822:	4620      	mov	r0, r4
   2c824:	f7f9 fb02 	bl	25e2c <z_fatal_error>
}
   2c828:	bd38      	pop	{r3, r4, r5, pc}

0002c82a <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
   2c82a:	b508      	push	{r3, lr}
   2c82c:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   2c82e:	6800      	ldr	r0, [r0, #0]
   2c830:	f7ff ffef 	bl	2c812 <z_arm_fatal_error>
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
   2c834:	bd08      	pop	{r3, pc}

0002c836 <z_irq_spurious>:
{
   2c836:	b508      	push	{r3, lr}
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   2c838:	2100      	movs	r1, #0
   2c83a:	2001      	movs	r0, #1
   2c83c:	f7ff ffe9 	bl	2c812 <z_arm_fatal_error>
}
   2c840:	bd08      	pop	{r3, pc}

0002c842 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   2c842:	b508      	push	{r3, lr}
	handler();
   2c844:	f7eb fd96 	bl	18374 <z_SysNmiOnReset>
	z_arm_int_exit();
   2c848:	f7eb ff22 	bl	18690 <z_arm_exc_exit>
}
   2c84c:	bd08      	pop	{r3, pc}

0002c84e <z_arm_prepare_switch_to_main>:
  __builtin_arm_set_fpscr(fpscr);
   2c84e:	2300      	movs	r3, #0
   2c850:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
   2c854:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   2c858:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   2c85c:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
   2c860:	f3bf 8f6f 	isb	sy
   2c864:	f3bf 8f6f 	isb	sy
}
   2c868:	4770      	bx	lr

0002c86a <memory_fault_recoverable>:
}
   2c86a:	2000      	movs	r0, #0
   2c86c:	4770      	bx	lr

0002c86e <fault_handle>:
{
   2c86e:	b508      	push	{r3, lr}
	*recoverable = false;
   2c870:	2300      	movs	r3, #0
   2c872:	7013      	strb	r3, [r2, #0]
	switch (fault) {
   2c874:	1ecb      	subs	r3, r1, #3
   2c876:	2b09      	cmp	r3, #9
   2c878:	d81a      	bhi.n	2c8b0 <fault_handle+0x42>
   2c87a:	e8df f003 	tbb	[pc, r3]
   2c87e:	0905      	.short	0x0905
   2c880:	1919110d 	.word	0x1919110d
   2c884:	14191919 	.word	0x14191919
		reason = hard_fault(esf, recoverable);
   2c888:	4611      	mov	r1, r2
   2c88a:	f7ec f8a3 	bl	189d4 <hard_fault>
}
   2c88e:	bd08      	pop	{r3, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   2c890:	2100      	movs	r1, #0
   2c892:	f7eb fff7 	bl	18884 <mem_manage_fault>
		break;
   2c896:	e7fa      	b.n	2c88e <fault_handle+0x20>
		reason = bus_fault(esf, 0, recoverable);
   2c898:	2100      	movs	r1, #0
   2c89a:	f7eb ff07 	bl	186ac <bus_fault>
		break;
   2c89e:	e7f6      	b.n	2c88e <fault_handle+0x20>
		reason = usage_fault(esf);
   2c8a0:	f7eb ff78 	bl	18794 <usage_fault>
		break;
   2c8a4:	e7f3      	b.n	2c88e <fault_handle+0x20>
		debug_monitor(esf, recoverable);
   2c8a6:	4611      	mov	r1, r2
   2c8a8:	f7eb ffce 	bl	18848 <debug_monitor>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   2c8ac:	2000      	movs	r0, #0
		break;
   2c8ae:	e7ee      	b.n	2c88e <fault_handle+0x20>
		reserved_exception(esf, fault);
   2c8b0:	f7eb ffd4 	bl	1885c <reserved_exception>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   2c8b4:	2000      	movs	r0, #0
	return reason;
   2c8b6:	e7ea      	b.n	2c88e <fault_handle+0x20>

0002c8b8 <mpu_partition_is_valid>:
		((part->size & (part->size - 1U)) == 0U)
   2c8b8:	6843      	ldr	r3, [r0, #4]
   2c8ba:	1e5a      	subs	r2, r3, #1
		&&
   2c8bc:	4213      	tst	r3, r2
   2c8be:	d106      	bne.n	2c8ce <mpu_partition_is_valid+0x16>
		&&
   2c8c0:	2b1f      	cmp	r3, #31
   2c8c2:	d906      	bls.n	2c8d2 <mpu_partition_is_valid+0x1a>
		((part->start & (part->size - 1U)) == 0U);
   2c8c4:	6803      	ldr	r3, [r0, #0]
		&&
   2c8c6:	421a      	tst	r2, r3
   2c8c8:	d005      	beq.n	2c8d6 <mpu_partition_is_valid+0x1e>
   2c8ca:	2000      	movs	r0, #0
   2c8cc:	4770      	bx	lr
   2c8ce:	2000      	movs	r0, #0
   2c8d0:	4770      	bx	lr
   2c8d2:	2000      	movs	r0, #0
   2c8d4:	4770      	bx	lr
   2c8d6:	2001      	movs	r0, #1
}
   2c8d8:	4770      	bx	lr

0002c8da <mpu_configure_region>:
{
   2c8da:	b500      	push	{lr}
   2c8dc:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
   2c8de:	680b      	ldr	r3, [r1, #0]
   2c8e0:	9301      	str	r3, [sp, #4]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   2c8e2:	684b      	ldr	r3, [r1, #4]
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
   2c8e4:	688a      	ldr	r2, [r1, #8]
	if (size <= 32U) {
   2c8e6:	2b20      	cmp	r3, #32
   2c8e8:	d912      	bls.n	2c910 <mpu_configure_region+0x36>
	if (size > (1UL << 31)) {
   2c8ea:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   2c8ee:	d811      	bhi.n	2c914 <mpu_configure_region+0x3a>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
   2c8f0:	3b01      	subs	r3, #1
   2c8f2:	fab3 f383 	clz	r3, r3
   2c8f6:	f1c3 031f 	rsb	r3, r3, #31
   2c8fa:	005b      	lsls	r3, r3, #1
   2c8fc:	f003 033e 	and.w	r3, r3, #62	; 0x3e
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
   2c900:	4313      	orrs	r3, r2
   2c902:	9303      	str	r3, [sp, #12]
	return region_allocate_and_init(index,
   2c904:	a901      	add	r1, sp, #4
   2c906:	f7ec fa2f 	bl	18d68 <region_allocate_and_init>
}
   2c90a:	b005      	add	sp, #20
   2c90c:	f85d fb04 	ldr.w	pc, [sp], #4
		return REGION_32B;
   2c910:	2308      	movs	r3, #8
   2c912:	e7f5      	b.n	2c900 <mpu_configure_region+0x26>
		return REGION_4G;
   2c914:	233e      	movs	r3, #62	; 0x3e
   2c916:	e7f3      	b.n	2c900 <mpu_configure_region+0x26>

0002c918 <_stdout_hook_default>:
}
   2c918:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2c91c:	4770      	bx	lr

0002c91e <_write>:
{
   2c91e:	b508      	push	{r3, lr}
   2c920:	4608      	mov	r0, r1
   2c922:	4611      	mov	r1, r2
		union { uintptr_t x; int val; } parm1 = { .val = nbytes };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_ZEPHYR_WRITE_STDOUT);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_write_stdout(buf, nbytes);
   2c924:	f7ec fb3a 	bl	18f9c <z_impl_zephyr_write_stdout>
}
   2c928:	bd08      	pop	{r3, pc}

0002c92a <__errno>:
{
   2c92a:	b508      	push	{r3, lr}
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   2c92c:	f7f9 fa48 	bl	25dc0 <z_impl_z_errno>
}
   2c930:	bd08      	pop	{r3, pc}

0002c932 <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
   2c932:	2806      	cmp	r0, #6
   2c934:	d000      	beq.n	2c938 <pm_state_set+0x6>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
   2c936:	4770      	bx	lr
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
   2c938:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2c93c:	2201      	movs	r2, #1
   2c93e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   2c942:	f3bf 8f4f 	dsb	sy
        __WFE();
   2c946:	bf20      	wfe
    while (true)
   2c948:	e7fd      	b.n	2c946 <pm_state_set+0x14>

0002c94a <pm_state_exit_post_ops>:
   2c94a:	2300      	movs	r3, #0
   2c94c:	f383 8811 	msr	BASEPRI, r3
   2c950:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   2c954:	4770      	bx	lr

0002c956 <uuid128_cmp>:

static int uuid128_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   2c956:	b510      	push	{r4, lr}
   2c958:	b08a      	sub	sp, #40	; 0x28
   2c95a:	460c      	mov	r4, r1
	struct bt_uuid_128 uuid1, uuid2;

	uuid_to_uuid128(u1, &uuid1);
   2c95c:	a905      	add	r1, sp, #20
   2c95e:	f7ec fc25 	bl	191ac <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   2c962:	4669      	mov	r1, sp
   2c964:	4620      	mov	r0, r4
   2c966:	f7ec fc21 	bl	191ac <uuid_to_uuid128>

	return memcmp(uuid1.val, uuid2.val, 16);
   2c96a:	2210      	movs	r2, #16
   2c96c:	f10d 0101 	add.w	r1, sp, #1
   2c970:	f10d 0015 	add.w	r0, sp, #21
   2c974:	f004 fa67 	bl	30e46 <memcmp>
}
   2c978:	b00a      	add	sp, #40	; 0x28
   2c97a:	bd10      	pop	{r4, pc}

0002c97c <bt_uuid_cmp>:

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   2c97c:	b508      	push	{r3, lr}
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
   2c97e:	7803      	ldrb	r3, [r0, #0]
   2c980:	780a      	ldrb	r2, [r1, #0]
   2c982:	4293      	cmp	r3, r2
   2c984:	d107      	bne.n	2c996 <bt_uuid_cmp+0x1a>
		return uuid128_cmp(u1, u2);
	}

	switch (u1->type) {
   2c986:	2b01      	cmp	r3, #1
   2c988:	d00c      	beq.n	2c9a4 <bt_uuid_cmp+0x28>
   2c98a:	2b02      	cmp	r3, #2
   2c98c:	d00e      	beq.n	2c9ac <bt_uuid_cmp+0x30>
   2c98e:	b12b      	cbz	r3, 2c99c <bt_uuid_cmp+0x20>
   2c990:	f06f 0015 	mvn.w	r0, #21
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
	}

	return -EINVAL;
}
   2c994:	bd08      	pop	{r3, pc}
		return uuid128_cmp(u1, u2);
   2c996:	f7ff ffde 	bl	2c956 <uuid128_cmp>
   2c99a:	e7fb      	b.n	2c994 <bt_uuid_cmp+0x18>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   2c99c:	8840      	ldrh	r0, [r0, #2]
   2c99e:	884b      	ldrh	r3, [r1, #2]
   2c9a0:	1ac0      	subs	r0, r0, r3
   2c9a2:	e7f7      	b.n	2c994 <bt_uuid_cmp+0x18>
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   2c9a4:	6840      	ldr	r0, [r0, #4]
   2c9a6:	684b      	ldr	r3, [r1, #4]
   2c9a8:	1ac0      	subs	r0, r0, r3
   2c9aa:	e7f3      	b.n	2c994 <bt_uuid_cmp+0x18>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   2c9ac:	2210      	movs	r2, #16
   2c9ae:	3101      	adds	r1, #1
   2c9b0:	3001      	adds	r0, #1
   2c9b2:	f004 fa48 	bl	30e46 <memcmp>
   2c9b6:	e7ed      	b.n	2c994 <bt_uuid_cmp+0x18>

0002c9b8 <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const uint8_t *data, uint8_t data_len)
{
   2c9b8:	b500      	push	{lr}
   2c9ba:	4603      	mov	r3, r0
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
   2c9bc:	2a04      	cmp	r2, #4
   2c9be:	d00f      	beq.n	2c9e0 <bt_uuid_create+0x28>
   2c9c0:	2a10      	cmp	r2, #16
   2c9c2:	d01d      	beq.n	2ca00 <bt_uuid_create+0x48>
   2c9c4:	2a02      	cmp	r2, #2
   2c9c6:	d002      	beq.n	2c9ce <bt_uuid_create+0x16>
   2c9c8:	2000      	movs	r0, #0
		break;
	default:
		return false;
	}
	return true;
}
   2c9ca:	f85d fb04 	ldr.w	pc, [sp], #4
		uuid->type = BT_UUID_TYPE_16;
   2c9ce:	2200      	movs	r2, #0
   2c9d0:	7002      	strb	r2, [r0, #0]
	return ((uint16_t)src[1] << 8) | src[0];
   2c9d2:	7848      	ldrb	r0, [r1, #1]
   2c9d4:	780a      	ldrb	r2, [r1, #0]
   2c9d6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   2c9da:	805a      	strh	r2, [r3, #2]
	return true;
   2c9dc:	2001      	movs	r0, #1
		break;
   2c9de:	e7f4      	b.n	2c9ca <bt_uuid_create+0x12>
		uuid->type = BT_UUID_TYPE_32;
   2c9e0:	2001      	movs	r0, #1
   2c9e2:	7018      	strb	r0, [r3, #0]
   2c9e4:	f891 c003 	ldrb.w	ip, [r1, #3]
   2c9e8:	788a      	ldrb	r2, [r1, #2]
   2c9ea:	ea42 2c0c 	orr.w	ip, r2, ip, lsl #8
   2c9ee:	f891 e001 	ldrb.w	lr, [r1, #1]
   2c9f2:	780a      	ldrb	r2, [r1, #0]
   2c9f4:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   2c9f8:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   2c9fc:	605a      	str	r2, [r3, #4]
		break;
   2c9fe:	e7e4      	b.n	2c9ca <bt_uuid_create+0x12>
		uuid->type = BT_UUID_TYPE_128;
   2ca00:	4602      	mov	r2, r0
   2ca02:	2002      	movs	r0, #2
   2ca04:	f802 0b01 	strb.w	r0, [r2], #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2ca08:	f8d1 e000 	ldr.w	lr, [r1]
   2ca0c:	f8d1 c004 	ldr.w	ip, [r1, #4]
   2ca10:	6888      	ldr	r0, [r1, #8]
   2ca12:	68c9      	ldr	r1, [r1, #12]
   2ca14:	f8c3 e001 	str.w	lr, [r3, #1]
   2ca18:	f8c2 c004 	str.w	ip, [r2, #4]
   2ca1c:	6090      	str	r0, [r2, #8]
   2ca1e:	60d1      	str	r1, [r2, #12]
	return true;
   2ca20:	2001      	movs	r0, #1
   2ca22:	e7d2      	b.n	2c9ca <bt_uuid_create+0x12>

0002ca24 <bt_addr_le_create_static>:

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
   2ca24:	b510      	push	{r4, lr}
   2ca26:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   2ca28:	2301      	movs	r3, #1
   2ca2a:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   2ca2e:	2106      	movs	r1, #6
   2ca30:	f7f5 fe90 	bl	22754 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
   2ca34:	b918      	cbnz	r0, 2ca3e <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
   2ca36:	79a3      	ldrb	r3, [r4, #6]
   2ca38:	f063 033f 	orn	r3, r3, #63	; 0x3f
   2ca3c:	71a3      	strb	r3, [r4, #6]

	return 0;
}
   2ca3e:	bd10      	pop	{r4, pc}

0002ca40 <skip_auto_phy_update_on_conn_establishment>:
}
   2ca40:	2000      	movs	r0, #0
   2ca42:	4770      	bx	lr

0002ca44 <hci_vendor_event>:
}
   2ca44:	4770      	bx	lr

0002ca46 <hci_disconn_complete_prio>:
{
   2ca46:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   2ca48:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   2ca4a:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	if (evt->status) {
   2ca4e:	781b      	ldrb	r3, [r3, #0]
   2ca50:	b103      	cbz	r3, 2ca54 <hci_disconn_complete_prio+0xe>
}
   2ca52:	bd38      	pop	{r3, r4, r5, pc}
	conn = bt_conn_lookup_handle(handle);
   2ca54:	4620      	mov	r0, r4
   2ca56:	f7ee fe19 	bl	1b68c <bt_conn_lookup_handle>
	if (!conn) {
   2ca5a:	4605      	mov	r5, r0
   2ca5c:	b130      	cbz	r0, 2ca6c <hci_disconn_complete_prio+0x26>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
   2ca5e:	2101      	movs	r1, #1
   2ca60:	f7ee fe1e 	bl	1b6a0 <bt_conn_set_state>
	bt_conn_unref(conn);
   2ca64:	4628      	mov	r0, r5
   2ca66:	f7ee fddf 	bl	1b628 <bt_conn_unref>
   2ca6a:	e7f2      	b.n	2ca52 <hci_disconn_complete_prio+0xc>
		conn_handle_disconnected(handle);
   2ca6c:	4620      	mov	r0, r4
   2ca6e:	f7ec fc65 	bl	1933c <conn_handle_disconnected>
		return;
   2ca72:	e7ee      	b.n	2ca52 <hci_disconn_complete_prio+0xc>

0002ca74 <set_event_mask>:
{
   2ca74:	b510      	push	{r4, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
   2ca76:	2108      	movs	r1, #8
   2ca78:	f640 4001 	movw	r0, #3073	; 0xc01
   2ca7c:	f7ed f8e4 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2ca80:	b1b8      	cbz	r0, 2cab2 <set_event_mask+0x3e>
   2ca82:	4604      	mov	r4, r0
   2ca84:	2108      	movs	r1, #8
   2ca86:	4408      	add	r0, r1
   2ca88:	f7f2 fb5c 	bl	1f144 <net_buf_simple_add>
	dst[0] = val;
   2ca8c:	2310      	movs	r3, #16
   2ca8e:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
   2ca90:	2388      	movs	r3, #136	; 0x88
   2ca92:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
   2ca94:	2200      	movs	r2, #0
   2ca96:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
   2ca98:	2302      	movs	r3, #2
   2ca9a:	70c3      	strb	r3, [r0, #3]
	dst[0] = val;
   2ca9c:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
   2ca9e:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
   2caa0:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
   2caa2:	2320      	movs	r3, #32
   2caa4:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
   2caa6:	4621      	mov	r1, r4
   2caa8:	f640 4001 	movw	r0, #3073	; 0xc01
   2caac:	f7ed f91a 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2cab0:	bd10      	pop	{r4, pc}
		return -ENOBUFS;
   2cab2:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2cab6:	e7fb      	b.n	2cab0 <set_event_mask+0x3c>

0002cab8 <hci_le_read_remote_features>:
{
   2cab8:	b538      	push	{r3, r4, r5, lr}
   2caba:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
   2cabc:	2102      	movs	r1, #2
   2cabe:	f242 0016 	movw	r0, #8214	; 0x2016
   2cac2:	f7ed f8c1 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cac6:	b168      	cbz	r0, 2cae4 <hci_le_read_remote_features+0x2c>
   2cac8:	4605      	mov	r5, r0
   2caca:	2102      	movs	r1, #2
   2cacc:	3008      	adds	r0, #8
   2cace:	f7f2 fb39 	bl	1f144 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   2cad2:	8823      	ldrh	r3, [r4, #0]
   2cad4:	8003      	strh	r3, [r0, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf, NULL);
   2cad6:	2200      	movs	r2, #0
   2cad8:	4629      	mov	r1, r5
   2cada:	f242 0016 	movw	r0, #8214	; 0x2016
   2cade:	f7ed f901 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2cae2:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
   2cae4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2cae8:	e7fb      	b.n	2cae2 <hci_le_read_remote_features+0x2a>

0002caea <bt_hci_disconnect>:
{
   2caea:	b570      	push	{r4, r5, r6, lr}
   2caec:	4605      	mov	r5, r0
   2caee:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   2caf0:	2103      	movs	r1, #3
   2caf2:	f240 4006 	movw	r0, #1030	; 0x406
   2caf6:	f7ed f8a7 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cafa:	b168      	cbz	r0, 2cb18 <bt_hci_disconnect+0x2e>
   2cafc:	4606      	mov	r6, r0
   2cafe:	2103      	movs	r1, #3
   2cb00:	3008      	adds	r0, #8
   2cb02:	f7f2 fb1f 	bl	1f144 <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(handle);
   2cb06:	8005      	strh	r5, [r0, #0]
	disconn->reason = reason;
   2cb08:	7084      	strb	r4, [r0, #2]
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   2cb0a:	2200      	movs	r2, #0
   2cb0c:	4631      	mov	r1, r6
   2cb0e:	f240 4006 	movw	r0, #1030	; 0x406
   2cb12:	f7ed f8e7 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2cb16:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   2cb18:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2cb1c:	e7fb      	b.n	2cb16 <bt_hci_disconnect+0x2c>

0002cb1e <bt_le_set_data_len>:
{
   2cb1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2cb20:	4606      	mov	r6, r0
   2cb22:	460f      	mov	r7, r1
   2cb24:	4614      	mov	r4, r2
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   2cb26:	2106      	movs	r1, #6
   2cb28:	f242 0022 	movw	r0, #8226	; 0x2022
   2cb2c:	f7ed f88c 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cb30:	b178      	cbz	r0, 2cb52 <bt_le_set_data_len+0x34>
   2cb32:	4605      	mov	r5, r0
   2cb34:	2106      	movs	r1, #6
   2cb36:	3008      	adds	r0, #8
   2cb38:	f7f2 fb04 	bl	1f144 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   2cb3c:	8833      	ldrh	r3, [r6, #0]
   2cb3e:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
   2cb40:	8047      	strh	r7, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
   2cb42:	8084      	strh	r4, [r0, #4]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DATA_LEN, buf, NULL);
   2cb44:	2200      	movs	r2, #0
   2cb46:	4629      	mov	r1, r5
   2cb48:	f242 0022 	movw	r0, #8226	; 0x2022
   2cb4c:	f7ed f8ca 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2cb50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   2cb52:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2cb56:	e7fb      	b.n	2cb50 <bt_le_set_data_len+0x32>

0002cb58 <bt_le_set_phy>:
{
   2cb58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2cb5c:	4607      	mov	r7, r0
   2cb5e:	460e      	mov	r6, r1
   2cb60:	4615      	mov	r5, r2
   2cb62:	461c      	mov	r4, r3
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   2cb64:	2107      	movs	r1, #7
   2cb66:	f242 0032 	movw	r0, #8242	; 0x2032
   2cb6a:	f7ed f86d 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cb6e:	b1a8      	cbz	r0, 2cb9c <bt_le_set_phy+0x44>
   2cb70:	4680      	mov	r8, r0
   2cb72:	2107      	movs	r1, #7
   2cb74:	3008      	adds	r0, #8
   2cb76:	f7f2 fae5 	bl	1f144 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   2cb7a:	883b      	ldrh	r3, [r7, #0]
   2cb7c:	8003      	strh	r3, [r0, #0]
	cp->all_phys = all_phys;
   2cb7e:	7086      	strb	r6, [r0, #2]
	cp->tx_phys = pref_tx_phy;
   2cb80:	70c5      	strb	r5, [r0, #3]
	cp->rx_phys = pref_rx_phy;
   2cb82:	7104      	strb	r4, [r0, #4]
	cp->phy_opts = phy_opts;
   2cb84:	f89d 3018 	ldrb.w	r3, [sp, #24]
   2cb88:	f8a0 3005 	strh.w	r3, [r0, #5]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PHY, buf, NULL);
   2cb8c:	2200      	movs	r2, #0
   2cb8e:	4641      	mov	r1, r8
   2cb90:	f242 0032 	movw	r0, #8242	; 0x2032
   2cb94:	f7ed f8a6 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2cb98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   2cb9c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2cba0:	e7fa      	b.n	2cb98 <bt_le_set_phy+0x40>

0002cba2 <enh_conn_complete>:
{
   2cba2:	b508      	push	{r3, lr}
	bt_hci_le_enh_conn_complete(evt);
   2cba4:	f7ed fb74 	bl	1a290 <bt_hci_le_enh_conn_complete>
}
   2cba8:	bd08      	pop	{r3, pc}

0002cbaa <le_enh_conn_complete>:
{
   2cbaa:	b508      	push	{r3, lr}
	enh_conn_complete((void *)buf->data);
   2cbac:	6880      	ldr	r0, [r0, #8]
   2cbae:	f7ff fff8 	bl	2cba2 <enh_conn_complete>
}
   2cbb2:	bd08      	pop	{r3, pc}

0002cbb4 <le_legacy_conn_complete>:
{
   2cbb4:	b500      	push	{lr}
   2cbb6:	b08d      	sub	sp, #52	; 0x34
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   2cbb8:	6883      	ldr	r3, [r0, #8]
	enh.status         = evt->status;
   2cbba:	781a      	ldrb	r2, [r3, #0]
   2cbbc:	f88d 2000 	strb.w	r2, [sp]
	enh.handle         = evt->handle;
   2cbc0:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   2cbc4:	f8ad 2001 	strh.w	r2, [sp, #1]
	enh.role           = evt->role;
   2cbc8:	78da      	ldrb	r2, [r3, #3]
   2cbca:	f88d 2003 	strb.w	r2, [sp, #3]
	enh.interval       = evt->interval;
   2cbce:	f8b3 200b 	ldrh.w	r2, [r3, #11]
   2cbd2:	f8ad 2017 	strh.w	r2, [sp, #23]
	enh.latency        = evt->latency;
   2cbd6:	f8b3 200d 	ldrh.w	r2, [r3, #13]
   2cbda:	f8ad 2019 	strh.w	r2, [sp, #25]
	enh.supv_timeout   = evt->supv_timeout;
   2cbde:	f8b3 200f 	ldrh.w	r2, [r3, #15]
   2cbe2:	f8ad 201b 	strh.w	r2, [sp, #27]
	enh.clock_accuracy = evt->clock_accuracy;
   2cbe6:	7c5a      	ldrb	r2, [r3, #17]
   2cbe8:	f88d 201d 	strb.w	r2, [sp, #29]
	memcpy(dst, src, sizeof(*dst));
   2cbec:	6858      	ldr	r0, [r3, #4]
   2cbee:	9001      	str	r0, [sp, #4]
   2cbf0:	891a      	ldrh	r2, [r3, #8]
   2cbf2:	7a9b      	ldrb	r3, [r3, #10]
   2cbf4:	f8ad 2008 	strh.w	r2, [sp, #8]
   2cbf8:	f88d 300a 	strb.w	r3, [sp, #10]
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   2cbfc:	2300      	movs	r3, #0
   2cbfe:	930a      	str	r3, [sp, #40]	; 0x28
   2cc00:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
	memcpy(dst, src, sizeof(*dst));
   2cc04:	f8cd 300b 	str.w	r3, [sp, #11]
   2cc08:	f8ad 300f 	strh.w	r3, [sp, #15]
	bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   2cc0c:	9308      	str	r3, [sp, #32]
   2cc0e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
   2cc12:	f8cd 3011 	str.w	r3, [sp, #17]
   2cc16:	f8ad 3015 	strh.w	r3, [sp, #21]
	enh_conn_complete(&enh);
   2cc1a:	4668      	mov	r0, sp
   2cc1c:	f7ff ffc1 	bl	2cba2 <enh_conn_complete>
}
   2cc20:	b00d      	add	sp, #52	; 0x34
   2cc22:	f85d fb04 	ldr.w	pc, [sp], #4

0002cc26 <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   2cc26:	8802      	ldrh	r2, [r0, #0]
   2cc28:	8843      	ldrh	r3, [r0, #2]
   2cc2a:	429a      	cmp	r2, r3
   2cc2c:	d817      	bhi.n	2cc5e <bt_le_conn_params_valid+0x38>
   2cc2e:	2a05      	cmp	r2, #5
   2cc30:	d917      	bls.n	2cc62 <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   2cc32:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   2cc36:	d816      	bhi.n	2cc66 <bt_le_conn_params_valid+0x40>
	if (param->latency > 499) {
   2cc38:	8881      	ldrh	r1, [r0, #4]
   2cc3a:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
   2cc3e:	d214      	bcs.n	2cc6a <bt_le_conn_params_valid+0x44>
	if (param->timeout < 10 || param->timeout > 3200 ||
   2cc40:	88c0      	ldrh	r0, [r0, #6]
   2cc42:	f1a0 020a 	sub.w	r2, r0, #10
   2cc46:	b292      	uxth	r2, r2
   2cc48:	f640 4c76 	movw	ip, #3190	; 0xc76
   2cc4c:	4562      	cmp	r2, ip
   2cc4e:	d80e      	bhi.n	2cc6e <bt_le_conn_params_valid+0x48>
	     ((1U + param->latency) * param->interval_max))) {
   2cc50:	fb01 3303 	mla	r3, r1, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   2cc54:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
   2cc58:	d20b      	bcs.n	2cc72 <bt_le_conn_params_valid+0x4c>
	return true;
   2cc5a:	2001      	movs	r0, #1
   2cc5c:	4770      	bx	lr
		return false;
   2cc5e:	2000      	movs	r0, #0
   2cc60:	4770      	bx	lr
   2cc62:	2000      	movs	r0, #0
   2cc64:	4770      	bx	lr
   2cc66:	2000      	movs	r0, #0
   2cc68:	4770      	bx	lr
		return false;
   2cc6a:	2000      	movs	r0, #0
   2cc6c:	4770      	bx	lr
		return false;
   2cc6e:	2000      	movs	r0, #0
   2cc70:	4770      	bx	lr
   2cc72:	2000      	movs	r0, #0
}
   2cc74:	4770      	bx	lr

0002cc76 <le_conn_param_req_reply>:
{
   2cc76:	b570      	push	{r4, r5, r6, lr}
   2cc78:	4605      	mov	r5, r0
   2cc7a:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
   2cc7c:	210e      	movs	r1, #14
   2cc7e:	f242 0020 	movw	r0, #8224	; 0x2020
   2cc82:	f7ec ffe1 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cc86:	b1c0      	cbz	r0, 2ccba <le_conn_param_req_reply+0x44>
   2cc88:	4606      	mov	r6, r0
   2cc8a:	210e      	movs	r1, #14
   2cc8c:	3008      	adds	r0, #8
   2cc8e:	f7f2 fa59 	bl	1f144 <net_buf_simple_add>
__ssp_bos_icheck3(memset, void *, int)
   2cc92:	2300      	movs	r3, #0
   2cc94:	6003      	str	r3, [r0, #0]
   2cc96:	6043      	str	r3, [r0, #4]
   2cc98:	6083      	str	r3, [r0, #8]
   2cc9a:	8183      	strh	r3, [r0, #12]
	cp->handle = sys_cpu_to_le16(handle);
   2cc9c:	8005      	strh	r5, [r0, #0]
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
   2cc9e:	8823      	ldrh	r3, [r4, #0]
   2cca0:	8043      	strh	r3, [r0, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
   2cca2:	8863      	ldrh	r3, [r4, #2]
   2cca4:	8083      	strh	r3, [r0, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
   2cca6:	88a3      	ldrh	r3, [r4, #4]
   2cca8:	80c3      	strh	r3, [r0, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
   2ccaa:	88e3      	ldrh	r3, [r4, #6]
   2ccac:	8103      	strh	r3, [r0, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   2ccae:	4631      	mov	r1, r6
   2ccb0:	f242 0020 	movw	r0, #8224	; 0x2020
   2ccb4:	f7ed fbd2 	bl	1a45c <bt_hci_cmd_send>
}
   2ccb8:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   2ccba:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2ccbe:	e7fb      	b.n	2ccb8 <le_conn_param_req_reply+0x42>

0002ccc0 <bt_init>:
{
   2ccc0:	b510      	push	{r4, lr}
	err = hci_init();
   2ccc2:	f7ed fa1f 	bl	1a104 <hci_init>
	if (err) {
   2ccc6:	4604      	mov	r4, r0
   2ccc8:	b108      	cbz	r0, 2ccce <bt_init+0xe>
}
   2ccca:	4620      	mov	r0, r4
   2cccc:	bd10      	pop	{r4, pc}
		err = bt_conn_init();
   2ccce:	f7ee fff5 	bl	1bcbc <bt_conn_init>
		if (err) {
   2ccd2:	4604      	mov	r4, r0
   2ccd4:	2800      	cmp	r0, #0
   2ccd6:	d1f8      	bne.n	2ccca <bt_init+0xa>
	bt_finalize_init();
   2ccd8:	f7ed fcf6 	bl	1a6c8 <bt_finalize_init>
	return 0;
   2ccdc:	e7f5      	b.n	2ccca <bt_init+0xa>

0002ccde <bt_get_appearance>:
#if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
	return bt_dev.appearance;
#else
	return CONFIG_BT_DEVICE_APPEARANCE;
#endif
}
   2ccde:	f44f 7000 	mov.w	r0, #512	; 0x200
   2cce2:	4770      	bx	lr

0002cce4 <bt_addr_le_is_bonded>:
		/* if there are any keys stored then device is bonded */
		return keys && keys->keys;
	} else {
		return false;
	}
}
   2cce4:	2000      	movs	r0, #0
   2cce6:	4770      	bx	lr

0002cce8 <bt_lookup_id_addr>:
}
   2cce8:	4608      	mov	r0, r1
   2ccea:	4770      	bx	lr

0002ccec <bt_id_set_adv_random_addr>:
{
   2ccec:	b508      	push	{r3, lr}
		return set_random_address(addr);
   2ccee:	4608      	mov	r0, r1
   2ccf0:	f7ed fd52 	bl	1a798 <set_random_address>
}
   2ccf4:	bd08      	pop	{r3, pc}

0002ccf6 <bt_id_set_adv_private_addr>:
{
   2ccf6:	b510      	push	{r4, lr}
   2ccf8:	b082      	sub	sp, #8
   2ccfa:	4604      	mov	r4, r0
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   2ccfc:	2106      	movs	r1, #6
   2ccfe:	4668      	mov	r0, sp
   2cd00:	f7f5 fd28 	bl	22754 <bt_rand>
	if (err) {
   2cd04:	b108      	cbz	r0, 2cd0a <bt_id_set_adv_private_addr+0x14>
}
   2cd06:	b002      	add	sp, #8
   2cd08:	bd10      	pop	{r4, pc}
	BT_ADDR_SET_NRPA(&nrpa);
   2cd0a:	f89d 3005 	ldrb.w	r3, [sp, #5]
   2cd0e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   2cd12:	f88d 3005 	strb.w	r3, [sp, #5]
	err = bt_id_set_adv_random_addr(adv, &nrpa);
   2cd16:	4669      	mov	r1, sp
   2cd18:	4620      	mov	r0, r4
   2cd1a:	f7ff ffe7 	bl	2ccec <bt_id_set_adv_random_addr>
	if (err) {
   2cd1e:	e7f2      	b.n	2cd06 <bt_id_set_adv_private_addr+0x10>

0002cd20 <bt_id_adv_random_addr_check>:
}
   2cd20:	2001      	movs	r0, #1
   2cd22:	4770      	bx	lr

0002cd24 <ad_is_limited>:
	for (i = 0; i < ad_len; i++) {
   2cd24:	2300      	movs	r3, #0
   2cd26:	428b      	cmp	r3, r1
   2cd28:	d219      	bcs.n	2cd5e <ad_is_limited+0x3a>
{
   2cd2a:	b500      	push	{lr}
   2cd2c:	e002      	b.n	2cd34 <ad_is_limited+0x10>
	for (i = 0; i < ad_len; i++) {
   2cd2e:	3301      	adds	r3, #1
   2cd30:	428b      	cmp	r3, r1
   2cd32:	d211      	bcs.n	2cd58 <ad_is_limited+0x34>
		if (ad[i].type == BT_DATA_FLAGS &&
   2cd34:	eb00 0ec3 	add.w	lr, r0, r3, lsl #3
   2cd38:	f830 c033 	ldrh.w	ip, [r0, r3, lsl #3]
   2cd3c:	f240 1201 	movw	r2, #257	; 0x101
   2cd40:	4594      	cmp	ip, r2
   2cd42:	d1f4      	bne.n	2cd2e <ad_is_limited+0xa>
		    ad[i].data != NULL) {
   2cd44:	f8de 2004 	ldr.w	r2, [lr, #4]
		    ad[i].data_len == sizeof(uint8_t) &&
   2cd48:	2a00      	cmp	r2, #0
   2cd4a:	d0f0      	beq.n	2cd2e <ad_is_limited+0xa>
			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
   2cd4c:	7812      	ldrb	r2, [r2, #0]
   2cd4e:	f012 0f01 	tst.w	r2, #1
   2cd52:	d0ec      	beq.n	2cd2e <ad_is_limited+0xa>
				return true;
   2cd54:	2001      	movs	r0, #1
   2cd56:	e000      	b.n	2cd5a <ad_is_limited+0x36>
	return false;
   2cd58:	2000      	movs	r0, #0
}
   2cd5a:	f85d fb04 	ldr.w	pc, [sp], #4
	return false;
   2cd5e:	2000      	movs	r0, #0
}
   2cd60:	4770      	bx	lr

0002cd62 <get_filter_policy>:
}
   2cd62:	2000      	movs	r0, #0
   2cd64:	4770      	bx	lr

0002cd66 <get_adv_channel_map>:
{
   2cd66:	4603      	mov	r3, r0
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_37) {
   2cd68:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   2cd6c:	d10b      	bne.n	2cd86 <get_adv_channel_map+0x20>
	uint8_t channel_map = 0x07;
   2cd6e:	2007      	movs	r0, #7
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
   2cd70:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   2cd74:	d001      	beq.n	2cd7a <get_adv_channel_map+0x14>
		channel_map &= ~0x02;
   2cd76:	f000 00fd 	and.w	r0, r0, #253	; 0xfd
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
   2cd7a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
   2cd7e:	d001      	beq.n	2cd84 <get_adv_channel_map+0x1e>
		channel_map &= ~0x04;
   2cd80:	f000 00fb 	and.w	r0, r0, #251	; 0xfb
}
   2cd84:	4770      	bx	lr
		channel_map &= ~0x01;
   2cd86:	2006      	movs	r0, #6
   2cd88:	e7f2      	b.n	2cd70 <get_adv_channel_map+0xa>

0002cd8a <hci_set_ad>:
{
   2cd8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2cd8e:	b082      	sub	sp, #8
   2cd90:	4607      	mov	r7, r0
   2cd92:	460d      	mov	r5, r1
   2cd94:	4616      	mov	r6, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   2cd96:	2120      	movs	r1, #32
   2cd98:	f7ec ff56 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cd9c:	b300      	cbz	r0, 2cde0 <hci_set_ad+0x56>
   2cd9e:	4680      	mov	r8, r0
   2cda0:	2120      	movs	r1, #32
   2cda2:	3008      	adds	r0, #8
   2cda4:	f7f2 f9ce 	bl	1f144 <net_buf_simple_add>
   2cda8:	4604      	mov	r4, r0
   2cdaa:	2220      	movs	r2, #32
   2cdac:	2100      	movs	r1, #0
   2cdae:	f004 f87b 	bl	30ea8 <memset>
	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
   2cdb2:	9400      	str	r4, [sp, #0]
   2cdb4:	4633      	mov	r3, r6
   2cdb6:	462a      	mov	r2, r5
   2cdb8:	211f      	movs	r1, #31
   2cdba:	1c60      	adds	r0, r4, #1
   2cdbc:	f7ed ff1e 	bl	1abfc <set_data_add_complete>
	if (err) {
   2cdc0:	4604      	mov	r4, r0
   2cdc2:	b948      	cbnz	r0, 2cdd8 <hci_set_ad+0x4e>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   2cdc4:	2200      	movs	r2, #0
   2cdc6:	4641      	mov	r1, r8
   2cdc8:	4638      	mov	r0, r7
   2cdca:	f7ec ff8b 	bl	19ce4 <bt_hci_cmd_send_sync>
   2cdce:	4604      	mov	r4, r0
}
   2cdd0:	4620      	mov	r0, r4
   2cdd2:	b002      	add	sp, #8
   2cdd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
   2cdd8:	4640      	mov	r0, r8
   2cdda:	f7f2 f89b 	bl	1ef14 <net_buf_unref>
		return err;
   2cdde:	e7f7      	b.n	2cdd0 <hci_set_ad+0x46>
		return -ENOBUFS;
   2cde0:	f06f 0468 	mvn.w	r4, #104	; 0x68
   2cde4:	e7f4      	b.n	2cdd0 <hci_set_ad+0x46>

0002cde6 <set_ad>:
{
   2cde6:	b508      	push	{r3, lr}
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   2cde8:	f242 0008 	movw	r0, #8200	; 0x2008
   2cdec:	f7ff ffcd 	bl	2cd8a <hci_set_ad>
}
   2cdf0:	bd08      	pop	{r3, pc}

0002cdf2 <set_sd>:
{
   2cdf2:	b508      	push	{r3, lr}
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   2cdf4:	f242 0009 	movw	r0, #8201	; 0x2009
   2cdf8:	f7ff ffc7 	bl	2cd8a <hci_set_ad>
}
   2cdfc:	bd08      	pop	{r3, pc}

0002cdfe <le_adv_update>:
{
   2cdfe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ce02:	b089      	sub	sp, #36	; 0x24
   2ce04:	4604      	mov	r4, r0
   2ce06:	460e      	mov	r6, r1
   2ce08:	4617      	mov	r7, r2
   2ce0a:	461d      	mov	r5, r3
   2ce0c:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
   2ce10:	f89d b04c 	ldrb.w	fp, [sp, #76]	; 0x4c
   2ce14:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
   2ce18:	f89d 9054 	ldrb.w	r9, [sp, #84]	; 0x54
	struct bt_ad d[2] = {};
   2ce1c:	2300      	movs	r3, #0
   2ce1e:	9304      	str	r3, [sp, #16]
   2ce20:	9305      	str	r3, [sp, #20]
   2ce22:	9306      	str	r3, [sp, #24]
   2ce24:	9307      	str	r3, [sp, #28]
	if (name_type != ADV_NAME_TYPE_NONE) {
   2ce26:	f1b9 0f00 	cmp.w	r9, #0
   2ce2a:	d133      	bne.n	2ce94 <le_adv_update+0x96>
	if (!(ext_adv && scannable)) {
   2ce2c:	f1bb 0f00 	cmp.w	fp, #0
   2ce30:	d002      	beq.n	2ce38 <le_adv_update+0x3a>
   2ce32:	f1ba 0f00 	cmp.w	sl, #0
   2ce36:	d10b      	bne.n	2ce50 <le_adv_update+0x52>
		d[0].data = ad;
   2ce38:	9604      	str	r6, [sp, #16]
		d[0].len = ad_len;
   2ce3a:	9705      	str	r7, [sp, #20]
		if (name_type == ADV_NAME_TYPE_AD) {
   2ce3c:	f1b9 0f01 	cmp.w	r9, #1
   2ce40:	d056      	beq.n	2cef0 <le_adv_update+0xf2>
		d_len = 1;
   2ce42:	2201      	movs	r2, #1
		err = set_ad(adv, d, d_len);
   2ce44:	a904      	add	r1, sp, #16
   2ce46:	4620      	mov	r0, r4
   2ce48:	f7ff ffcd 	bl	2cde6 <set_ad>
		if (err) {
   2ce4c:	4603      	mov	r3, r0
   2ce4e:	b9e8      	cbnz	r0, 2ce8c <le_adv_update+0x8e>
	if (scannable) {
   2ce50:	f1ba 0f00 	cmp.w	sl, #0
   2ce54:	d00c      	beq.n	2ce70 <le_adv_update+0x72>
		d[0].data = sd;
   2ce56:	9504      	str	r5, [sp, #16]
		d[0].len = sd_len;
   2ce58:	f8cd 8014 	str.w	r8, [sp, #20]
		if (name_type == ADV_NAME_TYPE_SD) {
   2ce5c:	f1b9 0f02 	cmp.w	r9, #2
   2ce60:	d04c      	beq.n	2cefc <le_adv_update+0xfe>
		d_len = 1;
   2ce62:	2201      	movs	r2, #1
		err = set_sd(adv, d, d_len);
   2ce64:	a904      	add	r1, sp, #16
   2ce66:	4620      	mov	r0, r4
   2ce68:	f7ff ffc3 	bl	2cdf2 <set_sd>
		if (err) {
   2ce6c:	4603      	mov	r3, r0
   2ce6e:	b968      	cbnz	r0, 2ce8c <le_adv_update+0x8e>
	atomic_set_bit(adv->flags, BT_ADV_DATA_SET);
   2ce70:	3410      	adds	r4, #16
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2ce72:	f3bf 8f5b 	dmb	ish
   2ce76:	e854 3f00 	ldrex	r3, [r4]
   2ce7a:	f043 0304 	orr.w	r3, r3, #4
   2ce7e:	e844 3200 	strex	r2, r3, [r4]
   2ce82:	2a00      	cmp	r2, #0
   2ce84:	d1f7      	bne.n	2ce76 <le_adv_update+0x78>
   2ce86:	f3bf 8f5b 	dmb	ish
	return 0;
   2ce8a:	2300      	movs	r3, #0
}
   2ce8c:	4618      	mov	r0, r3
   2ce8e:	b009      	add	sp, #36	; 0x24
   2ce90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		const char *name = bt_get_name();
   2ce94:	f7ed fc60 	bl	1a758 <bt_get_name>
   2ce98:	9001      	str	r0, [sp, #4]
		if ((ad && ad_has_name(ad, ad_len)) ||
   2ce9a:	b166      	cbz	r6, 2ceb6 <le_adv_update+0xb8>
	for (i = 0; i < ad_len; i++) {
   2ce9c:	2200      	movs	r2, #0
   2ce9e:	4297      	cmp	r7, r2
   2cea0:	d907      	bls.n	2ceb2 <le_adv_update+0xb4>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   2cea2:	f816 3032 	ldrb.w	r3, [r6, r2, lsl #3]
   2cea6:	3b08      	subs	r3, #8
   2cea8:	b2db      	uxtb	r3, r3
   2ceaa:	2b01      	cmp	r3, #1
   2ceac:	d90f      	bls.n	2cece <le_adv_update+0xd0>
	for (i = 0; i < ad_len; i++) {
   2ceae:	3201      	adds	r2, #1
   2ceb0:	e7f5      	b.n	2ce9e <le_adv_update+0xa0>
	return false;
   2ceb2:	2300      	movs	r3, #0
		if ((ad && ad_has_name(ad, ad_len)) ||
   2ceb4:	bb43      	cbnz	r3, 2cf08 <le_adv_update+0x10a>
   2ceb6:	b175      	cbz	r5, 2ced6 <le_adv_update+0xd8>
	for (i = 0; i < ad_len; i++) {
   2ceb8:	2200      	movs	r2, #0
   2ceba:	4590      	cmp	r8, r2
   2cebc:	d909      	bls.n	2ced2 <le_adv_update+0xd4>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   2cebe:	f815 3032 	ldrb.w	r3, [r5, r2, lsl #3]
   2cec2:	3b08      	subs	r3, #8
   2cec4:	b2db      	uxtb	r3, r3
   2cec6:	2b01      	cmp	r3, #1
   2cec8:	d910      	bls.n	2ceec <le_adv_update+0xee>
	for (i = 0; i < ad_len; i++) {
   2ceca:	3201      	adds	r2, #1
   2cecc:	e7f5      	b.n	2ceba <le_adv_update+0xbc>
			return true;
   2cece:	2301      	movs	r3, #1
   2ced0:	e7f0      	b.n	2ceb4 <le_adv_update+0xb6>
	return false;
   2ced2:	2300      	movs	r3, #0
		    (sd && ad_has_name(sd, sd_len))) {
   2ced4:	b9db      	cbnz	r3, 2cf0e <le_adv_update+0x110>
		data = (struct bt_data)BT_DATA(
   2ced6:	9801      	ldr	r0, [sp, #4]
   2ced8:	f7df fee7 	bl	ccaa <strlen>
   2cedc:	2309      	movs	r3, #9
   2cede:	f88d 3008 	strb.w	r3, [sp, #8]
   2cee2:	f88d 0009 	strb.w	r0, [sp, #9]
   2cee6:	9b01      	ldr	r3, [sp, #4]
   2cee8:	9303      	str	r3, [sp, #12]
   2ceea:	e79f      	b.n	2ce2c <le_adv_update+0x2e>
			return true;
   2ceec:	2301      	movs	r3, #1
   2ceee:	e7f1      	b.n	2ced4 <le_adv_update+0xd6>
			d[1].data = &data;
   2cef0:	ab02      	add	r3, sp, #8
   2cef2:	9306      	str	r3, [sp, #24]
			d[1].len = 1;
   2cef4:	2301      	movs	r3, #1
   2cef6:	9307      	str	r3, [sp, #28]
			d_len = 2;
   2cef8:	2202      	movs	r2, #2
   2cefa:	e7a3      	b.n	2ce44 <le_adv_update+0x46>
			d[1].data = &data;
   2cefc:	ab02      	add	r3, sp, #8
   2cefe:	9306      	str	r3, [sp, #24]
			d[1].len = 1;
   2cf00:	2301      	movs	r3, #1
   2cf02:	9307      	str	r3, [sp, #28]
			d_len = 2;
   2cf04:	2202      	movs	r2, #2
   2cf06:	e7ad      	b.n	2ce64 <le_adv_update+0x66>
			return -EINVAL;
   2cf08:	f06f 0315 	mvn.w	r3, #21
   2cf0c:	e7be      	b.n	2ce8c <le_adv_update+0x8e>
   2cf0e:	f06f 0315 	mvn.w	r3, #21
   2cf12:	e7bb      	b.n	2ce8c <le_adv_update+0x8e>

0002cf14 <valid_adv_param>:
{
   2cf14:	b508      	push	{r3, lr}
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
   2cf16:	6843      	ldr	r3, [r0, #4]
   2cf18:	f413 6f80 	tst.w	r3, #1024	; 0x400
   2cf1c:	d107      	bne.n	2cf2e <valid_adv_param+0x1a>
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   2cf1e:	6902      	ldr	r2, [r0, #16]
   2cf20:	b112      	cbz	r2, 2cf28 <valid_adv_param+0x14>
   2cf22:	f013 0f01 	tst.w	r3, #1
   2cf26:	d004      	beq.n	2cf32 <valid_adv_param+0x1e>
	return valid_adv_ext_param(param);
   2cf28:	f7ed febc 	bl	1aca4 <valid_adv_ext_param>
}
   2cf2c:	bd08      	pop	{r3, pc}
		return false;
   2cf2e:	2000      	movs	r0, #0
   2cf30:	e7fc      	b.n	2cf2c <valid_adv_param+0x18>
		return false;
   2cf32:	2000      	movs	r0, #0
   2cf34:	e7fa      	b.n	2cf2c <valid_adv_param+0x18>

0002cf36 <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
   2cf36:	6843      	ldr	r3, [r0, #4]
   2cf38:	f013 0f08 	tst.w	r3, #8
   2cf3c:	d00b      	beq.n	2cf56 <get_adv_name_type_param+0x20>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
   2cf3e:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   2cf42:	d10a      	bne.n	2cf5a <get_adv_name_type_param+0x24>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
   2cf44:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
   2cf48:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   2cf4c:	d001      	beq.n	2cf52 <get_adv_name_type_param+0x1c>
		return ADV_NAME_TYPE_SD;
   2cf4e:	2002      	movs	r0, #2
}
   2cf50:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
   2cf52:	2001      	movs	r0, #1
   2cf54:	4770      	bx	lr
	return ADV_NAME_TYPE_NONE;
   2cf56:	2000      	movs	r0, #0
   2cf58:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
   2cf5a:	2001      	movs	r0, #1
   2cf5c:	4770      	bx	lr

0002cf5e <bt_le_adv_set_enable_legacy>:
{
   2cf5e:	b570      	push	{r4, r5, r6, lr}
   2cf60:	b086      	sub	sp, #24
   2cf62:	4605      	mov	r5, r0
   2cf64:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
   2cf66:	2101      	movs	r1, #1
   2cf68:	f242 000a 	movw	r0, #8202	; 0x200a
   2cf6c:	f7ec fe6c 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2cf70:	b1d0      	cbz	r0, 2cfa8 <bt_le_adv_set_enable_legacy+0x4a>
   2cf72:	4606      	mov	r6, r0
	if (enable) {
   2cf74:	b19c      	cbz	r4, 2cf9e <bt_le_adv_set_enable_legacy+0x40>
	return net_buf_simple_add_u8(&buf->b, val);
   2cf76:	2101      	movs	r1, #1
   2cf78:	3008      	adds	r0, #8
   2cf7a:	f001 ffc4 	bl	2ef06 <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
   2cf7e:	9400      	str	r4, [sp, #0]
   2cf80:	2306      	movs	r3, #6
   2cf82:	f105 0210 	add.w	r2, r5, #16
   2cf86:	a903      	add	r1, sp, #12
   2cf88:	4630      	mov	r0, r6
   2cf8a:	f7ec fe4b 	bl	19c24 <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
   2cf8e:	2200      	movs	r2, #0
   2cf90:	4631      	mov	r1, r6
   2cf92:	f242 000a 	movw	r0, #8202	; 0x200a
   2cf96:	f7ec fea5 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2cf9a:	b006      	add	sp, #24
   2cf9c:	bd70      	pop	{r4, r5, r6, pc}
   2cf9e:	2100      	movs	r1, #0
   2cfa0:	3008      	adds	r0, #8
   2cfa2:	f001 ffb0 	bl	2ef06 <net_buf_simple_add_u8>
   2cfa6:	e7ea      	b.n	2cf7e <bt_le_adv_set_enable_legacy+0x20>
		return -ENOBUFS;
   2cfa8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2cfac:	e7f5      	b.n	2cf9a <bt_le_adv_set_enable_legacy+0x3c>

0002cfae <bt_le_adv_set_enable>:
{
   2cfae:	b508      	push	{r3, lr}
	return bt_le_adv_set_enable_legacy(adv, enable);
   2cfb0:	f7ff ffd5 	bl	2cf5e <bt_le_adv_set_enable_legacy>
}
   2cfb4:	bd08      	pop	{r3, pc}

0002cfb6 <bt_le_lim_adv_cancel_timeout>:
{
   2cfb6:	b508      	push	{r3, lr}
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
   2cfb8:	3018      	adds	r0, #24
   2cfba:	f7fa fd27 	bl	27a0c <k_work_cancel_delayable>
}
   2cfbe:	bd08      	pop	{r3, pc}

0002cfc0 <bt_le_adv_resume>:
{
   2cfc0:	b570      	push	{r4, r5, r6, lr}
   2cfc2:	b082      	sub	sp, #8
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   2cfc4:	f7ed ff3a 	bl	1ae3c <bt_le_adv_lookup_legacy>
	if (!adv) {
   2cfc8:	b150      	cbz	r0, 2cfe0 <bt_le_adv_resume+0x20>
   2cfca:	4604      	mov	r4, r0
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   2cfcc:	f100 0510 	add.w	r5, r0, #16
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2cfd0:	f3bf 8f5b 	dmb	ish
   2cfd4:	6903      	ldr	r3, [r0, #16]
   2cfd6:	f3bf 8f5b 	dmb	ish
   2cfda:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   2cfde:	d101      	bne.n	2cfe4 <bt_le_adv_resume+0x24>
}
   2cfe0:	b002      	add	sp, #8
   2cfe2:	bd70      	pop	{r4, r5, r6, pc}
   2cfe4:	f3bf 8f5b 	dmb	ish
   2cfe8:	6903      	ldr	r3, [r0, #16]
   2cfea:	f3bf 8f5b 	dmb	ish
   2cfee:	f3c3 1680 	ubfx	r6, r3, #6, #1
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   2cff2:	f013 0f40 	tst.w	r3, #64	; 0x40
   2cff6:	d1f3      	bne.n	2cfe0 <bt_le_adv_resume+0x20>
   2cff8:	f3bf 8f5b 	dmb	ish
   2cffc:	6903      	ldr	r3, [r0, #16]
   2cffe:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
   2d002:	f413 7f00 	tst.w	r3, #512	; 0x200
   2d006:	d0eb      	beq.n	2cfe0 <bt_le_adv_resume+0x20>
	err = le_adv_start_add_conn(adv, &conn);
   2d008:	a901      	add	r1, sp, #4
   2d00a:	f7ed fe99 	bl	1ad40 <le_adv_start_add_conn>
	if (err) {
   2d00e:	2800      	cmp	r0, #0
   2d010:	d1e6      	bne.n	2cfe0 <bt_le_adv_resume+0x20>
	err = bt_le_adv_set_enable(adv, true);
   2d012:	2101      	movs	r1, #1
   2d014:	4620      	mov	r0, r4
   2d016:	f7ff ffca 	bl	2cfae <bt_le_adv_set_enable>
	if (err) {
   2d01a:	b188      	cbz	r0, 2d040 <bt_le_adv_resume+0x80>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2d01c:	2100      	movs	r1, #0
   2d01e:	9801      	ldr	r0, [sp, #4]
   2d020:	f7ee fb3e 	bl	1b6a0 <bt_conn_set_state>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d024:	f3bf 8f5b 	dmb	ish
   2d028:	e855 6f00 	ldrex	r6, [r5]
   2d02c:	f426 5300 	bic.w	r3, r6, #8192	; 0x2000
   2d030:	e845 3200 	strex	r2, r3, [r5]
   2d034:	2a00      	cmp	r2, #0
   2d036:	d1f7      	bne.n	2d028 <bt_le_adv_resume+0x68>
   2d038:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   2d03c:	f3c6 3640 	ubfx	r6, r6, #13, #1
	bt_conn_unref(conn);
   2d040:	9801      	ldr	r0, [sp, #4]
   2d042:	f7ee faf1 	bl	1b628 <bt_conn_unref>
	if (persist_paused) {
   2d046:	2e00      	cmp	r6, #0
   2d048:	d0ca      	beq.n	2cfe0 <bt_le_adv_resume+0x20>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2d04a:	f3bf 8f5b 	dmb	ish
   2d04e:	e855 3f00 	ldrex	r3, [r5]
   2d052:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   2d056:	e845 3200 	strex	r2, r3, [r5]
   2d05a:	2a00      	cmp	r2, #0
   2d05c:	d1f7      	bne.n	2d04e <bt_le_adv_resume+0x8e>
   2d05e:	f3bf 8f5b 	dmb	ish
}
   2d062:	e7bd      	b.n	2cfe0 <bt_le_adv_resume+0x20>

0002d064 <tx_notify>:
{
   2d064:	b570      	push	{r4, r5, r6, lr}
   2d066:	4604      	mov	r4, r0
	BT_DBG("conn %p", conn);
   2d068:	e00c      	b.n	2d084 <tx_notify+0x20>
   2d06a:	f383 8811 	msr	BASEPRI, r3
   2d06e:	f3bf 8f6f 	isb	sy
		if (!tx) {
   2d072:	b1c8      	cbz	r0, 2d0a8 <tx_notify+0x44>
		cb = tx->cb;
   2d074:	6845      	ldr	r5, [r0, #4]
		user_data = tx->user_data;
   2d076:	6886      	ldr	r6, [r0, #8]
		tx_free(tx);
   2d078:	f7ee f934 	bl	1b2e4 <tx_free>
		cb(conn, user_data, 0);
   2d07c:	2200      	movs	r2, #0
   2d07e:	4631      	mov	r1, r6
   2d080:	4620      	mov	r0, r4
   2d082:	47a8      	blx	r5
	__asm__ volatile(
   2d084:	f04f 0240 	mov.w	r2, #64	; 0x40
   2d088:	f3ef 8311 	mrs	r3, BASEPRI
   2d08c:	f382 8812 	msr	BASEPRI_MAX, r2
   2d090:	f3bf 8f6f 	isb	sy
	return list->head;
   2d094:	6a20      	ldr	r0, [r4, #32]
		if (!sys_slist_is_empty(&conn->tx_complete)) {
   2d096:	2800      	cmp	r0, #0
   2d098:	d0e7      	beq.n	2d06a <tx_notify+0x6>
	return node->next;
   2d09a:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   2d09c:	6222      	str	r2, [r4, #32]
	return list->tail;
   2d09e:	6a61      	ldr	r1, [r4, #36]	; 0x24
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2d0a0:	4281      	cmp	r1, r0
   2d0a2:	d1e2      	bne.n	2d06a <tx_notify+0x6>
	list->tail = node;
   2d0a4:	6262      	str	r2, [r4, #36]	; 0x24
}
   2d0a6:	e7e0      	b.n	2d06a <tx_notify+0x6>
}
   2d0a8:	bd70      	pop	{r4, r5, r6, pc}

0002d0aa <tx_complete_work>:
{
   2d0aa:	b508      	push	{r3, lr}
	tx_notify(conn);
   2d0ac:	3828      	subs	r0, #40	; 0x28
   2d0ae:	f7ff ffd9 	bl	2d064 <tx_notify>
}
   2d0b2:	bd08      	pop	{r3, pc}

0002d0b4 <process_unack_tx>:
{
   2d0b4:	b510      	push	{r4, lr}
   2d0b6:	4604      	mov	r4, r0
   2d0b8:	e028      	b.n	2d10c <process_unack_tx+0x58>
			conn->pending_no_cb--;
   2d0ba:	3b01      	subs	r3, #1
   2d0bc:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
   2d0be:	f382 8811 	msr	BASEPRI, r2
   2d0c2:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
   2d0c6:	4620      	mov	r0, r4
   2d0c8:	f7ee f9ba 	bl	1b440 <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
   2d0cc:	f7f9 ff62 	bl	26f94 <z_impl_k_sem_give>
			continue;
   2d0d0:	e01c      	b.n	2d10c <process_unack_tx+0x58>
   2d0d2:	f382 8811 	msr	BASEPRI, r2
   2d0d6:	f3bf 8f6f 	isb	sy
		if (!node) {
   2d0da:	b361      	cbz	r1, 2d136 <process_unack_tx+0x82>
	__asm__ volatile(
   2d0dc:	f04f 0240 	mov.w	r2, #64	; 0x40
   2d0e0:	f3ef 8311 	mrs	r3, BASEPRI
   2d0e4:	f382 8812 	msr	BASEPRI_MAX, r2
   2d0e8:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
   2d0ec:	68ca      	ldr	r2, [r1, #12]
   2d0ee:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
   2d0f0:	2200      	movs	r2, #0
   2d0f2:	60ca      	str	r2, [r1, #12]
	__asm__ volatile(
   2d0f4:	f383 8811 	msr	BASEPRI, r3
   2d0f8:	f3bf 8f6f 	isb	sy
		conn_tx_destroy(conn, tx);
   2d0fc:	4620      	mov	r0, r4
   2d0fe:	f7ee f933 	bl	1b368 <conn_tx_destroy>
		k_sem_give(bt_conn_get_pkts(conn));
   2d102:	4620      	mov	r0, r4
   2d104:	f7ee f99c 	bl	1b440 <bt_conn_get_pkts>
   2d108:	f7f9 ff44 	bl	26f94 <z_impl_k_sem_give>
	__asm__ volatile(
   2d10c:	f04f 0340 	mov.w	r3, #64	; 0x40
   2d110:	f3ef 8211 	mrs	r2, BASEPRI
   2d114:	f383 8812 	msr	BASEPRI_MAX, r3
   2d118:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
   2d11c:	69e3      	ldr	r3, [r4, #28]
   2d11e:	2b00      	cmp	r3, #0
   2d120:	d1cb      	bne.n	2d0ba <process_unack_tx+0x6>
	return list->head;
   2d122:	6961      	ldr	r1, [r4, #20]
Z_GENLIST_GET(slist, snode)
   2d124:	2900      	cmp	r1, #0
   2d126:	d0d4      	beq.n	2d0d2 <process_unack_tx+0x1e>
	return node->next;
   2d128:	680b      	ldr	r3, [r1, #0]
	list->head = node;
   2d12a:	6163      	str	r3, [r4, #20]
	return list->tail;
   2d12c:	69a0      	ldr	r0, [r4, #24]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2d12e:	4281      	cmp	r1, r0
   2d130:	d1cf      	bne.n	2d0d2 <process_unack_tx+0x1e>
	list->tail = node;
   2d132:	61a3      	str	r3, [r4, #24]
}
   2d134:	e7cd      	b.n	2d0d2 <process_unack_tx+0x1e>
}
   2d136:	bd10      	pop	{r4, pc}

0002d138 <bt_conn_reset_rx_state>:
{
   2d138:	b510      	push	{r4, lr}
   2d13a:	4604      	mov	r4, r0
	if (!conn->rx) {
   2d13c:	6900      	ldr	r0, [r0, #16]
   2d13e:	b118      	cbz	r0, 2d148 <bt_conn_reset_rx_state+0x10>
	net_buf_unref(conn->rx);
   2d140:	f7f1 fee8 	bl	1ef14 <net_buf_unref>
	conn->rx = NULL;
   2d144:	2300      	movs	r3, #0
   2d146:	6123      	str	r3, [r4, #16]
}
   2d148:	bd10      	pop	{r4, pc}

0002d14a <bt_conn_recv>:
{
   2d14a:	b570      	push	{r4, r5, r6, lr}
   2d14c:	4604      	mov	r4, r0
   2d14e:	460d      	mov	r5, r1
   2d150:	4616      	mov	r6, r2
	tx_notify(conn);
   2d152:	f7ff ff87 	bl	2d064 <tx_notify>
		bt_acl_recv(conn, buf, flags);
   2d156:	4632      	mov	r2, r6
   2d158:	4629      	mov	r1, r5
   2d15a:	4620      	mov	r0, r4
   2d15c:	f7ee f9b0 	bl	1b4c0 <bt_acl_recv>
}
   2d160:	bd70      	pop	{r4, r5, r6, pc}

0002d162 <bt_conn_ref>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d162:	f3bf 8f5b 	dmb	ish
   2d166:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
   2d16a:	f3bf 8f5b 	dmb	ish
		if (!old) {
   2d16e:	b1eb      	cbz	r3, 2d1ac <bt_conn_ref+0x4a>
{
   2d170:	b500      	push	{lr}
   2d172:	e006      	b.n	2d182 <bt_conn_ref+0x20>
   2d174:	f3bf 8f5b 	dmb	ish
   2d178:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
   2d17c:	f3bf 8f5b 	dmb	ish
		if (!old) {
   2d180:	b193      	cbz	r3, 2d1a8 <bt_conn_ref+0x46>
   2d182:	f100 02c0 	add.w	r2, r0, #192	; 0xc0
	} while (!atomic_cas(&conn->ref, old, old + 1));
   2d186:	1c59      	adds	r1, r3, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   2d188:	f3bf 8f5b 	dmb	ish
   2d18c:	e852 cf00 	ldrex	ip, [r2]
   2d190:	459c      	cmp	ip, r3
   2d192:	d104      	bne.n	2d19e <bt_conn_ref+0x3c>
   2d194:	e842 1e00 	strex	lr, r1, [r2]
   2d198:	f1be 0f00 	cmp.w	lr, #0
   2d19c:	d1f6      	bne.n	2d18c <bt_conn_ref+0x2a>
   2d19e:	f3bf 8f5b 	dmb	ish
   2d1a2:	d1e7      	bne.n	2d174 <bt_conn_ref+0x12>
}
   2d1a4:	f85d fb04 	ldr.w	pc, [sp], #4
			return NULL;
   2d1a8:	2000      	movs	r0, #0
   2d1aa:	e7fb      	b.n	2d1a4 <bt_conn_ref+0x42>
   2d1ac:	2000      	movs	r0, #0
}
   2d1ae:	4770      	bx	lr

0002d1b0 <conn_lookup_handle>:
{
   2d1b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d1b2:	4606      	mov	r6, r0
   2d1b4:	460d      	mov	r5, r1
   2d1b6:	4617      	mov	r7, r2
	for (i = 0; i < size; i++) {
   2d1b8:	2400      	movs	r4, #0
   2d1ba:	e003      	b.n	2d1c4 <conn_lookup_handle+0x14>
			bt_conn_unref(conn);
   2d1bc:	4660      	mov	r0, ip
   2d1be:	f7ee fa33 	bl	1b628 <bt_conn_unref>
	for (i = 0; i < size; i++) {
   2d1c2:	3401      	adds	r4, #1
   2d1c4:	42ac      	cmp	r4, r5
   2d1c6:	d21b      	bcs.n	2d200 <conn_lookup_handle+0x50>
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   2d1c8:	20c8      	movs	r0, #200	; 0xc8
   2d1ca:	fb00 6004 	mla	r0, r0, r4, r6
   2d1ce:	f7ff ffc8 	bl	2d162 <bt_conn_ref>
		if (!conn) {
   2d1d2:	4684      	mov	ip, r0
   2d1d4:	2800      	cmp	r0, #0
   2d1d6:	d0f4      	beq.n	2d1c2 <conn_lookup_handle+0x12>
/* Look up an existing connection */
struct bt_conn *bt_conn_lookup_handle(uint16_t handle);

static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
{
	switch (conn->state) {
   2d1d8:	7a83      	ldrb	r3, [r0, #10]
   2d1da:	2b01      	cmp	r3, #1
   2d1dc:	d006      	beq.n	2d1ec <conn_lookup_handle+0x3c>
   2d1de:	b25a      	sxtb	r2, r3
   2d1e0:	2a00      	cmp	r2, #0
   2d1e2:	d0eb      	beq.n	2d1bc <conn_lookup_handle+0xc>
   2d1e4:	3b07      	subs	r3, #7
   2d1e6:	b2db      	uxtb	r3, r3
   2d1e8:	2b01      	cmp	r3, #1
   2d1ea:	d8e7      	bhi.n	2d1bc <conn_lookup_handle+0xc>
		if (conn->handle != handle) {
   2d1ec:	f8bc 3000 	ldrh.w	r3, [ip]
   2d1f0:	42bb      	cmp	r3, r7
   2d1f2:	d101      	bne.n	2d1f8 <conn_lookup_handle+0x48>
}
   2d1f4:	4660      	mov	r0, ip
   2d1f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			bt_conn_unref(conn);
   2d1f8:	4660      	mov	r0, ip
   2d1fa:	f7ee fa15 	bl	1b628 <bt_conn_unref>
			continue;
   2d1fe:	e7e0      	b.n	2d1c2 <conn_lookup_handle+0x12>
	return NULL;
   2d200:	f04f 0c00 	mov.w	ip, #0
   2d204:	e7f6      	b.n	2d1f4 <conn_lookup_handle+0x44>

0002d206 <bt_conn_connected>:
{
   2d206:	b510      	push	{r4, lr}
   2d208:	4604      	mov	r4, r0
	bt_l2cap_connected(conn);
   2d20a:	f7ee fdcd 	bl	1bda8 <bt_l2cap_connected>
	notify_connected(conn);
   2d20e:	4620      	mov	r0, r4
   2d210:	f7ee f8c8 	bl	1b3a4 <notify_connected>
}
   2d214:	bd10      	pop	{r4, pc}

0002d216 <bt_conn_get_security>:
}
   2d216:	2001      	movs	r0, #1
   2d218:	4770      	bx	lr

0002d21a <bt_conn_add_le>:
{
   2d21a:	b538      	push	{r3, r4, r5, lr}
   2d21c:	4605      	mov	r5, r0
   2d21e:	460c      	mov	r4, r1
	struct bt_conn *conn = acl_conn_new();
   2d220:	f7ee f946 	bl	1b4b0 <acl_conn_new>
	if (!conn) {
   2d224:	4603      	mov	r3, r0
   2d226:	b188      	cbz	r0, 2d24c <bt_conn_add_le+0x32>
	conn->id = id;
   2d228:	7205      	strb	r5, [r0, #8]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2d22a:	6822      	ldr	r2, [r4, #0]
   2d22c:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
   2d230:	88a1      	ldrh	r1, [r4, #4]
   2d232:	79a2      	ldrb	r2, [r4, #6]
   2d234:	f8a0 1094 	strh.w	r1, [r0, #148]	; 0x94
   2d238:	f880 2096 	strb.w	r2, [r0, #150]	; 0x96
	conn->type = BT_CONN_TYPE_LE;
   2d23c:	2201      	movs	r2, #1
   2d23e:	7082      	strb	r2, [r0, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
   2d240:	2218      	movs	r2, #24
   2d242:	f8a0 20a8 	strh.w	r2, [r0, #168]	; 0xa8
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;
   2d246:	2228      	movs	r2, #40	; 0x28
   2d248:	f8a0 20aa 	strh.w	r2, [r0, #170]	; 0xaa
}
   2d24c:	4618      	mov	r0, r3
   2d24e:	bd38      	pop	{r3, r4, r5, pc}

0002d250 <bt_conn_is_peer_addr_le>:
{
   2d250:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
   2d252:	7a03      	ldrb	r3, [r0, #8]
   2d254:	428b      	cmp	r3, r1
   2d256:	d001      	beq.n	2d25c <bt_conn_is_peer_addr_le+0xc>
		return false;
   2d258:	2000      	movs	r0, #0
}
   2d25a:	bd38      	pop	{r3, r4, r5, pc}
   2d25c:	4604      	mov	r4, r0
   2d25e:	4615      	mov	r5, r2
	return memcmp(a, b, sizeof(*a));
   2d260:	2207      	movs	r2, #7
   2d262:	f100 0190 	add.w	r1, r0, #144	; 0x90
   2d266:	4628      	mov	r0, r5
   2d268:	f003 fded 	bl	30e46 <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   2d26c:	b1a8      	cbz	r0, 2d29a <bt_conn_is_peer_addr_le+0x4a>
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
   2d26e:	78e3      	ldrb	r3, [r4, #3]
   2d270:	b14b      	cbz	r3, 2d286 <bt_conn_is_peer_addr_le+0x36>
   2d272:	2207      	movs	r2, #7
   2d274:	f104 0197 	add.w	r1, r4, #151	; 0x97
   2d278:	4628      	mov	r0, r5
   2d27a:	f003 fde4 	bl	30e46 <memcmp>
	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   2d27e:	fab0 f080 	clz	r0, r0
   2d282:	0940      	lsrs	r0, r0, #5
   2d284:	e7e9      	b.n	2d25a <bt_conn_is_peer_addr_le+0xa>
   2d286:	2207      	movs	r2, #7
   2d288:	f104 019e 	add.w	r1, r4, #158	; 0x9e
   2d28c:	4628      	mov	r0, r5
   2d28e:	f003 fdda 	bl	30e46 <memcmp>
		return bt_addr_le_cmp(peer, &conn->le.resp_addr) == 0;
   2d292:	fab0 f080 	clz	r0, r0
   2d296:	0940      	lsrs	r0, r0, #5
   2d298:	e7df      	b.n	2d25a <bt_conn_is_peer_addr_le+0xa>
		return true;
   2d29a:	2001      	movs	r0, #1
   2d29c:	e7dd      	b.n	2d25a <bt_conn_is_peer_addr_le+0xa>

0002d29e <bt_conn_get_dst>:
}
   2d29e:	3090      	adds	r0, #144	; 0x90
   2d2a0:	4770      	bx	lr

0002d2a2 <bt_conn_le_conn_update>:
{
   2d2a2:	b570      	push	{r4, r5, r6, lr}
   2d2a4:	4605      	mov	r5, r0
   2d2a6:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   2d2a8:	210e      	movs	r1, #14
   2d2aa:	f242 0013 	movw	r0, #8211	; 0x2013
   2d2ae:	f7ec fccb 	bl	19c48 <bt_hci_cmd_create>
	if (!buf) {
   2d2b2:	b1c8      	cbz	r0, 2d2e8 <bt_conn_le_conn_update+0x46>
   2d2b4:	4606      	mov	r6, r0
	return net_buf_simple_add(&buf->b, len);
   2d2b6:	210e      	movs	r1, #14
   2d2b8:	3008      	adds	r0, #8
   2d2ba:	f7f1 ff43 	bl	1f144 <net_buf_simple_add>
__ssp_bos_icheck3(memset, void *, int)
   2d2be:	2200      	movs	r2, #0
   2d2c0:	6002      	str	r2, [r0, #0]
   2d2c2:	6042      	str	r2, [r0, #4]
   2d2c4:	6082      	str	r2, [r0, #8]
   2d2c6:	8182      	strh	r2, [r0, #12]
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   2d2c8:	882b      	ldrh	r3, [r5, #0]
   2d2ca:	8003      	strh	r3, [r0, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   2d2cc:	8823      	ldrh	r3, [r4, #0]
   2d2ce:	8043      	strh	r3, [r0, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   2d2d0:	8863      	ldrh	r3, [r4, #2]
   2d2d2:	8083      	strh	r3, [r0, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   2d2d4:	88a3      	ldrh	r3, [r4, #4]
   2d2d6:	80c3      	strh	r3, [r0, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   2d2d8:	88e3      	ldrh	r3, [r4, #6]
   2d2da:	8103      	strh	r3, [r0, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   2d2dc:	4631      	mov	r1, r6
   2d2de:	f242 0013 	movw	r0, #8211	; 0x2013
   2d2e2:	f7ec fcff 	bl	19ce4 <bt_hci_cmd_send_sync>
}
   2d2e6:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   2d2e8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2d2ec:	e7fb      	b.n	2d2e6 <bt_conn_le_conn_update+0x44>

0002d2ee <l2cap_connected>:
}
   2d2ee:	4770      	bx	lr

0002d2f0 <l2cap_disconnected>:
}
   2d2f0:	4770      	bx	lr

0002d2f2 <l2cap_chan_recv>:
{
   2d2f2:	b510      	push	{r4, lr}
   2d2f4:	460c      	mov	r4, r1
	chan->ops->recv(chan, buf);
   2d2f6:	6843      	ldr	r3, [r0, #4]
   2d2f8:	691b      	ldr	r3, [r3, #16]
   2d2fa:	4798      	blx	r3
	net_buf_unref(buf);
   2d2fc:	4620      	mov	r0, r4
   2d2fe:	f7f1 fe09 	bl	1ef14 <net_buf_unref>
}
   2d302:	bd10      	pop	{r4, pc}

0002d304 <bt_l2cap_chan_del>:
{
   2d304:	b538      	push	{r3, r4, r5, lr}
   2d306:	4604      	mov	r4, r0
	const struct bt_l2cap_chan_ops *ops = chan->ops;
   2d308:	6845      	ldr	r5, [r0, #4]
	if (!chan->conn) {
   2d30a:	6803      	ldr	r3, [r0, #0]
   2d30c:	b123      	cbz	r3, 2d318 <bt_l2cap_chan_del+0x14>
	if (ops->disconnected) {
   2d30e:	686b      	ldr	r3, [r5, #4]
   2d310:	b103      	cbz	r3, 2d314 <bt_l2cap_chan_del+0x10>
		ops->disconnected(chan);
   2d312:	4798      	blx	r3
	chan->conn = NULL;
   2d314:	2300      	movs	r3, #0
   2d316:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   2d318:	68e3      	ldr	r3, [r4, #12]
   2d31a:	b10b      	cbz	r3, 2d320 <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   2d31c:	4620      	mov	r0, r4
   2d31e:	4798      	blx	r3
	if (ops->released) {
   2d320:	69eb      	ldr	r3, [r5, #28]
   2d322:	b10b      	cbz	r3, 2d328 <bt_l2cap_chan_del+0x24>
		ops->released(chan);
   2d324:	4620      	mov	r0, r4
   2d326:	4798      	blx	r3
}
   2d328:	bd38      	pop	{r3, r4, r5, pc}

0002d32a <bt_l2cap_chan_add>:
{
   2d32a:	b410      	push	{r4}
	sys_slist_append(&conn->channels, &chan->node);
   2d32c:	f101 0308 	add.w	r3, r1, #8
	parent->next = child;
   2d330:	2400      	movs	r4, #0
   2d332:	608c      	str	r4, [r1, #8]
	return list->tail;
   2d334:	6d84      	ldr	r4, [r0, #88]	; 0x58
Z_GENLIST_APPEND(slist, snode)
   2d336:	b134      	cbz	r4, 2d346 <bt_l2cap_chan_add+0x1c>
	parent->next = child;
   2d338:	6023      	str	r3, [r4, #0]
	list->tail = node;
   2d33a:	6583      	str	r3, [r0, #88]	; 0x58
	chan->conn = conn;
   2d33c:	6008      	str	r0, [r1, #0]
	chan->destroy = destroy;
   2d33e:	60ca      	str	r2, [r1, #12]
}
   2d340:	f85d 4b04 	ldr.w	r4, [sp], #4
   2d344:	4770      	bx	lr
   2d346:	6583      	str	r3, [r0, #88]	; 0x58
	list->head = node;
   2d348:	6543      	str	r3, [r0, #84]	; 0x54
}
   2d34a:	e7f7      	b.n	2d33c <bt_l2cap_chan_add+0x12>

0002d34c <bt_l2cap_disconnected>:
{
   2d34c:	b510      	push	{r4, lr}
	return list->head;
   2d34e:	6d40      	ldr	r0, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2d350:	b140      	cbz	r0, 2d364 <bt_l2cap_disconnected+0x18>
   2d352:	3808      	subs	r0, #8
   2d354:	d008      	beq.n	2d368 <bt_l2cap_disconnected+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2d356:	f110 0408 	adds.w	r4, r0, #8
   2d35a:	d00a      	beq.n	2d372 <bt_l2cap_disconnected+0x26>
	return node->next;
   2d35c:	6884      	ldr	r4, [r0, #8]
   2d35e:	b144      	cbz	r4, 2d372 <bt_l2cap_disconnected+0x26>
   2d360:	3c08      	subs	r4, #8
   2d362:	e006      	b.n	2d372 <bt_l2cap_disconnected+0x26>
   2d364:	4604      	mov	r4, r0
   2d366:	e004      	b.n	2d372 <bt_l2cap_disconnected+0x26>
   2d368:	4604      	mov	r4, r0
   2d36a:	e002      	b.n	2d372 <bt_l2cap_disconnected+0x26>
   2d36c:	4623      	mov	r3, r4
   2d36e:	4620      	mov	r0, r4
   2d370:	461c      	mov	r4, r3
   2d372:	b158      	cbz	r0, 2d38c <bt_l2cap_disconnected+0x40>
		bt_l2cap_chan_del(chan);
   2d374:	f7ff ffc6 	bl	2d304 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2d378:	2c00      	cmp	r4, #0
   2d37a:	d0f7      	beq.n	2d36c <bt_l2cap_disconnected+0x20>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2d37c:	f114 0308 	adds.w	r3, r4, #8
   2d380:	d0f5      	beq.n	2d36e <bt_l2cap_disconnected+0x22>
	return node->next;
   2d382:	68a3      	ldr	r3, [r4, #8]
   2d384:	2b00      	cmp	r3, #0
   2d386:	d0f2      	beq.n	2d36e <bt_l2cap_disconnected+0x22>
   2d388:	3b08      	subs	r3, #8
   2d38a:	e7f0      	b.n	2d36e <bt_l2cap_disconnected+0x22>
}
   2d38c:	bd10      	pop	{r4, pc}

0002d38e <bt_l2cap_create_pdu_timeout>:
{
   2d38e:	b508      	push	{r3, lr}
	return bt_conn_create_pdu_timeout(pool,
   2d390:	3104      	adds	r1, #4
   2d392:	f7ee fa7f 	bl	1b894 <bt_conn_create_pdu_timeout>
}
   2d396:	bd08      	pop	{r3, pc}

0002d398 <bt_l2cap_send_cb>:
{
   2d398:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d39a:	4605      	mov	r5, r0
   2d39c:	460f      	mov	r7, r1
   2d39e:	4614      	mov	r4, r2
   2d3a0:	461e      	mov	r6, r3
	return net_buf_simple_push(&buf->b, len);
   2d3a2:	2104      	movs	r1, #4
   2d3a4:	f102 0008 	add.w	r0, r2, #8
   2d3a8:	f7f1 feac 	bl	1f104 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   2d3ac:	89a3      	ldrh	r3, [r4, #12]
   2d3ae:	3b04      	subs	r3, #4
   2d3b0:	8003      	strh	r3, [r0, #0]
	hdr->cid = sys_cpu_to_le16(cid);
   2d3b2:	8047      	strh	r7, [r0, #2]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   2d3b4:	9b06      	ldr	r3, [sp, #24]
   2d3b6:	4632      	mov	r2, r6
   2d3b8:	4621      	mov	r1, r4
   2d3ba:	4628      	mov	r0, r5
   2d3bc:	f7ee f8f4 	bl	1b5a8 <bt_conn_send_cb>
}
   2d3c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002d3c2 <l2cap_send_reject>:
{
   2d3c2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2d3c6:	b083      	sub	sp, #12
   2d3c8:	4605      	mov	r5, r0
   2d3ca:	4690      	mov	r8, r2
   2d3cc:	461c      	mov	r4, r3
   2d3ce:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   2d3d2:	1cbb      	adds	r3, r7, #2
   2d3d4:	460a      	mov	r2, r1
   2d3d6:	2101      	movs	r1, #1
   2d3d8:	2000      	movs	r0, #0
   2d3da:	f7ee fd33 	bl	1be44 <l2cap_create_le_sig_pdu>
	if (!buf) {
   2d3de:	b1b0      	cbz	r0, 2d40e <l2cap_send_reject+0x4c>
   2d3e0:	4606      	mov	r6, r0
	return net_buf_simple_add(&buf->b, len);
   2d3e2:	f100 0908 	add.w	r9, r0, #8
   2d3e6:	2102      	movs	r1, #2
   2d3e8:	4648      	mov	r0, r9
   2d3ea:	f7f1 feab 	bl	1f144 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
   2d3ee:	f8a0 8000 	strh.w	r8, [r0]
	if (data) {
   2d3f2:	b124      	cbz	r4, 2d3fe <l2cap_send_reject+0x3c>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   2d3f4:	463a      	mov	r2, r7
   2d3f6:	4621      	mov	r1, r4
   2d3f8:	4648      	mov	r0, r9
   2d3fa:	f001 fd79 	bl	2eef0 <net_buf_simple_add_mem>
		     bt_conn_tx_cb_t cb, void *user_data);

static inline int bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				struct net_buf *buf)
{
	return bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
   2d3fe:	2300      	movs	r3, #0
   2d400:	9300      	str	r3, [sp, #0]
   2d402:	4632      	mov	r2, r6
   2d404:	2105      	movs	r1, #5
   2d406:	4628      	mov	r0, r5
   2d408:	f7ff ffc6 	bl	2d398 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, cid, buf)) {
   2d40c:	b910      	cbnz	r0, 2d414 <l2cap_send_reject+0x52>
}
   2d40e:	b003      	add	sp, #12
   2d410:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		net_buf_unref(buf);
   2d414:	4630      	mov	r0, r6
   2d416:	f7f1 fd7d 	bl	1ef14 <net_buf_unref>
}
   2d41a:	e7f8      	b.n	2d40e <l2cap_send_reject+0x4c>

0002d41c <bt_l2cap_le_lookup_rx_cid>:
	return list->head;
   2d41c:	6d40      	ldr	r0, [r0, #84]	; 0x54
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2d41e:	b110      	cbz	r0, 2d426 <bt_l2cap_le_lookup_rx_cid+0xa>
   2d420:	3808      	subs	r0, #8
   2d422:	e000      	b.n	2d426 <bt_l2cap_le_lookup_rx_cid+0xa>
   2d424:	4618      	mov	r0, r3
   2d426:	b148      	cbz	r0, 2d43c <bt_l2cap_le_lookup_rx_cid+0x20>
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   2d428:	8a83      	ldrh	r3, [r0, #20]
   2d42a:	428b      	cmp	r3, r1
   2d42c:	d006      	beq.n	2d43c <bt_l2cap_le_lookup_rx_cid+0x20>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2d42e:	f110 0308 	adds.w	r3, r0, #8
   2d432:	d0f7      	beq.n	2d424 <bt_l2cap_le_lookup_rx_cid+0x8>
	return node->next;
   2d434:	6880      	ldr	r0, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2d436:	b108      	cbz	r0, 2d43c <bt_l2cap_le_lookup_rx_cid+0x20>
   2d438:	3808      	subs	r0, #8
   2d43a:	e7f4      	b.n	2d426 <bt_l2cap_le_lookup_rx_cid+0xa>
}
   2d43c:	4770      	bx	lr

0002d43e <bt_l2cap_update_conn_param>:
{
   2d43e:	b570      	push	{r4, r5, r6, lr}
   2d440:	b082      	sub	sp, #8
   2d442:	4605      	mov	r5, r0
   2d444:	460c      	mov	r4, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   2d446:	f7ee fc55 	bl	1bcf4 <get_ident>
   2d44a:	4602      	mov	r2, r0
   2d44c:	2308      	movs	r3, #8
   2d44e:	2112      	movs	r1, #18
   2d450:	2000      	movs	r0, #0
   2d452:	f7ee fcf7 	bl	1be44 <l2cap_create_le_sig_pdu>
	if (!buf) {
   2d456:	b1e0      	cbz	r0, 2d492 <bt_l2cap_update_conn_param+0x54>
   2d458:	4606      	mov	r6, r0
	return net_buf_simple_add(&buf->b, len);
   2d45a:	2108      	movs	r1, #8
   2d45c:	4408      	add	r0, r1
   2d45e:	f7f1 fe71 	bl	1f144 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
   2d462:	8823      	ldrh	r3, [r4, #0]
   2d464:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
   2d466:	8863      	ldrh	r3, [r4, #2]
   2d468:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
   2d46a:	88a3      	ldrh	r3, [r4, #4]
   2d46c:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
   2d46e:	88e3      	ldrh	r3, [r4, #6]
   2d470:	80c3      	strh	r3, [r0, #6]
   2d472:	2300      	movs	r3, #0
   2d474:	9300      	str	r3, [sp, #0]
   2d476:	4632      	mov	r2, r6
   2d478:	2105      	movs	r1, #5
   2d47a:	4628      	mov	r0, r5
   2d47c:	f7ff ff8c 	bl	2d398 <bt_l2cap_send_cb>
	if (err) {
   2d480:	4604      	mov	r4, r0
   2d482:	b910      	cbnz	r0, 2d48a <bt_l2cap_update_conn_param+0x4c>
}
   2d484:	4620      	mov	r0, r4
   2d486:	b002      	add	sp, #8
   2d488:	bd70      	pop	{r4, r5, r6, pc}
		net_buf_unref(buf);
   2d48a:	4630      	mov	r0, r6
   2d48c:	f7f1 fd42 	bl	1ef14 <net_buf_unref>
		return err;
   2d490:	e7f8      	b.n	2d484 <bt_l2cap_update_conn_param+0x46>
		return -ENOMEM;
   2d492:	f06f 040b 	mvn.w	r4, #11
   2d496:	e7f5      	b.n	2d484 <bt_l2cap_update_conn_param+0x46>

0002d498 <bt_l2cap_init>:
#if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
	for (size_t i = 0; i < ARRAY_SIZE(l2cap_tx_meta_data); i++) {
		k_fifo_put(&free_l2cap_tx_meta_data, &l2cap_tx_meta_data[i]);
	}
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}
   2d498:	4770      	bx	lr

0002d49a <get_first_req_matching_chan>:
{
   2d49a:	4603      	mov	r3, r0
	return list->head;
   2d49c:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
   2d49e:	b120      	cbz	r0, 2d4aa <get_first_req_matching_chan+0x10>
	return node->next;
   2d4a0:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   2d4a2:	601a      	str	r2, [r3, #0]
	return list->tail;
   2d4a4:	6859      	ldr	r1, [r3, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2d4a6:	4288      	cmp	r0, r1
   2d4a8:	d000      	beq.n	2d4ac <get_first_req_matching_chan+0x12>
}
   2d4aa:	4770      	bx	lr
	list->tail = node;
   2d4ac:	605a      	str	r2, [r3, #4]
		return ATT_REQ(node);
   2d4ae:	e7fc      	b.n	2d4aa <get_first_req_matching_chan+0x10>

0002d4b0 <range_is_valid>:
	if (!start || !end) {
   2d4b0:	b120      	cbz	r0, 2d4bc <range_is_valid+0xc>
   2d4b2:	b119      	cbz	r1, 2d4bc <range_is_valid+0xc>
	if (start > end) {
   2d4b4:	4288      	cmp	r0, r1
   2d4b6:	d806      	bhi.n	2d4c6 <range_is_valid+0x16>
	return true;
   2d4b8:	2001      	movs	r0, #1
}
   2d4ba:	4770      	bx	lr
		if (err) {
   2d4bc:	b10a      	cbz	r2, 2d4c2 <range_is_valid+0x12>
			*err = 0U;
   2d4be:	2300      	movs	r3, #0
   2d4c0:	8013      	strh	r3, [r2, #0]
		return false;
   2d4c2:	2000      	movs	r0, #0
   2d4c4:	4770      	bx	lr
		if (err) {
   2d4c6:	b102      	cbz	r2, 2d4ca <range_is_valid+0x1a>
			*err = start;
   2d4c8:	8010      	strh	r0, [r2, #0]
		return false;
   2d4ca:	2000      	movs	r0, #0
   2d4cc:	4770      	bx	lr

0002d4ce <err_to_att>:
	if (err < 0 && err >= -0xff) {
   2d4ce:	f110 0fff 	cmn.w	r0, #255	; 0xff
   2d4d2:	d201      	bcs.n	2d4d8 <err_to_att+0xa>
	return BT_ATT_ERR_UNLIKELY;
   2d4d4:	200e      	movs	r0, #14
}
   2d4d6:	4770      	bx	lr
		return -err;
   2d4d8:	4240      	negs	r0, r0
   2d4da:	b2c0      	uxtb	r0, r0
   2d4dc:	4770      	bx	lr

0002d4de <attr_read_type_cb>:
{
   2d4de:	b410      	push	{r4}
	if (!data->rsp->len) {
   2d4e0:	68d4      	ldr	r4, [r2, #12]
   2d4e2:	7823      	ldrb	r3, [r4, #0]
   2d4e4:	b92b      	cbnz	r3, 2d4f2 <attr_read_type_cb+0x14>
		data->rsp->len = read + sizeof(*data->item);
   2d4e6:	3102      	adds	r1, #2
   2d4e8:	7021      	strb	r1, [r4, #0]
	return true;
   2d4ea:	2001      	movs	r0, #1
}
   2d4ec:	f85d 4b04 	ldr.w	r4, [sp], #4
   2d4f0:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   2d4f2:	3102      	adds	r1, #2
   2d4f4:	428b      	cmp	r3, r1
   2d4f6:	d005      	beq.n	2d504 <attr_read_type_cb+0x26>
		frag->len -= sizeof(*data->item);
   2d4f8:	8983      	ldrh	r3, [r0, #12]
   2d4fa:	3b02      	subs	r3, #2
   2d4fc:	8183      	strh	r3, [r0, #12]
		data->item = NULL;
   2d4fe:	2000      	movs	r0, #0
   2d500:	6110      	str	r0, [r2, #16]
		return false;
   2d502:	e7f3      	b.n	2d4ec <attr_read_type_cb+0xe>
	return true;
   2d504:	2001      	movs	r0, #1
   2d506:	e7f1      	b.n	2d4ec <attr_read_type_cb+0xe>

0002d508 <attr_read_group_cb>:
	if (!data->rsp->len) {
   2d508:	68d0      	ldr	r0, [r2, #12]
   2d50a:	7803      	ldrb	r3, [r0, #0]
   2d50c:	b91b      	cbnz	r3, 2d516 <attr_read_group_cb+0xe>
		data->rsp->len = read + sizeof(*data->group);
   2d50e:	3104      	adds	r1, #4
   2d510:	7001      	strb	r1, [r0, #0]
	return true;
   2d512:	2001      	movs	r0, #1
   2d514:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   2d516:	3104      	adds	r1, #4
   2d518:	428b      	cmp	r3, r1
   2d51a:	d006      	beq.n	2d52a <attr_read_group_cb+0x22>
		data->buf->len -= sizeof(*data->group);
   2d51c:	6891      	ldr	r1, [r2, #8]
   2d51e:	898b      	ldrh	r3, [r1, #12]
   2d520:	3b04      	subs	r3, #4
   2d522:	818b      	strh	r3, [r1, #12]
		data->group = NULL;
   2d524:	2000      	movs	r0, #0
   2d526:	6110      	str	r0, [r2, #16]
		return false;
   2d528:	4770      	bx	lr
	return true;
   2d52a:	2001      	movs	r0, #1
}
   2d52c:	4770      	bx	lr

0002d52e <att_prepare_write_req>:
}
   2d52e:	2006      	movs	r0, #6
   2d530:	4770      	bx	lr

0002d532 <att_exec_write_req>:
}
   2d532:	2006      	movs	r0, #6
   2d534:	4770      	bx	lr

0002d536 <att_op_get_type>:
	switch (op) {
   2d536:	1e43      	subs	r3, r0, #1
   2d538:	2bd1      	cmp	r3, #209	; 0xd1
   2d53a:	d874      	bhi.n	2d626 <att_op_get_type+0xf0>
   2d53c:	e8df f003 	tbb	[pc, r3]
   2d540:	696d696d 	.word	0x696d696d
   2d544:	696d696d 	.word	0x696d696d
   2d548:	696d696d 	.word	0x696d696d
   2d54c:	696d696d 	.word	0x696d696d
   2d550:	736d696d 	.word	0x736d696d
   2d554:	696d6973 	.word	0x696d6973
   2d558:	736f736d 	.word	0x736f736d
   2d55c:	69737871 	.word	0x69737871
   2d560:	736f736d 	.word	0x736f736d
   2d564:	73737373 	.word	0x73737373
   2d568:	73737373 	.word	0x73737373
   2d56c:	73737373 	.word	0x73737373
   2d570:	73737373 	.word	0x73737373
   2d574:	73737373 	.word	0x73737373
   2d578:	73737373 	.word	0x73737373
   2d57c:	73737373 	.word	0x73737373
   2d580:	73737373 	.word	0x73737373
   2d584:	73737373 	.word	0x73737373
   2d588:	73737373 	.word	0x73737373
   2d58c:	73737373 	.word	0x73737373
   2d590:	73736b73 	.word	0x73736b73
   2d594:	73737373 	.word	0x73737373
   2d598:	73737373 	.word	0x73737373
   2d59c:	73737373 	.word	0x73737373
   2d5a0:	73737373 	.word	0x73737373
   2d5a4:	73737373 	.word	0x73737373
   2d5a8:	73737373 	.word	0x73737373
   2d5ac:	73737373 	.word	0x73737373
   2d5b0:	73737373 	.word	0x73737373
   2d5b4:	73737373 	.word	0x73737373
   2d5b8:	73737373 	.word	0x73737373
   2d5bc:	73737373 	.word	0x73737373
   2d5c0:	73737373 	.word	0x73737373
   2d5c4:	73737373 	.word	0x73737373
   2d5c8:	73737373 	.word	0x73737373
   2d5cc:	73737373 	.word	0x73737373
   2d5d0:	73737373 	.word	0x73737373
   2d5d4:	73737373 	.word	0x73737373
   2d5d8:	73737373 	.word	0x73737373
   2d5dc:	73737373 	.word	0x73737373
   2d5e0:	73737373 	.word	0x73737373
   2d5e4:	73737373 	.word	0x73737373
   2d5e8:	73737373 	.word	0x73737373
   2d5ec:	73737373 	.word	0x73737373
   2d5f0:	73737373 	.word	0x73737373
   2d5f4:	73737373 	.word	0x73737373
   2d5f8:	73737373 	.word	0x73737373
   2d5fc:	73737373 	.word	0x73737373
   2d600:	73737373 	.word	0x73737373
   2d604:	73737373 	.word	0x73737373
   2d608:	73737373 	.word	0x73737373
   2d60c:	73737373 	.word	0x73737373
   2d610:	6b73      	.short	0x6b73
   2d612:	2001      	movs	r0, #1
   2d614:	4770      	bx	lr
		return ATT_COMMAND;
   2d616:	2000      	movs	r0, #0
   2d618:	4770      	bx	lr
		return ATT_RESPONSE;
   2d61a:	2002      	movs	r0, #2
   2d61c:	4770      	bx	lr
		return ATT_NOTIFICATION;
   2d61e:	2003      	movs	r0, #3
   2d620:	4770      	bx	lr
		return ATT_INDICATION;
   2d622:	2005      	movs	r0, #5
   2d624:	4770      	bx	lr
	if (op & ATT_CMD_MASK) {
   2d626:	f010 0f40 	tst.w	r0, #64	; 0x40
   2d62a:	d103      	bne.n	2d634 <att_op_get_type+0xfe>
	return ATT_UNKNOWN;
   2d62c:	2006      	movs	r0, #6
   2d62e:	4770      	bx	lr
		return ATT_CONFIRMATION;
   2d630:	2004      	movs	r0, #4
   2d632:	4770      	bx	lr
		return ATT_COMMAND;
   2d634:	2000      	movs	r0, #0
}
   2d636:	4770      	bx	lr

0002d638 <att_chan_attach>:
{
   2d638:	b538      	push	{r3, r4, r5, lr}
   2d63a:	4604      	mov	r4, r0
   2d63c:	460d      	mov	r5, r1
	return list->head;
   2d63e:	6a83      	ldr	r3, [r0, #40]	; 0x28
	if (sys_slist_is_empty(&att->chans)) {
   2d640:	b143      	cbz	r3, 2d654 <att_chan_attach+0x1c>
	sys_slist_prepend(&att->chans, &chan->node);
   2d642:	f105 03f0 	add.w	r3, r5, #240	; 0xf0
   2d646:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	parent->next = child;
   2d648:	f8c5 20f0 	str.w	r2, [r5, #240]	; 0xf0
	list->head = node;
   2d64c:	62a3      	str	r3, [r4, #40]	; 0x28
	return list->tail;
   2d64e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
Z_GENLIST_PREPEND(slist, snode)
   2d650:	b122      	cbz	r2, 2d65c <att_chan_attach+0x24>
}
   2d652:	bd38      	pop	{r3, r4, r5, pc}
		k_fifo_init(&att->tx_queue);
   2d654:	300c      	adds	r0, #12
	z_impl_k_queue_init(queue);
   2d656:	f003 f9c2 	bl	309de <z_impl_k_queue_init>
}
   2d65a:	e7f2      	b.n	2d642 <att_chan_attach+0xa>
	list->tail = node;
   2d65c:	62e3      	str	r3, [r4, #44]	; 0x2c
}
   2d65e:	e7f8      	b.n	2d652 <att_chan_attach+0x1a>

0002d660 <get_first_buf_matching_chan>:
{
   2d660:	b508      	push	{r3, lr}
		return net_buf_get(fifo, K_NO_WAIT);
   2d662:	2200      	movs	r2, #0
   2d664:	2300      	movs	r3, #0
   2d666:	f7f1 fae7 	bl	1ec38 <net_buf_get>
}
   2d66a:	bd08      	pop	{r3, pc}

0002d66c <att_notify_mult>:
{
   2d66c:	b508      	push	{r3, lr}
	bt_gatt_mult_notification(chan->att->conn, buf->data, buf->len);
   2d66e:	6803      	ldr	r3, [r0, #0]
   2d670:	898a      	ldrh	r2, [r1, #12]
   2d672:	6889      	ldr	r1, [r1, #8]
   2d674:	6818      	ldr	r0, [r3, #0]
   2d676:	f7f1 f8db 	bl	1e830 <bt_gatt_mult_notification>
}
   2d67a:	2000      	movs	r0, #0
   2d67c:	bd08      	pop	{r3, pc}

0002d67e <att_notify>:
{
   2d67e:	b538      	push	{r3, r4, r5, lr}
   2d680:	4605      	mov	r5, r0
   2d682:	460c      	mov	r4, r1
	return net_buf_simple_pull_le16(&buf->b);
   2d684:	f101 0008 	add.w	r0, r1, #8
   2d688:	f001 fc1d 	bl	2eec6 <net_buf_simple_pull_le16>
   2d68c:	4601      	mov	r1, r0
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   2d68e:	682d      	ldr	r5, [r5, #0]
   2d690:	89a3      	ldrh	r3, [r4, #12]
   2d692:	68a2      	ldr	r2, [r4, #8]
   2d694:	6828      	ldr	r0, [r5, #0]
   2d696:	f001 faef 	bl	2ec78 <bt_gatt_notification>
}
   2d69a:	2000      	movs	r0, #0
   2d69c:	bd38      	pop	{r3, r4, r5, pc}

0002d69e <att_chan_mtu_updated>:
{
   2d69e:	b570      	push	{r4, r5, r6, lr}
	struct bt_att *att = updated_chan->att;
   2d6a0:	6806      	ldr	r6, [r0, #0]
	return list->head;
   2d6a2:	6ab4      	ldr	r4, [r6, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2d6a4:	b14c      	cbz	r4, 2d6ba <att_chan_mtu_updated+0x1c>
   2d6a6:	3cf0      	subs	r4, #240	; 0xf0
   2d6a8:	d00b      	beq.n	2d6c2 <att_chan_mtu_updated+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2d6aa:	f114 03f0 	adds.w	r3, r4, #240	; 0xf0
   2d6ae:	d005      	beq.n	2d6bc <att_chan_mtu_updated+0x1e>
	return node->next;
   2d6b0:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
   2d6b4:	b113      	cbz	r3, 2d6bc <att_chan_mtu_updated+0x1e>
   2d6b6:	3bf0      	subs	r3, #240	; 0xf0
   2d6b8:	e000      	b.n	2d6bc <att_chan_mtu_updated+0x1e>
   2d6ba:	4623      	mov	r3, r4
   2d6bc:	2200      	movs	r2, #0
   2d6be:	4611      	mov	r1, r2
   2d6c0:	e004      	b.n	2d6cc <att_chan_mtu_updated+0x2e>
   2d6c2:	4623      	mov	r3, r4
   2d6c4:	e7fa      	b.n	2d6bc <att_chan_mtu_updated+0x1e>
   2d6c6:	461d      	mov	r5, r3
   2d6c8:	461c      	mov	r4, r3
   2d6ca:	462b      	mov	r3, r5
   2d6cc:	b1a4      	cbz	r4, 2d6f8 <att_chan_mtu_updated+0x5a>
		if (chan == updated_chan) {
   2d6ce:	4284      	cmp	r4, r0
   2d6d0:	d007      	beq.n	2d6e2 <att_chan_mtu_updated+0x44>
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
   2d6d2:	8d65      	ldrh	r5, [r4, #42]	; 0x2a
   2d6d4:	42a9      	cmp	r1, r5
   2d6d6:	bf38      	it	cc
   2d6d8:	4629      	movcc	r1, r5
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
   2d6da:	8b64      	ldrh	r4, [r4, #26]
   2d6dc:	42a2      	cmp	r2, r4
   2d6de:	bf38      	it	cc
   2d6e0:	4622      	movcc	r2, r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2d6e2:	2b00      	cmp	r3, #0
   2d6e4:	d0ef      	beq.n	2d6c6 <att_chan_mtu_updated+0x28>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2d6e6:	f113 05f0 	adds.w	r5, r3, #240	; 0xf0
   2d6ea:	d0ed      	beq.n	2d6c8 <att_chan_mtu_updated+0x2a>
	return node->next;
   2d6ec:	f8d3 50f0 	ldr.w	r5, [r3, #240]	; 0xf0
   2d6f0:	2d00      	cmp	r5, #0
   2d6f2:	d0e9      	beq.n	2d6c8 <att_chan_mtu_updated+0x2a>
   2d6f4:	3df0      	subs	r5, #240	; 0xf0
   2d6f6:	e7e7      	b.n	2d6c8 <att_chan_mtu_updated+0x2a>
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   2d6f8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
   2d6fa:	428b      	cmp	r3, r1
   2d6fc:	d802      	bhi.n	2d704 <att_chan_mtu_updated+0x66>
	    (updated_chan->chan.rx.mtu > max_rx)) {
   2d6fe:	8b44      	ldrh	r4, [r0, #26]
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   2d700:	4294      	cmp	r4, r2
   2d702:	d909      	bls.n	2d718 <att_chan_mtu_updated+0x7a>
		max_rx = MAX(max_rx, updated_chan->chan.rx.mtu);
   2d704:	8b40      	ldrh	r0, [r0, #26]
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
   2d706:	4282      	cmp	r2, r0
   2d708:	bf38      	it	cc
   2d70a:	4602      	movcc	r2, r0
   2d70c:	4299      	cmp	r1, r3
   2d70e:	bf38      	it	cc
   2d710:	4619      	movcc	r1, r3
   2d712:	6830      	ldr	r0, [r6, #0]
   2d714:	f7f1 f912 	bl	1e93c <bt_gatt_att_max_mtu_changed>
}
   2d718:	bd70      	pop	{r4, r5, r6, pc}

0002d71a <write_cb>:
{
   2d71a:	b5f0      	push	{r4, r5, r6, r7, lr}
   2d71c:	b083      	sub	sp, #12
   2d71e:	4606      	mov	r6, r0
   2d720:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(data->conn, attr,
   2d722:	f44f 7295 	mov.w	r2, #298	; 0x12a
   2d726:	4601      	mov	r1, r0
   2d728:	6820      	ldr	r0, [r4, #0]
   2d72a:	f001 fa55 	bl	2ebd8 <bt_gatt_check_perm>
   2d72e:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   2d730:	bb08      	cbnz	r0, 2d776 <write_cb+0x5c>
   2d732:	4605      	mov	r5, r0
	if (!data->req) {
   2d734:	7a23      	ldrb	r3, [r4, #8]
   2d736:	b11b      	cbz	r3, 2d740 <write_cb+0x26>
	} else if (data->req == BT_ATT_OP_EXEC_WRITE_REQ) {
   2d738:	2b18      	cmp	r3, #24
   2d73a:	d016      	beq.n	2d76a <write_cb+0x50>
	uint8_t flags = 0U;
   2d73c:	4603      	mov	r3, r0
   2d73e:	e000      	b.n	2d742 <write_cb+0x28>
		flags |= BT_GATT_WRITE_FLAG_CMD;
   2d740:	2302      	movs	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   2d742:	68b7      	ldr	r7, [r6, #8]
   2d744:	9301      	str	r3, [sp, #4]
   2d746:	8a63      	ldrh	r3, [r4, #18]
   2d748:	9300      	str	r3, [sp, #0]
   2d74a:	8a23      	ldrh	r3, [r4, #16]
   2d74c:	68e2      	ldr	r2, [r4, #12]
   2d74e:	4631      	mov	r1, r6
   2d750:	6820      	ldr	r0, [r4, #0]
   2d752:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   2d754:	2800      	cmp	r0, #0
   2d756:	db02      	blt.n	2d75e <write_cb+0x44>
   2d758:	8a23      	ldrh	r3, [r4, #16]
   2d75a:	4298      	cmp	r0, r3
   2d75c:	d007      	beq.n	2d76e <write_cb+0x54>
		data->err = err_to_att(write);
   2d75e:	f7ff feb6 	bl	2d4ce <err_to_att>
   2d762:	7520      	strb	r0, [r4, #20]
}
   2d764:	4628      	mov	r0, r5
   2d766:	b003      	add	sp, #12
   2d768:	bdf0      	pop	{r4, r5, r6, r7, pc}
		flags |= BT_GATT_WRITE_FLAG_EXECUTE;
   2d76a:	2304      	movs	r3, #4
   2d76c:	e7e9      	b.n	2d742 <write_cb+0x28>
	data->err = 0U;
   2d76e:	2300      	movs	r3, #0
   2d770:	7523      	strb	r3, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   2d772:	2501      	movs	r5, #1
   2d774:	e7f6      	b.n	2d764 <write_cb+0x4a>
		return BT_GATT_ITER_STOP;
   2d776:	2500      	movs	r5, #0
   2d778:	e7f4      	b.n	2d764 <write_cb+0x4a>

0002d77a <att_chan_read>:
{
   2d77a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d77e:	b085      	sub	sp, #20
   2d780:	4680      	mov	r8, r0
   2d782:	4689      	mov	r9, r1
   2d784:	9202      	str	r2, [sp, #8]
   2d786:	461d      	mov	r5, r3
	struct bt_conn *conn = chan->chan.chan.conn;
   2d788:	6841      	ldr	r1, [r0, #4]
   2d78a:	9103      	str	r1, [sp, #12]
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   2d78c:	8d40      	ldrh	r0, [r0, #42]	; 0x2a
	while (buf) {
   2d78e:	4613      	mov	r3, r2
	size_t bytes = 0;
   2d790:	2200      	movs	r2, #0
	while (buf) {
   2d792:	e002      	b.n	2d79a <att_chan_read+0x20>
		bytes += buf->len;
   2d794:	8999      	ldrh	r1, [r3, #12]
   2d796:	440a      	add	r2, r1
		buf = buf->frags;
   2d798:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2d79a:	2b00      	cmp	r3, #0
   2d79c:	d1fa      	bne.n	2d794 <att_chan_read+0x1a>
   2d79e:	4290      	cmp	r0, r2
   2d7a0:	d804      	bhi.n	2d7ac <att_chan_read+0x32>
		return 0;
   2d7a2:	2400      	movs	r4, #0
}
   2d7a4:	4620      	mov	r0, r4
   2d7a6:	b005      	add	sp, #20
   2d7a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	frag = net_buf_frag_last(buf);
   2d7ac:	9802      	ldr	r0, [sp, #8]
   2d7ae:	f7f1 fc03 	bl	1efb8 <net_buf_frag_last>
   2d7b2:	4607      	mov	r7, r0
	size_t len, total = 0;
   2d7b4:	f04f 0a00 	mov.w	sl, #0
   2d7b8:	e082      	b.n	2d8c0 <att_chan_read+0x146>
		bytes += buf->len;
   2d7ba:	8999      	ldrh	r1, [r3, #12]
   2d7bc:	440a      	add	r2, r1
		buf = buf->frags;
   2d7be:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2d7c0:	2b00      	cmp	r3, #0
   2d7c2:	d1fa      	bne.n	2d7ba <att_chan_read+0x40>
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   2d7c4:	1aa4      	subs	r4, r4, r2
	return net_buf_simple_tailroom(&buf->b);
   2d7c6:	f107 0608 	add.w	r6, r7, #8
   2d7ca:	4630      	mov	r0, r6
   2d7cc:	f001 fb87 	bl	2eede <net_buf_simple_tailroom>
   2d7d0:	4284      	cmp	r4, r0
   2d7d2:	d326      	bcc.n	2d822 <att_chan_read+0xa8>
   2d7d4:	4630      	mov	r0, r6
   2d7d6:	f001 fb82 	bl	2eede <net_buf_simple_tailroom>
   2d7da:	4606      	mov	r6, r0
		if (!len) {
   2d7dc:	b36e      	cbz	r6, 2d83a <att_chan_read+0xc0>
		read = attr->read(conn, attr, frag->data + frag->len, len,
   2d7de:	f8d9 4004 	ldr.w	r4, [r9, #4]
   2d7e2:	68b9      	ldr	r1, [r7, #8]
   2d7e4:	89ba      	ldrh	r2, [r7, #12]
   2d7e6:	9500      	str	r5, [sp, #0]
   2d7e8:	b2b3      	uxth	r3, r6
   2d7ea:	440a      	add	r2, r1
   2d7ec:	4649      	mov	r1, r9
   2d7ee:	9803      	ldr	r0, [sp, #12]
   2d7f0:	47a0      	blx	r4
		if (read < 0) {
   2d7f2:	1e04      	subs	r4, r0, #0
   2d7f4:	db55      	blt.n	2d8a2 <att_chan_read+0x128>
		if (cb && !cb(frag, read, user_data)) {
   2d7f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2d7f8:	b12b      	cbz	r3, 2d806 <att_chan_read+0x8c>
   2d7fa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   2d7fc:	4621      	mov	r1, r4
   2d7fe:	4638      	mov	r0, r7
   2d800:	4798      	blx	r3
   2d802:	2800      	cmp	r0, #0
   2d804:	d061      	beq.n	2d8ca <att_chan_read+0x150>
		net_buf_add(frag, read);
   2d806:	46a3      	mov	fp, r4
	return net_buf_simple_add(&buf->b, len);
   2d808:	4621      	mov	r1, r4
   2d80a:	f107 0008 	add.w	r0, r7, #8
   2d80e:	f7f1 fc99 	bl	1f144 <net_buf_simple_add>
		total += read;
   2d812:	44a2      	add	sl, r4
		offset += read;
   2d814:	4425      	add	r5, r4
   2d816:	b2ad      	uxth	r5, r5
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   2d818:	f8b8 002a 	ldrh.w	r0, [r8, #42]	; 0x2a
   2d81c:	9b02      	ldr	r3, [sp, #8]
	size_t bytes = 0;
   2d81e:	2200      	movs	r2, #0
   2d820:	e048      	b.n	2d8b4 <att_chan_read+0x13a>
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   2d822:	f8b8 602a 	ldrh.w	r6, [r8, #42]	; 0x2a
	while (buf) {
   2d826:	9b02      	ldr	r3, [sp, #8]
	size_t bytes = 0;
   2d828:	2200      	movs	r2, #0
	while (buf) {
   2d82a:	e002      	b.n	2d832 <att_chan_read+0xb8>
		bytes += buf->len;
   2d82c:	8999      	ldrh	r1, [r3, #12]
   2d82e:	440a      	add	r2, r1
		buf = buf->frags;
   2d830:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2d832:	2b00      	cmp	r3, #0
   2d834:	d1fa      	bne.n	2d82c <att_chan_read+0xb2>
   2d836:	1ab6      	subs	r6, r6, r2
   2d838:	e7d0      	b.n	2d7dc <att_chan_read+0x62>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
   2d83a:	9b02      	ldr	r3, [sp, #8]
   2d83c:	7998      	ldrb	r0, [r3, #6]
   2d83e:	f7f1 f8df 	bl	1ea00 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   2d842:	2200      	movs	r2, #0
   2d844:	2300      	movs	r3, #0
   2d846:	f001 fb31 	bl	2eeac <net_buf_alloc_fixed>
			if (!frag) {
   2d84a:	4607      	mov	r7, r0
   2d84c:	b150      	cbz	r0, 2d864 <att_chan_read+0xea>
			net_buf_frag_add(buf, frag);
   2d84e:	4601      	mov	r1, r0
   2d850:	f8dd b008 	ldr.w	fp, [sp, #8]
   2d854:	4658      	mov	r0, fp
   2d856:	f7f1 fbf5 	bl	1f044 <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   2d85a:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
	size_t bytes = 0;
   2d85e:	4632      	mov	r2, r6
	while (buf) {
   2d860:	465b      	mov	r3, fp
   2d862:	e004      	b.n	2d86e <att_chan_read+0xf4>
				return total;
   2d864:	4654      	mov	r4, sl
   2d866:	e79d      	b.n	2d7a4 <att_chan_read+0x2a>
		bytes += buf->len;
   2d868:	8999      	ldrh	r1, [r3, #12]
   2d86a:	440a      	add	r2, r1
		buf = buf->frags;
   2d86c:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2d86e:	2b00      	cmp	r3, #0
   2d870:	d1fa      	bne.n	2d868 <att_chan_read+0xee>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   2d872:	1aa4      	subs	r4, r4, r2
	return net_buf_simple_tailroom(&buf->b);
   2d874:	f107 0b08 	add.w	fp, r7, #8
   2d878:	4658      	mov	r0, fp
   2d87a:	f001 fb30 	bl	2eede <net_buf_simple_tailroom>
   2d87e:	4284      	cmp	r4, r0
   2d880:	d304      	bcc.n	2d88c <att_chan_read+0x112>
   2d882:	4658      	mov	r0, fp
   2d884:	f001 fb2b 	bl	2eede <net_buf_simple_tailroom>
   2d888:	4606      	mov	r6, r0
   2d88a:	e7a8      	b.n	2d7de <att_chan_read+0x64>
   2d88c:	f8b8 102a 	ldrh.w	r1, [r8, #42]	; 0x2a
	while (buf) {
   2d890:	9b02      	ldr	r3, [sp, #8]
   2d892:	e002      	b.n	2d89a <att_chan_read+0x120>
		bytes += buf->len;
   2d894:	899a      	ldrh	r2, [r3, #12]
   2d896:	4416      	add	r6, r2
		buf = buf->frags;
   2d898:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2d89a:	2b00      	cmp	r3, #0
   2d89c:	d1fa      	bne.n	2d894 <att_chan_read+0x11a>
   2d89e:	1b8e      	subs	r6, r1, r6
   2d8a0:	e79d      	b.n	2d7de <att_chan_read+0x64>
			if (total) {
   2d8a2:	f1ba 0f00 	cmp.w	sl, #0
   2d8a6:	f43f af7d 	beq.w	2d7a4 <att_chan_read+0x2a>
				return total;
   2d8aa:	4654      	mov	r4, sl
   2d8ac:	e77a      	b.n	2d7a4 <att_chan_read+0x2a>
		bytes += buf->len;
   2d8ae:	8999      	ldrh	r1, [r3, #12]
   2d8b0:	440a      	add	r2, r1
		buf = buf->frags;
   2d8b2:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2d8b4:	2b00      	cmp	r3, #0
   2d8b6:	d1fa      	bne.n	2d8ae <att_chan_read+0x134>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   2d8b8:	4290      	cmp	r0, r2
   2d8ba:	d906      	bls.n	2d8ca <att_chan_read+0x150>
   2d8bc:	45b3      	cmp	fp, r6
   2d8be:	d104      	bne.n	2d8ca <att_chan_read+0x150>
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   2d8c0:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
   2d8c4:	9b02      	ldr	r3, [sp, #8]
	size_t bytes = 0;
   2d8c6:	2200      	movs	r2, #0
	while (buf) {
   2d8c8:	e77a      	b.n	2d7c0 <att_chan_read+0x46>
	return total;
   2d8ca:	4654      	mov	r4, sl
   2d8cc:	e76a      	b.n	2d7a4 <att_chan_read+0x2a>

0002d8ce <read_vl_cb>:
{
   2d8ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2d8d2:	b082      	sub	sp, #8
   2d8d4:	4606      	mov	r6, r0
   2d8d6:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   2d8d8:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   2d8da:	6878      	ldr	r0, [r7, #4]
	data->err = 0x00;
   2d8dc:	2300      	movs	r3, #0
   2d8de:	7313      	strb	r3, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   2d8e0:	2295      	movs	r2, #149	; 0x95
   2d8e2:	4631      	mov	r1, r6
   2d8e4:	f001 f978 	bl	2ebd8 <bt_gatt_check_perm>
   2d8e8:	7320      	strb	r0, [r4, #12]
	if (data->err) {
   2d8ea:	b9f0      	cbnz	r0, 2d92a <read_vl_cb+0x5c>
   2d8ec:	4605      	mov	r5, r0
	if (chan->chan.tx.mtu - data->buf->len < 2) {
   2d8ee:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   2d8f0:	68a0      	ldr	r0, [r4, #8]
   2d8f2:	8982      	ldrh	r2, [r0, #12]
   2d8f4:	1a9b      	subs	r3, r3, r2
   2d8f6:	2b01      	cmp	r3, #1
   2d8f8:	dd18      	ble.n	2d92c <read_vl_cb+0x5e>
	return net_buf_simple_add(&buf->b, len);
   2d8fa:	2102      	movs	r1, #2
   2d8fc:	3008      	adds	r0, #8
   2d8fe:	f7f1 fc21 	bl	1f144 <net_buf_simple_add>
   2d902:	4680      	mov	r8, r0
	read = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   2d904:	2300      	movs	r3, #0
   2d906:	9301      	str	r3, [sp, #4]
   2d908:	9300      	str	r3, [sp, #0]
   2d90a:	88a3      	ldrh	r3, [r4, #4]
   2d90c:	68a2      	ldr	r2, [r4, #8]
   2d90e:	4631      	mov	r1, r6
   2d910:	4638      	mov	r0, r7
   2d912:	f7ff ff32 	bl	2d77a <att_chan_read>
	if (read < 0) {
   2d916:	2800      	cmp	r0, #0
   2d918:	db03      	blt.n	2d922 <read_vl_cb+0x54>
	rsp->len = read;
   2d91a:	f8a8 0000 	strh.w	r0, [r8]
	return BT_GATT_ITER_CONTINUE;
   2d91e:	2501      	movs	r5, #1
   2d920:	e004      	b.n	2d92c <read_vl_cb+0x5e>
		data->err = err_to_att(read);
   2d922:	f7ff fdd4 	bl	2d4ce <err_to_att>
   2d926:	7320      	strb	r0, [r4, #12]
		return BT_GATT_ITER_STOP;
   2d928:	e000      	b.n	2d92c <read_vl_cb+0x5e>
		return BT_GATT_ITER_STOP;
   2d92a:	2500      	movs	r5, #0
}
   2d92c:	4628      	mov	r0, r5
   2d92e:	b002      	add	sp, #8
   2d930:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002d934 <read_cb>:
{
   2d934:	b5f0      	push	{r4, r5, r6, r7, lr}
   2d936:	b083      	sub	sp, #12
   2d938:	4606      	mov	r6, r0
   2d93a:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   2d93c:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   2d93e:	6878      	ldr	r0, [r7, #4]
	data->err = 0x00;
   2d940:	2300      	movs	r3, #0
   2d942:	7313      	strb	r3, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   2d944:	2295      	movs	r2, #149	; 0x95
   2d946:	4631      	mov	r1, r6
   2d948:	f001 f946 	bl	2ebd8 <bt_gatt_check_perm>
   2d94c:	7320      	strb	r0, [r4, #12]
	if (data->err) {
   2d94e:	b118      	cbz	r0, 2d958 <read_cb+0x24>
		return BT_GATT_ITER_STOP;
   2d950:	2500      	movs	r5, #0
}
   2d952:	4628      	mov	r0, r5
   2d954:	b003      	add	sp, #12
   2d956:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2d958:	4605      	mov	r5, r0
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   2d95a:	2300      	movs	r3, #0
   2d95c:	9301      	str	r3, [sp, #4]
   2d95e:	9300      	str	r3, [sp, #0]
   2d960:	88a3      	ldrh	r3, [r4, #4]
   2d962:	68a2      	ldr	r2, [r4, #8]
   2d964:	4631      	mov	r1, r6
   2d966:	4638      	mov	r0, r7
   2d968:	f7ff ff07 	bl	2d77a <att_chan_read>
	if (ret < 0) {
   2d96c:	2800      	cmp	r0, #0
   2d96e:	db01      	blt.n	2d974 <read_cb+0x40>
	return BT_GATT_ITER_CONTINUE;
   2d970:	2501      	movs	r5, #1
   2d972:	e7ee      	b.n	2d952 <read_cb+0x1e>
		data->err = err_to_att(ret);
   2d974:	f7ff fdab 	bl	2d4ce <err_to_att>
   2d978:	7320      	strb	r0, [r4, #12]
		return BT_GATT_ITER_STOP;
   2d97a:	e7ea      	b.n	2d952 <read_cb+0x1e>

0002d97c <find_info_cb>:
{
   2d97c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2d980:	4606      	mov	r6, r0
   2d982:	460f      	mov	r7, r1
   2d984:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   2d986:	f8d2 8000 	ldr.w	r8, [r2]
	if (!data->rsp) {
   2d98a:	6893      	ldr	r3, [r2, #8]
   2d98c:	b14b      	cbz	r3, 2d9a2 <find_info_cb+0x26>
	switch (data->rsp->format) {
   2d98e:	68a3      	ldr	r3, [r4, #8]
   2d990:	781d      	ldrb	r5, [r3, #0]
   2d992:	2d01      	cmp	r5, #1
   2d994:	d013      	beq.n	2d9be <find_info_cb+0x42>
   2d996:	2d02      	cmp	r5, #2
   2d998:	d02d      	beq.n	2d9f6 <find_info_cb+0x7a>
   2d99a:	2500      	movs	r5, #0
}
   2d99c:	4628      	mov	r0, r5
   2d99e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2d9a2:	6850      	ldr	r0, [r2, #4]
   2d9a4:	2101      	movs	r1, #1
   2d9a6:	3008      	adds	r0, #8
   2d9a8:	f7f1 fbcc 	bl	1f144 <net_buf_simple_add>
   2d9ac:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   2d9ae:	6833      	ldr	r3, [r6, #0]
   2d9b0:	781b      	ldrb	r3, [r3, #0]
   2d9b2:	b913      	cbnz	r3, 2d9ba <find_info_cb+0x3e>
   2d9b4:	2301      	movs	r3, #1
   2d9b6:	7003      	strb	r3, [r0, #0]
   2d9b8:	e7e9      	b.n	2d98e <find_info_cb+0x12>
   2d9ba:	2302      	movs	r3, #2
   2d9bc:	e7fb      	b.n	2d9b6 <find_info_cb+0x3a>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   2d9be:	6833      	ldr	r3, [r6, #0]
   2d9c0:	f893 9000 	ldrb.w	r9, [r3]
   2d9c4:	f1b9 0f00 	cmp.w	r9, #0
   2d9c8:	d001      	beq.n	2d9ce <find_info_cb+0x52>
			return BT_GATT_ITER_STOP;
   2d9ca:	2500      	movs	r5, #0
   2d9cc:	e7e6      	b.n	2d99c <find_info_cb+0x20>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   2d9ce:	6860      	ldr	r0, [r4, #4]
   2d9d0:	2104      	movs	r1, #4
   2d9d2:	3008      	adds	r0, #8
   2d9d4:	f7f1 fbb6 	bl	1f144 <net_buf_simple_add>
   2d9d8:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(handle);
   2d9da:	8007      	strh	r7, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   2d9dc:	6832      	ldr	r2, [r6, #0]
   2d9de:	68e3      	ldr	r3, [r4, #12]
   2d9e0:	8852      	ldrh	r2, [r2, #2]
   2d9e2:	805a      	strh	r2, [r3, #2]
		if (chan->chan.tx.mtu - data->buf->len >
   2d9e4:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
   2d9e8:	6862      	ldr	r2, [r4, #4]
   2d9ea:	8992      	ldrh	r2, [r2, #12]
   2d9ec:	1a9b      	subs	r3, r3, r2
   2d9ee:	2b04      	cmp	r3, #4
   2d9f0:	d8d4      	bhi.n	2d99c <find_info_cb+0x20>
	return BT_GATT_ITER_STOP;
   2d9f2:	464d      	mov	r5, r9
   2d9f4:	e7d2      	b.n	2d99c <find_info_cb+0x20>
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   2d9f6:	6833      	ldr	r3, [r6, #0]
   2d9f8:	781b      	ldrb	r3, [r3, #0]
   2d9fa:	2b02      	cmp	r3, #2
   2d9fc:	d001      	beq.n	2da02 <find_info_cb+0x86>
			return BT_GATT_ITER_STOP;
   2d9fe:	2500      	movs	r5, #0
   2da00:	e7cc      	b.n	2d99c <find_info_cb+0x20>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   2da02:	6860      	ldr	r0, [r4, #4]
   2da04:	2112      	movs	r1, #18
   2da06:	3008      	adds	r0, #8
   2da08:	f7f1 fb9c 	bl	1f144 <net_buf_simple_add>
   2da0c:	60e0      	str	r0, [r4, #12]
		data->info128->handle = sys_cpu_to_le16(handle);
   2da0e:	8007      	strh	r7, [r0, #0]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   2da10:	68e3      	ldr	r3, [r4, #12]
   2da12:	6832      	ldr	r2, [r6, #0]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2da14:	f8d2 5001 	ldr.w	r5, [r2, #1]
   2da18:	f8d2 0005 	ldr.w	r0, [r2, #5]
   2da1c:	f8d2 1009 	ldr.w	r1, [r2, #9]
   2da20:	f8d2 200d 	ldr.w	r2, [r2, #13]
   2da24:	f8c3 5002 	str.w	r5, [r3, #2]
   2da28:	f8c3 0006 	str.w	r0, [r3, #6]
   2da2c:	f8c3 100a 	str.w	r1, [r3, #10]
   2da30:	f8c3 200e 	str.w	r2, [r3, #14]
		if (chan->chan.tx.mtu - data->buf->len >
   2da34:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
   2da38:	6862      	ldr	r2, [r4, #4]
   2da3a:	8992      	ldrh	r2, [r2, #12]
   2da3c:	1a9b      	subs	r3, r3, r2
   2da3e:	2b12      	cmp	r3, #18
   2da40:	d801      	bhi.n	2da46 <find_info_cb+0xca>
	return BT_GATT_ITER_STOP;
   2da42:	2500      	movs	r5, #0
   2da44:	e7aa      	b.n	2d99c <find_info_cb+0x20>
			return BT_GATT_ITER_CONTINUE;
   2da46:	2501      	movs	r5, #1
   2da48:	e7a8      	b.n	2d99c <find_info_cb+0x20>

0002da4a <bt_att_chan_send>:
{
   2da4a:	b508      	push	{r3, lr}
	return chan_send(chan, buf);
   2da4c:	f7ee fe04 	bl	1c658 <chan_send>
}
   2da50:	bd08      	pop	{r3, pc}

0002da52 <chan_req_send>:
{
   2da52:	b570      	push	{r4, r5, r6, lr}
   2da54:	4605      	mov	r5, r0
   2da56:	460c      	mov	r4, r1
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   2da58:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
   2da5a:	68a3      	ldr	r3, [r4, #8]
	size_t bytes = 0;
   2da5c:	2200      	movs	r2, #0
	while (buf) {
   2da5e:	e003      	b.n	2da68 <chan_req_send+0x16>
		bytes += buf->len;
   2da60:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
   2da64:	4462      	add	r2, ip
		buf = buf->frags;
   2da66:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   2da68:	2b00      	cmp	r3, #0
   2da6a:	d1f9      	bne.n	2da60 <chan_req_send+0xe>
   2da6c:	4291      	cmp	r1, r2
   2da6e:	d30d      	bcc.n	2da8c <chan_req_send+0x3a>
	chan->req = req;
   2da70:	f8c5 409c 	str.w	r4, [r5, #156]	; 0x9c
	buf = req->buf;
   2da74:	68a6      	ldr	r6, [r4, #8]
	req->buf = NULL;
   2da76:	60a3      	str	r3, [r4, #8]
	err = bt_att_chan_send(chan, buf);
   2da78:	4631      	mov	r1, r6
   2da7a:	4628      	mov	r0, r5
   2da7c:	f7ff ffe5 	bl	2da4a <bt_att_chan_send>
	if (err) {
   2da80:	b118      	cbz	r0, 2da8a <chan_req_send+0x38>
		req->buf = buf;
   2da82:	60a6      	str	r6, [r4, #8]
		chan->req = NULL;
   2da84:	2300      	movs	r3, #0
   2da86:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
}
   2da8a:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   2da8c:	f06f 0079 	mvn.w	r0, #121	; 0x79
   2da90:	e7fb      	b.n	2da8a <chan_req_send+0x38>

0002da92 <bt_att_status>:
{
   2da92:	b538      	push	{r3, r4, r5, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2da94:	f3bf 8f5b 	dmb	ish
   2da98:	680b      	ldr	r3, [r1, #0]
   2da9a:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   2da9e:	f013 0f01 	tst.w	r3, #1
   2daa2:	d007      	beq.n	2dab4 <bt_att_status+0x22>
   2daa4:	4604      	mov	r4, r0
   2daa6:	3804      	subs	r0, #4
	if (!chan->att) {
   2daa8:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2daac:	b113      	cbz	r3, 2dab4 <bt_att_status+0x22>
	if (chan->req) {
   2daae:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
   2dab2:	b102      	cbz	r2, 2dab6 <bt_att_status+0x24>
}
   2dab4:	bd38      	pop	{r3, r4, r5, pc}
	return list->head;
   2dab6:	685d      	ldr	r5, [r3, #4]
Z_GENLIST_GET(slist, snode)
   2dab8:	2d00      	cmp	r5, #0
   2daba:	d0fb      	beq.n	2dab4 <bt_att_status+0x22>
	return node->next;
   2dabc:	682a      	ldr	r2, [r5, #0]
	list->head = node;
   2dabe:	605a      	str	r2, [r3, #4]
	return list->tail;
   2dac0:	6899      	ldr	r1, [r3, #8]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2dac2:	428d      	cmp	r5, r1
   2dac4:	d00e      	beq.n	2dae4 <bt_att_status+0x52>
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   2dac6:	4629      	mov	r1, r5
   2dac8:	f7ee fe2e 	bl	1c728 <bt_att_chan_req_send>
   2dacc:	2800      	cmp	r0, #0
   2dace:	daf1      	bge.n	2dab4 <bt_att_status+0x22>
	sys_slist_prepend(&chan->att->reqs, node);
   2dad0:	f854 3c04 	ldr.w	r3, [r4, #-4]
	return list->head;
   2dad4:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   2dad6:	602a      	str	r2, [r5, #0]
	list->head = node;
   2dad8:	605d      	str	r5, [r3, #4]
	return list->tail;
   2dada:	689a      	ldr	r2, [r3, #8]
Z_GENLIST_PREPEND(slist, snode)
   2dadc:	2a00      	cmp	r2, #0
   2dade:	d1e9      	bne.n	2dab4 <bt_att_status+0x22>
	list->tail = node;
   2dae0:	609d      	str	r5, [r3, #8]
}
   2dae2:	e7e7      	b.n	2dab4 <bt_att_status+0x22>
	list->tail = node;
   2dae4:	609a      	str	r2, [r3, #8]
}
   2dae6:	e7ee      	b.n	2dac6 <bt_att_status+0x34>

0002dae8 <att_req_send_process>:
{
   2dae8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2daea:	4607      	mov	r7, r0
	return list->head;
   2daec:	6a85      	ldr	r5, [r0, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2daee:	b14d      	cbz	r5, 2db04 <att_req_send_process+0x1c>
   2daf0:	3df0      	subs	r5, #240	; 0xf0
   2daf2:	d00b      	beq.n	2db0c <att_req_send_process+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2daf4:	f115 04f0 	adds.w	r4, r5, #240	; 0xf0
   2daf8:	d005      	beq.n	2db06 <att_req_send_process+0x1e>
	return node->next;
   2dafa:	f8d5 40f0 	ldr.w	r4, [r5, #240]	; 0xf0
   2dafe:	b114      	cbz	r4, 2db06 <att_req_send_process+0x1e>
   2db00:	3cf0      	subs	r4, #240	; 0xf0
   2db02:	e000      	b.n	2db06 <att_req_send_process+0x1e>
   2db04:	462c      	mov	r4, r5
   2db06:	2200      	movs	r2, #0
   2db08:	4616      	mov	r6, r2
   2db0a:	e032      	b.n	2db72 <att_req_send_process+0x8a>
   2db0c:	462c      	mov	r4, r5
   2db0e:	e7fa      	b.n	2db06 <att_req_send_process+0x1e>
		if (!req && prev &&
   2db10:	b196      	cbz	r6, 2db38 <att_req_send_process+0x50>
		req = get_first_req_matching_chan(&att->reqs, chan);
   2db12:	4629      	mov	r1, r5
   2db14:	1d38      	adds	r0, r7, #4
   2db16:	f7ff fcc0 	bl	2d49a <get_first_req_matching_chan>
		if (!req) {
   2db1a:	4606      	mov	r6, r0
   2db1c:	b320      	cbz	r0, 2db68 <att_req_send_process+0x80>
		if (bt_att_chan_req_send(chan, req) >= 0) {
   2db1e:	4601      	mov	r1, r0
   2db20:	4628      	mov	r0, r5
   2db22:	f7ee fe01 	bl	1c728 <bt_att_chan_req_send>
   2db26:	2800      	cmp	r0, #0
   2db28:	da33      	bge.n	2db92 <att_req_send_process+0xaa>
	return list->head;
   2db2a:	687b      	ldr	r3, [r7, #4]
	parent->next = child;
   2db2c:	6033      	str	r3, [r6, #0]
	list->head = node;
   2db2e:	607e      	str	r6, [r7, #4]
	return list->tail;
   2db30:	68bb      	ldr	r3, [r7, #8]
Z_GENLIST_PREPEND(slist, snode)
   2db32:	b1b3      	cbz	r3, 2db62 <att_req_send_process+0x7a>
		prev = chan;
   2db34:	462a      	mov	r2, r5
   2db36:	e021      	b.n	2db7c <att_req_send_process+0x94>
		if (!req && prev &&
   2db38:	2a00      	cmp	r2, #0
   2db3a:	d0ea      	beq.n	2db12 <att_req_send_process+0x2a>
   2db3c:	f3bf 8f5b 	dmb	ish
   2db40:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   2db44:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2db48:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   2db4c:	f3bf 8f5b 	dmb	ish
   2db50:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
   2db54:	f3bf 8f5b 	dmb	ish
   2db58:	f3c1 01c0 	ubfx	r1, r1, #3, #1
   2db5c:	4299      	cmp	r1, r3
   2db5e:	d1d8      	bne.n	2db12 <att_req_send_process+0x2a>
   2db60:	e00c      	b.n	2db7c <att_req_send_process+0x94>
	list->tail = node;
   2db62:	60be      	str	r6, [r7, #8]
		prev = chan;
   2db64:	462a      	mov	r2, r5
}
   2db66:	e009      	b.n	2db7c <att_req_send_process+0x94>
   2db68:	462a      	mov	r2, r5
   2db6a:	e007      	b.n	2db7c <att_req_send_process+0x94>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2db6c:	4623      	mov	r3, r4
   2db6e:	4625      	mov	r5, r4
   2db70:	461c      	mov	r4, r3
   2db72:	b175      	cbz	r5, 2db92 <att_req_send_process+0xaa>
		if (chan->req) {
   2db74:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
   2db78:	2b00      	cmp	r3, #0
   2db7a:	d0c9      	beq.n	2db10 <att_req_send_process+0x28>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2db7c:	2c00      	cmp	r4, #0
   2db7e:	d0f5      	beq.n	2db6c <att_req_send_process+0x84>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2db80:	f114 03f0 	adds.w	r3, r4, #240	; 0xf0
   2db84:	d0f3      	beq.n	2db6e <att_req_send_process+0x86>
	return node->next;
   2db86:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
   2db8a:	2b00      	cmp	r3, #0
   2db8c:	d0ef      	beq.n	2db6e <att_req_send_process+0x86>
   2db8e:	3bf0      	subs	r3, #240	; 0xf0
   2db90:	e7ed      	b.n	2db6e <att_req_send_process+0x86>
}
   2db92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002db94 <process_queue>:
{
   2db94:	b570      	push	{r4, r5, r6, lr}
   2db96:	4604      	mov	r4, r0
   2db98:	460d      	mov	r5, r1
	buf = get_first_buf_matching_chan(queue, chan);
   2db9a:	4601      	mov	r1, r0
   2db9c:	4628      	mov	r0, r5
   2db9e:	f7ff fd5f 	bl	2d660 <get_first_buf_matching_chan>
	if (buf) {
   2dba2:	b168      	cbz	r0, 2dbc0 <process_queue+0x2c>
   2dba4:	4606      	mov	r6, r0
		err = bt_att_chan_send(chan, buf);
   2dba6:	4601      	mov	r1, r0
   2dba8:	4620      	mov	r0, r4
   2dbaa:	f7ff ff4e 	bl	2da4a <bt_att_chan_send>
		if (err) {
   2dbae:	4604      	mov	r4, r0
   2dbb0:	b908      	cbnz	r0, 2dbb6 <process_queue+0x22>
}
   2dbb2:	4620      	mov	r0, r4
   2dbb4:	bd70      	pop	{r4, r5, r6, pc}
			k_queue_prepend(&queue->_queue, buf);
   2dbb6:	4631      	mov	r1, r6
   2dbb8:	4628      	mov	r0, r5
   2dbba:	f002 ff29 	bl	30a10 <k_queue_prepend>
			return err;
   2dbbe:	e7f8      	b.n	2dbb2 <process_queue+0x1e>
	return -ENOENT;
   2dbc0:	f06f 0401 	mvn.w	r4, #1
   2dbc4:	e7f5      	b.n	2dbb2 <process_queue+0x1e>

0002dbc6 <bt_att_sent>:
{
   2dbc6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2dbc8:	4604      	mov	r4, r0
	struct bt_att_chan *chan = ATT_CHAN(ch);
   2dbca:	1f06      	subs	r6, r0, #4
	struct bt_att *att = chan->att;
   2dbcc:	f850 5c04 	ldr.w	r5, [r0, #-4]
	atomic_clear_bit(chan->flags, ATT_PENDING_SENT);
   2dbd0:	f100 0394 	add.w	r3, r0, #148	; 0x94
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2dbd4:	f3bf 8f5b 	dmb	ish
   2dbd8:	e853 2f00 	ldrex	r2, [r3]
   2dbdc:	f022 0210 	bic.w	r2, r2, #16
   2dbe0:	e843 2100 	strex	r1, r2, [r3]
   2dbe4:	2900      	cmp	r1, #0
   2dbe6:	d1f7      	bne.n	2dbd8 <bt_att_sent+0x12>
   2dbe8:	f3bf 8f5b 	dmb	ish
	if (!att) {
   2dbec:	b145      	cbz	r5, 2dc00 <bt_att_sent+0x3a>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   2dbee:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   2dbf2:	b133      	cbz	r3, 2dc02 <bt_att_sent+0x3c>
	err = process_queue(chan, &chan->tx_queue);
   2dbf4:	f104 019c 	add.w	r1, r4, #156	; 0x9c
   2dbf8:	4630      	mov	r0, r6
   2dbfa:	f7ff ffcb 	bl	2db94 <process_queue>
	if (!err) {
   2dbfe:	b9c0      	cbnz	r0, 2dc32 <bt_att_sent+0x6c>
}
   2dc00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return list->head;
   2dc02:	686f      	ldr	r7, [r5, #4]
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   2dc04:	2f00      	cmp	r7, #0
   2dc06:	d0f5      	beq.n	2dbf4 <bt_att_sent+0x2e>
	return node->next;
   2dc08:	683b      	ldr	r3, [r7, #0]
	list->head = node;
   2dc0a:	606b      	str	r3, [r5, #4]
	return list->tail;
   2dc0c:	68aa      	ldr	r2, [r5, #8]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2dc0e:	42ba      	cmp	r2, r7
   2dc10:	d00d      	beq.n	2dc2e <bt_att_sent+0x68>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   2dc12:	4639      	mov	r1, r7
   2dc14:	4630      	mov	r0, r6
   2dc16:	f7ff ff1c 	bl	2da52 <chan_req_send>
   2dc1a:	2800      	cmp	r0, #0
   2dc1c:	daf0      	bge.n	2dc00 <bt_att_sent+0x3a>
	return list->head;
   2dc1e:	686b      	ldr	r3, [r5, #4]
	parent->next = child;
   2dc20:	603b      	str	r3, [r7, #0]
	list->head = node;
   2dc22:	606f      	str	r7, [r5, #4]
	return list->tail;
   2dc24:	68ab      	ldr	r3, [r5, #8]
Z_GENLIST_PREPEND(slist, snode)
   2dc26:	2b00      	cmp	r3, #0
   2dc28:	d1e4      	bne.n	2dbf4 <bt_att_sent+0x2e>
	list->tail = node;
   2dc2a:	60af      	str	r7, [r5, #8]
}
   2dc2c:	e7e2      	b.n	2dbf4 <bt_att_sent+0x2e>
	list->tail = node;
   2dc2e:	60ab      	str	r3, [r5, #8]
}
   2dc30:	e7ef      	b.n	2dc12 <bt_att_sent+0x4c>
	(void)process_queue(chan, &att->tx_queue);
   2dc32:	f105 010c 	add.w	r1, r5, #12
   2dc36:	4630      	mov	r0, r6
   2dc38:	f7ff ffac 	bl	2db94 <process_queue>
   2dc3c:	e7e0      	b.n	2dc00 <bt_att_sent+0x3a>

0002dc3e <att_send_process>:
{
   2dc3e:	b570      	push	{r4, r5, r6, lr}
   2dc40:	4606      	mov	r6, r0
	return list->head;
   2dc42:	6a85      	ldr	r5, [r0, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2dc44:	b14d      	cbz	r5, 2dc5a <att_send_process+0x1c>
   2dc46:	3df0      	subs	r5, #240	; 0xf0
   2dc48:	d00b      	beq.n	2dc62 <att_send_process+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2dc4a:	f115 04f0 	adds.w	r4, r5, #240	; 0xf0
   2dc4e:	d005      	beq.n	2dc5c <att_send_process+0x1e>
	return node->next;
   2dc50:	f8d5 40f0 	ldr.w	r4, [r5, #240]	; 0xf0
   2dc54:	b114      	cbz	r4, 2dc5c <att_send_process+0x1e>
   2dc56:	3cf0      	subs	r4, #240	; 0xf0
   2dc58:	e000      	b.n	2dc5c <att_send_process+0x1e>
   2dc5a:	462c      	mov	r4, r5
   2dc5c:	2200      	movs	r2, #0
   2dc5e:	4611      	mov	r1, r2
   2dc60:	e013      	b.n	2dc8a <att_send_process+0x4c>
   2dc62:	462c      	mov	r4, r5
   2dc64:	e7fa      	b.n	2dc5c <att_send_process+0x1e>
		err = process_queue(chan, &att->tx_queue);
   2dc66:	f106 010c 	add.w	r1, r6, #12
   2dc6a:	4628      	mov	r0, r5
   2dc6c:	f7ff ff92 	bl	2db94 <process_queue>
		if (!err) {
   2dc70:	4602      	mov	r2, r0
   2dc72:	b330      	cbz	r0, 2dcc2 <att_send_process+0x84>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2dc74:	b31c      	cbz	r4, 2dcbe <att_send_process+0x80>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2dc76:	f114 03f0 	adds.w	r3, r4, #240	; 0xf0
   2dc7a:	d003      	beq.n	2dc84 <att_send_process+0x46>
	return node->next;
   2dc7c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
   2dc80:	b103      	cbz	r3, 2dc84 <att_send_process+0x46>
   2dc82:	3bf0      	subs	r3, #240	; 0xf0
   2dc84:	4629      	mov	r1, r5
   2dc86:	4625      	mov	r5, r4
   2dc88:	461c      	mov	r4, r3
   2dc8a:	b1d5      	cbz	r5, 2dcc2 <att_send_process+0x84>
		if (err == -ENOENT && prev &&
   2dc8c:	f112 0f02 	cmn.w	r2, #2
   2dc90:	d1e9      	bne.n	2dc66 <att_send_process+0x28>
   2dc92:	2900      	cmp	r1, #0
   2dc94:	d0e7      	beq.n	2dc66 <att_send_process+0x28>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2dc96:	f3bf 8f5b 	dmb	ish
   2dc9a:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   2dc9e:	f3bf 8f5b 	dmb	ish
   2dca2:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   2dca6:	f3bf 8f5b 	dmb	ish
   2dcaa:	f8d1 0098 	ldr.w	r0, [r1, #152]	; 0x98
   2dcae:	f3bf 8f5b 	dmb	ish
   2dcb2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   2dcb6:	4298      	cmp	r0, r3
   2dcb8:	d1d5      	bne.n	2dc66 <att_send_process+0x28>
   2dcba:	460d      	mov	r5, r1
   2dcbc:	e7da      	b.n	2dc74 <att_send_process+0x36>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2dcbe:	4623      	mov	r3, r4
   2dcc0:	e7e0      	b.n	2dc84 <att_send_process+0x46>
}
   2dcc2:	bd70      	pop	{r4, r5, r6, pc}

0002dcc4 <bt_att_chan_send_rsp>:
{
   2dcc4:	b538      	push	{r3, r4, r5, lr}
   2dcc6:	4604      	mov	r4, r0
   2dcc8:	460d      	mov	r5, r1
	err = chan_send(chan, buf);
   2dcca:	f7ee fcc5 	bl	1c658 <chan_send>
	if (err) {
   2dcce:	b900      	cbnz	r0, 2dcd2 <bt_att_chan_send_rsp+0xe>
}
   2dcd0:	bd38      	pop	{r3, r4, r5, pc}
		net_buf_put(&chan->tx_queue, buf);
   2dcd2:	4629      	mov	r1, r5
   2dcd4:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
   2dcd8:	f7f1 f8ea 	bl	1eeb0 <net_buf_put>
}
   2dcdc:	e7f8      	b.n	2dcd0 <bt_att_chan_send_rsp+0xc>

0002dcde <att_sent>:
{
   2dcde:	b508      	push	{r3, lr}
	struct bt_att_chan *att_chan = data->att_chan;
   2dce0:	680b      	ldr	r3, [r1, #0]
	struct bt_l2cap_chan *chan = &att_chan->chan.chan;
   2dce2:	1d18      	adds	r0, r3, #4
	if (chan->ops->sent) {
   2dce4:	689b      	ldr	r3, [r3, #8]
   2dce6:	695b      	ldr	r3, [r3, #20]
   2dce8:	b103      	cbz	r3, 2dcec <att_sent+0xe>
		chan->ops->sent(chan);
   2dcea:	4798      	blx	r3
}
   2dcec:	bd08      	pop	{r3, pc}

0002dcee <att_unknown>:
{
   2dcee:	b570      	push	{r4, r5, r6, lr}
   2dcf0:	4604      	mov	r4, r0
   2dcf2:	460d      	mov	r5, r1
	if (!err) {
   2dcf4:	4616      	mov	r6, r2
   2dcf6:	b12a      	cbz	r2, 2dd04 <att_unknown+0x16>
	chan_unknown(conn, user_data, err);
   2dcf8:	4632      	mov	r2, r6
   2dcfa:	4629      	mov	r1, r5
   2dcfc:	4620      	mov	r0, r4
   2dcfe:	f7ee fbcf 	bl	1c4a0 <chan_unknown>
}
   2dd02:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   2dd04:	f7ff ffeb 	bl	2dcde <att_sent>
   2dd08:	e7f6      	b.n	2dcf8 <att_unknown+0xa>

0002dd0a <att_tx_complete>:
{
   2dd0a:	b570      	push	{r4, r5, r6, lr}
   2dd0c:	4604      	mov	r4, r0
   2dd0e:	460d      	mov	r5, r1
	if (!err) {
   2dd10:	4616      	mov	r6, r2
   2dd12:	b12a      	cbz	r2, 2dd20 <att_tx_complete+0x16>
	chan_tx_complete(conn, user_data, err);
   2dd14:	4632      	mov	r2, r6
   2dd16:	4629      	mov	r1, r5
   2dd18:	4620      	mov	r0, r4
   2dd1a:	f7ee fc67 	bl	1c5ec <chan_tx_complete>
}
   2dd1e:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   2dd20:	f7ff ffdd 	bl	2dcde <att_sent>
   2dd24:	e7f6      	b.n	2dd14 <att_tx_complete+0xa>

0002dd26 <att_req_sent>:
{
   2dd26:	b570      	push	{r4, r5, r6, lr}
   2dd28:	4604      	mov	r4, r0
   2dd2a:	460d      	mov	r5, r1
	if (!err) {
   2dd2c:	4616      	mov	r6, r2
   2dd2e:	b12a      	cbz	r2, 2dd3c <att_req_sent+0x16>
	chan_req_sent(conn, user_data, err);
   2dd30:	4632      	mov	r2, r6
   2dd32:	4629      	mov	r1, r5
   2dd34:	4620      	mov	r0, r4
   2dd36:	f7ee fc2f 	bl	1c598 <chan_req_sent>
}
   2dd3a:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   2dd3c:	f7ff ffcf 	bl	2dcde <att_sent>
   2dd40:	e7f6      	b.n	2dd30 <att_req_sent+0xa>

0002dd42 <att_cfm_sent>:
{
   2dd42:	b570      	push	{r4, r5, r6, lr}
   2dd44:	4604      	mov	r4, r0
   2dd46:	460d      	mov	r5, r1
	if (!err) {
   2dd48:	4616      	mov	r6, r2
   2dd4a:	b12a      	cbz	r2, 2dd58 <att_cfm_sent+0x16>
	chan_cfm_sent(conn, user_data, err);
   2dd4c:	4632      	mov	r2, r6
   2dd4e:	4629      	mov	r1, r5
   2dd50:	4620      	mov	r0, r4
   2dd52:	f7ee fbc5 	bl	1c4e0 <chan_cfm_sent>
}
   2dd56:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   2dd58:	f7ff ffc1 	bl	2dcde <att_sent>
   2dd5c:	e7f6      	b.n	2dd4c <att_cfm_sent+0xa>

0002dd5e <att_rsp_sent>:
{
   2dd5e:	b570      	push	{r4, r5, r6, lr}
   2dd60:	4604      	mov	r4, r0
   2dd62:	460d      	mov	r5, r1
	if (!err) {
   2dd64:	4616      	mov	r6, r2
   2dd66:	b12a      	cbz	r2, 2dd74 <att_rsp_sent+0x16>
	chan_rsp_sent(conn, user_data, err);
   2dd68:	4632      	mov	r2, r6
   2dd6a:	4629      	mov	r1, r5
   2dd6c:	4620      	mov	r0, r4
   2dd6e:	f7ee fbe5 	bl	1c53c <chan_rsp_sent>
}
   2dd72:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   2dd74:	f7ff ffb3 	bl	2dcde <att_sent>
   2dd78:	e7f6      	b.n	2dd68 <att_rsp_sent+0xa>

0002dd7a <att_indicate>:
{
   2dd7a:	b538      	push	{r3, r4, r5, lr}
   2dd7c:	4605      	mov	r5, r0
   2dd7e:	460c      	mov	r4, r1
	return net_buf_simple_pull_le16(&buf->b);
   2dd80:	f101 0008 	add.w	r0, r1, #8
   2dd84:	f001 f89f 	bl	2eec6 <net_buf_simple_pull_le16>
   2dd88:	4601      	mov	r1, r0
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   2dd8a:	89a3      	ldrh	r3, [r4, #12]
   2dd8c:	68a2      	ldr	r2, [r4, #8]
   2dd8e:	6828      	ldr	r0, [r5, #0]
   2dd90:	6800      	ldr	r0, [r0, #0]
   2dd92:	f000 ff71 	bl	2ec78 <bt_gatt_notification>
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_CONFIRM, 0);
   2dd96:	2200      	movs	r2, #0
   2dd98:	211e      	movs	r1, #30
   2dd9a:	4628      	mov	r0, r5
   2dd9c:	f7ee fd0a 	bl	1c7b4 <bt_att_chan_create_pdu>
	if (!buf) {
   2dda0:	b118      	cbz	r0, 2ddaa <att_indicate+0x30>
   2dda2:	4601      	mov	r1, r0
	bt_att_chan_send_rsp(chan, buf);
   2dda4:	4628      	mov	r0, r5
   2dda6:	f7ff ff8d 	bl	2dcc4 <bt_att_chan_send_rsp>
}
   2ddaa:	2000      	movs	r0, #0
   2ddac:	bd38      	pop	{r3, r4, r5, pc}

0002ddae <send_err_rsp>:
	if (!req) {
   2ddae:	b901      	cbnz	r1, 2ddb2 <send_err_rsp+0x4>
   2ddb0:	4770      	bx	lr
{
   2ddb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ddb6:	4606      	mov	r6, r0
   2ddb8:	4615      	mov	r5, r2
   2ddba:	461c      	mov	r4, r3
   2ddbc:	460f      	mov	r7, r1
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   2ddbe:	2204      	movs	r2, #4
   2ddc0:	2101      	movs	r1, #1
   2ddc2:	f7ee fcf7 	bl	1c7b4 <bt_att_chan_create_pdu>
	if (!buf) {
   2ddc6:	4680      	mov	r8, r0
   2ddc8:	b158      	cbz	r0, 2dde2 <send_err_rsp+0x34>
	return net_buf_simple_add(&buf->b, len);
   2ddca:	2104      	movs	r1, #4
   2ddcc:	3008      	adds	r0, #8
   2ddce:	f7f1 f9b9 	bl	1f144 <net_buf_simple_add>
	rsp->request = req;
   2ddd2:	7007      	strb	r7, [r0, #0]
	rsp->handle = sys_cpu_to_le16(handle);
   2ddd4:	f8a0 5001 	strh.w	r5, [r0, #1]
	rsp->error = err;
   2ddd8:	70c4      	strb	r4, [r0, #3]
	bt_att_chan_send_rsp(chan, buf);
   2ddda:	4641      	mov	r1, r8
   2dddc:	4630      	mov	r0, r6
   2ddde:	f7ff ff71 	bl	2dcc4 <bt_att_chan_send_rsp>
}
   2dde2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002dde6 <att_write_cmd>:
{
   2dde6:	b530      	push	{r4, r5, lr}
   2dde8:	b085      	sub	sp, #20
   2ddea:	4605      	mov	r5, r0
   2ddec:	460c      	mov	r4, r1
	return net_buf_simple_pull_le16(&buf->b);
   2ddee:	f101 0008 	add.w	r0, r1, #8
   2ddf2:	f001 f868 	bl	2eec6 <net_buf_simple_pull_le16>
   2ddf6:	4603      	mov	r3, r0
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
   2ddf8:	68a2      	ldr	r2, [r4, #8]
   2ddfa:	89a1      	ldrh	r1, [r4, #12]
   2ddfc:	9102      	str	r1, [sp, #8]
   2ddfe:	9201      	str	r2, [sp, #4]
   2de00:	2100      	movs	r1, #0
   2de02:	9100      	str	r1, [sp, #0]
   2de04:	460a      	mov	r2, r1
   2de06:	4628      	mov	r0, r5
   2de08:	f7ee fdba 	bl	1c980 <att_write_rsp>
}
   2de0c:	b005      	add	sp, #20
   2de0e:	bd30      	pop	{r4, r5, pc}

0002de10 <att_write_req>:
{
   2de10:	b530      	push	{r4, r5, lr}
   2de12:	b085      	sub	sp, #20
   2de14:	4605      	mov	r5, r0
   2de16:	460c      	mov	r4, r1
   2de18:	f101 0008 	add.w	r0, r1, #8
   2de1c:	f001 f853 	bl	2eec6 <net_buf_simple_pull_le16>
   2de20:	4603      	mov	r3, r0
			     handle, 0, buf->data, buf->len);
   2de22:	68a2      	ldr	r2, [r4, #8]
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   2de24:	89a1      	ldrh	r1, [r4, #12]
   2de26:	9102      	str	r1, [sp, #8]
   2de28:	9201      	str	r2, [sp, #4]
   2de2a:	2200      	movs	r2, #0
   2de2c:	9200      	str	r2, [sp, #0]
   2de2e:	2213      	movs	r2, #19
   2de30:	2112      	movs	r1, #18
   2de32:	4628      	mov	r0, r5
   2de34:	f7ee fda4 	bl	1c980 <att_write_rsp>
}
   2de38:	b005      	add	sp, #20
   2de3a:	bd30      	pop	{r4, r5, pc}

0002de3c <att_read_group_req>:
{
   2de3c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2de3e:	b089      	sub	sp, #36	; 0x24
   2de40:	4605      	mov	r5, r0
   2de42:	4608      	mov	r0, r1
	uint8_t uuid_len = buf->len - sizeof(*req);
   2de44:	7b0c      	ldrb	r4, [r1, #12]
   2de46:	3c04      	subs	r4, #4
   2de48:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
   2de4a:	2c02      	cmp	r4, #2
   2de4c:	d001      	beq.n	2de52 <att_read_group_req+0x16>
   2de4e:	2c10      	cmp	r4, #16
   2de50:	d142      	bne.n	2ded8 <att_read_group_req+0x9c>
	return net_buf_simple_pull_mem(&buf->b, len);
   2de52:	2104      	movs	r1, #4
   2de54:	3008      	adds	r0, #8
   2de56:	f7f1 f935 	bl	1f0c4 <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   2de5a:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   2de5c:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   2de5e:	4622      	mov	r2, r4
   2de60:	1d01      	adds	r1, r0, #4
   2de62:	a801      	add	r0, sp, #4
   2de64:	f7fe fda8 	bl	2c9b8 <bt_uuid_create>
   2de68:	b3c8      	cbz	r0, 2dede <att_read_group_req+0xa2>
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   2de6a:	f10d 0216 	add.w	r2, sp, #22
   2de6e:	4639      	mov	r1, r7
   2de70:	4630      	mov	r0, r6
   2de72:	f7ff fb1d 	bl	2d4b0 <range_is_valid>
   2de76:	b1f0      	cbz	r0, 2deb6 <att_read_group_req+0x7a>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   2de78:	2300      	movs	r3, #0
   2de7a:	f88d 3018 	strb.w	r3, [sp, #24]
   2de7e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   2de82:	f8ad 301a 	strh.w	r3, [sp, #26]
   2de86:	a906      	add	r1, sp, #24
   2de88:	a801      	add	r0, sp, #4
   2de8a:	f7fe fd77 	bl	2c97c <bt_uuid_cmp>
   2de8e:	b158      	cbz	r0, 2dea8 <att_read_group_req+0x6c>
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
   2de90:	2300      	movs	r3, #0
   2de92:	f88d 301c 	strb.w	r3, [sp, #28]
   2de96:	f642 0301 	movw	r3, #10241	; 0x2801
   2de9a:	f8ad 301e 	strh.w	r3, [sp, #30]
   2de9e:	a907      	add	r1, sp, #28
   2dea0:	a801      	add	r0, sp, #4
   2dea2:	f7fe fd6b 	bl	2c97c <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   2dea6:	b978      	cbnz	r0, 2dec8 <att_read_group_req+0x8c>
	return att_read_group_rsp(chan, &u.uuid, start_handle, end_handle);
   2dea8:	463b      	mov	r3, r7
   2deaa:	4632      	mov	r2, r6
   2deac:	a901      	add	r1, sp, #4
   2deae:	4628      	mov	r0, r5
   2deb0:	f7ee fe36 	bl	1cb20 <att_read_group_rsp>
   2deb4:	e011      	b.n	2deda <att_read_group_req+0x9e>
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, err_handle,
   2deb6:	2301      	movs	r3, #1
   2deb8:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   2debc:	2110      	movs	r1, #16
   2debe:	4628      	mov	r0, r5
   2dec0:	f7ff ff75 	bl	2ddae <send_err_rsp>
		return 0;
   2dec4:	2000      	movs	r0, #0
   2dec6:	e008      	b.n	2deda <att_read_group_req+0x9e>
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, start_handle,
   2dec8:	2310      	movs	r3, #16
   2deca:	4632      	mov	r2, r6
   2decc:	4619      	mov	r1, r3
   2dece:	4628      	mov	r0, r5
   2ded0:	f7ff ff6d 	bl	2ddae <send_err_rsp>
		return 0;
   2ded4:	2000      	movs	r0, #0
   2ded6:	e000      	b.n	2deda <att_read_group_req+0x9e>
		return BT_ATT_ERR_INVALID_PDU;
   2ded8:	2004      	movs	r0, #4
}
   2deda:	b009      	add	sp, #36	; 0x24
   2dedc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_ATT_ERR_UNLIKELY;
   2dede:	200e      	movs	r0, #14
   2dee0:	e7fb      	b.n	2deda <att_read_group_req+0x9e>

0002dee2 <att_read_blob_req>:
{
   2dee2:	b500      	push	{lr}
   2dee4:	b083      	sub	sp, #12
	req = (void *)buf->data;
   2dee6:	688a      	ldr	r2, [r1, #8]
	handle = sys_le16_to_cpu(req->handle);
   2dee8:	8813      	ldrh	r3, [r2, #0]
	offset = sys_le16_to_cpu(req->offset);
   2deea:	8852      	ldrh	r2, [r2, #2]
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
   2deec:	9200      	str	r2, [sp, #0]
   2deee:	220d      	movs	r2, #13
   2def0:	210c      	movs	r1, #12
   2def2:	f7ee ff6d 	bl	1cdd0 <att_read_rsp>
}
   2def6:	b003      	add	sp, #12
   2def8:	f85d fb04 	ldr.w	pc, [sp], #4

0002defc <att_read_req>:
{
   2defc:	b500      	push	{lr}
   2defe:	b083      	sub	sp, #12
	req = (void *)buf->data;
   2df00:	688b      	ldr	r3, [r1, #8]
	handle = sys_le16_to_cpu(req->handle);
   2df02:	881b      	ldrh	r3, [r3, #0]
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   2df04:	2200      	movs	r2, #0
   2df06:	9200      	str	r2, [sp, #0]
   2df08:	220b      	movs	r2, #11
   2df0a:	210a      	movs	r1, #10
   2df0c:	f7ee ff60 	bl	1cdd0 <att_read_rsp>
}
   2df10:	b003      	add	sp, #12
   2df12:	f85d fb04 	ldr.w	pc, [sp], #4

0002df16 <att_read_type_req>:
{
   2df16:	b5f0      	push	{r4, r5, r6, r7, lr}
   2df18:	b087      	sub	sp, #28
   2df1a:	4605      	mov	r5, r0
   2df1c:	4608      	mov	r0, r1
	uint8_t uuid_len = buf->len - sizeof(*req);
   2df1e:	7b0c      	ldrb	r4, [r1, #12]
   2df20:	3c04      	subs	r4, #4
   2df22:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
   2df24:	2c02      	cmp	r4, #2
   2df26:	d001      	beq.n	2df2c <att_read_type_req+0x16>
   2df28:	2c10      	cmp	r4, #16
   2df2a:	d123      	bne.n	2df74 <att_read_type_req+0x5e>
   2df2c:	2104      	movs	r1, #4
   2df2e:	3008      	adds	r0, #8
   2df30:	f7f1 f8c8 	bl	1f0c4 <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   2df34:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   2df36:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   2df38:	4622      	mov	r2, r4
   2df3a:	1d01      	adds	r1, r0, #4
   2df3c:	a801      	add	r0, sp, #4
   2df3e:	f7fe fd3b 	bl	2c9b8 <bt_uuid_create>
   2df42:	b1c8      	cbz	r0, 2df78 <att_read_type_req+0x62>
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   2df44:	f10d 0216 	add.w	r2, sp, #22
   2df48:	4639      	mov	r1, r7
   2df4a:	4630      	mov	r0, r6
   2df4c:	f7ff fab0 	bl	2d4b0 <range_is_valid>
   2df50:	b138      	cbz	r0, 2df62 <att_read_type_req+0x4c>
	return att_read_type_rsp(chan, &u.uuid, start_handle, end_handle);
   2df52:	463b      	mov	r3, r7
   2df54:	4632      	mov	r2, r6
   2df56:	a901      	add	r1, sp, #4
   2df58:	4628      	mov	r0, r5
   2df5a:	f7ee ffbd 	bl	1ced8 <att_read_type_rsp>
}
   2df5e:	b007      	add	sp, #28
   2df60:	bdf0      	pop	{r4, r5, r6, r7, pc}
		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, err_handle,
   2df62:	2301      	movs	r3, #1
   2df64:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   2df68:	2108      	movs	r1, #8
   2df6a:	4628      	mov	r0, r5
   2df6c:	f7ff ff1f 	bl	2ddae <send_err_rsp>
		return 0;
   2df70:	2000      	movs	r0, #0
   2df72:	e7f4      	b.n	2df5e <att_read_type_req+0x48>
		return BT_ATT_ERR_INVALID_PDU;
   2df74:	2004      	movs	r0, #4
   2df76:	e7f2      	b.n	2df5e <att_read_type_req+0x48>
		return BT_ATT_ERR_UNLIKELY;
   2df78:	200e      	movs	r0, #14
   2df7a:	e7f0      	b.n	2df5e <att_read_type_req+0x48>

0002df7c <att_find_type_req>:
{
   2df7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2df80:	b087      	sub	sp, #28
   2df82:	4607      	mov	r7, r0
   2df84:	460c      	mov	r4, r1
   2df86:	2106      	movs	r1, #6
   2df88:	f104 0008 	add.w	r0, r4, #8
   2df8c:	f7f1 f89a 	bl	1f0c4 <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   2df90:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   2df92:	8846      	ldrh	r6, [r0, #2]
	type = sys_le16_to_cpu(req->type);
   2df94:	f8b0 8004 	ldrh.w	r8, [r0, #4]
	value = buf->data;
   2df98:	f8d4 9008 	ldr.w	r9, [r4, #8]
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   2df9c:	f10d 020e 	add.w	r2, sp, #14
   2dfa0:	4631      	mov	r1, r6
   2dfa2:	4628      	mov	r0, r5
   2dfa4:	f7ff fa84 	bl	2d4b0 <range_is_valid>
   2dfa8:	b1d0      	cbz	r0, 2dfe0 <att_find_type_req+0x64>
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   2dfaa:	2300      	movs	r3, #0
   2dfac:	f88d 3010 	strb.w	r3, [sp, #16]
   2dfb0:	f8ad 8012 	strh.w	r8, [sp, #18]
   2dfb4:	f88d 3014 	strb.w	r3, [sp, #20]
   2dfb8:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   2dfbc:	f8ad 3016 	strh.w	r3, [sp, #22]
   2dfc0:	a905      	add	r1, sp, #20
   2dfc2:	a804      	add	r0, sp, #16
   2dfc4:	f7fe fcda 	bl	2c97c <bt_uuid_cmp>
   2dfc8:	b998      	cbnz	r0, 2dff2 <att_find_type_req+0x76>
	return att_find_type_rsp(chan, start_handle, end_handle, value,
   2dfca:	7b23      	ldrb	r3, [r4, #12]
   2dfcc:	9300      	str	r3, [sp, #0]
   2dfce:	464b      	mov	r3, r9
   2dfd0:	4632      	mov	r2, r6
   2dfd2:	4629      	mov	r1, r5
   2dfd4:	4638      	mov	r0, r7
   2dfd6:	f7ee ffe5 	bl	1cfa4 <att_find_type_rsp>
}
   2dfda:	b007      	add	sp, #28
   2dfdc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, err_handle,
   2dfe0:	2301      	movs	r3, #1
   2dfe2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   2dfe6:	2106      	movs	r1, #6
   2dfe8:	4638      	mov	r0, r7
   2dfea:	f7ff fee0 	bl	2ddae <send_err_rsp>
		return 0;
   2dfee:	2000      	movs	r0, #0
   2dff0:	e7f3      	b.n	2dfda <att_find_type_req+0x5e>
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle,
   2dff2:	230a      	movs	r3, #10
   2dff4:	462a      	mov	r2, r5
   2dff6:	2106      	movs	r1, #6
   2dff8:	4638      	mov	r0, r7
   2dffa:	f7ff fed8 	bl	2ddae <send_err_rsp>
		return 0;
   2dffe:	2000      	movs	r0, #0
   2e000:	e7eb      	b.n	2dfda <att_find_type_req+0x5e>

0002e002 <att_find_info_req>:
{
   2e002:	b570      	push	{r4, r5, r6, lr}
   2e004:	b082      	sub	sp, #8
   2e006:	4604      	mov	r4, r0
	req = (void *)buf->data;
   2e008:	688b      	ldr	r3, [r1, #8]
	start_handle = sys_le16_to_cpu(req->start_handle);
   2e00a:	881d      	ldrh	r5, [r3, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   2e00c:	885e      	ldrh	r6, [r3, #2]
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   2e00e:	f10d 0206 	add.w	r2, sp, #6
   2e012:	4631      	mov	r1, r6
   2e014:	4628      	mov	r0, r5
   2e016:	f7ff fa4b 	bl	2d4b0 <range_is_valid>
   2e01a:	b130      	cbz	r0, 2e02a <att_find_info_req+0x28>
	return att_find_info_rsp(chan, start_handle, end_handle);
   2e01c:	4632      	mov	r2, r6
   2e01e:	4629      	mov	r1, r5
   2e020:	4620      	mov	r0, r4
   2e022:	f7ef f81f 	bl	1d064 <att_find_info_rsp>
}
   2e026:	b002      	add	sp, #8
   2e028:	bd70      	pop	{r4, r5, r6, pc}
		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, err_handle,
   2e02a:	2301      	movs	r3, #1
   2e02c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   2e030:	2104      	movs	r1, #4
   2e032:	4620      	mov	r0, r4
   2e034:	f7ff febb 	bl	2ddae <send_err_rsp>
		return 0;
   2e038:	2000      	movs	r0, #0
   2e03a:	e7f4      	b.n	2e026 <att_find_info_req+0x24>

0002e03c <att_mtu_req>:
{
   2e03c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->att->conn;
   2e040:	6803      	ldr	r3, [r0, #0]
   2e042:	681f      	ldr	r7, [r3, #0]
   2e044:	f3bf 8f5b 	dmb	ish
   2e048:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
   2e04c:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   2e050:	f013 0f08 	tst.w	r3, #8
   2e054:	d12f      	bne.n	2e0b6 <att_mtu_req+0x7a>
   2e056:	4604      	mov	r4, r0
	req = (void *)buf->data;
   2e058:	688b      	ldr	r3, [r1, #8]
	mtu_client = sys_le16_to_cpu(req->mtu);
   2e05a:	881e      	ldrh	r6, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   2e05c:	2e16      	cmp	r6, #22
   2e05e:	d92c      	bls.n	2e0ba <att_mtu_req+0x7e>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   2e060:	2202      	movs	r2, #2
   2e062:	2103      	movs	r1, #3
   2e064:	4638      	mov	r0, r7
   2e066:	f7ee fd21 	bl	1caac <bt_att_create_pdu>
	if (!pdu) {
   2e06a:	4680      	mov	r8, r0
   2e06c:	b338      	cbz	r0, 2e0be <att_mtu_req+0x82>
	return net_buf_simple_add(&buf->b, len);
   2e06e:	2102      	movs	r1, #2
   2e070:	3008      	adds	r0, #8
   2e072:	f7f1 f867 	bl	1f144 <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   2e076:	2500      	movs	r5, #0
   2e078:	2317      	movs	r3, #23
   2e07a:	7003      	strb	r3, [r0, #0]
   2e07c:	7045      	strb	r5, [r0, #1]
	bt_att_chan_send_rsp(chan, pdu);
   2e07e:	4641      	mov	r1, r8
   2e080:	4620      	mov	r0, r4
   2e082:	f7ff fe1f 	bl	2dcc4 <bt_att_chan_send_rsp>
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   2e086:	2e17      	cmp	r6, #23
   2e088:	bf28      	it	cs
   2e08a:	2617      	movcs	r6, #23
   2e08c:	8366      	strh	r6, [r4, #26]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   2e08e:	8566      	strh	r6, [r4, #42]	; 0x2a
	atomic_set_bit(conn->flags, BT_CONN_ATT_MTU_EXCHANGED);
   2e090:	3704      	adds	r7, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2e092:	f3bf 8f5b 	dmb	ish
   2e096:	e857 3f00 	ldrex	r3, [r7]
   2e09a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   2e09e:	e847 3200 	strex	r2, r3, [r7]
   2e0a2:	2a00      	cmp	r2, #0
   2e0a4:	d1f7      	bne.n	2e096 <att_mtu_req+0x5a>
   2e0a6:	f3bf 8f5b 	dmb	ish
	att_chan_mtu_updated(chan);
   2e0aa:	4620      	mov	r0, r4
   2e0ac:	f7ff faf7 	bl	2d69e <att_chan_mtu_updated>
	return 0;
   2e0b0:	4628      	mov	r0, r5
}
   2e0b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_NOT_SUPPORTED;
   2e0b6:	2006      	movs	r0, #6
   2e0b8:	e7fb      	b.n	2e0b2 <att_mtu_req+0x76>
		return BT_ATT_ERR_INVALID_PDU;
   2e0ba:	2004      	movs	r0, #4
   2e0bc:	e7f9      	b.n	2e0b2 <att_mtu_req+0x76>
		return BT_ATT_ERR_UNLIKELY;
   2e0be:	200e      	movs	r0, #14
   2e0c0:	e7f7      	b.n	2e0b2 <att_mtu_req+0x76>

0002e0c2 <bt_att_get_mtu>:
{
   2e0c2:	b508      	push	{r3, lr}
	att = att_get(conn);
   2e0c4:	f7ee f9b6 	bl	1c434 <att_get>
	if (!att) {
   2e0c8:	b318      	cbz	r0, 2e112 <bt_att_get_mtu+0x50>
	return list->head;
   2e0ca:	6a81      	ldr	r1, [r0, #40]	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2e0cc:	b149      	cbz	r1, 2e0e2 <bt_att_get_mtu+0x20>
   2e0ce:	39f0      	subs	r1, #240	; 0xf0
   2e0d0:	d00a      	beq.n	2e0e8 <bt_att_get_mtu+0x26>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e0d2:	f111 03f0 	adds.w	r3, r1, #240	; 0xf0
   2e0d6:	d005      	beq.n	2e0e4 <bt_att_get_mtu+0x22>
	return node->next;
   2e0d8:	f8d1 30f0 	ldr.w	r3, [r1, #240]	; 0xf0
   2e0dc:	b113      	cbz	r3, 2e0e4 <bt_att_get_mtu+0x22>
   2e0de:	3bf0      	subs	r3, #240	; 0xf0
   2e0e0:	e000      	b.n	2e0e4 <bt_att_get_mtu+0x22>
   2e0e2:	460b      	mov	r3, r1
   2e0e4:	2000      	movs	r0, #0
   2e0e6:	e004      	b.n	2e0f2 <bt_att_get_mtu+0x30>
   2e0e8:	460b      	mov	r3, r1
   2e0ea:	e7fb      	b.n	2e0e4 <bt_att_get_mtu+0x22>
   2e0ec:	461a      	mov	r2, r3
   2e0ee:	4619      	mov	r1, r3
   2e0f0:	4613      	mov	r3, r2
   2e0f2:	b179      	cbz	r1, 2e114 <bt_att_get_mtu+0x52>
		if (chan->chan.tx.mtu > mtu) {
   2e0f4:	8d4a      	ldrh	r2, [r1, #42]	; 0x2a
   2e0f6:	4282      	cmp	r2, r0
   2e0f8:	d900      	bls.n	2e0fc <bt_att_get_mtu+0x3a>
			mtu = chan->chan.tx.mtu;
   2e0fa:	4610      	mov	r0, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2e0fc:	2b00      	cmp	r3, #0
   2e0fe:	d0f5      	beq.n	2e0ec <bt_att_get_mtu+0x2a>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e100:	f113 02f0 	adds.w	r2, r3, #240	; 0xf0
   2e104:	d0f3      	beq.n	2e0ee <bt_att_get_mtu+0x2c>
	return node->next;
   2e106:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   2e10a:	2a00      	cmp	r2, #0
   2e10c:	d0ef      	beq.n	2e0ee <bt_att_get_mtu+0x2c>
   2e10e:	3af0      	subs	r2, #240	; 0xf0
   2e110:	e7ed      	b.n	2e0ee <bt_att_get_mtu+0x2c>
		return 0;
   2e112:	2000      	movs	r0, #0
}
   2e114:	bd08      	pop	{r3, pc}

0002e116 <att_handle_exec_write_rsp>:
{
   2e116:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e118:	2300      	movs	r3, #0
   2e11a:	898a      	ldrh	r2, [r1, #12]
   2e11c:	6889      	ldr	r1, [r1, #8]
   2e11e:	f7ef f861 	bl	1d1e4 <att_handle_rsp>
}
   2e122:	bd08      	pop	{r3, pc}

0002e124 <att_handle_prepare_write_rsp>:
{
   2e124:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e126:	2300      	movs	r3, #0
   2e128:	898a      	ldrh	r2, [r1, #12]
   2e12a:	6889      	ldr	r1, [r1, #8]
   2e12c:	f7ef f85a 	bl	1d1e4 <att_handle_rsp>
}
   2e130:	bd08      	pop	{r3, pc}

0002e132 <att_handle_write_rsp>:
{
   2e132:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e134:	2300      	movs	r3, #0
   2e136:	898a      	ldrh	r2, [r1, #12]
   2e138:	6889      	ldr	r1, [r1, #8]
   2e13a:	f7ef f853 	bl	1d1e4 <att_handle_rsp>
}
   2e13e:	bd08      	pop	{r3, pc}

0002e140 <att_handle_read_group_rsp>:
{
   2e140:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e142:	2300      	movs	r3, #0
   2e144:	898a      	ldrh	r2, [r1, #12]
   2e146:	6889      	ldr	r1, [r1, #8]
   2e148:	f7ef f84c 	bl	1d1e4 <att_handle_rsp>
}
   2e14c:	bd08      	pop	{r3, pc}

0002e14e <att_handle_read_mult_vl_rsp>:
{
   2e14e:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e150:	2300      	movs	r3, #0
   2e152:	898a      	ldrh	r2, [r1, #12]
   2e154:	6889      	ldr	r1, [r1, #8]
   2e156:	f7ef f845 	bl	1d1e4 <att_handle_rsp>
}
   2e15a:	bd08      	pop	{r3, pc}

0002e15c <att_handle_read_mult_rsp>:
{
   2e15c:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e15e:	2300      	movs	r3, #0
   2e160:	898a      	ldrh	r2, [r1, #12]
   2e162:	6889      	ldr	r1, [r1, #8]
   2e164:	f7ef f83e 	bl	1d1e4 <att_handle_rsp>
}
   2e168:	bd08      	pop	{r3, pc}

0002e16a <att_handle_read_blob_rsp>:
{
   2e16a:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e16c:	2300      	movs	r3, #0
   2e16e:	898a      	ldrh	r2, [r1, #12]
   2e170:	6889      	ldr	r1, [r1, #8]
   2e172:	f7ef f837 	bl	1d1e4 <att_handle_rsp>
}
   2e176:	bd08      	pop	{r3, pc}

0002e178 <att_handle_read_rsp>:
{
   2e178:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e17a:	2300      	movs	r3, #0
   2e17c:	898a      	ldrh	r2, [r1, #12]
   2e17e:	6889      	ldr	r1, [r1, #8]
   2e180:	f7ef f830 	bl	1d1e4 <att_handle_rsp>
}
   2e184:	bd08      	pop	{r3, pc}

0002e186 <att_handle_read_type_rsp>:
{
   2e186:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e188:	2300      	movs	r3, #0
   2e18a:	898a      	ldrh	r2, [r1, #12]
   2e18c:	6889      	ldr	r1, [r1, #8]
   2e18e:	f7ef f829 	bl	1d1e4 <att_handle_rsp>
}
   2e192:	bd08      	pop	{r3, pc}

0002e194 <att_handle_find_type_rsp>:
{
   2e194:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e196:	2300      	movs	r3, #0
   2e198:	898a      	ldrh	r2, [r1, #12]
   2e19a:	6889      	ldr	r1, [r1, #8]
   2e19c:	f7ef f822 	bl	1d1e4 <att_handle_rsp>
}
   2e1a0:	bd08      	pop	{r3, pc}

0002e1a2 <att_handle_find_info_rsp>:
{
   2e1a2:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e1a4:	2300      	movs	r3, #0
   2e1a6:	898a      	ldrh	r2, [r1, #12]
   2e1a8:	6889      	ldr	r1, [r1, #8]
   2e1aa:	f7ef f81b 	bl	1d1e4 <att_handle_rsp>
}
   2e1ae:	bd08      	pop	{r3, pc}

0002e1b0 <att_mtu_rsp>:
{
   2e1b0:	b570      	push	{r4, r5, r6, lr}
   2e1b2:	4604      	mov	r4, r0
	rsp = (void *)buf->data;
   2e1b4:	688e      	ldr	r6, [r1, #8]
	mtu = sys_le16_to_cpu(rsp->mtu);
   2e1b6:	8833      	ldrh	r3, [r6, #0]
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   2e1b8:	2b16      	cmp	r3, #22
   2e1ba:	d90e      	bls.n	2e1da <att_mtu_rsp+0x2a>
   2e1bc:	460d      	mov	r5, r1
	chan->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   2e1be:	2b17      	cmp	r3, #23
   2e1c0:	bf28      	it	cs
   2e1c2:	2317      	movcs	r3, #23
   2e1c4:	8343      	strh	r3, [r0, #26]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   2e1c6:	8543      	strh	r3, [r0, #42]	; 0x2a
	att_chan_mtu_updated(chan);
   2e1c8:	f7ff fa69 	bl	2d69e <att_chan_mtu_updated>
	return att_handle_rsp(chan, rsp, buf->len, 0);
   2e1cc:	2300      	movs	r3, #0
   2e1ce:	89aa      	ldrh	r2, [r5, #12]
   2e1d0:	4631      	mov	r1, r6
   2e1d2:	4620      	mov	r0, r4
   2e1d4:	f7ef f806 	bl	1d1e4 <att_handle_rsp>
}
   2e1d8:	bd70      	pop	{r4, r5, r6, pc}
		return att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   2e1da:	2304      	movs	r3, #4
   2e1dc:	2200      	movs	r2, #0
   2e1de:	4611      	mov	r1, r2
   2e1e0:	f7ef f800 	bl	1d1e4 <att_handle_rsp>
   2e1e4:	e7f8      	b.n	2e1d8 <att_mtu_rsp+0x28>

0002e1e6 <att_confirm>:
{
   2e1e6:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   2e1e8:	2300      	movs	r3, #0
   2e1ea:	898a      	ldrh	r2, [r1, #12]
   2e1ec:	6889      	ldr	r1, [r1, #8]
   2e1ee:	f7ee fff9 	bl	1d1e4 <att_handle_rsp>
}
   2e1f2:	bd08      	pop	{r3, pc}

0002e1f4 <bt_att_disconnected>:
{
   2e1f4:	b538      	push	{r3, r4, r5, lr}
   2e1f6:	4604      	mov	r4, r0
	struct bt_att *att = att_chan->att;
   2e1f8:	f850 5c04 	ldr.w	r5, [r0, #-4]
	if (!att_chan->att) {
   2e1fc:	b125      	cbz	r5, 2e208 <bt_att_disconnected+0x14>
   2e1fe:	3804      	subs	r0, #4
	att_chan_detach(att_chan);
   2e200:	f7ef f844 	bl	1d28c <att_chan_detach>
	return list->head;
   2e204:	6aab      	ldr	r3, [r5, #40]	; 0x28
	if (!sys_slist_is_empty(&att->chans)) {
   2e206:	b103      	cbz	r3, 2e20a <bt_att_disconnected+0x16>
}
   2e208:	bd38      	pop	{r3, r4, r5, pc}
	att_reset(att);
   2e20a:	4628      	mov	r0, r5
   2e20c:	f7ef f898 	bl	1d340 <att_reset>
	bt_gatt_disconnected(le_chan->chan.conn);
   2e210:	6820      	ldr	r0, [r4, #0]
   2e212:	f7f0 fbaf 	bl	1e974 <bt_gatt_disconnected>
   2e216:	e7f7      	b.n	2e208 <bt_att_disconnected+0x14>

0002e218 <bt_att_req_cancel>:
	struct bt_att *att;
	struct bt_att_chan *chan, *tmp;

	BT_DBG("req %p", req);

	if (!conn || !req) {
   2e218:	2800      	cmp	r0, #0
   2e21a:	d048      	beq.n	2e2ae <bt_att_req_cancel+0x96>
{
   2e21c:	b570      	push	{r4, r5, r6, lr}
   2e21e:	460d      	mov	r5, r1
	if (!conn || !req) {
   2e220:	2900      	cmp	r1, #0
   2e222:	d03a      	beq.n	2e29a <bt_att_req_cancel+0x82>
		return;
	}

	att = att_get(conn);
   2e224:	f7ee f906 	bl	1c434 <att_get>
	if (!att) {
   2e228:	4606      	mov	r6, r0
   2e22a:	2800      	cmp	r0, #0
   2e22c:	d035      	beq.n	2e29a <bt_att_req_cancel+0x82>
   2e22e:	6a80      	ldr	r0, [r0, #40]	; 0x28
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2e230:	b148      	cbz	r0, 2e246 <bt_att_req_cancel+0x2e>
   2e232:	38f0      	subs	r0, #240	; 0xf0
   2e234:	d009      	beq.n	2e24a <bt_att_req_cancel+0x32>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e236:	f110 04f0 	adds.w	r4, r0, #240	; 0xf0
   2e23a:	d00b      	beq.n	2e254 <bt_att_req_cancel+0x3c>
	return node->next;
   2e23c:	f8d0 40f0 	ldr.w	r4, [r0, #240]	; 0xf0
   2e240:	b144      	cbz	r4, 2e254 <bt_att_req_cancel+0x3c>
   2e242:	3cf0      	subs	r4, #240	; 0xf0
   2e244:	e006      	b.n	2e254 <bt_att_req_cancel+0x3c>
   2e246:	4604      	mov	r4, r0
   2e248:	e004      	b.n	2e254 <bt_att_req_cancel+0x3c>
   2e24a:	4604      	mov	r4, r0
   2e24c:	e002      	b.n	2e254 <bt_att_req_cancel+0x3c>
   2e24e:	4623      	mov	r3, r4
   2e250:	4620      	mov	r0, r4
   2e252:	461c      	mov	r4, r3
   2e254:	b170      	cbz	r0, 2e274 <bt_att_req_cancel+0x5c>
		/* Check if request is outstanding */
		if (bt_att_chan_req_cancel(chan, req)) {
   2e256:	4629      	mov	r1, r5
   2e258:	f7ef f8d0 	bl	1d3fc <bt_att_chan_req_cancel>
   2e25c:	b9e8      	cbnz	r0, 2e29a <bt_att_req_cancel+0x82>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   2e25e:	2c00      	cmp	r4, #0
   2e260:	d0f5      	beq.n	2e24e <bt_att_req_cancel+0x36>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e262:	f114 03f0 	adds.w	r3, r4, #240	; 0xf0
   2e266:	d0f3      	beq.n	2e250 <bt_att_req_cancel+0x38>
	return node->next;
   2e268:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
   2e26c:	2b00      	cmp	r3, #0
   2e26e:	d0ef      	beq.n	2e250 <bt_att_req_cancel+0x38>
   2e270:	3bf0      	subs	r3, #240	; 0xf0
   2e272:	e7ed      	b.n	2e250 <bt_att_req_cancel+0x38>
			return;
		}
	}

	/* Remove request from the list */
	sys_slist_find_and_remove(&att->reqs, &req->node);
   2e274:	1d32      	adds	r2, r6, #4
	return list->head;
   2e276:	6873      	ldr	r3, [r6, #4]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2e278:	b163      	cbz	r3, 2e294 <bt_att_req_cancel+0x7c>
   2e27a:	429d      	cmp	r5, r3
   2e27c:	d002      	beq.n	2e284 <bt_att_req_cancel+0x6c>
   2e27e:	4618      	mov	r0, r3
   2e280:	681b      	ldr	r3, [r3, #0]
   2e282:	e7f9      	b.n	2e278 <bt_att_req_cancel+0x60>
Z_GENLIST_REMOVE(slist, snode)
   2e284:	b150      	cbz	r0, 2e29c <bt_att_req_cancel+0x84>
	return node->next;
   2e286:	682b      	ldr	r3, [r5, #0]
	parent->next = child;
   2e288:	6003      	str	r3, [r0, #0]
	return list->tail;
   2e28a:	6853      	ldr	r3, [r2, #4]
Z_GENLIST_REMOVE(slist, snode)
   2e28c:	429d      	cmp	r5, r3
   2e28e:	d00c      	beq.n	2e2aa <bt_att_req_cancel+0x92>
	parent->next = child;
   2e290:	2300      	movs	r3, #0
   2e292:	602b      	str	r3, [r5, #0]

	bt_att_req_free(req);
   2e294:	4628      	mov	r0, r5
   2e296:	f7ee ff75 	bl	1d184 <bt_att_req_free>
}
   2e29a:	bd70      	pop	{r4, r5, r6, pc}
	return node->next;
   2e29c:	682b      	ldr	r3, [r5, #0]
	list->head = node;
   2e29e:	6073      	str	r3, [r6, #4]
	return list->tail;
   2e2a0:	6851      	ldr	r1, [r2, #4]
Z_GENLIST_REMOVE(slist, snode)
   2e2a2:	428d      	cmp	r5, r1
   2e2a4:	d1f4      	bne.n	2e290 <bt_att_req_cancel+0x78>
	list->tail = node;
   2e2a6:	6053      	str	r3, [r2, #4]
}
   2e2a8:	e7f2      	b.n	2e290 <bt_att_req_cancel+0x78>
	list->tail = node;
   2e2aa:	6050      	str	r0, [r2, #4]
}
   2e2ac:	e7f0      	b.n	2e290 <bt_att_req_cancel+0x78>
   2e2ae:	4770      	bx	lr

0002e2b0 <bt_att_find_req_by_user_data>:

struct bt_att_req *bt_att_find_req_by_user_data(struct bt_conn *conn, const void *user_data)
{
   2e2b0:	b510      	push	{r4, lr}
   2e2b2:	460c      	mov	r4, r1
	struct bt_att *att;
	struct bt_att_chan *chan;
	struct bt_att_req *req;

	att = att_get(conn);
   2e2b4:	f7ee f8be 	bl	1c434 <att_get>
	if (!att) {
   2e2b8:	4601      	mov	r1, r0
   2e2ba:	b1f8      	cbz	r0, 2e2fc <bt_att_find_req_by_user_data+0x4c>
	return list->head;
   2e2bc:	6a83      	ldr	r3, [r0, #40]	; 0x28
		return NULL;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   2e2be:	b113      	cbz	r3, 2e2c6 <bt_att_find_req_by_user_data+0x16>
   2e2c0:	3bf0      	subs	r3, #240	; 0xf0
   2e2c2:	e000      	b.n	2e2c6 <bt_att_find_req_by_user_data+0x16>
   2e2c4:	4613      	mov	r3, r2
   2e2c6:	b163      	cbz	r3, 2e2e2 <bt_att_find_req_by_user_data+0x32>
		if (chan->req->user_data == user_data) {
   2e2c8:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
   2e2cc:	68c2      	ldr	r2, [r0, #12]
   2e2ce:	42a2      	cmp	r2, r4
   2e2d0:	d014      	beq.n	2e2fc <bt_att_find_req_by_user_data+0x4c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e2d2:	f113 02f0 	adds.w	r2, r3, #240	; 0xf0
   2e2d6:	d0f5      	beq.n	2e2c4 <bt_att_find_req_by_user_data+0x14>
	return node->next;
   2e2d8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   2e2dc:	b10b      	cbz	r3, 2e2e2 <bt_att_find_req_by_user_data+0x32>
   2e2de:	3bf0      	subs	r3, #240	; 0xf0
   2e2e0:	e7f1      	b.n	2e2c6 <bt_att_find_req_by_user_data+0x16>
	return list->head;
   2e2e2:	684b      	ldr	r3, [r1, #4]
			return chan->req;
		}
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->reqs, req, node) {
   2e2e4:	b14b      	cbz	r3, 2e2fa <bt_att_find_req_by_user_data+0x4a>
		if (req->user_data == user_data) {
   2e2e6:	68da      	ldr	r2, [r3, #12]
   2e2e8:	42a2      	cmp	r2, r4
   2e2ea:	d008      	beq.n	2e2fe <bt_att_find_req_by_user_data+0x4e>
	SYS_SLIST_FOR_EACH_CONTAINER(&att->reqs, req, node) {
   2e2ec:	4618      	mov	r0, r3
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e2ee:	b12b      	cbz	r3, 2e2fc <bt_att_find_req_by_user_data+0x4c>
	return node->next;
   2e2f0:	681b      	ldr	r3, [r3, #0]
   2e2f2:	2b00      	cmp	r3, #0
   2e2f4:	d1f6      	bne.n	2e2e4 <bt_att_find_req_by_user_data+0x34>
			return req;
		}
	}

	return NULL;
   2e2f6:	4618      	mov	r0, r3
   2e2f8:	e000      	b.n	2e2fc <bt_att_find_req_by_user_data+0x4c>
   2e2fa:	4618      	mov	r0, r3
}
   2e2fc:	bd10      	pop	{r4, pc}
   2e2fe:	4618      	mov	r0, r3
   2e300:	e7fc      	b.n	2e2fc <bt_att_find_req_by_user_data+0x4c>

0002e302 <bt_att_fixed_chan_only>:
#if defined(CONFIG_BT_EATT)
	return bt_eatt_count(conn) == 0;
#else
	return true;
#endif /* CONFIG_BT_EATT */
}
   2e302:	2001      	movs	r0, #1
   2e304:	4770      	bx	lr

0002e306 <bt_att_clear_out_of_sync_sent>:

void bt_att_clear_out_of_sync_sent(struct bt_conn *conn)
{
   2e306:	b508      	push	{r3, lr}
	struct bt_att *att = att_get(conn);
   2e308:	f7ee f894 	bl	1c434 <att_get>
	struct bt_att_chan *chan;

	if (!att) {
   2e30c:	b1d8      	cbz	r0, 2e346 <bt_att_clear_out_of_sync_sent+0x40>
	return list->head;
   2e30e:	6a83      	ldr	r3, [r0, #40]	; 0x28
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   2e310:	b113      	cbz	r3, 2e318 <bt_att_clear_out_of_sync_sent+0x12>
   2e312:	3bf0      	subs	r3, #240	; 0xf0
   2e314:	e000      	b.n	2e318 <bt_att_clear_out_of_sync_sent+0x12>
   2e316:	4613      	mov	r3, r2
   2e318:	b1ab      	cbz	r3, 2e346 <bt_att_clear_out_of_sync_sent+0x40>
		atomic_clear_bit(chan->flags, ATT_OUT_OF_SYNC_SENT);
   2e31a:	f103 0298 	add.w	r2, r3, #152	; 0x98
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2e31e:	f3bf 8f5b 	dmb	ish
   2e322:	e852 1f00 	ldrex	r1, [r2]
   2e326:	f021 0120 	bic.w	r1, r1, #32
   2e32a:	e842 1000 	strex	r0, r1, [r2]
   2e32e:	2800      	cmp	r0, #0
   2e330:	d1f7      	bne.n	2e322 <bt_att_clear_out_of_sync_sent+0x1c>
   2e332:	f3bf 8f5b 	dmb	ish
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e336:	f113 02f0 	adds.w	r2, r3, #240	; 0xf0
   2e33a:	d0ec      	beq.n	2e316 <bt_att_clear_out_of_sync_sent+0x10>
	return node->next;
   2e33c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   2e340:	b10b      	cbz	r3, 2e346 <bt_att_clear_out_of_sync_sent+0x40>
   2e342:	3bf0      	subs	r3, #240	; 0xf0
   2e344:	e7e8      	b.n	2e318 <bt_att_clear_out_of_sync_sent+0x12>
	}
}
   2e346:	bd08      	pop	{r3, pc}

0002e348 <bt_att_out_of_sync_sent_on_fixed>:

bool bt_att_out_of_sync_sent_on_fixed(struct bt_conn *conn)
{
   2e348:	b508      	push	{r3, lr}
	struct bt_l2cap_chan *l2cap_chan;
	struct bt_att_chan *att_chan;

	l2cap_chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   2e34a:	2104      	movs	r1, #4
   2e34c:	f7ff f866 	bl	2d41c <bt_l2cap_le_lookup_rx_cid>
	if (!l2cap_chan) {
   2e350:	b140      	cbz	r0, 2e364 <bt_att_out_of_sync_sent_on_fixed+0x1c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2e352:	f3bf 8f5b 	dmb	ish
   2e356:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
   2e35a:	f3bf 8f5b 	dmb	ish
   2e35e:	f3c0 1040 	ubfx	r0, r0, #5, #1
		return false;
	}

	att_chan = ATT_CHAN(l2cap_chan);
	return atomic_test_bit(att_chan->flags, ATT_OUT_OF_SYNC_SENT);
}
   2e362:	bd08      	pop	{r3, pc}
		return false;
   2e364:	2000      	movs	r0, #0
   2e366:	e7fc      	b.n	2e362 <bt_att_out_of_sync_sent_on_fixed+0x1a>

0002e368 <bt_att_set_tx_meta_data>:

void bt_att_set_tx_meta_data(struct net_buf *buf, bt_gatt_complete_func_t func, void *user_data,
			     enum bt_att_chan_opt chan_opt)
{
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
   2e368:	6940      	ldr	r0, [r0, #20]

	data->func = func;
   2e36a:	6081      	str	r1, [r0, #8]
	data->user_data = user_data;
   2e36c:	60c2      	str	r2, [r0, #12]
	data->attr_count = 1;
   2e36e:	2201      	movs	r2, #1
   2e370:	8082      	strh	r2, [r0, #4]
	data->chan_opt = chan_opt;
   2e372:	7403      	strb	r3, [r0, #16]
}
   2e374:	4770      	bx	lr

0002e376 <update_range>:
	if (new_start >= *start && new_end <= *end) {
   2e376:	f8b0 c000 	ldrh.w	ip, [r0]
   2e37a:	4562      	cmp	r2, ip
   2e37c:	d312      	bcc.n	2e3a4 <update_range+0x2e>
{
   2e37e:	b500      	push	{lr}
	if (new_start >= *start && new_end <= *end) {
   2e380:	f8b1 e000 	ldrh.w	lr, [r1]
   2e384:	4573      	cmp	r3, lr
   2e386:	d908      	bls.n	2e39a <update_range+0x24>
	if (*start > new_start) {
   2e388:	4562      	cmp	r2, ip
   2e38a:	d200      	bcs.n	2e38e <update_range+0x18>
		*start = new_start;
   2e38c:	8002      	strh	r2, [r0, #0]
	if (*end < new_end) {
   2e38e:	880a      	ldrh	r2, [r1, #0]
   2e390:	4293      	cmp	r3, r2
   2e392:	d904      	bls.n	2e39e <update_range+0x28>
		*end = new_end;
   2e394:	800b      	strh	r3, [r1, #0]
	return true;
   2e396:	2001      	movs	r0, #1
   2e398:	e002      	b.n	2e3a0 <update_range+0x2a>
		return false;
   2e39a:	2000      	movs	r0, #0
   2e39c:	e000      	b.n	2e3a0 <update_range+0x2a>
	return true;
   2e39e:	2001      	movs	r0, #1
}
   2e3a0:	f85d fb04 	ldr.w	pc, [sp], #4
	if (*start > new_start) {
   2e3a4:	4562      	cmp	r2, ip
   2e3a6:	d200      	bcs.n	2e3aa <update_range+0x34>
		*start = new_start;
   2e3a8:	8002      	strh	r2, [r0, #0]
	if (*end < new_end) {
   2e3aa:	880a      	ldrh	r2, [r1, #0]
   2e3ac:	4293      	cmp	r3, r2
   2e3ae:	d902      	bls.n	2e3b6 <update_range+0x40>
		*end = new_end;
   2e3b0:	800b      	strh	r3, [r1, #0]
	return true;
   2e3b2:	2001      	movs	r0, #1
   2e3b4:	4770      	bx	lr
   2e3b6:	2001      	movs	r0, #1
}
   2e3b8:	4770      	bx	lr

0002e3ba <cf_set_value>:
{
   2e3ba:	b510      	push	{r4, lr}
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
   2e3bc:	2300      	movs	r3, #0
   2e3be:	e001      	b.n	2e3c4 <cf_set_value+0xa>
   2e3c0:	3301      	adds	r3, #1
   2e3c2:	b29b      	uxth	r3, r3
   2e3c4:	2b02      	cmp	r3, #2
   2e3c6:	d819      	bhi.n	2e3fc <cf_set_value+0x42>
   2e3c8:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
   2e3cc:	ebb2 0fd3 	cmp.w	r2, r3, lsr #3
   2e3d0:	d912      	bls.n	2e3f8 <cf_set_value+0x3e>
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   2e3d2:	eb00 040c 	add.w	r4, r0, ip
   2e3d6:	7a24      	ldrb	r4, [r4, #8]
   2e3d8:	f003 0e07 	and.w	lr, r3, #7
   2e3dc:	fa24 f40e 	lsr.w	r4, r4, lr
   2e3e0:	f014 0f01 	tst.w	r4, #1
   2e3e4:	d0ec      	beq.n	2e3c0 <cf_set_value+0x6>
		    !(value[i / 8] & BIT(i % 8))) {
   2e3e6:	f811 400c 	ldrb.w	r4, [r1, ip]
   2e3ea:	fa24 fe0e 	lsr.w	lr, r4, lr
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   2e3ee:	f01e 0f01 	tst.w	lr, #1
   2e3f2:	d1e5      	bne.n	2e3c0 <cf_set_value+0x6>
			return false;
   2e3f4:	2000      	movs	r0, #0
   2e3f6:	e017      	b.n	2e428 <cf_set_value+0x6e>
   2e3f8:	2300      	movs	r3, #0
   2e3fa:	e000      	b.n	2e3fe <cf_set_value+0x44>
   2e3fc:	2300      	movs	r3, #0
	for (i = 0U; i < len && i < CF_NUM_BYTES; i++) {
   2e3fe:	4293      	cmp	r3, r2
   2e400:	d211      	bcs.n	2e426 <cf_set_value+0x6c>
   2e402:	b973      	cbnz	r3, 2e422 <cf_set_value+0x68>
			cfg->data[i] |= value[i] & BIT_MASK(CF_NUM_BITS % 8);
   2e404:	f811 c003 	ldrb.w	ip, [r1, r3]
   2e408:	f00c 0c07 	and.w	ip, ip, #7
   2e40c:	eb00 0e03 	add.w	lr, r0, r3
   2e410:	f89e 4008 	ldrb.w	r4, [lr, #8]
   2e414:	ea4c 0c04 	orr.w	ip, ip, r4
   2e418:	f88e c008 	strb.w	ip, [lr, #8]
	for (i = 0U; i < len && i < CF_NUM_BYTES; i++) {
   2e41c:	3301      	adds	r3, #1
   2e41e:	b29b      	uxth	r3, r3
   2e420:	e7ed      	b.n	2e3fe <cf_set_value+0x44>
	return true;
   2e422:	2001      	movs	r0, #1
   2e424:	e000      	b.n	2e428 <cf_set_value+0x6e>
   2e426:	2001      	movs	r0, #1
}
   2e428:	bd10      	pop	{r4, pc}

0002e42a <find_next>:
	*next = (struct bt_gatt_attr *)attr;
   2e42a:	6010      	str	r0, [r2, #0]
}
   2e42c:	2000      	movs	r0, #0
   2e42e:	4770      	bx	lr

0002e430 <gatt_ccc_changed>:
{
   2e430:	b508      	push	{r3, lr}
   2e432:	460a      	mov	r2, r1
	uint16_t value = 0x0000;
   2e434:	2100      	movs	r1, #0
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   2e436:	460b      	mov	r3, r1
   2e438:	b13b      	cbz	r3, 2e44a <gatt_ccc_changed+0x1a>
	if (value != ccc->value) {
   2e43a:	8953      	ldrh	r3, [r2, #10]
   2e43c:	4299      	cmp	r1, r3
   2e43e:	d003      	beq.n	2e448 <gatt_ccc_changed+0x18>
		ccc->value = value;
   2e440:	8151      	strh	r1, [r2, #10]
		if (ccc->cfg_changed) {
   2e442:	68d3      	ldr	r3, [r2, #12]
   2e444:	b103      	cbz	r3, 2e448 <gatt_ccc_changed+0x18>
			ccc->cfg_changed(attr, value);
   2e446:	4798      	blx	r3
}
   2e448:	bd08      	pop	{r3, pc}
		if (ccc->cfg[i].value > value) {
   2e44a:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
   2e44e:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   2e452:	f8bc c008 	ldrh.w	ip, [ip, #8]
   2e456:	458c      	cmp	ip, r1
   2e458:	d900      	bls.n	2e45c <gatt_ccc_changed+0x2c>
			value = ccc->cfg[i].value;
   2e45a:	4661      	mov	r1, ip
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   2e45c:	3301      	adds	r3, #1
   2e45e:	e7eb      	b.n	2e438 <gatt_ccc_changed+0x8>

0002e460 <gatt_indicate_rsp>:
{
   2e460:	b510      	push	{r4, lr}
   2e462:	9c02      	ldr	r4, [sp, #8]
	if (params->func) {
   2e464:	68a3      	ldr	r3, [r4, #8]
   2e466:	b113      	cbz	r3, 2e46e <gatt_indicate_rsp+0xe>
   2e468:	460a      	mov	r2, r1
		params->func(conn, params, err);
   2e46a:	4621      	mov	r1, r4
   2e46c:	4798      	blx	r3
	params->_ref--;
   2e46e:	7da3      	ldrb	r3, [r4, #22]
   2e470:	3b01      	subs	r3, #1
   2e472:	b2db      	uxtb	r3, r3
   2e474:	75a3      	strb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
   2e476:	68e2      	ldr	r2, [r4, #12]
   2e478:	b112      	cbz	r2, 2e480 <gatt_indicate_rsp+0x20>
   2e47a:	b90b      	cbnz	r3, 2e480 <gatt_indicate_rsp+0x20>
		params->destroy(params);
   2e47c:	4620      	mov	r0, r4
   2e47e:	4790      	blx	r2
}
   2e480:	bd10      	pop	{r4, pc}

0002e482 <match_uuid>:
	data->attr = attr;
   2e482:	6010      	str	r0, [r2, #0]
	data->handle = handle;
   2e484:	8091      	strh	r1, [r2, #4]
}
   2e486:	2000      	movs	r0, #0
   2e488:	4770      	bx	lr

0002e48a <gatt_sub_is_empty>:
	return list->head;
   2e48a:	6880      	ldr	r0, [r0, #8]
}
   2e48c:	fab0 f080 	clz	r0, r0
   2e490:	0940      	lsrs	r0, r0, #5
   2e492:	4770      	bx	lr

0002e494 <check_subscribe_security_level>:
}
   2e494:	2001      	movs	r0, #1
   2e496:	4770      	bx	lr

0002e498 <write_name>:
{
   2e498:	b510      	push	{r4, lr}
   2e49a:	b088      	sub	sp, #32
   2e49c:	4611      	mov	r1, r2
   2e49e:	461a      	mov	r2, r3
   2e4a0:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	char value[CONFIG_BT_DEVICE_NAME_MAX] = {};
   2e4a4:	2000      	movs	r0, #0
   2e4a6:	9001      	str	r0, [sp, #4]
   2e4a8:	9002      	str	r0, [sp, #8]
   2e4aa:	9003      	str	r0, [sp, #12]
   2e4ac:	9004      	str	r0, [sp, #16]
   2e4ae:	9005      	str	r0, [sp, #20]
   2e4b0:	9006      	str	r0, [sp, #24]
   2e4b2:	9007      	str	r0, [sp, #28]
	if (offset >= sizeof(value)) {
   2e4b4:	2b1b      	cmp	r3, #27
   2e4b6:	d80d      	bhi.n	2e4d4 <write_name+0x3c>
	if (offset + len >= sizeof(value)) {
   2e4b8:	4614      	mov	r4, r2
   2e4ba:	4413      	add	r3, r2
   2e4bc:	2b1b      	cmp	r3, #27
   2e4be:	d80c      	bhi.n	2e4da <write_name+0x42>
	memcpy(value, buf, len);
   2e4c0:	231c      	movs	r3, #28
   2e4c2:	a801      	add	r0, sp, #4
   2e4c4:	f002 fcdd 	bl	30e82 <__memcpy_chk>
	bt_set_name(value);
   2e4c8:	a801      	add	r0, sp, #4
   2e4ca:	f7ec f923 	bl	1a714 <bt_set_name>
}
   2e4ce:	4620      	mov	r0, r4
   2e4d0:	b008      	add	sp, #32
   2e4d2:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2e4d4:	f06f 0406 	mvn.w	r4, #6
   2e4d8:	e7f9      	b.n	2e4ce <write_name+0x36>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   2e4da:	f06f 040c 	mvn.w	r4, #12
   2e4de:	e7f6      	b.n	2e4ce <write_name+0x36>

0002e4e0 <gen_hash_m>:
{
   2e4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e4e2:	b089      	sub	sp, #36	; 0x24
	if (attr->uuid->type != BT_UUID_TYPE_16)
   2e4e4:	6806      	ldr	r6, [r0, #0]
   2e4e6:	7835      	ldrb	r5, [r6, #0]
   2e4e8:	2d00      	cmp	r5, #0
   2e4ea:	d160      	bne.n	2e5ae <gen_hash_m+0xce>
   2e4ec:	4607      	mov	r7, r0
   2e4ee:	4614      	mov	r4, r2
	switch (u16->val) {
   2e4f0:	8873      	ldrh	r3, [r6, #2]
   2e4f2:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   2e4f6:	d019      	beq.n	2e52c <gen_hash_m+0x4c>
   2e4f8:	d913      	bls.n	2e522 <gen_hash_m+0x42>
   2e4fa:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
   2e4fe:	33ff      	adds	r3, #255	; 0xff
   2e500:	b29b      	uxth	r3, r3
   2e502:	2b04      	cmp	r3, #4
   2e504:	d859      	bhi.n	2e5ba <gen_hash_m+0xda>
		value = sys_cpu_to_le16(handle);
   2e506:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2e50a:	2202      	movs	r2, #2
   2e50c:	f10d 010a 	add.w	r1, sp, #10
   2e510:	4620      	mov	r0, r4
   2e512:	f7fe f8da 	bl	2c6ca <tc_cmac_update>
   2e516:	2800      	cmp	r0, #0
   2e518:	d139      	bne.n	2e58e <gen_hash_m+0xae>
			state->err = -EINVAL;
   2e51a:	f06f 0315 	mvn.w	r3, #21
   2e51e:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2e520:	e046      	b.n	2e5b0 <gen_hash_m+0xd0>
	switch (u16->val) {
   2e522:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   2e526:	b29b      	uxth	r3, r3
   2e528:	2b03      	cmp	r3, #3
   2e52a:	d844      	bhi.n	2e5b6 <gen_hash_m+0xd6>
		value = sys_cpu_to_le16(handle);
   2e52c:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2e530:	2202      	movs	r2, #2
   2e532:	f10d 010a 	add.w	r1, sp, #10
   2e536:	4620      	mov	r0, r4
   2e538:	f7fe f8c7 	bl	2c6ca <tc_cmac_update>
   2e53c:	b918      	cbnz	r0, 2e546 <gen_hash_m+0x66>
			state->err = -EINVAL;
   2e53e:	f06f 0315 	mvn.w	r3, #21
   2e542:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2e544:	e034      	b.n	2e5b0 <gen_hash_m+0xd0>
		value = sys_cpu_to_le16(u16->val);
   2e546:	8873      	ldrh	r3, [r6, #2]
   2e548:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2e54c:	2202      	movs	r2, #2
   2e54e:	f10d 010a 	add.w	r1, sp, #10
   2e552:	4620      	mov	r0, r4
   2e554:	f7fe f8b9 	bl	2c6ca <tc_cmac_update>
   2e558:	b178      	cbz	r0, 2e57a <gen_hash_m+0x9a>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   2e55a:	687e      	ldr	r6, [r7, #4]
   2e55c:	2000      	movs	r0, #0
   2e55e:	9000      	str	r0, [sp, #0]
   2e560:	2313      	movs	r3, #19
   2e562:	aa03      	add	r2, sp, #12
   2e564:	4639      	mov	r1, r7
   2e566:	47b0      	blx	r6
		if (len < 0) {
   2e568:	1e02      	subs	r2, r0, #0
   2e56a:	db0a      	blt.n	2e582 <gen_hash_m+0xa2>
		if (tc_cmac_update(&state->state, data, len) ==
   2e56c:	a903      	add	r1, sp, #12
   2e56e:	4620      	mov	r0, r4
   2e570:	f7fe f8ab 	bl	2c6ca <tc_cmac_update>
   2e574:	b138      	cbz	r0, 2e586 <gen_hash_m+0xa6>
	return BT_GATT_ITER_CONTINUE;
   2e576:	2501      	movs	r5, #1
   2e578:	e01a      	b.n	2e5b0 <gen_hash_m+0xd0>
			state->err = -EINVAL;
   2e57a:	f06f 0315 	mvn.w	r3, #21
   2e57e:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2e580:	e016      	b.n	2e5b0 <gen_hash_m+0xd0>
			state->err = len;
   2e582:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2e584:	e014      	b.n	2e5b0 <gen_hash_m+0xd0>
			state->err = -EINVAL;
   2e586:	f06f 0315 	mvn.w	r3, #21
   2e58a:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2e58c:	e010      	b.n	2e5b0 <gen_hash_m+0xd0>
		value = sys_cpu_to_le16(u16->val);
   2e58e:	8873      	ldrh	r3, [r6, #2]
   2e590:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2e594:	2202      	movs	r2, #2
   2e596:	f10d 010a 	add.w	r1, sp, #10
   2e59a:	4620      	mov	r0, r4
   2e59c:	f7fe f895 	bl	2c6ca <tc_cmac_update>
   2e5a0:	b108      	cbz	r0, 2e5a6 <gen_hash_m+0xc6>
	return BT_GATT_ITER_CONTINUE;
   2e5a2:	2501      	movs	r5, #1
   2e5a4:	e004      	b.n	2e5b0 <gen_hash_m+0xd0>
			state->err = -EINVAL;
   2e5a6:	f06f 0315 	mvn.w	r3, #21
   2e5aa:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2e5ac:	e000      	b.n	2e5b0 <gen_hash_m+0xd0>
		return BT_GATT_ITER_CONTINUE;
   2e5ae:	2501      	movs	r5, #1
}
   2e5b0:	4628      	mov	r0, r5
   2e5b2:	b009      	add	sp, #36	; 0x24
   2e5b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   2e5b6:	2501      	movs	r5, #1
   2e5b8:	e7fa      	b.n	2e5b0 <gen_hash_m+0xd0>
   2e5ba:	2501      	movs	r5, #1
   2e5bc:	e7f8      	b.n	2e5b0 <gen_hash_m+0xd0>

0002e5be <find_ccc_cfg>:
{
   2e5be:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e5c0:	b083      	sub	sp, #12
   2e5c2:	4607      	mov	r7, r0
   2e5c4:	460d      	mov	r5, r1
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   2e5c6:	2400      	movs	r4, #0
   2e5c8:	b11c      	cbz	r4, 2e5d2 <find_ccc_cfg+0x14>
	return NULL;
   2e5ca:	2600      	movs	r6, #0
}
   2e5cc:	4630      	mov	r0, r6
   2e5ce:	b003      	add	sp, #12
   2e5d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
   2e5d2:	eb04 0684 	add.w	r6, r4, r4, lsl #2
   2e5d6:	eb05 0646 	add.w	r6, r5, r6, lsl #1
		if (conn) {
   2e5da:	b167      	cbz	r7, 2e5f6 <find_ccc_cfg+0x38>
						    &cfg->peer)) {
   2e5dc:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   2e5e0:	4632      	mov	r2, r6
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   2e5e2:	3201      	adds	r2, #1
   2e5e4:	f815 1013 	ldrb.w	r1, [r5, r3, lsl #1]
   2e5e8:	4638      	mov	r0, r7
   2e5ea:	f7fe fe31 	bl	2d250 <bt_conn_is_peer_addr_le>
   2e5ee:	2800      	cmp	r0, #0
   2e5f0:	d1ec      	bne.n	2e5cc <find_ccc_cfg+0xe>
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   2e5f2:	3401      	adds	r4, #1
   2e5f4:	e7e8      	b.n	2e5c8 <find_ccc_cfg+0xa>
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   2e5f6:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   2e5fa:	eb05 0040 	add.w	r0, r5, r0, lsl #1
   2e5fe:	2300      	movs	r3, #0
   2e600:	9300      	str	r3, [sp, #0]
   2e602:	f8cd 3003 	str.w	r3, [sp, #3]
   2e606:	2207      	movs	r2, #7
   2e608:	4669      	mov	r1, sp
   2e60a:	3001      	adds	r0, #1
   2e60c:	f002 fc1b 	bl	30e46 <memcmp>
   2e610:	2800      	cmp	r0, #0
   2e612:	d1ee      	bne.n	2e5f2 <find_ccc_cfg+0x34>
   2e614:	e7da      	b.n	2e5cc <find_ccc_cfg+0xe>

0002e616 <clear_sc_cfg>:
__ssp_bos_icheck3(memset, void *, int)
   2e616:	2300      	movs	r3, #0
   2e618:	6003      	str	r3, [r0, #0]
   2e61a:	6043      	str	r3, [r0, #4]
   2e61c:	6083      	str	r3, [r0, #8]
}
   2e61e:	4770      	bx	lr

0002e620 <bt_gatt_clear_sc>:
{
   2e620:	b508      	push	{r3, lr}
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
   2e622:	f7ee ffb1 	bl	1d588 <find_sc_cfg>
	if (!cfg) {
   2e626:	b108      	cbz	r0, 2e62c <bt_gatt_clear_sc+0xc>
	clear_sc_cfg(cfg);
   2e628:	f7ff fff5 	bl	2e616 <clear_sc_cfg>
}
   2e62c:	2000      	movs	r0, #0
   2e62e:	bd08      	pop	{r3, pc}

0002e630 <sc_reset>:
   2e630:	2300      	movs	r3, #0
   2e632:	6083      	str	r3, [r0, #8]
}
   2e634:	4770      	bx	lr

0002e636 <sc_restore_rsp>:
{
   2e636:	b538      	push	{r3, r4, r5, lr}
   2e638:	4605      	mov	r5, r0
   2e63a:	4614      	mov	r4, r2
	if (bt_att_fixed_chan_only(conn)) {
   2e63c:	f7ff fe61 	bl	2e302 <bt_att_fixed_chan_only>
   2e640:	b908      	cbnz	r0, 2e646 <sc_restore_rsp+0x10>
	if (!err && IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED)) {
   2e642:	b1c4      	cbz	r4, 2e676 <sc_restore_rsp+0x40>
}
   2e644:	bd38      	pop	{r3, r4, r5, pc}
		cfg = find_cf_cfg(conn);
   2e646:	4628      	mov	r0, r5
   2e648:	f7ee ff74 	bl	1d534 <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
   2e64c:	4603      	mov	r3, r0
   2e64e:	2800      	cmp	r0, #0
   2e650:	d0f7      	beq.n	2e642 <sc_restore_rsp+0xc>
   2e652:	7a02      	ldrb	r2, [r0, #8]
   2e654:	f012 0f01 	tst.w	r2, #1
   2e658:	d0f3      	beq.n	2e642 <sc_restore_rsp+0xc>
			atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   2e65a:	330c      	adds	r3, #12
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2e65c:	f3bf 8f5b 	dmb	ish
   2e660:	e853 2f00 	ldrex	r2, [r3]
   2e664:	f042 0201 	orr.w	r2, r2, #1
   2e668:	e843 2100 	strex	r1, r2, [r3]
   2e66c:	2900      	cmp	r1, #0
   2e66e:	d1f7      	bne.n	2e660 <sc_restore_rsp+0x2a>
   2e670:	f3bf 8f5b 	dmb	ish
			BT_DBG("%s change-aware", bt_addr_le_str(&cfg->peer));
   2e674:	e7e5      	b.n	2e642 <sc_restore_rsp+0xc>
		struct gatt_sc_cfg *sc_cfg = find_sc_cfg(conn->id, &conn->le.dst);
   2e676:	f105 0190 	add.w	r1, r5, #144	; 0x90
   2e67a:	7a28      	ldrb	r0, [r5, #8]
   2e67c:	f7ee ff84 	bl	1d588 <find_sc_cfg>
		if (sc_cfg) {
   2e680:	2800      	cmp	r0, #0
   2e682:	d0df      	beq.n	2e644 <sc_restore_rsp+0xe>
			sc_reset(sc_cfg);
   2e684:	f7ff ffd4 	bl	2e630 <sc_reset>
}
   2e688:	e7dc      	b.n	2e644 <sc_restore_rsp+0xe>

0002e68a <gatt_foreach_iter>:
	if (handle > end_handle) {
   2e68a:	4299      	cmp	r1, r3
   2e68c:	d822      	bhi.n	2e6d4 <gatt_foreach_iter+0x4a>
{
   2e68e:	b538      	push	{r3, r4, r5, lr}
   2e690:	4605      	mov	r5, r0
   2e692:	460c      	mov	r4, r1
	if (handle < start_handle) {
   2e694:	4291      	cmp	r1, r2
   2e696:	d31f      	bcc.n	2e6d8 <gatt_foreach_iter+0x4e>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   2e698:	9b04      	ldr	r3, [sp, #16]
   2e69a:	b123      	cbz	r3, 2e6a6 <gatt_foreach_iter+0x1c>
   2e69c:	6801      	ldr	r1, [r0, #0]
   2e69e:	4618      	mov	r0, r3
   2e6a0:	f7fe f96c 	bl	2c97c <bt_uuid_cmp>
   2e6a4:	b9d0      	cbnz	r0, 2e6dc <gatt_foreach_iter+0x52>
	if (attr_data && attr_data != attr->user_data) {
   2e6a6:	9b05      	ldr	r3, [sp, #20]
   2e6a8:	b12b      	cbz	r3, 2e6b6 <gatt_foreach_iter+0x2c>
   2e6aa:	68eb      	ldr	r3, [r5, #12]
   2e6ac:	9a05      	ldr	r2, [sp, #20]
   2e6ae:	4293      	cmp	r3, r2
   2e6b0:	d001      	beq.n	2e6b6 <gatt_foreach_iter+0x2c>
		return BT_GATT_ITER_CONTINUE;
   2e6b2:	2001      	movs	r0, #1
   2e6b4:	e011      	b.n	2e6da <gatt_foreach_iter+0x50>
	*num_matches -= 1;
   2e6b6:	9b06      	ldr	r3, [sp, #24]
   2e6b8:	881b      	ldrh	r3, [r3, #0]
   2e6ba:	3b01      	subs	r3, #1
   2e6bc:	9a06      	ldr	r2, [sp, #24]
   2e6be:	8013      	strh	r3, [r2, #0]
	result = func(attr, handle, user_data);
   2e6c0:	9a08      	ldr	r2, [sp, #32]
   2e6c2:	4621      	mov	r1, r4
   2e6c4:	4628      	mov	r0, r5
   2e6c6:	9b07      	ldr	r3, [sp, #28]
   2e6c8:	4798      	blx	r3
	if (!*num_matches) {
   2e6ca:	9b06      	ldr	r3, [sp, #24]
   2e6cc:	881b      	ldrh	r3, [r3, #0]
   2e6ce:	b923      	cbnz	r3, 2e6da <gatt_foreach_iter+0x50>
		return BT_GATT_ITER_STOP;
   2e6d0:	2000      	movs	r0, #0
   2e6d2:	e002      	b.n	2e6da <gatt_foreach_iter+0x50>
		return BT_GATT_ITER_STOP;
   2e6d4:	2000      	movs	r0, #0
}
   2e6d6:	4770      	bx	lr
		return BT_GATT_ITER_CONTINUE;
   2e6d8:	2001      	movs	r0, #1
}
   2e6da:	bd38      	pop	{r3, r4, r5, pc}
		return BT_GATT_ITER_CONTINUE;
   2e6dc:	2001      	movs	r0, #1
   2e6de:	e7fc      	b.n	2e6da <gatt_foreach_iter+0x50>

0002e6e0 <gatt_req_alloc>:
{
   2e6e0:	b538      	push	{r3, r4, r5, lr}
   2e6e2:	4605      	mov	r5, r0
   2e6e4:	460c      	mov	r4, r1
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   2e6e6:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
   2e6ea:	2100      	movs	r1, #0
   2e6ec:	f7ee fd24 	bl	1d138 <bt_att_req_alloc>
	if (!req) {
   2e6f0:	4603      	mov	r3, r0
   2e6f2:	b108      	cbz	r0, 2e6f8 <gatt_req_alloc+0x18>
	req->func = func;
   2e6f4:	6045      	str	r5, [r0, #4]
	req->user_data = params;
   2e6f6:	60c4      	str	r4, [r0, #12]
}
   2e6f8:	4618      	mov	r0, r3
   2e6fa:	bd38      	pop	{r3, r4, r5, pc}

0002e6fc <gatt_req_send>:
{
   2e6fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2e700:	b083      	sub	sp, #12
   2e702:	4606      	mov	r6, r0
   2e704:	4608      	mov	r0, r1
   2e706:	4615      	mov	r5, r2
   2e708:	461c      	mov	r4, r3
   2e70a:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
   2e70e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
	req = gatt_req_alloc(func, params, encode, op, len);
   2e710:	9700      	str	r7, [sp, #0]
   2e712:	4643      	mov	r3, r8
   2e714:	4622      	mov	r2, r4
   2e716:	4629      	mov	r1, r5
   2e718:	f7ff ffe2 	bl	2e6e0 <gatt_req_alloc>
	if (!req) {
   2e71c:	b368      	cbz	r0, 2e77a <gatt_req_send+0x7e>
   2e71e:	4681      	mov	r9, r0
	buf = bt_att_create_pdu(conn, op, len);
   2e720:	463a      	mov	r2, r7
   2e722:	4641      	mov	r1, r8
   2e724:	4630      	mov	r0, r6
   2e726:	f7ee f9c1 	bl	1caac <bt_att_create_pdu>
	if (!buf) {
   2e72a:	4680      	mov	r8, r0
   2e72c:	b1b8      	cbz	r0, 2e75e <gatt_req_send+0x62>
	bt_att_set_tx_meta_data(buf, NULL, NULL, chan_opt);
   2e72e:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   2e732:	2200      	movs	r2, #0
   2e734:	4611      	mov	r1, r2
   2e736:	f7ff fe17 	bl	2e368 <bt_att_set_tx_meta_data>
	req->buf = buf;
   2e73a:	f8c9 8008 	str.w	r8, [r9, #8]
	err = encode(buf, len, params);
   2e73e:	462a      	mov	r2, r5
   2e740:	4639      	mov	r1, r7
   2e742:	4640      	mov	r0, r8
   2e744:	47a0      	blx	r4
	if (err) {
   2e746:	4604      	mov	r4, r0
   2e748:	b978      	cbnz	r0, 2e76a <gatt_req_send+0x6e>
	err = bt_att_req_send(conn, req);
   2e74a:	4649      	mov	r1, r9
   2e74c:	4630      	mov	r0, r6
   2e74e:	f7ee feb7 	bl	1d4c0 <bt_att_req_send>
	if (err) {
   2e752:	4604      	mov	r4, r0
   2e754:	b968      	cbnz	r0, 2e772 <gatt_req_send+0x76>
}
   2e756:	4620      	mov	r0, r4
   2e758:	b003      	add	sp, #12
   2e75a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bt_att_req_free(req);
   2e75e:	4648      	mov	r0, r9
   2e760:	f7ee fd10 	bl	1d184 <bt_att_req_free>
		return -ENOMEM;
   2e764:	f06f 040b 	mvn.w	r4, #11
   2e768:	e7f5      	b.n	2e756 <gatt_req_send+0x5a>
		bt_att_req_free(req);
   2e76a:	4648      	mov	r0, r9
   2e76c:	f7ee fd0a 	bl	1d184 <bt_att_req_free>
		return err;
   2e770:	e7f1      	b.n	2e756 <gatt_req_send+0x5a>
		bt_att_req_free(req);
   2e772:	4648      	mov	r0, r9
   2e774:	f7ee fd06 	bl	1d184 <bt_att_req_free>
   2e778:	e7ed      	b.n	2e756 <gatt_req_send+0x5a>
		return -ENOMEM;
   2e77a:	f06f 040b 	mvn.w	r4, #11
   2e77e:	e7ea      	b.n	2e756 <gatt_req_send+0x5a>

0002e780 <gatt_write_ccc_buf>:
{
   2e780:	b538      	push	{r3, r4, r5, lr}
   2e782:	4614      	mov	r4, r2
   2e784:	f100 0508 	add.w	r5, r0, #8
   2e788:	2102      	movs	r1, #2
   2e78a:	4628      	mov	r0, r5
   2e78c:	f7f0 fcda 	bl	1f144 <net_buf_simple_add>
	write_req->handle = sys_cpu_to_le16(params->ccc_handle);
   2e790:	89e3      	ldrh	r3, [r4, #14]
   2e792:	8003      	strh	r3, [r0, #0]
	net_buf_simple_add_le16(&buf->b, val);
   2e794:	8a21      	ldrh	r1, [r4, #16]
   2e796:	4628      	mov	r0, r5
   2e798:	f000 fbbc 	bl	2ef14 <net_buf_simple_add_le16>
	atomic_set_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);
   2e79c:	3414      	adds	r4, #20
   2e79e:	f3bf 8f5b 	dmb	ish
   2e7a2:	e854 3f00 	ldrex	r3, [r4]
   2e7a6:	f043 0304 	orr.w	r3, r3, #4
   2e7aa:	e844 3200 	strex	r2, r3, [r4]
   2e7ae:	2a00      	cmp	r2, #0
   2e7b0:	d1f7      	bne.n	2e7a2 <gatt_write_ccc_buf+0x22>
   2e7b2:	f3bf 8f5b 	dmb	ish
}
   2e7b6:	2000      	movs	r0, #0
   2e7b8:	bd38      	pop	{r3, r4, r5, pc}

0002e7ba <add_subscriptions>:
{
   2e7ba:	b538      	push	{r3, r4, r5, lr}
   2e7bc:	4605      	mov	r5, r0
	sub = gatt_sub_find(conn);
   2e7be:	f7ee ff07 	bl	1d5d0 <gatt_sub_find>
	if (!sub) {
   2e7c2:	b300      	cbz	r0, 2e806 <add_subscriptions+0x4c>
   2e7c4:	6884      	ldr	r4, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   2e7c6:	b13c      	cbz	r4, 2e7d8 <add_subscriptions+0x1e>
   2e7c8:	3c18      	subs	r4, #24
   2e7ca:	e005      	b.n	2e7d8 <add_subscriptions+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e7cc:	f114 0318 	adds.w	r3, r4, #24
   2e7d0:	d017      	beq.n	2e802 <add_subscriptions+0x48>
	return node->next;
   2e7d2:	69a4      	ldr	r4, [r4, #24]
   2e7d4:	b1bc      	cbz	r4, 2e806 <add_subscriptions+0x4c>
   2e7d6:	3c18      	subs	r4, #24
   2e7d8:	b1ac      	cbz	r4, 2e806 <add_subscriptions+0x4c>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   2e7da:	f105 0190 	add.w	r1, r5, #144	; 0x90
   2e7de:	7a28      	ldrb	r0, [r5, #8]
   2e7e0:	f7fe fa80 	bl	2cce4 <bt_addr_le_is_bonded>
   2e7e4:	2800      	cmp	r0, #0
   2e7e6:	d0f1      	beq.n	2e7cc <add_subscriptions+0x12>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2e7e8:	f3bf 8f5b 	dmb	ish
   2e7ec:	6963      	ldr	r3, [r4, #20]
   2e7ee:	f3bf 8f5b 	dmb	ish
   2e7f2:	f013 0f02 	tst.w	r3, #2
   2e7f6:	d1e9      	bne.n	2e7cc <add_subscriptions+0x12>
			gatt_write_ccc(conn, params);
   2e7f8:	4621      	mov	r1, r4
   2e7fa:	4628      	mov	r0, r5
   2e7fc:	f7ee ffaa 	bl	1d754 <gatt_write_ccc>
   2e800:	e7e4      	b.n	2e7cc <add_subscriptions+0x12>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   2e802:	461c      	mov	r4, r3
   2e804:	e7e8      	b.n	2e7d8 <add_subscriptions+0x1e>
}
   2e806:	bd38      	pop	{r3, r4, r5, pc}

0002e808 <clear_ccc_cfg>:
{
   2e808:	b082      	sub	sp, #8
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   2e80a:	2300      	movs	r3, #0
   2e80c:	9300      	str	r3, [sp, #0]
   2e80e:	f8cd 3003 	str.w	r3, [sp, #3]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2e812:	f8c0 3001 	str.w	r3, [r0, #1]
   2e816:	6043      	str	r3, [r0, #4]
	cfg->id = 0U;
   2e818:	7003      	strb	r3, [r0, #0]
	cfg->value = 0U;
   2e81a:	8103      	strh	r3, [r0, #8]
}
   2e81c:	b002      	add	sp, #8
   2e81e:	4770      	bx	lr

0002e820 <gatt_sub_remove>:
{
   2e820:	b570      	push	{r4, r5, r6, lr}
   2e822:	460c      	mov	r4, r1
	if (params) {
   2e824:	b17b      	cbz	r3, 2e846 <gatt_sub_remove+0x26>
   2e826:	4619      	mov	r1, r3
		sys_slist_remove(&sub->list, prev, &params->node);
   2e828:	f104 0308 	add.w	r3, r4, #8
   2e82c:	f101 0518 	add.w	r5, r1, #24
Z_GENLIST_REMOVE(slist, snode)
   2e830:	b172      	cbz	r2, 2e850 <gatt_sub_remove+0x30>
	parent->next = child;
   2e832:	698e      	ldr	r6, [r1, #24]
   2e834:	6016      	str	r6, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2e836:	685e      	ldr	r6, [r3, #4]
   2e838:	42b5      	cmp	r5, r6
   2e83a:	d010      	beq.n	2e85e <gatt_sub_remove+0x3e>
	parent->next = child;
   2e83c:	2200      	movs	r2, #0
   2e83e:	618a      	str	r2, [r1, #24]
		params->notify(conn, params, NULL, 0);
   2e840:	680d      	ldr	r5, [r1, #0]
   2e842:	4613      	mov	r3, r2
   2e844:	47a8      	blx	r5
	if (gatt_sub_is_empty(sub)) {
   2e846:	4620      	mov	r0, r4
   2e848:	f7ff fe1f 	bl	2e48a <gatt_sub_is_empty>
   2e84c:	b948      	cbnz	r0, 2e862 <gatt_sub_remove+0x42>
}
   2e84e:	bd70      	pop	{r4, r5, r6, pc}
	return node->next;
   2e850:	698a      	ldr	r2, [r1, #24]
	list->head = node;
   2e852:	60a2      	str	r2, [r4, #8]
Z_GENLIST_REMOVE(slist, snode)
   2e854:	685e      	ldr	r6, [r3, #4]
   2e856:	42b5      	cmp	r5, r6
   2e858:	d1f0      	bne.n	2e83c <gatt_sub_remove+0x1c>
	list->tail = node;
   2e85a:	605a      	str	r2, [r3, #4]
}
   2e85c:	e7ee      	b.n	2e83c <gatt_sub_remove+0x1c>
	list->tail = node;
   2e85e:	605a      	str	r2, [r3, #4]
}
   2e860:	e7ec      	b.n	2e83c <gatt_sub_remove+0x1c>
		gatt_sub_free(sub);
   2e862:	4620      	mov	r0, r4
   2e864:	f7ee fff4 	bl	1d850 <gatt_sub_free>
}
   2e868:	e7f1      	b.n	2e84e <gatt_sub_remove+0x2e>

0002e86a <clear_cf_cfg>:
{
   2e86a:	b082      	sub	sp, #8
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   2e86c:	2300      	movs	r3, #0
   2e86e:	9300      	str	r3, [sp, #0]
   2e870:	f8cd 3003 	str.w	r3, [sp, #3]
   2e874:	f8c0 3001 	str.w	r3, [r0, #1]
   2e878:	6043      	str	r3, [r0, #4]
__ssp_bos_icheck3(memset, void *, int)
   2e87a:	7203      	strb	r3, [r0, #8]
	atomic_set(cfg->flags, 0);
   2e87c:	300c      	adds	r0, #12
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   2e87e:	f3bf 8f5b 	dmb	ish
   2e882:	e850 2f00 	ldrex	r2, [r0]
   2e886:	e840 3100 	strex	r1, r3, [r0]
   2e88a:	2900      	cmp	r1, #0
   2e88c:	d1f9      	bne.n	2e882 <clear_cf_cfg+0x18>
   2e88e:	f3bf 8f5b 	dmb	ish
}
   2e892:	b002      	add	sp, #8
   2e894:	4770      	bx	lr

0002e896 <gatt_sub_update>:
	if (sub->peer.type == BT_ADDR_LE_PUBLIC) {
   2e896:	784b      	ldrb	r3, [r1, #1]
   2e898:	b903      	cbnz	r3, 2e89c <gatt_sub_update+0x6>
}
   2e89a:	4770      	bx	lr
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2e89c:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
   2e8a0:	f8c1 3001 	str.w	r3, [r1, #1]
   2e8a4:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
   2e8a8:	f890 3096 	ldrb.w	r3, [r0, #150]	; 0x96
   2e8ac:	f8a1 2005 	strh.w	r2, [r1, #5]
   2e8b0:	71cb      	strb	r3, [r1, #7]
}
   2e8b2:	e7f2      	b.n	2e89a <gatt_sub_update+0x4>

0002e8b4 <remove_subscriptions>:
{
   2e8b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e8b8:	4606      	mov	r6, r0
	sub = gatt_sub_find(conn);
   2e8ba:	f7ee fe89 	bl	1d5d0 <gatt_sub_find>
	if (!sub) {
   2e8be:	2800      	cmp	r0, #0
   2e8c0:	d03b      	beq.n	2e93a <remove_subscriptions+0x86>
   2e8c2:	4607      	mov	r7, r0
	return list->head;
   2e8c4:	6885      	ldr	r5, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   2e8c6:	b385      	cbz	r5, 2e92a <remove_subscriptions+0x76>
   2e8c8:	3d18      	subs	r5, #24
   2e8ca:	d032      	beq.n	2e932 <remove_subscriptions+0x7e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e8cc:	f115 0418 	adds.w	r4, r5, #24
   2e8d0:	d02c      	beq.n	2e92c <remove_subscriptions+0x78>
	return node->next;
   2e8d2:	69ac      	ldr	r4, [r5, #24]
   2e8d4:	b354      	cbz	r4, 2e92c <remove_subscriptions+0x78>
   2e8d6:	3c18      	subs	r4, #24
   2e8d8:	e028      	b.n	2e92c <remove_subscriptions+0x78>
			params->value = 0U;
   2e8da:	2300      	movs	r3, #0
   2e8dc:	822b      	strh	r3, [r5, #16]
			gatt_sub_remove(conn, sub, prev, params);
   2e8de:	462b      	mov	r3, r5
   2e8e0:	4642      	mov	r2, r8
   2e8e2:	4639      	mov	r1, r7
   2e8e4:	4630      	mov	r0, r6
   2e8e6:	f7ff ff9b 	bl	2e820 <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   2e8ea:	b324      	cbz	r4, 2e936 <remove_subscriptions+0x82>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2e8ec:	f114 0318 	adds.w	r3, r4, #24
   2e8f0:	d002      	beq.n	2e8f8 <remove_subscriptions+0x44>
	return node->next;
   2e8f2:	69a3      	ldr	r3, [r4, #24]
   2e8f4:	b103      	cbz	r3, 2e8f8 <remove_subscriptions+0x44>
   2e8f6:	3b18      	subs	r3, #24
   2e8f8:	4625      	mov	r5, r4
   2e8fa:	461c      	mov	r4, r3
   2e8fc:	b1ed      	cbz	r5, 2e93a <remove_subscriptions+0x86>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   2e8fe:	f106 0190 	add.w	r1, r6, #144	; 0x90
   2e902:	7a30      	ldrb	r0, [r6, #8]
   2e904:	f7fe f9ee 	bl	2cce4 <bt_addr_le_is_bonded>
   2e908:	2800      	cmp	r0, #0
   2e90a:	d0e6      	beq.n	2e8da <remove_subscriptions+0x26>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2e90c:	f3bf 8f5b 	dmb	ish
   2e910:	696b      	ldr	r3, [r5, #20]
   2e912:	f3bf 8f5b 	dmb	ish
   2e916:	f013 0f01 	tst.w	r3, #1
   2e91a:	d1de      	bne.n	2e8da <remove_subscriptions+0x26>
			gatt_sub_update(conn, sub);
   2e91c:	4639      	mov	r1, r7
   2e91e:	4630      	mov	r0, r6
   2e920:	f7ff ffb9 	bl	2e896 <gatt_sub_update>
			prev = &params->node;
   2e924:	f105 0818 	add.w	r8, r5, #24
   2e928:	e7df      	b.n	2e8ea <remove_subscriptions+0x36>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   2e92a:	462c      	mov	r4, r5
   2e92c:	f04f 0800 	mov.w	r8, #0
   2e930:	e7e4      	b.n	2e8fc <remove_subscriptions+0x48>
   2e932:	462c      	mov	r4, r5
   2e934:	e7fa      	b.n	2e92c <remove_subscriptions+0x78>
   2e936:	4623      	mov	r3, r4
   2e938:	e7de      	b.n	2e8f8 <remove_subscriptions+0x44>
}
   2e93a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002e93e <remove_cf_cfg>:
{
   2e93e:	b570      	push	{r4, r5, r6, lr}
   2e940:	4604      	mov	r4, r0
	cfg = find_cf_cfg(conn);
   2e942:	f7ee fdf7 	bl	1d534 <find_cf_cfg>
	if (!cfg) {
   2e946:	b150      	cbz	r0, 2e95e <remove_cf_cfg+0x20>
   2e948:	4605      	mov	r5, r0
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   2e94a:	f104 0690 	add.w	r6, r4, #144	; 0x90
   2e94e:	4631      	mov	r1, r6
   2e950:	7a20      	ldrb	r0, [r4, #8]
   2e952:	f7fe f9c7 	bl	2cce4 <bt_addr_le_is_bonded>
   2e956:	b918      	cbnz	r0, 2e960 <remove_cf_cfg+0x22>
		clear_cf_cfg(cfg);
   2e958:	4628      	mov	r0, r5
   2e95a:	f7ff ff86 	bl	2e86a <clear_cf_cfg>
}
   2e95e:	bd70      	pop	{r4, r5, r6, pc}
   2e960:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   2e964:	f8c5 3001 	str.w	r3, [r5, #1]
   2e968:	88b2      	ldrh	r2, [r6, #4]
   2e96a:	79b3      	ldrb	r3, [r6, #6]
   2e96c:	f8a5 2005 	strh.w	r2, [r5, #5]
   2e970:	71eb      	strb	r3, [r5, #7]
   2e972:	e7f4      	b.n	2e95e <remove_cf_cfg+0x20>

0002e974 <sc_ccc_cfg_write>:
{
   2e974:	b508      	push	{r3, lr}
	if (value == BT_GATT_CCC_INDICATE) {
   2e976:	2a02      	cmp	r2, #2
   2e978:	d003      	beq.n	2e982 <sc_ccc_cfg_write+0xe>
		sc_clear(conn);
   2e97a:	f7ee fe53 	bl	1d624 <sc_clear>
}
   2e97e:	2002      	movs	r0, #2
   2e980:	bd08      	pop	{r3, pc}
		sc_save(conn->id, &conn->le.dst, 0, 0);
   2e982:	2300      	movs	r3, #0
   2e984:	461a      	mov	r2, r3
   2e986:	f100 0190 	add.w	r1, r0, #144	; 0x90
   2e98a:	7a00      	ldrb	r0, [r0, #8]
   2e98c:	f7ef f81a 	bl	1d9c4 <sc_save>
   2e990:	e7f5      	b.n	2e97e <sc_ccc_cfg_write+0xa>

0002e992 <bt_gatt_attr_read>:
{
   2e992:	b510      	push	{r4, lr}
   2e994:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   2e998:	f8bd 4010 	ldrh.w	r4, [sp, #16]
	if (offset > value_len) {
   2e99c:	428c      	cmp	r4, r1
   2e99e:	d30c      	bcc.n	2e9ba <bt_gatt_attr_read+0x28>
   2e9a0:	4610      	mov	r0, r2
	len = MIN(buf_len, value_len - offset);
   2e9a2:	1a64      	subs	r4, r4, r1
   2e9a4:	42a3      	cmp	r3, r4
   2e9a6:	bfa8      	it	ge
   2e9a8:	4623      	movge	r3, r4
	memcpy(buf, (uint8_t *)value + offset, len);
   2e9aa:	b29c      	uxth	r4, r3
   2e9ac:	4622      	mov	r2, r4
   2e9ae:	9b03      	ldr	r3, [sp, #12]
   2e9b0:	4419      	add	r1, r3
   2e9b2:	f002 fa58 	bl	30e66 <memcpy>
	return len;
   2e9b6:	4620      	mov	r0, r4
}
   2e9b8:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2e9ba:	f06f 0006 	mvn.w	r0, #6
   2e9be:	e7fb      	b.n	2e9b8 <bt_gatt_attr_read+0x26>

0002e9c0 <read_ppcp>:
{
   2e9c0:	b510      	push	{r4, lr}
   2e9c2:	b086      	sub	sp, #24
	ppcp.min_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MIN_INT);
   2e9c4:	2418      	movs	r4, #24
   2e9c6:	f8ad 4010 	strh.w	r4, [sp, #16]
	ppcp.max_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MAX_INT);
   2e9ca:	2428      	movs	r4, #40	; 0x28
   2e9cc:	f8ad 4012 	strh.w	r4, [sp, #18]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
   2e9d0:	2400      	movs	r4, #0
   2e9d2:	f8ad 4014 	strh.w	r4, [sp, #20]
	ppcp.timeout = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);
   2e9d6:	242a      	movs	r4, #42	; 0x2a
   2e9d8:	f8ad 4016 	strh.w	r4, [sp, #22]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   2e9dc:	2408      	movs	r4, #8
   2e9de:	9402      	str	r4, [sp, #8]
   2e9e0:	ac04      	add	r4, sp, #16
   2e9e2:	9401      	str	r4, [sp, #4]
   2e9e4:	f8bd 4020 	ldrh.w	r4, [sp, #32]
   2e9e8:	9400      	str	r4, [sp, #0]
   2e9ea:	f7ff ffd2 	bl	2e992 <bt_gatt_attr_read>
}
   2e9ee:	b006      	add	sp, #24
   2e9f0:	bd10      	pop	{r4, pc}

0002e9f2 <read_appearance>:
{
   2e9f2:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e9f4:	b087      	sub	sp, #28
   2e9f6:	4604      	mov	r4, r0
   2e9f8:	460d      	mov	r5, r1
   2e9fa:	4616      	mov	r6, r2
   2e9fc:	461f      	mov	r7, r3
	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
   2e9fe:	f7fe f96e 	bl	2ccde <bt_get_appearance>
   2ea02:	f8ad 0016 	strh.w	r0, [sp, #22]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   2ea06:	2302      	movs	r3, #2
   2ea08:	9302      	str	r3, [sp, #8]
   2ea0a:	f10d 0316 	add.w	r3, sp, #22
   2ea0e:	9301      	str	r3, [sp, #4]
   2ea10:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   2ea14:	9300      	str	r3, [sp, #0]
   2ea16:	463b      	mov	r3, r7
   2ea18:	4632      	mov	r2, r6
   2ea1a:	4629      	mov	r1, r5
   2ea1c:	4620      	mov	r0, r4
   2ea1e:	f7ff ffb8 	bl	2e992 <bt_gatt_attr_read>
}
   2ea22:	b007      	add	sp, #28
   2ea24:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002ea26 <read_name>:
{
   2ea26:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ea2a:	b084      	sub	sp, #16
   2ea2c:	4604      	mov	r4, r0
   2ea2e:	460d      	mov	r5, r1
   2ea30:	4616      	mov	r6, r2
   2ea32:	461f      	mov	r7, r3
	const char *name = bt_get_name();
   2ea34:	f7eb fe90 	bl	1a758 <bt_get_name>
   2ea38:	4680      	mov	r8, r0
				 strlen(name));
   2ea3a:	f7de f936 	bl	ccaa <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   2ea3e:	b280      	uxth	r0, r0
   2ea40:	9002      	str	r0, [sp, #8]
   2ea42:	f8cd 8004 	str.w	r8, [sp, #4]
   2ea46:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   2ea4a:	9300      	str	r3, [sp, #0]
   2ea4c:	463b      	mov	r3, r7
   2ea4e:	4632      	mov	r2, r6
   2ea50:	4629      	mov	r1, r5
   2ea52:	4620      	mov	r0, r4
   2ea54:	f7ff ff9d 	bl	2e992 <bt_gatt_attr_read>
}
   2ea58:	b004      	add	sp, #16
   2ea5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002ea5e <cf_read>:
{
   2ea5e:	b5f0      	push	{r4, r5, r6, r7, lr}
   2ea60:	b087      	sub	sp, #28
   2ea62:	4604      	mov	r4, r0
   2ea64:	460d      	mov	r5, r1
   2ea66:	4616      	mov	r6, r2
   2ea68:	461f      	mov	r7, r3
	uint8_t data[1] = {};
   2ea6a:	2300      	movs	r3, #0
   2ea6c:	f88d 3014 	strb.w	r3, [sp, #20]
	cfg = find_cf_cfg(conn);
   2ea70:	f7ee fd60 	bl	1d534 <find_cf_cfg>
	if (cfg) {
   2ea74:	b110      	cbz	r0, 2ea7c <cf_read+0x1e>
		memcpy(data, cfg->data, sizeof(data));
   2ea76:	7a03      	ldrb	r3, [r0, #8]
   2ea78:	f88d 3014 	strb.w	r3, [sp, #20]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   2ea7c:	2301      	movs	r3, #1
   2ea7e:	9302      	str	r3, [sp, #8]
   2ea80:	ab05      	add	r3, sp, #20
   2ea82:	9301      	str	r3, [sp, #4]
   2ea84:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   2ea88:	9300      	str	r3, [sp, #0]
   2ea8a:	463b      	mov	r3, r7
   2ea8c:	4632      	mov	r2, r6
   2ea8e:	4629      	mov	r1, r5
   2ea90:	4620      	mov	r0, r4
   2ea92:	f7ff ff7e 	bl	2e992 <bt_gatt_attr_read>
}
   2ea96:	b007      	add	sp, #28
   2ea98:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002ea9a <bt_gatt_attr_read_service>:
{
   2ea9a:	b570      	push	{r4, r5, r6, lr}
   2ea9c:	b086      	sub	sp, #24
   2ea9e:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
	struct bt_uuid *uuid = attr->user_data;
   2eaa2:	68cc      	ldr	r4, [r1, #12]
	if (uuid->type == BT_UUID_TYPE_16) {
   2eaa4:	7826      	ldrb	r6, [r4, #0]
   2eaa6:	b146      	cbz	r6, 2eaba <bt_gatt_attr_read_service+0x20>
				 BT_UUID_128(uuid)->val, 16);
   2eaa8:	3401      	adds	r4, #1
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   2eaaa:	2610      	movs	r6, #16
   2eaac:	9602      	str	r6, [sp, #8]
   2eaae:	9401      	str	r4, [sp, #4]
   2eab0:	9500      	str	r5, [sp, #0]
   2eab2:	f7ff ff6e 	bl	2e992 <bt_gatt_attr_read>
}
   2eab6:	b006      	add	sp, #24
   2eab8:	bd70      	pop	{r4, r5, r6, pc}
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   2eaba:	8864      	ldrh	r4, [r4, #2]
   2eabc:	f8ad 4016 	strh.w	r4, [sp, #22]
		return bt_gatt_attr_read(conn, attr, buf, len, offset,
   2eac0:	2402      	movs	r4, #2
   2eac2:	9402      	str	r4, [sp, #8]
   2eac4:	f10d 0416 	add.w	r4, sp, #22
   2eac8:	9401      	str	r4, [sp, #4]
   2eaca:	9500      	str	r5, [sp, #0]
   2eacc:	f7ff ff61 	bl	2e992 <bt_gatt_attr_read>
   2ead0:	e7f1      	b.n	2eab6 <bt_gatt_attr_read_service+0x1c>

0002ead2 <bt_gatt_attr_read_ccc>:
{
   2ead2:	b5f0      	push	{r4, r5, r6, r7, lr}
   2ead4:	b087      	sub	sp, #28
   2ead6:	4605      	mov	r5, r0
   2ead8:	460c      	mov	r4, r1
   2eada:	4616      	mov	r6, r2
   2eadc:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   2eade:	68c9      	ldr	r1, [r1, #12]
   2eae0:	f7ff fd6d 	bl	2e5be <find_ccc_cfg>
	if (cfg) {
   2eae4:	b190      	cbz	r0, 2eb0c <bt_gatt_attr_read_ccc+0x3a>
		value = sys_cpu_to_le16(cfg->value);
   2eae6:	8903      	ldrh	r3, [r0, #8]
   2eae8:	f8ad 3016 	strh.w	r3, [sp, #22]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   2eaec:	2302      	movs	r3, #2
   2eaee:	9302      	str	r3, [sp, #8]
   2eaf0:	f10d 0316 	add.w	r3, sp, #22
   2eaf4:	9301      	str	r3, [sp, #4]
   2eaf6:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   2eafa:	9300      	str	r3, [sp, #0]
   2eafc:	463b      	mov	r3, r7
   2eafe:	4632      	mov	r2, r6
   2eb00:	4621      	mov	r1, r4
   2eb02:	4628      	mov	r0, r5
   2eb04:	f7ff ff45 	bl	2e992 <bt_gatt_attr_read>
}
   2eb08:	b007      	add	sp, #28
   2eb0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		value = 0x0000;
   2eb0c:	2300      	movs	r3, #0
   2eb0e:	f8ad 3016 	strh.w	r3, [sp, #22]
   2eb12:	e7eb      	b.n	2eaec <bt_gatt_attr_read_ccc+0x1a>

0002eb14 <bt_gatt_attr_value_handle>:
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   2eb14:	b1b8      	cbz	r0, 2eb46 <bt_gatt_attr_value_handle+0x32>
{
   2eb16:	b510      	push	{r4, lr}
   2eb18:	b082      	sub	sp, #8
   2eb1a:	4604      	mov	r4, r0
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   2eb1c:	2300      	movs	r3, #0
   2eb1e:	f88d 3004 	strb.w	r3, [sp, #4]
   2eb22:	f642 0303 	movw	r3, #10243	; 0x2803
   2eb26:	f8ad 3006 	strh.w	r3, [sp, #6]
   2eb2a:	a901      	add	r1, sp, #4
   2eb2c:	6800      	ldr	r0, [r0, #0]
   2eb2e:	f7fd ff25 	bl	2c97c <bt_uuid_cmp>
   2eb32:	b950      	cbnz	r0, 2eb4a <bt_gatt_attr_value_handle+0x36>
		struct bt_gatt_chrc *chrc = attr->user_data;
   2eb34:	68e3      	ldr	r3, [r4, #12]
		handle = chrc->value_handle;
   2eb36:	8898      	ldrh	r0, [r3, #4]
		if (handle == 0) {
   2eb38:	b940      	cbnz	r0, 2eb4c <bt_gatt_attr_value_handle+0x38>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
   2eb3a:	4620      	mov	r0, r4
   2eb3c:	f7ef f814 	bl	1db68 <bt_gatt_attr_get_handle>
   2eb40:	3001      	adds	r0, #1
   2eb42:	b280      	uxth	r0, r0
   2eb44:	e002      	b.n	2eb4c <bt_gatt_attr_value_handle+0x38>
	uint16_t handle = 0;
   2eb46:	2000      	movs	r0, #0
}
   2eb48:	4770      	bx	lr
	uint16_t handle = 0;
   2eb4a:	2000      	movs	r0, #0
}
   2eb4c:	b002      	add	sp, #8
   2eb4e:	bd10      	pop	{r4, pc}

0002eb50 <bt_gatt_attr_read_chrc>:
{
   2eb50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2eb54:	b08a      	sub	sp, #40	; 0x28
   2eb56:	4605      	mov	r5, r0
   2eb58:	460c      	mov	r4, r1
   2eb5a:	4616      	mov	r6, r2
   2eb5c:	461f      	mov	r7, r3
	struct bt_gatt_chrc *chrc = attr->user_data;
   2eb5e:	f8d1 800c 	ldr.w	r8, [r1, #12]
	pdu.properties = chrc->properties;
   2eb62:	f898 3006 	ldrb.w	r3, [r8, #6]
   2eb66:	f88d 3014 	strb.w	r3, [sp, #20]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   2eb6a:	4608      	mov	r0, r1
   2eb6c:	f7ff ffd2 	bl	2eb14 <bt_gatt_attr_value_handle>
   2eb70:	f8ad 0015 	strh.w	r0, [sp, #21]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   2eb74:	f8d8 1000 	ldr.w	r1, [r8]
   2eb78:	780b      	ldrb	r3, [r1, #0]
   2eb7a:	b993      	cbnz	r3, 2eba2 <bt_gatt_attr_read_chrc+0x52>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   2eb7c:	884b      	ldrh	r3, [r1, #2]
   2eb7e:	f8ad 3017 	strh.w	r3, [sp, #23]
		value_len += 2U;
   2eb82:	2305      	movs	r3, #5
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   2eb84:	9302      	str	r3, [sp, #8]
   2eb86:	ab05      	add	r3, sp, #20
   2eb88:	9301      	str	r3, [sp, #4]
   2eb8a:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   2eb8e:	9300      	str	r3, [sp, #0]
   2eb90:	463b      	mov	r3, r7
   2eb92:	4632      	mov	r2, r6
   2eb94:	4621      	mov	r1, r4
   2eb96:	4628      	mov	r0, r5
   2eb98:	f7ff fefb 	bl	2e992 <bt_gatt_attr_read>
}
   2eb9c:	b00a      	add	sp, #40	; 0x28
   2eb9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   2eba2:	f8d1 c001 	ldr.w	ip, [r1, #1]
   2eba6:	f8d1 0005 	ldr.w	r0, [r1, #5]
   2ebaa:	f8d1 2009 	ldr.w	r2, [r1, #9]
   2ebae:	f8d1 300d 	ldr.w	r3, [r1, #13]
   2ebb2:	f8cd c017 	str.w	ip, [sp, #23]
   2ebb6:	f8cd 001b 	str.w	r0, [sp, #27]
   2ebba:	f8cd 201f 	str.w	r2, [sp, #31]
   2ebbe:	f8cd 3023 	str.w	r3, [sp, #35]	; 0x23
		value_len += 16U;
   2ebc2:	2313      	movs	r3, #19
   2ebc4:	e7de      	b.n	2eb84 <bt_gatt_attr_read_chrc+0x34>

0002ebc6 <db_hash_process>:
{
   2ebc6:	b508      	push	{r3, lr}
	db_hash_gen(true);
   2ebc8:	2001      	movs	r0, #1
   2ebca:	f7ef f873 	bl	1dcb4 <db_hash_gen>
}
   2ebce:	bd08      	pop	{r3, pc}

0002ebd0 <bt_gatt_get_mtu>:
{
   2ebd0:	b508      	push	{r3, lr}
	return bt_att_get_mtu(conn);
   2ebd2:	f7ff fa76 	bl	2e0c2 <bt_att_get_mtu>
}
   2ebd6:	bd08      	pop	{r3, pc}

0002ebd8 <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   2ebd8:	f012 0f01 	tst.w	r2, #1
   2ebdc:	d005      	beq.n	2ebea <bt_gatt_check_perm+0x12>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   2ebde:	8a4b      	ldrh	r3, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   2ebe0:	f013 0f95 	tst.w	r3, #149	; 0x95
   2ebe4:	d01e      	beq.n	2ec24 <bt_gatt_check_perm+0x4c>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   2ebe6:	684b      	ldr	r3, [r1, #4]
   2ebe8:	b1f3      	cbz	r3, 2ec28 <bt_gatt_check_perm+0x50>
	if ((mask & BT_GATT_PERM_WRITE) &&
   2ebea:	f012 0f02 	tst.w	r2, #2
   2ebee:	d005      	beq.n	2ebfc <bt_gatt_check_perm+0x24>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   2ebf0:	8a4b      	ldrh	r3, [r1, #18]
	if ((mask & BT_GATT_PERM_WRITE) &&
   2ebf2:	f413 7f95 	tst.w	r3, #298	; 0x12a
   2ebf6:	d019      	beq.n	2ec2c <bt_gatt_check_perm+0x54>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   2ebf8:	688b      	ldr	r3, [r1, #8]
   2ebfa:	b1cb      	cbz	r3, 2ec30 <bt_gatt_check_perm+0x58>
{
   2ebfc:	b510      	push	{r4, lr}
	mask &= attr->perm;
   2ebfe:	8a4c      	ldrh	r4, [r1, #18]
   2ec00:	4014      	ands	r4, r2
	if (mask & BT_GATT_PERM_LESC_MASK) {
   2ec02:	f414 7fc0 	tst.w	r4, #384	; 0x180
   2ec06:	d115      	bne.n	2ec34 <bt_gatt_check_perm+0x5c>
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   2ec08:	f014 0f30 	tst.w	r4, #48	; 0x30
   2ec0c:	d104      	bne.n	2ec18 <bt_gatt_check_perm+0x40>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
   2ec0e:	f014 0f0c 	tst.w	r4, #12
   2ec12:	d111      	bne.n	2ec38 <bt_gatt_check_perm+0x60>
	return 0;
   2ec14:	2000      	movs	r0, #0
}
   2ec16:	bd10      	pop	{r4, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   2ec18:	f7fe fafd 	bl	2d216 <bt_conn_get_security>
   2ec1c:	2802      	cmp	r0, #2
   2ec1e:	d8f6      	bhi.n	2ec0e <bt_gatt_check_perm+0x36>
			return BT_ATT_ERR_AUTHENTICATION;
   2ec20:	2005      	movs	r0, #5
   2ec22:	e7f8      	b.n	2ec16 <bt_gatt_check_perm+0x3e>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   2ec24:	2002      	movs	r0, #2
   2ec26:	4770      	bx	lr
   2ec28:	2002      	movs	r0, #2
   2ec2a:	4770      	bx	lr
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   2ec2c:	2003      	movs	r0, #3
   2ec2e:	4770      	bx	lr
   2ec30:	2003      	movs	r0, #3
}
   2ec32:	4770      	bx	lr
			return BT_ATT_ERR_AUTHENTICATION;
   2ec34:	2005      	movs	r0, #5
   2ec36:	e7ee      	b.n	2ec16 <bt_gatt_check_perm+0x3e>
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   2ec38:	200f      	movs	r0, #15
   2ec3a:	e7ec      	b.n	2ec16 <bt_gatt_check_perm+0x3e>

0002ec3c <bt_gatt_cancel>:
{
   2ec3c:	b570      	push	{r4, r5, r6, lr}
   2ec3e:	b082      	sub	sp, #8
   2ec40:	4604      	mov	r4, r0
   2ec42:	460d      	mov	r5, r1
	k_sched_lock();
   2ec44:	f7f9 f8de 	bl	27e04 <k_sched_lock>
	req = bt_att_find_req_by_user_data(conn, params);
   2ec48:	4629      	mov	r1, r5
   2ec4a:	4620      	mov	r0, r4
   2ec4c:	f7ff fb30 	bl	2e2b0 <bt_att_find_req_by_user_data>
	if (req) {
   2ec50:	b178      	cbz	r0, 2ec72 <bt_gatt_cancel+0x36>
   2ec52:	4601      	mov	r1, r0
		func = req->func;
   2ec54:	6846      	ldr	r6, [r0, #4]
		bt_att_req_cancel(conn, req);
   2ec56:	4620      	mov	r0, r4
   2ec58:	f7ff fade 	bl	2e218 <bt_att_req_cancel>
	k_sched_unlock();
   2ec5c:	f7f9 fde6 	bl	2882c <k_sched_unlock>
	if (func) {
   2ec60:	b12e      	cbz	r6, 2ec6e <bt_gatt_cancel+0x32>
		func(conn, BT_ATT_ERR_UNLIKELY, NULL, 0, params);
   2ec62:	9500      	str	r5, [sp, #0]
   2ec64:	2300      	movs	r3, #0
   2ec66:	461a      	mov	r2, r3
   2ec68:	210e      	movs	r1, #14
   2ec6a:	4620      	mov	r0, r4
   2ec6c:	47b0      	blx	r6
}
   2ec6e:	b002      	add	sp, #8
   2ec70:	bd70      	pop	{r4, r5, r6, pc}
	k_sched_unlock();
   2ec72:	f7f9 fddb 	bl	2882c <k_sched_unlock>
	if (func) {
   2ec76:	e7fa      	b.n	2ec6e <bt_gatt_cancel+0x32>

0002ec78 <bt_gatt_notification>:
{
   2ec78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2ec7c:	4680      	mov	r8, r0
   2ec7e:	460f      	mov	r7, r1
   2ec80:	4691      	mov	r9, r2
   2ec82:	469a      	mov	sl, r3
	sub = gatt_sub_find(conn);
   2ec84:	f7ee fca4 	bl	1d5d0 <gatt_sub_find>
	if (!sub) {
   2ec88:	b380      	cbz	r0, 2ecec <bt_gatt_notification+0x74>
	return list->head;
   2ec8a:	6885      	ldr	r5, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   2ec8c:	b145      	cbz	r5, 2eca0 <bt_gatt_notification+0x28>
   2ec8e:	3d18      	subs	r5, #24
   2ec90:	d008      	beq.n	2eca4 <bt_gatt_notification+0x2c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2ec92:	f115 0418 	adds.w	r4, r5, #24
   2ec96:	d010      	beq.n	2ecba <bt_gatt_notification+0x42>
	return node->next;
   2ec98:	69ac      	ldr	r4, [r5, #24]
   2ec9a:	b174      	cbz	r4, 2ecba <bt_gatt_notification+0x42>
   2ec9c:	3c18      	subs	r4, #24
   2ec9e:	e00c      	b.n	2ecba <bt_gatt_notification+0x42>
   2eca0:	462c      	mov	r4, r5
   2eca2:	e00a      	b.n	2ecba <bt_gatt_notification+0x42>
   2eca4:	462c      	mov	r4, r5
   2eca6:	e008      	b.n	2ecba <bt_gatt_notification+0x42>
   2eca8:	b1f4      	cbz	r4, 2ece8 <bt_gatt_notification+0x70>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2ecaa:	f114 0618 	adds.w	r6, r4, #24
   2ecae:	d002      	beq.n	2ecb6 <bt_gatt_notification+0x3e>
	return node->next;
   2ecb0:	69a6      	ldr	r6, [r4, #24]
   2ecb2:	b106      	cbz	r6, 2ecb6 <bt_gatt_notification+0x3e>
   2ecb4:	3e18      	subs	r6, #24
   2ecb6:	4625      	mov	r5, r4
   2ecb8:	4634      	mov	r4, r6
   2ecba:	b1bd      	cbz	r5, 2ecec <bt_gatt_notification+0x74>
		if (handle != params->value_handle) {
   2ecbc:	89ab      	ldrh	r3, [r5, #12]
   2ecbe:	429f      	cmp	r7, r3
   2ecc0:	d1f2      	bne.n	2eca8 <bt_gatt_notification+0x30>
		if (check_subscribe_security_level(conn, params)) {
   2ecc2:	4629      	mov	r1, r5
   2ecc4:	4640      	mov	r0, r8
   2ecc6:	f7ff fbe5 	bl	2e494 <check_subscribe_security_level>
   2ecca:	2800      	cmp	r0, #0
   2eccc:	d0ec      	beq.n	2eca8 <bt_gatt_notification+0x30>
			if (params->notify(conn, params, data, length) ==
   2ecce:	682e      	ldr	r6, [r5, #0]
   2ecd0:	4653      	mov	r3, sl
   2ecd2:	464a      	mov	r2, r9
   2ecd4:	4629      	mov	r1, r5
   2ecd6:	4640      	mov	r0, r8
   2ecd8:	47b0      	blx	r6
   2ecda:	2800      	cmp	r0, #0
   2ecdc:	d1e4      	bne.n	2eca8 <bt_gatt_notification+0x30>
				bt_gatt_unsubscribe(conn, params);
   2ecde:	4629      	mov	r1, r5
   2ece0:	4640      	mov	r0, r8
   2ece2:	f7ef fd0d 	bl	1e700 <bt_gatt_unsubscribe>
   2ece6:	e7df      	b.n	2eca8 <bt_gatt_notification+0x30>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   2ece8:	4626      	mov	r6, r4
   2ecea:	e7e4      	b.n	2ecb6 <bt_gatt_notification+0x3e>
}
   2ecec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0002ecf0 <bt_gatt_change_aware>:
{
   2ecf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ecf2:	4606      	mov	r6, r0
   2ecf4:	460d      	mov	r5, r1
	cfg = find_cf_cfg(conn);
   2ecf6:	f7ee fc1d 	bl	1d534 <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   2ecfa:	2800      	cmp	r0, #0
   2ecfc:	d05c      	beq.n	2edb8 <bt_gatt_change_aware+0xc8>
   2ecfe:	7a02      	ldrb	r2, [r0, #8]
   2ed00:	f012 0f01 	tst.w	r2, #1
   2ed04:	d102      	bne.n	2ed0c <bt_gatt_change_aware+0x1c>
		return true;
   2ed06:	2401      	movs	r4, #1
}
   2ed08:	4620      	mov	r0, r4
   2ed0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   2ed0c:	f100 070c 	add.w	r7, r0, #12
   2ed10:	f3bf 8f5b 	dmb	ish
   2ed14:	68c4      	ldr	r4, [r0, #12]
   2ed16:	f3bf 8f5b 	dmb	ish
   2ed1a:	f014 0401 	ands.w	r4, r4, #1
   2ed1e:	d1f3      	bne.n	2ed08 <bt_gatt_change_aware+0x18>
	if (!req) {
   2ed20:	b90d      	cbnz	r5, 2ed26 <bt_gatt_change_aware+0x36>
		return false;
   2ed22:	462c      	mov	r4, r5
   2ed24:	e7f0      	b.n	2ed08 <bt_gatt_change_aware+0x18>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2ed26:	f3bf 8f5b 	dmb	ish
   2ed2a:	e857 3f00 	ldrex	r3, [r7]
   2ed2e:	f023 0202 	bic.w	r2, r3, #2
   2ed32:	e847 2100 	strex	r1, r2, [r7]
   2ed36:	2900      	cmp	r1, #0
   2ed38:	d1f7      	bne.n	2ed2a <bt_gatt_change_aware+0x3a>
   2ed3a:	f3bf 8f5b 	dmb	ish
	return (old & mask) != 0;
   2ed3e:	f3c3 0440 	ubfx	r4, r3, #1, #1
	if (atomic_test_and_clear_bit(cfg->flags, CF_DB_HASH_READ)) {
   2ed42:	f013 0f02 	tst.w	r3, #2
   2ed46:	d127      	bne.n	2ed98 <bt_gatt_change_aware+0xa8>
	if (bt_att_fixed_chan_only(conn) && bt_att_out_of_sync_sent_on_fixed(conn)) {
   2ed48:	4630      	mov	r0, r6
   2ed4a:	f7ff fada 	bl	2e302 <bt_att_fixed_chan_only>
   2ed4e:	4604      	mov	r4, r0
   2ed50:	2800      	cmp	r0, #0
   2ed52:	d0d9      	beq.n	2ed08 <bt_gatt_change_aware+0x18>
   2ed54:	4630      	mov	r0, r6
   2ed56:	f7ff faf7 	bl	2e348 <bt_att_out_of_sync_sent_on_fixed>
   2ed5a:	4604      	mov	r4, r0
   2ed5c:	2800      	cmp	r0, #0
   2ed5e:	d0d3      	beq.n	2ed08 <bt_gatt_change_aware+0x18>
   2ed60:	f3bf 8f5b 	dmb	ish
   2ed64:	e857 3f00 	ldrex	r3, [r7]
   2ed68:	f023 0302 	bic.w	r3, r3, #2
   2ed6c:	e847 3200 	strex	r2, r3, [r7]
   2ed70:	2a00      	cmp	r2, #0
   2ed72:	d1f7      	bne.n	2ed64 <bt_gatt_change_aware+0x74>
   2ed74:	f3bf 8f5b 	dmb	ish
		bt_att_clear_out_of_sync_sent(conn);
   2ed78:	4630      	mov	r0, r6
   2ed7a:	f7ff fac4 	bl	2e306 <bt_att_clear_out_of_sync_sent>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2ed7e:	f3bf 8f5b 	dmb	ish
   2ed82:	e857 3f00 	ldrex	r3, [r7]
   2ed86:	f043 0301 	orr.w	r3, r3, #1
   2ed8a:	e847 3200 	strex	r2, r3, [r7]
   2ed8e:	2a00      	cmp	r2, #0
   2ed90:	d1f7      	bne.n	2ed82 <bt_gatt_change_aware+0x92>
   2ed92:	f3bf 8f5b 	dmb	ish
		return true;
   2ed96:	e7b7      	b.n	2ed08 <bt_gatt_change_aware+0x18>
		bt_att_clear_out_of_sync_sent(conn);
   2ed98:	4630      	mov	r0, r6
   2ed9a:	f7ff fab4 	bl	2e306 <bt_att_clear_out_of_sync_sent>
   2ed9e:	f3bf 8f5b 	dmb	ish
   2eda2:	e857 3f00 	ldrex	r3, [r7]
   2eda6:	f043 0301 	orr.w	r3, r3, #1
   2edaa:	e847 3200 	strex	r2, r3, [r7]
   2edae:	2a00      	cmp	r2, #0
   2edb0:	d1f7      	bne.n	2eda2 <bt_gatt_change_aware+0xb2>
   2edb2:	f3bf 8f5b 	dmb	ish
		return true;
   2edb6:	e7a7      	b.n	2ed08 <bt_gatt_change_aware+0x18>
		return true;
   2edb8:	2401      	movs	r4, #1
   2edba:	e7a5      	b.n	2ed08 <bt_gatt_change_aware+0x18>

0002edbc <bt_smp_recv>:
{
   2edbc:	b5f0      	push	{r4, r5, r6, r7, lr}
   2edbe:	b083      	sub	sp, #12
	struct bt_conn *conn = chan->conn;
   2edc0:	6807      	ldr	r7, [r0, #0]
	buf = bt_l2cap_create_pdu(NULL, 0);
   2edc2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2edc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2edca:	2100      	movs	r1, #0
   2edcc:	4608      	mov	r0, r1
   2edce:	f7fe fade 	bl	2d38e <bt_l2cap_create_pdu_timeout>
   2edd2:	4604      	mov	r4, r0
	return net_buf_simple_add(&buf->b, len);
   2edd4:	f100 0608 	add.w	r6, r0, #8
   2edd8:	2101      	movs	r1, #1
   2edda:	4630      	mov	r0, r6
   2eddc:	f7f0 f9b2 	bl	1f144 <net_buf_simple_add>
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   2ede0:	2505      	movs	r5, #5
   2ede2:	7005      	strb	r5, [r0, #0]
   2ede4:	2101      	movs	r1, #1
   2ede6:	4630      	mov	r0, r6
   2ede8:	f7f0 f9ac 	bl	1f144 <net_buf_simple_add>
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   2edec:	7005      	strb	r5, [r0, #0]
   2edee:	2300      	movs	r3, #0
   2edf0:	9300      	str	r3, [sp, #0]
   2edf2:	4622      	mov	r2, r4
   2edf4:	2106      	movs	r1, #6
   2edf6:	4638      	mov	r0, r7
   2edf8:	f7fe face 	bl	2d398 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, BT_L2CAP_CID_SMP, buf)) {
   2edfc:	b910      	cbnz	r0, 2ee04 <bt_smp_recv+0x48>
}
   2edfe:	2000      	movs	r0, #0
   2ee00:	b003      	add	sp, #12
   2ee02:	bdf0      	pop	{r4, r5, r6, r7, pc}
		net_buf_unref(buf);
   2ee04:	4620      	mov	r0, r4
   2ee06:	f7f0 f885 	bl	1ef14 <net_buf_unref>
   2ee0a:	e7f8      	b.n	2edfe <bt_smp_recv+0x42>

0002ee0c <bt_smp_sign>:
}
   2ee0c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2ee10:	4770      	bx	lr

0002ee12 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);

int bt_smp_init(void)
{
	return 0;
}
   2ee12:	2000      	movs	r0, #0
   2ee14:	4770      	bx	lr

0002ee16 <fixed_data_unref>:
}
   2ee16:	4770      	bx	lr

0002ee18 <data_alloc>:
{
   2ee18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ee1c:	4604      	mov	r4, r0
   2ee1e:	460d      	mov	r5, r1
   2ee20:	4617      	mov	r7, r2
   2ee22:	461e      	mov	r6, r3
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   2ee24:	7980      	ldrb	r0, [r0, #6]
   2ee26:	f7ef fdeb 	bl	1ea00 <net_buf_pool_get>
	return pool->alloc->cb->alloc(buf, size, timeout);
   2ee2a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   2ee2c:	681b      	ldr	r3, [r3, #0]
   2ee2e:	f8d3 8000 	ldr.w	r8, [r3]
   2ee32:	463a      	mov	r2, r7
   2ee34:	4633      	mov	r3, r6
   2ee36:	4629      	mov	r1, r5
   2ee38:	4620      	mov	r0, r4
   2ee3a:	47c0      	blx	r8
}
   2ee3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002ee40 <data_unref>:
{
   2ee40:	b538      	push	{r3, r4, r5, lr}
   2ee42:	4604      	mov	r4, r0
   2ee44:	460d      	mov	r5, r1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   2ee46:	7980      	ldrb	r0, [r0, #6]
   2ee48:	f7ef fdda 	bl	1ea00 <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   2ee4c:	7963      	ldrb	r3, [r4, #5]
   2ee4e:	f013 0f02 	tst.w	r3, #2
   2ee52:	d105      	bne.n	2ee60 <data_unref+0x20>
	pool->alloc->cb->unref(buf, data);
   2ee54:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   2ee56:	681b      	ldr	r3, [r3, #0]
   2ee58:	689b      	ldr	r3, [r3, #8]
   2ee5a:	4629      	mov	r1, r5
   2ee5c:	4620      	mov	r0, r4
   2ee5e:	4798      	blx	r3
}
   2ee60:	bd38      	pop	{r3, r4, r5, pc}

0002ee62 <net_buf_id>:
{
   2ee62:	b510      	push	{r4, lr}
   2ee64:	4604      	mov	r4, r0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   2ee66:	7980      	ldrb	r0, [r0, #6]
   2ee68:	f7ef fdca 	bl	1ea00 <net_buf_pool_get>
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   2ee6c:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   2ee70:	3317      	adds	r3, #23
   2ee72:	f023 0303 	bic.w	r3, r3, #3
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
   2ee76:	6b00      	ldr	r0, [r0, #48]	; 0x30
   2ee78:	1a20      	subs	r0, r4, r0
}
   2ee7a:	fbb0 f0f3 	udiv	r0, r0, r3
   2ee7e:	bd10      	pop	{r4, pc}

0002ee80 <fixed_data_alloc>:
{
   2ee80:	b570      	push	{r4, r5, r6, lr}
   2ee82:	4604      	mov	r4, r0
   2ee84:	460d      	mov	r5, r1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   2ee86:	7980      	ldrb	r0, [r0, #6]
   2ee88:	f7ef fdba 	bl	1ea00 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   2ee8c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   2ee8e:	685b      	ldr	r3, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   2ee90:	682a      	ldr	r2, [r5, #0]
   2ee92:	6819      	ldr	r1, [r3, #0]
   2ee94:	428a      	cmp	r2, r1
   2ee96:	bf28      	it	cs
   2ee98:	460a      	movcs	r2, r1
   2ee9a:	602a      	str	r2, [r5, #0]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   2ee9c:	685d      	ldr	r5, [r3, #4]
   2ee9e:	681e      	ldr	r6, [r3, #0]
   2eea0:	4620      	mov	r0, r4
   2eea2:	f7ff ffde 	bl	2ee62 <net_buf_id>
}
   2eea6:	fb00 5006 	mla	r0, r0, r6, r5
   2eeaa:	bd70      	pop	{r4, r5, r6, pc}

0002eeac <net_buf_alloc_fixed>:
{
   2eeac:	b508      	push	{r3, lr}
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   2eeae:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
   2eeb0:	6849      	ldr	r1, [r1, #4]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   2eeb2:	6809      	ldr	r1, [r1, #0]
   2eeb4:	f7ef fdd0 	bl	1ea58 <net_buf_alloc_len>
}
   2eeb8:	bd08      	pop	{r3, pc}

0002eeba <net_buf_simple_init_with_data>:
	buf->__buf = data;
   2eeba:	6081      	str	r1, [r0, #8]
	buf->data  = data;
   2eebc:	6001      	str	r1, [r0, #0]
	buf->size  = size;
   2eebe:	b292      	uxth	r2, r2
   2eec0:	80c2      	strh	r2, [r0, #6]
	buf->len   = size;
   2eec2:	8082      	strh	r2, [r0, #4]
}
   2eec4:	4770      	bx	lr

0002eec6 <net_buf_simple_pull_le16>:

	return val;
}

uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   2eec6:	b510      	push	{r4, lr}
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   2eec8:	6803      	ldr	r3, [r0, #0]
   2eeca:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   2eecc:	2102      	movs	r1, #2
   2eece:	f7f0 f8db 	bl	1f088 <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   2eed2:	4620      	mov	r0, r4
   2eed4:	bd10      	pop	{r4, pc}

0002eed6 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   2eed6:	6802      	ldr	r2, [r0, #0]
   2eed8:	6880      	ldr	r0, [r0, #8]
}
   2eeda:	1a10      	subs	r0, r2, r0
   2eedc:	4770      	bx	lr

0002eede <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
   2eede:	b538      	push	{r3, r4, r5, lr}
   2eee0:	4604      	mov	r4, r0
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   2eee2:	88c5      	ldrh	r5, [r0, #6]
   2eee4:	f7ff fff7 	bl	2eed6 <net_buf_simple_headroom>
   2eee8:	1a2d      	subs	r5, r5, r0
   2eeea:	88a0      	ldrh	r0, [r4, #4]
}
   2eeec:	1a28      	subs	r0, r5, r0
   2eeee:	bd38      	pop	{r3, r4, r5, pc}

0002eef0 <net_buf_simple_add_mem>:
{
   2eef0:	b538      	push	{r3, r4, r5, lr}
   2eef2:	460d      	mov	r5, r1
   2eef4:	4614      	mov	r4, r2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   2eef6:	4611      	mov	r1, r2
   2eef8:	f7f0 f924 	bl	1f144 <net_buf_simple_add>
   2eefc:	4622      	mov	r2, r4
   2eefe:	4629      	mov	r1, r5
   2ef00:	f001 ffb1 	bl	30e66 <memcpy>
}
   2ef04:	bd38      	pop	{r3, r4, r5, pc}

0002ef06 <net_buf_simple_add_u8>:
{
   2ef06:	b510      	push	{r4, lr}
   2ef08:	460c      	mov	r4, r1
	u8 = net_buf_simple_add(buf, 1);
   2ef0a:	2101      	movs	r1, #1
   2ef0c:	f7f0 f91a 	bl	1f144 <net_buf_simple_add>
	*u8 = val;
   2ef10:	7004      	strb	r4, [r0, #0]
}
   2ef12:	bd10      	pop	{r4, pc}

0002ef14 <net_buf_simple_add_le16>:
{
   2ef14:	b510      	push	{r4, lr}
   2ef16:	460c      	mov	r4, r1
	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
   2ef18:	2102      	movs	r1, #2
   2ef1a:	f7f0 f913 	bl	1f144 <net_buf_simple_add>
	dst[0] = val;
   2ef1e:	7004      	strb	r4, [r0, #0]
	dst[1] = val >> 8;
   2ef20:	0a24      	lsrs	r4, r4, #8
   2ef22:	7044      	strb	r4, [r0, #1]
}
   2ef24:	bd10      	pop	{r4, pc}

0002ef26 <get_sub_data>:
	struct nrf_clock_control_data *data = dev->data;
   2ef26:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
   2ef28:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   2ef2c:	0089      	lsls	r1, r1, #2
   2ef2e:	3140      	adds	r1, #64	; 0x40
}
   2ef30:	4408      	add	r0, r1
   2ef32:	4770      	bx	lr

0002ef34 <get_sub_config>:
	const struct nrf_clock_control_config *config =
   2ef34:	6840      	ldr	r0, [r0, #4]
	return &config->subsys[type];
   2ef36:	eb01 0141 	add.w	r1, r1, r1, lsl #1
}
   2ef3a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   2ef3e:	4770      	bx	lr

0002ef40 <get_onoff_manager>:
	struct nrf_clock_control_data *data = dev->data;
   2ef40:	6900      	ldr	r0, [r0, #16]
}
   2ef42:	eb00 1041 	add.w	r0, r0, r1, lsl #5
   2ef46:	4770      	bx	lr

0002ef48 <set_off_state>:
   2ef48:	f04f 0340 	mov.w	r3, #64	; 0x40
   2ef4c:	f3ef 8211 	mrs	r2, BASEPRI
   2ef50:	f383 8812 	msr	BASEPRI_MAX, r3
   2ef54:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2ef58:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   2ef5a:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   2ef5e:	d001      	beq.n	2ef64 <set_off_state+0x1c>
   2ef60:	428b      	cmp	r3, r1
   2ef62:	d107      	bne.n	2ef74 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   2ef64:	2301      	movs	r3, #1
   2ef66:	6003      	str	r3, [r0, #0]
	int err = 0;
   2ef68:	2000      	movs	r0, #0
	__asm__ volatile(
   2ef6a:	f382 8811 	msr	BASEPRI, r2
   2ef6e:	f3bf 8f6f 	isb	sy
}
   2ef72:	4770      	bx	lr
		err = -EPERM;
   2ef74:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2ef78:	e7f7      	b.n	2ef6a <set_off_state+0x22>

0002ef7a <set_starting_state>:
	__asm__ volatile(
   2ef7a:	f04f 0340 	mov.w	r3, #64	; 0x40
   2ef7e:	f3ef 8211 	mrs	r2, BASEPRI
   2ef82:	f383 8812 	msr	BASEPRI_MAX, r3
   2ef86:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2ef8a:	6803      	ldr	r3, [r0, #0]
   2ef8c:	f003 0cc0 	and.w	ip, r3, #192	; 0xc0
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   2ef90:	f003 0307 	and.w	r3, r3, #7
   2ef94:	2b01      	cmp	r3, #1
   2ef96:	d008      	beq.n	2efaa <set_starting_state+0x30>
	} else if (current_ctx != ctx) {
   2ef98:	458c      	cmp	ip, r1
   2ef9a:	d009      	beq.n	2efb0 <set_starting_state+0x36>
		err = -EPERM;
   2ef9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	__asm__ volatile(
   2efa0:	f382 8811 	msr	BASEPRI, r2
   2efa4:	f3bf 8f6f 	isb	sy
}
   2efa8:	4770      	bx	lr
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   2efaa:	6001      	str	r1, [r0, #0]
	int err = 0;
   2efac:	2000      	movs	r0, #0
   2efae:	e7f7      	b.n	2efa0 <set_starting_state+0x26>
		err = -EALREADY;
   2efb0:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2efb4:	e7f4      	b.n	2efa0 <set_starting_state+0x26>

0002efb6 <set_on_state>:
	__asm__ volatile(
   2efb6:	f04f 0340 	mov.w	r3, #64	; 0x40
   2efba:	f3ef 8211 	mrs	r2, BASEPRI
   2efbe:	f383 8812 	msr	BASEPRI_MAX, r3
   2efc2:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   2efc6:	6803      	ldr	r3, [r0, #0]
   2efc8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   2efcc:	f043 0302 	orr.w	r3, r3, #2
   2efd0:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   2efd2:	f382 8811 	msr	BASEPRI, r2
   2efd6:	f3bf 8f6f 	isb	sy
}
   2efda:	4770      	bx	lr

0002efdc <clkstarted_handle>:
{
   2efdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2efde:	4606      	mov	r6, r0
   2efe0:	460c      	mov	r4, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   2efe2:	f7ff ffa0 	bl	2ef26 <get_sub_data>
	clock_control_cb_t callback = sub_data->cb;
   2efe6:	6805      	ldr	r5, [r0, #0]
	void *user_data = sub_data->user_data;
   2efe8:	6847      	ldr	r7, [r0, #4]
	sub_data->cb = NULL;
   2efea:	2300      	movs	r3, #0
   2efec:	f840 3b08 	str.w	r3, [r0], #8
	set_on_state(&sub_data->flags);
   2eff0:	f7ff ffe1 	bl	2efb6 <set_on_state>
	if (callback) {
   2eff4:	b11d      	cbz	r5, 2effe <clkstarted_handle+0x22>
		callback(dev, (clock_control_subsys_t)type, user_data);
   2eff6:	463a      	mov	r2, r7
   2eff8:	4621      	mov	r1, r4
   2effa:	4630      	mov	r0, r6
   2effc:	47a8      	blx	r5
}
   2effe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002f000 <async_start>:
{
   2f000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2f004:	4606      	mov	r6, r0
   2f006:	4690      	mov	r8, r2
   2f008:	461f      	mov	r7, r3
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   2f00a:	b2cd      	uxtb	r5, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   2f00c:	4629      	mov	r1, r5
   2f00e:	f7ff ff8a 	bl	2ef26 <get_sub_data>
   2f012:	4604      	mov	r4, r0
	err = set_starting_state(&subdata->flags, ctx);
   2f014:	9906      	ldr	r1, [sp, #24]
   2f016:	3008      	adds	r0, #8
   2f018:	f7ff ffaf 	bl	2ef7a <set_starting_state>
	if (err < 0) {
   2f01c:	2800      	cmp	r0, #0
   2f01e:	db09      	blt.n	2f034 <async_start+0x34>
	subdata->cb = cb;
   2f020:	f8c4 8000 	str.w	r8, [r4]
	subdata->user_data = user_data;
   2f024:	6067      	str	r7, [r4, #4]
	 get_sub_config(dev, type)->start();
   2f026:	4629      	mov	r1, r5
   2f028:	4630      	mov	r0, r6
   2f02a:	f7ff ff83 	bl	2ef34 <get_sub_config>
   2f02e:	6803      	ldr	r3, [r0, #0]
   2f030:	4798      	blx	r3
	return 0;
   2f032:	2000      	movs	r0, #0
}
   2f034:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002f038 <api_start>:
{
   2f038:	b510      	push	{r4, lr}
   2f03a:	b082      	sub	sp, #8
	return async_start(dev, subsys, cb, user_data, CTX_API);
   2f03c:	2480      	movs	r4, #128	; 0x80
   2f03e:	9400      	str	r4, [sp, #0]
   2f040:	f7ff ffde 	bl	2f000 <async_start>
}
   2f044:	b002      	add	sp, #8
   2f046:	bd10      	pop	{r4, pc}

0002f048 <onoff_started_callback>:
{
   2f048:	b510      	push	{r4, lr}
   2f04a:	4614      	mov	r4, r2
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
   2f04c:	b2c9      	uxtb	r1, r1
   2f04e:	f7ff ff77 	bl	2ef40 <get_onoff_manager>
	notify(mgr, 0);
   2f052:	2100      	movs	r1, #0
   2f054:	47a0      	blx	r4
}
   2f056:	bd10      	pop	{r4, pc}

0002f058 <hfclk_start>:
{
   2f058:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   2f05a:	2001      	movs	r0, #1
   2f05c:	f7f3 fe60 	bl	22d20 <nrfx_clock_start>
}
   2f060:	bd08      	pop	{r3, pc}

0002f062 <hfclk_stop>:
{
   2f062:	b508      	push	{r3, lr}
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   2f064:	2001      	movs	r0, #1
   2f066:	f7f3 fe7b 	bl	22d60 <nrfx_clock_stop>
}
   2f06a:	bd08      	pop	{r3, pc}

0002f06c <lfclk_stop>:
{
   2f06c:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   2f06e:	2000      	movs	r0, #0
   2f070:	f7f3 fe76 	bl	22d60 <nrfx_clock_stop>
}
   2f074:	bd08      	pop	{r3, pc}

0002f076 <api_stop>:
{
   2f076:	b508      	push	{r3, lr}
	return stop(dev, subsys, CTX_API);
   2f078:	2280      	movs	r2, #128	; 0x80
   2f07a:	f7f0 f8eb 	bl	1f254 <stop>
}
   2f07e:	bd08      	pop	{r3, pc}

0002f080 <blocking_start_callback>:
{
   2f080:	b508      	push	{r3, lr}
   2f082:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   2f084:	f7f7 ff86 	bl	26f94 <z_impl_k_sem_give>
}
   2f088:	bd08      	pop	{r3, pc}

0002f08a <st7789v_set_lcd_margins>:
	struct st7789v_data *data = dev->data;
   2f08a:	6903      	ldr	r3, [r0, #16]
	data->x_offset = x_offset;
   2f08c:	8019      	strh	r1, [r3, #0]
	data->y_offset = y_offset;
   2f08e:	805a      	strh	r2, [r3, #2]
}
   2f090:	4770      	bx	lr

0002f092 <st7789v_read>:
}
   2f092:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2f096:	4770      	bx	lr

0002f098 <st7789v_get_framebuffer>:
}
   2f098:	2000      	movs	r0, #0
   2f09a:	4770      	bx	lr

0002f09c <st7789v_set_brightness>:
}
   2f09c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2f0a0:	4770      	bx	lr

0002f0a2 <st7789v_set_contrast>:
}
   2f0a2:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2f0a6:	4770      	bx	lr

0002f0a8 <st7789v_get_capabilities>:
	const struct st7789v_config *config = dev->config;
   2f0a8:	6842      	ldr	r2, [r0, #4]
__ssp_bos_icheck3(memset, void *, int)
   2f0aa:	2300      	movs	r3, #0
   2f0ac:	600b      	str	r3, [r1, #0]
   2f0ae:	604b      	str	r3, [r1, #4]
   2f0b0:	608b      	str	r3, [r1, #8]
   2f0b2:	60cb      	str	r3, [r1, #12]
	capabilities->x_resolution = config->width;
   2f0b4:	f8b2 0058 	ldrh.w	r0, [r2, #88]	; 0x58
   2f0b8:	8008      	strh	r0, [r1, #0]
	capabilities->y_resolution = config->height;
   2f0ba:	f8b2 2056 	ldrh.w	r2, [r2, #86]	; 0x56
   2f0be:	804a      	strh	r2, [r1, #2]
	capabilities->supported_pixel_formats = PIXEL_FORMAT_RGB_565;
   2f0c0:	2210      	movs	r2, #16
   2f0c2:	604a      	str	r2, [r1, #4]
	capabilities->current_pixel_format = PIXEL_FORMAT_RGB_565;
   2f0c4:	730a      	strb	r2, [r1, #12]
	capabilities->current_orientation = DISPLAY_ORIENTATION_NORMAL;
   2f0c6:	734b      	strb	r3, [r1, #13]
}
   2f0c8:	4770      	bx	lr

0002f0ca <st7789v_exit_sleep>:
{
   2f0ca:	b508      	push	{r3, lr}
	st7789v_transmit(dev, ST7789V_CMD_SLEEP_OUT, NULL, 0);
   2f0cc:	2300      	movs	r3, #0
   2f0ce:	461a      	mov	r2, r3
   2f0d0:	2111      	movs	r1, #17
   2f0d2:	f7f0 fb83 	bl	1f7dc <st7789v_transmit>
	return z_impl_k_sleep(timeout);
   2f0d6:	f640 705d 	movw	r0, #3933	; 0xf5d
   2f0da:	2100      	movs	r1, #0
   2f0dc:	f7f9 fe3e 	bl	28d5c <z_impl_k_sleep>
}
   2f0e0:	bd08      	pop	{r3, pc}

0002f0e2 <st7789v_pm_action>:

#ifdef CONFIG_PM_DEVICE
static int st7789v_pm_action(const struct device *dev,
			     enum pm_device_action action)
{
   2f0e2:	b508      	push	{r3, lr}
	int ret = 0;

	switch (action) {
   2f0e4:	b129      	cbz	r1, 2f0f2 <st7789v_pm_action+0x10>
   2f0e6:	2901      	cmp	r1, #1
   2f0e8:	d10a      	bne.n	2f100 <st7789v_pm_action+0x1e>
	case PM_DEVICE_ACTION_RESUME:
		st7789v_exit_sleep(dev);
   2f0ea:	f7ff ffee 	bl	2f0ca <st7789v_exit_sleep>
	int ret = 0;
   2f0ee:	2000      	movs	r0, #0
		break;
   2f0f0:	e008      	b.n	2f104 <st7789v_pm_action+0x22>
	case PM_DEVICE_ACTION_SUSPEND:
		st7789v_transmit(dev, ST7789V_CMD_SLEEP_IN, NULL, 0);
   2f0f2:	2300      	movs	r3, #0
   2f0f4:	461a      	mov	r2, r3
   2f0f6:	2110      	movs	r1, #16
   2f0f8:	f7f0 fb70 	bl	1f7dc <st7789v_transmit>
	int ret = 0;
   2f0fc:	2000      	movs	r0, #0
		break;
   2f0fe:	e001      	b.n	2f104 <st7789v_pm_action+0x22>
	switch (action) {
   2f100:	f06f 0085 	mvn.w	r0, #133	; 0x85
		ret = -ENOTSUP;
		break;
	}

	return ret;
}
   2f104:	bd08      	pop	{r3, pc}

0002f106 <st7789v_set_mem_area>:
{
   2f106:	b570      	push	{r4, r5, r6, lr}
   2f108:	b082      	sub	sp, #8
   2f10a:	4605      	mov	r5, r0
	struct st7789v_data *data = dev->data;
   2f10c:	6906      	ldr	r6, [r0, #16]
	uint16_t ram_x = x + data->x_offset;
   2f10e:	f8b6 c000 	ldrh.w	ip, [r6]
   2f112:	4461      	add	r1, ip
   2f114:	fa1f fc81 	uxth.w	ip, r1
	uint16_t ram_y = y + data->y_offset;
   2f118:	8874      	ldrh	r4, [r6, #2]
   2f11a:	4414      	add	r4, r2
   2f11c:	b2a4      	uxth	r4, r4
	spi_data[0] = sys_cpu_to_be16(ram_x);
   2f11e:	f3c1 2107 	ubfx	r1, r1, #8, #8
   2f122:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
   2f126:	f8ad 1004 	strh.w	r1, [sp, #4]
	spi_data[1] = sys_cpu_to_be16(ram_x + w - 1);
   2f12a:	4463      	add	r3, ip
   2f12c:	3b01      	subs	r3, #1
   2f12e:	f3c3 2207 	ubfx	r2, r3, #8, #8
   2f132:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   2f136:	f8ad 3006 	strh.w	r3, [sp, #6]
	st7789v_transmit(dev, ST7789V_CMD_CASET, (uint8_t *)&spi_data[0], 4);
   2f13a:	2304      	movs	r3, #4
   2f13c:	eb0d 0203 	add.w	r2, sp, r3
   2f140:	212a      	movs	r1, #42	; 0x2a
   2f142:	f7f0 fb4b 	bl	1f7dc <st7789v_transmit>
	spi_data[0] = sys_cpu_to_be16(ram_y);
   2f146:	0a23      	lsrs	r3, r4, #8
   2f148:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
   2f14c:	f8ad 3004 	strh.w	r3, [sp, #4]
	spi_data[1] = sys_cpu_to_be16(ram_y + h - 1);
   2f150:	f8bd 2018 	ldrh.w	r2, [sp, #24]
   2f154:	4414      	add	r4, r2
   2f156:	3c01      	subs	r4, #1
   2f158:	f3c4 2307 	ubfx	r3, r4, #8, #8
   2f15c:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
   2f160:	f8ad 4006 	strh.w	r4, [sp, #6]
	st7789v_transmit(dev, ST7789V_CMD_RASET, (uint8_t *)&spi_data[0], 4);
   2f164:	2304      	movs	r3, #4
   2f166:	eb0d 0203 	add.w	r2, sp, r3
   2f16a:	212b      	movs	r1, #43	; 0x2b
   2f16c:	4628      	mov	r0, r5
   2f16e:	f7f0 fb35 	bl	1f7dc <st7789v_transmit>
}
   2f172:	b002      	add	sp, #8
   2f174:	bd70      	pop	{r4, r5, r6, pc}

0002f176 <st7789v_blanking_off>:
{
   2f176:	b508      	push	{r3, lr}
	st7789v_transmit(dev, ST7789V_CMD_DISP_ON, NULL, 0);
   2f178:	2300      	movs	r3, #0
   2f17a:	461a      	mov	r2, r3
   2f17c:	2129      	movs	r1, #41	; 0x29
   2f17e:	f7f0 fb2d 	bl	1f7dc <st7789v_transmit>
}
   2f182:	2000      	movs	r0, #0
   2f184:	bd08      	pop	{r3, pc}

0002f186 <st7789v_blanking_on>:
{
   2f186:	b508      	push	{r3, lr}
	st7789v_transmit(dev, ST7789V_CMD_DISP_OFF, NULL, 0);
   2f188:	2300      	movs	r3, #0
   2f18a:	461a      	mov	r2, r3
   2f18c:	2128      	movs	r1, #40	; 0x28
   2f18e:	f7f0 fb25 	bl	1f7dc <st7789v_transmit>
}
   2f192:	2000      	movs	r0, #0
   2f194:	bd08      	pop	{r3, pc}

0002f196 <st7789v_lcd_init>:
{
   2f196:	b570      	push	{r4, r5, r6, lr}
   2f198:	b082      	sub	sp, #8
   2f19a:	4604      	mov	r4, r0
	struct st7789v_data *data = dev->data;
   2f19c:	6903      	ldr	r3, [r0, #16]
	const struct st7789v_config *config = dev->config;
   2f19e:	6845      	ldr	r5, [r0, #4]
	st7789v_set_lcd_margins(dev, data->x_offset,
   2f1a0:	885a      	ldrh	r2, [r3, #2]
   2f1a2:	8819      	ldrh	r1, [r3, #0]
   2f1a4:	f7ff ff71 	bl	2f08a <st7789v_set_lcd_margins>
	st7789v_transmit(dev, ST7789V_CMD_CMD2EN,
   2f1a8:	2304      	movs	r3, #4
   2f1aa:	f105 022e 	add.w	r2, r5, #46	; 0x2e
   2f1ae:	21df      	movs	r1, #223	; 0xdf
   2f1b0:	4620      	mov	r0, r4
   2f1b2:	f7f0 fb13 	bl	1f7dc <st7789v_transmit>
	st7789v_transmit(dev, ST7789V_CMD_PORCTRL,
   2f1b6:	2305      	movs	r3, #5
   2f1b8:	f105 0229 	add.w	r2, r5, #41	; 0x29
   2f1bc:	21b2      	movs	r1, #178	; 0xb2
   2f1be:	4620      	mov	r0, r4
   2f1c0:	f7f0 fb0c 	bl	1f7dc <st7789v_transmit>
	tmp = 0x00;
   2f1c4:	2300      	movs	r3, #0
   2f1c6:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_DGMEN, &tmp, 1);
   2f1ca:	2301      	movs	r3, #1
   2f1cc:	f10d 0207 	add.w	r2, sp, #7
   2f1d0:	21ba      	movs	r1, #186	; 0xba
   2f1d2:	4620      	mov	r0, r4
   2f1d4:	f7f0 fb02 	bl	1f7dc <st7789v_transmit>
	tmp = 0x0f;
   2f1d8:	230f      	movs	r3, #15
   2f1da:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_FRCTRL2, &tmp, 1);
   2f1de:	2301      	movs	r3, #1
   2f1e0:	f10d 0207 	add.w	r2, sp, #7
   2f1e4:	21c6      	movs	r1, #198	; 0xc6
   2f1e6:	4620      	mov	r0, r4
   2f1e8:	f7f0 faf8 	bl	1f7dc <st7789v_transmit>
	tmp = config->gctrl;
   2f1ec:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
   2f1f0:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_GCTRL, &tmp, 1);
   2f1f4:	2301      	movs	r3, #1
   2f1f6:	f10d 0207 	add.w	r2, sp, #7
   2f1fa:	21b7      	movs	r1, #183	; 0xb7
   2f1fc:	4620      	mov	r0, r4
   2f1fe:	f7f0 faed 	bl	1f7dc <st7789v_transmit>
	tmp = config->vcom;
   2f202:	f895 3020 	ldrb.w	r3, [r5, #32]
   2f206:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_VCOMS, &tmp, 1);
   2f20a:	2301      	movs	r3, #1
   2f20c:	f10d 0207 	add.w	r2, sp, #7
   2f210:	21bb      	movs	r1, #187	; 0xbb
   2f212:	4620      	mov	r0, r4
   2f214:	f7f0 fae2 	bl	1f7dc <st7789v_transmit>
	if (config->vdv_vrh_enable) {
   2f218:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
   2f21c:	2b00      	cmp	r3, #0
   2f21e:	d156      	bne.n	2f2ce <st7789v_lcd_init+0x138>
	st7789v_transmit(dev, ST7789V_CMD_PWCTRL1,
   2f220:	2302      	movs	r3, #2
   2f222:	f105 0232 	add.w	r2, r5, #50	; 0x32
   2f226:	21d0      	movs	r1, #208	; 0xd0
   2f228:	4620      	mov	r0, r4
   2f22a:	f7f0 fad7 	bl	1f7dc <st7789v_transmit>
	tmp = config->mdac;
   2f22e:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   2f232:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_MADCTL, &tmp, 1);
   2f236:	2301      	movs	r3, #1
   2f238:	f10d 0207 	add.w	r2, sp, #7
   2f23c:	2136      	movs	r1, #54	; 0x36
   2f23e:	4620      	mov	r0, r4
   2f240:	f7f0 facc 	bl	1f7dc <st7789v_transmit>
	tmp = config->colmod;
   2f244:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   2f248:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_COLMOD, &tmp, 1);
   2f24c:	2301      	movs	r3, #1
   2f24e:	f10d 0207 	add.w	r2, sp, #7
   2f252:	213a      	movs	r1, #58	; 0x3a
   2f254:	4620      	mov	r0, r4
   2f256:	f7f0 fac1 	bl	1f7dc <st7789v_transmit>
	tmp = config->lcm;
   2f25a:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
   2f25e:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_LCMCTRL, &tmp, 1);
   2f262:	2301      	movs	r3, #1
   2f264:	f10d 0207 	add.w	r2, sp, #7
   2f268:	21c0      	movs	r1, #192	; 0xc0
   2f26a:	4620      	mov	r0, r4
   2f26c:	f7f0 fab6 	bl	1f7dc <st7789v_transmit>
	tmp = config->gamma;
   2f270:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   2f274:	f88d 3007 	strb.w	r3, [sp, #7]
	st7789v_transmit(dev, ST7789V_CMD_GAMSET, &tmp, 1);
   2f278:	2301      	movs	r3, #1
   2f27a:	f10d 0207 	add.w	r2, sp, #7
   2f27e:	2126      	movs	r1, #38	; 0x26
   2f280:	4620      	mov	r0, r4
   2f282:	f7f0 faab 	bl	1f7dc <st7789v_transmit>
	st7789v_transmit(dev, ST7789V_CMD_INV_ON, NULL, 0);
   2f286:	2300      	movs	r3, #0
   2f288:	461a      	mov	r2, r3
   2f28a:	2121      	movs	r1, #33	; 0x21
   2f28c:	4620      	mov	r0, r4
   2f28e:	f7f0 faa5 	bl	1f7dc <st7789v_transmit>
	st7789v_transmit(dev, ST7789V_CMD_PVGAMCTRL,
   2f292:	230e      	movs	r3, #14
   2f294:	f105 0234 	add.w	r2, r5, #52	; 0x34
   2f298:	21e0      	movs	r1, #224	; 0xe0
   2f29a:	4620      	mov	r0, r4
   2f29c:	f7f0 fa9e 	bl	1f7dc <st7789v_transmit>
	st7789v_transmit(dev, ST7789V_CMD_NVGAMCTRL,
   2f2a0:	230e      	movs	r3, #14
   2f2a2:	f105 0242 	add.w	r2, r5, #66	; 0x42
   2f2a6:	21e1      	movs	r1, #225	; 0xe1
   2f2a8:	4620      	mov	r0, r4
   2f2aa:	f7f0 fa97 	bl	1f7dc <st7789v_transmit>
	st7789v_transmit(dev, ST7789V_CMD_RAMCTRL,
   2f2ae:	2302      	movs	r3, #2
   2f2b0:	f105 0250 	add.w	r2, r5, #80	; 0x50
   2f2b4:	21b0      	movs	r1, #176	; 0xb0
   2f2b6:	4620      	mov	r0, r4
   2f2b8:	f7f0 fa90 	bl	1f7dc <st7789v_transmit>
	st7789v_transmit(dev, ST7789V_CMD_RGBCTRL,
   2f2bc:	2303      	movs	r3, #3
   2f2be:	f105 0252 	add.w	r2, r5, #82	; 0x52
   2f2c2:	21b1      	movs	r1, #177	; 0xb1
   2f2c4:	4620      	mov	r0, r4
   2f2c6:	f7f0 fa89 	bl	1f7dc <st7789v_transmit>
}
   2f2ca:	b002      	add	sp, #8
   2f2cc:	bd70      	pop	{r4, r5, r6, pc}
		tmp = 0x01;
   2f2ce:	2601      	movs	r6, #1
   2f2d0:	f88d 6007 	strb.w	r6, [sp, #7]
		st7789v_transmit(dev, ST7789V_CMD_VDVVRHEN, &tmp, 1);
   2f2d4:	4633      	mov	r3, r6
   2f2d6:	f10d 0207 	add.w	r2, sp, #7
   2f2da:	21c2      	movs	r1, #194	; 0xc2
   2f2dc:	4620      	mov	r0, r4
   2f2de:	f7f0 fa7d 	bl	1f7dc <st7789v_transmit>
		tmp = config->vrh_value;
   2f2e2:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
   2f2e6:	f88d 3007 	strb.w	r3, [sp, #7]
		st7789v_transmit(dev, ST7789V_CMD_VRH, &tmp, 1);
   2f2ea:	4633      	mov	r3, r6
   2f2ec:	f10d 0207 	add.w	r2, sp, #7
   2f2f0:	21c3      	movs	r1, #195	; 0xc3
   2f2f2:	4620      	mov	r0, r4
   2f2f4:	f7f0 fa72 	bl	1f7dc <st7789v_transmit>
		tmp = config->vdv_value;
   2f2f8:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   2f2fc:	f88d 3007 	strb.w	r3, [sp, #7]
		st7789v_transmit(dev, ST7789V_CMD_VDS, &tmp, 1);
   2f300:	4633      	mov	r3, r6
   2f302:	f10d 0207 	add.w	r2, sp, #7
   2f306:	21c4      	movs	r1, #196	; 0xc4
   2f308:	4620      	mov	r0, r4
   2f30a:	f7f0 fa67 	bl	1f7dc <st7789v_transmit>
   2f30e:	e787      	b.n	2f220 <st7789v_lcd_init+0x8a>

0002f310 <get_drive>:
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   2f310:	f020 00f9 	bic.w	r0, r0, #249	; 0xf9
   2f314:	0580      	lsls	r0, r0, #22
   2f316:	0d80      	lsrs	r0, r0, #22
   2f318:	f5b0 7f83 	cmp.w	r0, #262	; 0x106
   2f31c:	d033      	beq.n	2f386 <get_drive+0x76>
   2f31e:	d816      	bhi.n	2f34e <get_drive+0x3e>
   2f320:	2806      	cmp	r0, #6
   2f322:	d02c      	beq.n	2f37e <get_drive+0x6e>
   2f324:	d906      	bls.n	2f334 <get_drive+0x24>
   2f326:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   2f32a:	d10d      	bne.n	2f348 <get_drive+0x38>
		*drive = NRF_GPIO_PIN_H0S1;
   2f32c:	2301      	movs	r3, #1
   2f32e:	700b      	strb	r3, [r1, #0]
	return 0;
   2f330:	2000      	movs	r0, #0
		break;
   2f332:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   2f334:	b300      	cbz	r0, 2f378 <get_drive+0x68>
   2f336:	2802      	cmp	r0, #2
   2f338:	d103      	bne.n	2f342 <get_drive+0x32>
		*drive = NRF_GPIO_PIN_D0S1;
   2f33a:	2304      	movs	r3, #4
   2f33c:	700b      	strb	r3, [r1, #0]
	return 0;
   2f33e:	2000      	movs	r0, #0
		break;
   2f340:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   2f342:	f06f 0015 	mvn.w	r0, #21
   2f346:	4770      	bx	lr
   2f348:	f06f 0015 	mvn.w	r0, #21
   2f34c:	4770      	bx	lr
   2f34e:	f240 2302 	movw	r3, #514	; 0x202
   2f352:	4298      	cmp	r0, r3
   2f354:	d01b      	beq.n	2f38e <get_drive+0x7e>
   2f356:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
   2f35a:	d103      	bne.n	2f364 <get_drive+0x54>
		*drive = NRF_GPIO_PIN_H0H1;
   2f35c:	2303      	movs	r3, #3
   2f35e:	700b      	strb	r3, [r1, #0]
	return 0;
   2f360:	2000      	movs	r0, #0
		break;
   2f362:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   2f364:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   2f368:	d103      	bne.n	2f372 <get_drive+0x62>
		*drive = NRF_GPIO_PIN_S0H1;
   2f36a:	2302      	movs	r3, #2
   2f36c:	700b      	strb	r3, [r1, #0]
	return 0;
   2f36e:	2000      	movs	r0, #0
		break;
   2f370:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   2f372:	f06f 0015 	mvn.w	r0, #21
   2f376:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0S1;
   2f378:	2000      	movs	r0, #0
   2f37a:	7008      	strb	r0, [r1, #0]
		break;
   2f37c:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0D1;
   2f37e:	2306      	movs	r3, #6
   2f380:	700b      	strb	r3, [r1, #0]
	return 0;
   2f382:	2000      	movs	r0, #0
		break;
   2f384:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_H0D1;
   2f386:	2307      	movs	r3, #7
   2f388:	700b      	strb	r3, [r1, #0]
	return 0;
   2f38a:	2000      	movs	r0, #0
		break;
   2f38c:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_D0H1;
   2f38e:	2305      	movs	r3, #5
   2f390:	700b      	strb	r3, [r1, #0]
	return 0;
   2f392:	2000      	movs	r0, #0
}
   2f394:	4770      	bx	lr

0002f396 <get_pull>:
	if (flags & GPIO_PULL_UP) {
   2f396:	f010 0f10 	tst.w	r0, #16
   2f39a:	d104      	bne.n	2f3a6 <get_pull+0x10>
	} else if (flags & GPIO_PULL_DOWN) {
   2f39c:	f010 0f20 	tst.w	r0, #32
   2f3a0:	d103      	bne.n	2f3aa <get_pull+0x14>
	return NRF_GPIO_PIN_NOPULL;
   2f3a2:	2000      	movs	r0, #0
   2f3a4:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLUP;
   2f3a6:	2003      	movs	r0, #3
   2f3a8:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLDOWN;
   2f3aa:	2001      	movs	r0, #1
}
   2f3ac:	4770      	bx	lr

0002f3ae <gpio_nrfx_port_get_raw>:
	return port->config;
   2f3ae:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2f3b0:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   2f3b2:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
   2f3b6:	600b      	str	r3, [r1, #0]
}
   2f3b8:	2000      	movs	r0, #0
   2f3ba:	4770      	bx	lr

0002f3bc <gpio_nrfx_port_set_masked_raw>:
	return port->config;
   2f3bc:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2f3be:	685b      	ldr	r3, [r3, #4]
	const uint32_t set_mask = value & mask;
   2f3c0:	ea02 0001 	and.w	r0, r2, r1
	const uint32_t clear_mask = (~set_mask) & mask;
   2f3c4:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
   2f3c8:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    p_reg->OUTCLR = clr_mask;
   2f3cc:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
}
   2f3d0:	2000      	movs	r0, #0
   2f3d2:	4770      	bx	lr

0002f3d4 <gpio_nrfx_port_set_bits_raw>:
	return port->config;
   2f3d4:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2f3d6:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   2f3d8:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
}
   2f3dc:	2000      	movs	r0, #0
   2f3de:	4770      	bx	lr

0002f3e0 <gpio_nrfx_port_clear_bits_raw>:
	return port->config;
   2f3e0:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2f3e2:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   2f3e4:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
}
   2f3e8:	2000      	movs	r0, #0
   2f3ea:	4770      	bx	lr

0002f3ec <gpio_nrfx_port_toggle_bits>:
	return port->config;
   2f3ec:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2f3ee:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   2f3f0:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	const uint32_t set_mask = value & mask;
   2f3f4:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
   2f3f8:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
   2f3fa:	f8c2 0508 	str.w	r0, [r2, #1288]	; 0x508
    p_reg->OUTCLR = clr_mask;
   2f3fe:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
}
   2f402:	2000      	movs	r0, #0
   2f404:	4770      	bx	lr

0002f406 <get_trigger>:
	if (mode == GPIO_INT_MODE_LEVEL) {
   2f406:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
   2f40a:	d007      	beq.n	2f41c <get_trigger+0x16>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   2f40c:	f1b1 6fc0 	cmp.w	r1, #100663296	; 0x6000000
   2f410:	d00d      	beq.n	2f42e <get_trigger+0x28>
   2f412:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
   2f416:	d008      	beq.n	2f42a <get_trigger+0x24>
   2f418:	2001      	movs	r0, #1
}
   2f41a:	4770      	bx	lr
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   2f41c:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
   2f420:	d001      	beq.n	2f426 <get_trigger+0x20>
   2f422:	2005      	movs	r0, #5
   2f424:	4770      	bx	lr
   2f426:	2004      	movs	r0, #4
   2f428:	4770      	bx	lr
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   2f42a:	2002      	movs	r0, #2
   2f42c:	4770      	bx	lr
   2f42e:	2003      	movs	r0, #3
   2f430:	4770      	bx	lr

0002f432 <irq_connect0>:
		      POST_KERNEL,					       \
		      CONFIG_I2C_INIT_PRIORITY,				       \
		      &i2c_nrfx_twim_driver_api)

#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
   2f432:	b508      	push	{r3, lr}
   2f434:	2200      	movs	r2, #0
   2f436:	2101      	movs	r1, #1
   2f438:	2003      	movs	r0, #3
   2f43a:	f7e8 ff5d 	bl	182f8 <z_arm_irq_priority_set>
   2f43e:	bd08      	pop	{r3, pc}

0002f440 <twim_nrfx_pm_action>:
{
   2f440:	b570      	push	{r4, r5, r6, lr}
   2f442:	b082      	sub	sp, #8
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   2f444:	6845      	ldr	r5, [r0, #4]
	switch (action) {
   2f446:	b1b1      	cbz	r1, 2f476 <twim_nrfx_pm_action+0x36>
   2f448:	2901      	cmp	r1, #1
   2f44a:	d127      	bne.n	2f49c <twim_nrfx_pm_action+0x5c>
		ret = pinctrl_apply_state(dev_config->pcfg,
   2f44c:	6a2e      	ldr	r6, [r5, #32]
	ret = pinctrl_lookup_state(config, id, &state);
   2f44e:	aa01      	add	r2, sp, #4
   2f450:	2100      	movs	r1, #0
   2f452:	4630      	mov	r0, r6
   2f454:	f000 fb77 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f458:	1e04      	subs	r4, r0, #0
   2f45a:	db06      	blt.n	2f46a <twim_nrfx_pm_action+0x2a>
	return pinctrl_apply_state_direct(config, state);
   2f45c:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f45e:	6832      	ldr	r2, [r6, #0]
   2f460:	7919      	ldrb	r1, [r3, #4]
   2f462:	6818      	ldr	r0, [r3, #0]
   2f464:	f7f2 fb5a 	bl	21b1c <pinctrl_configure_pins>
   2f468:	4604      	mov	r4, r0
		if (ret < 0) {
   2f46a:	2c00      	cmp	r4, #0
   2f46c:	db18      	blt.n	2f4a0 <twim_nrfx_pm_action+0x60>
		nrfx_twim_enable(&dev_config->twim);
   2f46e:	4628      	mov	r0, r5
   2f470:	f7f6 f986 	bl	25780 <nrfx_twim_enable>
		break;
   2f474:	e014      	b.n	2f4a0 <twim_nrfx_pm_action+0x60>
		nrfx_twim_disable(&dev_config->twim);
   2f476:	4628      	mov	r0, r5
   2f478:	f7f6 f9ac 	bl	257d4 <nrfx_twim_disable>
		ret = pinctrl_apply_state(dev_config->pcfg,
   2f47c:	6a2d      	ldr	r5, [r5, #32]
	ret = pinctrl_lookup_state(config, id, &state);
   2f47e:	aa01      	add	r2, sp, #4
   2f480:	2101      	movs	r1, #1
   2f482:	4628      	mov	r0, r5
   2f484:	f000 fb5f 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f488:	1e04      	subs	r4, r0, #0
   2f48a:	db09      	blt.n	2f4a0 <twim_nrfx_pm_action+0x60>
	return pinctrl_apply_state_direct(config, state);
   2f48c:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f48e:	682a      	ldr	r2, [r5, #0]
   2f490:	7919      	ldrb	r1, [r3, #4]
   2f492:	6818      	ldr	r0, [r3, #0]
   2f494:	f7f2 fb42 	bl	21b1c <pinctrl_configure_pins>
   2f498:	4604      	mov	r4, r0
	return pinctrl_apply_state_direct(config, state);
   2f49a:	e001      	b.n	2f4a0 <twim_nrfx_pm_action+0x60>
	switch (action) {
   2f49c:	f06f 0485 	mvn.w	r4, #133	; 0x85
}
   2f4a0:	4620      	mov	r0, r4
   2f4a2:	b002      	add	sp, #8
   2f4a4:	bd70      	pop	{r4, r5, r6, pc}

0002f4a6 <pwm_nrfx_uninit>:

#ifdef CONFIG_PM_DEVICE
static void pwm_nrfx_uninit(const struct device *dev)
{
   2f4a6:	b510      	push	{r4, lr}
   2f4a8:	4604      	mov	r4, r0
	const struct pwm_nrfx_config *config = dev->config;

	nrfx_pwm_uninit(&config->pwm);
   2f4aa:	6840      	ldr	r0, [r0, #4]
   2f4ac:	f7f4 fec4 	bl	24238 <nrfx_pwm_uninit>

	memset(dev->data, 0, sizeof(struct pwm_nrfx_data));
   2f4b0:	6923      	ldr	r3, [r4, #16]
   2f4b2:	2200      	movs	r2, #0
   2f4b4:	601a      	str	r2, [r3, #0]
   2f4b6:	605a      	str	r2, [r3, #4]
   2f4b8:	609a      	str	r2, [r3, #8]
   2f4ba:	60da      	str	r2, [r3, #12]
}
   2f4bc:	bd10      	pop	{r4, pc}

0002f4be <pwm_nrfx_pm_action>:

static int pwm_nrfx_pm_action(const struct device *dev,
			      enum pm_device_action action)
{
   2f4be:	b530      	push	{r4, r5, lr}
   2f4c0:	b083      	sub	sp, #12
   2f4c2:	4604      	mov	r4, r0
#ifdef CONFIG_PINCTRL
	const struct pwm_nrfx_config *config = dev->config;
   2f4c4:	6845      	ldr	r5, [r0, #4]
#endif
	int ret = 0;

	switch (action) {
   2f4c6:	b1a9      	cbz	r1, 2f4f4 <pwm_nrfx_pm_action+0x36>
   2f4c8:	2901      	cmp	r1, #1
   2f4ca:	d124      	bne.n	2f516 <pwm_nrfx_pm_action+0x58>
	case PM_DEVICE_ACTION_RESUME:
#ifdef CONFIG_PINCTRL
		ret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
   2f4cc:	6aad      	ldr	r5, [r5, #40]	; 0x28
	ret = pinctrl_lookup_state(config, id, &state);
   2f4ce:	aa01      	add	r2, sp, #4
   2f4d0:	2100      	movs	r1, #0
   2f4d2:	4628      	mov	r0, r5
   2f4d4:	f000 fb37 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f4d8:	2800      	cmp	r0, #0
   2f4da:	db05      	blt.n	2f4e8 <pwm_nrfx_pm_action+0x2a>
	return pinctrl_apply_state_direct(config, state);
   2f4dc:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f4de:	682a      	ldr	r2, [r5, #0]
   2f4e0:	7919      	ldrb	r1, [r3, #4]
   2f4e2:	6818      	ldr	r0, [r3, #0]
   2f4e4:	f7f2 fb1a 	bl	21b1c <pinctrl_configure_pins>
		if (ret < 0) {
   2f4e8:	2800      	cmp	r0, #0
   2f4ea:	db16      	blt.n	2f51a <pwm_nrfx_pm_action+0x5c>
			return ret;
		}
#endif
		ret = pwm_nrfx_init(dev);
   2f4ec:	4620      	mov	r0, r4
   2f4ee:	f7f0 ffe3 	bl	204b8 <pwm_nrfx_init>
		break;
   2f4f2:	e012      	b.n	2f51a <pwm_nrfx_pm_action+0x5c>

	case PM_DEVICE_ACTION_SUSPEND:
		pwm_nrfx_uninit(dev);
   2f4f4:	f7ff ffd7 	bl	2f4a6 <pwm_nrfx_uninit>

#ifdef CONFIG_PINCTRL
		ret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_SLEEP);
   2f4f8:	6aac      	ldr	r4, [r5, #40]	; 0x28
	ret = pinctrl_lookup_state(config, id, &state);
   2f4fa:	aa01      	add	r2, sp, #4
   2f4fc:	2101      	movs	r1, #1
   2f4fe:	4620      	mov	r0, r4
   2f500:	f000 fb21 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f504:	2800      	cmp	r0, #0
   2f506:	db08      	blt.n	2f51a <pwm_nrfx_pm_action+0x5c>
	return pinctrl_apply_state_direct(config, state);
   2f508:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f50a:	6822      	ldr	r2, [r4, #0]
   2f50c:	7919      	ldrb	r1, [r3, #4]
   2f50e:	6818      	ldr	r0, [r3, #0]
   2f510:	f7f2 fb04 	bl	21b1c <pinctrl_configure_pins>
	return pinctrl_apply_state_direct(config, state);
   2f514:	e001      	b.n	2f51a <pwm_nrfx_pm_action+0x5c>
	switch (action) {
   2f516:	f06f 0085 	mvn.w	r0, #133	; 0x85
	default:
		return -ENOTSUP;
	}

	return ret;
}
   2f51a:	b003      	add	sp, #12
   2f51c:	bd30      	pop	{r4, r5, pc}

0002f51e <irq_connect1>:
#ifdef CONFIG_SPI_0_NRF_SPI
SPI_NRFX_SPI_DEFINE(0);
#endif

#ifdef CONFIG_SPI_1_NRF_SPI
SPI_NRFX_SPI_DEFINE(1);
   2f51e:	b508      	push	{r3, lr}
   2f520:	2200      	movs	r2, #0
   2f522:	2101      	movs	r1, #1
   2f524:	2004      	movs	r0, #4
   2f526:	f7e8 fee7 	bl	182f8 <z_arm_irq_priority_set>
   2f52a:	bd08      	pop	{r3, pc}

0002f52c <irq_connect2>:
#endif

#ifdef CONFIG_SPI_2_NRF_SPI
SPI_NRFX_SPI_DEFINE(2);
   2f52c:	b508      	push	{r3, lr}
   2f52e:	2200      	movs	r2, #0
   2f530:	2101      	movs	r1, #1
   2f532:	2023      	movs	r0, #35	; 0x23
   2f534:	f7e8 fee0 	bl	182f8 <z_arm_irq_priority_set>
   2f538:	bd08      	pop	{r3, pc}

0002f53a <spi_nrfx_pm_action>:
{
   2f53a:	b530      	push	{r4, r5, lr}
   2f53c:	b083      	sub	sp, #12
	struct spi_nrfx_data *dev_data = dev->data;
   2f53e:	6905      	ldr	r5, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
   2f540:	6844      	ldr	r4, [r0, #4]
	switch (action) {
   2f542:	b181      	cbz	r1, 2f566 <spi_nrfx_pm_action+0x2c>
   2f544:	2901      	cmp	r1, #1
   2f546:	d127      	bne.n	2f598 <spi_nrfx_pm_action+0x5e>
		ret = pinctrl_apply_state(dev_config->pcfg,
   2f548:	6a24      	ldr	r4, [r4, #32]
	ret = pinctrl_lookup_state(config, id, &state);
   2f54a:	aa01      	add	r2, sp, #4
   2f54c:	2100      	movs	r1, #0
   2f54e:	4620      	mov	r0, r4
   2f550:	f000 faf9 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f554:	2800      	cmp	r0, #0
   2f556:	db21      	blt.n	2f59c <spi_nrfx_pm_action+0x62>
	return pinctrl_apply_state_direct(config, state);
   2f558:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f55a:	6822      	ldr	r2, [r4, #0]
   2f55c:	7919      	ldrb	r1, [r3, #4]
   2f55e:	6818      	ldr	r0, [r3, #0]
   2f560:	f7f2 fadc 	bl	21b1c <pinctrl_configure_pins>
	return pinctrl_apply_state_direct(config, state);
   2f564:	e01a      	b.n	2f59c <spi_nrfx_pm_action+0x62>
		if (dev_data->initialized) {
   2f566:	f895 306d 	ldrb.w	r3, [r5, #109]	; 0x6d
   2f56a:	b973      	cbnz	r3, 2f58a <spi_nrfx_pm_action+0x50>
		ret = pinctrl_apply_state(dev_config->pcfg,
   2f56c:	6a24      	ldr	r4, [r4, #32]
	ret = pinctrl_lookup_state(config, id, &state);
   2f56e:	aa01      	add	r2, sp, #4
   2f570:	2101      	movs	r1, #1
   2f572:	4620      	mov	r0, r4
   2f574:	f000 fae7 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f578:	2800      	cmp	r0, #0
   2f57a:	db0f      	blt.n	2f59c <spi_nrfx_pm_action+0x62>
	return pinctrl_apply_state_direct(config, state);
   2f57c:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f57e:	6822      	ldr	r2, [r4, #0]
   2f580:	7919      	ldrb	r1, [r3, #4]
   2f582:	6818      	ldr	r0, [r3, #0]
   2f584:	f7f2 faca 	bl	21b1c <pinctrl_configure_pins>
	return pinctrl_apply_state_direct(config, state);
   2f588:	e008      	b.n	2f59c <spi_nrfx_pm_action+0x62>
			nrfx_spi_uninit(&dev_config->spi);
   2f58a:	4620      	mov	r0, r4
   2f58c:	f7f5 fb74 	bl	24c78 <nrfx_spi_uninit>
			dev_data->initialized = false;
   2f590:	2300      	movs	r3, #0
   2f592:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
   2f596:	e7e9      	b.n	2f56c <spi_nrfx_pm_action+0x32>
	switch (action) {
   2f598:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   2f59c:	b003      	add	sp, #12
   2f59e:	bd30      	pop	{r4, r5, pc}

0002f5a0 <spi_nrfx_transceive>:
{
   2f5a0:	b510      	push	{r4, lr}
   2f5a2:	b082      	sub	sp, #8
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL);
   2f5a4:	2400      	movs	r4, #0
   2f5a6:	9401      	str	r4, [sp, #4]
   2f5a8:	9400      	str	r4, [sp, #0]
   2f5aa:	f7f1 fb91 	bl	20cd0 <transceive>
}
   2f5ae:	b002      	add	sp, #8
   2f5b0:	bd10      	pop	{r4, pc}

0002f5b2 <endtx_isr>:
	const struct uarte_nrfx_config *config = dev->config;
   2f5b2:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   2f5b4:	681b      	ldr	r3, [r3, #0]
	__asm__ volatile(
   2f5b6:	f04f 0140 	mov.w	r1, #64	; 0x40
   2f5ba:	f3ef 8211 	mrs	r2, BASEPRI
   2f5be:	f381 8812 	msr	BASEPRI_MAX, r1
   2f5c2:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f5c6:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   2f5ca:	b131      	cbz	r1, 2f5da <endtx_isr+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f5cc:	2100      	movs	r1, #0
   2f5ce:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   2f5d2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f5d6:	2101      	movs	r1, #1
   2f5d8:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   2f5da:	f382 8811 	msr	BASEPRI, r2
   2f5de:	f3bf 8f6f 	isb	sy
}
   2f5e2:	4770      	bx	lr

0002f5e4 <uarte_nrfx_isr_int>:
{
   2f5e4:	b538      	push	{r3, r4, r5, lr}
	const struct uarte_nrfx_config *config = dev->config;
   2f5e6:	6845      	ldr	r5, [r0, #4]
	return config->uarte_regs;
   2f5e8:	682c      	ldr	r4, [r5, #0]
    return p_reg->INTENSET & mask;
   2f5ea:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   2f5ee:	f413 7f80 	tst.w	r3, #256	; 0x100
   2f5f2:	d002      	beq.n	2f5fa <uarte_nrfx_isr_int+0x16>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f5f4:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
   2f5f8:	b9d3      	cbnz	r3, 2f630 <uarte_nrfx_isr_int+0x4c>
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
   2f5fa:	686b      	ldr	r3, [r5, #4]
   2f5fc:	f013 0f10 	tst.w	r3, #16
   2f600:	d015      	beq.n	2f62e <uarte_nrfx_isr_int+0x4a>
	__asm__ volatile(
   2f602:	f04f 0240 	mov.w	r2, #64	; 0x40
   2f606:	f3ef 8311 	mrs	r3, BASEPRI
   2f60a:	f382 8812 	msr	BASEPRI_MAX, r2
   2f60e:	f3bf 8f6f 	isb	sy
   2f612:	f8d4 2158 	ldr.w	r2, [r4, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   2f616:	b112      	cbz	r2, 2f61e <uarte_nrfx_isr_int+0x3a>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   2f618:	2200      	movs	r2, #0
   2f61a:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   2f61e:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
   2f622:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
	__asm__ volatile(
   2f626:	f383 8811 	msr	BASEPRI, r3
   2f62a:	f3bf 8f6f 	isb	sy
}
   2f62e:	bd38      	pop	{r3, r4, r5, pc}
		endtx_isr(dev);
   2f630:	f7ff ffbf 	bl	2f5b2 <endtx_isr>
   2f634:	e7e1      	b.n	2f5fa <uarte_nrfx_isr_int+0x16>

0002f636 <uarte_nrfx_configure>:
{
   2f636:	b570      	push	{r4, r5, r6, lr}
   2f638:	b082      	sub	sp, #8
	struct uarte_nrfx_data *data = dev->data;
   2f63a:	6905      	ldr	r5, [r0, #16]
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
   2f63c:	794b      	ldrb	r3, [r1, #5]
   2f63e:	2b01      	cmp	r3, #1
   2f640:	d137      	bne.n	2f6b2 <uarte_nrfx_configure+0x7c>
   2f642:	4606      	mov	r6, r0
   2f644:	460c      	mov	r4, r1
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   2f646:	798b      	ldrb	r3, [r1, #6]
   2f648:	2b03      	cmp	r3, #3
   2f64a:	d135      	bne.n	2f6b8 <uarte_nrfx_configure+0x82>
	switch (cfg->flow_ctrl) {
   2f64c:	79cb      	ldrb	r3, [r1, #7]
   2f64e:	b133      	cbz	r3, 2f65e <uarte_nrfx_configure+0x28>
   2f650:	2b01      	cmp	r3, #1
   2f652:	d00e      	beq.n	2f672 <uarte_nrfx_configure+0x3c>
   2f654:	f06f 0385 	mvn.w	r3, #133	; 0x85
}
   2f658:	4618      	mov	r0, r3
   2f65a:	b002      	add	sp, #8
   2f65c:	bd70      	pop	{r4, r5, r6, pc}
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
   2f65e:	2300      	movs	r3, #0
   2f660:	f88d 3004 	strb.w	r3, [sp, #4]
	switch (cfg->parity) {
   2f664:	7923      	ldrb	r3, [r4, #4]
   2f666:	b143      	cbz	r3, 2f67a <uarte_nrfx_configure+0x44>
   2f668:	2b02      	cmp	r3, #2
   2f66a:	d01e      	beq.n	2f6aa <uarte_nrfx_configure+0x74>
   2f66c:	f06f 0385 	mvn.w	r3, #133	; 0x85
   2f670:	e7f2      	b.n	2f658 <uarte_nrfx_configure+0x22>
		uarte_cfg.hwfc = NRF_UARTE_HWFC_ENABLED;
   2f672:	2301      	movs	r3, #1
   2f674:	f88d 3004 	strb.w	r3, [sp, #4]
		break;
   2f678:	e7f4      	b.n	2f664 <uarte_nrfx_configure+0x2e>
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
   2f67a:	2300      	movs	r3, #0
   2f67c:	f88d 3005 	strb.w	r3, [sp, #5]
	if (baudrate_set(dev, cfg->baudrate) != 0) {
   2f680:	6821      	ldr	r1, [r4, #0]
   2f682:	4630      	mov	r0, r6
   2f684:	f7f1 fd20 	bl	210c8 <baudrate_set>
   2f688:	4603      	mov	r3, r0
   2f68a:	b9c0      	cbnz	r0, 2f6be <uarte_nrfx_configure+0x88>
	const struct uarte_nrfx_config *config = dev->config;
   2f68c:	6872      	ldr	r2, [r6, #4]
	return config->uarte_regs;
   2f68e:	6811      	ldr	r1, [r2, #0]
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   2f690:	f89d 2005 	ldrb.w	r2, [sp, #5]
                    | (uint32_t)p_cfg->hwfc;
   2f694:	f89d 0004 	ldrb.w	r0, [sp, #4]
   2f698:	4302      	orrs	r2, r0
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   2f69a:	f8c1 256c 	str.w	r2, [r1, #1388]	; 0x56c
	data->uart_config = *cfg;
   2f69e:	3504      	adds	r5, #4
   2f6a0:	e894 0003 	ldmia.w	r4, {r0, r1}
   2f6a4:	e885 0003 	stmia.w	r5, {r0, r1}
	return 0;
   2f6a8:	e7d6      	b.n	2f658 <uarte_nrfx_configure+0x22>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   2f6aa:	230e      	movs	r3, #14
   2f6ac:	f88d 3005 	strb.w	r3, [sp, #5]
		break;
   2f6b0:	e7e6      	b.n	2f680 <uarte_nrfx_configure+0x4a>
		return -ENOTSUP;
   2f6b2:	f06f 0385 	mvn.w	r3, #133	; 0x85
   2f6b6:	e7cf      	b.n	2f658 <uarte_nrfx_configure+0x22>
		return -ENOTSUP;
   2f6b8:	f06f 0385 	mvn.w	r3, #133	; 0x85
   2f6bc:	e7cc      	b.n	2f658 <uarte_nrfx_configure+0x22>
		return -ENOTSUP;
   2f6be:	f06f 0385 	mvn.w	r3, #133	; 0x85
   2f6c2:	e7c9      	b.n	2f658 <uarte_nrfx_configure+0x22>

0002f6c4 <uarte_nrfx_config_get>:
{
   2f6c4:	460a      	mov	r2, r1
	struct uarte_nrfx_data *data = dev->data;
   2f6c6:	6903      	ldr	r3, [r0, #16]
	*cfg = data->uart_config;
   2f6c8:	3304      	adds	r3, #4
   2f6ca:	e893 0003 	ldmia.w	r3, {r0, r1}
   2f6ce:	e882 0003 	stmia.w	r2, {r0, r1}
}
   2f6d2:	2000      	movs	r0, #0
   2f6d4:	4770      	bx	lr

0002f6d6 <uarte_nrfx_err_check>:
	const struct uarte_nrfx_config *config = dev->config;
   2f6d6:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   2f6d8:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   2f6da:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   2f6de:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   2f6e2:	4770      	bx	lr

0002f6e4 <is_tx_ready>:
	const struct uarte_nrfx_config *config = dev->config;
   2f6e4:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   2f6e6:	681a      	ldr	r2, [r3, #0]
	bool ppi_endtx = config->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   2f6e8:	685b      	ldr	r3, [r3, #4]
   2f6ea:	f003 0302 	and.w	r3, r3, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f6ee:	f8d2 1158 	ldr.w	r1, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   2f6f2:	b929      	cbnz	r1, 2f700 <is_tx_ready+0x1c>
   2f6f4:	b933      	cbnz	r3, 2f704 <is_tx_ready+0x20>
   2f6f6:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   2f6fa:	b92b      	cbnz	r3, 2f708 <is_tx_ready+0x24>
   2f6fc:	2000      	movs	r0, #0
   2f6fe:	4770      	bx	lr
   2f700:	2001      	movs	r0, #1
   2f702:	4770      	bx	lr
   2f704:	2000      	movs	r0, #0
   2f706:	4770      	bx	lr
   2f708:	2001      	movs	r0, #1
}
   2f70a:	4770      	bx	lr

0002f70c <uarte_enable>:
	const struct uarte_nrfx_config *config = dev->config;
   2f70c:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   2f70e:	681b      	ldr	r3, [r3, #0]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   2f710:	2208      	movs	r2, #8
   2f712:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   2f716:	4770      	bx	lr

0002f718 <uart_disable>:
	const struct uarte_nrfx_config *config = dev->config;
   2f718:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   2f71a:	681b      	ldr	r3, [r3, #0]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   2f71c:	2200      	movs	r2, #0
   2f71e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   2f722:	4770      	bx	lr

0002f724 <uarte_nrfx_poll_in>:
{
   2f724:	b410      	push	{r4}
	const struct uarte_nrfx_data *data = dev->data;
   2f726:	6904      	ldr	r4, [r0, #16]
	const struct uarte_nrfx_config *config = dev->config;
   2f728:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   2f72a:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f72c:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   2f730:	b162      	cbz	r2, 2f74c <uarte_nrfx_poll_in+0x28>
	*c = *data->rx_data;
   2f732:	6962      	ldr	r2, [r4, #20]
   2f734:	7812      	ldrb	r2, [r2, #0]
   2f736:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f738:	2000      	movs	r0, #0
   2f73a:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   2f73e:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f742:	2201      	movs	r2, #1
   2f744:	601a      	str	r2, [r3, #0]
}
   2f746:	f85d 4b04 	ldr.w	r4, [sp], #4
   2f74a:	4770      	bx	lr
		return -1;
   2f74c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2f750:	e7f9      	b.n	2f746 <uarte_nrfx_poll_in+0x22>

0002f752 <wait_for_tx_stopped>:
 * There are 2 configurations that must be handled:
 * - ENDTX->TXSTOPPED PPI enabled - just pend until TXSTOPPED event is set
 * - disable ENDTX interrupt and manually trigger STOPTX, pend for TXSTOPPED
 */
static void wait_for_tx_stopped(const struct device *dev)
{
   2f752:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct uarte_nrfx_config *config = dev->config;
   2f754:	6842      	ldr	r2, [r0, #4]
	bool ppi_endtx = config->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   2f756:	6857      	ldr	r7, [r2, #4]
	return config->uarte_regs;
   2f758:	6815      	ldr	r5, [r2, #0]
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
	bool res;

	if (!ppi_endtx) {
   2f75a:	f017 0702 	ands.w	r7, r7, #2
   2f75e:	d118      	bne.n	2f792 <wait_for_tx_stopped+0x40>
   2f760:	4606      	mov	r6, r0
    p_reg->INTENCLR = mask;
   2f762:	f44f 7380 	mov.w	r3, #256	; 0x100
   2f766:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
		 * including the one that uarte interrupt will not preempt.
		 * Disable endtx interrupt to ensure that it will not be triggered
		 * (if in lower priority context) and stop TX if necessary.
		 */
		nrf_uarte_int_disable(uarte, NRF_UARTE_INT_ENDTX_MASK);
		NRFX_WAIT_FOR(is_tx_ready(dev), 1000, 1, res);
   2f76a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   2f76e:	4630      	mov	r0, r6
   2f770:	f7ff ffb8 	bl	2f6e4 <is_tx_ready>
   2f774:	b920      	cbnz	r0, 2f780 <wait_for_tx_stopped+0x2e>
   2f776:	2001      	movs	r0, #1
   2f778:	f000 ff8d 	bl	30696 <nrfx_busy_wait>
   2f77c:	3c01      	subs	r4, #1
   2f77e:	d1f6      	bne.n	2f76e <wait_for_tx_stopped+0x1c>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f780:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
		if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   2f784:	b92b      	cbnz	r3, 2f792 <wait_for_tx_stopped+0x40>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f786:	f8c5 3120 	str.w	r3, [r5, #288]	; 0x120
   2f78a:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f78e:	2301      	movs	r3, #1
   2f790:	60eb      	str	r3, [r5, #12]
		NRFX_WAIT_FOR(is_tx_ready(dev), 1000, 1, res);
   2f792:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f796:	f8d5 3158 	ldr.w	r3, [r5, #344]	; 0x158
			nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDTX);
			nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
		}
	}

	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED),
   2f79a:	b923      	cbnz	r3, 2f7a6 <wait_for_tx_stopped+0x54>
   2f79c:	2001      	movs	r0, #1
   2f79e:	f000 ff7a 	bl	30696 <nrfx_busy_wait>
   2f7a2:	3c01      	subs	r4, #1
   2f7a4:	d1f7      	bne.n	2f796 <wait_for_tx_stopped+0x44>
		      1000, 1, res);

	if (!ppi_endtx) {
   2f7a6:	b91f      	cbnz	r7, 2f7b0 <wait_for_tx_stopped+0x5e>
    p_reg->INTENSET = mask;
   2f7a8:	f44f 7380 	mov.w	r3, #256	; 0x100
   2f7ac:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
		nrf_uarte_int_enable(uarte, NRF_UARTE_INT_ENDTX_MASK);
	}
}
   2f7b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002f7b2 <wait_tx_ready>:
{
   2f7b2:	b570      	push	{r4, r5, r6, lr}
   2f7b4:	4606      	mov	r6, r0
   2f7b6:	e014      	b.n	2f7e2 <wait_tx_ready+0x30>
		if (res) {
   2f7b8:	b17d      	cbz	r5, 2f7da <wait_tx_ready+0x28>
	__asm__ volatile(
   2f7ba:	f04f 0340 	mov.w	r3, #64	; 0x40
   2f7be:	f3ef 8411 	mrs	r4, BASEPRI
   2f7c2:	f383 8812 	msr	BASEPRI_MAX, r3
   2f7c6:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   2f7ca:	4630      	mov	r0, r6
   2f7cc:	f7ff ff8a 	bl	2f6e4 <is_tx_ready>
   2f7d0:	b9a0      	cbnz	r0, 2f7fc <wait_tx_ready+0x4a>
	__asm__ volatile(
   2f7d2:	f384 8811 	msr	BASEPRI, r4
   2f7d6:	f3bf 8f6f 	isb	sy
   2f7da:	2021      	movs	r0, #33	; 0x21
   2f7dc:	2100      	movs	r1, #0
   2f7de:	f7f9 fabd 	bl	28d5c <z_impl_k_sleep>
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   2f7e2:	2464      	movs	r4, #100	; 0x64
   2f7e4:	4630      	mov	r0, r6
   2f7e6:	f7ff ff7d 	bl	2f6e4 <is_tx_ready>
   2f7ea:	4605      	mov	r5, r0
   2f7ec:	2800      	cmp	r0, #0
   2f7ee:	d1e3      	bne.n	2f7b8 <wait_tx_ready+0x6>
   2f7f0:	2001      	movs	r0, #1
   2f7f2:	f000 ff50 	bl	30696 <nrfx_busy_wait>
   2f7f6:	3c01      	subs	r4, #1
   2f7f8:	d1f4      	bne.n	2f7e4 <wait_tx_ready+0x32>
   2f7fa:	e7dd      	b.n	2f7b8 <wait_tx_ready+0x6>
}
   2f7fc:	4620      	mov	r0, r4
   2f7fe:	bd70      	pop	{r4, r5, r6, pc}

0002f800 <tx_start>:
{
   2f800:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2f804:	b082      	sub	sp, #8
   2f806:	4605      	mov	r5, r0
   2f808:	460f      	mov	r7, r1
   2f80a:	4616      	mov	r6, r2
	const struct uarte_nrfx_config *config = dev->config;
   2f80c:	f8d0 8004 	ldr.w	r8, [r0, #4]
	return config->uarte_regs;
   2f810:	f8d8 4000 	ldr.w	r4, [r8]
	(void)pm_device_state_get(dev, &state);
   2f814:	f10d 0107 	add.w	r1, sp, #7
   2f818:	f7fc fea8 	bl	2c56c <pm_device_state_get>
	if (state != PM_DEVICE_STATE_ACTIVE) {
   2f81c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2f820:	b993      	cbnz	r3, 2f848 <tx_start+0x48>

NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2f822:	f8c4 7544 	str.w	r7, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2f826:	f8c4 6548 	str.w	r6, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f82a:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
   2f82e:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
   2f832:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
   2f836:	f8d4 3158 	ldr.w	r3, [r4, #344]	; 0x158
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
   2f83a:	f8d8 3004 	ldr.w	r3, [r8, #4]
   2f83e:	f013 0f10 	tst.w	r3, #16
   2f842:	d104      	bne.n	2f84e <tx_start+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f844:	2301      	movs	r3, #1
   2f846:	60a3      	str	r3, [r4, #8]
}
   2f848:	b002      	add	sp, #8
   2f84a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		uarte_enable(dev, UARTE_LOW_POWER_TX);
   2f84e:	2101      	movs	r1, #1
   2f850:	4628      	mov	r0, r5
   2f852:	f7ff ff5b 	bl	2f70c <uarte_enable>
    p_reg->INTENSET = mask;
   2f856:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   2f85a:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   2f85e:	e7f1      	b.n	2f844 <tx_start+0x44>

0002f860 <uarte_instance_init>:
{
   2f860:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2f864:	b083      	sub	sp, #12
   2f866:	4605      	mov	r5, r0
	const struct uarte_nrfx_config *config = dev->config;
   2f868:	6847      	ldr	r7, [r0, #4]
	return config->uarte_regs;
   2f86a:	683e      	ldr	r6, [r7, #0]
	struct uarte_nrfx_data *data = dev->data;
   2f86c:	f8d0 8010 	ldr.w	r8, [r0, #16]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   2f870:	2100      	movs	r1, #0
   2f872:	f8c6 1500 	str.w	r1, [r6, #1280]	; 0x500
	data->dev = dev;
   2f876:	f8c8 0000 	str.w	r0, [r8]
	err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
   2f87a:	f8d7 900c 	ldr.w	r9, [r7, #12]
	ret = pinctrl_lookup_state(config, id, &state);
   2f87e:	aa01      	add	r2, sp, #4
   2f880:	4648      	mov	r0, r9
   2f882:	f000 f960 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f886:	1e04      	subs	r4, r0, #0
   2f888:	db07      	blt.n	2f89a <uarte_instance_init+0x3a>
	return pinctrl_apply_state_direct(config, state);
   2f88a:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f88c:	f8d9 2000 	ldr.w	r2, [r9]
   2f890:	7919      	ldrb	r1, [r3, #4]
   2f892:	6818      	ldr	r0, [r3, #0]
   2f894:	f7f2 f942 	bl	21b1c <pinctrl_configure_pins>
   2f898:	4604      	mov	r4, r0
	if (err < 0) {
   2f89a:	2c00      	cmp	r4, #0
   2f89c:	db35      	blt.n	2f90a <uarte_instance_init+0xaa>
	err = uarte_nrfx_configure(dev, &data->uart_config);
   2f89e:	f108 0104 	add.w	r1, r8, #4
   2f8a2:	4628      	mov	r0, r5
   2f8a4:	f7ff fec7 	bl	2f636 <uarte_nrfx_configure>
	if (err) {
   2f8a8:	4604      	mov	r4, r0
   2f8aa:	bb70      	cbnz	r0, 2f90a <uarte_instance_init+0xaa>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   2f8ac:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   2f8ae:	f013 0f02 	tst.w	r3, #2
   2f8b2:	d12e      	bne.n	2f912 <uarte_instance_init+0xb2>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   2f8b4:	2308      	movs	r3, #8
   2f8b6:	f8c6 3500 	str.w	r3, [r6, #1280]	; 0x500
		if (!cfg->disable_rx) {
   2f8ba:	7a3b      	ldrb	r3, [r7, #8]
   2f8bc:	b95b      	cbnz	r3, 2f8d6 <uarte_instance_init+0x76>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f8be:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   2f8c2:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, data->rx_data, 1);
   2f8c6:	f8d8 3014 	ldr.w	r3, [r8, #20]

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2f8ca:	f8c6 3534 	str.w	r3, [r6, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   2f8ce:	2301      	movs	r3, #1
   2f8d0:	f8c6 3538 	str.w	r3, [r6, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f8d4:	6033      	str	r3, [r6, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   2f8d6:	687b      	ldr	r3, [r7, #4]
   2f8d8:	f013 0f02 	tst.w	r3, #2
   2f8dc:	d103      	bne.n	2f8e6 <uarte_instance_init+0x86>
    p_reg->INTENSET = mask;
   2f8de:	f44f 7380 	mov.w	r3, #256	; 0x100
   2f8e2:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   2f8e6:	687b      	ldr	r3, [r7, #4]
   2f8e8:	f013 0f10 	tst.w	r3, #16
   2f8ec:	d003      	beq.n	2f8f6 <uarte_instance_init+0x96>
   2f8ee:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   2f8f2:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
	nrf_uarte_tx_buffer_set(uarte, data->char_out, 0);
   2f8f6:	f8d8 3010 	ldr.w	r3, [r8, #16]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2f8fa:	f8c6 3544 	str.w	r3, [r6, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2f8fe:	2300      	movs	r3, #0
   2f900:	f8c6 3548 	str.w	r3, [r6, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f904:	2301      	movs	r3, #1
   2f906:	60b3      	str	r3, [r6, #8]
   2f908:	60f3      	str	r3, [r6, #12]
}
   2f90a:	4620      	mov	r0, r4
   2f90c:	b003      	add	sp, #12
   2f90e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = endtx_stoptx_ppi_init(uarte, data);
   2f912:	4641      	mov	r1, r8
   2f914:	4630      	mov	r0, r6
   2f916:	f7f1 fcb9 	bl	2128c <endtx_stoptx_ppi_init>
		if (err < 0) {
   2f91a:	2800      	cmp	r0, #0
   2f91c:	daca      	bge.n	2f8b4 <uarte_instance_init+0x54>
			return err;
   2f91e:	4604      	mov	r4, r0
   2f920:	e7f3      	b.n	2f90a <uarte_instance_init+0xaa>

0002f922 <uarte_0_init>:
		(__attribute__((__section__(LINKER_DT_NODE_REGION_NAME(	       \
			DT_PHANDLE(UARTE(idx), memory_regions)))))),	       \
		())

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   2f922:	b510      	push	{r4, lr}
   2f924:	4604      	mov	r4, r0
   2f926:	2200      	movs	r2, #0
   2f928:	2101      	movs	r1, #1
   2f92a:	2002      	movs	r0, #2
   2f92c:	f7e8 fce4 	bl	182f8 <z_arm_irq_priority_set>
   2f930:	2002      	movs	r0, #2
   2f932:	f7e8 fcb1 	bl	18298 <arch_irq_enable>
   2f936:	2100      	movs	r1, #0
   2f938:	4620      	mov	r0, r4
   2f93a:	f7ff ff91 	bl	2f860 <uarte_instance_init>
   2f93e:	bd10      	pop	{r4, pc}

0002f940 <uarte_nrfx_pm_action>:
{
   2f940:	b570      	push	{r4, r5, r6, lr}
   2f942:	b082      	sub	sp, #8
	const struct uarte_nrfx_config *config = dev->config;
   2f944:	6846      	ldr	r6, [r0, #4]
	return config->uarte_regs;
   2f946:	6834      	ldr	r4, [r6, #0]
	switch (action) {
   2f948:	b321      	cbz	r1, 2f994 <uarte_nrfx_pm_action+0x54>
   2f94a:	2901      	cmp	r1, #1
   2f94c:	d15a      	bne.n	2fa04 <uarte_nrfx_pm_action+0xc4>
		if (cfg->flags & UARTE_CFG_FLAG_GPIO_MGMT) {
   2f94e:	6873      	ldr	r3, [r6, #4]
   2f950:	f013 0f01 	tst.w	r3, #1
   2f954:	d10d      	bne.n	2f972 <uarte_nrfx_pm_action+0x32>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   2f956:	2308      	movs	r3, #8
   2f958:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   2f95c:	7a33      	ldrb	r3, [r6, #8]
   2f95e:	2b00      	cmp	r3, #0
   2f960:	d154      	bne.n	2fa0c <uarte_nrfx_pm_action+0xcc>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f962:	2000      	movs	r0, #0
   2f964:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
   2f968:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f96c:	2301      	movs	r3, #1
   2f96e:	6023      	str	r3, [r4, #0]
}
   2f970:	e04a      	b.n	2fa08 <uarte_nrfx_pm_action+0xc8>
			ret = pinctrl_apply_state(cfg->pcfg,
   2f972:	68f5      	ldr	r5, [r6, #12]
	ret = pinctrl_lookup_state(config, id, &state);
   2f974:	aa01      	add	r2, sp, #4
   2f976:	2100      	movs	r1, #0
   2f978:	4628      	mov	r0, r5
   2f97a:	f000 f8e4 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f97e:	2800      	cmp	r0, #0
   2f980:	db05      	blt.n	2f98e <uarte_nrfx_pm_action+0x4e>
	return pinctrl_apply_state_direct(config, state);
   2f982:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f984:	682a      	ldr	r2, [r5, #0]
   2f986:	7919      	ldrb	r1, [r3, #4]
   2f988:	6818      	ldr	r0, [r3, #0]
   2f98a:	f7f2 f8c7 	bl	21b1c <pinctrl_configure_pins>
			if (ret < 0) {
   2f98e:	2800      	cmp	r0, #0
   2f990:	dae1      	bge.n	2f956 <uarte_nrfx_pm_action+0x16>
   2f992:	e039      	b.n	2fa08 <uarte_nrfx_pm_action+0xc8>
   2f994:	4605      	mov	r5, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f996:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXSTARTED)) {
   2f99a:	b1ab      	cbz	r3, 2f9c8 <uarte_nrfx_pm_action+0x88>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2f99c:	2301      	movs	r3, #1
   2f99e:	6063      	str	r3, [r4, #4]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2f9a0:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
			while (!nrf_uarte_event_check(uarte,
   2f9a4:	b91b      	cbnz	r3, 2f9ae <uarte_nrfx_pm_action+0x6e>
   2f9a6:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
						      NRF_UARTE_EVENT_RXTO) &&
   2f9aa:	2b00      	cmp	r3, #0
   2f9ac:	d0f8      	beq.n	2f9a0 <uarte_nrfx_pm_action+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2f9ae:	2300      	movs	r3, #0
   2f9b0:	f8c4 314c 	str.w	r3, [r4, #332]	; 0x14c
   2f9b4:	f8d4 214c 	ldr.w	r2, [r4, #332]	; 0x14c
   2f9b8:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
   2f9bc:	f8d4 2144 	ldr.w	r2, [r4, #324]	; 0x144
   2f9c0:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   2f9c4:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
		wait_for_tx_stopped(dev);
   2f9c8:	4628      	mov	r0, r5
   2f9ca:	f7ff fec2 	bl	2f752 <wait_for_tx_stopped>
		uart_disable(dev);
   2f9ce:	4628      	mov	r0, r5
   2f9d0:	f7ff fea2 	bl	2f718 <uart_disable>
		if (cfg->flags & UARTE_CFG_FLAG_GPIO_MGMT) {
   2f9d4:	6873      	ldr	r3, [r6, #4]
   2f9d6:	f013 0f01 	tst.w	r3, #1
   2f9da:	d101      	bne.n	2f9e0 <uarte_nrfx_pm_action+0xa0>
	return 0;
   2f9dc:	2000      	movs	r0, #0
   2f9de:	e013      	b.n	2fa08 <uarte_nrfx_pm_action+0xc8>
			ret = pinctrl_apply_state(cfg->pcfg,
   2f9e0:	68f4      	ldr	r4, [r6, #12]
	ret = pinctrl_lookup_state(config, id, &state);
   2f9e2:	aa01      	add	r2, sp, #4
   2f9e4:	2101      	movs	r1, #1
   2f9e6:	4620      	mov	r0, r4
   2f9e8:	f000 f8ad 	bl	2fb46 <pinctrl_lookup_state>
	if (ret < 0) {
   2f9ec:	2800      	cmp	r0, #0
   2f9ee:	db05      	blt.n	2f9fc <uarte_nrfx_pm_action+0xbc>
	return pinctrl_apply_state_direct(config, state);
   2f9f0:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2f9f2:	6822      	ldr	r2, [r4, #0]
   2f9f4:	7919      	ldrb	r1, [r3, #4]
   2f9f6:	6818      	ldr	r0, [r3, #0]
   2f9f8:	f7f2 f890 	bl	21b1c <pinctrl_configure_pins>
			if (ret < 0) {
   2f9fc:	2800      	cmp	r0, #0
   2f9fe:	db03      	blt.n	2fa08 <uarte_nrfx_pm_action+0xc8>
	return 0;
   2fa00:	2000      	movs	r0, #0
   2fa02:	e001      	b.n	2fa08 <uarte_nrfx_pm_action+0xc8>
	switch (action) {
   2fa04:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   2fa08:	b002      	add	sp, #8
   2fa0a:	bd70      	pop	{r4, r5, r6, pc}
	return 0;
   2fa0c:	2000      	movs	r0, #0
   2fa0e:	e7fb      	b.n	2fa08 <uarte_nrfx_pm_action+0xc8>

0002fa10 <rng_pool_put>:
	uint8_t first = rngp->first_read;
   2fa10:	7842      	ldrb	r2, [r0, #1]
	uint8_t last  = rngp->last;
   2fa12:	7883      	ldrb	r3, [r0, #2]
	uint8_t mask  = rngp->mask;
   2fa14:	f890 c003 	ldrb.w	ip, [r0, #3]
	if (((last - first) & mask) == mask) {
   2fa18:	1a9a      	subs	r2, r3, r2
   2fa1a:	ea3c 0202 	bics.w	r2, ip, r2
   2fa1e:	d008      	beq.n	2fa32 <rng_pool_put+0x22>
	rngp->buffer[last] = byte;
   2fa20:	18c2      	adds	r2, r0, r3
   2fa22:	7151      	strb	r1, [r2, #5]
	rngp->last = (last + 1) & mask;
   2fa24:	3301      	adds	r3, #1
   2fa26:	b25b      	sxtb	r3, r3
   2fa28:	ea03 030c 	and.w	r3, r3, ip
   2fa2c:	7083      	strb	r3, [r0, #2]
	return 0;
   2fa2e:	2000      	movs	r0, #0
   2fa30:	4770      	bx	lr
		return -ENOBUFS;
   2fa32:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   2fa36:	4770      	bx	lr

0002fa38 <rng_pool_init>:
	rngp->first_alloc = 0U;
   2fa38:	2300      	movs	r3, #0
   2fa3a:	7003      	strb	r3, [r0, #0]
	rngp->first_read  = 0U;
   2fa3c:	7043      	strb	r3, [r0, #1]
	rngp->last	  = 0U;
   2fa3e:	7083      	strb	r3, [r0, #2]
	rngp->mask	  = size - 1;
   2fa40:	3901      	subs	r1, #1
   2fa42:	70c1      	strb	r1, [r0, #3]
	rngp->threshold	  = threshold;
   2fa44:	7102      	strb	r2, [r0, #4]
}
   2fa46:	4770      	bx	lr

0002fa48 <entropy_bt_init>:

static int entropy_bt_init(const struct device *dev)
{
	/* Nothing to do */
	return 0;
}
   2fa48:	2000      	movs	r0, #0
   2fa4a:	4770      	bx	lr

0002fa4c <entropy_bt_get_entropy>:

static int entropy_bt_get_entropy(const struct device *dev,
				  uint8_t *buffer, uint16_t length)
{
   2fa4c:	b538      	push	{r3, r4, r5, lr}
   2fa4e:	460c      	mov	r4, r1
   2fa50:	4615      	mov	r5, r2
	if (!bt_is_ready()) {
   2fa52:	f7ea fe53 	bl	1a6fc <bt_is_ready>
   2fa56:	b120      	cbz	r0, 2fa62 <entropy_bt_get_entropy+0x16>
		return -EAGAIN;
	}

	return bt_hci_le_rand(buffer, length);
   2fa58:	4629      	mov	r1, r5
   2fa5a:	4620      	mov	r0, r4
   2fa5c:	f7ea fb84 	bl	1a168 <bt_hci_le_rand>
}
   2fa60:	bd38      	pop	{r3, r4, r5, pc}
		return -EAGAIN;
   2fa62:	f06f 000a 	mvn.w	r0, #10
   2fa66:	e7fb      	b.n	2fa60 <entropy_bt_get_entropy+0x14>

0002fa68 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   2fa68:	4770      	bx	lr

0002fa6a <counter_sub>:
	return (a - b) & COUNTER_MAX;
   2fa6a:	1a40      	subs	r0, r0, r1
}
   2fa6c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   2fa70:	4770      	bx	lr

0002fa72 <event_clear>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   2fa72:	f100 0350 	add.w	r3, r0, #80	; 0x50
   2fa76:	009b      	lsls	r3, r3, #2
   2fa78:	b29b      	uxth	r3, r3
   2fa7a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2fa7e:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
   2fa82:	2200      	movs	r2, #0
   2fa84:	601a      	str	r2, [r3, #0]
   2fa86:	681b      	ldr	r3, [r3, #0]
}
   2fa88:	4770      	bx	lr

0002fa8a <absolute_time_to_cc>:
}
   2fa8a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   2fa8e:	4770      	bx	lr

0002fa90 <full_int_lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   2fa90:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   2fa94:	b672      	cpsid	i
}
   2fa96:	4770      	bx	lr

0002fa98 <full_int_unlock>:
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   2fa98:	f380 8810 	msr	PRIMASK, r0
}
   2fa9c:	4770      	bx	lr

0002fa9e <set_absolute_alarm>:
{
   2fa9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2faa0:	4606      	mov	r6, r0
	uint32_t cc_val = abs_val & COUNTER_MAX;
   2faa2:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	uint32_t prev_cc = get_comparator(chan);
   2faa6:	f7f1 fda7 	bl	215f8 <get_comparator>
   2faaa:	4607      	mov	r7, r0
   2faac:	e019      	b.n	2fae2 <set_absolute_alarm+0x44>
	z_impl_k_busy_wait(usec_to_wait);
   2faae:	2013      	movs	r0, #19
   2fab0:	f001 f883 	bl	30bba <z_impl_k_busy_wait>
}
   2fab4:	e022      	b.n	2fafc <set_absolute_alarm+0x5e>
		event_clear(chan);
   2fab6:	4630      	mov	r0, r6
   2fab8:	f7ff ffdb 	bl	2fa72 <event_clear>
		event_enable(chan);
   2fabc:	4630      	mov	r0, r6
   2fabe:	f7f1 fda3 	bl	21608 <event_enable>
		set_comparator(chan, cc_val);
   2fac2:	4629      	mov	r1, r5
   2fac4:	4630      	mov	r0, r6
   2fac6:	f7f1 fd8d 	bl	215e4 <set_comparator>
		now2 = counter();
   2faca:	f7f1 fdb1 	bl	21630 <counter>
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   2face:	4284      	cmp	r4, r0
   2fad0:	d01e      	beq.n	2fb10 <set_absolute_alarm+0x72>
   2fad2:	1c81      	adds	r1, r0, #2
   2fad4:	4628      	mov	r0, r5
   2fad6:	f7ff ffc8 	bl	2fa6a <counter_sub>
	} while ((now2 != now) &&
   2fada:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   2fade:	d917      	bls.n	2fb10 <set_absolute_alarm+0x72>
		prev_cc = cc_val;
   2fae0:	462f      	mov	r7, r5
		now = counter();
   2fae2:	f7f1 fda5 	bl	21630 <counter>
   2fae6:	4604      	mov	r4, r0
		set_comparator(chan, now);
   2fae8:	4601      	mov	r1, r0
   2faea:	4630      	mov	r0, r6
   2faec:	f7f1 fd7a 	bl	215e4 <set_comparator>
		if (counter_sub(prev_cc, now) == 1) {
   2faf0:	4621      	mov	r1, r4
   2faf2:	4638      	mov	r0, r7
   2faf4:	f7ff ffb9 	bl	2fa6a <counter_sub>
   2faf8:	2801      	cmp	r0, #1
   2fafa:	d0d8      	beq.n	2faae <set_absolute_alarm+0x10>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   2fafc:	1ca7      	adds	r7, r4, #2
   2fafe:	4639      	mov	r1, r7
   2fb00:	4628      	mov	r0, r5
   2fb02:	f7ff ffb2 	bl	2fa6a <counter_sub>
   2fb06:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   2fb0a:	d9d4      	bls.n	2fab6 <set_absolute_alarm+0x18>
			cc_val = now + 2;
   2fb0c:	463d      	mov	r5, r7
   2fb0e:	e7d2      	b.n	2fab6 <set_absolute_alarm+0x18>
}
   2fb10:	4628      	mov	r0, r5
   2fb12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002fb14 <compare_set>:
{
   2fb14:	b5f0      	push	{r4, r5, r6, r7, lr}
   2fb16:	b083      	sub	sp, #12
   2fb18:	4604      	mov	r4, r0
   2fb1a:	4617      	mov	r7, r2
   2fb1c:	461d      	mov	r5, r3
	key = compare_int_lock(chan);
   2fb1e:	f7f1 fd8d 	bl	2163c <compare_int_lock>
   2fb22:	4606      	mov	r6, r0
	int ret = compare_set_nolocks(chan, target_time, handler, user_data);
   2fb24:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2fb26:	9301      	str	r3, [sp, #4]
   2fb28:	9b08      	ldr	r3, [sp, #32]
   2fb2a:	9300      	str	r3, [sp, #0]
   2fb2c:	463a      	mov	r2, r7
   2fb2e:	462b      	mov	r3, r5
   2fb30:	4620      	mov	r0, r4
   2fb32:	f7f1 fe73 	bl	2181c <compare_set_nolocks>
   2fb36:	4605      	mov	r5, r0
	compare_int_unlock(chan, key);
   2fb38:	4631      	mov	r1, r6
   2fb3a:	4620      	mov	r0, r4
   2fb3c:	f7f1 fde2 	bl	21704 <compare_int_unlock>
}
   2fb40:	4628      	mov	r0, r5
   2fb42:	b003      	add	sp, #12
   2fb44:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002fb46 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
   2fb46:	b430      	push	{r4, r5}
	*state = &config->states[0];
   2fb48:	6843      	ldr	r3, [r0, #4]
   2fb4a:	6013      	str	r3, [r2, #0]
	while (*state <= &config->states[config->state_cnt - 1U]) {
   2fb4c:	e001      	b.n	2fb52 <pinctrl_lookup_state+0xc>
		if (id == (*state)->id) {
			return 0;
		}

		(*state)++;
   2fb4e:	3408      	adds	r4, #8
   2fb50:	6014      	str	r4, [r2, #0]
	while (*state <= &config->states[config->state_cnt - 1U]) {
   2fb52:	6814      	ldr	r4, [r2, #0]
   2fb54:	7a03      	ldrb	r3, [r0, #8]
   2fb56:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   2fb5a:	3b01      	subs	r3, #1
   2fb5c:	6845      	ldr	r5, [r0, #4]
   2fb5e:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
   2fb62:	429c      	cmp	r4, r3
   2fb64:	d804      	bhi.n	2fb70 <pinctrl_lookup_state+0x2a>
		if (id == (*state)->id) {
   2fb66:	7963      	ldrb	r3, [r4, #5]
   2fb68:	428b      	cmp	r3, r1
   2fb6a:	d1f0      	bne.n	2fb4e <pinctrl_lookup_state+0x8>
			return 0;
   2fb6c:	2000      	movs	r0, #0
   2fb6e:	e001      	b.n	2fb74 <pinctrl_lookup_state+0x2e>
	}

	return -ENOENT;
   2fb70:	f06f 0001 	mvn.w	r0, #1
}
   2fb74:	bc30      	pop	{r4, r5}
   2fb76:	4770      	bx	lr

0002fb78 <event_packet_is_discardable>:
	switch (hdr->evt) {
   2fb78:	7803      	ldrb	r3, [r0, #0]
   2fb7a:	2b3e      	cmp	r3, #62	; 0x3e
   2fb7c:	d003      	beq.n	2fb86 <event_packet_is_discardable+0xe>
   2fb7e:	2bff      	cmp	r3, #255	; 0xff
   2fb80:	d008      	beq.n	2fb94 <event_packet_is_discardable+0x1c>
   2fb82:	2000      	movs	r0, #0
   2fb84:	4770      	bx	lr
		switch (me->subevent) {
   2fb86:	7883      	ldrb	r3, [r0, #2]
   2fb88:	2b02      	cmp	r3, #2
   2fb8a:	d001      	beq.n	2fb90 <event_packet_is_discardable+0x18>
			return false;
   2fb8c:	2000      	movs	r0, #0
   2fb8e:	4770      	bx	lr
			return true;
   2fb90:	2001      	movs	r0, #1
   2fb92:	4770      	bx	lr
		uint8_t subevent = hci_buf[2];
   2fb94:	7883      	ldrb	r3, [r0, #2]
		switch (subevent) {
   2fb96:	2b80      	cmp	r3, #128	; 0x80
   2fb98:	d001      	beq.n	2fb9e <event_packet_is_discardable+0x26>
			return false;
   2fb9a:	2000      	movs	r0, #0
}
   2fb9c:	4770      	bx	lr
			return true;
   2fb9e:	2001      	movs	r0, #1
   2fba0:	4770      	bx	lr

0002fba2 <fetch_and_process_hci_evt>:
{
   2fba2:	b538      	push	{r3, r4, r5, lr}
   2fba4:	4604      	mov	r4, r0
	errcode = MULTITHREADING_LOCK_ACQUIRE();
   2fba6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2fbaa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2fbae:	f7f2 fb4b 	bl	22248 <multithreading_lock_acquire>
	if (!errcode) {
   2fbb2:	4605      	mov	r5, r0
   2fbb4:	b110      	cbz	r0, 2fbbc <fetch_and_process_hci_evt+0x1a>
	if (errcode) {
   2fbb6:	b145      	cbz	r5, 2fbca <fetch_and_process_hci_evt+0x28>
		return false;
   2fbb8:	2000      	movs	r0, #0
}
   2fbba:	bd38      	pop	{r3, r4, r5, pc}
		errcode = hci_internal_evt_get(p_hci_buffer);
   2fbbc:	4620      	mov	r0, r4
   2fbbe:	f7f2 fda1 	bl	22704 <hci_internal_evt_get>
   2fbc2:	4605      	mov	r5, r0
		MULTITHREADING_LOCK_RELEASE();
   2fbc4:	f7f2 fb4a 	bl	2225c <multithreading_lock_release>
   2fbc8:	e7f5      	b.n	2fbb6 <fetch_and_process_hci_evt+0x14>
	event_packet_process(p_hci_buffer);
   2fbca:	4620      	mov	r0, r4
   2fbcc:	f7f2 fb68 	bl	222a0 <event_packet_process>
	return true;
   2fbd0:	2001      	movs	r0, #1
   2fbd2:	e7f2      	b.n	2fbba <fetch_and_process_hci_evt+0x18>

0002fbd4 <fetch_and_process_acl_data>:
{
   2fbd4:	b538      	push	{r3, r4, r5, lr}
   2fbd6:	4604      	mov	r4, r0
	errcode = MULTITHREADING_LOCK_ACQUIRE();
   2fbd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2fbdc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2fbe0:	f7f2 fb32 	bl	22248 <multithreading_lock_acquire>
	if (!errcode) {
   2fbe4:	4605      	mov	r5, r0
   2fbe6:	b110      	cbz	r0, 2fbee <fetch_and_process_acl_data+0x1a>
	if (errcode) {
   2fbe8:	b145      	cbz	r5, 2fbfc <fetch_and_process_acl_data+0x28>
		return false;
   2fbea:	2000      	movs	r0, #0
}
   2fbec:	bd38      	pop	{r3, r4, r5, pc}
		errcode = sdc_hci_data_get(p_hci_buffer);
   2fbee:	4620      	mov	r0, r4
   2fbf0:	f7dd fdba 	bl	d768 <sdc_hci_data_get>
   2fbf4:	4605      	mov	r5, r0
		MULTITHREADING_LOCK_RELEASE();
   2fbf6:	f7f2 fb31 	bl	2225c <multithreading_lock_release>
   2fbfa:	e7f5      	b.n	2fbe8 <fetch_and_process_acl_data+0x14>
	data_packet_process(p_hci_buffer);
   2fbfc:	4620      	mov	r0, r4
   2fbfe:	f7f2 fb77 	bl	222f0 <data_packet_process>
	return true;
   2fc02:	2001      	movs	r0, #1
   2fc04:	e7f2      	b.n	2fbec <fetch_and_process_acl_data+0x18>

0002fc06 <receive_work_handler>:
{
   2fc06:	b508      	push	{r3, lr}
	hci_driver_receive_process();
   2fc08:	f7f2 fbf6 	bl	223f8 <hci_driver_receive_process>
}
   2fc0c:	bd08      	pop	{r3, pc}

0002fc0e <hci_driver_send>:
{
   2fc0e:	b538      	push	{r3, r4, r5, lr}
	if (!buf->len) {
   2fc10:	8983      	ldrh	r3, [r0, #12]
   2fc12:	b183      	cbz	r3, 2fc36 <hci_driver_send+0x28>
   2fc14:	4604      	mov	r4, r0
   2fc16:	7d03      	ldrb	r3, [r0, #20]
	switch (type) {
   2fc18:	b14b      	cbz	r3, 2fc2e <hci_driver_send+0x20>
   2fc1a:	2b02      	cmp	r3, #2
   2fc1c:	d10e      	bne.n	2fc3c <hci_driver_send+0x2e>
		err = acl_handle(buf);
   2fc1e:	f7f2 fc13 	bl	22448 <acl_handle>
   2fc22:	4605      	mov	r5, r0
	if (!err) {
   2fc24:	b965      	cbnz	r5, 2fc40 <hci_driver_send+0x32>
		net_buf_unref(buf);
   2fc26:	4620      	mov	r0, r4
   2fc28:	f7ef f974 	bl	1ef14 <net_buf_unref>
   2fc2c:	e008      	b.n	2fc40 <hci_driver_send+0x32>
		err = cmd_handle(buf);
   2fc2e:	f7f2 fc29 	bl	22484 <cmd_handle>
   2fc32:	4605      	mov	r5, r0
		break;
   2fc34:	e7f6      	b.n	2fc24 <hci_driver_send+0x16>
		return -EINVAL;
   2fc36:	f06f 0515 	mvn.w	r5, #21
   2fc3a:	e001      	b.n	2fc40 <hci_driver_send+0x32>
	switch (type) {
   2fc3c:	f06f 0515 	mvn.w	r5, #21
}
   2fc40:	4628      	mov	r0, r5
   2fc42:	bd38      	pop	{r3, r4, r5, pc}

0002fc44 <configure_supported_features>:
{
   2fc44:	b508      	push	{r3, lr}
			err = sdc_support_adv();
   2fc46:	f7d5 fab9 	bl	51bc <sdc_support_adv>
			if (err) {
   2fc4a:	b960      	cbnz	r0, 2fc66 <configure_supported_features+0x22>
		err = sdc_support_peripheral();
   2fc4c:	f7d5 fae8 	bl	5220 <sdc_support_peripheral>
		if (err) {
   2fc50:	b960      	cbnz	r0, 2fc6c <configure_supported_features+0x28>
			err = sdc_support_dle_peripheral();
   2fc52:	f7d5 fac3 	bl	51dc <sdc_support_dle_peripheral>
			if (err) {
   2fc56:	b960      	cbnz	r0, 2fc72 <configure_supported_features+0x2e>
		err = sdc_support_le_2m_phy();
   2fc58:	f7d5 fad0 	bl	51fc <sdc_support_le_2m_phy>
		if (err) {
   2fc5c:	b960      	cbnz	r0, 2fc78 <configure_supported_features+0x34>
			err = sdc_support_phy_update_peripheral();
   2fc5e:	f7d5 faef 	bl	5240 <sdc_support_phy_update_peripheral>
			if (err) {
   2fc62:	b960      	cbnz	r0, 2fc7e <configure_supported_features+0x3a>
}
   2fc64:	bd08      	pop	{r3, pc}
				return -ENOTSUP;
   2fc66:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2fc6a:	e7fb      	b.n	2fc64 <configure_supported_features+0x20>
			return -ENOTSUP;
   2fc6c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2fc70:	e7f8      	b.n	2fc64 <configure_supported_features+0x20>
				return -ENOTSUP;
   2fc72:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2fc76:	e7f5      	b.n	2fc64 <configure_supported_features+0x20>
			return -ENOTSUP;
   2fc78:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2fc7c:	e7f2      	b.n	2fc64 <configure_supported_features+0x20>
				return -ENOTSUP;
   2fc7e:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2fc82:	e7ef      	b.n	2fc64 <configure_supported_features+0x20>

0002fc84 <command_generates_command_complete_event>:
	switch (hci_opcode) {
   2fc84:	f242 0344 	movw	r3, #8260	; 0x2044
   2fc88:	4298      	cmp	r0, r3
   2fc8a:	d834      	bhi.n	2fcf6 <command_generates_command_complete_event+0x72>
   2fc8c:	f242 030d 	movw	r3, #8205	; 0x200d
   2fc90:	4298      	cmp	r0, r3
   2fc92:	d322      	bcc.n	2fcda <command_generates_command_complete_event+0x56>
   2fc94:	f5a0 5000 	sub.w	r0, r0, #8192	; 0x2000
   2fc98:	380d      	subs	r0, #13
   2fc9a:	2837      	cmp	r0, #55	; 0x37
   2fc9c:	d82f      	bhi.n	2fcfe <command_generates_command_complete_event+0x7a>
   2fc9e:	e8df f000 	tbb	[pc, r0]
   2fca2:	2e28      	.short	0x2e28
   2fca4:	2e2e2e2e 	.word	0x2e2e2e2e
   2fca8:	282e2e28 	.word	0x282e2e28
   2fcac:	2e282e2e 	.word	0x2e282e2e
   2fcb0:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcb4:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcb8:	28282e2e 	.word	0x28282e2e
   2fcbc:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcc0:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcc4:	282e2e2e 	.word	0x282e2e2e
   2fcc8:	2e2e2e2e 	.word	0x2e2e2e2e
   2fccc:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcd0:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcd4:	2e2e2e2e 	.word	0x2e2e2e2e
   2fcd8:	2828      	.short	0x2828
   2fcda:	f240 4306 	movw	r3, #1030	; 0x406
   2fcde:	4298      	cmp	r0, r3
   2fce0:	d00b      	beq.n	2fcfa <command_generates_command_complete_event+0x76>
   2fce2:	f240 431d 	movw	r3, #1053	; 0x41d
   2fce6:	4298      	cmp	r0, r3
   2fce8:	d001      	beq.n	2fcee <command_generates_command_complete_event+0x6a>
		return true;
   2fcea:	2001      	movs	r0, #1
   2fcec:	4770      	bx	lr
	switch (hci_opcode) {
   2fcee:	2000      	movs	r0, #0
   2fcf0:	4770      	bx	lr
   2fcf2:	2000      	movs	r0, #0
   2fcf4:	4770      	bx	lr
		return true;
   2fcf6:	2001      	movs	r0, #1
   2fcf8:	4770      	bx	lr
	switch (hci_opcode) {
   2fcfa:	2000      	movs	r0, #0
   2fcfc:	4770      	bx	lr
		return true;
   2fcfe:	2001      	movs	r0, #1
}
   2fd00:	4770      	bx	lr

0002fd02 <encode_command_status>:
	evt_hdr->evt = BT_HCI_EVT_CMD_STATUS;
   2fd02:	230f      	movs	r3, #15
   2fd04:	7003      	strb	r3, [r0, #0]
	evt_hdr->len = sizeof(struct bt_hci_evt_cmd_status);
   2fd06:	2304      	movs	r3, #4
   2fd08:	7043      	strb	r3, [r0, #1]
	evt_data->status = status_code;
   2fd0a:	7082      	strb	r2, [r0, #2]
	evt_data->ncmd = 1;
   2fd0c:	2301      	movs	r3, #1
   2fd0e:	70c3      	strb	r3, [r0, #3]
	evt_data->opcode = hci_opcode;
   2fd10:	8081      	strh	r1, [r0, #4]
}
   2fd12:	4770      	bx	lr

0002fd14 <encode_command_complete_header>:
	evt_hdr->evt = BT_HCI_EVT_CMD_COMPLETE;
   2fd14:	f04f 0c0e 	mov.w	ip, #14
   2fd18:	f880 c000 	strb.w	ip, [r0]
	evt_hdr->len = param_length;
   2fd1c:	7042      	strb	r2, [r0, #1]
	evt_data->ncmd = 1;
   2fd1e:	2201      	movs	r2, #1
   2fd20:	7082      	strb	r2, [r0, #2]
	evt_data->opcode = hci_opcode;
   2fd22:	f8a0 1003 	strh.w	r1, [r0, #3]
	event[BT_HCI_EVT_HDR_SIZE + sizeof(struct bt_hci_evt_cmd_complete)] = status;
   2fd26:	7143      	strb	r3, [r0, #5]
}
   2fd28:	4770      	bx	lr

0002fd2a <le_read_supported_states>:
	*buf = states1;
   2fd2a:	238f      	movs	r3, #143	; 0x8f
   2fd2c:	7003      	strb	r3, [r0, #0]
	*(buf + 4) = states2;
   2fd2e:	23c0      	movs	r3, #192	; 0xc0
   2fd30:	7103      	strb	r3, [r0, #4]
}
   2fd32:	4770      	bx	lr

0002fd34 <status_param_cmd_put>:
}
   2fd34:	2001      	movs	r0, #1
   2fd36:	4770      	bx	lr

0002fd38 <link_control_cmd_put>:
{
   2fd38:	b508      	push	{r3, lr}
	return ((uint16_t)src[1] << 8) | src[0];
   2fd3a:	7842      	ldrb	r2, [r0, #1]
   2fd3c:	f810 3b03 	ldrb.w	r3, [r0], #3
   2fd40:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   2fd44:	b21b      	sxth	r3, r3
	switch (opcode)	{
   2fd46:	f240 4206 	movw	r2, #1030	; 0x406
   2fd4a:	4293      	cmp	r3, r2
   2fd4c:	d005      	beq.n	2fd5a <link_control_cmd_put+0x22>
   2fd4e:	f240 421d 	movw	r2, #1053	; 0x41d
   2fd52:	4293      	cmp	r3, r2
   2fd54:	d004      	beq.n	2fd60 <link_control_cmd_put+0x28>
   2fd56:	2001      	movs	r0, #1
}
   2fd58:	bd08      	pop	{r3, pc}
		return sdc_hci_cmd_lc_disconnect((void *)cmd_params);
   2fd5a:	f7dd fe36 	bl	d9ca <sdc_hci_cmd_lc_disconnect>
   2fd5e:	e7fb      	b.n	2fd58 <link_control_cmd_put+0x20>
		return sdc_hci_cmd_lc_read_remote_version_information((void *)cmd_params);
   2fd60:	f7dd fe35 	bl	d9ce <sdc_hci_cmd_lc_read_remote_version_information>
   2fd64:	e7f8      	b.n	2fd58 <link_control_cmd_put+0x20>

0002fd66 <controller_and_baseband_cmd_put>:
{
   2fd66:	b508      	push	{r3, lr}
   2fd68:	4684      	mov	ip, r0
	uint8_t const *cmd_params = &cmd[BT_HCI_CMD_HDR_SIZE];
   2fd6a:	3003      	adds	r0, #3
   2fd6c:	f89c e001 	ldrb.w	lr, [ip, #1]
   2fd70:	f89c 3000 	ldrb.w	r3, [ip]
   2fd74:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
   2fd78:	b21b      	sxth	r3, r3
	switch (opcode)	{
   2fd7a:	f640 4c63 	movw	ip, #3171	; 0xc63
   2fd7e:	4563      	cmp	r3, ip
   2fd80:	d02c      	beq.n	2fddc <controller_and_baseband_cmd_put+0x76>
   2fd82:	f101 0106 	add.w	r1, r1, #6
   2fd86:	dc16      	bgt.n	2fdb6 <controller_and_baseband_cmd_put+0x50>
   2fd88:	f640 4c03 	movw	ip, #3075	; 0xc03
   2fd8c:	4563      	cmp	r3, ip
   2fd8e:	d022      	beq.n	2fdd6 <controller_and_baseband_cmd_put+0x70>
   2fd90:	f640 4c2d 	movw	ip, #3117	; 0xc2d
   2fd94:	4563      	cmp	r3, ip
   2fd96:	d105      	bne.n	2fda4 <controller_and_baseband_cmd_put+0x3e>
		*param_length_out += sizeof(sdc_hci_cmd_cb_read_transmit_power_level_return_t);
   2fd98:	7813      	ldrb	r3, [r2, #0]
   2fd9a:	3303      	adds	r3, #3
   2fd9c:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_cb_read_transmit_power_level((void *)cmd_params,
   2fd9e:	f7dd fd12 	bl	d7c6 <sdc_hci_cmd_cb_read_transmit_power_level>
   2fda2:	e007      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>
	switch (opcode)	{
   2fda4:	f640 4201 	movw	r2, #3073	; 0xc01
   2fda8:	4293      	cmp	r3, r2
   2fdaa:	d102      	bne.n	2fdb2 <controller_and_baseband_cmd_put+0x4c>
		return sdc_hci_cmd_cb_set_event_mask((void *)cmd_params);
   2fdac:	f7dd fd0d 	bl	d7ca <sdc_hci_cmd_cb_set_event_mask>
   2fdb0:	e000      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>
	switch (opcode)	{
   2fdb2:	2001      	movs	r0, #1
}
   2fdb4:	bd08      	pop	{r3, pc}
	switch (opcode)	{
   2fdb6:	f640 4c7b 	movw	ip, #3195	; 0xc7b
   2fdba:	4563      	cmp	r3, ip
   2fdbc:	d011      	beq.n	2fde2 <controller_and_baseband_cmd_put+0x7c>
   2fdbe:	f640 4c7c 	movw	ip, #3196	; 0xc7c
   2fdc2:	4563      	cmp	r3, ip
   2fdc4:	d105      	bne.n	2fdd2 <controller_and_baseband_cmd_put+0x6c>
		*param_length_out +=
   2fdc6:	7813      	ldrb	r3, [r2, #0]
   2fdc8:	3302      	adds	r3, #2
   2fdca:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_cb_write_authenticated_payload_timeout((void *)cmd_params,
   2fdcc:	f7dd fd07 	bl	d7de <sdc_hci_cmd_cb_write_authenticated_payload_timeout>
   2fdd0:	e7f0      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>
	switch (opcode)	{
   2fdd2:	2001      	movs	r0, #1
   2fdd4:	e7ee      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>
		return sdc_hci_cmd_cb_reset();
   2fdd6:	f7d5 fb73 	bl	54c0 <sdc_hci_cmd_cb_reset>
   2fdda:	e7eb      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>
		return sdc_hci_cmd_cb_set_event_mask_page_2((void *)cmd_params);
   2fddc:	f7dd fcfa 	bl	d7d4 <sdc_hci_cmd_cb_set_event_mask_page_2>
   2fde0:	e7e8      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>
		*param_length_out +=
   2fde2:	7813      	ldrb	r3, [r2, #0]
   2fde4:	3304      	adds	r3, #4
   2fde6:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_cb_read_authenticated_payload_timeout((void *)cmd_params,
   2fde8:	f7dd fceb 	bl	d7c2 <sdc_hci_cmd_cb_read_authenticated_payload_timeout>
   2fdec:	e7e2      	b.n	2fdb4 <controller_and_baseband_cmd_put+0x4e>

0002fdee <supported_commands>:
{
   2fdee:	b510      	push	{r4, lr}
   2fdf0:	4604      	mov	r4, r0
   2fdf2:	222f      	movs	r2, #47	; 0x2f
   2fdf4:	2100      	movs	r1, #0
   2fdf6:	f001 f857 	bl	30ea8 <memset>
	cmds->hci_disconnect = 1;
   2fdfa:	7823      	ldrb	r3, [r4, #0]
   2fdfc:	f043 0320 	orr.w	r3, r3, #32
   2fe00:	7023      	strb	r3, [r4, #0]
	cmds->hci_read_remote_version_information = 1;
   2fe02:	78a3      	ldrb	r3, [r4, #2]
   2fe04:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2fe08:	70a3      	strb	r3, [r4, #2]
	cmds->hci_set_event_mask = 1;
   2fe0a:	7963      	ldrb	r3, [r4, #5]
   2fe0c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2fe10:	7163      	strb	r3, [r4, #5]
	cmds->hci_reset = 1;
   2fe12:	b2db      	uxtb	r3, r3
   2fe14:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2fe18:	7163      	strb	r3, [r4, #5]
	cmds->hci_read_transmit_power_level = 1;
   2fe1a:	7aa3      	ldrb	r3, [r4, #10]
   2fe1c:	f043 0304 	orr.w	r3, r3, #4
   2fe20:	72a3      	strb	r3, [r4, #10]
	cmds->hci_read_local_version_information = 1;
   2fe22:	7ba3      	ldrb	r3, [r4, #14]
   2fe24:	f043 0308 	orr.w	r3, r3, #8
   2fe28:	73a3      	strb	r3, [r4, #14]
	cmds->hci_read_local_supported_features = 1;
   2fe2a:	b2db      	uxtb	r3, r3
   2fe2c:	f043 0320 	orr.w	r3, r3, #32
   2fe30:	73a3      	strb	r3, [r4, #14]
	cmds->hci_read_bd_addr = 1;
   2fe32:	7be3      	ldrb	r3, [r4, #15]
   2fe34:	f043 0302 	orr.w	r3, r3, #2
   2fe38:	73e3      	strb	r3, [r4, #15]
	cmds->hci_set_event_mask_page_2 = 1;
   2fe3a:	7da3      	ldrb	r3, [r4, #22]
   2fe3c:	f043 0304 	orr.w	r3, r3, #4
   2fe40:	75a3      	strb	r3, [r4, #22]
	cmds->hci_le_set_event_mask = 1;
   2fe42:	7e63      	ldrb	r3, [r4, #25]
   2fe44:	f043 0301 	orr.w	r3, r3, #1
   2fe48:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_read_buffer_size_v1 = 1;
   2fe4a:	b2db      	uxtb	r3, r3
   2fe4c:	f043 0302 	orr.w	r3, r3, #2
   2fe50:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_read_local_supported_features = 1;
   2fe52:	b2db      	uxtb	r3, r3
   2fe54:	f043 0304 	orr.w	r3, r3, #4
   2fe58:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_set_random_address = 1;
   2fe5a:	b2db      	uxtb	r3, r3
   2fe5c:	f043 0310 	orr.w	r3, r3, #16
   2fe60:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_set_advertising_parameters = 1;
   2fe62:	b2db      	uxtb	r3, r3
   2fe64:	f043 0320 	orr.w	r3, r3, #32
   2fe68:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_read_advertising_physical_channel_tx_power = 1;
   2fe6a:	b2db      	uxtb	r3, r3
   2fe6c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2fe70:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_set_advertising_data = 1;
   2fe72:	b2db      	uxtb	r3, r3
   2fe74:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2fe78:	7663      	strb	r3, [r4, #25]
	cmds->hci_le_set_scan_response_data = 1;
   2fe7a:	7ea3      	ldrb	r3, [r4, #26]
   2fe7c:	f043 0301 	orr.w	r3, r3, #1
   2fe80:	76a3      	strb	r3, [r4, #26]
	cmds->hci_le_set_advertising_enable = 1;
   2fe82:	b2db      	uxtb	r3, r3
   2fe84:	f043 0302 	orr.w	r3, r3, #2
   2fe88:	76a3      	strb	r3, [r4, #26]
	cmds->hci_le_read_filter_accept_list_size = 1;
   2fe8a:	b2db      	uxtb	r3, r3
   2fe8c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2fe90:	76a3      	strb	r3, [r4, #26]
	cmds->hci_le_clear_filter_accept_list = 1;
   2fe92:	b2db      	uxtb	r3, r3
   2fe94:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2fe98:	76a3      	strb	r3, [r4, #26]
	cmds->hci_le_add_device_to_filter_accept_list = 1;
   2fe9a:	7ee3      	ldrb	r3, [r4, #27]
   2fe9c:	f043 0301 	orr.w	r3, r3, #1
   2fea0:	76e3      	strb	r3, [r4, #27]
	cmds->hci_le_remove_device_from_filter_accept_list = 1;
   2fea2:	b2db      	uxtb	r3, r3
   2fea4:	f043 0302 	orr.w	r3, r3, #2
   2fea8:	76e3      	strb	r3, [r4, #27]
	cmds->hci_le_read_channel_map = 1;
   2feaa:	b2db      	uxtb	r3, r3
   2feac:	f043 0310 	orr.w	r3, r3, #16
   2feb0:	76e3      	strb	r3, [r4, #27]
	cmds->hci_le_read_remote_features = 1;
   2feb2:	b2db      	uxtb	r3, r3
   2feb4:	f043 0320 	orr.w	r3, r3, #32
   2feb8:	76e3      	strb	r3, [r4, #27]
	cmds->hci_le_encrypt = 1;
   2feba:	b2db      	uxtb	r3, r3
   2febc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2fec0:	76e3      	strb	r3, [r4, #27]
	cmds->hci_le_rand = 1;
   2fec2:	b2db      	uxtb	r3, r3
   2fec4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2fec8:	76e3      	strb	r3, [r4, #27]
	cmds->hci_le_long_term_key_request_reply = 1;
   2feca:	7f23      	ldrb	r3, [r4, #28]
   2fecc:	f043 0302 	orr.w	r3, r3, #2
   2fed0:	7723      	strb	r3, [r4, #28]
	cmds->hci_le_long_term_key_request_negative_reply = 1;
   2fed2:	b2db      	uxtb	r3, r3
   2fed4:	f043 0304 	orr.w	r3, r3, #4
   2fed8:	7723      	strb	r3, [r4, #28]
	cmds->hci_le_read_supported_states = 1;
   2feda:	b2db      	uxtb	r3, r3
   2fedc:	f043 0308 	orr.w	r3, r3, #8
   2fee0:	7723      	strb	r3, [r4, #28]
	cmds->hci_le_receiver_test_v1 = 1;
   2fee2:	b2db      	uxtb	r3, r3
   2fee4:	f043 0310 	orr.w	r3, r3, #16
   2fee8:	7723      	strb	r3, [r4, #28]
	cmds->hci_le_transmitter_test_v1 = 1;
   2feea:	b2db      	uxtb	r3, r3
   2feec:	f043 0320 	orr.w	r3, r3, #32
   2fef0:	7723      	strb	r3, [r4, #28]
	cmds->hci_le_test_end = 1;
   2fef2:	b2db      	uxtb	r3, r3
   2fef4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2fef8:	7723      	strb	r3, [r4, #28]
	cmds->hci_read_authenticated_payload_timeout = 1;
   2fefa:	f894 3020 	ldrb.w	r3, [r4, #32]
   2fefe:	f043 0310 	orr.w	r3, r3, #16
   2ff02:	f884 3020 	strb.w	r3, [r4, #32]
	cmds->hci_write_authenticated_payload_timeout = 1;
   2ff06:	b2db      	uxtb	r3, r3
   2ff08:	f043 0320 	orr.w	r3, r3, #32
   2ff0c:	f884 3020 	strb.w	r3, [r4, #32]
	cmds->hci_le_set_data_length = 1;
   2ff10:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   2ff14:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2ff18:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	cmds->hci_le_read_suggested_default_data_length = 1;
   2ff1c:	b2db      	uxtb	r3, r3
   2ff1e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2ff22:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
	cmds->hci_le_write_suggested_default_data_length = 1;
   2ff26:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   2ff2a:	f043 0301 	orr.w	r3, r3, #1
   2ff2e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	cmds->hci_le_read_maximum_data_length = 1;
   2ff32:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
   2ff36:	f043 0308 	orr.w	r3, r3, #8
   2ff3a:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	cmds->hci_le_read_phy = 1;
   2ff3e:	b2db      	uxtb	r3, r3
   2ff40:	f043 0310 	orr.w	r3, r3, #16
   2ff44:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	cmds->hci_le_set_default_phy = 1;
   2ff48:	b2db      	uxtb	r3, r3
   2ff4a:	f043 0320 	orr.w	r3, r3, #32
   2ff4e:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	cmds->hci_le_set_phy = 1;
   2ff52:	b2db      	uxtb	r3, r3
   2ff54:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2ff58:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	cmds->hci_le_receiver_test_v2 = 1;
   2ff5c:	b2db      	uxtb	r3, r3
   2ff5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2ff62:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	cmds->hci_le_transmitter_test_v2 = 1;
   2ff66:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   2ff6a:	f043 0301 	orr.w	r3, r3, #1
   2ff6e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	cmds->hci_le_read_transmit_power = 1;
   2ff72:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
   2ff76:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2ff7a:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
	cmds->hci_le_read_local_p256_public_key = 1;
   2ff7e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   2ff82:	f043 0302 	orr.w	r3, r3, #2
   2ff86:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	cmds->hci_le_generate_dhkey_v1 = 1;
   2ff8a:	b2db      	uxtb	r3, r3
   2ff8c:	f043 0304 	orr.w	r3, r3, #4
   2ff90:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	cmds->hci_le_generate_dhkey_v2 = 1;
   2ff94:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
   2ff98:	f043 0304 	orr.w	r3, r3, #4
   2ff9c:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
}
   2ffa0:	bd10      	pop	{r4, pc}

0002ffa2 <supported_features>:
   2ffa2:	2300      	movs	r3, #0
   2ffa4:	6003      	str	r3, [r0, #0]
   2ffa6:	6043      	str	r3, [r0, #4]
	features->bdedr_not_supported = 1;
   2ffa8:	7903      	ldrb	r3, [r0, #4]
   2ffaa:	f043 0320 	orr.w	r3, r3, #32
   2ffae:	7103      	strb	r3, [r0, #4]
	features->le_supported = 1;
   2ffb0:	b2db      	uxtb	r3, r3
   2ffb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2ffb6:	7103      	strb	r3, [r0, #4]
}
   2ffb8:	4770      	bx	lr

0002ffba <info_param_cmd_put>:
{
   2ffba:	b508      	push	{r3, lr}
   2ffbc:	4684      	mov	ip, r0
	uint8_t * const event_out_params = &raw_event_out[CMD_COMPLETE_MIN_SIZE];
   2ffbe:	1d88      	adds	r0, r1, #6
   2ffc0:	f89c e001 	ldrb.w	lr, [ip, #1]
   2ffc4:	f89c 3000 	ldrb.w	r3, [ip]
   2ffc8:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
   2ffcc:	b21b      	sxth	r3, r3
	switch (opcode)	{
   2ffce:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
   2ffd2:	3b01      	subs	r3, #1
   2ffd4:	2b08      	cmp	r3, #8
   2ffd6:	d820      	bhi.n	3001a <info_param_cmd_put+0x60>
   2ffd8:	e8df f003 	tbb	[pc, r3]
   2ffdc:	1f120b05 	.word	0x1f120b05
   2ffe0:	1f1f1f1f 	.word	0x1f1f1f1f
   2ffe4:	19          	.byte	0x19
   2ffe5:	00          	.byte	0x00
		*param_length_out += sizeof(sdc_hci_cmd_ip_read_local_version_information_return_t);
   2ffe6:	7813      	ldrb	r3, [r2, #0]
   2ffe8:	3308      	adds	r3, #8
   2ffea:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_ip_read_local_version_information((void *)event_out_params);
   2ffec:	f7dd fcb0 	bl	d950 <sdc_hci_cmd_ip_read_local_version_information>
   2fff0:	e014      	b.n	3001c <info_param_cmd_put+0x62>
		*param_length_out += sizeof(sdc_hci_cmd_ip_read_local_supported_commands_return_t);
   2fff2:	7813      	ldrb	r3, [r2, #0]
   2fff4:	3340      	adds	r3, #64	; 0x40
   2fff6:	7013      	strb	r3, [r2, #0]
		supported_commands((void *)event_out_params);
   2fff8:	f7ff fef9 	bl	2fdee <supported_commands>
		return 0;
   2fffc:	2000      	movs	r0, #0
   2fffe:	e00d      	b.n	3001c <info_param_cmd_put+0x62>
		*param_length_out += sizeof(sdc_hci_cmd_ip_read_local_supported_features_return_t);
   30000:	7813      	ldrb	r3, [r2, #0]
   30002:	3308      	adds	r3, #8
   30004:	7013      	strb	r3, [r2, #0]
		supported_features((void *)event_out_params);
   30006:	f7ff ffcc 	bl	2ffa2 <supported_features>
		return 0;
   3000a:	2000      	movs	r0, #0
   3000c:	e006      	b.n	3001c <info_param_cmd_put+0x62>
		*param_length_out += sizeof(sdc_hci_cmd_ip_read_bd_addr_return_t);
   3000e:	7813      	ldrb	r3, [r2, #0]
   30010:	3306      	adds	r3, #6
   30012:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_ip_read_bd_addr((void *)event_out_params);
   30014:	f7dd fc9a 	bl	d94c <sdc_hci_cmd_ip_read_bd_addr>
   30018:	e000      	b.n	3001c <info_param_cmd_put+0x62>
	switch (opcode)	{
   3001a:	2001      	movs	r0, #1
}
   3001c:	bd08      	pop	{r3, pc}

0003001e <le_supported_features>:
   3001e:	2300      	movs	r3, #0
   30020:	6003      	str	r3, [r0, #0]
   30022:	7103      	strb	r3, [r0, #4]
	features->le_encryption = 1;
   30024:	7803      	ldrb	r3, [r0, #0]
   30026:	f043 0301 	orr.w	r3, r3, #1
   3002a:	7003      	strb	r3, [r0, #0]
	features->extended_reject_indication = 1;
   3002c:	b2db      	uxtb	r3, r3
   3002e:	f043 0304 	orr.w	r3, r3, #4
   30032:	7003      	strb	r3, [r0, #0]
	features->slave_initiated_features_exchange = 1;
   30034:	b2db      	uxtb	r3, r3
   30036:	f043 0308 	orr.w	r3, r3, #8
   3003a:	7003      	strb	r3, [r0, #0]
	features->le_ping = 1;
   3003c:	b2db      	uxtb	r3, r3
   3003e:	f043 0310 	orr.w	r3, r3, #16
   30042:	7003      	strb	r3, [r0, #0]
	features->le_data_packet_length_extension = 1;
   30044:	b2db      	uxtb	r3, r3
   30046:	f043 0320 	orr.w	r3, r3, #32
   3004a:	7003      	strb	r3, [r0, #0]
	features->le_2m_phy = 1;
   3004c:	7843      	ldrb	r3, [r0, #1]
   3004e:	f043 0301 	orr.w	r3, r3, #1
   30052:	7043      	strb	r3, [r0, #1]
	features->channel_selection_algorithm_2 = 1;
   30054:	b2db      	uxtb	r3, r3
   30056:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3005a:	7043      	strb	r3, [r0, #1]
}
   3005c:	4770      	bx	lr

0003005e <vs_zephyr_supported_commands>:
   3005e:	2300      	movs	r3, #0
   30060:	8003      	strh	r3, [r0, #0]
	cmds->read_version_info = 1;
   30062:	7803      	ldrb	r3, [r0, #0]
   30064:	f043 0301 	orr.w	r3, r3, #1
   30068:	7003      	strb	r3, [r0, #0]
	cmds->read_supported_commands = 1;
   3006a:	b2db      	uxtb	r3, r3
   3006c:	f043 0302 	orr.w	r3, r3, #2
   30070:	7003      	strb	r3, [r0, #0]
	cmds->write_bd_addr = 1;
   30072:	b2db      	uxtb	r3, r3
   30074:	f043 0320 	orr.w	r3, r3, #32
   30078:	7003      	strb	r3, [r0, #0]
	cmds->read_static_addresses = 1;
   3007a:	7843      	ldrb	r3, [r0, #1]
   3007c:	f043 0301 	orr.w	r3, r3, #1
   30080:	7043      	strb	r3, [r0, #1]
	cmds->read_key_hierarchy_roots = 1;
   30082:	b2db      	uxtb	r3, r3
   30084:	f043 0302 	orr.w	r3, r3, #2
   30088:	7043      	strb	r3, [r0, #1]
	cmds->read_chip_temperature = 1;
   3008a:	b2db      	uxtb	r3, r3
   3008c:	f043 0304 	orr.w	r3, r3, #4
   30090:	7043      	strb	r3, [r0, #1]
}
   30092:	4770      	bx	lr

00030094 <vs_supported_commands>:
   30094:	2300      	movs	r3, #0
   30096:	8003      	strh	r3, [r0, #0]
	cmds->read_supported_vs_commands = 1;
   30098:	7803      	ldrb	r3, [r0, #0]
   3009a:	f043 0301 	orr.w	r3, r3, #1
   3009e:	7003      	strb	r3, [r0, #0]
	cmds->llpm_mode_set = 1;
   300a0:	b2db      	uxtb	r3, r3
   300a2:	f043 0302 	orr.w	r3, r3, #2
   300a6:	7003      	strb	r3, [r0, #0]
	cmds->conn_update = 1;
   300a8:	b2db      	uxtb	r3, r3
   300aa:	f043 0304 	orr.w	r3, r3, #4
   300ae:	7003      	strb	r3, [r0, #0]
	cmds->conn_event_extend = 1;
   300b0:	b2db      	uxtb	r3, r3
   300b2:	f043 0308 	orr.w	r3, r3, #8
   300b6:	7003      	strb	r3, [r0, #0]
	cmds->qos_conn_event_report_enable = 1;
   300b8:	b2db      	uxtb	r3, r3
   300ba:	f043 0310 	orr.w	r3, r3, #16
   300be:	7003      	strb	r3, [r0, #0]
	cmds->event_length_set = 1;
   300c0:	b2db      	uxtb	r3, r3
   300c2:	f043 0320 	orr.w	r3, r3, #32
   300c6:	7003      	strb	r3, [r0, #0]
}
   300c8:	4770      	bx	lr

000300ca <le_controller_cmd_put>:
{
   300ca:	b508      	push	{r3, lr}
   300cc:	4684      	mov	ip, r0
	uint8_t const *cmd_params = &cmd[BT_HCI_CMD_HDR_SIZE];
   300ce:	3003      	adds	r0, #3
	uint8_t * const event_out_params = &raw_event_out[CMD_COMPLETE_MIN_SIZE];
   300d0:	3106      	adds	r1, #6
   300d2:	f89c e001 	ldrb.w	lr, [ip, #1]
   300d6:	f89c 3000 	ldrb.w	r3, [ip]
   300da:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
   300de:	b21b      	sxth	r3, r3
	switch (opcode)	{
   300e0:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
   300e4:	3b01      	subs	r3, #1
   300e6:	2b5d      	cmp	r3, #93	; 0x5d
   300e8:	f200 80c6 	bhi.w	30278 <le_controller_cmd_put+0x1ae>
   300ec:	e8df f003 	tbb	[pc, r3]
   300f0:	c439322f 	.word	0xc439322f
   300f4:	4e474441 	.word	0x4e474441
   300f8:	c4c45451 	.word	0xc4c45451
   300fc:	5e57c4c4 	.word	0x5e57c4c4
   30100:	c4c46461 	.word	0xc4c46461
   30104:	76706d67 	.word	0x76706d67
   30108:	89837dc4 	.word	0x89837dc4
   3010c:	c4c4c4c4 	.word	0xc4c4c4c4
   30110:	9e9791c4 	.word	0x9e9791c4
   30114:	c4c4a4a1 	.word	0xc4c4a4a1
   30118:	c4c4c4c4 	.word	0xc4c4c4c4
   3011c:	b1aac4c4 	.word	0xb1aac4c4
   30120:	c4c4bab7 	.word	0xc4c4bab7
   30124:	c4c4c4c4 	.word	0xc4c4c4c4
   30128:	c4c4c4c4 	.word	0xc4c4c4c4
   3012c:	c4c4c4c4 	.word	0xc4c4c4c4
   30130:	c4c4c4c4 	.word	0xc4c4c4c4
   30134:	c4c4c4c4 	.word	0xc4c4c4c4
   30138:	c4bdc4c4 	.word	0xc4bdc4c4
   3013c:	c4c4c4c4 	.word	0xc4c4c4c4
   30140:	c4c4c4c4 	.word	0xc4c4c4c4
   30144:	c4c4c4c4 	.word	0xc4c4c4c4
   30148:	c4c4c4c4 	.word	0xc4c4c4c4
   3014c:	a7c4      	.short	0xa7c4
		return sdc_hci_cmd_le_set_event_mask((void *)cmd_params);
   3014e:	f7dd fc2f 	bl	d9b0 <sdc_hci_cmd_le_set_event_mask>
   30152:	e092      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_buffer_size_return_t);
   30154:	7813      	ldrb	r3, [r2, #0]
   30156:	3303      	adds	r3, #3
   30158:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_buffer_size((void *)event_out_params);
   3015a:	4608      	mov	r0, r1
   3015c:	f7dd fc0c 	bl	d978 <sdc_hci_cmd_le_read_buffer_size>
   30160:	e08b      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_local_supported_features_return_t);
   30162:	7813      	ldrb	r3, [r2, #0]
   30164:	3308      	adds	r3, #8
   30166:	7013      	strb	r3, [r2, #0]
		le_supported_features((void *)event_out_params);
   30168:	4608      	mov	r0, r1
   3016a:	f7ff ff58 	bl	3001e <le_supported_features>
		return 0;
   3016e:	2000      	movs	r0, #0
   30170:	e083      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_random_address((void *)cmd_params);
   30172:	f7dd fc24 	bl	d9be <sdc_hci_cmd_le_set_random_address>
   30176:	e080      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_adv_params((void *)cmd_params);
   30178:	f7dd fc14 	bl	d9a4 <sdc_hci_cmd_le_set_adv_params>
   3017c:	e07d      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out +=
   3017e:	7813      	ldrb	r3, [r2, #0]
   30180:	3301      	adds	r3, #1
   30182:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_adv_physical_channel_tx_power((void *)event_out_params);
   30184:	4608      	mov	r0, r1
   30186:	f7dd fbf5 	bl	d974 <sdc_hci_cmd_le_read_adv_physical_channel_tx_power>
   3018a:	e076      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_adv_data((void *)cmd_params);
   3018c:	f7dd fc06 	bl	d99c <sdc_hci_cmd_le_set_adv_data>
   30190:	e073      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_scan_response_data((void *)cmd_params);
   30192:	f7dd fc16 	bl	d9c2 <sdc_hci_cmd_le_set_scan_response_data>
   30196:	e070      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_adv_enable((void *)cmd_params);
   30198:	f7dd fc02 	bl	d9a0 <sdc_hci_cmd_le_set_adv_enable>
   3019c:	e06d      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_filter_accept_list_size_return_t);
   3019e:	7813      	ldrb	r3, [r2, #0]
   301a0:	3301      	adds	r3, #1
   301a2:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_filter_accept_list_size((void *)event_out_params);
   301a4:	4608      	mov	r0, r1
   301a6:	f7dd fbeb 	bl	d980 <sdc_hci_cmd_le_read_filter_accept_list_size>
   301aa:	e066      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_clear_filter_accept_list();
   301ac:	f7dd fbd4 	bl	d958 <sdc_hci_cmd_le_clear_filter_accept_list>
   301b0:	e063      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_add_device_to_filter_accept_list((void *)cmd_params);
   301b2:	f7dd fbcf 	bl	d954 <sdc_hci_cmd_le_add_device_to_filter_accept_list>
   301b6:	e060      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_remove_device_from_filter_accept_list((void *)cmd_params);
   301b8:	f7dd fbee 	bl	d998 <sdc_hci_cmd_le_remove_device_from_filter_accept_list>
   301bc:	e05d      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_channel_map_return_t);
   301be:	7813      	ldrb	r3, [r2, #0]
   301c0:	3307      	adds	r3, #7
   301c2:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_channel_map((void *)cmd_params,
   301c4:	f7dd fbda 	bl	d97c <sdc_hci_cmd_le_read_channel_map>
   301c8:	e057      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_read_remote_features((void *)cmd_params);
   301ca:	f7dd fbdf 	bl	d98c <sdc_hci_cmd_le_read_remote_features>
   301ce:	e054      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_encrypt_return_t);
   301d0:	7813      	ldrb	r3, [r2, #0]
   301d2:	3310      	adds	r3, #16
   301d4:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_encrypt((void *)cmd_params, (void *)event_out_params);
   301d6:	f7dd fbc1 	bl	d95c <sdc_hci_cmd_le_encrypt>
   301da:	e04e      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_rand_return_t);
   301dc:	7813      	ldrb	r3, [r2, #0]
   301de:	3308      	adds	r3, #8
   301e0:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_rand((void *)event_out_params);
   301e2:	4608      	mov	r0, r1
   301e4:	f7dd fbc4 	bl	d970 <sdc_hci_cmd_le_rand>
   301e8:	e047      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_long_term_key_request_reply_return_t);
   301ea:	7813      	ldrb	r3, [r2, #0]
   301ec:	3302      	adds	r3, #2
   301ee:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_long_term_key_request_reply((void *)cmd_params,
   301f0:	f7dd fbba 	bl	d968 <sdc_hci_cmd_le_long_term_key_request_reply>
   301f4:	e041      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out +=
   301f6:	7813      	ldrb	r3, [r2, #0]
   301f8:	3302      	adds	r3, #2
   301fa:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_long_term_key_request_negative_reply(
   301fc:	f7dd fbb0 	bl	d960 <sdc_hci_cmd_le_long_term_key_request_negative_reply>
   30200:	e03b      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_supported_states_return_t);
   30202:	7813      	ldrb	r3, [r2, #0]
   30204:	3308      	adds	r3, #8
   30206:	7013      	strb	r3, [r2, #0]
		le_read_supported_states((void *)event_out_params);
   30208:	4608      	mov	r0, r1
   3020a:	f7ff fd8e 	bl	2fd2a <le_read_supported_states>
		return 0;
   3020e:	2000      	movs	r0, #0
   30210:	e033      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_set_data_length_return_t);
   30212:	7813      	ldrb	r3, [r2, #0]
   30214:	3302      	adds	r3, #2
   30216:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_set_data_length((void *)cmd_params, (void *)event_out_params);
   30218:	f7dd fbc6 	bl	d9a8 <sdc_hci_cmd_le_set_data_length>
   3021c:	e02d      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out +=
   3021e:	7813      	ldrb	r3, [r2, #0]
   30220:	3304      	adds	r3, #4
   30222:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_suggested_default_data_length((void *)event_out_params);
   30224:	4608      	mov	r0, r1
   30226:	f7dd fbb3 	bl	d990 <sdc_hci_cmd_le_read_suggested_default_data_length>
   3022a:	e026      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_write_suggested_default_data_length((void *)cmd_params);
   3022c:	f7dd fbcb 	bl	d9c6 <sdc_hci_cmd_le_write_suggested_default_data_length>
   30230:	e023      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return hci_cmd_le_read_local_p256_public_key();
   30232:	f7f2 fc59 	bl	22ae8 <hci_cmd_le_read_local_p256_public_key>
   30236:	e020      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return hci_cmd_le_generate_dhkey((void *)cmd_params);
   30238:	f000 f8ed 	bl	30416 <hci_cmd_le_generate_dhkey>
   3023c:	e01d      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return hci_cmd_le_generate_dhkey_v2((void *)cmd_params);
   3023e:	f000 f8ef 	bl	30420 <hci_cmd_le_generate_dhkey_v2>
   30242:	e01a      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_max_data_length_return_t);
   30244:	7813      	ldrb	r3, [r2, #0]
   30246:	3308      	adds	r3, #8
   30248:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_max_data_length((void *)event_out_params);
   3024a:	4608      	mov	r0, r1
   3024c:	f7dd fb9a 	bl	d984 <sdc_hci_cmd_le_read_max_data_length>
   30250:	e013      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_phy_return_t);
   30252:	7813      	ldrb	r3, [r2, #0]
   30254:	3304      	adds	r3, #4
   30256:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_phy((void *)cmd_params, (void *)event_out_params);
   30258:	f7dd fb96 	bl	d988 <sdc_hci_cmd_le_read_phy>
   3025c:	e00d      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_default_phy((void *)cmd_params);
   3025e:	f7dd fba5 	bl	d9ac <sdc_hci_cmd_le_set_default_phy>
   30262:	e00a      	b.n	3027a <le_controller_cmd_put+0x1b0>
		return sdc_hci_cmd_le_set_phy((void *)cmd_params);
   30264:	f7dd fba9 	bl	d9ba <sdc_hci_cmd_le_set_phy>
   30268:	e007      	b.n	3027a <le_controller_cmd_put+0x1b0>
		*param_length_out += sizeof(sdc_hci_cmd_le_read_transmit_power_return_t);
   3026a:	7813      	ldrb	r3, [r2, #0]
   3026c:	3302      	adds	r3, #2
   3026e:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_le_read_transmit_power((void *)event_out_params);
   30270:	4608      	mov	r0, r1
   30272:	f7dd fb8f 	bl	d994 <sdc_hci_cmd_le_read_transmit_power>
   30276:	e000      	b.n	3027a <le_controller_cmd_put+0x1b0>
	switch (opcode)	{
   30278:	2001      	movs	r0, #1
}
   3027a:	bd08      	pop	{r3, pc}

0003027c <vs_cmd_put>:
{
   3027c:	b508      	push	{r3, lr}
   3027e:	4684      	mov	ip, r0
	uint8_t const *cmd_params = &cmd[BT_HCI_CMD_HDR_SIZE];
   30280:	3003      	adds	r0, #3
	uint8_t * const event_out_params = &raw_event_out[CMD_COMPLETE_MIN_SIZE];
   30282:	3106      	adds	r1, #6
   30284:	f89c e001 	ldrb.w	lr, [ip, #1]
   30288:	f89c 3000 	ldrb.w	r3, [ip]
   3028c:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
	switch (opcode)	{
   30290:	f64f 4c0a 	movw	ip, #64522	; 0xfc0a
   30294:	4563      	cmp	r3, ip
   30296:	d911      	bls.n	302bc <vs_cmd_put+0x40>
   30298:	f64f 5c09 	movw	ip, #64777	; 0xfd09
   3029c:	4563      	cmp	r3, ip
   3029e:	d861      	bhi.n	30364 <vs_cmd_put+0xe8>
   302a0:	f5b3 4f7d 	cmp.w	r3, #64768	; 0xfd00
   302a4:	d31b      	bcc.n	302de <vs_cmd_put+0x62>
   302a6:	f5a3 437d 	sub.w	r3, r3, #64768	; 0xfd00
   302aa:	2b09      	cmp	r3, #9
   302ac:	d856      	bhi.n	3035c <vs_cmd_put+0xe0>
   302ae:	e8df f003 	tbb	[pc, r3]
   302b2:	433b      	.short	0x433b
   302b4:	4f4c4946 	.word	0x4f4c4946
   302b8:	52555555 	.word	0x52555555
   302bc:	f5b3 4f7c 	cmp.w	r3, #64512	; 0xfc00
   302c0:	d801      	bhi.n	302c6 <vs_cmd_put+0x4a>
   302c2:	2001      	movs	r0, #1
}
   302c4:	bd08      	pop	{r3, pc}
	switch (opcode)	{
   302c6:	f5a3 437c 	sub.w	r3, r3, #64512	; 0xfc00
   302ca:	3b01      	subs	r3, #1
   302cc:	2b09      	cmp	r3, #9
   302ce:	d847      	bhi.n	30360 <vs_cmd_put+0xe4>
   302d0:	e8df f003 	tbb	[pc, r3]
   302d4:	46460e07 	.word	0x46460e07
   302d8:	46462746 	.word	0x46462746
   302dc:	2016      	.short	0x2016
   302de:	2001      	movs	r0, #1
   302e0:	e7f0      	b.n	302c4 <vs_cmd_put+0x48>
		*param_length_out += sizeof(sdc_hci_cmd_vs_zephyr_read_version_info_return_t);
   302e2:	7813      	ldrb	r3, [r2, #0]
   302e4:	330c      	adds	r3, #12
   302e6:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_vs_zephyr_read_version_info((void *)event_out_params);
   302e8:	4608      	mov	r0, r1
   302ea:	f7d5 f8fd 	bl	54e8 <sdc_hci_cmd_vs_zephyr_read_version_info>
   302ee:	e7e9      	b.n	302c4 <vs_cmd_put+0x48>
		*param_length_out += sizeof(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t);
   302f0:	7813      	ldrb	r3, [r2, #0]
   302f2:	3340      	adds	r3, #64	; 0x40
   302f4:	7013      	strb	r3, [r2, #0]
		vs_zephyr_supported_commands((void *)event_out_params);
   302f6:	4608      	mov	r0, r1
   302f8:	f7ff feb1 	bl	3005e <vs_zephyr_supported_commands>
		return 0;
   302fc:	2000      	movs	r0, #0
   302fe:	e7e1      	b.n	302c4 <vs_cmd_put+0x48>
		*param_length_out += sizeof(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t);
   30300:	7813      	ldrb	r3, [r2, #0]
   30302:	3301      	adds	r3, #1
   30304:	b2db      	uxtb	r3, r3
   30306:	7013      	strb	r3, [r2, #0]
		*param_length_out += sizeof(sdc_hci_vs_zephyr_static_address_t);
   30308:	3316      	adds	r3, #22
   3030a:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_vs_zephyr_read_static_addresses((void *)event_out_params);
   3030c:	4608      	mov	r0, r1
   3030e:	f7dd facc 	bl	d8aa <sdc_hci_cmd_vs_zephyr_read_static_addresses>
   30312:	e7d7      	b.n	302c4 <vs_cmd_put+0x48>
		*param_length_out +=
   30314:	7813      	ldrb	r3, [r2, #0]
   30316:	3320      	adds	r3, #32
   30318:	7013      	strb	r3, [r2, #0]
		return sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots((void *)event_out_params);
   3031a:	4608      	mov	r0, r1
   3031c:	f7dd fa78 	bl	d810 <sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots>
   30320:	e7d0      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_zephyr_write_bd_addr((void *)cmd_params);
   30322:	f7dd fb11 	bl	d948 <sdc_hci_cmd_vs_zephyr_write_bd_addr>
   30326:	e7cd      	b.n	302c4 <vs_cmd_put+0x48>
		*param_length_out += sizeof(sdc_hci_cmd_vs_read_supported_vs_commands_return_t);
   30328:	7813      	ldrb	r3, [r2, #0]
   3032a:	3340      	adds	r3, #64	; 0x40
   3032c:	7013      	strb	r3, [r2, #0]
		vs_supported_commands((void *)event_out_params);
   3032e:	4608      	mov	r0, r1
   30330:	f7ff feb0 	bl	30094 <vs_supported_commands>
		return 0;
   30334:	2000      	movs	r0, #0
   30336:	e7c5      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_llpm_mode_set((void *)cmd_params);
   30338:	f7dd fa5f 	bl	d7fa <sdc_hci_cmd_vs_llpm_mode_set>
   3033c:	e7c2      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_conn_update((void *)cmd_params);
   3033e:	f7dd fa58 	bl	d7f2 <sdc_hci_cmd_vs_conn_update>
   30342:	e7bf      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_conn_event_extend((void *)cmd_params);
   30344:	f7dd fa4d 	bl	d7e2 <sdc_hci_cmd_vs_conn_event_extend>
   30348:	e7bc      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_qos_conn_event_report_enable((void *)cmd_params);
   3034a:	f7dd fa5c 	bl	d806 <sdc_hci_cmd_vs_qos_conn_event_report_enable>
   3034e:	e7b9      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_event_length_set((void *)cmd_params);
   30350:	f7dd fa51 	bl	d7f6 <sdc_hci_cmd_vs_event_length_set>
   30354:	e7b6      	b.n	302c4 <vs_cmd_put+0x48>
		return sdc_hci_cmd_vs_peripheral_latency_mode_set((void *)cmd_params);
   30356:	f7dd fa52 	bl	d7fe <sdc_hci_cmd_vs_peripheral_latency_mode_set>
   3035a:	e7b3      	b.n	302c4 <vs_cmd_put+0x48>
	switch (opcode)	{
   3035c:	2001      	movs	r0, #1
   3035e:	e7b1      	b.n	302c4 <vs_cmd_put+0x48>
   30360:	2001      	movs	r0, #1
   30362:	e7af      	b.n	302c4 <vs_cmd_put+0x48>
   30364:	2001      	movs	r0, #1
   30366:	e7ad      	b.n	302c4 <vs_cmd_put+0x48>

00030368 <cmd_put>:
{
   30368:	b570      	push	{r4, r5, r6, lr}
   3036a:	b082      	sub	sp, #8
   3036c:	460e      	mov	r6, r1
   3036e:	7842      	ldrb	r2, [r0, #1]
   30370:	7805      	ldrb	r5, [r0, #0]
   30372:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
	uint8_t return_param_length = sizeof(struct bt_hci_evt_cmd_complete)
   30376:	2304      	movs	r3, #4
   30378:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (BT_OGF(opcode)) {
   3037c:	0893      	lsrs	r3, r2, #2
   3037e:	2a23      	cmp	r2, #35	; 0x23
   30380:	d80b      	bhi.n	3039a <cmd_put+0x32>
   30382:	b21a      	sxth	r2, r3
   30384:	2a00      	cmp	r2, #0
   30386:	d03a      	beq.n	303fe <cmd_put+0x96>
   30388:	3b01      	subs	r3, #1
   3038a:	2b07      	cmp	r3, #7
   3038c:	d839      	bhi.n	30402 <cmd_put+0x9a>
   3038e:	e8df f003 	tbb	[pc, r3]
   30392:	381a      	.short	0x381a
   30394:	382a241e 	.word	0x382a241e
   30398:	3038      	.short	0x3038
   3039a:	2b3f      	cmp	r3, #63	; 0x3f
   3039c:	d105      	bne.n	303aa <cmd_put+0x42>
		status = vs_cmd_put(cmd_in,
   3039e:	f10d 0207 	add.w	r2, sp, #7
   303a2:	f7ff ff6b 	bl	3027c <vs_cmd_put>
   303a6:	4604      	mov	r4, r0
		break;
   303a8:	e000      	b.n	303ac <cmd_put+0x44>
	switch (BT_OGF(opcode)) {
   303aa:	2401      	movs	r4, #1
	if (!command_generates_command_complete_event(opcode) ||
   303ac:	4628      	mov	r0, r5
   303ae:	f7ff fc69 	bl	2fc84 <command_generates_command_complete_event>
   303b2:	b108      	cbz	r0, 303b8 <cmd_put+0x50>
   303b4:	2c01      	cmp	r4, #1
   303b6:	d126      	bne.n	30406 <cmd_put+0x9e>
		encode_command_status(raw_event_out, opcode, status);
   303b8:	4622      	mov	r2, r4
   303ba:	4629      	mov	r1, r5
   303bc:	4630      	mov	r0, r6
   303be:	f7ff fca0 	bl	2fd02 <encode_command_status>
}
   303c2:	b002      	add	sp, #8
   303c4:	bd70      	pop	{r4, r5, r6, pc}
		status = link_control_cmd_put(cmd_in);
   303c6:	f7ff fcb7 	bl	2fd38 <link_control_cmd_put>
   303ca:	4604      	mov	r4, r0
		break;
   303cc:	e7ee      	b.n	303ac <cmd_put+0x44>
		status = controller_and_baseband_cmd_put(cmd_in,
   303ce:	f10d 0207 	add.w	r2, sp, #7
   303d2:	f7ff fcc8 	bl	2fd66 <controller_and_baseband_cmd_put>
   303d6:	4604      	mov	r4, r0
		break;
   303d8:	e7e8      	b.n	303ac <cmd_put+0x44>
		status = info_param_cmd_put(cmd_in,
   303da:	f10d 0207 	add.w	r2, sp, #7
   303de:	f7ff fdec 	bl	2ffba <info_param_cmd_put>
   303e2:	4604      	mov	r4, r0
		break;
   303e4:	e7e2      	b.n	303ac <cmd_put+0x44>
		status = status_param_cmd_put(cmd_in,
   303e6:	f10d 0207 	add.w	r2, sp, #7
   303ea:	f7ff fca3 	bl	2fd34 <status_param_cmd_put>
   303ee:	4604      	mov	r4, r0
		break;
   303f0:	e7dc      	b.n	303ac <cmd_put+0x44>
		status = le_controller_cmd_put(cmd_in,
   303f2:	f10d 0207 	add.w	r2, sp, #7
   303f6:	f7ff fe68 	bl	300ca <le_controller_cmd_put>
   303fa:	4604      	mov	r4, r0
		break;
   303fc:	e7d6      	b.n	303ac <cmd_put+0x44>
	switch (BT_OGF(opcode)) {
   303fe:	2401      	movs	r4, #1
   30400:	e7d4      	b.n	303ac <cmd_put+0x44>
   30402:	2401      	movs	r4, #1
   30404:	e7d2      	b.n	303ac <cmd_put+0x44>
		encode_command_complete_header(raw_event_out, opcode, return_param_length, status);
   30406:	4623      	mov	r3, r4
   30408:	f89d 2007 	ldrb.w	r2, [sp, #7]
   3040c:	4629      	mov	r1, r5
   3040e:	4630      	mov	r0, r6
   30410:	f7ff fc80 	bl	2fd14 <encode_command_complete_header>
}
   30414:	e7d5      	b.n	303c2 <cmd_put+0x5a>

00030416 <hci_cmd_le_generate_dhkey>:

uint8_t hci_cmd_le_generate_dhkey(struct bt_hci_cp_le_generate_dhkey *p_params)
{
   30416:	b508      	push	{r3, lr}
	return cmd_le_generate_dhkey(p_params->key,
   30418:	2100      	movs	r1, #0
   3041a:	f7f2 fb7d 	bl	22b18 <cmd_le_generate_dhkey>
				     BT_HCI_LE_KEY_TYPE_GENERATED);
}
   3041e:	bd08      	pop	{r3, pc}

00030420 <hci_cmd_le_generate_dhkey_v2>:

uint8_t hci_cmd_le_generate_dhkey_v2(struct bt_hci_cp_le_generate_dhkey_v2 *p_params)
{
	if (p_params->key_type > BT_HCI_LE_KEY_TYPE_DEBUG) {
   30420:	f890 1040 	ldrb.w	r1, [r0, #64]	; 0x40
   30424:	2901      	cmp	r1, #1
   30426:	d803      	bhi.n	30430 <hci_cmd_le_generate_dhkey_v2+0x10>
{
   30428:	b508      	push	{r3, lr}
		return BT_HCI_ERR_INVALID_PARAM;
	}

	return cmd_le_generate_dhkey(p_params->key, p_params->key_type);
   3042a:	f7f2 fb75 	bl	22b18 <cmd_le_generate_dhkey>
}
   3042e:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_INVALID_PARAM;
   30430:	2012      	movs	r0, #18
}
   30432:	4770      	bx	lr

00030434 <m_config_clock_source_get>:
}
   30434:	2001      	movs	r0, #1
   30436:	4770      	bx	lr

00030438 <mpsl_timer0_isr_wrapper>:
ISR_DIRECT_DECLARE(mpsl_timer0_isr_wrapper)
   30438:	4668      	mov	r0, sp
   3043a:	f020 0107 	bic.w	r1, r0, #7
   3043e:	468d      	mov	sp, r1
   30440:	b501      	push	{r0, lr}
	MPSL_IRQ_TIMER0_Handler();
   30442:	f7d3 fbe7 	bl	3c14 <MPSL_IRQ_TIMER0_Handler>
	ISR_DIRECT_PM();
   30446:	f7e7 ff85 	bl	18354 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   3044a:	f7e8 f921 	bl	18690 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(mpsl_timer0_isr_wrapper)
   3044e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   30452:	4685      	mov	sp, r0
   30454:	4770      	bx	lr

00030456 <mpsl_rtc0_isr_wrapper>:
ISR_DIRECT_DECLARE(mpsl_rtc0_isr_wrapper)
   30456:	4668      	mov	r0, sp
   30458:	f020 0107 	bic.w	r1, r0, #7
   3045c:	468d      	mov	sp, r1
   3045e:	b501      	push	{r0, lr}
	MPSL_IRQ_RTC0_Handler();
   30460:	f7d3 fb4e 	bl	3b00 <MPSL_IRQ_RTC0_Handler>
	ISR_DIRECT_PM();
   30464:	f7e7 ff76 	bl	18354 <_arch_isr_direct_pm>
ISR_DIRECT_DECLARE(mpsl_rtc0_isr_wrapper)
   30468:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3046c:	4685      	mov	sp, r0
   3046e:	4770      	bx	lr

00030470 <mpsl_radio_isr_wrapper>:
ISR_DIRECT_DECLARE(mpsl_radio_isr_wrapper)
   30470:	4668      	mov	r0, sp
   30472:	f020 0107 	bic.w	r1, r0, #7
   30476:	468d      	mov	sp, r1
   30478:	b501      	push	{r0, lr}
	MPSL_IRQ_RADIO_Handler();
   3047a:	f7d1 f8cf 	bl	161c <MPSL_IRQ_RADIO_Handler>
	ISR_DIRECT_PM();
   3047e:	f7e7 ff69 	bl	18354 <_arch_isr_direct_pm>
   30482:	f7e8 f905 	bl	18690 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(mpsl_radio_isr_wrapper)
   30486:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3048a:	4685      	mov	sp, r0
   3048c:	4770      	bx	lr

0003048e <nrfx_clock_enable>:
}
   3048e:	4770      	bx	lr

00030490 <nrfx_power_clock_irq_handler>:


void nrfx_clock_irq_handler(void)
{
   30490:	b508      	push	{r3, lr}
	MPSL_IRQ_CLOCK_Handler();
   30492:	f7d4 f82f 	bl	44f4 <MPSL_IRQ_CLOCK_Handler>
}
   30496:	bd08      	pop	{r3, pc}

00030498 <nrf52_errata_12>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   30498:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   3049c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   304a0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   304a4:	d003      	beq.n	304ae <nrf52_errata_12+0x16>
                var2 = *(uint32_t *)0x10000134ul;
            }
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   304a6:	2b06      	cmp	r3, #6
   304a8:	d006      	beq.n	304b8 <nrf52_errata_12+0x20>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   304aa:	2000      	movs	r0, #0
   304ac:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   304ae:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   304b2:	f893 3fe0 	ldrb.w	r3, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   304b6:	e7f6      	b.n	304a6 <nrf52_errata_12+0xe>
                        return true;
   304b8:	2001      	movs	r0, #1
    #endif
}
   304ba:	4770      	bx	lr

000304bc <nrf52_errata_16>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   304bc:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   304c0:	f893 2fe0 	ldrb.w	r2, [r3, #4064]	; 0xfe0
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   304c4:	f8d3 3fe8 	ldr.w	r3, [r3, #4072]	; 0xfe8
   304c8:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   304cc:	2a06      	cmp	r2, #6
   304ce:	d001      	beq.n	304d4 <nrf52_errata_16+0x18>
                    default:
                        return false;
                }
            }
        #endif
        return false;
   304d0:	2000      	movs	r0, #0
   304d2:	4770      	bx	lr
                switch(var2)
   304d4:	3b03      	subs	r3, #3
   304d6:	2b00      	cmp	r3, #0
   304d8:	d804      	bhi.n	304e4 <nrf52_errata_16+0x28>
   304da:	e8df f003 	tbb	[pc, r3]
   304de:	01          	.byte	0x01
   304df:	00          	.byte	0x00
   304e0:	2001      	movs	r0, #1
   304e2:	4770      	bx	lr
                        return false;
   304e4:	2000      	movs	r0, #0
    #endif
}
   304e6:	4770      	bx	lr

000304e8 <nrf52_errata_31>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   304e8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   304ec:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   304f0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   304f4:	d003      	beq.n	304fe <nrf52_errata_31+0x16>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   304f6:	2b06      	cmp	r3, #6
   304f8:	d006      	beq.n	30508 <nrf52_errata_31+0x20>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   304fa:	2000      	movs	r0, #0
   304fc:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   304fe:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   30502:	f893 3fe0 	ldrb.w	r3, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   30506:	e7f6      	b.n	304f6 <nrf52_errata_31+0xe>
                        return true;
   30508:	2001      	movs	r0, #1
    #endif
}
   3050a:	4770      	bx	lr

0003050c <nrf52_errata_32>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   3050c:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   30510:	f893 2fe0 	ldrb.w	r2, [r3, #4064]	; 0xfe0
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   30514:	f8d3 3fe8 	ldr.w	r3, [r3, #4072]	; 0xfe8
   30518:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   3051c:	2a06      	cmp	r2, #6
   3051e:	d001      	beq.n	30524 <nrf52_errata_32+0x18>
                    default:
                        return false;
                }
            }
        #endif
        return false;
   30520:	2000      	movs	r0, #0
   30522:	4770      	bx	lr
                switch(var2)
   30524:	3b03      	subs	r3, #3
   30526:	2b00      	cmp	r3, #0
   30528:	d804      	bhi.n	30534 <nrf52_errata_32+0x28>
   3052a:	e8df f003 	tbb	[pc, r3]
   3052e:	01          	.byte	0x01
   3052f:	00          	.byte	0x00
   30530:	2001      	movs	r0, #1
   30532:	4770      	bx	lr
                        return false;
   30534:	2000      	movs	r0, #0
    #endif
}
   30536:	4770      	bx	lr

00030538 <nrf52_errata_36>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   30538:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   3053c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   30540:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   30544:	d003      	beq.n	3054e <nrf52_errata_36+0x16>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   30546:	2b06      	cmp	r3, #6
   30548:	d006      	beq.n	30558 <nrf52_errata_36+0x20>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   3054a:	2000      	movs	r0, #0
   3054c:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   3054e:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   30552:	f893 3fe0 	ldrb.w	r3, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   30556:	e7f6      	b.n	30546 <nrf52_errata_36+0xe>
                        return true;
   30558:	2001      	movs	r0, #1
    #endif
}
   3055a:	4770      	bx	lr

0003055c <nrf52_errata_37>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   3055c:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   30560:	f893 2fe0 	ldrb.w	r2, [r3, #4064]	; 0xfe0
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   30564:	f8d3 3fe8 	ldr.w	r3, [r3, #4072]	; 0xfe8
   30568:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   3056c:	2a06      	cmp	r2, #6
   3056e:	d001      	beq.n	30574 <nrf52_errata_37+0x18>
                    default:
                        return false;
                }
            }
        #endif
        return false;
   30570:	2000      	movs	r0, #0
   30572:	4770      	bx	lr
                switch(var2)
   30574:	3b03      	subs	r3, #3
   30576:	2b00      	cmp	r3, #0
   30578:	d804      	bhi.n	30584 <nrf52_errata_37+0x28>
   3057a:	e8df f003 	tbb	[pc, r3]
   3057e:	01          	.byte	0x01
   3057f:	00          	.byte	0x00
   30580:	2001      	movs	r0, #1
   30582:	4770      	bx	lr
                        return false;
   30584:	2000      	movs	r0, #0
    #endif
}
   30586:	4770      	bx	lr

00030588 <nrf52_errata_57>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   30588:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   3058c:	f893 2fe0 	ldrb.w	r2, [r3, #4064]	; 0xfe0
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   30590:	f8d3 3fe8 	ldr.w	r3, [r3, #4072]	; 0xfe8
   30594:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   30598:	2a06      	cmp	r2, #6
   3059a:	d001      	beq.n	305a0 <nrf52_errata_57+0x18>
                    default:
                        return false;
                }
            }
        #endif
        return false;
   3059c:	2000      	movs	r0, #0
   3059e:	4770      	bx	lr
                switch(var2)
   305a0:	3b03      	subs	r3, #3
   305a2:	2b00      	cmp	r3, #0
   305a4:	d804      	bhi.n	305b0 <nrf52_errata_57+0x28>
   305a6:	e8df f003 	tbb	[pc, r3]
   305aa:	01          	.byte	0x01
   305ab:	00          	.byte	0x00
   305ac:	2001      	movs	r0, #1
   305ae:	4770      	bx	lr
                        return false;
   305b0:	2000      	movs	r0, #0
    #endif
}
   305b2:	4770      	bx	lr

000305b4 <nrf52_errata_66>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   305b4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   305b8:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   305bc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   305c0:	d007      	beq.n	305d2 <nrf52_errata_66+0x1e>
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
   305c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   305c6:	f8d2 2134 	ldr.w	r2, [r2, #308]	; 0x134
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   305ca:	2b06      	cmp	r3, #6
   305cc:	d00a      	beq.n	305e4 <nrf52_errata_66+0x30>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   305ce:	2000      	movs	r0, #0
   305d0:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   305d2:	f04f 4270 	mov.w	r2, #4026531840	; 0xf0000000
   305d6:	f892 3fe0 	ldrb.w	r3, [r2, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   305da:	f8d2 2fe8 	ldr.w	r2, [r2, #4072]	; 0xfe8
   305de:	f3c2 1203 	ubfx	r2, r2, #4, #4
   305e2:	e7f2      	b.n	305ca <nrf52_errata_66+0x16>
                switch(var2)
   305e4:	3a03      	subs	r2, #3
   305e6:	2a01      	cmp	r2, #1
   305e8:	d804      	bhi.n	305f4 <nrf52_errata_66+0x40>
   305ea:	e8df f002 	tbb	[pc, r2]
   305ee:	0101      	.short	0x0101
   305f0:	2000      	movs	r0, #0
   305f2:	4770      	bx	lr
                        return true;
   305f4:	2001      	movs	r0, #1
    #endif
}
   305f6:	4770      	bx	lr

000305f8 <nrf52_errata_108>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   305f8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   305fc:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   30600:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   30604:	d003      	beq.n	3060e <nrf52_errata_108+0x16>
                var2 = *(uint32_t *)0x10000134ul;
            }
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   30606:	2b06      	cmp	r3, #6
   30608:	d006      	beq.n	30618 <nrf52_errata_108+0x20>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   3060a:	2000      	movs	r0, #0
   3060c:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   3060e:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   30612:	f893 3fe0 	ldrb.w	r3, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   30616:	e7f6      	b.n	30606 <nrf52_errata_108+0xe>
                        return true;
   30618:	2001      	movs	r0, #1
    #endif
}
   3061a:	4770      	bx	lr

0003061c <nrf52_errata_136>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
   3061c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   30620:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   30624:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   30628:	d003      	beq.n	30632 <nrf52_errata_136+0x16>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   3062a:	2b06      	cmp	r3, #6
   3062c:	d006      	beq.n	3063c <nrf52_errata_136+0x20>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   3062e:	2000      	movs	r0, #0
   30630:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
   30632:	f04f 4370 	mov.w	r3, #4026531840	; 0xf0000000
   30636:	f893 3fe0 	ldrb.w	r3, [r3, #4064]	; 0xfe0
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
   3063a:	e7f6      	b.n	3062a <nrf52_errata_136+0xe>
                        return true;
   3063c:	2001      	movs	r0, #1
    #endif
}
   3063e:	4770      	bx	lr

00030640 <nrf52_errata_182>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   30640:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   30644:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   30648:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   3064c:	2a06      	cmp	r2, #6
   3064e:	d001      	beq.n	30654 <nrf52_errata_182+0x14>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   30650:	2000      	movs	r0, #0
   30652:	4770      	bx	lr
                switch(var2)
   30654:	2b05      	cmp	r3, #5
   30656:	d803      	bhi.n	30660 <nrf52_errata_182+0x20>
   30658:	2b03      	cmp	r3, #3
   3065a:	d303      	bcc.n	30664 <nrf52_errata_182+0x24>
   3065c:	2000      	movs	r0, #0
   3065e:	4770      	bx	lr
                        return true;
   30660:	2001      	movs	r0, #1
   30662:	4770      	bx	lr
                        return true;
   30664:	2001      	movs	r0, #1
    #endif
}
   30666:	4770      	bx	lr

00030668 <nrf52_configuration_249>:
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   30668:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   3066c:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
            uint32_t var2 = *(uint32_t *)0x10000134ul;
   30670:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
   30674:	2a06      	cmp	r2, #6
   30676:	d001      	beq.n	3067c <nrf52_configuration_249+0x14>
                    default:
                        return true;
                }
            }
        #endif
        return false;
   30678:	2000      	movs	r0, #0
   3067a:	4770      	bx	lr
                switch(var2)
   3067c:	2b06      	cmp	r3, #6
   3067e:	d803      	bhi.n	30688 <nrf52_configuration_249+0x20>
   30680:	2b03      	cmp	r3, #3
   30682:	d303      	bcc.n	3068c <nrf52_configuration_249+0x24>
   30684:	2000      	movs	r0, #0
   30686:	4770      	bx	lr
                        return true;
   30688:	2001      	movs	r0, #1
   3068a:	4770      	bx	lr
                        return true;
   3068c:	2001      	movs	r0, #1
    #endif
}
   3068e:	4770      	bx	lr

00030690 <nrfx_isr>:
#include <nrfx.h>
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
   30690:	b508      	push	{r3, lr}
	((nrfx_irq_handler_t)irq_handler)();
   30692:	4780      	blx	r0
}
   30694:	bd08      	pop	{r3, pc}

00030696 <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
   30696:	b508      	push	{r3, lr}
	z_impl_k_busy_wait(usec_to_wait);
   30698:	f000 fa8f 	bl	30bba <z_impl_k_busy_wait>
	if (IS_ENABLED(CONFIG_SYS_CLOCK_EXISTS)) {
		k_busy_wait(usec_to_wait);
	} else {
		nrfx_coredep_delay_us(usec_to_wait);
	}
}
   3069c:	bd08      	pop	{r3, pc}

0003069e <pin_is_task_output>:
{
   3069e:	b510      	push	{r4, lr}
   306a0:	4604      	mov	r4, r0
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   306a2:	f7f2 fd33 	bl	2310c <pin_is_output>
   306a6:	b128      	cbz	r0, 306b4 <pin_is_task_output+0x16>
   306a8:	4620      	mov	r0, r4
   306aa:	f7f2 fd19 	bl	230e0 <pin_in_use_by_te>
   306ae:	b118      	cbz	r0, 306b8 <pin_is_task_output+0x1a>
   306b0:	2001      	movs	r0, #1
   306b2:	e000      	b.n	306b6 <pin_is_task_output+0x18>
   306b4:	2000      	movs	r0, #0
}
   306b6:	bd10      	pop	{r4, pc}
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   306b8:	2000      	movs	r0, #0
   306ba:	e7fc      	b.n	306b6 <pin_is_task_output+0x18>

000306bc <pin_is_input>:
{
   306bc:	b508      	push	{r3, lr}
    return !pin_is_output(pin);
   306be:	f7f2 fd25 	bl	2310c <pin_is_output>
   306c2:	f080 0001 	eor.w	r0, r0, #1
}
   306c6:	b2c0      	uxtb	r0, r0
   306c8:	bd08      	pop	{r3, pc}

000306ca <gpiote_polarity_to_trigger>:
}
   306ca:	4770      	bx	lr

000306cc <gpiote_trigger_to_polarity>:
}
   306cc:	4770      	bx	lr

000306ce <is_level>:
}
   306ce:	2803      	cmp	r0, #3
   306d0:	bf94      	ite	ls
   306d2:	2000      	movls	r0, #0
   306d4:	2001      	movhi	r0, #1
   306d6:	4770      	bx	lr

000306d8 <latch_pending_read_and_check>:
    for (i = start_port; i < (start_port + length); i++)
   306d8:	4684      	mov	ip, r0
   306da:	2300      	movs	r3, #0
   306dc:	e008      	b.n	306f0 <latch_pending_read_and_check+0x18>
        *p_masks = gpio_regs[i]->LATCH;
   306de:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
   306e2:	f8d2 1520 	ldr.w	r1, [r2, #1312]	; 0x520
   306e6:	f84c 1b04 	str.w	r1, [ip], #4
        gpio_regs[i]->LATCH = *p_masks;
   306ea:	f8c2 1520 	str.w	r1, [r2, #1312]	; 0x520
    for (i = start_port; i < (start_port + length); i++)
   306ee:	3301      	adds	r3, #1
   306f0:	2b00      	cmp	r3, #0
   306f2:	d0f4      	beq.n	306de <latch_pending_read_and_check+0x6>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
   306f4:	2300      	movs	r3, #0
   306f6:	b10b      	cbz	r3, 306fc <latch_pending_read_and_check+0x24>
    return false;
   306f8:	2000      	movs	r0, #0
   306fa:	4770      	bx	lr
        if (latch[port_idx])
   306fc:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
   30700:	b90a      	cbnz	r2, 30706 <latch_pending_read_and_check+0x2e>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
   30702:	3301      	adds	r3, #1
   30704:	e7f7      	b.n	306f6 <latch_pending_read_and_check+0x1e>
            return true;
   30706:	2001      	movs	r0, #1
}
   30708:	4770      	bx	lr

0003070a <start_playback>:
{
   3070a:	b410      	push	{r4}
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   3070c:	2402      	movs	r4, #2
   3070e:	720c      	strb	r4, [r1, #8]
    p_cb->flags = flags;
   30710:	724a      	strb	r2, [r1, #9]
    if (p_cb->handler)
   30712:	6809      	ldr	r1, [r1, #0]
   30714:	b181      	cbz	r1, 30738 <start_playback+0x2e>
        if (flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ0)
   30716:	f012 0f04 	tst.w	r2, #4
   3071a:	d11d      	bne.n	30758 <start_playback+0x4e>
        uint32_t int_mask = NRF_PWM_INT_LOOPSDONE_MASK |
   3071c:	2182      	movs	r1, #130	; 0x82
        if (flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ1)
   3071e:	f012 0f08 	tst.w	r2, #8
   30722:	d001      	beq.n	30728 <start_playback+0x1e>
            int_mask |= NRF_PWM_INT_SEQEND1_MASK;
   30724:	f041 0120 	orr.w	r1, r1, #32
        if (flags & NRFX_PWM_FLAG_NO_EVT_FINISHED)
   30728:	f012 0f10 	tst.w	r2, #16
   3072c:	d001      	beq.n	30732 <start_playback+0x28>
            int_mask &= ~NRF_PWM_INT_LOOPSDONE_MASK;
   3072e:	f021 0180 	bic.w	r1, r1, #128	; 0x80
        nrf_pwm_int_set(p_instance->p_registers, int_mask);
   30732:	6804      	ldr	r4, [r0, #0]
    p_reg->INTEN = mask;
   30734:	f8c4 1300 	str.w	r1, [r4, #768]	; 0x300
    nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_STOPPED);
   30738:	6801      	ldr	r1, [r0, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3073a:	2400      	movs	r4, #0
   3073c:	f8c1 4104 	str.w	r4, [r1, #260]	; 0x104
   30740:	f8d1 1104 	ldr.w	r1, [r1, #260]	; 0x104
    if (flags & NRFX_PWM_FLAG_START_VIA_TASK)
   30744:	f012 0f80 	tst.w	r2, #128	; 0x80
   30748:	d108      	bne.n	3075c <start_playback+0x52>
    nrf_pwm_task_trigger(p_instance->p_registers, starting_task);
   3074a:	6802      	ldr	r2, [r0, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3074c:	2101      	movs	r1, #1
   3074e:	50d1      	str	r1, [r2, r3]
    return 0;
   30750:	2000      	movs	r0, #0
}
   30752:	f85d 4b04 	ldr.w	r4, [sp], #4
   30756:	4770      	bx	lr
            int_mask |= NRF_PWM_INT_SEQEND0_MASK;
   30758:	2192      	movs	r1, #146	; 0x92
   3075a:	e7e0      	b.n	3071e <start_playback+0x14>
            nrf_pwm_task_address_get(p_instance->p_registers, starting_task);
   3075c:	6800      	ldr	r0, [r0, #0]
    return ((uint32_t)p_reg + (uint32_t)task);
   3075e:	4418      	add	r0, r3
        return starting_task_address;
   30760:	e7f7      	b.n	30752 <start_playback+0x48>

00030762 <transfer_byte>:
{
   30762:	b430      	push	{r4, r5}
   30764:	b082      	sub	sp, #8
    return p_reg->RXD;
   30766:	f8d0 3518 	ldr.w	r3, [r0, #1304]	; 0x518
   3076a:	b2db      	uxtb	r3, r3
    volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
   3076c:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
   30770:	6a0b      	ldr	r3, [r1, #32]
   30772:	698a      	ldr	r2, [r1, #24]
   30774:	4293      	cmp	r3, r2
   30776:	d203      	bcs.n	30780 <transfer_byte+0x1e>
        p_cb->evt.xfer_desc.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
   30778:	694a      	ldr	r2, [r1, #20]
   3077a:	f89d 4007 	ldrb.w	r4, [sp, #7]
   3077e:	54d4      	strb	r4, [r2, r3]
    ++p_cb->bytes_transferred;
   30780:	6a0b      	ldr	r3, [r1, #32]
   30782:	3301      	adds	r3, #1
   30784:	620b      	str	r3, [r1, #32]
    size_t bytes_used = p_cb->bytes_transferred + 1;
   30786:	1c5a      	adds	r2, r3, #1
    if (p_cb->abort)
   30788:	f891 4024 	ldrb.w	r4, [r1, #36]	; 0x24
   3078c:	b13c      	cbz	r4, 3079e <transfer_byte+0x3c>
        if (bytes_used < p_cb->evt.xfer_desc.tx_length)
   3078e:	690c      	ldr	r4, [r1, #16]
   30790:	4294      	cmp	r4, r2
   30792:	d900      	bls.n	30796 <transfer_byte+0x34>
            p_cb->evt.xfer_desc.tx_length = bytes_used;
   30794:	610a      	str	r2, [r1, #16]
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   30796:	698c      	ldr	r4, [r1, #24]
   30798:	4294      	cmp	r4, r2
   3079a:	d900      	bls.n	3079e <transfer_byte+0x3c>
            p_cb->evt.xfer_desc.rx_length = bytes_used;
   3079c:	618a      	str	r2, [r1, #24]
    if (bytes_used < p_cb->evt.xfer_desc.tx_length)
   3079e:	690c      	ldr	r4, [r1, #16]
   307a0:	4294      	cmp	r4, r2
   307a2:	d808      	bhi.n	307b6 <transfer_byte+0x54>
    else if (bytes_used < p_cb->evt.xfer_desc.rx_length)
   307a4:	698d      	ldr	r5, [r1, #24]
   307a6:	4295      	cmp	r5, r2
   307a8:	d80d      	bhi.n	307c6 <transfer_byte+0x64>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
   307aa:	42a3      	cmp	r3, r4
   307ac:	d310      	bcc.n	307d0 <transfer_byte+0x6e>
   307ae:	42ab      	cmp	r3, r5
   307b0:	d210      	bcs.n	307d4 <transfer_byte+0x72>
   307b2:	2001      	movs	r0, #1
   307b4:	e004      	b.n	307c0 <transfer_byte+0x5e>
        nrf_spi_txd_set(p_spi, p_cb->evt.xfer_desc.p_tx_buffer[bytes_used]);
   307b6:	68cb      	ldr	r3, [r1, #12]
   307b8:	5c9b      	ldrb	r3, [r3, r2]
    p_reg->TXD = data;
   307ba:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
        return true;
   307be:	2001      	movs	r0, #1
}
   307c0:	b002      	add	sp, #8
   307c2:	bc30      	pop	{r4, r5}
   307c4:	4770      	bx	lr
        nrf_spi_txd_set(p_spi, p_cb->orc);
   307c6:	7fcb      	ldrb	r3, [r1, #31]
   307c8:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
        return true;
   307cc:	2001      	movs	r0, #1
   307ce:	e7f7      	b.n	307c0 <transfer_byte+0x5e>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
   307d0:	2001      	movs	r0, #1
   307d2:	e7f5      	b.n	307c0 <transfer_byte+0x5e>
   307d4:	2000      	movs	r0, #0
   307d6:	e7f3      	b.n	307c0 <transfer_byte+0x5e>

000307d8 <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   307d8:	7b0b      	ldrb	r3, [r1, #12]
   307da:	2b03      	cmp	r3, #3
   307dc:	d839      	bhi.n	30852 <xfer_completeness_check+0x7a>
   307de:	e8df f003 	tbb	[pc, r3]
   307e2:	312a      	.short	0x312a
   307e4:	0216      	.short	0x0216
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   307e6:	688b      	ldr	r3, [r1, #8]
   307e8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   307ec:	d004      	beq.n	307f8 <xfer_completeness_check+0x20>
}

NRF_STATIC_INLINE size_t nrf_twim_txd_amount_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->TXD.AMOUNT;
   307ee:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   307f2:	690a      	ldr	r2, [r1, #16]
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   307f4:	429a      	cmp	r2, r3
   307f6:	d10f      	bne.n	30818 <xfer_completeness_check+0x40>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   307f8:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   307fa:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   307fe:	d12a      	bne.n	30856 <xfer_completeness_check+0x7e>
   30800:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.secondary_length)))
   30804:	694a      	ldr	r2, [r1, #20]
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   30806:	429a      	cmp	r2, r3
   30808:	d106      	bne.n	30818 <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   3080a:	2001      	movs	r0, #1
   3080c:	4770      	bx	lr
   3080e:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   30812:	690a      	ldr	r2, [r1, #16]
   30814:	429a      	cmp	r2, r3
   30816:	d007      	beq.n	30828 <xfer_completeness_check+0x50>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   30818:	2300      	movs	r3, #0
   3081a:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   3081e:	2206      	movs	r2, #6
   30820:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
}
   30824:	4618      	mov	r0, r3
   30826:	4770      	bx	lr
}

NRF_STATIC_INLINE size_t nrf_twim_rxd_amount_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->RXD.AMOUNT;
   30828:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
                (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.secondary_length))
   3082c:	694a      	ldr	r2, [r1, #20]
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   3082e:	429a      	cmp	r2, r3
   30830:	d1f2      	bne.n	30818 <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   30832:	2001      	movs	r0, #1
   30834:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   30836:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   3083a:	690a      	ldr	r2, [r1, #16]
   3083c:	429a      	cmp	r2, r3
   3083e:	d1eb      	bne.n	30818 <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   30840:	2001      	movs	r0, #1
   30842:	4770      	bx	lr
    return p_reg->RXD.AMOUNT;
   30844:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   30848:	690a      	ldr	r2, [r1, #16]
   3084a:	429a      	cmp	r2, r3
   3084c:	d1e4      	bne.n	30818 <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   3084e:	2001      	movs	r0, #1
}
   30850:	4770      	bx	lr
    switch (p_cb->xfer_desc.type)
   30852:	2001      	movs	r0, #1
   30854:	4770      	bx	lr
    bool transfer_complete = true;
   30856:	2001      	movs	r0, #1
   30858:	4770      	bx	lr

0003085a <twim_list_enable_handle>:
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   3085a:	f011 0f01 	tst.w	r1, #1
   3085e:	d009      	beq.n	30874 <twim_list_enable_handle+0x1a>
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   30860:	2301      	movs	r3, #1
   30862:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   30866:	f011 0f02 	tst.w	r1, #2
   3086a:	d007      	beq.n	3087c <twim_list_enable_handle+0x22>
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   3086c:	2301      	movs	r3, #1
   3086e:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
   30872:	4770      	bx	lr
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   30874:	2300      	movs	r3, #0
   30876:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
}
   3087a:	e7f4      	b.n	30866 <twim_list_enable_handle+0xc>

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   3087c:	2300      	movs	r3, #0
   3087e:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
   30882:	4770      	bx	lr

00030884 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   30884:	b148      	cbz	r0, 3089a <z_device_is_ready+0x16>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   30886:	68c3      	ldr	r3, [r0, #12]
   30888:	8818      	ldrh	r0, [r3, #0]
   3088a:	f3c0 0008 	ubfx	r0, r0, #0, #9
   3088e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   30892:	bf14      	ite	ne
   30894:	2000      	movne	r0, #0
   30896:	2001      	moveq	r0, #1
   30898:	4770      	bx	lr
		return false;
   3089a:	2000      	movs	r0, #0
}
   3089c:	4770      	bx	lr

0003089e <z_early_memset>:
{
   3089e:	b508      	push	{r3, lr}
   308a0:	f000 fb02 	bl	30ea8 <memset>
}
   308a4:	bd08      	pop	{r3, pc}

000308a6 <z_early_memcpy>:
{
   308a6:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   308a8:	f000 fadd 	bl	30e66 <memcpy>
}
   308ac:	bd08      	pop	{r3, pc}

000308ae <k_heap_init>:
{
   308ae:	b510      	push	{r4, lr}
	sys_dlist_init(&w->waitq);
   308b0:	f100 040c 	add.w	r4, r0, #12
	list->head = (sys_dnode_t *)list;
   308b4:	60c4      	str	r4, [r0, #12]
	list->tail = (sys_dnode_t *)list;
   308b6:	6104      	str	r4, [r0, #16]
	sys_heap_init(&h->heap, mem, bytes);
   308b8:	f7e5 fcde 	bl	16278 <sys_heap_init>
}
   308bc:	bd10      	pop	{r4, pc}

000308be <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   308be:	6902      	ldr	r2, [r0, #16]
   308c0:	6943      	ldr	r3, [r0, #20]
   308c2:	431a      	orrs	r2, r3
   308c4:	f012 0203 	ands.w	r2, r2, #3
   308c8:	d10d      	bne.n	308e6 <create_free_list+0x28>
	slab->free_list = NULL;
   308ca:	2100      	movs	r1, #0
   308cc:	6181      	str	r1, [r0, #24]
	for (j = 0U; j < slab->num_blocks; j++) {
   308ce:	e005      	b.n	308dc <create_free_list+0x1e>
		*(char **)p = slab->free_list;
   308d0:	6981      	ldr	r1, [r0, #24]
   308d2:	6019      	str	r1, [r3, #0]
		slab->free_list = p;
   308d4:	6183      	str	r3, [r0, #24]
		p += slab->block_size;
   308d6:	6901      	ldr	r1, [r0, #16]
   308d8:	440b      	add	r3, r1
	for (j = 0U; j < slab->num_blocks; j++) {
   308da:	3201      	adds	r2, #1
   308dc:	68c1      	ldr	r1, [r0, #12]
   308de:	4291      	cmp	r1, r2
   308e0:	d8f6      	bhi.n	308d0 <create_free_list+0x12>
	return 0;
   308e2:	2000      	movs	r0, #0
   308e4:	4770      	bx	lr
		return -EINVAL;
   308e6:	f06f 0015 	mvn.w	r0, #21
}
   308ea:	4770      	bx	lr

000308ec <setup_thread_stack>:
{
   308ec:	b410      	push	{r4}
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   308ee:	3207      	adds	r2, #7
   308f0:	f022 0207 	bic.w	r2, r2, #7
   308f4:	f102 0340 	add.w	r3, r2, #64	; 0x40

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
   308f8:	f101 0440 	add.w	r4, r1, #64	; 0x40
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
   308fc:	6744      	str	r4, [r0, #116]	; 0x74
	new_thread->stack_info.size = stack_buf_size;
   308fe:	6782      	str	r2, [r0, #120]	; 0x78
	new_thread->stack_info.delta = delta;
   30900:	2200      	movs	r2, #0
   30902:	67c2      	str	r2, [r0, #124]	; 0x7c
}
   30904:	18c8      	adds	r0, r1, r3
   30906:	f85d 4b04 	ldr.w	r4, [sp], #4
   3090a:	4770      	bx	lr

0003090c <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   3090c:	f3ef 8005 	mrs	r0, IPSR
}
   30910:	3800      	subs	r0, #0
   30912:	bf18      	it	ne
   30914:	2001      	movne	r0, #1
   30916:	4770      	bx	lr

00030918 <z_impl_k_thread_name_set>:
}
   30918:	f06f 0057 	mvn.w	r0, #87	; 0x57
   3091c:	4770      	bx	lr

0003091e <k_thread_name_get>:
}
   3091e:	2000      	movs	r0, #0
   30920:	4770      	bx	lr

00030922 <z_impl_k_thread_start>:
{
   30922:	b508      	push	{r3, lr}
	z_sched_start(thread);
   30924:	f7f7 fd0a 	bl	2833c <z_sched_start>
}
   30928:	bd08      	pop	{r3, pc}

0003092a <z_init_thread_base>:
{
   3092a:	b410      	push	{r4}
	thread_base->pended_on = NULL;
   3092c:	2400      	movs	r4, #0
   3092e:	6084      	str	r4, [r0, #8]
	thread_base->user_options = (uint8_t)options;
   30930:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   30932:	7342      	strb	r2, [r0, #13]
	thread_base->prio = priority;
   30934:	7381      	strb	r1, [r0, #14]
	thread_base->sched_locked = 0U;
   30936:	73c4      	strb	r4, [r0, #15]
	node->next = NULL;
   30938:	6184      	str	r4, [r0, #24]
	node->prev = NULL;
   3093a:	61c4      	str	r4, [r0, #28]
}
   3093c:	f85d 4b04 	ldr.w	r4, [sp], #4
   30940:	4770      	bx	lr

00030942 <z_pm_save_idle_exit>:
{
   30942:	b508      	push	{r3, lr}
	pm_system_resume();
   30944:	f7e6 fdc8 	bl	174d8 <pm_system_resume>
	sys_clock_idle_exit();
   30948:	f7ff f88e 	bl	2fa68 <sys_clock_idle_exit>
}
   3094c:	bd08      	pop	{r3, pc}

0003094e <k_msgq_init>:
	msgq->msg_size = msg_size;
   3094e:	60c2      	str	r2, [r0, #12]
	msgq->max_msgs = max_msgs;
   30950:	6103      	str	r3, [r0, #16]
	msgq->buffer_start = buffer;
   30952:	6141      	str	r1, [r0, #20]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
   30954:	fb03 1202 	mla	r2, r3, r2, r1
   30958:	6182      	str	r2, [r0, #24]
	msgq->read_ptr = buffer;
   3095a:	61c1      	str	r1, [r0, #28]
	msgq->write_ptr = buffer;
   3095c:	6201      	str	r1, [r0, #32]
	msgq->used_msgs = 0;
   3095e:	2300      	movs	r3, #0
   30960:	6243      	str	r3, [r0, #36]	; 0x24
	msgq->flags = 0;
   30962:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
	list->head = (sys_dnode_t *)list;
   30966:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   30968:	6040      	str	r0, [r0, #4]
	msgq->lock = (struct k_spinlock) {};
   3096a:	6083      	str	r3, [r0, #8]
	sys_dlist_init(&msgq->poll_events);
   3096c:	f100 0328 	add.w	r3, r0, #40	; 0x28
	list->head = (sys_dnode_t *)list;
   30970:	6283      	str	r3, [r0, #40]	; 0x28
	list->tail = (sys_dnode_t *)list;
   30972:	62c3      	str	r3, [r0, #44]	; 0x2c
}
   30974:	4770      	bx	lr

00030976 <new_prio_for_inheritance>:
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
   30976:	4288      	cmp	r0, r1
   30978:	da00      	bge.n	3097c <new_prio_for_inheritance+0x6>
   3097a:	4601      	mov	r1, r0
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   3097c:	f111 0f7f 	cmn.w	r1, #127	; 0x7f
   30980:	db01      	blt.n	30986 <new_prio_for_inheritance+0x10>
   30982:	4608      	mov	r0, r1
   30984:	4770      	bx	lr
   30986:	f06f 007e 	mvn.w	r0, #126	; 0x7e
}
   3098a:	4770      	bx	lr

0003098c <adjust_owner_prio>:
{
   3098c:	b508      	push	{r3, lr}
	if (mutex->owner->base.prio != new_prio) {
   3098e:	6880      	ldr	r0, [r0, #8]
   30990:	f990 300e 	ldrsb.w	r3, [r0, #14]
   30994:	428b      	cmp	r3, r1
   30996:	d101      	bne.n	3099c <adjust_owner_prio+0x10>
	return false;
   30998:	2000      	movs	r0, #0
}
   3099a:	bd08      	pop	{r3, pc}
		return z_set_prio(mutex->owner, new_prio);
   3099c:	f7f7 fe42 	bl	28624 <z_set_prio>
   309a0:	e7fb      	b.n	3099a <adjust_owner_prio+0xe>

000309a2 <z_impl_k_mutex_init>:
{
   309a2:	4603      	mov	r3, r0
	mutex->owner = NULL;
   309a4:	2000      	movs	r0, #0
   309a6:	6098      	str	r0, [r3, #8]
	mutex->lock_count = 0U;
   309a8:	60d8      	str	r0, [r3, #12]
	list->head = (sys_dnode_t *)list;
   309aa:	601b      	str	r3, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   309ac:	605b      	str	r3, [r3, #4]
}
   309ae:	4770      	bx	lr

000309b0 <prepare_thread_to_run>:
{
   309b0:	b508      	push	{r3, lr}
   309b2:	2200      	movs	r2, #0
   309b4:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
   309b8:	6141      	str	r1, [r0, #20]
	z_ready_thread(thread);
   309ba:	f7f7 fc7b 	bl	282b4 <z_ready_thread>
}
   309be:	bd08      	pop	{r3, pc}

000309c0 <z_queue_node_peek>:
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   309c0:	b160      	cbz	r0, 309dc <z_queue_node_peek+0x1c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   309c2:	6803      	ldr	r3, [r0, #0]
   309c4:	f013 0f03 	tst.w	r3, #3
   309c8:	d008      	beq.n	309dc <z_queue_node_peek+0x1c>
{
   309ca:	b510      	push	{r4, lr}
		ret = anode->data;
   309cc:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   309ce:	b909      	cbnz	r1, 309d4 <z_queue_node_peek+0x14>
		ret = anode->data;
   309d0:	4620      	mov	r0, r4
}
   309d2:	bd10      	pop	{r4, pc}
			k_free(anode);
   309d4:	f000 f9dc 	bl	30d90 <k_free>
		ret = anode->data;
   309d8:	4620      	mov	r0, r4
   309da:	e7fa      	b.n	309d2 <z_queue_node_peek+0x12>
}
   309dc:	4770      	bx	lr

000309de <z_impl_k_queue_init>:
	list->head = NULL;
   309de:	2300      	movs	r3, #0
   309e0:	6003      	str	r3, [r0, #0]
	list->tail = NULL;
   309e2:	6043      	str	r3, [r0, #4]
	queue->lock = (struct k_spinlock) {};
   309e4:	6083      	str	r3, [r0, #8]
   309e6:	f100 030c 	add.w	r3, r0, #12
	list->head = (sys_dnode_t *)list;
   309ea:	60c3      	str	r3, [r0, #12]
	list->tail = (sys_dnode_t *)list;
   309ec:	6103      	str	r3, [r0, #16]
	sys_dlist_init(&queue->poll_events);
   309ee:	f100 0314 	add.w	r3, r0, #20
	list->head = (sys_dnode_t *)list;
   309f2:	6143      	str	r3, [r0, #20]
	list->tail = (sys_dnode_t *)list;
   309f4:	6183      	str	r3, [r0, #24]
}
   309f6:	4770      	bx	lr

000309f8 <k_queue_append>:
{
   309f8:	b500      	push	{lr}
   309fa:	b083      	sub	sp, #12
   309fc:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   309fe:	2301      	movs	r3, #1
   30a00:	9300      	str	r3, [sp, #0]
   30a02:	2300      	movs	r3, #0
   30a04:	4619      	mov	r1, r3
   30a06:	f7f6 f95d 	bl	26cc4 <queue_insert>
}
   30a0a:	b003      	add	sp, #12
   30a0c:	f85d fb04 	ldr.w	pc, [sp], #4

00030a10 <k_queue_prepend>:
{
   30a10:	b500      	push	{lr}
   30a12:	b083      	sub	sp, #12
   30a14:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
   30a16:	2100      	movs	r1, #0
   30a18:	9100      	str	r1, [sp, #0]
   30a1a:	460b      	mov	r3, r1
   30a1c:	f7f6 f952 	bl	26cc4 <queue_insert>
}
   30a20:	b003      	add	sp, #12
   30a22:	f85d fb04 	ldr.w	pc, [sp], #4

00030a26 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   30a26:	b15a      	cbz	r2, 30a40 <z_impl_k_sem_init+0x1a>
   30a28:	428a      	cmp	r2, r1
   30a2a:	d30c      	bcc.n	30a46 <z_impl_k_sem_init+0x20>
	sem->count = initial_count;
   30a2c:	6081      	str	r1, [r0, #8]
	sem->limit = limit;
   30a2e:	60c2      	str	r2, [r0, #12]
	list->head = (sys_dnode_t *)list;
   30a30:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   30a32:	6040      	str	r0, [r0, #4]
	sys_dlist_init(&sem->poll_events);
   30a34:	f100 0310 	add.w	r3, r0, #16
	list->head = (sys_dnode_t *)list;
   30a38:	6103      	str	r3, [r0, #16]
	list->tail = (sys_dnode_t *)list;
   30a3a:	6143      	str	r3, [r0, #20]
	return 0;
   30a3c:	2000      	movs	r0, #0
   30a3e:	4770      	bx	lr
		return -EINVAL;
   30a40:	f06f 0015 	mvn.w	r0, #21
   30a44:	4770      	bx	lr
   30a46:	f06f 0015 	mvn.w	r0, #21
}
   30a4a:	4770      	bx	lr

00030a4c <cancel_async_locked>:
{
   30a4c:	4603      	mov	r3, r0
	return (*flagp & BIT(bit)) != 0U;
   30a4e:	68c2      	ldr	r2, [r0, #12]
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   30a50:	f012 0f02 	tst.w	r2, #2
   30a54:	d009      	beq.n	30a6a <cancel_async_locked+0x1e>
	return *flagp;
   30a56:	68da      	ldr	r2, [r3, #12]
	if (ret != 0) {
   30a58:	f012 000f 	ands.w	r0, r2, #15
   30a5c:	d004      	beq.n	30a68 <cancel_async_locked+0x1c>
	*flagp |= BIT(bit);
   30a5e:	f042 0202 	orr.w	r2, r2, #2
   30a62:	60da      	str	r2, [r3, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
   30a64:	f002 000f 	and.w	r0, r2, #15
}
   30a68:	4770      	bx	lr
		queue_remove_locked(work->queue, work);
   30a6a:	6880      	ldr	r0, [r0, #8]
	*flagp &= ~BIT(bit);
   30a6c:	f022 0104 	bic.w	r1, r2, #4
   30a70:	60d9      	str	r1, [r3, #12]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
   30a72:	f012 0f04 	tst.w	r2, #4
   30a76:	d0ee      	beq.n	30a56 <cancel_async_locked+0xa>
		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
   30a78:	f100 0cd0 	add.w	ip, r0, #208	; 0xd0
	return list->head;
   30a7c:	f8d0 20d0 	ldr.w	r2, [r0, #208]	; 0xd0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   30a80:	2100      	movs	r1, #0
   30a82:	2a00      	cmp	r2, #0
   30a84:	d0e7      	beq.n	30a56 <cancel_async_locked+0xa>
   30a86:	4293      	cmp	r3, r2
   30a88:	d002      	beq.n	30a90 <cancel_async_locked+0x44>
   30a8a:	4611      	mov	r1, r2
   30a8c:	6812      	ldr	r2, [r2, #0]
   30a8e:	e7f8      	b.n	30a82 <cancel_async_locked+0x36>
Z_GENLIST_REMOVE(slist, snode)
   30a90:	b141      	cbz	r1, 30aa4 <cancel_async_locked+0x58>
	return node->next;
   30a92:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   30a94:	600a      	str	r2, [r1, #0]
	return list->tail;
   30a96:	f8dc 2004 	ldr.w	r2, [ip, #4]
Z_GENLIST_REMOVE(slist, snode)
   30a9a:	4293      	cmp	r3, r2
   30a9c:	d00c      	beq.n	30ab8 <cancel_async_locked+0x6c>
	parent->next = child;
   30a9e:	2200      	movs	r2, #0
   30aa0:	601a      	str	r2, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   30aa2:	e7d8      	b.n	30a56 <cancel_async_locked+0xa>
	return node->next;
   30aa4:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   30aa6:	f8c0 20d0 	str.w	r2, [r0, #208]	; 0xd0
	return list->tail;
   30aaa:	f8dc 1004 	ldr.w	r1, [ip, #4]
Z_GENLIST_REMOVE(slist, snode)
   30aae:	428b      	cmp	r3, r1
   30ab0:	d1f5      	bne.n	30a9e <cancel_async_locked+0x52>
	list->tail = node;
   30ab2:	f8cc 2004 	str.w	r2, [ip, #4]
}
   30ab6:	e7f2      	b.n	30a9e <cancel_async_locked+0x52>
	list->tail = node;
   30ab8:	f8cc 1004 	str.w	r1, [ip, #4]
}
   30abc:	e7ef      	b.n	30a9e <cancel_async_locked+0x52>

00030abe <cancel_delayable_async_locked>:
{
   30abe:	b510      	push	{r4, lr}
   30ac0:	4604      	mov	r4, r0
	return (*flagp & BIT(bit)) != 0U;
   30ac2:	68c3      	ldr	r3, [r0, #12]
	*flagp &= ~BIT(bit);
   30ac4:	f023 0208 	bic.w	r2, r3, #8
   30ac8:	60c2      	str	r2, [r0, #12]
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   30aca:	f013 0f08 	tst.w	r3, #8
   30ace:	d103      	bne.n	30ad8 <cancel_delayable_async_locked+0x1a>
	return cancel_async_locked(&dwork->work);
   30ad0:	4620      	mov	r0, r4
   30ad2:	f7ff ffbb 	bl	30a4c <cancel_async_locked>
}
   30ad6:	bd10      	pop	{r4, pc}
		z_abort_timeout(&dwork->timeout);
   30ad8:	3010      	adds	r0, #16
   30ada:	f7f8 fbd1 	bl	29280 <z_abort_timeout>
		ret = true;
   30ade:	e7f7      	b.n	30ad0 <cancel_delayable_async_locked+0x12>

00030ae0 <k_work_submit_to_queue>:
{
   30ae0:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
   30ae2:	f7f6 fd6b 	bl	275bc <z_work_submit_to_queue>
	if (ret > 0) {
   30ae6:	1e04      	subs	r4, r0, #0
   30ae8:	dc01      	bgt.n	30aee <k_work_submit_to_queue+0xe>
}
   30aea:	4620      	mov	r0, r4
   30aec:	bd10      	pop	{r4, pc}
	__asm__ volatile(
   30aee:	f04f 0340 	mov.w	r3, #64	; 0x40
   30af2:	f3ef 8011 	mrs	r0, BASEPRI
   30af6:	f383 8812 	msr	BASEPRI_MAX, r3
   30afa:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   30afe:	f000 f80d 	bl	30b1c <z_reschedule_irqlock>
	return ret;
   30b02:	e7f2      	b.n	30aea <k_work_submit_to_queue+0xa>

00030b04 <thread_active_elsewhere>:
}
   30b04:	2000      	movs	r0, #0
   30b06:	4770      	bx	lr

00030b08 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
   30b08:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   30b0c:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
   30b10:	4283      	cmp	r3, r0
   30b12:	d001      	beq.n	30b18 <z_sched_prio_cmp+0x10>
		return b2 - b1;
   30b14:	1ac0      	subs	r0, r0, r3
   30b16:	4770      	bx	lr
	return 0;
   30b18:	2000      	movs	r0, #0
}
   30b1a:	4770      	bx	lr

00030b1c <z_reschedule_irqlock>:
{
   30b1c:	b508      	push	{r3, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   30b1e:	4603      	mov	r3, r0
   30b20:	b920      	cbnz	r0, 30b2c <z_reschedule_irqlock+0x10>
   30b22:	f3ef 8205 	mrs	r2, IPSR
   30b26:	b942      	cbnz	r2, 30b3a <z_reschedule_irqlock+0x1e>
   30b28:	2201      	movs	r2, #1
   30b2a:	e000      	b.n	30b2e <z_reschedule_irqlock+0x12>
   30b2c:	2200      	movs	r2, #0
	if (resched(key)) {
   30b2e:	b932      	cbnz	r2, 30b3e <z_reschedule_irqlock+0x22>
	__asm__ volatile(
   30b30:	f383 8811 	msr	BASEPRI, r3
   30b34:	f3bf 8f6f 	isb	sy
}
   30b38:	bd08      	pop	{r3, pc}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   30b3a:	2200      	movs	r2, #0
   30b3c:	e7f7      	b.n	30b2e <z_reschedule_irqlock+0x12>
   30b3e:	4618      	mov	r0, r3
   30b40:	f7e7 fc4a 	bl	183d8 <arch_swap>
	return ret;
   30b44:	e7f8      	b.n	30b38 <z_reschedule_irqlock+0x1c>

00030b46 <z_priq_dumb_best>:
{
   30b46:	4603      	mov	r3, r0
	return list->head == list;
   30b48:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   30b4a:	4283      	cmp	r3, r0
   30b4c:	d000      	beq.n	30b50 <z_priq_dumb_best+0xa>
}
   30b4e:	4770      	bx	lr
	struct k_thread *thread = NULL;
   30b50:	2000      	movs	r0, #0
	return thread;
   30b52:	e7fc      	b.n	30b4e <z_priq_dumb_best+0x8>

00030b54 <z_unpend_all>:
{
   30b54:	b538      	push	{r3, r4, r5, lr}
   30b56:	4605      	mov	r5, r0
	int need_sched = 0;
   30b58:	2000      	movs	r0, #0
	return list->head == list;
   30b5a:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   30b5c:	42a5      	cmp	r5, r4
   30b5e:	d008      	beq.n	30b72 <z_unpend_all+0x1e>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   30b60:	b13c      	cbz	r4, 30b72 <z_unpend_all+0x1e>
		z_unpend_thread(thread);
   30b62:	4620      	mov	r0, r4
   30b64:	f7f7 f9d0 	bl	27f08 <z_unpend_thread>
		z_ready_thread(thread);
   30b68:	4620      	mov	r0, r4
   30b6a:	f7f7 fba3 	bl	282b4 <z_ready_thread>
		need_sched = 1;
   30b6e:	2001      	movs	r0, #1
   30b70:	e7f3      	b.n	30b5a <z_unpend_all+0x6>
}
   30b72:	bd38      	pop	{r3, r4, r5, pc}

00030b74 <init_ready_q>:
	sys_dlist_init(&rq->runq);
   30b74:	1d03      	adds	r3, r0, #4
	list->head = (sys_dnode_t *)list;
   30b76:	6043      	str	r3, [r0, #4]
	list->tail = (sys_dnode_t *)list;
   30b78:	6083      	str	r3, [r0, #8]
}
   30b7a:	4770      	bx	lr

00030b7c <remove_timeout>:
{
   30b7c:	b510      	push	{r4, lr}
   30b7e:	4604      	mov	r4, r0
	if (next(t) != NULL) {
   30b80:	f7f8 fa76 	bl	29070 <next>
   30b84:	b148      	cbz	r0, 30b9a <remove_timeout+0x1e>
   30b86:	4602      	mov	r2, r0
		next(t)->dticks += t->dticks;
   30b88:	6920      	ldr	r0, [r4, #16]
   30b8a:	6961      	ldr	r1, [r4, #20]
   30b8c:	6913      	ldr	r3, [r2, #16]
   30b8e:	181b      	adds	r3, r3, r0
   30b90:	6950      	ldr	r0, [r2, #20]
   30b92:	eb41 0100 	adc.w	r1, r1, r0
   30b96:	6113      	str	r3, [r2, #16]
   30b98:	6151      	str	r1, [r2, #20]
	sys_dnode_t *const prev = node->prev;
   30b9a:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
   30b9c:	6823      	ldr	r3, [r4, #0]
	prev->next = next;
   30b9e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   30ba0:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   30ba2:	2300      	movs	r3, #0
   30ba4:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
   30ba6:	6063      	str	r3, [r4, #4]
}
   30ba8:	bd10      	pop	{r4, pc}

00030baa <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   30baa:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   30bac:	f7f8 fcf2 	bl	29594 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   30bb0:	bd08      	pop	{r3, pc}

00030bb2 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
   30bb2:	b508      	push	{r3, lr}
	return sys_clock_tick_get();
   30bb4:	f7f8 fcee 	bl	29594 <sys_clock_tick_get>
}
   30bb8:	bd08      	pop	{r3, pc}

00030bba <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   30bba:	b900      	cbnz	r0, 30bbe <z_impl_k_busy_wait+0x4>
   30bbc:	4770      	bx	lr
{
   30bbe:	b508      	push	{r3, lr}
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   30bc0:	f7e8 fa42 	bl	19048 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   30bc4:	bd08      	pop	{r3, pc}

00030bc6 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   30bc6:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   30bca:	bf08      	it	eq
   30bcc:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
   30bd0:	d021      	beq.n	30c16 <sys_clock_timeout_end_calc+0x50>
{
   30bd2:	b538      	push	{r3, r4, r5, lr}
   30bd4:	4605      	mov	r5, r0
   30bd6:	460c      	mov	r4, r1
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   30bd8:	ea51 0300 	orrs.w	r3, r1, r0
   30bdc:	d009      	beq.n	30bf2 <sys_clock_timeout_end_calc+0x2c>
		return sys_clock_tick_get();
	} else {

		dt = timeout.ticks;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   30bde:	f06f 0301 	mvn.w	r3, #1
   30be2:	1a18      	subs	r0, r3, r0
   30be4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   30be8:	eb63 0101 	sbc.w	r1, r3, r1
   30bec:	2900      	cmp	r1, #0
   30bee:	db03      	blt.n	30bf8 <sys_clock_timeout_end_calc+0x32>
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   30bf0:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get();
   30bf2:	f7f8 fccf 	bl	29594 <sys_clock_tick_get>
   30bf6:	e7fb      	b.n	30bf0 <sys_clock_timeout_end_calc+0x2a>
		return sys_clock_tick_get() + MAX(1, dt);
   30bf8:	f7f8 fccc 	bl	29594 <sys_clock_tick_get>
   30bfc:	4603      	mov	r3, r0
   30bfe:	4628      	mov	r0, r5
   30c00:	4622      	mov	r2, r4
   30c02:	2d01      	cmp	r5, #1
   30c04:	f174 0400 	sbcs.w	r4, r4, #0
   30c08:	da01      	bge.n	30c0e <sys_clock_timeout_end_calc+0x48>
   30c0a:	2001      	movs	r0, #1
   30c0c:	2200      	movs	r2, #0
   30c0e:	1818      	adds	r0, r3, r0
   30c10:	eb41 0102 	adc.w	r1, r1, r2
   30c14:	e7ec      	b.n	30bf0 <sys_clock_timeout_end_calc+0x2a>
		return UINT64_MAX;
   30c16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   30c1a:	4601      	mov	r1, r0
}
   30c1c:	4770      	bx	lr

00030c1e <k_timer_init>:
	timer->expiry_fn = expiry_fn;
   30c1e:	6201      	str	r1, [r0, #32]
	timer->stop_fn = stop_fn;
   30c20:	6242      	str	r2, [r0, #36]	; 0x24
	timer->status = 0U;
   30c22:	2300      	movs	r3, #0
   30c24:	6303      	str	r3, [r0, #48]	; 0x30
   30c26:	f100 0218 	add.w	r2, r0, #24
	list->head = (sys_dnode_t *)list;
   30c2a:	6182      	str	r2, [r0, #24]
	list->tail = (sys_dnode_t *)list;
   30c2c:	61c2      	str	r2, [r0, #28]
	node->next = NULL;
   30c2e:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   30c30:	6043      	str	r3, [r0, #4]
	timer->user_data = NULL;
   30c32:	6343      	str	r3, [r0, #52]	; 0x34
}
   30c34:	4770      	bx	lr

00030c36 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   30c36:	b510      	push	{r4, lr}
   30c38:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
   30c3a:	f7f8 fb21 	bl	29280 <z_abort_timeout>

	if (inactive) {
   30c3e:	b9a0      	cbnz	r0, 30c6a <z_impl_k_timer_stop+0x34>
		return;
	}

	if (timer->stop_fn != NULL) {
   30c40:	6a63      	ldr	r3, [r4, #36]	; 0x24
   30c42:	b10b      	cbz	r3, 30c48 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   30c44:	4620      	mov	r0, r4
   30c46:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   30c48:	f104 0018 	add.w	r0, r4, #24
   30c4c:	f7f7 feae 	bl	289ac <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   30c50:	b158      	cbz	r0, 30c6a <z_impl_k_timer_stop+0x34>
			z_ready_thread(pending_thread);
   30c52:	f7f7 fb2f 	bl	282b4 <z_ready_thread>
	__asm__ volatile(
   30c56:	f04f 0340 	mov.w	r3, #64	; 0x40
   30c5a:	f3ef 8011 	mrs	r0, BASEPRI
   30c5e:	f383 8812 	msr	BASEPRI_MAX, r3
   30c62:	f3bf 8f6f 	isb	sy
   30c66:	f7ff ff59 	bl	30b1c <z_reschedule_irqlock>
			z_reschedule_unlocked();
		}
	}
}
   30c6a:	bd10      	pop	{r4, pc}

00030c6c <poller_thread>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   30c6c:	b108      	cbz	r0, 30c72 <poller_thread+0x6>
   30c6e:	3860      	subs	r0, #96	; 0x60
   30c70:	4770      	bx	lr
}
   30c72:	4770      	bx	lr

00030c74 <signal_triggered_work>:

extern int z_work_submit_to_queue(struct k_work_q *queue,
			 struct k_work *work);

static int signal_triggered_work(struct k_poll_event *event, uint32_t status)
{
   30c74:	b570      	push	{r4, r5, r6, lr}
	struct z_poller *poller = event->poller;
   30c76:	6884      	ldr	r4, [r0, #8]
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   30c78:	7823      	ldrb	r3, [r4, #0]
   30c7a:	b173      	cbz	r3, 30c9a <signal_triggered_work+0x26>
   30c7c:	f854 5c04 	ldr.w	r5, [r4, #-4]
   30c80:	b15d      	cbz	r5, 30c9a <signal_triggered_work+0x26>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
   30c82:	f1a4 0614 	sub.w	r6, r4, #20
   30c86:	f104 0014 	add.w	r0, r4, #20
   30c8a:	f7f8 faf9 	bl	29280 <z_abort_timeout>
		twork->poll_result = 0;
   30c8e:	2300      	movs	r3, #0
   30c90:	62e3      	str	r3, [r4, #44]	; 0x2c
		z_work_submit_to_queue(work_q, &twork->work);
   30c92:	4631      	mov	r1, r6
   30c94:	4628      	mov	r0, r5
   30c96:	f7f6 fc91 	bl	275bc <z_work_submit_to_queue>
	}

	return 0;
}
   30c9a:	2000      	movs	r0, #0
   30c9c:	bd70      	pop	{r4, r5, r6, pc}

00030c9e <signal_poll_event>:
{
   30c9e:	b570      	push	{r4, r5, r6, lr}
   30ca0:	4604      	mov	r4, r0
   30ca2:	460d      	mov	r5, r1
	struct z_poller *poller = event->poller;
   30ca4:	6886      	ldr	r6, [r0, #8]
	if (poller != NULL) {
   30ca6:	b1d6      	cbz	r6, 30cde <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
   30ca8:	7873      	ldrb	r3, [r6, #1]
   30caa:	2b01      	cmp	r3, #1
   30cac:	d00d      	beq.n	30cca <signal_poll_event+0x2c>
		} else if (poller->mode == MODE_TRIGGERED) {
   30cae:	2b02      	cmp	r3, #2
   30cb0:	d012      	beq.n	30cd8 <signal_poll_event+0x3a>
		poller->is_polling = false;
   30cb2:	2000      	movs	r0, #0
   30cb4:	7030      	strb	r0, [r6, #0]
	event->poller = NULL;
   30cb6:	2300      	movs	r3, #0
   30cb8:	60a3      	str	r3, [r4, #8]
	event->state |= state;
   30cba:	68e3      	ldr	r3, [r4, #12]
   30cbc:	f3c3 3145 	ubfx	r1, r3, #13, #6
   30cc0:	430d      	orrs	r5, r1
   30cc2:	f365 3352 	bfi	r3, r5, #13, #6
   30cc6:	60e3      	str	r3, [r4, #12]
}
   30cc8:	bd70      	pop	{r4, r5, r6, pc}
			retcode = signal_poller(event, state);
   30cca:	f7f8 fe81 	bl	299d0 <signal_poller>
		poller->is_polling = false;
   30cce:	2300      	movs	r3, #0
   30cd0:	7033      	strb	r3, [r6, #0]
		if (retcode < 0) {
   30cd2:	4298      	cmp	r0, r3
   30cd4:	daef      	bge.n	30cb6 <signal_poll_event+0x18>
   30cd6:	e7f7      	b.n	30cc8 <signal_poll_event+0x2a>
			retcode = signal_triggered_work(event, state);
   30cd8:	f7ff ffcc 	bl	30c74 <signal_triggered_work>
   30cdc:	e7f7      	b.n	30cce <signal_poll_event+0x30>
	int retcode = 0;
   30cde:	2000      	movs	r0, #0
   30ce0:	e7e9      	b.n	30cb6 <signal_poll_event+0x18>

00030ce2 <z_handle_obj_poll_events>:
{
   30ce2:	b508      	push	{r3, lr}
   30ce4:	4603      	mov	r3, r0
	return list->head == list;
   30ce6:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   30ce8:	4283      	cmp	r3, r0
   30cea:	d009      	beq.n	30d00 <z_handle_obj_poll_events+0x1e>
	sys_dnode_t *const prev = node->prev;
   30cec:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;
   30cee:	6803      	ldr	r3, [r0, #0]
	prev->next = next;
   30cf0:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   30cf2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   30cf4:	2300      	movs	r3, #0
   30cf6:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   30cf8:	6043      	str	r3, [r0, #4]
	if (poll_event != NULL) {
   30cfa:	b108      	cbz	r0, 30d00 <z_handle_obj_poll_events+0x1e>
		(void) signal_poll_event(poll_event, state);
   30cfc:	f7ff ffcf 	bl	30c9e <signal_poll_event>
}
   30d00:	bd08      	pop	{r3, pc}

00030d02 <z_impl_k_poll_signal_init>:
	list->head = (sys_dnode_t *)list;
   30d02:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   30d04:	6040      	str	r0, [r0, #4]
	sig->signaled = 0U;
   30d06:	2300      	movs	r3, #0
   30d08:	6083      	str	r3, [r0, #8]
}
   30d0a:	4770      	bx	lr

00030d0c <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
   30d0c:	2300      	movs	r3, #0
   30d0e:	6083      	str	r3, [r0, #8]
}
   30d10:	4770      	bx	lr

00030d12 <are_wait_conditions_met>:
	uint32_t  match = current & desired;
   30d12:	4001      	ands	r1, r0
	if (wait_condition == K_EVENT_WAIT_ALL) {
   30d14:	2a01      	cmp	r2, #1
   30d16:	d003      	beq.n	30d20 <are_wait_conditions_met+0xe>
	return match != 0;
   30d18:	1e08      	subs	r0, r1, #0
   30d1a:	bf18      	it	ne
   30d1c:	2001      	movne	r0, #1
}
   30d1e:	4770      	bx	lr
		return match == desired;
   30d20:	4288      	cmp	r0, r1
   30d22:	bf14      	ite	ne
   30d24:	2000      	movne	r0, #0
   30d26:	2001      	moveq	r0, #1
   30d28:	4770      	bx	lr

00030d2a <z_impl_k_event_init>:
	event->events = 0;
   30d2a:	2300      	movs	r3, #0
   30d2c:	6083      	str	r3, [r0, #8]
	event->lock = (struct k_spinlock) {};
   30d2e:	60c3      	str	r3, [r0, #12]
	list->head = (sys_dnode_t *)list;
   30d30:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   30d32:	6040      	str	r0, [r0, #4]
}
   30d34:	4770      	bx	lr

00030d36 <z_impl_k_event_post>:
{
   30d36:	b508      	push	{r3, lr}
   30d38:	460a      	mov	r2, r1
	k_event_post_internal(event, events, events);
   30d3a:	f7f9 f9d7 	bl	2a0ec <k_event_post_internal>
}
   30d3e:	bd08      	pop	{r3, pc}

00030d40 <z_impl_k_event_set>:
{
   30d40:	b508      	push	{r3, lr}
	k_event_post_internal(event, events, ~0);
   30d42:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   30d46:	f7f9 f9d1 	bl	2a0ec <k_event_post_internal>
}
   30d4a:	bd08      	pop	{r3, pc}

00030d4c <z_impl_k_event_set_masked>:
{
   30d4c:	b508      	push	{r3, lr}
	k_event_post_internal(event, events, events_mask);
   30d4e:	f7f9 f9cd 	bl	2a0ec <k_event_post_internal>
}
   30d52:	bd08      	pop	{r3, pc}

00030d54 <z_impl_k_event_wait>:
/**
 * Wait for any of the specified events
 */
uint32_t z_impl_k_event_wait(struct k_event *event, uint32_t events,
			     bool reset, k_timeout_t timeout)
{
   30d54:	b500      	push	{lr}
   30d56:	b083      	sub	sp, #12
	uint32_t options = reset ? K_EVENT_WAIT_RESET : 0;
   30d58:	b14a      	cbz	r2, 30d6e <z_impl_k_event_wait+0x1a>
   30d5a:	2202      	movs	r2, #2

	return k_event_wait_internal(event, events, options, timeout);
   30d5c:	ed9d 7b04 	vldr	d7, [sp, #16]
   30d60:	ed8d 7b00 	vstr	d7, [sp]
   30d64:	f7f9 fa1c 	bl	2a1a0 <k_event_wait_internal>
}
   30d68:	b003      	add	sp, #12
   30d6a:	f85d fb04 	ldr.w	pc, [sp], #4
	uint32_t options = reset ? K_EVENT_WAIT_RESET : 0;
   30d6e:	2200      	movs	r2, #0
   30d70:	e7f4      	b.n	30d5c <z_impl_k_event_wait+0x8>

00030d72 <z_impl_k_event_wait_all>:
/**
 * Wait for all of the specified events
 */
uint32_t z_impl_k_event_wait_all(struct k_event *event, uint32_t events,
				 bool reset, k_timeout_t timeout)
{
   30d72:	b500      	push	{lr}
   30d74:	b083      	sub	sp, #12
	uint32_t options = reset ? (K_EVENT_WAIT_RESET | K_EVENT_WAIT_ALL)
				 : K_EVENT_WAIT_ALL;
   30d76:	b14a      	cbz	r2, 30d8c <z_impl_k_event_wait_all+0x1a>
   30d78:	2203      	movs	r2, #3

	return k_event_wait_internal(event, events, options, timeout);
   30d7a:	ed9d 7b04 	vldr	d7, [sp, #16]
   30d7e:	ed8d 7b00 	vstr	d7, [sp]
   30d82:	f7f9 fa0d 	bl	2a1a0 <k_event_wait_internal>
}
   30d86:	b003      	add	sp, #12
   30d88:	f85d fb04 	ldr.w	pc, [sp], #4
				 : K_EVENT_WAIT_ALL;
   30d8c:	2201      	movs	r2, #1
   30d8e:	e7f4      	b.n	30d7a <z_impl_k_event_wait_all+0x8>

00030d90 <k_free>:
	if (ptr != NULL) {
   30d90:	b130      	cbz	r0, 30da0 <k_free+0x10>
{
   30d92:	b508      	push	{r3, lr}
		k_heap_free(*heap_ref, ptr);
   30d94:	1f01      	subs	r1, r0, #4
   30d96:	f850 0c04 	ldr.w	r0, [r0, #-4]
   30d9a:	f7f5 fa47 	bl	2622c <k_heap_free>
}
   30d9e:	bd08      	pop	{r3, pc}
   30da0:	4770      	bx	lr

00030da2 <k_malloc>:
{
   30da2:	b508      	push	{r3, lr}
   30da4:	4601      	mov	r1, r0
	void *ret = k_aligned_alloc(sizeof(void *), size);
   30da6:	2004      	movs	r0, #4
   30da8:	f7f9 fac2 	bl	2a330 <k_aligned_alloc>
}
   30dac:	bd08      	pop	{r3, pc}

00030dae <k_calloc>:
{
   30dae:	b538      	push	{r3, r4, r5, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   30db0:	2300      	movs	r3, #0
   30db2:	fba0 4001 	umull	r4, r0, r0, r1
   30db6:	b958      	cbnz	r0, 30dd0 <k_calloc+0x22>
	if (size_mul_overflow(nmemb, size, &bounds)) {
   30db8:	b963      	cbnz	r3, 30dd4 <k_calloc+0x26>
	ret = k_malloc(bounds);
   30dba:	4620      	mov	r0, r4
   30dbc:	f7ff fff1 	bl	30da2 <k_malloc>
	if (ret != NULL) {
   30dc0:	4605      	mov	r5, r0
   30dc2:	b118      	cbz	r0, 30dcc <k_calloc+0x1e>
__ssp_bos_icheck3(memset, void *, int)
   30dc4:	4622      	mov	r2, r4
   30dc6:	2100      	movs	r1, #0
   30dc8:	f000 f86e 	bl	30ea8 <memset>
}
   30dcc:	4628      	mov	r0, r5
   30dce:	bd38      	pop	{r3, r4, r5, pc}
   30dd0:	2301      	movs	r3, #1
   30dd2:	e7f1      	b.n	30db8 <k_calloc+0xa>
		return NULL;
   30dd4:	2500      	movs	r5, #0
   30dd6:	e7f9      	b.n	30dcc <k_calloc+0x1e>

00030dd8 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   30dd8:	4770      	bx	lr

00030dda <cabsf>:
   30dda:	b508      	push	{r3, lr}
   30ddc:	ed2d 8b04 	vpush	{d8-d9}
   30de0:	eeb0 9a40 	vmov.f32	s18, s0
   30de4:	eef0 8a60 	vmov.f32	s17, s1
   30de8:	f000 f815 	bl	30e16 <crealf>
   30dec:	eef0 0a68 	vmov.f32	s1, s17
   30df0:	eeb0 8a40 	vmov.f32	s16, s0
   30df4:	eeb0 0a49 	vmov.f32	s0, s18
   30df8:	f000 f80a 	bl	30e10 <cimagf>
   30dfc:	eef0 0a40 	vmov.f32	s1, s0
   30e00:	eeb0 0a48 	vmov.f32	s0, s16
   30e04:	ecbd 8b04 	vpop	{d8-d9}
   30e08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   30e0c:	f7f9 bf48 	b.w	2aca0 <hypotf>

00030e10 <cimagf>:
   30e10:	eeb0 0a60 	vmov.f32	s0, s1
   30e14:	4770      	bx	lr

00030e16 <crealf>:
   30e16:	4770      	bx	lr

00030e18 <__ieee754_sqrtf>:
   30e18:	eeb1 0ac0 	vsqrt.f32	s0, s0
   30e1c:	4770      	bx	lr

00030e1e <fabsf>:
   30e1e:	ee10 3a10 	vmov	r3, s0
   30e22:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   30e26:	ee00 3a10 	vmov	s0, r3
   30e2a:	4770      	bx	lr

00030e2c <finitef>:
   30e2c:	b082      	sub	sp, #8
   30e2e:	ed8d 0a01 	vstr	s0, [sp, #4]
   30e32:	9801      	ldr	r0, [sp, #4]
   30e34:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   30e38:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
   30e3c:	bfac      	ite	ge
   30e3e:	2000      	movge	r0, #0
   30e40:	2001      	movlt	r0, #1
   30e42:	b002      	add	sp, #8
   30e44:	4770      	bx	lr

00030e46 <memcmp>:
   30e46:	b510      	push	{r4, lr}
   30e48:	3901      	subs	r1, #1
   30e4a:	4402      	add	r2, r0
   30e4c:	4290      	cmp	r0, r2
   30e4e:	d101      	bne.n	30e54 <memcmp+0xe>
   30e50:	2000      	movs	r0, #0
   30e52:	e005      	b.n	30e60 <memcmp+0x1a>
   30e54:	7803      	ldrb	r3, [r0, #0]
   30e56:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   30e5a:	42a3      	cmp	r3, r4
   30e5c:	d001      	beq.n	30e62 <memcmp+0x1c>
   30e5e:	1b18      	subs	r0, r3, r4
   30e60:	bd10      	pop	{r4, pc}
   30e62:	3001      	adds	r0, #1
   30e64:	e7f2      	b.n	30e4c <memcmp+0x6>

00030e66 <memcpy>:
   30e66:	440a      	add	r2, r1
   30e68:	4291      	cmp	r1, r2
   30e6a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   30e6e:	d100      	bne.n	30e72 <memcpy+0xc>
   30e70:	4770      	bx	lr
   30e72:	b510      	push	{r4, lr}
   30e74:	f811 4b01 	ldrb.w	r4, [r1], #1
   30e78:	f803 4f01 	strb.w	r4, [r3, #1]!
   30e7c:	4291      	cmp	r1, r2
   30e7e:	d1f9      	bne.n	30e74 <memcpy+0xe>
   30e80:	bd10      	pop	{r4, pc}

00030e82 <__memcpy_chk>:
   30e82:	429a      	cmp	r2, r3
   30e84:	b508      	push	{r3, lr}
   30e86:	d901      	bls.n	30e8c <__memcpy_chk+0xa>
   30e88:	f7e8 f8a2 	bl	18fd0 <__chk_fail>
   30e8c:	4281      	cmp	r1, r0
   30e8e:	d804      	bhi.n	30e9a <__memcpy_chk+0x18>
   30e90:	188b      	adds	r3, r1, r2
   30e92:	4298      	cmp	r0, r3
   30e94:	d3f8      	bcc.n	30e88 <__memcpy_chk+0x6>
   30e96:	4281      	cmp	r1, r0
   30e98:	d102      	bne.n	30ea0 <__memcpy_chk+0x1e>
   30e9a:	1883      	adds	r3, r0, r2
   30e9c:	4299      	cmp	r1, r3
   30e9e:	d3f3      	bcc.n	30e88 <__memcpy_chk+0x6>
   30ea0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   30ea4:	f7ff bfdf 	b.w	30e66 <memcpy>

00030ea8 <memset>:
   30ea8:	4402      	add	r2, r0
   30eaa:	4603      	mov	r3, r0
   30eac:	4293      	cmp	r3, r2
   30eae:	d100      	bne.n	30eb2 <memset+0xa>
   30eb0:	4770      	bx	lr
   30eb2:	f803 1b01 	strb.w	r1, [r3], #1
   30eb6:	e7f9      	b.n	30eac <memset+0x4>

00030eb8 <__strncpy_chk>:
   30eb8:	429a      	cmp	r2, r3
   30eba:	b508      	push	{r3, lr}
   30ebc:	d901      	bls.n	30ec2 <__strncpy_chk+0xa>
   30ebe:	f7e8 f887 	bl	18fd0 <__chk_fail>
   30ec2:	4281      	cmp	r1, r0
   30ec4:	d804      	bhi.n	30ed0 <__strncpy_chk+0x18>
   30ec6:	188b      	adds	r3, r1, r2
   30ec8:	4298      	cmp	r0, r3
   30eca:	d3f8      	bcc.n	30ebe <__strncpy_chk+0x6>
   30ecc:	4281      	cmp	r1, r0
   30ece:	d102      	bne.n	30ed6 <__strncpy_chk+0x1e>
   30ed0:	1883      	adds	r3, r0, r2
   30ed2:	4299      	cmp	r1, r3
   30ed4:	d3f3      	bcc.n	30ebe <__strncpy_chk+0x6>
   30ed6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   30eda:	f000 b80c 	b.w	30ef6 <strncpy>

00030ede <strnlen>:
   30ede:	b510      	push	{r4, lr}
   30ee0:	4602      	mov	r2, r0
   30ee2:	4401      	add	r1, r0
   30ee4:	428a      	cmp	r2, r1
   30ee6:	4613      	mov	r3, r2
   30ee8:	d003      	beq.n	30ef2 <strnlen+0x14>
   30eea:	781c      	ldrb	r4, [r3, #0]
   30eec:	3201      	adds	r2, #1
   30eee:	2c00      	cmp	r4, #0
   30ef0:	d1f8      	bne.n	30ee4 <strnlen+0x6>
   30ef2:	1a18      	subs	r0, r3, r0
   30ef4:	bd10      	pop	{r4, pc}

00030ef6 <strncpy>:
   30ef6:	b510      	push	{r4, lr}
   30ef8:	3901      	subs	r1, #1
   30efa:	4603      	mov	r3, r0
   30efc:	b132      	cbz	r2, 30f0c <strncpy+0x16>
   30efe:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   30f02:	f803 4b01 	strb.w	r4, [r3], #1
   30f06:	3a01      	subs	r2, #1
   30f08:	2c00      	cmp	r4, #0
   30f0a:	d1f7      	bne.n	30efc <strncpy+0x6>
   30f0c:	441a      	add	r2, r3
   30f0e:	2100      	movs	r1, #0
   30f10:	4293      	cmp	r3, r2
   30f12:	d100      	bne.n	30f16 <strncpy+0x20>
   30f14:	bd10      	pop	{r4, pc}
   30f16:	f803 1b01 	strb.w	r1, [r3], #1
   30f1a:	e7f9      	b.n	30f10 <strncpy+0x1a>
